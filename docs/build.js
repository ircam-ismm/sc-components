(function () {
  'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var _global = createCommonjsModule(function (module) {
    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
    : Function('return this')();
    if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var hasOwnProperty = {}.hasOwnProperty;

  var _has = function _has(it, key) {
    return hasOwnProperty.call(it, key);
  };

  var _fails = function _fails(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var _core = createCommonjsModule(function (module) {
    var core = module.exports = {
      version: '2.6.12'
    };
    if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });

  var _isObject = function _isObject(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function _anObject(it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var document$1 = _global.document; // typeof document.createElement is 'object' in old IE

  var is = _isObject(document$1) && _isObject(document$1.createElement);

  var _domCreate = function _domCreate(it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var _toPrimitive = function _toPrimitive(it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
    f: f
  };

  var _propertyDesc = function _propertyDesc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var id = 0;
  var px = Math.random();

  var _uid = function _uid(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var _library = false;

  var _shared = createCommonjsModule(function (module) {
    var SHARED = '__core-js_shared__';
    var store = _global[SHARED] || (_global[SHARED] = {});
    (module.exports = function (key, value) {
      return store[key] || (store[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: _core.version,
      mode:  'global',
      copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
    });
  });

  var _functionToString = _shared('native-function-to-string', Function.toString);

  var _redefine = createCommonjsModule(function (module) {
    var SRC = _uid('src');
    var TO_STRING = 'toString';
    var TPL = ('' + _functionToString).split(TO_STRING);

    _core.inspectSource = function (it) {
      return _functionToString.call(it);
    };

    (module.exports = function (O, key, val, safe) {
      var isFunction = typeof val == 'function';
      if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
      if (O[key] === val) return;
      if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

      if (O === _global) {
        O[key] = val;
      } else if (!safe) {
        delete O[key];
        _hide(O, key, val);
      } else if (O[key]) {
        O[key] = val;
      } else {
        _hide(O, key, val);
      } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

    })(Function.prototype, TO_STRING, function toString() {
      return typeof this == 'function' && this[SRC] || _functionToString.call(this);
    });
  });

  var _aFunction = function _aFunction(it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function _ctx(fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function
      /* ...args */
    () {
      return fn.apply(that, arguments);
    };
  };

  var PROTOTYPE = 'prototype';

  var $export = function $export(type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;

    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

      out = (own ? target : source)[key]; // bind timers to global for call from export context

      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

      if (target) _redefine(target, key, out, type & $export.U); // export

      if (exports[key] != out) _hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };

  _global.core = _core; // type bitmap

  $export.F = 1; // forced

  $export.G = 2; // global

  $export.S = 4; // static

  $export.P = 8; // proto

  $export.B = 16; // bind

  $export.W = 32; // wrap

  $export.U = 64; // safe

  $export.R = 128; // real proto method for `library`

  var _export = $export;

  var _meta = createCommonjsModule(function (module) {
    var META = _uid('meta');
    var setDesc = _objectDp.f;
    var id = 0;

    var isExtensible = Object.isExtensible || function () {
      return true;
    };

    var FREEZE = !_fails(function () {
      return isExtensible(Object.preventExtensions({}));
    });

    var setMeta = function setMeta(it) {
      setDesc(it, META, {
        value: {
          i: 'O' + ++id,
          // object ID
          w: {} // weak collections IDs

        }
      });
    };

    var fastKey = function fastKey(it, create) {
      // return primitive with prefix
      if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

      if (!_has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F'; // not necessary to add metadata

        if (!create) return 'E'; // add missing metadata

        setMeta(it); // return object ID
      }

      return it[META].i;
    };

    var getWeak = function getWeak(it, create) {
      if (!_has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true; // not necessary to add metadata

        if (!create) return false; // add missing metadata

        setMeta(it); // return hash weak collections IDs
      }

      return it[META].w;
    }; // add metadata on freeze-family methods calling


    var onFreeze = function onFreeze(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
      return it;
    };

    var meta = module.exports = {
      KEY: META,
      NEED: false,
      fastKey: fastKey,
      getWeak: getWeak,
      onFreeze: onFreeze
    };
  });

  var _wks = createCommonjsModule(function (module) {
    var store = _shared('wks');
    var Symbol = _global.Symbol;
    var USE_SYMBOL = typeof Symbol == 'function';

    var $exports = module.exports = function (name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
    };

    $exports.store = store;
  });

  var def = _objectDp.f;
  var TAG = _wks('toStringTag');

  var _setToStringTag = function _setToStringTag(it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  };

  var f$1 = _wks;
  var _wksExt = {
    f: f$1
  };

  var defineProperty = _objectDp.f;

  var _wksDefine = function _wksDefine(name) {
    var $Symbol = _core.Symbol || (_core.Symbol =  _global.Symbol || {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
      value: _wksExt.f(name)
    });
  };

  var toString = {}.toString;

  var _cof = function _cof(it) {
    return toString.call(it).slice(8, -1);
  };

  // eslint-disable-next-line no-prototype-builtins

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function _defined(it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _toIobject = function _toIobject(it) {
    return _iobject(_defined(it));
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;

  var _toInteger = function _toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var min = Math.min;

  var _toLength = function _toLength(it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;

  var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  // true  -> Array#includes

  var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if (IS_INCLUDES || index in O) {
          if (O[index] === el) return IS_INCLUDES || index || 0;
        }
      }
      return !IS_INCLUDES && -1;
    };
  };

  var shared = _shared('keys');

  var _sharedKey = function _sharedKey(key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function _objectKeysInternal(object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) {
      if (key != IE_PROTO) _has(O, key) && result.push(key);
    } // Don't enum bug & hidden keys


    while (names.length > i) {
      if (_has(O, key = names[i++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
    }

    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var f$2 = Object.getOwnPropertySymbols;
  var _objectGops = {
    f: f$2
  };

  var f$3 = {}.propertyIsEnumerable;
  var _objectPie = {
    f: f$3
  };

  var _enumKeys = function _enumKeys(it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;

    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;

      while (symbols.length > i) {
        if (isEnum.call(it, key = symbols[i++])) result.push(key);
      }
    }

    return result;
  };

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  var _toObject = function _toObject(it) {
    return Object(_defined(it));
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;

    while (length > i) {
      _objectDp.f(O, P = keys[i++], Properties[P]);
    }

    return O;
  };

  var document$2 = _global.document;

  var _html = document$2 && document$2.documentElement;

  var IE_PROTO$1 = _sharedKey('IE_PROTO');

  var Empty = function Empty() {
    /* empty */
  };

  var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

  var _createDict = function createDict() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);

    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    _createDict = iframeDocument.F;

    while (i--) {
      delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
    }

    return _createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO$1] = O;
    } else result = _createDict();

    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
    f: f$4
  };

  var gOPN = _objectGopn.f;
  var toString$1 = {}.toString;
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function getWindowNames(it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };

  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
  };

  var _objectGopnExt = {
    f: f$5
  };

  var gOPD = Object.getOwnPropertyDescriptor;
  var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) {
      /* empty */
    }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };
  var _objectGopd = {
    f: f$6
  };

  var META = _meta.KEY;
  var gOPD$1 = _objectGopd.f;
  var dP$1 = _objectDp.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON = _global.JSON;

  var _stringify = $JSON && $JSON.stringify;

  var PROTOTYPE$2 = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto = Object[PROTOTYPE$2];
  var USE_NATIVE = typeof $Symbol == 'function' && !!_objectGops.f;
  var QObject = _global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP$1({}, 'a', {
      get: function get() {
        return dP$1(this, 'a', {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD$1(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    dP$1(it, key, D);
    if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
  } : dP$1;

  var wrap = function wrap(tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);

    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);

    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, {
          enumerable: _propertyDesc(0, false)
        });
      }

      return setSymbolDesc(it, key, D);
    }

    return dP$1(it, key, D);
  };

  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;

    while (l > i) {
      $defineProperty(it, key = keys[i++], P[key]);
    }

    return it;
  };

  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };

  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;

    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    }

    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;

    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
    }

    return result;
  }; // 19.4.1.1 Symbol([description])


  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);

      var $set = function $set(value) {
        if (this === ObjectProto) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };

      if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, {
        configurable: true,
        set: $set
      });
      return wrap(tag);
    };

    _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
      return this._k;
    });
    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;

    if (_descriptors && !_library) {
      _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    _wksExt.f = function (name) {
      return wrap(_wks(name));
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE, {
    Symbol: $Symbol
  });

  for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
    _wks(es6Symbols[j++]);
  }

  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) {
    _wksDefine(wellKnownSymbols[k++]);
  }

  _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function _for(key) {
      return _has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

      for (var key in SymbolRegistry) {
        if (SymbolRegistry[key] === sym) return key;
      }
    },
    useSetter: function useSetter() {
      setter = true;
    },
    useSimple: function useSimple() {
      setter = false;
    }
  });
  _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443

  var FAILS_ON_PRIMITIVES = _fails(function () {
    _objectGops.f(1);
  });
  _export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return _objectGops.f(_toObject(it));
    }
  }); // 24.3.2 JSON.stringify(value [, replacer [, space]])

  $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
    var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols

    return _stringify([S]) != '[null]' || _stringify({
      a: S
    }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;

      while (arguments.length > i) {
        args.push(arguments[i++]);
      }

      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!_isArray(replacer)) replacer = function replacer(key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

  _setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

  _setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

  _setToStringTag(_global.JSON, 'JSON', true);

  _export(_export.S, 'Object', {
    create: _objectCreate
  });

  _export(_export.S + _export.F * !_descriptors, 'Object', {
    defineProperty: _objectDp.f
  });

  _export(_export.S + _export.F * !_descriptors, 'Object', {
    defineProperties: _objectDps
  });

  var _objectSap = function _objectSap(KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () {
      fn(1);
    }), 'Object', exp);
  };

  var $getOwnPropertyDescriptor$1 = _objectGopd.f;
  _objectSap('getOwnPropertyDescriptor', function () {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor$1(_toIobject(it), key);
    };
  });

  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto$1 = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];

    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }

    return O instanceof Object ? ObjectProto$1 : null;
  };

  _objectSap('getPrototypeOf', function () {
    return function getPrototypeOf(it) {
      return _objectGpo(_toObject(it));
    };
  });

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  _objectSap('getOwnPropertyNames', function () {
    return _objectGopnExt.f;
  });

  var meta = _meta.onFreeze;
  _objectSap('freeze', function ($freeze) {
    return function freeze(it) {
      return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
    };
  });

  var meta$1 = _meta.onFreeze;
  _objectSap('seal', function ($seal) {
    return function seal(it) {
      return $seal && _isObject(it) ? $seal(meta$1(it)) : it;
    };
  });

  var meta$2 = _meta.onFreeze;
  _objectSap('preventExtensions', function ($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && _isObject(it) ? $preventExtensions(meta$2(it)) : it;
    };
  });

  _objectSap('isFrozen', function ($isFrozen) {
    return function isFrozen(it) {
      return _isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });

  _objectSap('isSealed', function ($isSealed) {
    return function isSealed(it) {
      return _isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });

  _objectSap('isExtensible', function ($isExtensible) {
    return function isExtensible(it) {
      return _isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });

  var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {}; // eslint-disable-next-line no-undef

    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;

    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
      }
    }

    return T;
  } : $assign;

  _export(_export.S + _export.F, 'Object', {
    assign: _objectAssign
  });

  // 7.2.9 SameValue(x, y)
  var _sameValue = Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };

  _export(_export.S, 'Object', {
    is: _sameValue
  });

  /* eslint-disable no-proto */

  var check = function check(O, proto) {
    _anObject(O);
    if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };

  var _setProto = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }

      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };

  _export(_export.S, 'Object', {
    setPrototypeOf: _setProto.set
  });

  var TAG$1 = _wks('toStringTag'); // ES3 wrong here

  var ARG = _cof(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function tryGet(it, key) {
    try {
      return it[key];
    } catch (e) {
      /* empty */
    }
  };

  var _classof = function _classof(it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T // builtinTag case
    : ARG ? _cof(O) // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var test = {};
  test[_wks('toStringTag')] = 'z';

  if (test + '' != '[object z]') {
    _redefine(Object.prototype, 'toString', function toString() {
      return '[object ' + _classof(this) + ']';
    }, true);
  }

  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  var _invoke = function _invoke(fn, args, that) {
    var un = that === undefined;

    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);

      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);

      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }

    return fn.apply(that, args);
  };

  var arraySlice = [].slice;
  var factories = {};

  var construct = function construct(F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) {
        n[i] = 'a[' + i + ']';
      } // eslint-disable-next-line no-new-func


      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }

    return factories[len](F, args);
  };

  var _bind = Function.bind || function bind(that
  /* , ...args */
  ) {
    var fn = _aFunction(this);
    var partArgs = arraySlice.call(arguments, 1);

    var bound = function
      /* args... */
    bound() {
      var args = partArgs.concat(arraySlice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
    };

    if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
  };

  _export(_export.P, 'Function', {
    bind: _bind
  });

  var dP$2 = _objectDp.f;
  var FProto = Function.prototype;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME = 'name'; // 19.2.4.2 name

  NAME in FProto || _descriptors && dP$2(FProto, NAME, {
    configurable: true,
    get: function get() {
      try {
        return ('' + this).match(nameRE)[1];
      } catch (e) {
        return '';
      }
    }
  });

  var HAS_INSTANCE = _wks('hasInstance');
  var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

  if (!(HAS_INSTANCE in FunctionProto)) _objectDp.f(FunctionProto, HAS_INSTANCE, {
    value: function value(O) {
      if (typeof this != 'function' || !_isObject(O)) return false;
      if (!_isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

      while (O = _objectGpo(O)) {
        if (this.prototype === O) return true;
      }

      return false;
    }
  });

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');

  var exporter = function exporter(KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  }; // 1 -> String#trimLeft
  // 2 -> String#trimRight
  // 3 -> String#trim


  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };

  var _stringTrim = exporter;

  var $parseInt = _global.parseInt;
  var $trim = _stringTrim.trim;
  var hex = /^[-+]?0[xX]/;

  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
  } : $parseInt;

  _export(_export.G + _export.F * (parseInt != _parseInt), {
    parseInt: _parseInt
  });

  var $parseFloat = _global.parseFloat;
  var $trim$1 = _stringTrim.trim;

  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim$1(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  _export(_export.G + _export.F * (parseFloat != _parseFloat), {
    parseFloat: _parseFloat
  });

  var setPrototypeOf = _setProto.set;

  var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
    var S = target.constructor;
    var P;

    if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
      setPrototypeOf(that, P);
    }

    return that;
  };

  var gOPN$2 = _objectGopn.f;
  var gOPD$2 = _objectGopd.f;
  var dP$3 = _objectDp.f;
  var $trim$2 = _stringTrim.trim;
  var NUMBER = 'Number';
  var $Number = _global[NUMBER];
  var Base = $Number;
  var proto = $Number.prototype; // Opera ~12 has broken Object#toString

  var BROKEN_COF = _cof(_objectCreate(proto)) == NUMBER;
  var TRIM = ('trim' in String.prototype); // 7.1.3 ToNumber(argument)

  var toNumber = function toNumber(argument) {
    var it = _toPrimitive(argument, false);

    if (typeof it == 'string' && it.length > 2) {
      it = TRIM ? it.trim() : $trim$2(it, 3);
      var first = it.charCodeAt(0);
      var third, radix, maxCode;

      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66:
          case 98:
            radix = 2;
            maxCode = 49;
            break;
          // fast equal /^0b[01]+$/i

          case 79:
          case 111:
            radix = 8;
            maxCode = 55;
            break;
          // fast equal /^0o[0-7]+$/i

          default:
            return +it;
        }

        for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
          code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols

          if (code < 48 || code > maxCode) return NaN;
        }

        return parseInt(digits, radix);
      }
    }

    return +it;
  };

  if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
      var it = arguments.length < 1 ? 0 : value;
      var that = this;
      return that instanceof $Number // check on 1..constructor(foo) case
      && (BROKEN_COF ? _fails(function () {
        proto.valueOf.call(that);
      }) : _cof(that) != NUMBER) ? _inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
    };

    for (var keys = _descriptors ? gOPN$2(Base) : ( // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key; keys.length > j$1; j$1++) {
      if (_has(Base, key = keys[j$1]) && !_has($Number, key)) {
        dP$3($Number, key, gOPD$2(Base, key));
      }
    }

    $Number.prototype = proto;
    proto.constructor = $Number;
    _redefine(_global, NUMBER, $Number);
  }

  var _aNumberValue = function _aNumberValue(it, msg) {
    if (typeof it != 'number' && _cof(it) != 'Number') throw TypeError(msg);
    return +it;
  };

  var _stringRepeat = function repeat(count) {
    var str = String(_defined(this));
    var res = '';
    var n = _toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

    for (; n > 0; (n >>>= 1) && (str += str)) {
      if (n & 1) res += str;
    }

    return res;
  };

  var $toFixed = 1.0.toFixed;
  var floor$1 = Math.floor;
  var data = [0, 0, 0, 0, 0, 0];
  var ERROR = 'Number.toFixed: incorrect invocation!';
  var ZERO = '0';

  var multiply = function multiply(n, c) {
    var i = -1;
    var c2 = c;

    while (++i < 6) {
      c2 += n * data[i];
      data[i] = c2 % 1e7;
      c2 = floor$1(c2 / 1e7);
    }
  };

  var divide = function divide(n) {
    var i = 6;
    var c = 0;

    while (--i >= 0) {
      c += data[i];
      data[i] = floor$1(c / n);
      c = c % n * 1e7;
    }
  };

  var numToString = function numToString() {
    var i = 6;
    var s = '';

    while (--i >= 0) {
      if (s !== '' || i === 0 || data[i] !== 0) {
        var t = String(data[i]);
        s = s === '' ? t : s + _stringRepeat.call(ZERO, 7 - t.length) + t;
      }
    }

    return s;
  };

  var pow = function pow(x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
  };

  var log = function log(x) {
    var n = 0;
    var x2 = x;

    while (x2 >= 4096) {
      n += 12;
      x2 /= 4096;
    }

    while (x2 >= 2) {
      n += 1;
      x2 /= 2;
    }

    return n;
  };

  _export(_export.P + _export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !_fails(function () {
    // V8 ~ Android 4.3-
    $toFixed.call({});
  })), 'Number', {
    toFixed: function toFixed(fractionDigits) {
      var x = _aNumberValue(this, ERROR);
      var f = _toInteger(fractionDigits);
      var s = '';
      var m = ZERO;
      var e, z, j, k;
      if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

      if (x != x) return 'NaN';
      if (x <= -1e21 || x >= 1e21) return String(x);

      if (x < 0) {
        s = '-';
        x = -x;
      }

      if (x > 1e-21) {
        e = log(x * pow(2, 69, 1)) - 69;
        z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
        z *= 0x10000000000000;
        e = 52 - e;

        if (e > 0) {
          multiply(0, z);
          j = f;

          while (j >= 7) {
            multiply(1e7, 0);
            j -= 7;
          }

          multiply(pow(10, j, 1), 0);
          j = e - 1;

          while (j >= 23) {
            divide(1 << 23);
            j -= 23;
          }

          divide(1 << j);
          multiply(1, 1);
          divide(2);
          m = numToString();
        } else {
          multiply(0, z);
          multiply(1 << -e, 0);
          m = numToString() + _stringRepeat.call(ZERO, f);
        }
      }

      if (f > 0) {
        k = m.length;
        m = s + (k <= f ? '0.' + _stringRepeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
      } else {
        m = s + m;
      }

      return m;
    }
  });

  var $toPrecision = 1.0.toPrecision;
  _export(_export.P + _export.F * (_fails(function () {
    // IE7-
    return $toPrecision.call(1, undefined) !== '1';
  }) || !_fails(function () {
    // V8 ~ Android 4.3-
    $toPrecision.call({});
  })), 'Number', {
    toPrecision: function toPrecision(precision) {
      var that = _aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
      return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
    }
  });

  _export(_export.S, 'Number', {
    EPSILON: Math.pow(2, -52)
  });

  var _isFinite = _global.isFinite;
  _export(_export.S, 'Number', {
    isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }
  });

  var floor$2 = Math.floor;

  var _isInteger = function isInteger(it) {
    return !_isObject(it) && isFinite(it) && floor$2(it) === it;
  };

  _export(_export.S, 'Number', {
    isInteger: _isInteger
  });

  _export(_export.S, 'Number', {
    isNaN: function isNaN(number) {
      // eslint-disable-next-line no-self-compare
      return number != number;
    }
  });

  var abs = Math.abs;
  _export(_export.S, 'Number', {
    isSafeInteger: function isSafeInteger(number) {
      return _isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }
  });

  _export(_export.S, 'Number', {
    MAX_SAFE_INTEGER: 0x1fffffffffffff
  });

  _export(_export.S, 'Number', {
    MIN_SAFE_INTEGER: -0x1fffffffffffff
  });

  _export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', {
    parseFloat: _parseFloat
  });

  _export(_export.S + _export.F * (Number.parseInt != _parseInt), 'Number', {
    parseInt: _parseInt
  });

  // 20.2.2.20 Math.log1p(x)
  var _mathLog1p = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };

  var sqrt = Math.sqrt;
  var $acosh = Math.acosh;
  _export(_export.S + _export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity), 'Math', {
    acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : _mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }
  });

  var $asinh = Math.asinh;

  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  } // Tor Browser bug: Math.asinh(0) -> -0


  _export(_export.S + _export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
    asinh: asinh
  });

  var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

  _export(_export.S + _export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
    atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }
  });

  // 20.2.2.28 Math.sign(x)
  var _mathSign = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };

  _export(_export.S, 'Math', {
    cbrt: function cbrt(x) {
      return _mathSign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }
  });

  _export(_export.S, 'Math', {
    clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }
  });

  var exp = Math.exp;
  _export(_export.S, 'Math', {
    cosh: function cosh(x) {
      return (exp(x = +x) + exp(-x)) / 2;
    }
  });

  // 20.2.2.14 Math.expm1(x)
  var $expm1 = Math.expm1;

  var _mathExpm1 = !$expm1 // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
  || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  } : $expm1;

  _export(_export.S + _export.F * (_mathExpm1 != Math.expm1), 'Math', {
    expm1: _mathExpm1
  });

  var pow$1 = Math.pow;
  var EPSILON = pow$1(2, -52);
  var EPSILON32 = pow$1(2, -23);
  var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
  var MIN32 = pow$1(2, -126);

  var roundTiesToEven = function roundTiesToEven(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };

  var _mathFround = Math.fround || function fround(x) {
    var $abs = Math.abs(x);
    var $sign = _mathSign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs); // eslint-disable-next-line no-self-compare

    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
  };

  _export(_export.S, 'Math', {
    fround: _mathFround
  });

  var abs$1 = Math.abs;
  _export(_export.S, 'Math', {
    hypot: function hypot(value1, value2) {
      // eslint-disable-line no-unused-vars
      var sum = 0;
      var i = 0;
      var aLen = arguments.length;
      var larg = 0;
      var arg, div;

      while (i < aLen) {
        arg = abs$1(arguments[i++]);

        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else sum += arg;
      }

      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }
  });

  var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

  _export(_export.S + _export.F * _fails(function () {
    return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
  }), 'Math', {
    imul: function imul(x, y) {
      var UINT16 = 0xffff;
      var xn = +x;
      var yn = +y;
      var xl = UINT16 & xn;
      var yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
  });

  _export(_export.S, 'Math', {
    log10: function log10(x) {
      return Math.log(x) * Math.LOG10E;
    }
  });

  _export(_export.S, 'Math', {
    log1p: _mathLog1p
  });

  _export(_export.S, 'Math', {
    log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }
  });

  _export(_export.S, 'Math', {
    sign: _mathSign
  });

  var exp$1 = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

  _export(_export.S + _export.F * _fails(function () {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {
    sinh: function sinh(x) {
      return Math.abs(x = +x) < 1 ? (_mathExpm1(x) - _mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
    }
  });

  var exp$2 = Math.exp;
  _export(_export.S, 'Math', {
    tanh: function tanh(x) {
      var a = _mathExpm1(x = +x);
      var b = _mathExpm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
    }
  });

  _export(_export.S, 'Math', {
    trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }
  });

  var fromCharCode = String.fromCharCode;
  var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

  _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function fromCodePoint(x) {
      // eslint-disable-line no-unused-vars
      var res = [];
      var aLen = arguments.length;
      var i = 0;
      var code;

      while (aLen > i) {
        code = +arguments[i++];
        if (_toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }

      return res.join('');
    }
  });

  _export(_export.S, 'String', {
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function raw(callSite) {
      var tpl = _toIobject(callSite.raw);
      var len = _toLength(tpl.length);
      var aLen = arguments.length;
      var res = [];
      var i = 0;

      while (len > i) {
        res.push(String(tpl[i++]));
        if (i < aLen) res.push(String(arguments[i]));
      }

      return res.join('');
    }
  });

  _stringTrim('trim', function ($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });

  // false -> String#codePointAt

  var _stringAt = function _stringAt(TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var _iterators = {};

  var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

  _hide(IteratorPrototype, _wks('iterator'), function () {
    return this;
  });

  var _iterCreate = function _iterCreate(Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, {
      next: _propertyDesc(1, next)
    });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function returnThis() {
    return this;
  };

  var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);

    var getMethod = function getMethod(kind) {
      if (!BUGGY && kind in proto) return proto[kind];

      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };

        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }

      return function entries() {
        return new Constructor(this, kind);
      };
    };

    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype; // Fix native

    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));

      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

        if ( typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
      }
    } // fix Array#{values, @@iterator}.name in V8 / FF


    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;

      $default = function values() {
        return $native.call(this);
      };
    } // Define iterator


    if ( (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    } // Plug for library


    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;

    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }

    return methods;
  };

  var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()

  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated); // target

    this._i = 0; // next index
    // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });

  var $at$1 = _stringAt(false);
  _export(_export.P, 'String', {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: function codePointAt(pos) {
      return $at$1(this, pos);
    }
  });

  var MATCH = _wks('match');

  var _isRegexp = function _isRegexp(it) {
    var isRegExp;
    return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
  };

  var _stringContext = function _stringContext(that, searchString, NAME) {
    if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(_defined(that));
  };

  var MATCH$1 = _wks('match');

  var _failsIsRegexp = function _failsIsRegexp(KEY) {
    var re = /./;

    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH$1] = false;
        return !'/./'[KEY](re);
      } catch (f) {
        /* empty */
      }
    }

    return true;
  };

  var ENDS_WITH = 'endsWith';
  var $endsWith = ''[ENDS_WITH];
  _export(_export.P + _export.F * _failsIsRegexp(ENDS_WITH), 'String', {
    endsWith: function endsWith(searchString
    /* , endPosition = @length */
    ) {
      var that = _stringContext(this, searchString, ENDS_WITH);
      var endPosition = arguments.length > 1 ? arguments[1] : undefined;
      var len = _toLength(that.length);
      var end = endPosition === undefined ? len : Math.min(_toLength(endPosition), len);
      var search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }
  });

  var INCLUDES = 'includes';
  _export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
    includes: function includes(searchString
    /* , position = 0 */
    ) {
      return !!~_stringContext(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  _export(_export.P, 'String', {
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: _stringRepeat
  });

  var STARTS_WITH = 'startsWith';
  var $startsWith = ''[STARTS_WITH];
  _export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
    startsWith: function startsWith(searchString
    /* , position = 0 */
    ) {
      var that = _stringContext(this, searchString, STARTS_WITH);
      var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
  });

  var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

  var createHTML = function createHTML(string, tag, attribute, value) {
    var S = String(_defined(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
  };

  var _stringHtml = function _stringHtml(NAME, exec) {
    var O = {};
    O[NAME] = exec(createHTML);
    _export(_export.P + _export.F * _fails(function () {
      var test = ''[NAME]('"');
      return test !== test.toLowerCase() || test.split('"').length > 3;
    }), 'String', O);
  };

  _stringHtml('anchor', function (createHTML) {
    return function anchor(name) {
      return createHTML(this, 'a', 'name', name);
    };
  });

  _stringHtml('big', function (createHTML) {
    return function big() {
      return createHTML(this, 'big', '', '');
    };
  });

  _stringHtml('blink', function (createHTML) {
    return function blink() {
      return createHTML(this, 'blink', '', '');
    };
  });

  _stringHtml('bold', function (createHTML) {
    return function bold() {
      return createHTML(this, 'b', '', '');
    };
  });

  _stringHtml('fixed', function (createHTML) {
    return function fixed() {
      return createHTML(this, 'tt', '', '');
    };
  });

  _stringHtml('fontcolor', function (createHTML) {
    return function fontcolor(color) {
      return createHTML(this, 'font', 'color', color);
    };
  });

  _stringHtml('fontsize', function (createHTML) {
    return function fontsize(size) {
      return createHTML(this, 'font', 'size', size);
    };
  });

  _stringHtml('italics', function (createHTML) {
    return function italics() {
      return createHTML(this, 'i', '', '');
    };
  });

  _stringHtml('link', function (createHTML) {
    return function link(url) {
      return createHTML(this, 'a', 'href', url);
    };
  });

  _stringHtml('small', function (createHTML) {
    return function small() {
      return createHTML(this, 'small', '', '');
    };
  });

  _stringHtml('strike', function (createHTML) {
    return function strike() {
      return createHTML(this, 'strike', '', '');
    };
  });

  _stringHtml('sub', function (createHTML) {
    return function sub() {
      return createHTML(this, 'sub', '', '');
    };
  });

  _stringHtml('sup', function (createHTML) {
    return function sup() {
      return createHTML(this, 'sup', '', '');
    };
  });

  _export(_export.S, 'Date', {
    now: function now() {
      return new Date().getTime();
    }
  });

  _export(_export.P + _export.F * _fails(function () {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
      toISOString: function toISOString() {
        return 1;
      }
    }) !== 1;
  }), 'Date', {
    // eslint-disable-next-line no-unused-vars
    toJSON: function toJSON(key) {
      var O = _toObject(this);
      var pv = _toPrimitive(O);
      return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
  });

  var getTime = Date.prototype.getTime;
  var $toISOString = Date.prototype.toISOString;

  var lz = function lz(num) {
    return num > 9 ? num : '0' + num;
  }; // PhantomJS / old WebKit has a broken implementations


  var _dateToIsoString = _fails(function () {
    return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
  }) || !_fails(function () {
    $toISOString.call(new Date(NaN));
  }) ? function toISOString() {
    if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
    var d = this;
    var y = d.getUTCFullYear();
    var m = d.getUTCMilliseconds();
    var s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  } : $toISOString;

  // PhantomJS / old WebKit has a broken implementations

  _export(_export.P + _export.F * (Date.prototype.toISOString !== _dateToIsoString), 'Date', {
    toISOString: _dateToIsoString
  });

  var DateProto = Date.prototype;
  var INVALID_DATE = 'Invalid Date';
  var TO_STRING = 'toString';
  var $toString = DateProto[TO_STRING];
  var getTime$1 = DateProto.getTime;

  if (new Date(NaN) + '' != INVALID_DATE) {
    _redefine(DateProto, TO_STRING, function toString() {
      var value = getTime$1.call(this); // eslint-disable-next-line no-self-compare

      return value === value ? $toString.call(this) : INVALID_DATE;
    });
  }

  var NUMBER$1 = 'number';

  var _dateToPrimitive = function _dateToPrimitive(hint) {
    if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
    return _toPrimitive(_anObject(this), hint != NUMBER$1);
  };

  var TO_PRIMITIVE$1 = _wks('toPrimitive');
  var proto$1 = Date.prototype;
  if (!(TO_PRIMITIVE$1 in proto$1)) _hide(proto$1, TO_PRIMITIVE$1, _dateToPrimitive);

  _export(_export.S, 'Array', {
    isArray: _isArray
  });

  var _iterCall = function _iterCall(iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function _isArrayIter(it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function _createProperty(object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
  };

  var ITERATOR$2 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR$3]();

    riter['return'] = function () {
      SAFE_CLOSING = true;
    }; // eslint-disable-next-line no-throw-literal


    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {
    /* empty */
  }

  var _iterDetect = function _iterDetect(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;

    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();

      iter.next = function () {
        return {
          done: safe = true
        };
      };

      arr[ITERATOR$3] = function () {
        return iter;
      };

      exec(arr);
    } catch (e) {
      /* empty */
    }

    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) {
    Array.from(iter);
  }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike
    /* , mapfn = undefined, thisArg = undefined */
    ) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);

        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }

      result.length = index;
      return result;
    }
  });

  _export(_export.S + _export.F * _fails(function () {
    function F() {
      /* empty */
    }

    return !(Array.of.call(F) instanceof F);
  }), 'Array', {
    // 22.1.2.3 Array.of( ...items)
    of: function
      /* ...args */
    of() {
      var index = 0;
      var aLen = arguments.length;
      var result = new (typeof this == 'function' ? this : Array)(aLen);

      while (aLen > index) {
        _createProperty(result, index, arguments[index++]);
      }

      result.length = aLen;
      return result;
    }
  });

  var _strictMethod = function _strictMethod(method, arg) {
    return !!method && _fails(function () {
      // eslint-disable-next-line no-useless-call
      arg ? method.call(null, function () {
        /* empty */
      }, 1) : method.call(null);
    });
  };

  var arrayJoin = [].join; // fallback for not array-like strings

  _export(_export.P + _export.F * (_iobject != Object || !_strictMethod(arrayJoin)), 'Array', {
    join: function join(separator) {
      return arrayJoin.call(_toIobject(this), separator === undefined ? ',' : separator);
    }
  });

  var arraySlice$1 = [].slice; // fallback for not array-like ES3 strings and DOM objects

  _export(_export.P + _export.F * _fails(function () {
    if (_html) arraySlice$1.call(_html);
  }), 'Array', {
    slice: function slice(begin, end) {
      var len = _toLength(this.length);
      var klass = _cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array') return arraySlice$1.call(this, begin, end);
      var start = _toAbsoluteIndex(begin, len);
      var upTo = _toAbsoluteIndex(end, len);
      var size = _toLength(upTo - start);
      var cloned = new Array(size);
      var i = 0;

      for (; i < size; i++) {
        cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      }

      return cloned;
    }
  });

  var $sort = [].sort;
  var test$1 = [1, 2, 3];
  _export(_export.P + _export.F * (_fails(function () {
    // IE8-
    test$1.sort(undefined);
  }) || !_fails(function () {
    // V8 bug
    test$1.sort(null); // Old WebKit
  }) || !_strictMethod($sort)), 'Array', {
    // 22.1.3.25 Array.prototype.sort(comparefn)
    sort: function sort(comparefn) {
      return comparefn === undefined ? $sort.call(_toObject(this)) : $sort.call(_toObject(this), _aFunction(comparefn));
    }
  });

  var SPECIES = _wks('species');

  var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
    var C;

    if (_isArray(original)) {
      C = original.constructor; // cross-realm fallback

      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;

      if (_isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }

    return C === undefined ? Array : C;
  };

  var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex

  var _arrayMethods = function _arrayMethods(TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;

      for (; length > index; index++) {
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);

          if (TYPE) {
            if (IS_MAP) result[index] = res; // map
            else if (res) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return val;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                result.push(val);
              // filter
            } else if (IS_EVERY) return false; // every
          }
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var $forEach = _arrayMethods(0);
  var STRICT = _strictMethod([].forEach, true);
  _export(_export.P + _export.F * !STRICT, 'Array', {
    // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      return $forEach(this, callbackfn, arguments[1]);
    }
  });

  var $map = _arrayMethods(1);
  _export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
    // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
    map: function map(callbackfn
    /* , thisArg */
    ) {
      return $map(this, callbackfn, arguments[1]);
    }
  });

  var $filter = _arrayMethods(2);
  _export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
    // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return $filter(this, callbackfn, arguments[1]);
    }
  });

  var $some = _arrayMethods(3);
  _export(_export.P + _export.F * !_strictMethod([].some, true), 'Array', {
    // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return $some(this, callbackfn, arguments[1]);
    }
  });

  var $every = _arrayMethods(4);
  _export(_export.P + _export.F * !_strictMethod([].every, true), 'Array', {
    // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return $every(this, callbackfn, arguments[1]);
    }
  });

  var _arrayReduce = function _arrayReduce(that, callbackfn, aLen, memo, isRight) {
    _aFunction(callbackfn);
    var O = _toObject(that);
    var self = _iobject(O);
    var length = _toLength(O.length);
    var index = isRight ? length - 1 : 0;
    var i = isRight ? -1 : 1;
    if (aLen < 2) for (;;) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (isRight ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; isRight ? index >= 0 : length > index; index += i) {
      if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
    }

    return memo;
  };

  _export(_export.P + _export.F * !_strictMethod([].reduce, true), 'Array', {
    // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      return _arrayReduce(this, callbackfn, arguments.length, arguments[1], false);
    }
  });

  _export(_export.P + _export.F * !_strictMethod([].reduceRight, true), 'Array', {
    // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      return _arrayReduce(this, callbackfn, arguments.length, arguments[1], true);
    }
  });

  var $indexOf = _arrayIncludes(false);
  var $native = [].indexOf;
  var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
  _export(_export.P + _export.F * (NEGATIVE_ZERO || !_strictMethod($native)), 'Array', {
    // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
    indexOf: function indexOf(searchElement
    /* , fromIndex = 0 */
    ) {
      return NEGATIVE_ZERO // convert -0 to +0
      ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
    }
  });

  var $native$1 = [].lastIndexOf;
  var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;
  _export(_export.P + _export.F * (NEGATIVE_ZERO$1 || !_strictMethod($native$1)), 'Array', {
    // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex = @[*-1] */
    ) {
      // convert -0 to +0
      if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
      var O = _toIobject(this);
      var length = _toLength(O.length);
      var index = length - 1;
      if (arguments.length > 1) index = Math.min(index, _toInteger(arguments[1]));
      if (index < 0) index = length + index;

      for (; index >= 0; index--) {
        if (index in O) if (O[index] === searchElement) return index || 0;
      }

      return -1;
    }
  });

  var _arrayCopyWithin = [].copyWithin || function copyWithin(target
  /* = 0 */
  , start
  /* = 0, end = @length */
  ) {
    var O = _toObject(this);
    var len = _toLength(O.length);
    var to = _toAbsoluteIndex(target, len);
    var from = _toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;

    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }

    while (count-- > 0) {
      if (from in O) O[to] = O[from];else delete O[to];
      to += inc;
      from += inc;
    }

    return O;
  };

  var UNSCOPABLES = _wks('unscopables');
  var ArrayProto$1 = Array.prototype;
  if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});

  var _addToUnscopables = function _addToUnscopables(key) {
    ArrayProto$1[UNSCOPABLES][key] = true;
  };

  _export(_export.P, 'Array', {
    copyWithin: _arrayCopyWithin
  });
  _addToUnscopables('copyWithin');

  var _arrayFill = function fill(value
  /* , start = 0, end = @length */
  ) {
    var O = _toObject(this);
    var length = _toLength(O.length);
    var aLen = arguments.length;
    var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
    var end = aLen > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);

    while (endPos > index) {
      O[index++] = value;
    }

    return O;
  };

  _export(_export.P, 'Array', {
    fill: _arrayFill
  });
  _addToUnscopables('fill');

  var $find = _arrayMethods(5);
  var KEY = 'find';
  var forced = true; // Shouldn't skip holes

  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  _export(_export.P + _export.F * forced, 'Array', {
    find: function find(callbackfn
    /* , that = undefined */
    ) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  _addToUnscopables(KEY);

  var $find$1 = _arrayMethods(6);
  var KEY$1 = 'findIndex';
  var forced$1 = true; // Shouldn't skip holes

  if (KEY$1 in []) Array(1)[KEY$1](function () {
    forced$1 = false;
  });
  _export(_export.P + _export.F * forced$1, 'Array', {
    findIndex: function findIndex(callbackfn
    /* , that = undefined */
    ) {
      return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  _addToUnscopables(KEY$1);

  var SPECIES$1 = _wks('species');

  var _setSpecies = function _setSpecies(KEY) {
    var C = _global[KEY];
    if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
      configurable: true,
      get: function get() {
        return this;
      }
    });
  };

  _setSpecies('Array');

  var _iterStep = function _iterStep(done, value) {
    return {
      value: value,
      done: !!done
    };
  };

  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()


  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target

    this._i = 0; // next index

    this._k = kind; // kind
    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;

    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }

    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

  _iterators.Arguments = _iterators.Array;
  _addToUnscopables('keys');
  _addToUnscopables('values');
  _addToUnscopables('entries');

  var _flags = function _flags() {
    var that = _anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  var dP$4 = _objectDp.f;
  var gOPN$3 = _objectGopn.f;
  var $RegExp = _global.RegExp;
  var Base$1 = $RegExp;
  var proto$2 = $RegExp.prototype;
  var re1 = /a/g;
  var re2 = /a/g; // "new" creates a new object, old webkit buggy here

  var CORRECT_NEW = new $RegExp(re1) !== re1;

  if (_descriptors && (!CORRECT_NEW || _fails(function () {
    re2[_wks('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var tiRE = this instanceof $RegExp;
      var piRE = _isRegexp(p);
      var fiU = f === undefined;
      return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : _inheritIfRequired(CORRECT_NEW ? new Base$1(piRE && !fiU ? p.source : p, f) : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f), tiRE ? this : proto$2, $RegExp);
    };

    var proxy = function proxy(key) {
      key in $RegExp || dP$4($RegExp, key, {
        configurable: true,
        get: function get() {
          return Base$1[key];
        },
        set: function set(it) {
          Base$1[key] = it;
        }
      });
    };

    for (var keys$1 = gOPN$3(Base$1), i = 0; keys$1.length > i;) {
      proxy(keys$1[i++]);
    }

    proto$2.constructor = $RegExp;
    $RegExp.prototype = proto$2;
    _redefine(_global, 'RegExp', $RegExp);
  }

  _setSpecies('RegExp');

  var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.

  var nativeReplace = String.prototype.replace;
  var patchedExec = nativeExec;
  var LAST_INDEX = 'lastIndex';

  var UPDATES_LAST_INDEX_WRONG = function () {
    var re1 = /a/,
        re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
  }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
      }

      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
      match = nativeExec.call(re, str);

      if (UPDATES_LAST_INDEX_WRONG && match) {
        re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
      }

      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        // eslint-disable-next-line no-loop-func
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  var _regexpExec = patchedExec;

  _export({
    target: 'RegExp',
    proto: true,
    forced: _regexpExec !== /./.exec
  }, {
    exec: _regexpExec
  });

  if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: _flags
  });

  var TO_STRING$1 = 'toString';
  var $toString$1 = /./[TO_STRING$1];

  var define = function define(fn) {
    _redefine(RegExp.prototype, TO_STRING$1, fn, true);
  }; // 21.2.5.14 RegExp.prototype.toString()


  if (_fails(function () {
    return $toString$1.call({
      source: 'a',
      flags: 'b'
    }) != '/a/b';
  })) {
    define(function toString() {
      var R = _anObject(this);
      return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
    }); // FF44- RegExp#toString has a wrong name
  } else if ($toString$1.name != TO_STRING$1) {
    define(function toString() {
      return $toString$1.call(this);
    });
  }

  var at = _stringAt(true); // `AdvanceStringIndex` abstract operation
  // https://tc39.github.io/ecma262/#sec-advancestringindex

  var _advanceStringIndex = function _advanceStringIndex(S, index, unicode) {
    return index + (unicode ? at(S, index).length : 1);
  };

  var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
  // https://tc39.github.io/ecma262/#sec-regexpexec

  var _regexpExecAbstract = function _regexpExecAbstract(R, S) {
    var exec = R.exec;

    if (typeof exec === 'function') {
      var result = exec.call(R, S);

      if (typeof result !== 'object') {
        throw new TypeError('RegExp exec method returned something other than an Object or null');
      }

      return result;
    }

    if (_classof(R) !== 'RegExp') {
      throw new TypeError('RegExp#exec called on incompatible receiver');
    }

    return builtinExec.call(R, S);
  };

  var SPECIES$2 = _wks('species');
  var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;

    re.exec = function () {
      var result = [];
      result.groups = {
        a: '7'
      };
      return result;
    };

    return ''.replace(re, '$<a>') !== '7';
  });

  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
    // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    var re = /(?:)/;
    var originalExec = re.exec;

    re.exec = function () {
      return originalExec.apply(this, arguments);
    };

    var result = 'ab'.split(re);
    return result.length === 2 && result[0] === 'a' && result[1] === 'b';
  }();

  var _fixReWks = function _fixReWks(KEY, length, exec) {
    var SYMBOL = _wks(KEY);
    var DELEGATES_TO_SYMBOL = !_fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};

      O[SYMBOL] = function () {
        return 7;
      };

      return ''[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      re.exec = function () {
        execCalled = true;
        return null;
      };

      if (KEY === 'split') {
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};

        re.constructor[SPECIES$2] = function () {
          return re;
        };
      }

      re[SYMBOL]('');
      return !execCalled;
    }) : undefined;

    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
      var nativeRegExpMethod = /./[SYMBOL];
      var fns = exec(_defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === _regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return {
              done: true,
              value: nativeRegExpMethod.call(regexp, str, arg2)
            };
          }

          return {
            done: true,
            value: nativeMethod.call(str, regexp, arg2)
          };
        }

        return {
          done: false
        };
      });
      var strfn = fns[0];
      var rxfn = fns[1];
      _redefine(String.prototype, KEY, strfn);
      _hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) {
        return rxfn.call(string, this, arg);
      } // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) {
        return rxfn.call(string, this);
      });
    }
  };

  _fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
    return [// `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    }, // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      if (!rx.global) return _regexpExecAbstract(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;

      while ((result = _regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
        n++;
      }

      return n === 0 ? null : A;
    }];
  });

  var max$1 = Math.max;
  var min$2 = Math.min;
  var floor$3 = Math.floor;
  var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

  var maybeToString = function maybeToString(it) {
    return it === undefined ? it : String(it);
  }; // @@replace logic


  _fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
    return [// `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    }, // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;

      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }

      var results = [];

      while (true) {
        var result = _regexpExecAbstract(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;

      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max$1(min$2(_toInteger(result.index), S.length), 0);
        var captures = []; // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

        for (var j = 1; j < result.length; j++) {
          captures.push(maybeToString(result[j]));
        }

        var namedCaptures = result.groups;

        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }

        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }

      return accumulatedResult + S.slice(nextSourcePosition);
    }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

      if (namedCaptures !== undefined) {
        namedCaptures = _toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }

      return $replace.call(replacement, symbols, function (match, ch) {
        var capture;

        switch (ch.charAt(0)) {
          case '$':
            return '$';

          case '&':
            return matched;

          case '`':
            return str.slice(0, position);

          case "'":
            return str.slice(tailPos);

          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;

          default:
            // \d\d?
            var n = +ch;
            if (n === 0) return match;

            if (n > m) {
              var f = floor$3(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }

            capture = captures[n - 1];
        }

        return capture === undefined ? '' : capture;
      });
    }
  });

  _fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
    return [// `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    }, // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = _regexpExecAbstract(rx, S);
      if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }];
  });

  var SPECIES$3 = _wks('species');

  var _speciesConstructor = function _speciesConstructor(O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES$3]) == undefined ? D : _aFunction(S);
  };

  var $min = Math.min;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX$1 = 'lastIndex';
  var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

  var SUPPORTS_Y = !_fails(function () {
    RegExp(MAX_UINT32, 'y');
  }); // @@split logic

  _fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
    var internalSplit;

    if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function internalSplit(separator, limit) {
        var string = String(this);
        if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

        if (!_isRegexp(separator)) return $split.call(string, separator, limit);
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;

        while (match = _regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy[LAST_INDEX$1];

          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
            lastLength = match[0][LENGTH];
            lastLastIndex = lastIndex;
            if (output[LENGTH] >= splitLimit) break;
          }

          if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
        }

        if (lastLastIndex === string[LENGTH]) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));

        return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
      }; // Chakra, V8

    } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
      internalSplit = function internalSplit(separator, limit) {
        return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
      };
    } else {
      internalSplit = $split;
    }

    return [// `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
    }, // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      var C = _speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.

      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];

      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;

        if (z === null || (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
          q = _advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;

          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }

          q = p = e;
        }
      }

      A.push(S.slice(p));
      return A;
    }];
  });

  var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
      throw TypeError(name + ': incorrect invocation!');
    }

    return it;
  };

  var _forOf = createCommonjsModule(function (module) {
    var BREAK = {};
    var RETURN = {};

    var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR ? function () {
        return iterable;
      } : core_getIteratorMethod(iterable);
      var f = _ctx(fn, that, entries ? 2 : 1);
      var index = 0;
      var length, step, iterator, result;
      if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

      if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
        result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
        if (result === BREAK || result === RETURN) return result;
      } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
        result = _iterCall(iterator, f, step.value, entries);
        if (result === BREAK || result === RETURN) return result;
      }
    };

    exports.BREAK = BREAK;
    exports.RETURN = RETURN;
  });

  var process = _global.process;
  var setTask = _global.setImmediate;
  var clearTask = _global.clearImmediate;
  var MessageChannel = _global.MessageChannel;
  var Dispatch = _global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function run() {
    var id = +this; // eslint-disable-next-line no-prototype-builtins

    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var listener = function listener(event) {
    run.call(event.data);
  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;

      while (arguments.length > i) {
        args.push(arguments[i++]);
      }

      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        _invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };

      defer(counter);
      return counter;
    };

    clearTask = function clearImmediate(id) {
      delete queue[id];
    }; // Node.js 0.8-


    if (_cof(process) == 'process') {
      defer = function defer(id) {
        process.nextTick(_ctx(run, id, 1));
      }; // Sphere (JS game engine) Dispatch API

    } else if (Dispatch && Dispatch.now) {
      defer = function defer(id) {
        Dispatch.now(_ctx(run, id, 1));
      }; // Browsers with MessageChannel, includes WebWorkers

    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
      defer = function defer(id) {
        _global.postMessage(id + '', '*');
      };

      _global.addEventListener('message', listener, false); // IE8-
    } else if (ONREADYSTATECHANGE in _domCreate('script')) {
      defer = function defer(id) {
        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
          _html.removeChild(this);
          run.call(id);
        };
      }; // Rest old browsers

    } else {
      defer = function defer(id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
    }
  }

  var _task = {
    set: setTask,
    clear: clearTask
  };

  var macrotask = _task.set;
  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
  var process$1 = _global.process;
  var Promise$1 = _global.Promise;
  var isNode = _cof(process$1) == 'process';

  var _microtask = function _microtask() {
    var head, last, notify;

    var flush = function flush() {
      var parent, fn;
      if (isNode && (parent = process$1.domain)) parent.exit();

      while (head) {
        fn = head.fn;
        head = head.next;

        try {
          fn();
        } catch (e) {
          if (head) notify();else last = undefined;
          throw e;
        }
      }

      last = undefined;
      if (parent) parent.enter();
    }; // Node.js


    if (isNode) {
      notify = function notify() {
        process$1.nextTick(flush);
      }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, {
        characterData: true
      }); // eslint-disable-line no-new

      notify = function notify() {
        node.data = toggle = !toggle;
      }; // environments with maybe non-completely correct, but existent Promise

    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      var promise = Promise$1.resolve(undefined);

      notify = function notify() {
        promise.then(flush);
      }; // for other environments - macrotask based on:
      // - setImmediate
      // - MessageChannel
      // - window.postMessag
      // - onreadystatechange
      // - setTimeout

    } else {
      notify = function notify() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(_global, flush);
      };
    }

    return function (fn) {
      var task = {
        fn: fn,
        next: undefined
      };
      if (last) last.next = task;

      if (!head) {
        head = task;
        notify();
      }

      last = task;
    };
  };

  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }

  var f$7 = function f(C) {
    return new PromiseCapability(C);
  };

  var _newPromiseCapability = {
    f: f$7
  };

  var _perform = function _perform(exec) {
    try {
      return {
        e: false,
        v: exec()
      };
    } catch (e) {
      return {
        e: true,
        v: e
      };
    }
  };

  var navigator$1 = _global.navigator;

  var _userAgent = navigator$1 && navigator$1.userAgent || '';

  var _promiseResolve = function _promiseResolve(C, x) {
    _anObject(C);
    if (_isObject(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var _redefineAll = function _redefineAll(target, src, safe) {
    for (var key in src) {
      _redefine(target, key, src[key], safe);
    }

    return target;
  };

  var task = _task.set;
  var microtask = _microtask();
  var PROMISE = 'Promise';
  var TypeError$1 = _global.TypeError;
  var process$2 = _global.process;
  var versions = process$2 && process$2.versions;
  var v8 = versions && versions.v8 || '';
  var $Promise = _global[PROMISE];
  var isNode$1 = _classof(process$2) == 'process';

  var empty = function empty() {
    /* empty */
  };

  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
  var USE_NATIVE$1 = !!function () {
    try {
      // correct subclassing with @@species support
      var promise = $Promise.resolve(1);

      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
        exec(empty, empty);
      }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


      return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;
    } catch (e) {
      /* empty */
    }
  }(); // helpers

  var isThenable = function isThenable(it) {
    var then;
    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify = function notify(promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;

      var run = function run(reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;

        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }

            if (handler === true) result = value;else {
              if (domain) domain.enter();
              result = handler(value); // may throw

              if (domain) {
                domain.exit();
                exited = true;
              }
            }

            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };

      while (chain.length > i) {
        run(chain[i++]);
      } // variable length - can't use forEach


      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };

  var onUnhandled = function onUnhandled(promise) {
    task.call(_global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;

      if (unhandled) {
        result = _perform(function () {
          if (isNode$1) {
            process$2.emit('unhandledRejection', value, promise);
          } else if (handler = _global.onunhandledrejection) {
            handler({
              promise: promise,
              reason: value
            });
          } else if ((console = _global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
      }

      promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };

  var isUnhandled = function isUnhandled(promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };

  var onHandleUnhandled = function onHandleUnhandled(promise) {
    task.call(_global, function () {
      var handler;

      if (isNode$1) {
        process$2.emit('rejectionHandled', promise);
      } else if (handler = _global.onrejectionhandled) {
        handler({
          promise: promise,
          reason: promise._v
        });
      }
    });
  };

  var $reject = function $reject(value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap

    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };

  var $resolve = function $resolve(value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap

    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");

      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = {
            _w: promise,
            _d: false
          }; // wrap

          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({
        _w: promise,
        _d: false
      }, e); // wrap
    }
  }; // constructor polyfill


  if (!USE_NATIVE$1) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, '_h');
      _aFunction(executor);
      Internal.call(this);

      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    }; // eslint-disable-next-line no-unused-vars


    Internal = function Promise(executor) {
      this._c = []; // <- awaiting reactions

      this._a = undefined; // <- checked in isUnhandled reactions

      this._s = 0; // <- state

      this._d = false; // <- done

      this._v = undefined; // <- value

      this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

      this._n = false; // <- notify
    };

    Internal.prototype = _redefineAll($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode$1 ? process$2.domain : undefined;

        this._c.push(reaction);

        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function _catch(onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    OwnPromiseCapability = function OwnPromiseCapability() {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };

    _newPromiseCapability.f = newPromiseCapability = function newPromiseCapability(C) {
      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {
    Promise: $Promise
  });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core[PROMISE]; // statics

  _export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * ( !USE_NATIVE$1), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return _promiseResolve( this, x);
    }
  });
  _export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
    $Promise.all(iter)['catch'](empty);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = _perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        _forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = _perform(function () {
        _forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });

  var _validateCollection = function _validateCollection(it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$5 = _objectDp.f;
  var fastKey = _meta.fastKey;
  var SIZE = _descriptors ? '_s' : 'size';

  var getEntry = function getEntry(that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index]; // frozen object case

    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };

  var _collectionStrong = {
    getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME; // collection type

        that._i = _objectCreate(null); // index

        that._f = undefined; // first entry

        that._l = undefined; // last entry

        that[SIZE] = 0; // size

        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }

          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function _delete(key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }

          return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;

          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this); // revert to the last existing entry

            while (entry && entry.r) {
              entry = entry.p;
            }
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$5(C.prototype, 'size', {
        get: function get() {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function def(that, key, value) {
      var entry = getEntry(that, key);
      var prev, index; // change existing entry

      if (entry) {
        entry.v = value; // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          // <- index
          k: key,
          // <- key
          v: value,
          // <- value
          p: prev = that._l,
          // <- previous entry
          n: undefined,
          // <- next entry
          r: false // <- removed

        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++; // add to index

        if (index !== 'F') that._i[index] = entry;
      }

      return that;
    },
    getEntry: getEntry,
    setStrong: function setStrong(C, NAME, IS_MAP) {
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME); // target

        this._k = kind; // kind

        this._l = undefined; // previous
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l; // revert to the last existing entry

        while (entry && entry.r) {
          entry = entry.p;
        } // get next entry


        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          // or finish the iteration
          that._t = undefined;
          return _iterStep(1);
        } // return step by kind


        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

      _setSpecies(NAME);
    }
  };

  var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};

    var fixMethod = function fixMethod(KEY) {
      var fn = proto[KEY];
      _redefine(proto, KEY, KEY == 'delete' ? function (a) {
        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };

    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      var instance = new C(); // early implementations not supports chaining

      var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

      var THROWS_ON_PRIMITIVES = _fails(function () {
        instance.has(1);
      }); // most early implementations doesn't supports iterables, most modern - not close it correctly

      var ACCEPT_ITERABLES = _iterDetect(function (iter) {
        new C(iter);
      }); // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same

      var BUGGY_ZERO = !IS_WEAK && _fails(function () {
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C();
        var index = 5;

        while (index--) {
          $instance[ADDER](index, index);
        }

        return !$instance.has(-0);
      });

      if (!ACCEPT_ITERABLES) {
        C = wrapper(function (target, iterable) {
          _anInstance(target, C, NAME);
          var that = _inheritIfRequired(new Base(), target, C);
          if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }

      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }

      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

      if (IS_WEAK && proto.clear) delete proto.clear;
    }

    _setToStringTag(C, NAME);
    O[NAME] = C;
    _export(_export.G + _export.W + _export.F * (C != Base), O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };

  var MAP = 'Map'; // 23.1 Map Objects

  var es6_map = _collection(MAP, function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
    }
  }, _collectionStrong, true);

  var SET = 'Set'; // 23.2 Set Objects

  var es6_set = _collection(SET, function (get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function add(value) {
      return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
    }
  }, _collectionStrong);

  var getWeak = _meta.getWeak;
  var arrayFind = _arrayMethods(5);
  var arrayFindIndex = _arrayMethods(6);
  var id$1 = 0; // fallback for uncaught frozen keys

  var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
    return that._l || (that._l = new UncaughtFrozenStore());
  };

  var UncaughtFrozenStore = function UncaughtFrozenStore() {
    this.a = [];
  };

  var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
    return arrayFind(store.a, function (it) {
      return it[0] === key;
    });
  };

  UncaughtFrozenStore.prototype = {
    get: function get(key) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) return entry[1];
    },
    has: function has(key) {
      return !!findUncaughtFrozen(this, key);
    },
    set: function set(key, value) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) entry[1] = value;else this.a.push([key, value]);
    },
    'delete': function _delete(key) {
      var index = arrayFindIndex(this.a, function (it) {
        return it[0] === key;
      });
      if (~index) this.a.splice(index, 1);
      return !!~index;
    }
  };
  var _collectionWeak = {
    getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME; // collection type

        that._i = id$1++; // collection id

        that._l = undefined; // leak store for uncaught frozen objects

        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        // 23.3.3.2 WeakMap.prototype.delete(key)
        // 23.4.3.3 WeakSet.prototype.delete(value)
        'delete': function _delete(key) {
          if (!_isObject(key)) return false;
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
          return data && _has(data, this._i) && delete data[this._i];
        },
        // 23.3.3.4 WeakMap.prototype.has(key)
        // 23.4.3.4 WeakSet.prototype.has(value)
        has: function has(key) {
          if (!_isObject(key)) return false;
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
          return data && _has(data, this._i);
        }
      });
      return C;
    },
    def: function def(that, key, value) {
      var data = getWeak(_anObject(key), true);
      if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
      return that;
    },
    ufstore: uncaughtFrozenStore
  };

  var es6_weakMap = createCommonjsModule(function (module) {

    var each = _arrayMethods(0);
    var NATIVE_WEAK_MAP = _validateCollection;
    var IS_IE11 = !_global.ActiveXObject && 'ActiveXObject' in _global;
    var WEAK_MAP = 'WeakMap';
    var getWeak = _meta.getWeak;
    var isExtensible = Object.isExtensible;
    var uncaughtFrozenStore = _collectionWeak.ufstore;
    var InternalMap;

    var wrapper = function wrapper(get) {
      return function WeakMap() {
        return get(this, arguments.length > 0 ? arguments[0] : undefined);
      };
    };

    var methods = {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        if (_isObject(key)) {
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
          return data ? data[this._i] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
      }
    }; // 23.3 WeakMap Objects

    var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true); // IE11 WeakMap frozen keys fix

    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
      _objectAssign(InternalMap.prototype, methods);
      _meta.NEED = true;
      each(['delete', 'has', 'get', 'set'], function (key) {
        var proto = $WeakMap.prototype;
        var method = proto[key];
        _redefine(proto, key, function (a, b) {
          // store frozen objects on internal weakmap shim
          if (_isObject(a) && !isExtensible(a)) {
            if (!this._f) this._f = new InternalMap();

            var result = this._f[key](a, b);

            return key == 'set' ? this : result; // store all the rest on native weakmap
          }

          return method.call(this, a, b);
        });
      });
    }
  });

  var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

  _collection(WEAK_SET, function (get) {
    return function WeakSet() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function add(value) {
      return _collectionWeak.def(_validateCollection(this, WEAK_SET), value, true);
    }
  }, _collectionWeak, false, true);

  var TYPED = _uid('typed_array');
  var VIEW = _uid('view');
  var ABV = !!(_global.ArrayBuffer && _global.DataView);
  var CONSTR = ABV;
  var i$1 = 0;
  var l = 9;
  var Typed;
  var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

  while (i$1 < l) {
    if (Typed = _global[TypedArrayConstructors[i$1++]]) {
      _hide(Typed.prototype, TYPED, true);
      _hide(Typed.prototype, VIEW, true);
    } else CONSTR = false;
  }

  var _typed = {
    ABV: ABV,
    CONSTR: CONSTR,
    TYPED: TYPED,
    VIEW: VIEW
  };

  var _toIndex = function _toIndex(it) {
    if (it === undefined) return 0;
    var number = _toInteger(it);
    var length = _toLength(number);
    if (number !== length) throw RangeError('Wrong length!');
    return length;
  };

  var _typedBuffer = createCommonjsModule(function (module, exports) {

    var gOPN = _objectGopn.f;
    var dP = _objectDp.f;
    var ARRAY_BUFFER = 'ArrayBuffer';
    var DATA_VIEW = 'DataView';
    var PROTOTYPE = 'prototype';
    var WRONG_LENGTH = 'Wrong length!';
    var WRONG_INDEX = 'Wrong index!';
    var $ArrayBuffer = _global[ARRAY_BUFFER];
    var $DataView = _global[DATA_VIEW];
    var Math = _global.Math;
    var RangeError = _global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

    var Infinity = _global.Infinity;
    var BaseBuffer = $ArrayBuffer;
    var abs = Math.abs;
    var pow = Math.pow;
    var floor = Math.floor;
    var log = Math.log;
    var LN2 = Math.LN2;
    var BUFFER = 'buffer';
    var BYTE_LENGTH = 'byteLength';
    var BYTE_OFFSET = 'byteOffset';
    var $BUFFER = _descriptors ? '_b' : BUFFER;
    var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
    var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

    function packIEEE754(value, mLen, nBytes) {
      var buffer = new Array(nBytes);
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
      var i = 0;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      var e, m, c;
      value = abs(value); // eslint-disable-next-line no-self-compare

      if (value != value || value === Infinity) {
        // eslint-disable-next-line no-self-compare
        m = value != value ? 1 : 0;
        e = eMax;
      } else {
        e = floor(log(value) / LN2);

        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }

        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * pow(2, 1 - eBias);
        }

        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
      }

      e = e << mLen | m;
      eLen += mLen;

      for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
      }

      buffer[--i] |= s * 128;
      return buffer;
    }

    function unpackIEEE754(buffer, mLen, nBytes) {
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = eLen - 7;
      var i = nBytes - 1;
      var s = buffer[i--];
      var e = s & 127;
      var m;
      s >>= 7;

      for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
      }

      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;

      for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
      }

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity : Infinity;
      } else {
        m = m + pow(2, mLen);
        e = e - eBias;
      }

      return (s ? -1 : 1) * m * pow(2, e - mLen);
    }

    function unpackI32(bytes) {
      return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
    }

    function packI8(it) {
      return [it & 0xff];
    }

    function packI16(it) {
      return [it & 0xff, it >> 8 & 0xff];
    }

    function packI32(it) {
      return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
    }

    function packF64(it) {
      return packIEEE754(it, 52, 8);
    }

    function packF32(it) {
      return packIEEE754(it, 23, 4);
    }

    function addGetter(C, key, internal) {
      dP(C[PROTOTYPE], key, {
        get: function get() {
          return this[internal];
        }
      });
    }

    function get(view, bytes, index, isLittleEndian) {
      var numIndex = +index;
      var intIndex = _toIndex(numIndex);
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
      var store = view[$BUFFER]._b;
      var start = intIndex + view[$OFFSET];
      var pack = store.slice(start, start + bytes);
      return isLittleEndian ? pack : pack.reverse();
    }

    function set(view, bytes, index, conversion, value, isLittleEndian) {
      var numIndex = +index;
      var intIndex = _toIndex(numIndex);
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
      var store = view[$BUFFER]._b;
      var start = intIndex + view[$OFFSET];
      var pack = conversion(+value);

      for (var i = 0; i < bytes; i++) {
        store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
      }
    }

    if (!_typed.ABV) {
      $ArrayBuffer = function ArrayBuffer(length) {
        _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = _toIndex(length);
        this._b = _arrayFill.call(new Array(byteLength), 0);
        this[$LENGTH] = byteLength;
      };

      $DataView = function DataView(buffer, byteOffset, byteLength) {
        _anInstance(this, $DataView, DATA_VIEW);
        _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = buffer[$LENGTH];
        var offset = _toInteger(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
        byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
        this[$BUFFER] = buffer;
        this[$OFFSET] = offset;
        this[$LENGTH] = byteLength;
      };

      if (_descriptors) {
        addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
        addGetter($DataView, BUFFER, '_b');
        addGetter($DataView, BYTE_LENGTH, '_l');
        addGetter($DataView, BYTE_OFFSET, '_o');
      }

      _redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
          return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset
        /* , littleEndian */
        ) {
          var bytes = get(this, 2, byteOffset, arguments[1]);
          return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset
        /* , littleEndian */
        ) {
          var bytes = get(this, 2, byteOffset, arguments[1]);
          return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset
        /* , littleEndian */
        ) {
          return unpackI32(get(this, 4, byteOffset, arguments[1]));
        },
        getUint32: function getUint32(byteOffset
        /* , littleEndian */
        ) {
          return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset
        /* , littleEndian */
        ) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
        },
        getFloat64: function getFloat64(byteOffset
        /* , littleEndian */
        ) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
        },
        setInt8: function setInt8(byteOffset, value) {
          set(this, 1, byteOffset, packI8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set(this, 1, byteOffset, packI8, value);
        },
        setInt16: function setInt16(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setUint16: function setUint16(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setInt32: function setInt32(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setUint32: function setUint32(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setFloat32: function setFloat32(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 4, byteOffset, packF32, value, arguments[2]);
        },
        setFloat64: function setFloat64(byteOffset, value
        /* , littleEndian */
        ) {
          set(this, 8, byteOffset, packF64, value, arguments[2]);
        }
      });
    } else {
      if (!_fails(function () {
        $ArrayBuffer(1);
      }) || !_fails(function () {
        new $ArrayBuffer(-1); // eslint-disable-line no-new
      }) || _fails(function () {
        new $ArrayBuffer(); // eslint-disable-line no-new

        new $ArrayBuffer(1.5); // eslint-disable-line no-new

        new $ArrayBuffer(NaN); // eslint-disable-line no-new

        return $ArrayBuffer.name != ARRAY_BUFFER;
      })) {
        $ArrayBuffer = function ArrayBuffer(length) {
          _anInstance(this, $ArrayBuffer);
          return new BaseBuffer(_toIndex(length));
        };

        var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

        for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
          if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
        }

        ArrayBufferProto.constructor = $ArrayBuffer;
      } // iOS Safari 7.x bug


      var view = new $DataView(new $ArrayBuffer(2));
      var $setInt8 = $DataView[PROTOTYPE].setInt8;
      view.setInt8(0, 2147483648);
      view.setInt8(1, 2147483649);
      if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
        setInt8: function setInt8(byteOffset, value) {
          $setInt8.call(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
          $setInt8.call(this, byteOffset, value << 24 >> 24);
        }
      }, true);
    }

    _setToStringTag($ArrayBuffer, ARRAY_BUFFER);
    _setToStringTag($DataView, DATA_VIEW);
    _hide($DataView[PROTOTYPE], _typed.VIEW, true);
    exports[ARRAY_BUFFER] = $ArrayBuffer;
    exports[DATA_VIEW] = $DataView;
  });

  var ArrayBuffer = _global.ArrayBuffer;
  var $ArrayBuffer = _typedBuffer.ArrayBuffer;
  var $DataView = _typedBuffer.DataView;
  var $isView = _typed.ABV && ArrayBuffer.isView;
  var $slice = $ArrayBuffer.prototype.slice;
  var VIEW$1 = _typed.VIEW;
  var ARRAY_BUFFER = 'ArrayBuffer';
  _export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), {
    ArrayBuffer: $ArrayBuffer
  });
  _export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
    // 24.1.3.1 ArrayBuffer.isView(arg)
    isView: function isView(it) {
      return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
    }
  });
  _export(_export.P + _export.U + _export.F * _fails(function () {
    return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
  }), ARRAY_BUFFER, {
    // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
    slice: function slice(start, end) {
      if ($slice !== undefined && end === undefined) return $slice.call(_anObject(this), start); // FF fix

      var len = _anObject(this).byteLength;
      var first = _toAbsoluteIndex(start, len);
      var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
      var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
      var viewS = new $DataView(this);
      var viewT = new $DataView(result);
      var index = 0;

      while (first < fin) {
        viewT.setUint8(index++, viewS.getUint8(first++));
      }

      return result;
    }
  });
  _setSpecies(ARRAY_BUFFER);

  _export(_export.G + _export.W + _export.F * !_typed.ABV, {
    DataView: _typedBuffer.DataView
  });

  var _typedArray = createCommonjsModule(function (module) {

    if (_descriptors) {
      var LIBRARY = _library;
      var global = _global;
      var fails = _fails;
      var $export = _export;
      var $typed = _typed;
      var $buffer = _typedBuffer;
      var ctx = _ctx;
      var anInstance = _anInstance;
      var propertyDesc = _propertyDesc;
      var hide = _hide;
      var redefineAll = _redefineAll;
      var toInteger = _toInteger;
      var toLength = _toLength;
      var toIndex = _toIndex;
      var toAbsoluteIndex = _toAbsoluteIndex;
      var toPrimitive = _toPrimitive;
      var has = _has;
      var classof = _classof;
      var isObject = _isObject;
      var toObject = _toObject;
      var isArrayIter = _isArrayIter;
      var create = _objectCreate;
      var getPrototypeOf = _objectGpo;
      var gOPN = _objectGopn.f;
      var getIterFn = core_getIteratorMethod;
      var uid = _uid;
      var wks = _wks;
      var createArrayMethod = _arrayMethods;
      var createArrayIncludes = _arrayIncludes;
      var speciesConstructor = _speciesConstructor;
      var ArrayIterators = es6_array_iterator;
      var Iterators = _iterators;
      var $iterDetect = _iterDetect;
      var setSpecies = _setSpecies;
      var arrayFill = _arrayFill;
      var arrayCopyWithin = _arrayCopyWithin;
      var $DP = _objectDp;
      var $GOPD = _objectGopd;
      var dP = $DP.f;
      var gOPD = $GOPD.f;
      var RangeError = global.RangeError;
      var TypeError = global.TypeError;
      var Uint8Array = global.Uint8Array;
      var ARRAY_BUFFER = 'ArrayBuffer';
      var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
      var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
      var PROTOTYPE = 'prototype';
      var ArrayProto = Array[PROTOTYPE];
      var $ArrayBuffer = $buffer.ArrayBuffer;
      var $DataView = $buffer.DataView;
      var arrayForEach = createArrayMethod(0);
      var arrayFilter = createArrayMethod(2);
      var arraySome = createArrayMethod(3);
      var arrayEvery = createArrayMethod(4);
      var arrayFind = createArrayMethod(5);
      var arrayFindIndex = createArrayMethod(6);
      var arrayIncludes = createArrayIncludes(true);
      var arrayIndexOf = createArrayIncludes(false);
      var arrayValues = ArrayIterators.values;
      var arrayKeys = ArrayIterators.keys;
      var arrayEntries = ArrayIterators.entries;
      var arrayLastIndexOf = ArrayProto.lastIndexOf;
      var arrayReduce = ArrayProto.reduce;
      var arrayReduceRight = ArrayProto.reduceRight;
      var arrayJoin = ArrayProto.join;
      var arraySort = ArrayProto.sort;
      var arraySlice = ArrayProto.slice;
      var arrayToString = ArrayProto.toString;
      var arrayToLocaleString = ArrayProto.toLocaleString;
      var ITERATOR = wks('iterator');
      var TAG = wks('toStringTag');
      var TYPED_CONSTRUCTOR = uid('typed_constructor');
      var DEF_CONSTRUCTOR = uid('def_constructor');
      var ALL_CONSTRUCTORS = $typed.CONSTR;
      var TYPED_ARRAY = $typed.TYPED;
      var VIEW = $typed.VIEW;
      var WRONG_LENGTH = 'Wrong length!';
      var $map = createArrayMethod(1, function (O, length) {
        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
      });
      var LITTLE_ENDIAN = fails(function () {
        // eslint-disable-next-line no-undef
        return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
      });
      var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
        new Uint8Array(1).set({});
      });

      var toOffset = function toOffset(it, BYTES) {
        var offset = toInteger(it);
        if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
        return offset;
      };

      var validate = function validate(it) {
        if (isObject(it) && TYPED_ARRAY in it) return it;
        throw TypeError(it + ' is not a typed array!');
      };

      var allocate = function allocate(C, length) {
        if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
          throw TypeError('It is not a typed array constructor!');
        }

        return new C(length);
      };

      var speciesFromList = function speciesFromList(O, list) {
        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
      };

      var fromList = function fromList(C, list) {
        var index = 0;
        var length = list.length;
        var result = allocate(C, length);

        while (length > index) {
          result[index] = list[index++];
        }

        return result;
      };

      var addGetter = function addGetter(it, key, internal) {
        dP(it, key, {
          get: function get() {
            return this._d[internal];
          }
        });
      };

      var $from = function from(source
      /* , mapfn, thisArg */
      ) {
        var O = toObject(source);
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : undefined;
        var mapping = mapfn !== undefined;
        var iterFn = getIterFn(O);
        var i, length, values, result, step, iterator;

        if (iterFn != undefined && !isArrayIter(iterFn)) {
          for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
            values.push(step.value);
          }

          O = values;
        }

        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

        for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
          result[i] = mapping ? mapfn(O[i], i) : O[i];
        }

        return result;
      };

      var $of = function
        /* ...items */
      of() {
        var index = 0;
        var length = arguments.length;
        var result = allocate(this, length);

        while (length > index) {
          result[index] = arguments[index++];
        }

        return result;
      }; // iOS Safari 6.x fails here


      var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
        arrayToLocaleString.call(new Uint8Array(1));
      });

      var $toLocaleString = function toLocaleString() {
        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
      };

      var proto = {
        copyWithin: function copyWithin(target, start
        /* , end */
        ) {
          return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
        },
        every: function every(callbackfn
        /* , thisArg */
        ) {
          return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        fill: function fill(value
        /* , start, end */
        ) {
          // eslint-disable-line no-unused-vars
          return arrayFill.apply(validate(this), arguments);
        },
        filter: function filter(callbackfn
        /* , thisArg */
        ) {
          return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
        },
        find: function find(predicate
        /* , thisArg */
        ) {
          return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        },
        findIndex: function findIndex(predicate
        /* , thisArg */
        ) {
          return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        },
        forEach: function forEach(callbackfn
        /* , thisArg */
        ) {
          arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        indexOf: function indexOf(searchElement
        /* , fromIndex */
        ) {
          return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        },
        includes: function includes(searchElement
        /* , fromIndex */
        ) {
          return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        },
        join: function join(separator) {
          // eslint-disable-line no-unused-vars
          return arrayJoin.apply(validate(this), arguments);
        },
        lastIndexOf: function lastIndexOf(searchElement
        /* , fromIndex */
        ) {
          // eslint-disable-line no-unused-vars
          return arrayLastIndexOf.apply(validate(this), arguments);
        },
        map: function map(mapfn
        /* , thisArg */
        ) {
          return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        reduce: function reduce(callbackfn
        /* , initialValue */
        ) {
          // eslint-disable-line no-unused-vars
          return arrayReduce.apply(validate(this), arguments);
        },
        reduceRight: function reduceRight(callbackfn
        /* , initialValue */
        ) {
          // eslint-disable-line no-unused-vars
          return arrayReduceRight.apply(validate(this), arguments);
        },
        reverse: function reverse() {
          var that = this;
          var length = validate(that).length;
          var middle = Math.floor(length / 2);
          var index = 0;
          var value;

          while (index < middle) {
            value = that[index];
            that[index++] = that[--length];
            that[length] = value;
          }

          return that;
        },
        some: function some(callbackfn
        /* , thisArg */
        ) {
          return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        sort: function sort(comparefn) {
          return arraySort.call(validate(this), comparefn);
        },
        subarray: function subarray(begin, end) {
          var O = validate(this);
          var length = O.length;
          var $begin = toAbsoluteIndex(begin, length);
          return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
        }
      };

      var $slice = function slice(start, end) {
        return speciesFromList(this, arraySlice.call(validate(this), start, end));
      };

      var $set = function set(arrayLike
      /* , offset */
      ) {
        validate(this);
        var offset = toOffset(arguments[1], 1);
        var length = this.length;
        var src = toObject(arrayLike);
        var len = toLength(src.length);
        var index = 0;
        if (len + offset > length) throw RangeError(WRONG_LENGTH);

        while (index < len) {
          this[offset + index] = src[index++];
        }
      };

      var $iterators = {
        entries: function entries() {
          return arrayEntries.call(validate(this));
        },
        keys: function keys() {
          return arrayKeys.call(validate(this));
        },
        values: function values() {
          return arrayValues.call(validate(this));
        }
      };

      var isTAIndex = function isTAIndex(target, key) {
        return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
      };

      var $getDesc = function getOwnPropertyDescriptor(target, key) {
        return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
      };

      var $setDesc = function defineProperty(target, key, desc) {
        if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
        && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
          target[key] = desc.value;
          return target;
        }

        return dP(target, key, desc);
      };

      if (!ALL_CONSTRUCTORS) {
        $GOPD.f = $getDesc;
        $DP.f = $setDesc;
      }

      $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
        getOwnPropertyDescriptor: $getDesc,
        defineProperty: $setDesc
      });

      if (fails(function () {
        arrayToString.call({});
      })) {
        arrayToString = arrayToLocaleString = function toString() {
          return arrayJoin.call(this);
        };
      }

      var $TypedArrayPrototype$ = redefineAll({}, proto);
      redefineAll($TypedArrayPrototype$, $iterators);
      hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
      redefineAll($TypedArrayPrototype$, {
        slice: $slice,
        set: $set,
        constructor: function constructor() {
          /* noop */
        },
        toString: arrayToString,
        toLocaleString: $toLocaleString
      });
      addGetter($TypedArrayPrototype$, 'buffer', 'b');
      addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
      addGetter($TypedArrayPrototype$, 'byteLength', 'l');
      addGetter($TypedArrayPrototype$, 'length', 'e');
      dP($TypedArrayPrototype$, TAG, {
        get: function get() {
          return this[TYPED_ARRAY];
        }
      }); // eslint-disable-next-line max-statements

      module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
        CLAMPED = !!CLAMPED;
        var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + KEY;
        var SETTER = 'set' + KEY;
        var TypedArray = global[NAME];
        var Base = TypedArray || {};
        var TAC = TypedArray && getPrototypeOf(TypedArray);
        var FORCED = !TypedArray || !$typed.ABV;
        var O = {};
        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

        var getter = function getter(that, index) {
          var data = that._d;
          return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
        };

        var setter = function setter(that, index, value) {
          var data = that._d;
          if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
          data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
        };

        var addElement = function addElement(that, index) {
          dP(that, index, {
            get: function get() {
              return getter(this, index);
            },
            set: function set(value) {
              return setter(this, index, value);
            },
            enumerable: true
          });
        };

        if (FORCED) {
          TypedArray = wrapper(function (that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME, '_d');
            var index = 0;
            var offset = 0;
            var buffer, byteLength, length, klass;

            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new $ArrayBuffer(byteLength);
            } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              buffer = data;
              offset = toOffset($offset, BYTES);
              var $len = data.byteLength;

              if ($length === undefined) {
                if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                byteLength = $len - offset;
                if (byteLength < 0) throw RangeError(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
              }

              length = byteLength / BYTES;
            } else if (TYPED_ARRAY in data) {
              return fromList(TypedArray, data);
            } else {
              return $from.call(TypedArray, data);
            }

            hide(that, '_d', {
              b: buffer,
              o: offset,
              l: byteLength,
              e: length,
              v: new $DataView(buffer)
            });

            while (index < length) {
              addElement(that, index++);
            }
          });
          TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
          hide(TypedArrayPrototype, 'constructor', TypedArray);
        } else if (!fails(function () {
          TypedArray(1);
        }) || !fails(function () {
          new TypedArray(-1); // eslint-disable-line no-new
        }) || !$iterDetect(function (iter) {
          new TypedArray(); // eslint-disable-line no-new

          new TypedArray(null); // eslint-disable-line no-new

          new TypedArray(1.5); // eslint-disable-line no-new

          new TypedArray(iter); // eslint-disable-line no-new
        }, true)) {
          TypedArray = wrapper(function (that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME);
            var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
            // https://github.com/websockets/ws/pull/645

            if (!isObject(data)) return new Base(toIndex(data));

            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
            }

            if (TYPED_ARRAY in data) return fromList(TypedArray, data);
            return $from.call(TypedArray, data);
          });
          arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
            if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
          });
          TypedArray[PROTOTYPE] = TypedArrayPrototype;
          if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
        }

        var $nativeIterator = TypedArrayPrototype[ITERATOR];
        var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
        var $iterator = $iterators.values;
        hide(TypedArray, TYPED_CONSTRUCTOR, true);
        hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
        hide(TypedArrayPrototype, VIEW, true);
        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
          dP(TypedArrayPrototype, TAG, {
            get: function get() {
              return NAME;
            }
          });
        }

        O[NAME] = TypedArray;
        $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
        $export($export.S, NAME, {
          BYTES_PER_ELEMENT: BYTES
        });
        $export($export.S + $export.F * fails(function () {
          Base.of.call(TypedArray, 1);
        }), NAME, {
          from: $from,
          of: $of
        });
        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
        $export($export.P, NAME, proto);
        setSpecies(NAME);
        $export($export.P + $export.F * FORCED_SET, NAME, {
          set: $set
        });
        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
        $export($export.P + $export.F * fails(function () {
          new TypedArray(1).slice();
        }), NAME, {
          slice: $slice
        });
        $export($export.P + $export.F * (fails(function () {
          return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
        }) || !fails(function () {
          TypedArrayPrototype.toLocaleString.call([1, 2]);
        })), NAME, {
          toLocaleString: $toLocaleString
        });
        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
      };
    } else module.exports = function () {
      /* empty */
    };
  });

  _typedArray('Int8', 1, function (init) {
    return function Int8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint8', 1, function (init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint8', 1, function (init) {
    return function Uint8ClampedArray(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  }, true);

  _typedArray('Int16', 2, function (init) {
    return function Int16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint16', 2, function (init) {
    return function Uint16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Int32', 4, function (init) {
    return function Int32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint32', 4, function (init) {
    return function Uint32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Float32', 4, function (init) {
    return function Float32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Float64', 8, function (init) {
    return function Float64Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  var rApply = (_global.Reflect || {}).apply;
  var fApply = Function.apply; // MS Edge argumentsList argument is optional

  _export(_export.S + _export.F * !_fails(function () {
    rApply(function () {
      /* empty */
    });
  }), 'Reflect', {
    apply: function apply(target, thisArgument, argumentsList) {
      var T = _aFunction(target);
      var L = _anObject(argumentsList);
      return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
    }
  });

  var rConstruct = (_global.Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = _fails(function () {
    function F() {
      /* empty */
    }

    return !(rConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !_fails(function () {
    rConstruct(function () {
      /* empty */
    });
  });
  _export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      _aFunction(Target);
      _anObject(args);
      var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        $args.push.apply($args, args);
        return new (_bind.apply(Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return _isObject(result) ? result : instance;
    }
  });

  // MS Edge has broken Reflect.defineProperty - throwing instead of returning false

  _export(_export.S + _export.F * _fails(function () {
    // eslint-disable-next-line no-undef
    Reflect.defineProperty(_objectDp.f({}, 1, {
      value: 1
    }), 1, {
      value: 2
    });
  }), 'Reflect', {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
      _anObject(target);
      propertyKey = _toPrimitive(propertyKey, true);
      _anObject(attributes);

      try {
        _objectDp.f(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    }
  });

  var gOPD$3 = _objectGopd.f;
  _export(_export.S, 'Reflect', {
    deleteProperty: function deleteProperty(target, propertyKey) {
      var desc = gOPD$3(_anObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    }
  });

  var Enumerate = function Enumerate(iterated) {
    this._t = _anObject(iterated); // target

    this._i = 0; // next index

    var keys = this._k = []; // keys

    var key;

    for (key in iterated) {
      keys.push(key);
    }
  };

  _iterCreate(Enumerate, 'Object', function () {
    var that = this;
    var keys = that._k;
    var key;

    do {
      if (that._i >= keys.length) return {
        value: undefined,
        done: true
      };
    } while (!((key = keys[that._i++]) in that._t));

    return {
      value: key,
      done: false
    };
  });
  _export(_export.S, 'Reflect', {
    enumerate: function enumerate(target) {
      return new Enumerate(target);
    }
  });

  function get(target, propertyKey
  /* , receiver */
  ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var desc, proto;
    if (_anObject(target) === receiver) return target[propertyKey];
    if (desc = _objectGopd.f(target, propertyKey)) return _has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (_isObject(proto = _objectGpo(target))) return get(proto, propertyKey, receiver);
  }

  _export(_export.S, 'Reflect', {
    get: get
  });

  _export(_export.S, 'Reflect', {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return _objectGopd.f(_anObject(target), propertyKey);
    }
  });

  _export(_export.S, 'Reflect', {
    getPrototypeOf: function getPrototypeOf(target) {
      return _objectGpo(_anObject(target));
    }
  });

  _export(_export.S, 'Reflect', {
    has: function has(target, propertyKey) {
      return propertyKey in target;
    }
  });

  var $isExtensible = Object.isExtensible;
  _export(_export.S, 'Reflect', {
    isExtensible: function isExtensible(target) {
      _anObject(target);
      return $isExtensible ? $isExtensible(target) : true;
    }
  });

  var Reflect$1 = _global.Reflect;

  var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
    var keys = _objectGopn.f(_anObject(it));
    var getSymbols = _objectGops.f;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
  };

  _export(_export.S, 'Reflect', {
    ownKeys: _ownKeys
  });

  var $preventExtensions = Object.preventExtensions;
  _export(_export.S, 'Reflect', {
    preventExtensions: function preventExtensions(target) {
      _anObject(target);

      try {
        if ($preventExtensions) $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    }
  });

  function set(target, propertyKey, V
  /* , receiver */
  ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDesc = _objectGopd.f(_anObject(target), propertyKey);
    var existingDescriptor, proto;

    if (!ownDesc) {
      if (_isObject(proto = _objectGpo(target))) {
        return set(proto, propertyKey, V, receiver);
      }

      ownDesc = _propertyDesc(0);
    }

    if (_has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !_isObject(receiver)) return false;

      if (existingDescriptor = _objectGopd.f(receiver, propertyKey)) {
        if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
        existingDescriptor.value = V;
        _objectDp.f(receiver, propertyKey, existingDescriptor);
      } else _objectDp.f(receiver, propertyKey, _propertyDesc(0, V));

      return true;
    }

    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }

  _export(_export.S, 'Reflect', {
    set: set
  });

  if (_setProto) _export(_export.S, 'Reflect', {
    setPrototypeOf: function setPrototypeOf(target, proto) {
      _setProto.check(target, proto);

      try {
        _setProto.set(target, proto);
        return true;
      } catch (e) {
        return false;
      }
    }
  });

  var $includes = _arrayIncludes(true);
  _export(_export.P, 'Array', {
    includes: function includes(el
    /* , fromIndex = 0 */
    ) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  _addToUnscopables('includes');

  var includes = _core.Array.includes;

  var IS_CONCAT_SPREADABLE = _wks('isConcatSpreadable');

  function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? _ctx(mapper, thisArg, 3) : false;
    var element, spreadable;

    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
        spreadable = false;

        if (_isObject(element)) {
          spreadable = element[IS_CONCAT_SPREADABLE];
          spreadable = spreadable !== undefined ? !!spreadable : _isArray(element);
        }

        if (spreadable && depth > 0) {
          targetIndex = flattenIntoArray(target, original, element, _toLength(element.length), targetIndex, depth - 1) - 1;
        } else {
          if (targetIndex >= 0x1fffffffffffff) throw TypeError();
          target[targetIndex] = element;
        }

        targetIndex++;
      }

      sourceIndex++;
    }

    return targetIndex;
  }

  var _flattenIntoArray = flattenIntoArray;

  _export(_export.P, 'Array', {
    flatMap: function flatMap(callbackfn
    /* , thisArg */
    ) {
      var O = _toObject(this);
      var sourceLen, A;
      _aFunction(callbackfn);
      sourceLen = _toLength(O.length);
      A = _arraySpeciesCreate(O, 0);
      _flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
      return A;
    }
  });
  _addToUnscopables('flatMap');

  var flatMap = _core.Array.flatMap;

  var _stringPad = function _stringPad(that, maxLength, fillString, left) {
    var S = String(_defined(that));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = _toLength(maxLength);
    if (intMaxLength <= stringLength || fillStr == '') return S;
    var fillLen = intMaxLength - stringLength;
    var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };

  // https://github.com/zloirock/core-js/issues/280


  var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);
  _export(_export.P + _export.F * WEBKIT_BUG, 'String', {
    padStart: function padStart(maxLength
    /* , fillString = ' ' */
    ) {
      return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
    }
  });

  var padStart = _core.String.padStart;

  // https://github.com/zloirock/core-js/issues/280


  var WEBKIT_BUG$1 = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);
  _export(_export.P + _export.F * WEBKIT_BUG$1, 'String', {
    padEnd: function padEnd(maxLength
    /* , fillString = ' ' */
    ) {
      return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
    }
  });

  var padEnd = _core.String.padEnd;

  _stringTrim('trimLeft', function ($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  }, 'trimStart');

  var trimStart = _core.String.trimLeft;

  _stringTrim('trimRight', function ($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  }, 'trimEnd');

  var trimEnd = _core.String.trimRight;

  _wksDefine('asyncIterator');

  var asyncIterator = _wksExt.f('asyncIterator');

  _export(_export.S, 'Object', {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = _toIobject(object);
      var getDesc = _objectGopd.f;
      var keys = _ownKeys(O);
      var result = {};
      var i = 0;
      var key, desc;

      while (keys.length > i) {
        desc = getDesc(O, key = keys[i++]);
        if (desc !== undefined) _createProperty(result, key, desc);
      }

      return result;
    }
  });

  var getOwnPropertyDescriptors = _core.Object.getOwnPropertyDescriptors;

  var isEnum$1 = _objectPie.f;

  var _objectToArray = function _objectToArray(isEntries) {
    return function (it) {
      var O = _toIobject(it);
      var keys = _objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        key = keys[i++];

        if (!_descriptors || isEnum$1.call(O, key)) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      }

      return result;
    };
  };

  var $values = _objectToArray(false);
  _export(_export.S, 'Object', {
    values: function values(it) {
      return $values(it);
    }
  });

  var values = _core.Object.values;

  var $entries = _objectToArray(true);
  _export(_export.S, 'Object', {
    entries: function entries(it) {
      return $entries(it);
    }
  });

  var entries = _core.Object.entries;

  _export(_export.P + _export.R, 'Promise', {
    'finally': function _finally(onFinally) {
      var C = _speciesConstructor(this, _core.Promise || _global.Promise);
      var isFunction = typeof onFinally == 'function';
      return this.then(isFunction ? function (x) {
        return _promiseResolve(C, onFinally()).then(function () {
          return x;
        });
      } : onFinally, isFunction ? function (e) {
        return _promiseResolve(C, onFinally()).then(function () {
          throw e;
        });
      } : onFinally);
    }
  });

  var _finally = _core.Promise['finally'];

  var slice = [].slice;
  var MSIE = /MSIE .\./.test(_userAgent); // <- dirty ie9- check

  var wrap$1 = function wrap(set) {
    return function (fn, time
    /* , ...args */
    ) {
      var boundArgs = arguments.length > 2;
      var args = boundArgs ? slice.call(arguments, 2) : false;
      return set(boundArgs ? function () {
        // eslint-disable-next-line no-new-func
        (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
      } : fn, time);
    };
  };

  _export(_export.G + _export.B + _export.F * MSIE, {
    setTimeout: wrap$1(_global.setTimeout),
    setInterval: wrap$1(_global.setInterval)
  });

  _export(_export.G + _export.B, {
    setImmediate: _task.set,
    clearImmediate: _task.clear
  });

  var ITERATOR$4 = _wks('iterator');
  var TO_STRING_TAG = _wks('toStringTag');
  var ArrayValues = _iterators.Array;
  var DOMIterables = {
    CSSRuleList: true,
    // TODO: Not spec compliant, should be false.
    CSSStyleDeclaration: false,
    CSSValueList: false,
    ClientRectList: false,
    DOMRectList: false,
    DOMStringList: false,
    DOMTokenList: true,
    DataTransferItemList: false,
    FileList: false,
    HTMLAllCollection: false,
    HTMLCollection: false,
    HTMLFormElement: false,
    HTMLSelectElement: false,
    MediaList: true,
    // TODO: Not spec compliant, should be false.
    MimeTypeArray: false,
    NamedNodeMap: false,
    NodeList: true,
    PaintRequestList: false,
    Plugin: false,
    PluginArray: false,
    SVGLengthList: false,
    SVGNumberList: false,
    SVGPathSegList: false,
    SVGPointList: false,
    SVGStringList: false,
    SVGTransformList: false,
    SourceBufferList: false,
    StyleSheetList: true,
    // TODO: Not spec compliant, should be false.
    TextTrackCueList: false,
    TextTrackList: false,
    TouchList: false
  };

  for (var collections = _objectKeys(DOMIterables), i$2 = 0; i$2 < collections.length; i$2++) {
    var NAME$1 = collections[i$2];
    var explicit = DOMIterables[NAME$1];
    var Collection = _global[NAME$1];
    var proto$3 = Collection && Collection.prototype;
    var key$1;

    if (proto$3) {
      if (!proto$3[ITERATOR$4]) _hide(proto$3, ITERATOR$4, ArrayValues);
      if (!proto$3[TO_STRING_TAG]) _hide(proto$3, TO_STRING_TAG, NAME$1);
      _iterators[NAME$1] = ArrayValues;
      if (explicit) for (key$1 in es6_array_iterator) {
        if (!proto$3[key$1]) _redefine(proto$3, key$1, es6_array_iterator[key$1], true);
      }
    }
  }

  var runtime_1 = createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define(Gp, "constructor", GeneratorFunctionPrototype);
      define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      });
      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      define(Gp, iteratorSymbol, function () {
        return this;
      });
      define(Gp, "toString", function () {
        return "[object Generator]";
      });

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, in modern engines
      // we can explicitly access globalThis. In older engines we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  });

  var _global$1 = createCommonjsModule(function (module) {
    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
    : Function('return this')();
    if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core$1 = createCommonjsModule(function (module) {
    var core = module.exports = {
      version: '2.6.12'
    };
    if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });

  var _aFunction$1 = function _aFunction(it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx$1 = function _ctx(fn, that, length) {
    _aFunction$1(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function
      /* ...args */
    () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject$1 = function _isObject(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject$1 = function _anObject(it) {
    if (!_isObject$1(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails$1 = function _fails(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors$1 = !_fails$1(function () {
    return Object.defineProperty({}, 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var document$3 = _global$1.document; // typeof document.createElement is 'object' in old IE

  var is$1 = _isObject$1(document$3) && _isObject$1(document$3.createElement);

  var _domCreate$1 = function _domCreate(it) {
    return is$1 ? document$3.createElement(it) : {};
  };

  var _ie8DomDefine$1 = !_descriptors$1 && !_fails$1(function () {
    return Object.defineProperty(_domCreate$1('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var _toPrimitive$1 = function _toPrimitive(it, S) {
    if (!_isObject$1(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject$1(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject$1(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject$1(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP$6 = Object.defineProperty;
  var f$8 = _descriptors$1 ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject$1(O);
    P = _toPrimitive$1(P, true);
    _anObject$1(Attributes);
    if (_ie8DomDefine$1) try {
      return dP$6(O, P, Attributes);
    } catch (e) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp$1 = {
    f: f$8
  };

  var _propertyDesc$1 = function _propertyDesc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide$1 = _descriptors$1 ? function (object, key, value) {
    return _objectDp$1.f(object, key, _propertyDesc$1(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty$1 = {}.hasOwnProperty;

  var _has$1 = function _has(it, key) {
    return hasOwnProperty$1.call(it, key);
  };

  var PROTOTYPE$3 = 'prototype';

  var $export$1 = function $export(type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core$1 : _core$1[name] || (_core$1[name] = {});
    var expProto = exports[PROTOTYPE$3];
    var target = IS_GLOBAL ? _global$1 : IS_STATIC ? _global$1[name] : (_global$1[name] || {})[PROTOTYPE$3];
    var key, own, out;
    if (IS_GLOBAL) source = name;

    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has$1(exports, key)) continue; // export native or passed

      out = own ? target[key] : source[key]; // prevent global pollution for namespaces

      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
      : IS_BIND && own ? _ctx$1(out, _global$1) // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? function (C) {
        var F = function F(a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0:
                return new C();

              case 1:
                return new C(a);

              case 2:
                return new C(a, b);
            }

            return new C(a, b, c);
          }

          return C.apply(this, arguments);
        };

        F[PROTOTYPE$3] = C[PROTOTYPE$3];
        return F; // make static versions for prototype methods
      }(out) : IS_PROTO && typeof out == 'function' ? _ctx$1(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

        if (type & $export.R && expProto && !expProto[key]) _hide$1(expProto, key, out);
      }
    }
  }; // type bitmap


  $export$1.F = 1; // forced

  $export$1.G = 2; // global

  $export$1.S = 4; // static

  $export$1.P = 8; // proto

  $export$1.B = 16; // bind

  $export$1.W = 32; // wrap

  $export$1.U = 64; // safe

  $export$1.R = 128; // real proto method for `library`

  var _export$1 = $export$1;

  _export$1(_export$1.G, {
    global: _global$1
  });

  var global$1 = _core$1.global;

  var lib = createCommonjsModule(function (module) {

    var _global = _interopRequireDefault(global$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
      console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
    }

    _global["default"]._babelPolyfill = true;
  });

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var t;

  var i$3 = globalThis.trustedTypes,
      s = i$3 ? i$3.createPolicy("lit-html", {
    createHTML: function createHTML(t) {
      return t;
    }
  }) : void 0,
      e = "lit$".concat((Math.random() + "").slice(9), "$"),
      o = "?" + e,
      n = "<".concat(o, ">"),
      l$1 = document,
      h = function h() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return l$1.createComment(t);
  },
      r = function r(t) {
    return null === t || "object" != typeof t && "function" != typeof t;
  },
      d = Array.isArray,
      u = function u(t) {
    var i;
    return d(t) || "function" == typeof (null === (i = t) || void 0 === i ? void 0 : i[Symbol.iterator]);
  },
      c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
      v = /-->/g,
      a = />/g,
      f$9 = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,
      _ = /'/g,
      m = /"/g,
      g = /^(?:script|style|textarea|title)$/i,
      p = function p(t) {
    return function (i) {
      for (var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        s[_key - 1] = arguments[_key];
      }

      return {
        _$litType$: t,
        strings: i,
        values: s
      };
    };
  },
      $ = p(1),
      b = Symbol.for("lit-noChange"),
      w = Symbol.for("lit-nothing"),
      T = new WeakMap(),
      x = function x(t, i, s) {
    var e, o;
    var n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;
    var l = n._$litPart$;

    if (void 0 === l) {
      var _t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;

      n._$litPart$ = l = new N(i.insertBefore(h(), _t), _t, void 0, null != s ? s : {});
    }

    return l._$AI(t), l;
  },
      A = l$1.createTreeWalker(l$1, 129, null, !1),
      C = function C(t, i) {
    var o = t.length - 1,
        l = [];
    var h,
        r = 2 === i ? "<svg>" : "",
        d = c;

    for (var _i = 0; _i < o; _i++) {
      var _s = t[_i];

      var _o = void 0,
          _u = void 0,
          _p = -1,
          _$ = 0;

      for (; _$ < _s.length && (d.lastIndex = _$, _u = d.exec(_s), null !== _u);) {
        _$ = d.lastIndex, d === c ? "!--" === _u[1] ? d = v : void 0 !== _u[1] ? d = a : void 0 !== _u[2] ? (g.test(_u[2]) && (h = RegExp("</" + _u[2], "g")), d = f$9) : void 0 !== _u[3] && (d = f$9) : d === f$9 ? ">" === _u[0] ? (d = null != h ? h : c, _p = -1) : void 0 === _u[1] ? _p = -2 : (_p = d.lastIndex - _u[2].length, _o = _u[1], d = void 0 === _u[3] ? f$9 : '"' === _u[3] ? m : _) : d === m || d === _ ? d = f$9 : d === v || d === a ? d = c : (d = f$9, h = void 0);
      }

      var _y = d === f$9 && t[_i + 1].startsWith("/>") ? " " : "";

      r += d === c ? _s + n : _p >= 0 ? (l.push(_o), _s.slice(0, _p) + "$lit$" + _s.slice(_p) + e + _y) : _s + e + (-2 === _p ? (l.push(void 0), _i) : _y);
    }

    var u = r + (t[o] || "<?>") + (2 === i ? "</svg>" : "");
    if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [void 0 !== s ? s.createHTML(u) : u, l];
  };

  var E = /*#__PURE__*/function () {
    function E(_ref, n) {
      var t = _ref.strings,
          s = _ref._$litType$;

      _classCallCheck(this, E);

      var l;
      this.parts = [];
      var r = 0,
          d = 0;

      var u = t.length - 1,
          c = this.parts,
          _C = C(t, s),
          _C2 = _slicedToArray(_C, 2),
          v = _C2[0],
          a = _C2[1];

      if (this.el = E.createElement(v, n), A.currentNode = this.el.content, 2 === s) {
        var _t2 = this.el.content,
            _i2 = _t2.firstChild;
        _i2.remove(), _t2.append.apply(_t2, _toConsumableArray(_i2.childNodes));
      }

      for (; null !== (l = A.nextNode()) && c.length < u;) {
        if (1 === l.nodeType) {
          if (l.hasAttributes()) {
            var _t3 = [];

            var _iterator = _createForOfIteratorHelper(l.getAttributeNames()),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _i5 = _step.value;

                if (_i5.endsWith("$lit$") || _i5.startsWith(e)) {
                  var _s2 = a[d++];

                  if (_t3.push(_i5), void 0 !== _s2) {
                    var _t5 = l.getAttribute(_s2.toLowerCase() + "$lit$").split(e),
                        _i6 = /([.?@])?(.*)/.exec(_s2);

                    c.push({
                      type: 1,
                      index: r,
                      name: _i6[2],
                      strings: _t5,
                      ctor: "." === _i6[1] ? M : "?" === _i6[1] ? H : "@" === _i6[1] ? I : S
                    });
                  } else c.push({
                    type: 6,
                    index: r
                  });
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            for (var _i3 = 0, _t4 = _t3; _i3 < _t4.length; _i3++) {
              var _i4 = _t4[_i3];
              l.removeAttribute(_i4);
            }
          }

          if (g.test(l.tagName)) {
            var _t6 = l.textContent.split(e),
                _s3 = _t6.length - 1;

            if (_s3 > 0) {
              l.textContent = i$3 ? i$3.emptyScript : "";

              for (var _i7 = 0; _i7 < _s3; _i7++) {
                l.append(_t6[_i7], h()), A.nextNode(), c.push({
                  type: 2,
                  index: ++r
                });
              }

              l.append(_t6[_s3], h());
            }
          }
        } else if (8 === l.nodeType) if (l.data === o) c.push({
          type: 2,
          index: r
        });else {
          var _t7 = -1;

          for (; -1 !== (_t7 = l.data.indexOf(e, _t7 + 1));) {
            c.push({
              type: 7,
              index: r
            }), _t7 += e.length - 1;
          }
        }

        r++;
      }
    }

    _createClass(E, null, [{
      key: "createElement",
      value: function createElement(t, i) {
        var s = l$1.createElement("template");
        return s.innerHTML = t, s;
      }
    }]);

    return E;
  }();

  function P(t, i) {
    var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;
    var e = arguments.length > 3 ? arguments[3] : undefined;
    var o, n, l, h;
    if (i === b) return i;
    var d = void 0 !== e ? null === (o = s._$Cl) || void 0 === o ? void 0 : o[e] : s._$Cu;
    var u = r(i) ? void 0 : i._$litDirective$;
    return (null == d ? void 0 : d.constructor) !== u && (null === (n = null == d ? void 0 : d._$AO) || void 0 === n || n.call(d, !1), void 0 === u ? d = void 0 : (d = new u(t), d._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Cl) && void 0 !== l ? l : h._$Cl = [])[e] = d : s._$Cu = d), void 0 !== d && (i = P(t, d._$AS(t, i.values), d, e)), i;
  }

  var V = /*#__PURE__*/function () {
    function V(t, i) {
      _classCallCheck(this, V);

      this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
    }

    _createClass(V, [{
      key: "parentNode",
      get: function get() {
        return this._$AM.parentNode;
      }
    }, {
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "p",
      value: function p(t) {
        var i;
        var _this$_$AD = this._$AD,
            s = _this$_$AD.el.content,
            e = _this$_$AD.parts,
            o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : l$1).importNode(s, !0);
        A.currentNode = o;
        var n = A.nextNode(),
            h = 0,
            r = 0,
            d = e[0];

        for (; void 0 !== d;) {
          if (h === d.index) {
            var _i8 = void 0;

            2 === d.type ? _i8 = new N(n, n.nextSibling, this, t) : 1 === d.type ? _i8 = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (_i8 = new L(n, this, t)), this.v.push(_i8), d = e[++r];
          }

          h !== (null == d ? void 0 : d.index) && (n = A.nextNode(), h++);
        }

        return o;
      }
    }, {
      key: "m",
      value: function m(t) {
        var i = 0;

        var _iterator2 = _createForOfIteratorHelper(this.v),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _s4 = _step2.value;
            void 0 !== _s4 && (void 0 !== _s4.strings ? (_s4._$AI(t, _s4, i), i += _s4.strings.length - 2) : _s4._$AI(t[i])), i++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }]);

    return V;
  }();

  var N = /*#__PURE__*/function () {
    function N(t, i, s, e) {
      _classCallCheck(this, N);

      var o;
      this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cg = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;
    }

    _createClass(N, [{
      key: "_$AU",
      get: function get() {
        var t, i;
        return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cg;
      }
    }, {
      key: "parentNode",
      get: function get() {
        var t = this._$AA.parentNode;
        var i = this._$AM;
        return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;
      }
    }, {
      key: "startNode",
      get: function get() {
        return this._$AA;
      }
    }, {
      key: "endNode",
      get: function get() {
        return this._$AB;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        t = P(this, t, i), r(t) ? t === w || null == t || "" === t ? (this._$AH !== w && this._$AR(), this._$AH = w) : t !== this._$AH && t !== b && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : u(t) ? this.S(t) : this.$(t);
      }
    }, {
      key: "M",
      value: function M(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._$AB;
        return this._$AA.parentNode.insertBefore(t, i);
      }
    }, {
      key: "k",
      value: function k(t) {
        this._$AH !== t && (this._$AR(), this._$AH = this.M(t));
      }
    }, {
      key: "$",
      value: function $(t) {
        this._$AH !== w && r(this._$AH) ? this._$AA.nextSibling.data = t : this.k(l$1.createTextNode(t)), this._$AH = t;
      }
    }, {
      key: "T",
      value: function T(t) {
        var i;
        var s = t.values,
            e = t._$litType$,
            o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = E.createElement(e.h, this.options)), e);
        if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.m(s);else {
          var _t8 = new V(o, this),
              _i9 = _t8.p(this.options);

          _t8.m(s), this.k(_i9), this._$AH = _t8;
        }
      }
    }, {
      key: "_$AC",
      value: function _$AC(t) {
        var i = T.get(t.strings);
        return void 0 === i && T.set(t.strings, i = new E(t)), i;
      }
    }, {
      key: "S",
      value: function S(t) {
        d(this._$AH) || (this._$AH = [], this._$AR());
        var i = this._$AH;
        var s,
            e = 0;

        var _iterator3 = _createForOfIteratorHelper(t),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _o2 = _step3.value;
            e === i.length ? i.push(s = new N(this.M(h()), this.M(h()), this, this.options)) : s = i[e], s._$AI(_o2), e++;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);
      }
    }, {
      key: "_$AR",
      value: function _$AR() {
        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._$AA.nextSibling;
        var i = arguments.length > 1 ? arguments[1] : undefined;
        var s;

        for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {
          var _i10 = t.nextSibling;
          t.remove(), t = _i10;
        }
      }
    }, {
      key: "setConnected",
      value: function setConnected(t) {
        var i;
        void 0 === this._$AM && (this._$Cg = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));
      }
    }]);

    return N;
  }();

  var S = /*#__PURE__*/function () {
    function S(t, i, s, e, o) {
      _classCallCheck(this, S);

      this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = w;
    }

    _createClass(S, [{
      key: "tagName",
      get: function get() {
        return this.element.tagName;
      }
    }, {
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var s = arguments.length > 2 ? arguments[2] : undefined;
        var e = arguments.length > 3 ? arguments[3] : undefined;
        var o = this.strings;
        var n = !1;
        if (void 0 === o) t = P(this, t, i, 0), n = !r(t) || t !== this._$AH && t !== b, n && (this._$AH = t);else {
          var _e = t;

          var _l, _h;

          for (t = o[0], _l = 0; _l < o.length - 1; _l++) {
            _h = P(this, _e[s + _l], i, _l), _h === b && (_h = this._$AH[_l]), n || (n = !r(_h) || _h !== this._$AH[_l]), _h === w ? t = w : t !== w && (t += (null != _h ? _h : "") + o[_l + 1]), this._$AH[_l] = _h;
          }
        }
        n && !e && this.C(t);
      }
    }, {
      key: "C",
      value: function C(t) {
        t === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");
      }
    }]);

    return S;
  }();

  var M = /*#__PURE__*/function (_S) {
    _inherits(M, _S);

    var _super = _createSuper(M);

    function M() {
      var _this;

      _classCallCheck(this, M);

      _this = _super.apply(this, arguments), _this.type = 3;
      return _this;
    }

    _createClass(M, [{
      key: "C",
      value: function C(t) {
        this.element[this.name] = t === w ? void 0 : t;
      }
    }]);

    return M;
  }(S);

  var k$1 = i$3 ? i$3.emptyScript : "";

  var H = /*#__PURE__*/function (_S2) {
    _inherits(H, _S2);

    var _super2 = _createSuper(H);

    function H() {
      var _this2;

      _classCallCheck(this, H);

      _this2 = _super2.apply(this, arguments), _this2.type = 4;
      return _this2;
    }

    _createClass(H, [{
      key: "C",
      value: function C(t) {
        t && t !== w ? this.element.setAttribute(this.name, k$1) : this.element.removeAttribute(this.name);
      }
    }]);

    return H;
  }(S);

  var I = /*#__PURE__*/function (_S3) {
    _inherits(I, _S3);

    var _super3 = _createSuper(I);

    function I(t, i, s, e, o) {
      var _this3;

      _classCallCheck(this, I);

      _this3 = _super3.call(this, t, i, s, e, o), _this3.type = 5;
      return _this3;
    }

    _createClass(I, [{
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var s;
        if ((t = null !== (s = P(this, t, i, 0)) && void 0 !== s ? s : w) === b) return;
        var e = this._$AH,
            o = t === w && e !== w || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,
            n = t !== w && (e === w || o);
        o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(t) {
        var i, s;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);
      }
    }]);

    return I;
  }(S);

  var L = /*#__PURE__*/function () {
    function L(t, i, s) {
      _classCallCheck(this, L);

      this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
    }

    _createClass(L, [{
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        P(this, t);
      }
    }]);

    return L;
  }();

  var z = window.litHtmlPolyfillSupport;
  null == z || z(E, N), (null !== (t = globalThis.litHtmlVersions) && void 0 !== t ? t : globalThis.litHtmlVersions = []).push("2.2.3");

  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var t$1 = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
      e$1 = Symbol(),
      n$1 = new Map();

  var s$1 = /*#__PURE__*/function () {
    function s(t, n) {
      _classCallCheck(this, s);

      if (this._$cssResult$ = !0, n !== e$1) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t;
    }

    _createClass(s, [{
      key: "styleSheet",
      get: function get() {
        var e = n$1.get(this.cssText);
        return t$1 && void 0 === e && (n$1.set(this.cssText, e = new CSSStyleSheet()), e.replaceSync(this.cssText)), e;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.cssText;
      }
    }]);

    return s;
  }();

  var o$1 = function o(t) {
    return new s$1("string" == typeof t ? t : t + "", e$1);
  },
      r$1 = function r(t) {
    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      n[_key - 1] = arguments[_key];
    }

    var o = 1 === t.length ? t[0] : n.reduce(function (e, n, s) {
      return e + function (t) {
        if (!0 === t._$cssResult$) return t.cssText;
        if ("number" == typeof t) return t;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      }(n) + t[s + 1];
    }, t[0]);
    return new s$1(o, e$1);
  },
      i$4 = function i(e, n) {
    t$1 ? e.adoptedStyleSheets = n.map(function (t) {
      return t instanceof CSSStyleSheet ? t : t.styleSheet;
    }) : n.forEach(function (t) {
      var n = document.createElement("style"),
          s = window.litNonce;
      void 0 !== s && n.setAttribute("nonce", s), n.textContent = t.cssText, e.appendChild(n);
    });
  },
      S$1 = t$1 ? function (t) {
    return t;
  } : function (t) {
    return t instanceof CSSStyleSheet ? function (t) {
      var e = "";

      var _iterator = _createForOfIteratorHelper(t.cssRules),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _n = _step.value;
          e += _n.cssText;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return o$1(e);
    }(t) : t;
  };

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */

  var s$2;

  var e$2 = window.trustedTypes,
      r$2 = e$2 ? e$2.emptyScript : "",
      h$1 = window.reactiveElementPolyfillSupport,
      o$2 = {
    toAttribute(t, i) {
      switch (i) {
        case Boolean:
          t = t ? r$2 : null;
          break;

        case Object:
        case Array:
          t = null == t ? t : JSON.stringify(t);
      }

      return t;
    },

    fromAttribute(t, i) {
      var s = t;

      switch (i) {
        case Boolean:
          s = null !== t;
          break;

        case Number:
          s = null === t ? null : Number(t);
          break;

        case Object:
        case Array:
          try {
            s = JSON.parse(t);
          } catch (t) {
            s = null;
          }

      }

      return s;
    }

  },
      n$2 = function n(t, i) {
    return i !== t && (i == i || t == t);
  },
      l$2 = {
    attribute: !0,
    type: String,
    converter: o$2,
    reflect: !1,
    hasChanged: n$2
  };

  var a$1 = /*#__PURE__*/function (_HTMLElement) {
    _inherits(a, _HTMLElement);

    var _super = _createSuper(a);

    function a() {
      var _this;

      _classCallCheck(this, a);

      _this = _super.call(this), _this._$Et = new Map(), _this.isUpdatePending = !1, _this.hasUpdated = !1, _this._$Ei = null, _this.o();
      return _this;
    }

    _createClass(a, [{
      key: "o",
      value: function o() {
        var _this2 = this;

        var t;
        this._$Ep = new Promise(function (t) {
          return _this2.enableUpdating = t;
        }), this._$AL = new Map(), this._$Em(), this.requestUpdate(), null === (t = this.constructor.l) || void 0 === t || t.forEach(function (t) {
          return t(_this2);
        });
      }
    }, {
      key: "addController",
      value: function addController(t) {
        var i, s;
        (null !== (i = this._$Eg) && void 0 !== i ? i : this._$Eg = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t));
      }
    }, {
      key: "removeController",
      value: function removeController(t) {
        var i;
        null === (i = this._$Eg) || void 0 === i || i.splice(this._$Eg.indexOf(t) >>> 0, 1);
      }
    }, {
      key: "_$Em",
      value: function _$Em() {
        var _this3 = this;

        this.constructor.elementProperties.forEach(function (t, i) {
          _this3.hasOwnProperty(i) && (_this3._$Et.set(i, _this3[i]), delete _this3[i]);
        });
      }
    }, {
      key: "createRenderRoot",
      value: function createRenderRoot() {
        var t;
        var s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
        return i$4(s, this.constructor.elementStyles), s;
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var t;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$Eg) || void 0 === t || t.forEach(function (t) {
          var i;
          return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t);
        });
      }
    }, {
      key: "enableUpdating",
      value: function enableUpdating(t) {}
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var t;
        null === (t = this._$Eg) || void 0 === t || t.forEach(function (t) {
          var i;
          return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t);
        });
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(t, i, s) {
        this._$AK(t, s);
      }
    }, {
      key: "_$ES",
      value: function _$ES(t, i) {
        var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : l$2;
        var e, r;

        var h = this.constructor._$Eh(t, s);

        if (void 0 !== h && !0 === s.reflect) {
          var _n = (null !== (r = null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) && void 0 !== r ? r : o$2.toAttribute)(i, s.type);

          this._$Ei = t, null == _n ? this.removeAttribute(h) : this.setAttribute(h, _n), this._$Ei = null;
        }
      }
    }, {
      key: "_$AK",
      value: function _$AK(t, i) {
        var s, e, r;

        var h = this.constructor,
            n = h._$Eu.get(t);

        if (void 0 !== n && this._$Ei !== n) {
          var _t = h.getPropertyOptions(n),
              _l = _t.converter,
              _a2 = null !== (r = null !== (e = null === (s = _l) || void 0 === s ? void 0 : s.fromAttribute) && void 0 !== e ? e : "function" == typeof _l ? _l : null) && void 0 !== r ? r : o$2.fromAttribute;

          this._$Ei = n, this[n] = _a2(i, _t.type), this._$Ei = null;
        }
      }
    }, {
      key: "requestUpdate",
      value: function requestUpdate(t, i, s) {
        var e = !0;
        void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || n$2)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$Ei !== t && (void 0 === this._$EC && (this._$EC = new Map()), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$Ep = this._$E_());
      }
    }, {
      key: "_$E_",
      value: function () {
        var _$E_2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var t;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.isUpdatePending = !0;
                  _context.prev = 1;
                  _context.next = 4;
                  return this._$Ep;

                case 4:
                  _context.next = 9;
                  break;

                case 6:
                  _context.prev = 6;
                  _context.t0 = _context["catch"](1);
                  Promise.reject(_context.t0);

                case 9:
                  t = this.scheduleUpdate();
                  _context.t1 = null != t;

                  if (!_context.t1) {
                    _context.next = 14;
                    break;
                  }

                  _context.next = 14;
                  return t;

                case 14:
                  return _context.abrupt("return", !this.isUpdatePending);

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[1, 6]]);
        }));

        function _$E_() {
          return _$E_2.apply(this, arguments);
        }

        return _$E_;
      }()
    }, {
      key: "scheduleUpdate",
      value: function scheduleUpdate() {
        return this.performUpdate();
      }
    }, {
      key: "performUpdate",
      value: function performUpdate() {
        var _this4 = this;

        var t;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Et && (this._$Et.forEach(function (t, i) {
          return _this4[i] = t;
        }), this._$Et = void 0);
        var i = !1;
        var s = this._$AL;

        try {
          i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this._$Eg) || void 0 === t || t.forEach(function (t) {
            var i;
            return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t);
          }), this.update(s)) : this._$EU();
        } catch (t) {
          throw i = !1, this._$EU(), t;
        }

        i && this._$AE(s);
      }
    }, {
      key: "willUpdate",
      value: function willUpdate(t) {}
    }, {
      key: "_$AE",
      value: function _$AE(t) {
        var i;
        null === (i = this._$Eg) || void 0 === i || i.forEach(function (t) {
          var i;
          return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
      }
    }, {
      key: "_$EU",
      value: function _$EU() {
        this._$AL = new Map(), this.isUpdatePending = !1;
      }
    }, {
      key: "updateComplete",
      get: function get() {
        return this.getUpdateComplete();
      }
    }, {
      key: "getUpdateComplete",
      value: function getUpdateComplete() {
        return this._$Ep;
      }
    }, {
      key: "shouldUpdate",
      value: function shouldUpdate(t) {
        return !0;
      }
    }, {
      key: "update",
      value: function update(t) {
        var _this5 = this;

        void 0 !== this._$EC && (this._$EC.forEach(function (t, i) {
          return _this5._$ES(i, _this5[i], t);
        }), this._$EC = void 0), this._$EU();
      }
    }, {
      key: "updated",
      value: function updated(t) {}
    }, {
      key: "firstUpdated",
      value: function firstUpdated(t) {}
    }], [{
      key: "addInitializer",
      value: function addInitializer(t) {
        var i;
        null !== (i = this.l) && void 0 !== i || (this.l = []), this.l.push(t);
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        var _this6 = this;

        this.finalize();
        var t = [];
        return this.elementProperties.forEach(function (i, s) {
          var e = _this6._$Eh(s, i);

          void 0 !== e && (_this6._$Eu.set(e, s), t.push(e));
        }), t;
      }
    }, {
      key: "createProperty",
      value: function createProperty(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : l$2;

        if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {
          var _s = "symbol" == typeof t ? Symbol() : "__" + t,
              _e = this.getPropertyDescriptor(t, _s, i);

          void 0 !== _e && Object.defineProperty(this.prototype, t, _e);
        }
      }
    }, {
      key: "getPropertyDescriptor",
      value: function getPropertyDescriptor(t, i, s) {
        return {
          get() {
            return this[i];
          },

          set(e) {
            var r = this[t];
            this[i] = e, this.requestUpdate(t, r, s);
          },

          configurable: !0,
          enumerable: !0
        };
      }
    }, {
      key: "getPropertyOptions",
      value: function getPropertyOptions(t) {
        return this.elementProperties.get(t) || l$2;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this.hasOwnProperty("finalized")) return !1;
        this.finalized = !0;
        var t = Object.getPrototypeOf(this);

        if (t.finalize(), this.elementProperties = new Map(t.elementProperties), this._$Eu = new Map(), this.hasOwnProperty("properties")) {
          var _t2 = this.properties,
              _i = [].concat(_toConsumableArray(Object.getOwnPropertyNames(_t2)), _toConsumableArray(Object.getOwnPropertySymbols(_t2)));

          var _iterator = _createForOfIteratorHelper(_i),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _s2 = _step.value;
              this.createProperty(_s2, _t2[_s2]);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return this.elementStyles = this.finalizeStyles(this.styles), !0;
      }
    }, {
      key: "finalizeStyles",
      value: function finalizeStyles(i) {
        var s = [];

        if (Array.isArray(i)) {
          var _e2 = new Set(i.flat(1 / 0).reverse());

          var _iterator2 = _createForOfIteratorHelper(_e2),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _i2 = _step2.value;
              s.unshift(S$1(_i2));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else void 0 !== i && s.push(S$1(i));

        return s;
      }
    }, {
      key: "_$Eh",
      value: function _$Eh(t, i) {
        var s = i.attribute;
        return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0;
      }
    }]);

    return a;
  }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));

  a$1.finalized = !0, a$1.elementProperties = new Map(), a$1.elementStyles = [], a$1.shadowRootOptions = {
    mode: "open"
  }, null == h$1 || h$1({
    ReactiveElement: a$1
  }), (null !== (s$2 = globalThis.reactiveElementVersions) && void 0 !== s$2 ? s$2 : globalThis.reactiveElementVersions = []).push("1.3.2");

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var t$2;

  var i$5 = globalThis.trustedTypes,
      s$3 = i$5 ? i$5.createPolicy("lit-html", {
    createHTML: function createHTML(t) {
      return t;
    }
  }) : void 0,
      e$3 = "lit$".concat((Math.random() + "").slice(9), "$"),
      o$3 = "?" + e$3,
      n$3 = "<".concat(o$3, ">"),
      l$3 = document,
      h$2 = function h() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return l$3.createComment(t);
  },
      r$3 = function r(t) {
    return null === t || "object" != typeof t && "function" != typeof t;
  },
      d$1 = Array.isArray,
      u$1 = function u(t) {
    var i;
    return d$1(t) || "function" == typeof (null === (i = t) || void 0 === i ? void 0 : i[Symbol.iterator]);
  },
      c$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
      v$1 = /-->/g,
      a$2 = />/g,
      f$a = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,
      _$1 = /'/g,
      m$1 = /"/g,
      g$1 = /^(?:script|style|textarea|title)$/i,
      p$1 = function p(t) {
    return function (i) {
      for (var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        s[_key - 1] = arguments[_key];
      }

      return {
        _$litType$: t,
        strings: i,
        values: s
      };
    };
  },
      $$1 = p$1(1),
      y = p$1(2),
      b$1 = Symbol.for("lit-noChange"),
      w$1 = Symbol.for("lit-nothing"),
      T$1 = new WeakMap(),
      x$1 = function x(t, i, s) {
    var e, o;
    var n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;
    var l = n._$litPart$;

    if (void 0 === l) {
      var _t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;

      n._$litPart$ = l = new N$1(i.insertBefore(h$2(), _t), _t, void 0, null != s ? s : {});
    }

    return l._$AI(t), l;
  },
      A$1 = l$3.createTreeWalker(l$3, 129, null, !1),
      C$1 = function C(t, i) {
    var o = t.length - 1,
        l = [];
    var h,
        r = 2 === i ? "<svg>" : "",
        d = c$1;

    for (var _i = 0; _i < o; _i++) {
      var _s = t[_i];

      var _o = void 0,
          _u = void 0,
          _p = -1,
          _$ = 0;

      for (; _$ < _s.length && (d.lastIndex = _$, _u = d.exec(_s), null !== _u);) {
        _$ = d.lastIndex, d === c$1 ? "!--" === _u[1] ? d = v$1 : void 0 !== _u[1] ? d = a$2 : void 0 !== _u[2] ? (g$1.test(_u[2]) && (h = RegExp("</" + _u[2], "g")), d = f$a) : void 0 !== _u[3] && (d = f$a) : d === f$a ? ">" === _u[0] ? (d = null != h ? h : c$1, _p = -1) : void 0 === _u[1] ? _p = -2 : (_p = d.lastIndex - _u[2].length, _o = _u[1], d = void 0 === _u[3] ? f$a : '"' === _u[3] ? m$1 : _$1) : d === m$1 || d === _$1 ? d = f$a : d === v$1 || d === a$2 ? d = c$1 : (d = f$a, h = void 0);
      }

      var _y = d === f$a && t[_i + 1].startsWith("/>") ? " " : "";

      r += d === c$1 ? _s + n$3 : _p >= 0 ? (l.push(_o), _s.slice(0, _p) + "$lit$" + _s.slice(_p) + e$3 + _y) : _s + e$3 + (-2 === _p ? (l.push(void 0), _i) : _y);
    }

    var u = r + (t[o] || "<?>") + (2 === i ? "</svg>" : "");
    if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [void 0 !== s$3 ? s$3.createHTML(u) : u, l];
  };

  var E$1 = /*#__PURE__*/function () {
    function E(_ref, n) {
      var t = _ref.strings,
          s = _ref._$litType$;

      _classCallCheck(this, E);

      var l;
      this.parts = [];
      var r = 0,
          d = 0;

      var u = t.length - 1,
          c = this.parts,
          _C = C$1(t, s),
          _C2 = _slicedToArray(_C, 2),
          v = _C2[0],
          a = _C2[1];

      if (this.el = E.createElement(v, n), A$1.currentNode = this.el.content, 2 === s) {
        var _t2 = this.el.content,
            _i2 = _t2.firstChild;
        _i2.remove(), _t2.append.apply(_t2, _toConsumableArray(_i2.childNodes));
      }

      for (; null !== (l = A$1.nextNode()) && c.length < u;) {
        if (1 === l.nodeType) {
          if (l.hasAttributes()) {
            var _t3 = [];

            var _iterator = _createForOfIteratorHelper(l.getAttributeNames()),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _i5 = _step.value;

                if (_i5.endsWith("$lit$") || _i5.startsWith(e$3)) {
                  var _s2 = a[d++];

                  if (_t3.push(_i5), void 0 !== _s2) {
                    var _t5 = l.getAttribute(_s2.toLowerCase() + "$lit$").split(e$3),
                        _i6 = /([.?@])?(.*)/.exec(_s2);

                    c.push({
                      type: 1,
                      index: r,
                      name: _i6[2],
                      strings: _t5,
                      ctor: "." === _i6[1] ? M$1 : "?" === _i6[1] ? H$1 : "@" === _i6[1] ? I$1 : S$2
                    });
                  } else c.push({
                    type: 6,
                    index: r
                  });
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            for (var _i3 = 0, _t4 = _t3; _i3 < _t4.length; _i3++) {
              var _i4 = _t4[_i3];
              l.removeAttribute(_i4);
            }
          }

          if (g$1.test(l.tagName)) {
            var _t6 = l.textContent.split(e$3),
                _s3 = _t6.length - 1;

            if (_s3 > 0) {
              l.textContent = i$5 ? i$5.emptyScript : "";

              for (var _i7 = 0; _i7 < _s3; _i7++) {
                l.append(_t6[_i7], h$2()), A$1.nextNode(), c.push({
                  type: 2,
                  index: ++r
                });
              }

              l.append(_t6[_s3], h$2());
            }
          }
        } else if (8 === l.nodeType) if (l.data === o$3) c.push({
          type: 2,
          index: r
        });else {
          var _t7 = -1;

          for (; -1 !== (_t7 = l.data.indexOf(e$3, _t7 + 1));) {
            c.push({
              type: 7,
              index: r
            }), _t7 += e$3.length - 1;
          }
        }

        r++;
      }
    }

    _createClass(E, null, [{
      key: "createElement",
      value: function createElement(t, i) {
        var s = l$3.createElement("template");
        return s.innerHTML = t, s;
      }
    }]);

    return E;
  }();

  function P$1(t, i) {
    var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;
    var e = arguments.length > 3 ? arguments[3] : undefined;
    var o, n, l, h;
    if (i === b$1) return i;
    var d = void 0 !== e ? null === (o = s._$Cl) || void 0 === o ? void 0 : o[e] : s._$Cu;
    var u = r$3(i) ? void 0 : i._$litDirective$;
    return (null == d ? void 0 : d.constructor) !== u && (null === (n = null == d ? void 0 : d._$AO) || void 0 === n || n.call(d, !1), void 0 === u ? d = void 0 : (d = new u(t), d._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Cl) && void 0 !== l ? l : h._$Cl = [])[e] = d : s._$Cu = d), void 0 !== d && (i = P$1(t, d._$AS(t, i.values), d, e)), i;
  }

  var V$1 = /*#__PURE__*/function () {
    function V(t, i) {
      _classCallCheck(this, V);

      this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
    }

    _createClass(V, [{
      key: "parentNode",
      get: function get() {
        return this._$AM.parentNode;
      }
    }, {
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "p",
      value: function p(t) {
        var i;
        var _this$_$AD = this._$AD,
            s = _this$_$AD.el.content,
            e = _this$_$AD.parts,
            o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : l$3).importNode(s, !0);
        A$1.currentNode = o;
        var n = A$1.nextNode(),
            h = 0,
            r = 0,
            d = e[0];

        for (; void 0 !== d;) {
          if (h === d.index) {
            var _i8 = void 0;

            2 === d.type ? _i8 = new N$1(n, n.nextSibling, this, t) : 1 === d.type ? _i8 = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (_i8 = new L$1(n, this, t)), this.v.push(_i8), d = e[++r];
          }

          h !== (null == d ? void 0 : d.index) && (n = A$1.nextNode(), h++);
        }

        return o;
      }
    }, {
      key: "m",
      value: function m(t) {
        var i = 0;

        var _iterator2 = _createForOfIteratorHelper(this.v),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _s4 = _step2.value;
            void 0 !== _s4 && (void 0 !== _s4.strings ? (_s4._$AI(t, _s4, i), i += _s4.strings.length - 2) : _s4._$AI(t[i])), i++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }]);

    return V;
  }();

  var N$1 = /*#__PURE__*/function () {
    function N(t, i, s, e) {
      _classCallCheck(this, N);

      var o;
      this.type = 2, this._$AH = w$1, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cg = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;
    }

    _createClass(N, [{
      key: "_$AU",
      get: function get() {
        var t, i;
        return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cg;
      }
    }, {
      key: "parentNode",
      get: function get() {
        var t = this._$AA.parentNode;
        var i = this._$AM;
        return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;
      }
    }, {
      key: "startNode",
      get: function get() {
        return this._$AA;
      }
    }, {
      key: "endNode",
      get: function get() {
        return this._$AB;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        t = P$1(this, t, i), r$3(t) ? t === w$1 || null == t || "" === t ? (this._$AH !== w$1 && this._$AR(), this._$AH = w$1) : t !== this._$AH && t !== b$1 && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : u$1(t) ? this.S(t) : this.$(t);
      }
    }, {
      key: "M",
      value: function M(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._$AB;
        return this._$AA.parentNode.insertBefore(t, i);
      }
    }, {
      key: "k",
      value: function k(t) {
        this._$AH !== t && (this._$AR(), this._$AH = this.M(t));
      }
    }, {
      key: "$",
      value: function $(t) {
        this._$AH !== w$1 && r$3(this._$AH) ? this._$AA.nextSibling.data = t : this.k(l$3.createTextNode(t)), this._$AH = t;
      }
    }, {
      key: "T",
      value: function T(t) {
        var i;
        var s = t.values,
            e = t._$litType$,
            o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = E$1.createElement(e.h, this.options)), e);
        if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.m(s);else {
          var _t8 = new V$1(o, this),
              _i9 = _t8.p(this.options);

          _t8.m(s), this.k(_i9), this._$AH = _t8;
        }
      }
    }, {
      key: "_$AC",
      value: function _$AC(t) {
        var i = T$1.get(t.strings);
        return void 0 === i && T$1.set(t.strings, i = new E$1(t)), i;
      }
    }, {
      key: "S",
      value: function S(t) {
        d$1(this._$AH) || (this._$AH = [], this._$AR());
        var i = this._$AH;
        var s,
            e = 0;

        var _iterator3 = _createForOfIteratorHelper(t),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _o2 = _step3.value;
            e === i.length ? i.push(s = new N(this.M(h$2()), this.M(h$2()), this, this.options)) : s = i[e], s._$AI(_o2), e++;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);
      }
    }, {
      key: "_$AR",
      value: function _$AR() {
        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._$AA.nextSibling;
        var i = arguments.length > 1 ? arguments[1] : undefined;
        var s;

        for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {
          var _i10 = t.nextSibling;
          t.remove(), t = _i10;
        }
      }
    }, {
      key: "setConnected",
      value: function setConnected(t) {
        var i;
        void 0 === this._$AM && (this._$Cg = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));
      }
    }]);

    return N;
  }();

  var S$2 = /*#__PURE__*/function () {
    function S(t, i, s, e, o) {
      _classCallCheck(this, S);

      this.type = 1, this._$AH = w$1, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = w$1;
    }

    _createClass(S, [{
      key: "tagName",
      get: function get() {
        return this.element.tagName;
      }
    }, {
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var s = arguments.length > 2 ? arguments[2] : undefined;
        var e = arguments.length > 3 ? arguments[3] : undefined;
        var o = this.strings;
        var n = !1;
        if (void 0 === o) t = P$1(this, t, i, 0), n = !r$3(t) || t !== this._$AH && t !== b$1, n && (this._$AH = t);else {
          var _e = t;

          var _l, _h;

          for (t = o[0], _l = 0; _l < o.length - 1; _l++) {
            _h = P$1(this, _e[s + _l], i, _l), _h === b$1 && (_h = this._$AH[_l]), n || (n = !r$3(_h) || _h !== this._$AH[_l]), _h === w$1 ? t = w$1 : t !== w$1 && (t += (null != _h ? _h : "") + o[_l + 1]), this._$AH[_l] = _h;
          }
        }
        n && !e && this.C(t);
      }
    }, {
      key: "C",
      value: function C(t) {
        t === w$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");
      }
    }]);

    return S;
  }();

  var M$1 = /*#__PURE__*/function (_S) {
    _inherits(M, _S);

    var _super = _createSuper(M);

    function M() {
      var _this;

      _classCallCheck(this, M);

      _this = _super.apply(this, arguments), _this.type = 3;
      return _this;
    }

    _createClass(M, [{
      key: "C",
      value: function C(t) {
        this.element[this.name] = t === w$1 ? void 0 : t;
      }
    }]);

    return M;
  }(S$2);

  var k$2 = i$5 ? i$5.emptyScript : "";

  var H$1 = /*#__PURE__*/function (_S2) {
    _inherits(H, _S2);

    var _super2 = _createSuper(H);

    function H() {
      var _this2;

      _classCallCheck(this, H);

      _this2 = _super2.apply(this, arguments), _this2.type = 4;
      return _this2;
    }

    _createClass(H, [{
      key: "C",
      value: function C(t) {
        t && t !== w$1 ? this.element.setAttribute(this.name, k$2) : this.element.removeAttribute(this.name);
      }
    }]);

    return H;
  }(S$2);

  var I$1 = /*#__PURE__*/function (_S3) {
    _inherits(I, _S3);

    var _super3 = _createSuper(I);

    function I(t, i, s, e, o) {
      var _this3;

      _classCallCheck(this, I);

      _this3 = _super3.call(this, t, i, s, e, o), _this3.type = 5;
      return _this3;
    }

    _createClass(I, [{
      key: "_$AI",
      value: function _$AI(t) {
        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var s;
        if ((t = null !== (s = P$1(this, t, i, 0)) && void 0 !== s ? s : w$1) === b$1) return;
        var e = this._$AH,
            o = t === w$1 && e !== w$1 || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,
            n = t !== w$1 && (e === w$1 || o);
        o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(t) {
        var i, s;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);
      }
    }]);

    return I;
  }(S$2);

  var L$1 = /*#__PURE__*/function () {
    function L(t, i, s) {
      _classCallCheck(this, L);

      this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
    }

    _createClass(L, [{
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "_$AI",
      value: function _$AI(t) {
        P$1(this, t);
      }
    }]);

    return L;
  }();

  var R = {
    L: "$lit$",
    P: e$3,
    V: o$3,
    I: 1,
    N: C$1,
    R: V$1,
    j: u$1,
    D: P$1,
    H: N$1,
    F: S$2,
    O: H$1,
    W: I$1,
    B: M$1,
    Z: L$1
  },
      z$1 = window.litHtmlPolyfillSupport;
  null == z$1 || z$1(E$1, N$1), (null !== (t$2 = globalThis.litHtmlVersions) && void 0 !== t$2 ? t$2 : globalThis.litHtmlVersions = []).push("2.2.3");

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */

  var l$4, o$4;

  var s$4 = /*#__PURE__*/function (_t) {
    _inherits(s, _t);

    var _super = _createSuper(s);

    function s() {
      var _this;

      _classCallCheck(this, s);

      _this = _super.apply(this, arguments), _this.renderOptions = {
        host: _assertThisInitialized(_this)
      }, _this._$Dt = void 0;
      return _this;
    }

    _createClass(s, [{
      key: "createRenderRoot",
      value: function createRenderRoot() {
        var t, e;

        var i = _get(_getPrototypeOf(s.prototype), "createRenderRoot", this).call(this);

        return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = i.firstChild), i;
      }
    }, {
      key: "update",
      value: function update(t) {
        var i = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), _get(_getPrototypeOf(s.prototype), "update", this).call(this, t), this._$Dt = x$1(i, this.renderRoot, this.renderOptions);
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var t;
        _get(_getPrototypeOf(s.prototype), "connectedCallback", this).call(this), null === (t = this._$Dt) || void 0 === t || t.setConnected(!0);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var t;
        _get(_getPrototypeOf(s.prototype), "disconnectedCallback", this).call(this), null === (t = this._$Dt) || void 0 === t || t.setConnected(!1);
      }
    }, {
      key: "render",
      value: function render() {
        return b$1;
      }
    }]);

    return s;
  }(a$1);

  s$4.finalized = !0, s$4._$litElement$ = !0, null === (l$4 = globalThis.litElementHydrateSupport) || void 0 === l$4 || l$4.call(globalThis, {
    LitElement: s$4
  });
  var n$4 = globalThis.litElementPolyfillSupport;
  null == n$4 || n$4({
    LitElement: s$4
  });
  (null !== (o$4 = globalThis.litElementVersions) && void 0 !== o$4 ? o$4 : globalThis.litElementVersions = []).push("3.2.0");

  // https://github.com/Polymer/lit-element/issues/450

  var id$2 = 0;
  var userSelectNoneOnBodyRegister = new Set();

  var ScElement = /*#__PURE__*/function (_LitElement) {
    _inherits(ScElement, _LitElement);

    var _super = _createSuper(ScElement);

    function ScElement() {
      var _this;

      _classCallCheck(this, ScElement);

      _this = _super.call(this);
      _this._scId = "".concat(_this.constructor.name.toLowerCase(), "-").concat(id$2++);
      return _this;
    }

    _createClass(ScElement, [{
      key: "_preventContextMenu",
      value: function _preventContextMenu(e) {
        e.preventDefault();
      }
    }, {
      key: "_requestUserSelectNoneOnBody",
      value: function _requestUserSelectNoneOnBody() {
        if (userSelectNoneOnBodyRegister.size === 0) {
          document.body.style.userSelect = 'none';
        }

        userSelectNoneOnBodyRegister.add(this._scId);
      }
    }, {
      key: "_cancelUserSelectNoneOnBody",
      value: function _cancelUserSelectNoneOnBody() {
        userSelectNoneOnBodyRegister.delete(this._scId);

        if (userSelectNoneOnBodyRegister.size === 0) {
          document.body.style.userSelect = 'auto';
        }
      }
    }]);

    return ScElement;
  }(s$4);

  var _templateObject, _templateObject2;

  var ScPositionSurface = /*#__PURE__*/function (_ScElement) {
    _inherits(ScPositionSurface, _ScElement);

    var _super = _createSuper(ScPositionSurface);

    function ScPositionSurface() {
      var _this;

      _classCallCheck(this, ScPositionSurface);

      _this = _super.call(this);
      _this.xRange = [0, 1];
      _this.yRange = [0, 1];
      _this.clampPositions = false;
      _this.activePointers = new Map();
      _this.pointerIds = []; // we want to keep the order of appearance consistant

      _this.mouseMove = _this.mouseMove.bind(_assertThisInitialized(_this));
      _this.mouseUp = _this.mouseUp.bind(_assertThisInitialized(_this));
      _this.touchStart = _this.touchStart.bind(_assertThisInitialized(_this));
      _this.touchMove = _this.touchMove.bind(_assertThisInitialized(_this));
      _this.touchEnd = _this.touchEnd.bind(_assertThisInitialized(_this));
      _this.propagateValues = _this.propagateValues.bind(_assertThisInitialized(_this));
      _this.rafId = null;
      return _this;
    }
    /**
     * this is ok as the surface is not rendered often
     */


    _createClass(ScPositionSurface, [{
      key: "performUpdate",
      value: function performUpdate() {
        var _this2 = this;

        var xDelta = this.xRange[1] - this.xRange[0];
        var yDelta = this.yRange[1] - this.yRange[0];

        this.px2x = function (px) {
          var val = px / _this2.width * xDelta + _this2.xRange[0];

          if (_this2.clampPositions) {
            val = Math.min(_this2.xRange[1], Math.max(_this2.xRange[0], val));
          }

          return val;
        };

        this.px2y = function (px) {
          var val = px / _this2.height * yDelta + _this2.yRange[0];

          if (_this2.clampPositions) {
            val = Math.min(_this2.yRange[1], Math.max(_this2.yRange[0], val));
          }

          return val;
        };

        _get(_getPrototypeOf(ScPositionSurface.prototype), "performUpdate", this).call(this);
      }
    }, {
      key: "render",
      value: function render() {
        return $$1(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      <div\n        style=\"width: ", "px; height: ", "px;\"\n\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      ></div>\n    "])), this.width, this.height, this.mouseDown, {
          handleEvent: this.touchStart,
          passive: false
        }, this._preventContextMenu);
      }
    }, {
      key: "mouseDown",
      value: function mouseDown(e) {
        window.addEventListener('mousemove', this.mouseMove, {
          passive: false
        });
        window.addEventListener('mouseup', this.mouseUp);
        this.pointerIds.push('mouse');
        this.activePointers.set('mouse', e);

        this._requestUserSelectNoneOnBody();

        this.requestPropagateValues(e);
      }
    }, {
      key: "mouseMove",
      value: function mouseMove(e) {
        this.activePointers.set('mouse', e);
        this.requestPropagateValues(e);
      }
    }, {
      key: "mouseUp",
      value: function mouseUp(e) {
        window.removeEventListener('mousemove', this.mouseMove);
        window.removeEventListener('mouseup', this.mouseUp);
        this.pointerIds.splice(this.pointerIds.indexOf('mouse'));
        this.activePointers.delete('mouse');

        this._cancelUserSelectNoneOnBody(); // propagate outside the shadow dom boudaries
        // cf. https://lit-element.polymer-project.org/guide/events#custom-events


        var event = new CustomEvent('pointerend', {
          bubbles: true,
          composed: true,
          detail: {
            pointerId: 'mouse'
          }
        });
        this.dispatchEvent(event);
        this.requestPropagateValues(e);
      }
    }, {
      key: "touchStart",
      value: function touchStart(e) {
        e.preventDefault(); // iOS needs that to prevent scrolling

        if (this.pointerIds.length === 0) {
          window.addEventListener('touchmove', this.touchMove, {
            passive: false
          });
          window.addEventListener('touchend', this.touchEnd);
          window.addEventListener('touchcancel', this.touchEnd);

          this._requestUserSelectNoneOnBody();
        }

        var _iterator = _createForOfIteratorHelper(e.changedTouches),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var touch = _step.value;
            var id = touch.identifier;
            this.pointerIds.push(id);
            this.activePointers.set(id, touch);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.requestPropagateValues(e);
      }
    }, {
      key: "touchMove",
      value: function touchMove(e) {
        e.preventDefault(); // prevent scrolling

        var _iterator2 = _createForOfIteratorHelper(e.changedTouches),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var touch = _step2.value;
            var id = touch.identifier; // only consider touches that started in the area

            if (this.pointerIds.indexOf(id) !== -1) {
              this.activePointers.set(id, touch);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.requestPropagateValues(e);
      }
    }, {
      key: "touchEnd",
      value: function touchEnd(e) {
        var _iterator3 = _createForOfIteratorHelper(e.changedTouches),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var touch = _step3.value;
            var pointerId = touch.identifier;
            var index = this.pointerIds.indexOf(pointerId); // only consider tracked touches

            if (index !== -1) {
              this.pointerIds.splice(index, 1);
              this.activePointers.delete(pointerId); // propagate outside the shadow dom boudaries
              // cf. https://lit-element.polymer-project.org/guide/events#custom-events

              var event = new CustomEvent('pointerend', {
                bubbles: true,
                composed: true,
                detail: {
                  pointerId
                }
              });
              this.dispatchEvent(event);
            }
          } // if that's the last tracked event remove listeners

        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        if (this.pointerIds.length === 0) {
          window.removeEventListener('touchmove', this.touchMove);
          window.removeEventListener('touchend', this.touchEnd);
          window.removeEventListener('touchcancel', this.touchEnd);

          this._cancelUserSelectNoneOnBody(e);
        }

        this.requestPropagateValues(e);
      }
    }, {
      key: "requestPropagateValues",
      value: function requestPropagateValues(e) {
        var _this3 = this;

        window.cancelAnimationFrame(this.rafId);
        this.rafId = window.requestAnimationFrame(function () {
          return _this3.propagateValues(e);
        });
      }
    }, {
      key: "propagateValues",
      value: function propagateValues(e) {
        var _this4 = this;

        var rect = this.getBoundingClientRect();
        var values = this.pointerIds.map(function (pointerId) {
          var event = _this4.activePointers.get(pointerId); // this seems quite robust
          // https://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element/18053642#18053642


          var x = event.clientX - rect.left;

          var scaledX = _this4.px2x(x);

          var y = event.clientY - rect.top;

          var scaledY = _this4.px2y(y);

          return {
            x: scaledX,
            y: scaledY,
            pointerId
          };
        }); // propagate outside the shadow dom boudaries
        // cf. https://lit-element.polymer-project.org/guide/events#custom-events

        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: values
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          xRange: {
            type: Array,
            attribute: 'x-range'
          },
          yRange: {
            type: Array,
            attribute: 'y-range'
          },
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          clamp: {
            type: Boolean,
            attribute: 'clamp'
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      :host {\n        display: inline-block;\n        box-sizing: border-box;\n      };\n    "])));
      }
    }]);

    return ScPositionSurface;
  }(ScElement);

  customElements.define('sc-position-surface', ScPositionSurface);

  var _templateObject$1, _templateObject2$1;

  function getTime$2() {
    if (window.performance) {
      return window.performance.now();
    } else {
      return Date.now();
    }
  }

  var ScSpeedSurface = /*#__PURE__*/function (_ScElement) {
    _inherits(ScSpeedSurface, _ScElement);

    var _super = _createSuper(ScSpeedSurface);

    function ScSpeedSurface() {
      var _this;

      _classCallCheck(this, ScSpeedSurface);

      _this = _super.call(this);
      _this.width = 200;
      _this.height = 200;
      _this.pointerId = null;
      _this.lastPointer = null;
      _this.lastTime = null;
      _this.mouseMove = _this.mouseMove.bind(_assertThisInitialized(_this));
      _this.mouseUp = _this.mouseUp.bind(_assertThisInitialized(_this));
      _this.touchStart = _this.touchStart.bind(_assertThisInitialized(_this));
      _this.touchMove = _this.touchMove.bind(_assertThisInitialized(_this));
      _this.touchEnd = _this.touchEnd.bind(_assertThisInitialized(_this));
      _this.propagateValues = _this.propagateValues.bind(_assertThisInitialized(_this));
      _this.rafId = null;
      return _this;
    }

    _createClass(ScSpeedSurface, [{
      key: "render",
      value: function render() {
        return $$1(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n      <div\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      ></div>\n    "])), this.width, this.height, this.mouseDown, {
          handleEvent: this.touchStart,
          passive: false
        }, this._preventContextMenu);
      }
    }, {
      key: "mouseDown",
      value: function mouseDown(e) {
        window.addEventListener('mousemove', this.mouseMove);
        window.addEventListener('mouseup', this.mouseUp);

        this._requestUserSelectNoneOnBody();

        this.pointerId = 'mouse';
        this.lastTime = getTime$2();
        this.lastPointer = e;
      }
    }, {
      key: "mouseMove",
      value: function mouseMove(e) {
        this.requestPropagateValues(e);
      }
    }, {
      key: "mouseUp",
      value: function mouseUp(e) {
        var _this2 = this;

        window.removeEventListener('mousemove', this.mouseMove);
        window.removeEventListener('mouseup', this.mouseUp);

        this._cancelUserSelectNoneOnBody();

        this.requestPropagateValues(e); // we want to have { dx: 0, dy: 0 } on mouse up,
        // with 20ms, we should be in the next requestAnimationFrame

        setTimeout(function () {
          _this2.pointerId = null;

          _this2.requestPropagateValues(e);
        }, 20);
      } // @eventOptions({ passive: false })

    }, {
      key: "touchStart",
      value: function touchStart(e) {
        e.preventDefault(); // prevent scrolling

        if (this.pointerId === null) {
          var touch = e.changedTouches[0];
          this.pointerId = touch.identifier;
          window.addEventListener('touchmove', this.touchMove, {
            passive: false
          });
          window.addEventListener('touchend', this.touchEnd);
          window.addEventListener('touchcancel', this.touchEnd);

          this._requestUserSelectNoneOnBody();

          this.lastTime = getTime$2();
          this.lastPointer = touch;
        }
      }
    }, {
      key: "touchMove",
      value: function touchMove(e) {
        e.preventDefault(); // prevent scrolling

        var _iterator = _createForOfIteratorHelper(e.changedTouches),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var touch = _step.value;

            if (touch.identifier === this.pointerId) {
              this.requestPropagateValues(touch);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "touchEnd",
      value: function touchEnd(e) {
        var _this3 = this;

        var _iterator2 = _createForOfIteratorHelper(e.changedTouches),
            _step2;

        try {
          var _loop = function _loop() {
            var touch = _step2.value;

            if (touch.identifier === _this3.pointerId) {
              window.removeEventListener('touchmove', _this3.touchMove);
              window.removeEventListener('touchend', _this3.touchEnd);
              window.removeEventListener('touchcancel', _this3.touchEnd);

              _this3._cancelUserSelectNoneOnBody();

              _this3.requestPropagateValues(touch); // we want to have { dx: 0, dy: 0 } on mouse up,
              // with 20ms, we should be in the next requestAnimationFrame


              setTimeout(function () {
                _this3.pointerId = null;

                _this3.requestPropagateValues(touch);
              }, 20);
            }
          };

          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "requestPropagateValues",
      value: function requestPropagateValues(e) {
        var _this4 = this;

        window.cancelAnimationFrame(this.rafId);
        this.rafId = window.requestAnimationFrame(function () {
          return _this4.propagateValues(e);
        });
      } // return speed in px / ms

    }, {
      key: "propagateValues",
      value: function propagateValues(e) {
        var lastX = this.lastPointer.screenX;
        var lastY = this.lastPointer.screenY;
        var x = e.screenX;
        var y = e.screenY;
        var now = getTime$2();
        var dt = this.lastTime - now;
        var dx = (x - lastX) / dt;
        var dy = (y - lastY) / dt;
        this.lastTime = now;
        this.lastPointer = e; // propagate outside the shadow dom boudaries
        // cf. https://lit-element.polymer-project.org/guide/events#custom-events

        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            dx,
            dy,
            pointerId: this.pointerId
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["\n      :host {\n        display: inline-block;\n        box-sizing: border-box;\n      };\n    "])));
      }
    }]);

    return ScSpeedSurface;
  }(ScElement);

  customElements.define('sc-speed-surface', ScSpeedSurface);

  var _templateObject$2, _templateObject2$2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;

  var fontFamily = r$1(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["Consolas, monaco, monospace"])));
  var fontSize = r$1(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["11px"])));
  var theme = {};
  theme['--color-primary-0'] = r$1(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["#121212ff"])));
  theme['--color-primary-1'] = r$1(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["#272822ff"])));
  theme['--color-primary-2'] = r$1(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["#3d3e39ff"])));
  theme['--color-primary-3'] = r$1(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["#6a6a69ff"])));
  theme['--color-primary-4'] = r$1(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["#dededeff"])));
  theme['--color-secondary-1'] = r$1(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["#f0db4fff"]))); // yellow

  theme['--color-secondary-2'] = r$1(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["#1c78c0ff"]))); // blue

  theme['--color-secondary-3'] = r$1(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["#d9534fff"]))); // red

  theme['--color-secondary-4'] = r$1(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["#5ec451ff"]))); // green
  // export const userSelectNone = css`
  //   -webkit-touch-callout: none; /* iOS Safari */
  //     -webkit-user-select: none; /* Safari */
  //      -khtml-user-select: none; /* Konqueror HTML */
  //        -moz-user-select: none; /* Old versions of Firefox */
  //         -ms-user-select: none; /* Internet Explorer/Edge */
  //             user-select: none; /* Non-prefixed version, currently
  //                                   supported by Chrome, Edge, Opera and Firefox */
  // `
  // export const largeBtn = css`
  //   font-family: ${fontFamily};
  //   color: white;
  //   font-size: 1.6rem;
  //   width: 100%;
  //   border: 1px solid #676767;
  //   border-radius: 2px;
  //   background-color: #121212;
  //   height: 36px;
  //   line-height: 36px;
  // `;
  // export const info = css`
  //   font-family: ${fontFamily};
  //   color: white;
  //   font-size: 1.2rem;
  //   width: 100%;
  //   text-align: center;
  //   height: 36px;
  //   line-height: 36px;
  // `;

  var arrow = r$1(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfkCAUKBTL+mGjUAAAAeUlEQVRIx+3OMQ6AIBBE0a93sMLEk1h4Y7Ww9mRiRUIM6jJUGob6/QXqfrCGkbbAHw0bE14+v8PAjBffwgDgWCS+4sJXlETElcSF5yYSPCdxw62JB25JvPC3hIE/JYz8LpHBU4lMfk0IPE6IPCRWepUDdHQlvO4jOwFwgu1NCrBo/wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wOC0wNVQxMDowNTo0OSswMDowMBWQx3oAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMDgtMDVUMTA6MDU6NDkrMDA6MDBkzX/GAAAAIHRFWHRzb2Z0d2FyZQBodHRwczovL2ltYWdlbWFnaWNrLm9yZ7zPHZ0AAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6SGVpZ2h0ADUxMo+NU4EAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgANTEyHHwD3AAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk2NjIxOTQ5QVn8gAAAABJ0RVh0VGh1bWI6OlNpemUAMzI2MEJCw0lk+gAAAFR0RVh0VGh1bWI6OlVSSQBmaWxlOi8vLi91cGxvYWRzLzU2L2V4dHg3bGQvMjQ1Ni9pbmRpY2F0b3JfYXJyb3dfdHJpYW5nbGVfaWNvbl8xNDkwMjAucG5n2GvxiAAAAABJRU5ErkJggg=="])));
  var arrowRight = r$1(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAQAAAAAYLlVAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAA7DgAAOw4AXEryjgAAAAHdElNRQflAxQLDS8ArDZ8AAACgklEQVRo3u3ZT0gUURzA8e+sstgSlmtg9MeCIoKKIIQCu0TZIbxIBdmhKDxZhw7mQYICQRCsU1B4CA8ReJEg+nMpKQjBTT0UERHlYmQGGUWYmOt0aHm9Ic2ZN7/9LYRvbnvY+fDmz/e9XVgaRR4l837qkSbFdPFYh3nGEGdYUZzTVzCIj88Mt9lNQh9QTRY/f3yglVXFBPjM8oC9uvMQBPj4THCJ1fqAKcaYyxNyPKaOUl3AKAe5wXczD5N0sk4TkKWaJI2MmHmYI0MDSU0AwEau8dXMwzeuskkXAEkaGCRnEM85zjJNAMBauvhsCFP0sE0XACUc4qk1D685zXJNAEAV7UwYwjS97MLTBECCfTxk1iCynJWO1r8BAJW08d4QxKO1OAA89nCHmcJEKwwAoJxzvCtEtMICwGMnvfyQjlZ4AECKJl4ZQo4n8aMVDQCwlR7JaEUHQJlktFwAIBgtV4BYtNwBIBKteACBaMUFQMxoSQB+R+tRIFqNugCANG18MYQM6fmchR0/8aOfS+oS1HLfugRjnNIEVHGBj9ZN2EeN3k1YygH6rcfwDc2aj+Ea2gMvoltsj/oVcV7F9QyYJPm84KTmq3gDlwMx6mazwww6Aso4wrCV42GOauZ4C92BBckV1ruePDogxQleWkuyAer1lmQeO7hpLUo/0aG5KC2nmbfWsryf/XrL8gQ19Fkbk3Euam5MKmkJbM3uUau3Nfs7Mq2slDv5YoBYkYkLiB2ZeACByLgDhCLjChCLjAsgKRmZqIBR6rguGZmogOCP1QKRiQr4cwhFxg0gGBkXgGhkwo40mXxk7spGJvw4xhAjnNf4285b4NMKPCatfd3S+H/HLwusPWkzmFSAAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTAzLTIwVDExOjEzOjQ3KzAwOjAwRxN4GAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wMy0yMFQxMToxMzo0NyswMDowMDZOwKQAAAAgdEVYdHNvZnR3YXJlAGh0dHBzOi8vaW1hZ2VtYWdpY2sub3JnvM8dnQAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpIZWlnaHQANTEyj41TgQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA1MTIcfAPcAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADE2MTYyMzg4MjfA6B9qAAAAEnRFWHRUaHVtYjo6U2l6ZQA1MTU5QkJP1GlWAAAAUHRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8uL3VwbG9hZHMvNTYvaEpIZnVxcC8yOTAyL2Fycm93X3JpZ2h0X3RyaWFuZ2xlX2ljb25fMTgzMTIxLnBuZ8GglZQAAAAASUVORK5CYII="])));
  var arrowDown = r$1(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["data:image/png;base64,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"])));

  var _templateObject$3, _templateObject2$3;

  var ScButton = /*#__PURE__*/function (_ScElement) {
    _inherits(ScButton, _ScElement);

    var _super = _createSuper(ScButton);

    function ScButton() {
      var _this;

      _classCallCheck(this, ScButton);

      _this = _super.call(this);
      _this.width = 200;
      _this.height = 30;
      _this.text = '';
      _this.value = null;
      _this.selected = false;
      _this._pressed = false;
      _this.onEvent = _this.onEvent.bind(_assertThisInitialized(_this));
      return _this;
    }
    /**
     * @todo - add `down` and `up` events
     */


    _createClass(ScButton, [{
      key: "render",
      value: function render() {
        var text = this.text ? this.text : this.value;
        return $$1(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n      <button\n        style=\"\n          width: ", "px;\n          height: ", "px;\n          line-height: ", "px;\n        \"\n        class=\"", "\"\n        @mousedown=\"", "\"\n        @mouseup=\"", "\"\n\n        @touchstart=\"", "\"\n        @touchend=\"", "\"\n        @contextmenu=\"", "\"\n      >", "</button>\n    "])), this.width, this.height, this.height, this.selected ? 'selected' : '', this.onEvent, this.onEvent, {
          handleEvent: this.onEvent,
          passive: false
        }, this.onEvent, this._preventContextMenu, text);
      }
    }, {
      key: "onEvent",
      value: function onEvent(e) {
        e.preventDefault();
        var eventName;

        if (e.type === 'touchend' || e.type === 'mouseup') {
          eventName = 'release';
        } else {
          eventName = 'press';
        } // we don't want to trigger a release if no pressed has been recorded


        if (eventName === 'release' && this._pressed === false) {
          return;
        }

        this._pressed = eventName === 'press';
        var event = new CustomEvent(eventName, {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.dispatchEvent(event);

        if (eventName === 'press') {
          var inputEvent = new CustomEvent('input', {
            bubbles: true,
            composed: true,
            detail: {
              value: this.value
            }
          });
          this.dispatchEvent(inputEvent);
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          text: {
            type: String
          },
          value: {
            type: String
          },
          selected: {
            type: Boolean
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        overflow: hidden;\n      }\n\n      button {\n        box-sizing: border-box;\n        font-family: ", ";\n        font-size: ", ";\n        color: #ffffff;\n        background-color: ", ";\n        border: 1px solid ", ";\n        border-radius:  1px;\n        font-size: 13px;\n        padding: 0;\n      }\n\n      button:hover {\n        background-color: ", ";\n        cursor: pointer;\n      }\n\n      button:active {\n        background-color: ", ";\n      }\n\n\n      button.selected {\n        background-color: ", ";\n        border: 1px solid ", ";\n      }\n\n      // not really visible\n      button:focus {\n        outline: none;\n      }\n    "])), fontFamily, fontSize, theme['--color-primary-1'], theme['--color-primary-2'], theme['--color-primary-2'], theme['--color-primary-3'], theme['--color-secondary-3'], theme['--color-secondary-3']);
      }
    }]);

    return ScButton;
  }(ScElement);

  customElements.define('sc-button', ScButton);

  var _templateObject$4, _templateObject2$4, _templateObject3$1, _templateObject4$1;

  var ScToggle = /*#__PURE__*/function (_ScElement) {
    _inherits(ScToggle, _ScElement);

    var _super = _createSuper(ScToggle);

    function ScToggle() {
      var _this;

      _classCallCheck(this, ScToggle);

      _this = _super.call(this);
      _this.width = 30;
      _this.active = false;
      _this.updateValue = _this.updateValue.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(ScToggle, [{
      key: "width",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "height",
      get: function get() {
        return this._size;
      } // alias active for consistency and genericity with other components
      ,
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "value",
      get: function get() {
        return this.active;
      },
      set: function set(active) {
        this.active = active;
      }
    }, {
      key: "render",
      value: function render() {
        var padding = 25;
        var strokeWidth = 10;
        return $$1(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n      <svg\n        style=\"width: ", "px; height: ", "px;\"\n        viewbox=\"0 0 100 100\"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n\n        @contextmenu=\"", "\"\n      >\n        <rect\n          x=\"0\"\n          y=\"0\"\n          width=\"100\"\n          height=\"100\"\n          fill=\"", "\"\n        ></rect>\n        ", "\n      </svg>\n    "])), this._size, this._size, this.updateValue, {
          handleEvent: this.updateValue,
          passive: false
        }, this._preventContextMenu, theme['--color-primary-1'], this.active ? y(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral(["\n              <line\n                x1=\"", "\"\n                y1=\"", "\"\n                x2=\"", "\"\n                y2=\"", "\"\n                style=\"stroke-width:", "; stroke:#ffffff;\" />\n              <line\n                x1=\"", "\"\n                y1=\"", "\"\n                x2=\"", "\"\n                y2=\"", "\"\n                style=\"stroke-width:", "; stroke:#ffffff;\" />\n            "])), padding, padding, 100 - padding, 100 - padding, strokeWidth, padding, 100 - padding, 100 - padding, padding, strokeWidth) : y(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["\n              <line\n                x1=\"", "\"\n                y1=\"", "\"\n                x2=\"", "\"\n                y2=\"", "\"\n                style=\"stroke-width:", "; stroke:", ";\" />\n              <line\n                x1=\"", "\"\n                y1=\"", "\"\n                x2=\"", "\"\n                y2=\"", "\"\n                style=\"stroke-width:", "; stroke:", ";\" />\n            "])), padding, padding, 100 - padding, 100 - padding, strokeWidth, theme['--color-primary-3'], padding, 100 - padding, 100 - padding, padding, strokeWidth, theme['--color-primary-3']));
      }
    }, {
      key: "updateValue",
      value: function updateValue(e) {
        e.preventDefault();
        e.stopPropagation();
        this.active = !this.active;
        var changeEvent = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.active
          }
        });
        this.dispatchEvent(changeEvent);
        this.requestUpdate();
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          active: {
            type: Boolean,
            reflect: true
          },
          value: {
            type: Boolean
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        user-select: none;\n        font-size: 0 !important;\n      }\n\n      svg {\n        box-sizing: border-box;\n        border: 1px solid ", ";\n      }\n    "])), theme['--color-primary-2']);
      }
    }]);

    return ScToggle;
  }(ScElement);

  customElements.define('sc-toggle', ScToggle);

  function getScale(domain, range) {
    var slope = (range[1] - range[0]) / (domain[1] - domain[0]);
    var intercept = range[0] - slope * domain[0];

    function scale(val) {
      return slope * val + intercept;
    }

    scale.invert = function (val) {
      return (val - intercept) / slope;
    };

    return scale;
  }

  function getClipper(min, max, step) {
    return function (val) {
      var clippedValue = Math.round(val / step) * step;
      var fixed = Math.max(Math.log10(1 / step), 0);
      var fixedValue = clippedValue.toFixed(fixed); // fix floating point errors

      return Math.min(max, Math.max(min, parseFloat(fixedValue)));
    };
  }

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var t$3 = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
  },
      e$4 = function e(t) {
    return function () {
      for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
        e[_key] = arguments[_key];
      }

      return {
        _$litDirective$: t,
        values: e
      };
    };
  };

  var i$6 = /*#__PURE__*/function () {
    function i(t) {
      _classCallCheck(this, i);
    }

    _createClass(i, [{
      key: "_$AU",
      get: function get() {
        return this._$AM._$AU;
      }
    }, {
      key: "_$AT",
      value: function _$AT(t, e, _i) {
        this._$Ct = t, this._$AM = e, this._$Ci = _i;
      }
    }, {
      key: "_$AS",
      value: function _$AS(t, e) {
        return this.update(t, e);
      }
    }, {
      key: "update",
      value: function update(t, e) {
        return this.render.apply(this, _toConsumableArray(e));
      }
    }]);

    return i;
  }();

  /**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */

  var o$5 = e$4( /*#__PURE__*/function (_s) {
    _inherits(_class, _s);

    var _super = _createSuper(_class);

    function _class(t) {
      var _this;

      _classCallCheck(this, _class);

      var i;
      if (_this = _super.call(this, t), t.type !== t$3.ATTRIBUTE || "class" !== t.name || (null === (i = t.strings) || void 0 === i ? void 0 : i.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
      return _possibleConstructorReturn(_this);
    }

    _createClass(_class, [{
      key: "render",
      value: function render(t) {
        return " " + Object.keys(t).filter(function (i) {
          return t[i];
        }).join(" ") + " ";
      }
    }, {
      key: "update",
      value: function update(i, _ref) {
        var _this2 = this;

        var _ref2 = _slicedToArray(_ref, 1),
            s = _ref2[0];

        var r, o;

        if (void 0 === this.et) {
          this.et = new Set(), void 0 !== i.strings && (this.st = new Set(i.strings.join(" ").split(/\s/).filter(function (t) {
            return "" !== t;
          })));

          for (var _t in s) {
            s[_t] && !(null === (r = this.st) || void 0 === r ? void 0 : r.has(_t)) && this.et.add(_t);
          }

          return this.render(s);
        }

        var e = i.element.classList;
        this.et.forEach(function (t) {
          t in s || (e.remove(t), _this2.et.delete(t));
        });

        for (var _t2 in s) {
          var _i = !!s[_t2];

          _i === this.et.has(_t2) || (null === (o = this.st) || void 0 === o ? void 0 : o.has(_t2)) || (_i ? (e.add(_t2), this.et.add(_t2)) : (e.remove(_t2), this.et.delete(_t2)));
        }

        return b$1;
      }
    }]);

    return _class;
  }(i$6));

  /**
   * @desc 解决浮动运算问题，避免小数点后产生多位数和计算精度损失。
   * 问题示例：2.3 + 2.4 = 4.699999999999999，1.0 - 0.9 = 0.09999999999999998
   */

  /**
   * 把错误的数据转正
   * strip(0.09999999999999998)=0.1
   */
  function strip(num, precision) {
    if (precision === void 0) {
      precision = 15;
    }

    return +parseFloat(Number(num).toPrecision(precision));
  }
  /**
   * Return digits length of a number
   * @param {*number} num Input number
   */


  function digitLength(num) {
    // Get digit length of e
    var eSplit = num.toString().split(/[eE]/);
    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
  }
  /**
   * 把小数转成整数，支持科学计数法。如果是小数则放大成整数
   * @param {*number} num 输入数
   */


  function float2Fixed(num) {
    if (num.toString().indexOf('e') === -1) {
      return Number(num.toString().replace('.', ''));
    }

    var dLen = digitLength(num);
    return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
  }
  /**
   * 检测数字是否越界，如果越界给出提示
   * @param {*number} num 输入数
   */


  function checkBoundary(num) {
    if (_boundaryCheckingState) {
      if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
        console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
      }
    }
  }
  /**
   * 迭代操作
   */


  function iteratorOperation(arr, operation) {
    var num1 = arr[0],
        num2 = arr[1],
        others = arr.slice(2);
    var res = operation(num1, num2);
    others.forEach(function (num) {
      res = operation(res, num);
    });
    return res;
  }
  /**
   * 精确乘法
   */


  function times() {
    var nums = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }

    if (nums.length > 2) {
      return iteratorOperation(nums, times);
    }

    var num1 = nums[0],
        num2 = nums[1];
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    var baseNum = digitLength(num1) + digitLength(num2);
    var leftValue = num1Changed * num2Changed;
    checkBoundary(leftValue);
    return leftValue / Math.pow(10, baseNum);
  }
  /**
   * 精确加法
   */


  function plus() {
    var nums = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }

    if (nums.length > 2) {
      return iteratorOperation(nums, plus);
    }

    var num1 = nums[0],
        num2 = nums[1]; // 取最大的小数位

    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2))); // 把小数都转为整数然后再计算

    return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
  }
  /**
   * 精确减法
   */


  function minus() {
    var nums = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }

    if (nums.length > 2) {
      return iteratorOperation(nums, minus);
    }

    var num1 = nums[0],
        num2 = nums[1];
    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
    return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
  }
  /**
   * 精确除法
   */


  function divide$1() {
    var nums = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }

    if (nums.length > 2) {
      return iteratorOperation(nums, divide$1);
    }

    var num1 = nums[0],
        num2 = nums[1];
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    checkBoundary(num1Changed);
    checkBoundary(num2Changed); // fix: 类似 10 ** -4 为 0.00009999999999999999，strip 修正

    return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
  }
  /**
   * 四舍五入
   */


  function round(num, ratio) {
    var base = Math.pow(10, ratio);
    var result = divide$1(Math.round(Math.abs(times(num, base))), base);

    if (num < 0 && result !== 0) {
      result = times(result, -1);
    }

    return result;
  }

  var _boundaryCheckingState = true;
  /**
   * 是否进行边界检查，默认开启
   * @param flag 标记开关，true 为开启，false 为关闭，默认为 true
   */

  function enableBoundaryChecking(flag) {
    if (flag === void 0) {
      flag = true;
    }

    _boundaryCheckingState = flag;
  }

  var index = {
    strip: strip,
    plus: plus,
    minus: minus,
    times: times,
    divide: divide$1,
    round: round,
    digitLength: digitLength,
    float2Fixed: float2Fixed,
    enableBoundaryChecking: enableBoundaryChecking
  };

  var _templateObject$5, _templateObject2$5, _templateObject3$2;

  var ScNumber = /*#__PURE__*/function (_ScElement) {
    _inherits(ScNumber, _ScElement);

    var _super = _createSuper(ScNumber);

    function ScNumber() {
      var _this;

      _classCallCheck(this, ScNumber);

      _this = _super.call(this);
      _this.width = 100;
      _this.height = 30;
      _this.integer = false;
      _this._min = -Infinity;
      _this._max = +Infinity;
      _this._value = 0;
      _this._displayValue = '0'; // init through setters
      // this.min = -Infinity;
      // this.max = +Infinity;
      // this.value = 0;

      _this._valueChanged = false;
      _this._updateValue1 = _this.updateValueFromPointer(1);
      _this._updateValue01 = _this.updateValueFromPointer(0.1);
      _this._updateValue001 = _this.updateValueFromPointer(0.01);
      _this._updateValue0001 = _this.updateValueFromPointer(0.001);
      _this._updateValue00001 = _this.updateValueFromPointer(0.0001);
      _this._updateValue000001 = _this.updateValueFromPointer(0.00001);
      _this._updateValue0000001 = _this.updateValueFromPointer(0.000001);
      _this._numKeyPressed = 0;
      _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
      return _this;
    }
    /**
     * @note: do not remove spaces between <span> to avoid white space
     * https://stackoverflow.com/questions/5078239/how-do-i-remove-the-space-between-inline-inline-block-elements
     */


    _createClass(ScNumber, [{
      key: "min",
      get: function get() {
        return this._min;
      },
      set: function set(value) {
        this._min = Math.min(value, this._max);

        if (this._value < this._min) {
          this.value = this._min;

          this._emitChange();
        }
      }
    }, {
      key: "max",
      get: function get() {
        return this._max;
      },
      set: function set(value) {
        this._max = Math.max(value, this._min);

        if (this._value > this._max) {
          this.value = this._max;

          this._emitChange();
        }
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(val) {
        val = Math.min(this._max, Math.max(this._min, val));

        if (val !== this._value) {
          this._value = val;
          this._displayValue = val.toString();
          this.requestUpdate();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var parts = this._displayValue.split('.');

        if (!parts[1]) {
          parts[1] = [];
        }

        var emptySpace = ' ';
        var characterWidth = 7; // in pixels

        var isEdited = {
          edited: this._numKeyPressed !== 0
        };
        return $$1(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n      <div\n        tabindex=\"-1\"\n        class=\"container\"\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        @focus=\"", "\"\n        @blur=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      >\n        <div\n          class=\"info ", "\"\n          style=\"height: ", "px;\"\n        ></div>\n\n        <div\n          class=\"content\"\n          style=\"height: ", "px;\"\n        >\n\n          <span class=\"z\"\n            style=\"\n              height: ", "px;\n              line-height: ", "px;\n              width: ", "px;\n            \"\n          >\n            ", "\n            <sc-speed-surface\n              width=\"", "\"\n              height=\"", "\"\n              @input=\"", "\"\n            ></sc-speed-surface>\n          </span>\n          ", "\n        </div>\n      </div>\n    "])), this.width, this.height, this.onFocus, this.onBlur, this.triggerFocus, this._preventContextMenu, o$5(isEdited), this.height, this.height, this.height, this.height, characterWidth * parts[0].length, parts[0], characterWidth * Math.max(parts[0].length, 2), this.height, this._updateValue1, !this.integer ? $$1(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteral(["\n              <span class=\"z\" style=\"height: ", "px; line-height: ", "px\">\n                .\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>\n              <span class=\"z\"\n                style=\"\n                  height: ", "px;\n                  line-height: ", "px;\n                  width: ", "px;\n                \"\n              >\n                ", "\n                <sc-speed-surface\n                  width=\"", "\"\n                  height=\"", "\"\n                  @input=\"", "\"\n                ></sc-speed-surface>\n              </span>"])), this.height, this.height, this.height, this.height, characterWidth, parts[1][0] || emptySpace, characterWidth, this.height, this._updateValue01, this.height, this.height, characterWidth, parts[1][1] || emptySpace, characterWidth, this.height, this._updateValue001, this.height, this.height, characterWidth, parts[1][2] || emptySpace, characterWidth, this.height, this._updateValue0001, this.height, this.height, characterWidth, parts[1][3] || emptySpace, characterWidth, this.height, this._updateValue00001, this.height, this.height, characterWidth, parts[1][4] || emptySpace, characterWidth, this.height, this._updateValue000001, this.height, this.height, characterWidth, parts[1][5] || emptySpace, characterWidth, this.height, this._updateValue0000001) : w$1);
      } // force focus for touchstart (is prevented by speed-surfaces...)

    }, {
      key: "triggerFocus",
      value: function triggerFocus() {
        var $container = this.shadowRoot.querySelector('.container');
        $container.focus();
      } // keyboard interactions

    }, {
      key: "onFocus",
      value: function onFocus() {
        this._numKeyPressed = 0;
        window.addEventListener('keydown', this.onKeyDown);
      }
    }, {
      key: "onBlur",
      value: function onBlur() {
        this.updateValueFromDisplayValue();
        window.removeEventListener('keydown', this.onKeyDown);
      }
    }, {
      key: "onKeyDown",
      value: function onKeyDown(e) {
        var validSymbols = this.integer ? ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-'] : ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '.', ','];

        if (validSymbols.indexOf(e.key) !== -1) {
          if (this._numKeyPressed === 0) {
            this._displayValue = '';
          }

          var symbol = e.key;

          if (symbol === ',') {
            symbol = '.';
          }

          this._displayValue += symbol;
          this._numKeyPressed += 1;
          this.requestUpdate();
        } // handle backspace


        if (e.key === 'Backspace' || e.which === 8) {
          // if last character is '.' remove it automatically
          if (this._displayValue[this._displayValue.length - 1] === '.') {
            this._displayValue = this._displayValue.substring(0, this._displayValue.length - 1);
          }

          this._displayValue = this._displayValue.substring(0, this._displayValue.length - 1);
          this._numKeyPressed += 1;
          this.requestUpdate();
        } // Tab has the same effect as it triggers blur


        if (e.key === 'Enter' || e.which === 13) {
          this.updateValueFromDisplayValue();
        }
      }
    }, {
      key: "updateValueFromDisplayValue",
      value: function updateValueFromDisplayValue() {
        if (this._numKeyPressed > 0) {
          this._value = this.integer ? parseInt(this._displayValue) : parseFloat(this._displayValue); // modify displayValue only if needed

          if (this._value < this._min || this._value > this._max) {
            this._value = Math.max(this._min, Math.min(this._max, this._value));
            this._displayValue = this._value.toString();
          }

          this._numKeyPressed = 0;

          this._emitInput();

          this._emitChange();

          this.requestUpdate();
        }
      }
    }, {
      key: "updateValueFromPointer",
      value: function updateValueFromPointer(step) {
        var _this2 = this;

        return function (e) {
          e.stopPropagation(); // do all computation if not mouseup or touchend,
          // else only propagate the `change event`

          if (e.detail.pointerId !== null) {
            // ignore very small movements
            if (Math.abs(e.detail.dy) < 0.02) {
              return;
            }

            var lastValue = _this2._value;
            var sign = e.detail.dy < 0 ? -1 : 1; // heuristically adjust sensiblity

            var scale = 8;
            var exponent = 1.2; // apply scale and exponent factors

            var dy = Math.pow(Math.abs(e.detail.dy * scale), exponent); // clamp at 1

            dy = Math.max(1, dy); // reapply sign

            dy = dy * sign;
            _this2._value += step * dy; // crop at step (use precision arythmetics)

            _this2._value = index.times(Math.round(_this2._value / step), step);
            _this2._value = Math.max(_this2._min, Math.min(_this2._max, _this2._value)); // format display value to show trailing zeros...)

            var displayValue = _this2._value.toString();

            var valueParts = displayValue.toString().split('.');
            var stepDecimals = step.toString().split('.')[1];

            if (stepDecimals) {
              if (!valueParts[1]) {
                valueParts[1] = [];
              }

              while (valueParts[1].length < stepDecimals.length) {
                valueParts[1] += '0';
              }
            }

            _this2._displayValue = valueParts.join('.');

            if (_this2._value !== lastValue) {
              _this2._valueChanged = true;

              _this2._emitInput();
            }
          } else {
            // this triggers a change when we select the box without changing the value
            if (_this2._valueChanged === true) {
              _this2._valueChanged = false;

              _this2._emitChange();
            }
          }

          _this2.requestUpdate();
        };
      }
    }, {
      key: "_emitInput",
      value: function _emitInput() {
        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        });
        this.dispatchEvent(event);
      }
    }, {
      key: "_emitChange",
      value: function _emitChange() {
        var event = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          min: {
            type: Number
          },
          max: {
            type: Number
          },
          value: {
            type: Number
          },
          integer: {
            type: Boolean,
            reflect: true
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n      }\n\n      :host > div {\n        overflow-y: hidden;\n        position: relative;\n        box-sizing: border-box;\n        background-color: ", ";\n        border: 1px solid ", ";\n        font-family: ", ";\n        color: #ffffff;\n        user-select: none;\n      }\n\n      .container:focus {\n        outline: none;\n      }\n\n      .info {\n        width: 15px;\n        display: inline-block;\n        background-color: ", ";\n      }\n\n      .container:focus .info {\n        outline: 2px solid ", ";\n      }\n\n      .info.edited {\n        background-color: ", ";\n      }\n\n      .content {\n        display: inline-block;\n        position: absolute;\n        top: 0;\n        left: 15px;\n        padding-left: 4px;\n        font-size: 0;\n      }\n\n      .z {\n        display: inline-block;\n        vertical-align: top;\n        text-align: center;\n        position: relative;\n        font-size: ", ";\n      }\n\n      .z:first-child {\n        margin-left: 3px;\n      }\n\n      .z sc-speed-surface {\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 1;\n      }\n    "])), theme['--color-primary-1'], theme['--color-primary-2'], fontFamily, theme['--color-primary-2'], theme['--color-secondary-2'], theme['--color-primary-3'], fontSize);
      }
    }]);

    return ScNumber;
  }(ScElement);

  customElements.define('sc-number', ScNumber);

  var _templateObject$6, _templateObject2$6, _templateObject3$3, _templateObject4$2, _templateObject5$1;

  var ScSlider = /*#__PURE__*/function (_ScElement) {
    _inherits(ScSlider, _ScElement);

    var _super = _createSuper(ScSlider);

    function ScSlider() {
      var _this;

      _classCallCheck(this, ScSlider);

      _this = _super.call(this);
      _this.mode = 'jump'; // @todo: relative

      _this.width = 200;
      _this.height = 30;
      _this.min = 0;
      _this.max = 1;
      _this.step = 0.001;
      _this.value = 0.5;
      _this.orientation = 'horizontal';
      _this.displayNumber = false;
      _this.color = theme['--color-primary-4'];
      _this._marginSliderNumber = 3;
      _this._numberWidth = 80;
      _this._pointerId = null;
      _this._dirty = true;
      return _this;
    }

    _createClass(ScSlider, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        this._dirty = true;

        _get(_getPrototypeOf(ScSlider.prototype), "connectedCallback", this).call(this);
      }
    }, {
      key: "update",
      value: function update(changedProperties) {
        this._dirty = true;

        _get(_getPrototypeOf(ScSlider.prototype), "update", this).call(this, changedProperties);
      }
    }, {
      key: "render",
      value: function render() {
        if (this._dirty) {
          if (this.orientation === 'horizontal') {
            this._sliderWidth = this.displayNumber ? this.width - this._numberWidth - this._marginSliderNumber : this.width;
          } else {
            // @todo - clean vertical w/ number box
            this._sliderWidth = this.width;
          }

          this._sliderWidth -= 2; // take borders into account

          this._sliderHeight = this.height - 2; // take borders into account

          if (this.max < this.min) {
            var tmp = this.max;
            this.max = this.min;
            this.min = tmp;
          } // define transfert functions and scales


          this.scale = getScale([this.min, this.max], [0, this.orientation === 'horizontal' ? this._sliderWidth : this._sliderHeight]);
          this.clipper = getClipper(this.min, this.max, this.step); // clean default value

          this.value = this.clipper(this.value);
          this._dirty = false;
        }

        return $$1(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral(["\n      <div\n        @contextmenu=\"", "\"\n        style=\"width: ", "px; height: ", "px\"\n      >\n        <svg\n          style=\"width: ", "px; height: ", "px\"\n          viewport=\"0 0 ", " ", "\"\n        >\n          ", "\n        </svg>\n        <sc-position-surface\n          width=\"", "\"\n          height=\"", "\"\n          clamp\n          x-range=\"", "\"\n          y-range=\"", "\"\n          @input=\"", "\"\n          @pointerend=\"", "\"\n        ></sc-position-surface>\n      </div>\n      ", "\n    "])), this._preventContextMenu, this._sliderWidth, this._sliderHeight, this._sliderWidth, this._sliderHeight, this._sliderWidth, this._sliderHeight, this.orientation === 'horizontal' ? y(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteral(["\n              <rect class=\"background\" width=\"", "\" height=\"", "\"></rect>\n              <rect class=\"foreground\" width=\"", "\" height=\"", "\" fill=\"", "\"></rect>\n            "])), this._sliderWidth, this._sliderHeight, Math.max(0, this.scale(this.value)), this._sliderHeight, this.color) : y(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteral(["\n              <rect class=\"foreground\" width=\"", "\" height=\"", "\" fill=\"", "\"></rect>\n              <rect class=\"background\" width=\"", "\" height=\"", "\"></rect>\n            "])), this._sliderWidth, this._sliderHeight, this.color, this._sliderWidth, Math.max(0, this._sliderHeight - this.scale(this.value))), this._sliderWidth, this._sliderHeight, JSON.stringify([this.min, this.max]), JSON.stringify([this.max, this.min]), this.updateValue, this.changeValue, this.displayNumber ? $$1(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["\n          <sc-number\n            style=\"margin-left: ", "px\"\n            width=\"", "\"\n            min=\"", "\"\n            max=\"", "\"\n            value=\"", "\"\n            @input=\"", "\"\n          ></sc-number>\n        "])), this._marginSliderNumber, this._numberWidth, this.min, this.max, this.value, this.updateValueFromNumber) : w$1);
      }
    }, {
      key: "updateValueFromNumber",
      value: function updateValueFromNumber(e) {
        e.stopPropagation();
        this.value = this.clipper(e.detail.value);
        var inputEvent = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.dispatchEvent(inputEvent);
        var changeEvent = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.dispatchEvent(changeEvent);
        this.requestUpdate();
      }
    }, {
      key: "changeValue",
      value: function changeValue(e) {
        if (e.detail.pointerId === this._pointerId) {
          this._pointerId = null;
          var event = new CustomEvent('change', {
            bubbles: true,
            composed: true,
            detail: {
              value: this.value
            }
          });
          this.dispatchEvent(event);
        }
      }
    }, {
      key: "updateValue",
      value: function updateValue(e) {
        e.stopPropagation(); // override event from sc-position-surface
        // consider only first pointer in list, we don't want a multitouch slider...

        if (e.detail.value[0] && (this._pointerId === null || e.detail.value[0].pointerId === this._pointerId)) {
          var _e$detail$value$ = e.detail.value[0],
              x = _e$detail$value$.x,
              y = _e$detail$value$.y,
              pointerId = _e$detail$value$.pointerId;
          var value = this.orientation === 'horizontal' ? x : y;
          this._pointerId = pointerId;
          this.value = this.clipper(value);
          var event = new CustomEvent('input', {
            bubbles: true,
            composed: true,
            detail: {
              value: this.value
            }
          });
          this.dispatchEvent(event);
          this.requestUpdate();
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          // mode: {
          //   type: String
          // },
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          min: {
            type: Number
          },
          max: {
            type: Number
          },
          step: {
            type: Number
          },
          orientation: {
            type: String
          },
          displayNumber: {
            type: Boolean,
            attribute: 'display-number',
            reflect: true
          },
          value: {
            type: Number
          },
          color: {
            type: String
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        font-size: 0 !important;\n        vertical-align: top;\n        position: relative;\n      }\n\n      :host > div {\n        position: relative;\n        display: inline-block;\n        font-size: 0;\n        border: 1px solid ", ";\n        vertical-align: top;\n      }\n\n      sc-position-surface {\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 1;\n      }\n\n      rect.foreground {}\n\n      rect.background {\n        fill: ", ";\n      }\n\n      sc-number {\n        display: inline-block;\n      }\n    "])), theme['--color-primary-2'], theme['--color-primary-1']);
      }
    }]);

    return ScSlider;
  }(ScElement);

  customElements.define('sc-slider', ScSlider);

  var codemirror = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // This is CodeMirror (https://codemirror.net), a code editor
    // implemented in JavaScript on top of the browser's DOM.
    //
    // You can find some technical background for some of the code below
    // at http://marijnhaverbeke.nl/blog/#cm-internals .
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {
      // detected are enabled based on userAgent etc sniffing.

      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
      var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.

      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);

      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }

      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X


      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;

      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }

      var rmClass = function rmClass(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);

        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };

      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) {
          e.removeChild(e.firstChild);
        }

        return e;
      }

      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);

        if (className) {
          e.className = className;
        }

        if (style) {
          e.style.cssText = style;
        }

        if (typeof content == "string") {
          e.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i = 0; i < content.length; ++i) {
            e.appendChild(content[i]);
          }
        }

        return e;
      } // wrapper for elt, which removes the elt from the accessibility tree


      function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e;
      }

      var range;

      if (document.createRange) {
        range = function range(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      } else {
        range = function range(node, start, end) {
          var r = document.body.createTextRange();

          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }

          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      }

      function contains(parent, child) {
        if (child.nodeType == 3) // Android browser always returns false when child is a textnode
          {
            child = child.parentNode;
          }

        if (parent.contains) {
          return parent.contains(child);
        }

        do {
          if (child.nodeType == 11) {
            child = child.host;
          }

          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }

      function activeElt() {
        // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
        // IE < 10 will throw when accessed while the page is loading or in an iframe.
        // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
        var activeElement;

        try {
          activeElement = document.activeElement;
        } catch (e) {
          activeElement = document.body || null;
        }

        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
          activeElement = activeElement.shadowRoot.activeElement;
        }

        return activeElement;
      }

      function addClass(node, cls) {
        var current = node.className;

        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }

      function joinClasses(a, b) {
        var as = a.split(" ");

        for (var i = 0; i < as.length; i++) {
          if (as[i] && !classTest(as[i]).test(b)) {
            b += " " + as[i];
          }
        }

        return b;
      }

      var selectInput = function selectInput(node) {
        node.select();
      };

      if (ios) // Mobile Safari apparently has a bug where select() is broken.
        {
          selectInput = function selectInput(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) // Suppress mysterious IE10 errors
        {
          selectInput = function selectInput(node) {
            try {
              node.select();
            } catch (_e) {}
          };
        }

      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(null, args);
        };
      }

      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }

        for (var prop in obj) {
          if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
            target[prop] = obj[prop];
          }
        }

        return target;
      } // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.


      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);

          if (end == -1) {
            end = string.length;
          }
        }

        for (var i = startIndex || 0, n = startValue || 0;;) {
          var nextTab = string.indexOf("\t", i);

          if (nextTab < 0 || nextTab >= end) {
            return n + (end - i);
          }

          n += nextTab - i;
          n += tabSize - n % tabSize;
          i = nextTab + 1;
        }
      }

      var Delayed = function Delayed() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
      };

      Delayed.prototype.onTimeout = function (self) {
        self.id = 0;

        if (self.time <= +new Date()) {
          self.f();
        } else {
          setTimeout(self.handler, self.time - +new Date());
        }
      };

      Delayed.prototype.set = function (ms, f) {
        this.f = f;
        var time = +new Date() + ms;

        if (!this.id || time < this.time) {
          clearTimeout(this.id);
          this.id = setTimeout(this.handler, ms);
          this.time = time;
        }
      };

      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i) {
          if (array[i] == elt) {
            return i;
          }
        }

        return -1;
      } // Number of pixels added to scroller and sizer to hide scrollbar


      var scrollerGap = 50; // Returned or thrown by various protocols to signal 'I'm not
      // handling this'.

      var Pass = {
        toString: function toString() {
          return "CodeMirror.Pass";
        }
      }; // Reused option objects for setSelection & friends

      var sel_dontScroll = {
        scroll: false
      },
          sel_mouse = {
        origin: "*mouse"
      },
          sel_move = {
        origin: "+move"
      }; // The inverse of countColumn -- find the offset that corresponds to
      // a particular column.

      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
          var nextTab = string.indexOf("\t", pos);

          if (nextTab == -1) {
            nextTab = string.length;
          }

          var skipped = nextTab - pos;

          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }

          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;

          if (col >= goal) {
            return pos;
          }
        }
      }

      var spaceStrs = [""];

      function spaceStr(n) {
        while (spaceStrs.length <= n) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }

        return spaceStrs[n];
      }

      function lst(arr) {
        return arr[arr.length - 1];
      }

      function map(array, f) {
        var out = [];

        for (var i = 0; i < array.length; i++) {
          out[i] = f(array[i], i);
        }

        return out;
      }

      function insertSorted(array, value, score) {
        var pos = 0,
            priority = score(value);

        while (pos < array.length && score(array[pos]) <= priority) {
          pos++;
        }

        array.splice(pos, 0, value);
      }

      function nothing() {}

      function createObj(base, props) {
        var inst;

        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }

        if (props) {
          copyObj(props, inst);
        }

        return inst;
      }

      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      }

      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }

        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }

        return helper.test(ch);
      }

      function isEmpty(obj) {
        for (var n in obj) {
          if (obj.hasOwnProperty(n) && obj[n]) {
            return false;
          }
        }

        return true;
      } // Extending unicode characters. A series of a non-extending char +
      // any number of extending chars is treated as a single unit as far
      // as editing and measuring is concerned. This is not fully correct,
      // since some scripts/fonts/browsers also treat other configurations
      // of code points as a group.


      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.


      function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
          pos += dir;
        }

        return pos;
      } // Returns the value from the range [`from`; `to`] that satisfies
      // `pred` and is closest to `from`. Assumes that at least `to`
      // satisfies `pred`. Supports `from` being greater than `to`.


      function findFirst(pred, from, to) {
        // At any point we are certain `to` satisfies `pred`, don't know
        // whether `from` does.
        var dir = from > to ? -1 : 1;

        for (;;) {
          if (from == to) {
            return from;
          }

          var midF = (from + to) / 2,
              mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);

          if (mid == from) {
            return pred(mid) ? from : to;
          }

          if (pred(mid)) {
            to = mid;
          } else {
            from = mid + dir;
          }
        }
      } // BIDI HELPERS


      function iterateBidiSections(order, from, to, f) {
        if (!order) {
          return f(from, to, "ltr", 0);
        }

        var found = false;

        for (var i = 0; i < order.length; ++i) {
          var part = order[i];

          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
            found = true;
          }
        }

        if (!found) {
          f(from, to, "ltr");
        }
      }

      var bidiOther = null;

      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;

        for (var i = 0; i < order.length; ++i) {
          var cur = order[i];

          if (cur.from < ch && cur.to > ch) {
            return i;
          }

          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") {
              found = i;
            } else {
              bidiOther = i;
            }
          }

          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") {
              found = i;
            } else {
              bidiOther = i;
            }
          }
        }

        return found != null ? found : bidiOther;
      } // Bidirectional ordering algorithm
      // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
      // that this (partially) implements.
      // One-char codes used for character types:
      // L (L):   Left-to-Right
      // R (R):   Right-to-Left
      // r (AL):  Right-to-Left Arabic
      // 1 (EN):  European Number
      // + (ES):  European Number Separator
      // % (ET):  European Number Terminator
      // n (AN):  Arabic Number
      // , (CS):  Common Number Separator
      // m (NSM): Non-Spacing Mark
      // b (BN):  Boundary Neutral
      // s (B):   Paragraph Separator
      // t (S):   Segment Separator
      // w (WS):  Whitespace
      // N (ON):  Other Neutrals
      // Returns null if characters are ordered as they appear
      // (left-to-right), or an array of sections ({from, to, level}
      // objects) in the order in which they occur visually.


      var bidiOrdering = function () {
        // Character types for codepoints 0 to 0xff
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

        function charType(code) {
          if (code <= 0xf7) {
            return lowTypes.charAt(code);
          } else if (0x590 <= code && code <= 0x5f4) {
            return "R";
          } else if (0x600 <= code && code <= 0x6f9) {
            return arabicTypes.charAt(code - 0x600);
          } else if (0x6ee <= code && code <= 0x8ac) {
            return "r";
          } else if (0x2000 <= code && code <= 0x200b) {
            return "w";
          } else if (code == 0x200c) {
            return "b";
          } else {
            return "L";
          }
        }

        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;

        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }

        return function (str, direction) {
          var outerType = direction == "ltr" ? "L" : "R";

          if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
            return false;
          }

          var len = str.length,
              types = [];

          for (var i = 0; i < len; ++i) {
            types.push(charType(str.charCodeAt(i)));
          } // W1. Examine each non-spacing mark (NSM) in the level run, and
          // change the type of the NSM to the type of the previous
          // character. If the NSM is at the start of the level run, it will
          // get the type of sor.


          for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
            var type = types[i$1];

            if (type == "m") {
              types[i$1] = prev;
            } else {
              prev = type;
            }
          } // W2. Search backwards from each instance of a European number
          // until the first strong type (R, L, AL, or sor) is found. If an
          // AL is found, change the type of the European number to Arabic
          // number.
          // W3. Change all ALs to R.


          for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
            var type$1 = types[i$2];

            if (type$1 == "1" && cur == "r") {
              types[i$2] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;

              if (type$1 == "r") {
                types[i$2] = "R";
              }
            }
          } // W4. A single European separator between two European numbers
          // changes to a European number. A single common separator between
          // two numbers of the same type changes to that type.


          for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];

            if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
              types[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types[i$3] = prev$1;
            }

            prev$1 = type$2;
          } // W5. A sequence of European terminators adjacent to European
          // numbers changes to all European numbers.
          // W6. Otherwise, separators and terminators change to Other
          // Neutral.


          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];

            if (type$3 == ",") {
              types[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;

              for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}

              var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

              for (var j = i$4; j < end; ++j) {
                types[j] = replace;
              }

              i$4 = end - 1;
            }
          } // W7. Search backwards from each instance of a European number
          // until the first strong type (R, L, or sor) is found. If an L is
          // found, then change the type of the European number to L.


          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];

            if (cur$1 == "L" && type$4 == "1") {
              types[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          } // N1. A sequence of neutrals takes the direction of the
          // surrounding strong text if the text on both sides has the same
          // direction. European and Arabic numbers act as if they were R in
          // terms of their influence on neutrals. Start-of-level-run (sor)
          // and end-of-level-run (eor) are used at level run boundaries.
          // N2. Any remaining neutrals take the embedding direction.


          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = void 0;

              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}

              var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len ? types[end$1] : outerType) == "L";
              var replace$1 = before == after ? before ? "L" : "R" : outerType;

              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types[j$1] = replace$1;
              }

              i$6 = end$1 - 1;
            }
          } // Here we depart from the documented algorithm, in order to avoid
          // building up an actual levels array. Since there are only three
          // levels (0, 1, 2) in an implementation that doesn't take
          // explicit embedding into account, we can build up the order on
          // the fly, without following the level-based algorithm.


          var order = [],
              m;

          for (var i$7 = 0; i$7 < len;) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;

              for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}

              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7,
                  at = order.length,
                  isRTL = direction == "rtl" ? 1 : 0;

              for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}

              for (var j$2 = pos; j$2 < i$7;) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    at += isRTL;
                  }

                  var nstart = j$2;

                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}

                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  at += isRTL;
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }

              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }

          if (direction == "ltr") {
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
              order[0].from = m[0].length;
              order.unshift(new BidiSpan(0, 0, m[0].length));
            }

            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
              lst(order).to -= m[0].length;
              order.push(new BidiSpan(0, len - m[0].length, len));
            }
          }

          return direction == "rtl" ? order.reverse() : order;
        };
      }(); // Get the bidi ordering for the given line (and cache it). Returns
      // false for lines that are fully left-to-right, and an array of
      // BidiSpan objects otherwise.


      function getOrder(line, direction) {
        var order = line.order;

        if (order == null) {
          order = line.order = bidiOrdering(line.text, direction);
        }

        return order;
      } // EVENT HANDLING
      // Lightweight event framework. on/off also work on DOM nodes,
      // registering native DOM handlers.


      var noHandlers = [];

      var on = function on(emitter, type, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type, f);
        } else {
          var map = emitter._handlers || (emitter._handlers = {});
          map[type] = (map[type] || noHandlers).concat(f);
        }
      };

      function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
      }

      function off(emitter, type, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type, f);
        } else {
          var map = emitter._handlers,
              arr = map && map[type];

          if (arr) {
            var index = indexOf(arr, f);

            if (index > -1) {
              map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
            }
          }
        }
      }

      function signal(emitter, type
      /*, values...*/
      ) {
        var handlers = getHandlers(emitter, type);

        if (!handlers.length) {
          return;
        }

        var args = Array.prototype.slice.call(arguments, 2);

        for (var i = 0; i < handlers.length; ++i) {
          handlers[i].apply(null, args);
        }
      } // The DOM events that CodeMirror handles can be overridden by
      // registering a (non-DOM) handler on the editor for the event name,
      // and preventDefault-ing the event in that handler.


      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
          e = {
            type: e,
            preventDefault: function preventDefault() {
              this.defaultPrevented = true;
            }
          };
        }

        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }

      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;

        if (!arr) {
          return;
        }

        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);

        for (var i = 0; i < arr.length; ++i) {
          if (indexOf(set, arr[i]) == -1) {
            set.push(arr[i]);
          }
        }
      }

      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
      } // Add on and off methods to a constructor's prototype, to make
      // registering events on such objects more convenient.


      function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
          on(this, type, f);
        };

        ctor.prototype.off = function (type, f) {
          off(this, type, f);
        };
      } // Due to the fact that we still support jurassic IE versions, some
      // compatibility wrappers are needed.


      function e_preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }

      function e_stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }

      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }

      function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      }

      function e_target(e) {
        return e.target || e.srcElement;
      }

      function e_button(e) {
        var b = e.which;

        if (b == null) {
          if (e.button & 1) {
            b = 1;
          } else if (e.button & 2) {
            b = 3;
          } else if (e.button & 4) {
            b = 2;
          }
        }

        if (mac && e.ctrlKey && b == 1) {
          b = 3;
        }

        return b;
      } // Detect drag-and-drop


      var dragAndDrop = function () {
        // There is *some* kind of drag-and-drop support in IE6-8, but I
        // couldn't get it to work yet.
        if (ie && ie_version < 9) {
          return false;
        }

        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();

      var zwspSupported;

      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));

          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }

        var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      } // Feature-detect IE's crummy client rect reporting for bidi text


      var badBidiRects;

      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }

        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);

        if (!r0 || r0.left == r0.right) {
          return false;
        } // Safari returns null in some cases (#2780)


        return badBidiRects = r1.right - r0.right < 3;
      } // See if "".split is the broken IE version, if so, provide an
      // alternative way to split lines.


      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0,
            result = [],
            l = string.length;

        while (pos <= l) {
          var nl = string.indexOf("\n", pos);

          if (nl == -1) {
            nl = string.length;
          }

          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");

          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }

        return result;
      } : function (string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function (te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function (te) {
        var range;

        try {
          range = te.ownerDocument.selection.createRange();
        } catch (e) {}

        if (!range || range.parentElement() != te) {
          return false;
        }

        return range.compareEndPoints("StartToEnd", range) != 0;
      };

      var hasCopyEvent = function () {
        var e = elt("div");

        if ("oncopy" in e) {
          return true;
        }

        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      }();

      var badZoomedRects = null;

      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }

        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      } // Known modes, by name and by MIME


      var modes = {},
          mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)

      function defineMode(name, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }

        modes[name] = mode;
      }

      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      } // Given a MIME type, a {name, ...options} config object, or a name
      // string, return a mode config object.


      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];

          if (typeof found == "string") {
            found = {
              name: found
            };
          }

          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }

        if (typeof spec == "string") {
          return {
            name: spec
          };
        } else {
          return spec || {
            name: "null"
          };
        }
      } // Given a mode spec (anything that resolveMode accepts), find and
      // initialize an actual mode object.


      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];

        if (!mfactory) {
          return getMode(options, "text/plain");
        }

        var modeObj = mfactory(options, spec);

        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];

          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) {
              continue;
            }

            if (modeObj.hasOwnProperty(prop)) {
              modeObj["_" + prop] = modeObj[prop];
            }

            modeObj[prop] = exts[prop];
          }
        }

        modeObj.name = spec.name;

        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }

        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }

        return modeObj;
      } // This can be used to attach properties to mode objects from
      // outside the actual mode definition.


      var modeExtensions = {};

      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }

      function copyState(mode, state) {
        if (state === true) {
          return state;
        }

        if (mode.copyState) {
          return mode.copyState(state);
        }

        var nstate = {};

        for (var n in state) {
          var val = state[n];

          if (val instanceof Array) {
            val = val.concat([]);
          }

          nstate[n] = val;
        }

        return nstate;
      } // Given a mode and a state (for that mode), find the inner mode and
      // state at the position that the state refers to.


      function innerMode(mode, state) {
        var info;

        while (mode.innerMode) {
          info = mode.innerMode(state);

          if (!info || info.mode == mode) {
            break;
          }

          state = info.state;
          mode = info.mode;
        }

        return info || {
          mode: mode,
          state: state
        };
      }

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      } // STRING STREAM
      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.


      var StringStream = function StringStream(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };

      StringStream.prototype.eol = function () {
        return this.pos >= this.string.length;
      };

      StringStream.prototype.sol = function () {
        return this.pos == this.lineStart;
      };

      StringStream.prototype.peek = function () {
        return this.string.charAt(this.pos) || undefined;
      };

      StringStream.prototype.next = function () {
        if (this.pos < this.string.length) {
          return this.string.charAt(this.pos++);
        }
      };

      StringStream.prototype.eat = function (match) {
        var ch = this.string.charAt(this.pos);
        var ok;

        if (typeof match == "string") {
          ok = ch == match;
        } else {
          ok = ch && (match.test ? match.test(ch) : match(ch));
        }

        if (ok) {
          ++this.pos;
          return ch;
        }
      };

      StringStream.prototype.eatWhile = function (match) {
        var start = this.pos;

        while (this.eat(match)) {}

        return this.pos > start;
      };

      StringStream.prototype.eatSpace = function () {
        var start = this.pos;

        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
          ++this.pos;
        }

        return this.pos > start;
      };

      StringStream.prototype.skipToEnd = function () {
        this.pos = this.string.length;
      };

      StringStream.prototype.skipTo = function (ch) {
        var found = this.string.indexOf(ch, this.pos);

        if (found > -1) {
          this.pos = found;
          return true;
        }
      };

      StringStream.prototype.backUp = function (n) {
        this.pos -= n;
      };

      StringStream.prototype.column = function () {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }

        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };

      StringStream.prototype.indentation = function () {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };

      StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function cased(str) {
            return caseInsensitive ? str.toLowerCase() : str;
          };

          var substr = this.string.substr(this.pos, pattern.length);

          if (cased(substr) == cased(pattern)) {
            if (consume !== false) {
              this.pos += pattern.length;
            }

            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);

          if (match && match.index > 0) {
            return null;
          }

          if (match && consume !== false) {
            this.pos += match[0].length;
          }

          return match;
        }
      };

      StringStream.prototype.current = function () {
        return this.string.slice(this.start, this.pos);
      };

      StringStream.prototype.hideFirstChars = function (n, inner) {
        this.lineStart += n;

        try {
          return inner();
        } finally {
          this.lineStart -= n;
        }
      };

      StringStream.prototype.lookAhead = function (n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
      };

      StringStream.prototype.baseToken = function () {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
      }; // Find the line object corresponding to the given line number.


      function getLine(doc, n) {
        n -= doc.first;

        if (n < 0 || n >= doc.size) {
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        }

        var chunk = doc;

        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();

            if (n < sz) {
              chunk = child;
              break;
            }

            n -= sz;
          }
        }

        return chunk.lines[n];
      } // Get the part of a document between two positions, as an array of
      // strings.


      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;

          if (n == end.line) {
            text = text.slice(0, end.ch);
          }

          if (n == start.line) {
            text = text.slice(start.ch);
          }

          out.push(text);
          ++n;
        });
        return out;
      } // Get the lines between from and to, as array of strings.


      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
          out.push(line.text);
        }); // iter aborts when callback returns truthy value

        return out;
      } // Update the height of a line, propagating the height change
      // upwards to parent nodes.


      function updateLineHeight(line, height) {
        var diff = height - line.height;

        if (diff) {
          for (var n = line; n; n = n.parent) {
            n.height += diff;
          }
        }
      } // Given a line object, find its line number by walking up through
      // its parent links.


      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }

        var cur = line.parent,
            no = indexOf(cur.lines, line);

        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) {
              break;
            }

            no += chunk.children[i].chunkSize();
          }
        }

        return no + cur.first;
      } // Find the line at the given vertical position, using the height
      // information in the document tree.


      function _lineAtHeight(chunk, h) {
        var n = chunk.first;

        outer: do {
          for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
            var child = chunk.children[i$1],
                ch = child.height;

            if (h < ch) {
              chunk = child;
              continue outer;
            }

            h -= ch;
            n += child.chunkSize();
          }

          return n;
        } while (!chunk.lines);

        var i = 0;

        for (; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i],
              lh = line.height;

          if (h < lh) {
            break;
          }

          h -= lh;
        }

        return n + i;
      }

      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }

      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      } // A Pos instance represents a position within the text.


      function Pos(line, ch, sticky) {
        if (sticky === void 0) sticky = null;

        if (!(this instanceof Pos)) {
          return new Pos(line, ch, sticky);
        }

        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      } // Compare two positions, return 0 if they are the same, a negative
      // number when a is less, and a positive number otherwise.


      function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
      }

      function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
      }

      function copyPos(x) {
        return Pos(x.line, x.ch);
      }

      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }

      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      } // Most of the external API clips given positions to make sure they
      // actually exist within the document.


      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }

      function _clipPos(doc, pos) {
        if (pos.line < doc.first) {
          return Pos(doc.first, 0);
        }

        var last = doc.first + doc.size - 1;

        if (pos.line > last) {
          return Pos(last, getLine(doc, last).text.length);
        }

        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }

      function clipToLen(pos, linelen) {
        var ch = pos.ch;

        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }

      function clipPosArray(doc, array) {
        var out = [];

        for (var i = 0; i < array.length; i++) {
          out[i] = _clipPos(doc, array[i]);
        }

        return out;
      }

      var SavedContext = function SavedContext(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };

      var Context = function Context(doc, state, line, lookAhead) {
        this.state = state;
        this.doc = doc;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };

      Context.prototype.lookAhead = function (n) {
        var line = this.doc.getLine(this.line + n);

        if (line != null && n > this.maxLookAhead) {
          this.maxLookAhead = n;
        }

        return line;
      };

      Context.prototype.baseToken = function (n) {
        if (!this.baseTokens) {
          return null;
        }

        while (this.baseTokens[this.baseTokenPos] <= n) {
          this.baseTokenPos += 2;
        }

        var type = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: type && type.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n
        };
      };

      Context.prototype.nextLine = function () {
        this.line++;

        if (this.maxLookAhead > 0) {
          this.maxLookAhead--;
        }
      };

      Context.fromSaved = function (doc, saved, line) {
        if (saved instanceof SavedContext) {
          return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
        } else {
          return new Context(doc, copyState(doc.mode, saved), line);
        }
      };

      Context.prototype.save = function (copy) {
        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
      }; // Compute a style array (an array starting with a mode generation
      // -- for invalidation -- followed by pairs of end positions and
      // style strings), which is used to highlight the tokens on the
      // line.


      function highlightLine(cm, line, context, forceToEnd) {
        // A styles array always starts with a number identifying the
        // mode/overlays that it is based on (for easy invalidation).
        var st = [cm.state.modeGen],
            lineClasses = {}; // Compute the base array of styles

        runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
          return st.push(end, style);
        }, lineClasses, forceToEnd);
        var state = context.state; // Run overlays, adjust style array.

        var loop = function loop(o) {
          context.baseTokens = st;
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          context.state = true;
          runMode(cm, line.text, overlay.mode, context, function (end, style) {
            var start = i; // Ensure there's a token end at the current position, and that i points at it

            while (at < end) {
              var i_end = st[i];

              if (i_end > end) {
                st.splice(i, 1, end, st[i + 1], i_end);
              }

              i += 2;
              at = Math.min(end, i_end);
            }

            if (!style) {
              return;
            }

            if (overlay.opaque) {
              st.splice(start, i - start, end, "overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };

        for (var o = 0; o < cm.state.overlays.length; ++o) {
          loop(o);
        }

        return {
          styles: st,
          classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
      }

      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);

          if (resetState) {
            context.state = resetState;
          }

          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;

          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }

          if (updateFrontier === cm.doc.highlightFrontier) {
            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
          }
        }

        return line.styles;
      }

      function getContextBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;

        if (!doc.mode.startState) {
          return new Context(doc, true, n);
        }

        var start = findStartLine(cm, n, precise);
        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
        doc.iter(start, n, function (line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });

        if (precise) {
          doc.modeFrontier = context.line;
        }

        return context;
      } // Lightweight form of highlight -- proceed over this line and
      // update state, but don't save a style array. Used for lines that
      // aren't currently visible.


      function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;

        if (text == "") {
          callBlankLine(mode, context.state);
        }

        while (!stream.eol()) {
          readToken(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }

      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }

        if (!mode.innerMode) {
          return;
        }

        var inner = innerMode(mode, state);

        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }

      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }

          var style = mode.token(stream, state);

          if (stream.pos > stream.start) {
            return style;
          }
        }

        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }

      var Token = function Token(stream, type, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type || null;
        this.state = state;
      }; // Utility for getTokenAt and getLineTokens


      function takeToken(cm, pos, precise, asArray) {
        var doc = cm.doc,
            mode = doc.mode,
            style;
        pos = _clipPos(doc, pos);
        var line = getLine(doc, pos.line),
            context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context),
            tokens;

        if (asArray) {
          tokens = [];
        }

        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, context.state);

          if (asArray) {
            tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
          }
        }

        return asArray ? tokens : new Token(stream, style, context.state);
      }

      function extractLineClasses(type, output) {
        if (type) {
          for (;;) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);

            if (!lineClass) {
              break;
            }

            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";

            if (output[prop] == null) {
              output[prop] = lineClass[2];
            } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop])) {
              output[prop] += " " + lineClass[2];
            }
          }
        }

        return type;
      } // Run the given mode's parser over a line, calling f for each token.


      function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;

        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }

        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context),
            style;
        var inner = cm.options.addModeClass && [null];

        if (text == "") {
          extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }

        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;

            if (forceToEnd) {
              processLine(cm, text, context, stream.pos);
            }

            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
          }

          if (inner) {
            var mName = inner[0].name;

            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }

          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5000);
              f(curStart, curStyle);
            }

            curStyle = style;
          }

          stream.start = stream.pos;
        }

        while (curStart < stream.pos) {
          // Webkit seems to refuse to render text nodes longer than 57444
          // characters, and returns inaccurate measurements in nodes
          // starting around 5000 chars.
          var pos = Math.min(stream.pos, curStart + 5000);
          f(pos, curStyle);
          curStart = pos;
        }
      } // Finds the line to start with when starting a parse. Tries to
      // find a line with a stateAfter, so that it can start with a
      // valid state. If that fails, it returns the line with the
      // smallest indentation, which tends to need the least context to
      // parse correctly.


      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);

        for (var search = n; search > lim; --search) {
          if (search <= doc.first) {
            return doc.first;
          }

          var line = getLine(doc, search - 1),
              after = line.stateAfter;

          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
            return search;
          }

          var indented = countColumn(line.text, null, cm.options.tabSize);

          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }

        return minline;
      }

      function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);

        if (doc.highlightFrontier < n - 10) {
          return;
        }

        var start = doc.first;

        for (var line = n - 1; line > start; line--) {
          var saved = getLine(doc, line).stateAfter; // change is on 3
          // state on line 1 looked ahead 2 -- so saw 3
          // test 1 + 2 < 3 should cover this

          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
            start = line + 1;
            break;
          }
        }

        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
      } // Optimize some code when these features are not used.


      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;

      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }

      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      } // TEXTMARKER SPANS


      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      } // Search an array of spans for a span matching the given marker.


      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];

            if (span.marker == marker) {
              return span;
            }
          }
        }
      } // Remove a span from an array, returning undefined if no spans are
      // left (we don't store arrays for lines without spans).


      function removeMarkedSpan(spans, span) {
        var r;

        for (var i = 0; i < spans.length; ++i) {
          if (spans[i] != span) {
            (r || (r = [])).push(spans[i]);
          }
        }

        return r;
      } // Add a span to a line.


      function addMarkedSpan(line, span, op) {
        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));

        if (inThisOp && inThisOp.has(line.markedSpans)) {
          line.markedSpans.push(span);
        } else {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];

          if (inThisOp) {
            inThisOp.add(line.markedSpans);
          }
        }

        span.marker.attachLine(line);
      } // Used for the algorithm that adjusts markers for a change in the
      // document. These functions cut an array of spans at a given
      // character position, returning an array of remaining chunks (or
      // undefined if nothing remains).


      function markedSpansBefore(old, startCh, isInsert) {
        var nw;

        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }

        return nw;
      }

      function markedSpansAfter(old, endCh, isInsert) {
        var nw;

        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        }

        return nw;
      } // Given a change object, compute the new set of marker spans that
      // cover the line in which the change took place. Removes spans
      // entirely within the change, reconnects spans belonging to the
      // same marker that appear on both sides of the change, and cuts off
      // spans partially within the change. Returns an array of span
      // arrays with one element for each line in (after) the change.


      function stretchSpansOverChange(doc, change) {
        if (change.full) {
          return null;
        }

        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;

        if (!oldFirst && !oldLast) {
          return null;
        }

        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);

        if (first) {
          // Fix up .to properties of first
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];

            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);

              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }

        if (last) {
          // Fix up .from in last (or move them into first in case of sameLine)
          for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];

            if (span$1.to != null) {
              span$1.to += offset;
            }

            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);

              if (!found$1) {
                span$1.from = offset;

                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;

              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        } // Make sure we didn't create any zero-length spans


        if (first) {
          first = clearEmptySpans(first);
        }

        if (last && last != first) {
          last = clearEmptySpans(last);
        }

        var newMarkers = [first];

        if (!sameLine) {
          // Fill gap with whole-line-spans
          var gap = change.text.length - 2,
              gapMarkers;

          if (gap > 0 && first) {
            for (var i$2 = 0; i$2 < first.length; ++i$2) {
              if (first[i$2].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
              }
            }
          }

          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }

          newMarkers.push(last);
        }

        return newMarkers;
      } // Remove spans that are empty and don't have a clearWhenEmpty
      // option of false.


      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];

          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i--, 1);
          }
        }

        if (!spans.length) {
          return null;
        }

        return spans;
      } // Used to 'clip' out readOnly ranges when making a change.


      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var mark = line.markedSpans[i].marker;

              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });

        if (!markers) {
          return null;
        }

        var parts = [{
          from: from,
          to: to
        }];

        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find(0);

          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];

            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
              continue;
            }

            var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to);

            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({
                from: p.from,
                to: m.from
              });
            }

            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({
                from: m.to,
                to: p.to
              });
            }

            parts.splice.apply(parts, newParts);
            j += newParts.length - 3;
          }
        }

        return parts;
      } // Connect or disconnect spans from a line.


      function detachMarkedSpans(line) {
        var spans = line.markedSpans;

        if (!spans) {
          return;
        }

        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.detachLine(line);
        }

        line.markedSpans = null;
      }

      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }

        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.attachLine(line);
        }

        line.markedSpans = spans;
      } // Helpers used when computing which overlapping collapsed span
      // counts as the larger one.


      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }

      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      } // Returns a number indicating which of two overlapping collapsed
      // spans is larger (and thus includes the other). Falls back to
      // comparing ids when the spans cover exactly the same range.


      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;

        if (lenDiff != 0) {
          return lenDiff;
        }

        var aPos = a.find(),
            bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);

        if (fromCmp) {
          return -fromCmp;
        }

        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);

        if (toCmp) {
          return toCmp;
        }

        return b.id - a.id;
      } // Find out whether a line ends or starts in a collapsed span. If
      // so, return the marker for that span.


      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;

        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];

            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }

        return found;
      }

      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }

      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }

      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];

            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }

        return found;
      } // Test whether there exists a collapsed span that partially
      // overlaps (covers the start or end, but not both) of a new span.
      // Such overlap is not allowed.


      function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];

            if (!sp.marker.collapsed) {
              continue;
            }

            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);

            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }

            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      } // A visual line is a line as drawn on the screen. Folding, for
      // example, can cause multiple logical lines to appear on the same
      // visual line. This finds the start of the visual line that the
      // given line is part of (usually that is the line itself).


      function visualLine(line) {
        var merged;

        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }

        return line;
      }

      function visualLineEnd(line) {
        var merged;

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }

        return line;
      } // Returns an array of logical lines that continue the visual line
      // started by the argument, or undefined if there are no such lines.


      function visualLineContinued(line) {
        var merged, lines;

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }

        return lines;
      } // Get the line number of the start of the visual line that the
      // given line number is part of.


      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN),
            vis = visualLine(line);

        if (line == vis) {
          return lineN;
        }

        return lineNo(vis);
      } // Get the line number of the start of the next visual line after
      // the given line.


      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) {
          return lineN;
        }

        var line = getLine(doc, lineN),
            merged;

        if (!lineIsHidden(doc, line)) {
          return lineN;
        }

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }

        return lineNo(line) + 1;
      } // Compute whether a line is hidden. Lines count as hidden when they
      // are part of a visual line that starts with another line, or when
      // they are entirely covered by collapsed, non-widget span.


      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;

        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];

            if (!sp.marker.collapsed) {
              continue;
            }

            if (sp.from == null) {
              return true;
            }

            if (sp.marker.widgetNode) {
              continue;
            }

            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
      }

      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }

        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }

        for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];

          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      } // Find the height above the given line.


      function _heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0,
            chunk = lineObj.parent;

        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];

          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }

        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];

            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }

        return h;
      } // Compute the character length of a line, taking into account
      // collapsed ranges (see markText) that might hide parts, and join
      // other lines onto it.


      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }

        var len = line.text.length,
            merged,
            cur = line;

        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }

        cur = line;

        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }

        return len;
      } // Find the longest line in the document.


      function findMaxLine(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(line);

          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      } // LINE DATA STRUCTURE
      // Line objects. These hold state related to a line, including
      // highlighting info (the styles array).


      var Line = function Line(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };

      Line.prototype.lineNo = function () {
        return lineNo(this);
      };

      eventMixin(Line); // Change the content (text, markers) of a line. Automatically
      // invalidates cached information and tries to re-estimate the
      // line's height.

      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;

        if (line.stateAfter) {
          line.stateAfter = null;
        }

        if (line.styles) {
          line.styles = null;
        }

        if (line.order != null) {
          line.order = null;
        }

        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;

        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      } // Detach a line from the document tree and its markers.


      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      } // Convert a style as returned by a mode (either null, or a string
      // containing one or more styles) to a CSS style. This is cached,
      // and also looks for line-wide styles.


      var styleToClassCache = {},
          styleToClassCacheWithMode = {};

      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }

        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      } // Render the DOM representation of the text of a line. Also builds
      // up a 'line map', which points at the DOM nodes that represent
      // specific stretches of text, and is used by the measuring code.
      // The returned object contains the DOM node, this map, and
      // information about line-wide styles that were set by the mode.


      function buildLineContent(cm, lineView) {
        // The padding-right forces the element to have a 'border', which
        // is needed on Webkit to be able to get line-level bounding
        // rectangles for it (in measureChar).
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: eltP("pre", [content], "CodeMirror-line"),
          content: content,
          col: 0,
          pos: 0,
          cm: cm,
          trailingSpace: false,
          splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line,
              order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
          // algorithm, to deal with browser quirks.

          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }

          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));

          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }

            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          } // Ensure at least a single node is present, for measuring.


          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          } // Store the map and a cache object for the current logical line


          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        } // See issue #2901


        if (webkit) {
          var last = builder.content.lastChild;

          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }

        signal(cm, "renderLine", cm, lineView.line, builder.pre);

        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }

        return builder;
      }

      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      } // Build up the DOM representation for a single token, and add it to
      // the line map. Takes care to render special characters separately.


      function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) {
          return;
        }

        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars,
            mustWrap = false;
        var content;

        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);

          if (ie && ie_version < 9) {
            mustWrap = true;
          }

          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;

          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;

            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));

              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }

              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }

            if (!m) {
              break;
            }

            pos += skipped + 1;
            var txt$1 = void 0;

            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);

              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }

              builder.col += 1;
            }

            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }

        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

        if (style || startStyle || endStyle || mustWrap || css || attributes) {
          var fullStyle = style || "";

          if (startStyle) {
            fullStyle += startStyle;
          }

          if (endStyle) {
            fullStyle += endStyle;
          }

          var token = elt("span", [content], fullStyle, css);

          if (attributes) {
            for (var attr in attributes) {
              if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                token.setAttribute(attr, attributes[attr]);
              }
            }
          }

          return builder.content.appendChild(token);
        }

        builder.content.appendChild(content);
      } // Change some spaces to NBSP to prevent the browser from collapsing
      // trailing spaces at the end of a line when rendering text (issue #1362).


      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
          return text;
        }

        var spaceBefore = trailingBefore,
            result = "";

        for (var i = 0; i < text.length; i++) {
          var ch = text.charAt(i);

          if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
            ch = "\u00a0";
          }

          result += ch;
          spaceBefore = ch == " ";
        }

        return result;
      } // Work around nonsense dimensions being reported for stretches of
      // right-to-left text.


      function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos,
              end = start + text.length;

          for (;;) {
            // Find the part that overlaps with the start of this text
            var part = void 0;

            for (var i = 0; i < order.length; i++) {
              part = order[i];

              if (part.to > start && part.from <= start) {
                break;
              }
            }

            if (part.to >= end) {
              return inner(builder, text, style, startStyle, endStyle, css, attributes);
            }

            inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }

      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;

        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }

        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }

          widget.setAttribute("cm-marker", marker.id);
        }

        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }

        builder.pos += size;
        builder.trailingSpace = false;
      } // Outputs a number of spans to make up a line, taking highlighting
      // and marked text into account.


      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;

        if (!spans) {
          for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
          }

          return;
        }

        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style,
            css;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            collapsed,
            attributes;

        for (;;) {
          if (nextChange == pos) {
            // Update current marker set
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [],
                endStyles = void 0;

            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;

              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }

                if (m.className) {
                  spanStyle += " " + m.className;
                }

                if (m.css) {
                  css = (css ? css + ";" : "") + m.css;
                }

                if (m.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m.startStyle;
                }

                if (m.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                } // support for the old title property
                // https://github.com/codemirror/CodeMirror/pull/5673


                if (m.title) {
                  (attributes || (attributes = {})).title = m.title;
                }

                if (m.attributes) {
                  for (var attr in m.attributes) {
                    (attributes || (attributes = {}))[attr] = m.attributes[attr];
                  }
                }

                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }

            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }

            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }

            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);

              if (collapsed.to == null) {
                return;
              }

              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }

          if (pos >= len) {
            break;
          }

          var upto = Math.min(len, nextChange);

          while (true) {
            if (text) {
              var end = pos + text.length;

              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
              }

              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }

              pos = end;
              spanStartStyle = "";
            }

            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      } // These objects are used to represent the visible (currently drawn)
      // part of the document. A LineView may correspond to multiple
      // logical lines, if those are connected by collapsed ranges.


      function LineView(doc, line, lineN) {
        // The starting line
        this.line = line; // Continuing lines, if any

        this.rest = visualLineContinued(line); // Number of logical lines in this visual line

        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      } // Create a range of LineView objects for the given lines.


      function buildViewArray(cm, from, to) {
        var array = [],
            nextPos;

        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }

        return array;
      }

      var operationGroup = null;

      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }

      function fireCallbacksForOps(group) {
        // Calls delayed callbacks and cursorActivity handlers until no
        // new ones appear
        var callbacks = group.delayedCallbacks,
            i = 0;

        do {
          for (; i < callbacks.length; i++) {
            callbacks[i].call(null);
          }

          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];

            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i < callbacks.length);
      }

      function finishOperation(op, endCb) {
        var group = op.ownsGroup;

        if (!group) {
          return;
        }

        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }

      var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
      // middle of some work, but don't want the handler to start calling
      // other methods on the editor, which might be in an inconsistent
      // state or simply not expect any other events to happen.
      // signalLater looks whether there are any handlers, and schedules
      // them to be executed when the last operation ends, or, if no
      // operation is active, when a timeout fires.

      function signalLater(emitter, type
      /*, values...*/
      ) {
        var arr = getHandlers(emitter, type);

        if (!arr.length) {
          return;
        }

        var args = Array.prototype.slice.call(arguments, 2),
            list;

        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }

        var loop = function loop(i) {
          list.push(function () {
            return arr[i].apply(null, args);
          });
        };

        for (var i = 0; i < arr.length; ++i) {
          loop(i);
        }
      }

      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;

        for (var i = 0; i < delayed.length; ++i) {
          delayed[i]();
        }
      } // When an aspect of a line changes, a string is added to
      // lineView.changes. This updates the relevant part of the line's
      // DOM structure.


      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];

          if (type == "text") {
            updateLineText(cm, lineView);
          } else if (type == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type == "class") {
            updateLineClasses(cm, lineView);
          } else if (type == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }

        lineView.changes = null;
      } // Lines with gutter elements, widgets or a background class need to
      // be wrapped, and have the extra elements added to the wrapper div


      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");

          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }

          lineView.node.appendChild(lineView.text);

          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }

        return lineView.node;
      }

      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;

        if (cls) {
          cls += " CodeMirror-linebackground";
        }

        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      } // Wrapper around buildLineContent which will reuse the structure
      // in display.externalMeasured when possible.


      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;

        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }

        return buildLineContent(cm, lineView);
      } // Redraw the line's text. Interacts with the background and text
      // classes because the mode may output tokens that influence these
      // classes.


      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);

        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }

        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;

        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }

      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);

        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }

        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }

      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }

        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }

        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }

        var markers = lineView.line.gutterMarkers;

        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          gutterWrap.setAttribute("aria-hidden", "true");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);

          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }

          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          }

          if (markers) {
            for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
              var id = cm.display.gutterSpecs[k].className,
                  found = markers.hasOwnProperty(id) && markers[id];

              if (found) {
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
              }
            }
          }
        }
      }

      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }

        var isWidget = classTest("CodeMirror-linewidget");

        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;

          if (isWidget.test(node.className)) {
            lineView.node.removeChild(node);
          }
        }

        insertLineWidgets(cm, lineView, dims);
      } // Build a line's DOM representation from scratch


      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;

        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }

        if (built.textClass) {
          lineView.textClass = built.textClass;
        }

        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      } // A lineView may contain multiple logical lines (when merged by
      // collapsed spans). The widgets for all of them need to be drawn.


      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);

        if (lineView.rest) {
          for (var i = 0; i < lineView.rest.length; i++) {
            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
          }
        }
      }

      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }

        var wrap = ensureLineWrapped(lineView);

        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));

          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }

          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);

          if (allowAbove && widget.above) {
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap.appendChild(node);
          }

          signalLater(widget, "redraw");
        }
      }

      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";

          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }

          node.style.width = width + "px";
        }

        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";

          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }

      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }

        var cm = widget.doc.cm;

        if (!cm) {
          return 0;
        }

        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";

          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }

          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }

          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }

        return widget.height = widget.node.parentNode.offsetHeight;
      } // Return true when the given mouse event happened in a widget


      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
            return true;
          }
        }
      } // POSITION MEASUREMENT


      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }

      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }

      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }

        var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
          left: parseInt(style.paddingLeft),
          right: parseInt(style.paddingRight)
        };

        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }

        return data;
      }

      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }

      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }

      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      } // Ensure the lineView.wrapping.heights array is populated. This is
      // an array of bottom offsets for the lines that make up a drawn
      // line. When lineWrapping is on, there might be more than one
      // height.


      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);

        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];

          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();

            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i],
                  next = rects[i + 1];

              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }

          heights.push(rect.bottom - rect.top);
        }
      } // Find a line map (mapping character offsets to text nodes) and a
      // measurement cache for the given line number. (A line view might
      // contain multiple lines when collapsed ranges are present.)


      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
          };
        }

        for (var i = 0; i < lineView.rest.length; i++) {
          if (lineView.rest[i] == line) {
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i]
            };
          }
        }

        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
          if (lineNo(lineView.rest[i$1]) > lineN) {
            return {
              map: lineView.measure.maps[i$1],
              cache: lineView.measure.caches[i$1],
              before: true
            };
          }
        }
      } // Render a line into the hidden node display.externalMeasured. Used
      // when measurement is needed for a line that's not in the viewport.


      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      } // Get a {top, bottom, left, right} box (in line-local coordinates)
      // for a given character.


      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      } // Find a line view that corresponds to the given line number.


      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }

        var ext = cm.display.externalMeasured;

        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      } // Measurement can be split in two steps, the set-up work that
      // applies to the whole line, and the measurement of the actual
      // character. Functions like coordsChar, that need to do a lot of
      // measurements in a row, can thus ensure that the set-up work is
      // only done once.


      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);

        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }

        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }

        var info = mapFromLineView(view, line, lineN);
        return {
          line: line,
          view: view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      } // Given a prepared measurement object, measures the position of an
      // actual character (or fetches it from the cache).


      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }

        var key = ch + (bias || ""),
            found;

        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }

          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }

          found = measureCharInner(cm, prepared, ch, bias);

          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }

        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }

      var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };

      function nodeAndOffsetInLineMap(map, ch, bias) {
        var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,
        // or closest to, the target character.

        for (var i = 0; i < map.length; i += 3) {
          mStart = map[i];
          mEnd = map[i + 1];

          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;

            if (ch >= mEnd) {
              collapse = "right";
            }
          }

          if (start != null) {
            node = map[i + 2];

            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }

            if (bias == "left" && start == 0) {
              while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                node = map[(i -= 3) + 2];
                collapse = "left";
              }
            }

            if (bias == "right" && start == mEnd - mStart) {
              while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                node = map[(i += 3) + 2];
                collapse = "right";
              }
            }

            break;
          }
        }

        return {
          node: node,
          start: start,
          end: end,
          collapse: collapse,
          coverStart: mStart,
          coverEnd: mEnd
        };
      }

      function getUsefulRect(rects, bias) {
        var rect = nullRect;

        if (bias == "left") {
          for (var i = 0; i < rects.length; i++) {
            if ((rect = rects[i]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
            if ((rect = rects[i$1]).left != rect.right) {
              break;
            }
          }
        }

        return rect;
      }

      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse;
        var rect;

        if (node.nodeType == 3) {
          // If it is a text node, use a range to retrieve the coordinates.
          for (var i$1 = 0; i$1 < 4; i$1++) {
            // Retry a maximum of 4 times when nonsense rectangles are returned
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
              --start;
            }

            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }

            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
            }

            if (rect.left || rect.right || start == 0) {
              break;
            }

            end = start;
            start = start - 1;
            collapse = "right";
          }

          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          // If it is a widget, simply get the box for the whole widget.
          if (start > 0) {
            collapse = bias = "right";
          }

          var rects;

          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }

        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];

          if (rSpan) {
            rect = {
              left: rSpan.left,
              right: rSpan.left + charWidth(cm.display),
              top: rSpan.top,
              bottom: rSpan.bottom
            };
          } else {
            rect = nullRect;
          }
        }

        var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i = 0;

        for (; i < heights.length - 1; i++) {
          if (mid < heights[i]) {
            break;
          }
        }

        var top = i ? heights[i - 1] : 0,
            bot = heights[i];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top: top,
          bottom: bot
        };

        if (!rect.left && !rect.right) {
          result.bogus = true;
        }

        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }

        return result;
      } // Work around problem with bounding client rects on ranges being
      // returned incorrectly when zoomed on IE10 and below.


      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }

        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }

      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;

          if (lineView.rest) {
            for (var i = 0; i < lineView.rest.length; i++) {
              lineView.measure.caches[i] = {};
            }
          }
        }
      }

      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);

        for (var i = 0; i < cm.display.view.length; i++) {
          clearLineMeasurementCacheFor(cm.display.view[i]);
        }
      }

      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;

        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }

        cm.display.lineNumChars = null;
      }

      function pageScrollX() {
        // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
        // which causes page_Offset and bounding client rects to use
        // different reference viewports and invalidate our calculations.
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
        }

        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }

      function pageScrollY() {
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
        }

        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }

      function widgetTopHeight(lineObj) {
        var height = 0;

        if (lineObj.widgets) {
          for (var i = 0; i < lineObj.widgets.length; ++i) {
            if (lineObj.widgets[i].above) {
              height += widgetHeight(lineObj.widgets[i]);
            }
          }
        }

        return height;
      } // Converts a {top, bottom, left, right} box from line-local
      // coordinates into another coordinate system. Context may be one of
      // "line", "div" (display.lineDiv), "local"./null (editor), "window",
      // or "page".


      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height;
          rect.bottom += height;
        }

        if (context == "line") {
          return rect;
        }

        if (!context) {
          context = "local";
        }

        var yOff = _heightAtLine(lineObj);

        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }

        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }

        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      } // Coverts a box from "div" coords to another coordinate system.
      // Context may be "window", "page", "div", or "local"./null.


      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }

        var left = coords.left,
            top = coords.top; // First move into "page" coordinate system

        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }

        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
          left: left - lineSpaceBox.left,
          top: top - lineSpaceBox.top
        };
      }

      function _charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine(cm.doc, pos.line);
        }

        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      } // Returns a box for a given cursor position, which may have an
      // 'other' property containing the position of the secondary cursor
      // on a bidi boundary.
      // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
      // and after `char - 1` in writing order of `char - 1`
      // A cursor Pos(line, char, "after") is on the same visual line as `char`
      // and before `char` in writing order of `char`
      // Examples (upper-case letters are RTL, lower-case are LTR):
      //     Pos(0, 1, ...)
      //     before   after
      // ab     a|b     a|b
      // aB     a|B     aB|
      // Ab     |Ab     A|b
      // AB     B|A     B|A
      // Every position after the last character on a line is considered to stick
      // to the last character on the line.


      function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);

        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }

        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);

          if (right) {
            m.left = m.right;
          } else {
            m.right = m.left;
          }

          return intoCoordSystem(cm, lineObj, m, context);
        }

        var order = getOrder(lineObj, cm.doc.direction),
            ch = pos.ch,
            sticky = pos.sticky;

        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }

        if (!order) {
          return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }

        function getBidi(ch, partPos, invert) {
          var part = order[partPos],
              right = part.level == 1;
          return get(invert ? ch - 1 : ch, right != invert);
        }

        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");

        if (other != null) {
          val.other = getBidi(ch, other, sticky != "before");
        }

        return val;
      } // Used to cheaply estimate the coordinates for a position. Used for
      // intermediate scroll updates.


      function estimateCoords(cm, pos) {
        var left = 0;
        pos = _clipPos(cm.doc, pos);

        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }

        var lineObj = getLine(cm.doc, pos.line);
        var top = _heightAtLine(lineObj) + paddingTop(cm.display);
        return {
          left: left,
          right: left,
          top: top,
          bottom: top + lineObj.height
        };
      } // Positions returned by coordsChar contain some extra information.
      // xRel is the relative x position of the input coordinates compared
      // to the found position (so xRel > 0 means the coordinates are to
      // the right of the character position, for example). When outside
      // is true, that means the coordinates lie outside the line's
      // vertical range.


      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;

        if (outside) {
          pos.outside = outside;
        }

        return pos;
      } // Compute the character position closest to the given coordinates.
      // Input must be lineSpace-local ("div" coordinate system).


      function _coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;

        if (y < 0) {
          return PosWithInfo(doc.first, 0, null, -1, -1);
        }

        var lineN = _lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;

        if (lineN > last) {
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
        }

        if (x < 0) {
          x = 0;
        }

        var lineObj = getLine(doc, lineN);

        for (;;) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));

          if (!collapsed) {
            return found;
          }

          var rangeEnd = collapsed.find(1);

          if (rangeEnd.line == lineN) {
            return rangeEnd;
          }

          lineObj = getLine(doc, lineN = rangeEnd.line);
        }
      }

      function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function (ch) {
          return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, end, 0);
        end = findFirst(function (ch) {
          return measureCharPrepared(cm, preparedMeasure, ch).top > y;
        }, begin, end);
        return {
          begin: begin,
          end: end
        };
      }

      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }

        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
      } // Returns true if the given side of a box is after the given
      // coordinates, in top-to-bottom, left-to-right order.


      function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
      }

      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        // Move y into line-local coordinate space
        y -= _heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust
        // for the widgets at this line.

        var widgetHeight = widgetTopHeight(lineObj);
        var begin = 0,
            end = lineObj.text.length,
            ltr = true;
        var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out
        // which bidi section the coordinates fall into.

        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
          ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called
          // on these below) will treat its first bound as inclusive,
          // second as exclusive, but we want to actually address the
          // characters in the part's range

          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        } // A binary search to find the first character whose bounding box
        // starts after the coordinates. If we run across any whose box wrap
        // the coordinates, store that.


        var chAround = null,
            boxAround = null;
        var ch = findFirst(function (ch) {
          var box = measureCharPrepared(cm, preparedMeasure, ch);
          box.top += widgetHeight;
          box.bottom += widgetHeight;

          if (!boxIsAfter(box, x, y, false)) {
            return false;
          }

          if (box.top <= y && box.left <= x) {
            chAround = ch;
            boxAround = box;
          }

          return true;
        }, begin, end);
        var baseX,
            sticky,
            outside = false; // If a box around the coordinates was found, use that

        if (boxAround) {
          // Distinguish coordinates nearer to the left or right side of the box
          var atLeft = x - boxAround.left < boxAround.right - x,
              atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          // (Adjust for extended bound, if necessary.)
          if (!ltr && (ch == end || ch == begin)) {
            ch++;
          } // To determine which side to associate with, get the box to the
          // left of the character and compare it's vertical position to the
          // coordinates


          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before"; // Now get accurate coordinates for this place, in order to get a
          // base X position

          var coords = _cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);

          baseX = coords.left;
          outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
        }

        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
      }

      function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
        // Bidi parts are sorted left-to-right, and in a non-line-wrapping
        // situation, we can take this ordering to correspond to the visual
        // ordering. This finds the first part whose end is after the given
        // coordinates.
        var index = findFirst(function (i) {
          var part = order[i],
              ltr = part.level != 1;
          return boxIsAfter(_cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
        }, 0, order.length - 1);
        var part = order[index]; // If this isn't the first part, the part's start is also after
        // the coordinates, and the coordinates aren't on the same line as
        // that start, move one part back.

        if (index > 0) {
          var ltr = part.level != 1;

          var start = _cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);

          if (boxIsAfter(start, x, y, true) && start.top > y) {
            part = order[index - 1];
          }
        }

        return part;
      }

      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        // In a wrapped line, rtl text on wrapping boundaries can do things
        // that don't correspond to the ordering in our `order` array at
        // all, so a binary search doesn't work, and we want to return a
        // part that only spans one line so that the binary search in
        // coordsCharInner is safe. As such, we first find the extent of the
        // wrapped line, and then do a flat search in which we discard any
        // spans that aren't on the line.
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;

        if (/\s/.test(lineObj.text.charAt(end - 1))) {
          end--;
        }

        var part = null,
            closestDist = null;

        for (var i = 0; i < order.length; i++) {
          var p = order[i];

          if (p.from >= end || p.to <= begin) {
            continue;
          }

          var ltr = p.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only
          // picked if nothing ends after

          var dist = endX < x ? x - endX + 1e9 : endX - x;

          if (!part || closestDist > dist) {
            part = p;
            closestDist = dist;
          }
        }

        if (!part) {
          part = order[order.length - 1];
        } // Clip the part to the wrapped line.


        if (part.from < begin) {
          part = {
            from: begin,
            to: part.to,
            level: part.level
          };
        }

        if (part.to > end) {
          part = {
            from: part.from,
            to: end,
            level: part.level
          };
        }

        return part;
      }

      var measureText; // Compute the default text height.

      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }

        if (measureText == null) {
          measureText = elt("pre", null, "CodeMirror-line-like"); // Measure a bunch of lines, for browsers that compute
          // fractional heights.

          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }

          measureText.appendChild(document.createTextNode("x"));
        }

        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;

        if (height > 3) {
          display.cachedTextHeight = height;
        }

        removeChildren(display.measure);
        return height || 1;
      } // Compute the default character width.


      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }

        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10;

        if (width > 2) {
          display.cachedCharWidth = width;
        }

        return width || 10;
      } // Do a bulk-read of the DOM positions and sizes needed to draw the
      // view, so that we don't interleave reading and writing to the DOM.


      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        var gutterLeft = d.gutters.clientLeft;

        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          var id = cm.display.gutterSpecs[i].className;
          left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[id] = n.clientWidth;
        }

        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
      // but using getBoundingClientRect to get a sub-pixel-accurate
      // result.


      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      } // Returns a function that estimates the height of a line, to use as
      // first approximation until the line becomes visible (and is thus
      // properly measurable).


      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }

          var widgetsHeight = 0;

          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].height) {
                widgetsHeight += line.widgets[i].height;
              }
            }
          }

          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }

      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);

          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      } // Given a mouse event, find the corresponding position. If liberal
      // is false, it checks whether a gutter or scrollbar was clicked,
      // and returns null if it was. forRect is used by rectangular
      // selections, and tries to estimate a character position even for
      // coordinates beyond the right of the text.


      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;

        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
          return null;
        }

        var x,
            y,
            space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.

        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e$1) {
          return null;
        }

        var coords = _coordsChar(cm, x, y),
            line;

        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }

        return coords;
      } // Find the view element corresponding to a given line. Return null
      // when the line isn't visible.


      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
          return null;
        }

        n -= cm.display.viewFrom;

        if (n < 0) {
          return null;
        }

        var view = cm.display.view;

        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;

          if (n < 0) {
            return i;
          }
        }
      } // Updates the display.view data structure for a given change to the
      // document. From and to are in pre-change coordinates. Lendiff is
      // the amount of lines added or subtracted by the change. This is
      // used for changes that span multiple lines, or change the way
      // lines are divided into visual lines. regLineChange (below)
      // registers single-line changes.


      function regChange(cm, from, to, lendiff) {
        if (from == null) {
          from = cm.doc.first;
        }

        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }

        if (!lendiff) {
          lendiff = 0;
        }

        var display = cm.display;

        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
          display.updateLineNumbers = from;
        }

        cm.curOp.viewChanged = true;

        if (from >= display.viewTo) {
          // Change after
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          // Change before
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          // Full overlap
          resetView(cm);
        } else if (from <= display.viewFrom) {
          // Top overlap
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);

          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          // Bottom overlap
          var cut$1 = viewCuttingPoint(cm, from, from, -1);

          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          // Gap in the middle
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);

          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }

        var ext = display.externalMeasured;

        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      } // Register a change to a single line. Type must be one of "text",
      // "gutter", "class", "widget"


      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display,
            ext = cm.display.externalMeasured;

        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }

        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }

        var lineView = display.view[findViewIndex(cm, line)];

        if (lineView.node == null) {
          return;
        }

        var arr = lineView.changes || (lineView.changes = []);

        if (indexOf(arr, type) == -1) {
          arr.push(type);
        }
      } // Clear the view.


      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }

      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view;

        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return {
            index: index,
            lineN: newN
          };
        }

        var n = cm.display.viewFrom;

        for (var i = 0; i < index; i++) {
          n += view[i].size;
        }

        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1) {
              return null;
            }

            diff = n + view[index].size - oldN;
            index++;
          } else {
            diff = n - oldN;
          }

          oldN += diff;
          newN += diff;
        }

        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }

          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }

        return {
          index: index,
          lineN: newN
        };
      } // Force the view to cover a given range, adding empty view element
      // or clipping off existing ones as needed.


      function adjustView(cm, from, to) {
        var display = cm.display,
            view = display.view;

        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from) {
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from) {
            display.view = display.view.slice(findViewIndex(cm, from));
          }

          display.viewFrom = from;

          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }

        display.viewTo = to;
      } // Count the number of lines in the view whose DOM representation is
      // out of date (or nonexistent).


      function countDirtyView(cm) {
        var view = cm.display.view,
            dirty = 0;

        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];

          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }

        return dirty;
      }

      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }

      function prepareSelection(cm, primary) {
        if (primary === void 0) primary = true;
        var doc = cm.doc,
            result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (!primary && i == doc.sel.primIndex) {
            continue;
          }

          var range = doc.sel.ranges[i];

          if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
            continue;
          }

          var collapsed = range.empty();

          if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range.head, curFragment);
          }

          if (!collapsed) {
            drawSelectionRange(cm, range, selFragment);
          }
        }

        return result;
      } // Draws a cursor for the given range


      function drawSelectionCursor(cm, head, output) {
        var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

        if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
          var charPos = _charCoords(cm, head, "div", null, null);

          if (charPos.right - charPos.left > 0) {
            cursor.style.width = charPos.right - charPos.left + "px";
          }
        }

        if (pos.other) {
          // Secondary cursor, shown when on a 'jump' in bi-directional text
          var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }

      function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
      } // Draws the given range as a highlighted selection


      function drawSelectionRange(cm, range, output) {
        var display = cm.display,
            doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display),
            leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc.direction == "ltr";

        function add(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }

          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }

        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;

          function coords(ch, bias) {
            return _charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }

          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop = dir == "ltr" == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop)[prop];
          }

          var order = getOrder(lineObj, doc.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
            var ltr = dir == "ltr";
            var fromPos = coords(from, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");
            var openStart = fromArg == null && from == 0,
                openEnd = toArg == null && to == lineLen;
            var first = i == 0,
                last = !order || i == order.length - 1;

            if (toPos.top - fromPos.top <= 3) {
              // Single line
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add(left, fromPos.top, right - left, fromPos.bottom);
            } else {
              // Multiple lines
              var topLeft, topRight, botLeft, botRight;

              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }

              add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);

              if (fromPos.bottom < toPos.top) {
                add(leftSide, fromPos.bottom, null, toPos.top);
              }

              add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }

            if (!start || cmpCoords(fromPos, start) < 0) {
              start = fromPos;
            }

            if (cmpCoords(toPos, start) < 0) {
              start = toPos;
            }

            if (!end || cmpCoords(fromPos, end) < 0) {
              end = fromPos;
            }

            if (cmpCoords(toPos, end) < 0) {
              end = toPos;
            }
          });
          return {
            start: start,
            end: end
          };
        }

        var sFrom = range.from(),
            sTo = range.to();

        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }

          if (leftEnd.bottom < rightStart.top) {
            add(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }

        output.appendChild(fragment);
      } // Cursor-blinking


      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }

        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";

        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function () {
            if (!cm.hasFocus()) {
              onBlur(cm);
            }

            display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }

      function ensureFocus(cm) {
        if (!cm.hasFocus()) {
          cm.display.input.focus();

          if (!cm.state.focused) {
            onFocus(cm);
          }
        }
      }

      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function () {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;

            if (cm.state.focused) {
              onBlur(cm);
            }
          }
        }, 100);
      }

      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
          cm.state.delayingBlurEvent = false;
        }

        if (cm.options.readOnly == "nocursor") {
          return;
        }

        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused"); // This test prevents this from firing when a context
          // menu is closed (since the input reset would kill the
          // select-all detection hack)

          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();

            if (webkit) {
              setTimeout(function () {
                return cm.display.input.reset(true);
              }, 20);
            } // Issue #1730

          }

          cm.display.input.receivedFocus();
        }

        restartBlink(cm);
      }

      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
          return;
        }

        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }

        clearInterval(cm.display.blinker);
        setTimeout(function () {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      } // Read the actual heights of the rendered lines, and update their
      // stored heights to match.


      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
        var oldHeight = display.lineDiv.getBoundingClientRect().top;
        var mustScroll = 0;

        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i],
              wrapping = cm.options.lineWrapping;
          var height = void 0,
              width = 0;

          if (cur.hidden) {
            continue;
          }

          oldHeight += cur.line.height;

          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top; // Check that lines don't extend past the right of the current
            // editor width

            if (!wrapping && cur.text.firstChild) {
              width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
            }
          }

          var diff = cur.line.height - height;

          if (diff > .005 || diff < -.005) {
            if (oldHeight < viewTop) {
              mustScroll -= diff;
            }

            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);

            if (cur.rest) {
              for (var j = 0; j < cur.rest.length; j++) {
                updateWidgetHeight(cur.rest[j]);
              }
            }
          }

          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));

            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }

        if (Math.abs(mustScroll) > 2) {
          display.scroller.scrollTop += mustScroll;
        }
      } // Read and store the height of line widgets associated with the
      // given line.


      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i = 0; i < line.widgets.length; ++i) {
            var w = line.widgets[i],
                parent = w.node.parentNode;

            if (parent) {
              w.height = parent.offsetHeight;
            }
          }
        }
      } // Compute the lines that are visible in a given viewport (defaults
      // the the current scroll position). viewport may contain top,
      // height, and ensure (see op.scrollToPos) properties.


      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

        var from = _lineAtHeight(doc, top),
            to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
        // forces those lines into the viewport (if possible).


        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line;

          if (ensureFrom < from) {
            from = ensureFrom;
            to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }

        return {
          from: from,
          to: Math.max(to, from + 1)
        };
      } // SCROLLING THINGS INTO VIEW
      // If an editor sits on the top or bottom of the window, partially
      // scrolled out of view, this ensures that the cursor is visible.


      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }

        var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null;

        if (rect.top + box.top < 0) {
          doScroll = true;
        } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
          doScroll = false;
        }

        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      } // Scroll a given position into view (immediately), verifying that
      // it actually became visible (as line heights are accurately
      // measured, the position of something may 'drift' during drawing).


      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }

        var rect;

        if (!cm.options.lineWrapping && pos == end) {
          // Set pos and end to the cursor positions around the character pos sticks to
          // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
          // If pos == Pos(_, 0, "before"), pos and end are unchanged
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        }

        for (var limit = 0; limit < 5; limit++) {
          var changed = false;

          var coords = _cursorCoords(cm, pos);

          var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);
          rect = {
            left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin
          };
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;

          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);

            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }

          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);

            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }

          if (!changed) {
            break;
          }
        }

        return rect;
      } // Scroll a given set of coordinates into view (immediately).


      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);

        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
        }

        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      } // Calculate a new scroll position needed to scroll the given
      // rectangle into view. Returns an object with scrollTop and
      // scrollLeft properties. When these are undefined, the
      // vertical/horizontal position does not need to be adjusted.


      function calculateScrollPos(cm, rect) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);

        if (rect.top < 0) {
          rect.top = 0;
        }

        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm),
            result = {};

        if (rect.bottom - rect.top > screen) {
          rect.bottom = rect.top + screen;
        }

        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin,
            atBottom = rect.bottom > docBottom - snapMargin;

        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);

          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }

        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
        var screenw = displayWidth(cm) - display.gutters.offsetWidth;
        var tooWide = rect.right - rect.left > screenw;

        if (tooWide) {
          rect.right = rect.left + screenw;
        }

        if (rect.left < 10) {
          result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
          result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
          result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }

        return result;
      } // Store a relative adjustment to the scroll position in the current
      // operation (to be applied when the operation finishes).


      function addToScrollTop(cm, top) {
        if (top == null) {
          return;
        }

        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      } // Make sure that at the end of the operation the current cursor is
      // shown.


      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = {
          from: cur,
          to: cur,
          margin: cm.options.cursorScrollMargin
        };
      }

      function scrollToCoords(cm, x, y) {
        if (x != null || y != null) {
          resolveScrollToPos(cm);
        }

        if (x != null) {
          cm.curOp.scrollLeft = x;
        }

        if (y != null) {
          cm.curOp.scrollTop = y;
        }
      }

      function scrollToRange(cm, range) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range;
      } // When an operation has its scrollToPos property set, and another
      // scroll action is applied before the end of the operation, this
      // 'simulates' scrolling that position into view in a cheap way, so
      // that the effect of intermediate scroll commands is not ignored.


      function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;

        if (range) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to);
          scrollToCoordsRange(cm, from, to, range.margin);
        }
      }

      function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from.left, to.left),
          top: Math.min(from.top, to.top) - margin,
          right: Math.max(from.right, to.right),
          bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      } // Sync the scrollable area and scrollbars, ensure the viewport
      // covers the visible area.


      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }

        if (!gecko) {
          updateDisplaySimple(cm, {
            top: val
          });
        }

        setScrollTop(cm, val, true);

        if (gecko) {
          updateDisplaySimple(cm);
        }

        startWorker(cm, 100);
      }

      function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));

        if (cm.display.scroller.scrollTop == val && !forceScroll) {
          return;
        }

        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);

        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
      } // Sync scroller and scrollbar, ensure the gutter elements are
      // aligned.


      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));

        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
          return;
        }

        cm.doc.scrollLeft = val;
        alignHorizontally(cm);

        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }

        cm.display.scrollbars.setScrollLeft(val);
      } // SCROLLBARS
      // Prepare DOM reads needed to update the scrollbars. Done in one
      // shot to minimize update/measure roundtrips.


      function measureForScrollbars(cm) {
        var d = cm.display,
            gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }

      var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function () {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function () {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).

        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      };

      NativeScrollbars.prototype.update = function (measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;

        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.

          this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }

        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }

        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) {
            this.zeroWidthHack();
          }

          this.checkedZeroWidth = true;
        }

        return {
          right: needsV ? sWidth : 0,
          bottom: needsH ? sWidth : 0
        };
      };

      NativeScrollbars.prototype.setScrollLeft = function (pos) {
        if (this.horiz.scrollLeft != pos) {
          this.horiz.scrollLeft = pos;
        }

        if (this.disableHoriz) {
          this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
      };

      NativeScrollbars.prototype.setScrollTop = function (pos) {
        if (this.vert.scrollTop != pos) {
          this.vert.scrollTop = pos;
        }

        if (this.disableVert) {
          this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
      };

      NativeScrollbars.prototype.zeroWidthHack = function () {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
        this.disableHoriz = new Delayed();
        this.disableVert = new Delayed();
      };

      NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
        bar.style.pointerEvents = "auto";

        function maybeDisable() {
          // To find out whether the scrollbar is still visible, we
          // check whether the element under the pixel in the bottom
          // right corner of the scrollbar box is the scrollbar box
          // itself (when the bar is still visible) or its filler child
          // (when the bar is hidden). If it is still visible, we keep
          // it enabled, if it's hidden, we disable pointer events.
          var box = bar.getBoundingClientRect();
          var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);

          if (elt != bar) {
            bar.style.pointerEvents = "none";
          } else {
            delay.set(1000, maybeDisable);
          }
        }

        delay.set(1000, maybeDisable);
      };

      NativeScrollbars.prototype.clear = function () {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };

      var NullScrollbars = function NullScrollbars() {};

      NullScrollbars.prototype.update = function () {
        return {
          bottom: 0,
          right: 0
        };
      };

      NullScrollbars.prototype.setScrollLeft = function () {};

      NullScrollbars.prototype.setScrollTop = function () {};

      NullScrollbars.prototype.clear = function () {};

      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }

        var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);

        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }

          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      } // Re-synchronize the fake scrollbars with the actual size of the
      // content.


      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d.scrollbarFiller.style.display = "";
        }

        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d.gutterFiller.style.display = "";
        }
      }

      var scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
      };

      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();

          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }

        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus

          on(node, "mousedown", function () {
            if (cm.state.focused) {
              setTimeout(function () {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function (pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            updateScrollTop(cm, pos);
          }
        }, cm);

        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      } // Operations are used to wrap a series of changes to the editor
      // state in such a way that each change won't have to update the
      // cursor and display (which would be awkward, slow, and
      // error-prone). Instead, display updates are batched and then all
      // combined and executed at once.


      var nextOpId = 0; // Start a new operation.

      function _startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: cm.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++nextOpId,
          // Unique ID
          markArrays: null // Used by addMarkedSpan

        };
        pushOperation(cm.curOp);
      } // Finish an operation, updating the display and signalling delayed events


      function _endOperation(cm) {
        var op = cm.curOp;

        if (op) {
          finishOperation(op, function (group) {
            for (var i = 0; i < group.ops.length; i++) {
              group.ops[i].cm.curOp = null;
            }

            endOperations(group);
          });
        }
      } // The DOM updates done when an operation finishes are batched so
      // that the minimum number of relayouts are required.


      function endOperations(group) {
        var ops = group.ops;

        for (var i = 0; i < ops.length; i++) // Read DOM
        {
          endOperation_R1(ops[i]);
        }

        for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
        {
          endOperation_W1(ops[i$1]);
        }

        for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
        {
          endOperation_R2(ops[i$2]);
        }

        for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
        {
          endOperation_W2(ops[i$3]);
        }

        for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
        {
          endOperation_finish(ops[i$4]);
        }
      }

      function endOperation_R1(op) {
        var cm = op.cm,
            display = cm.display;
        maybeClipScrollbars(cm);

        if (op.updateMaxLine) {
          findMaxLine(cm);
        }

        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      }

      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }

      function endOperation_R2(op) {
        var cm = op.cm,
            display = cm.display;

        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }

        op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
        // and ensure the document's width matches it.
        // updateDisplay_W2 will use these properties to do the actual resizing

        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }

        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection();
        }
      }

      function endOperation_W2(op) {
        var cm = op.cm;

        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";

          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }

          cm.display.maxLineChanged = false;
        }

        var takeFocus = op.focus && op.focus == activeElt();

        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }

        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }

        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }

        if (op.selectionChanged) {
          restartBlink(cm);
        }

        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }

        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }

      function endOperation_finish(op) {
        var cm = op.cm,
            display = cm.display,
            doc = cm.doc;

        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        } // Abort mouse wheel delta measurement, when scrolling explicitly


        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        } // Propagate the scroll position to the actual DOM scroller


        if (op.scrollTop != null) {
          setScrollTop(cm, op.scrollTop, op.forceScroll);
        }

        if (op.scrollLeft != null) {
          setScrollLeft(cm, op.scrollLeft, true, true);
        } // If we need to scroll a specific position into view, do so.


        if (op.scrollToPos) {
          var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          maybeScrollWindow(cm, rect);
        } // Fire events for markers that are hidden/unidden by editing or
        // undoing


        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;

        if (hidden) {
          for (var i = 0; i < hidden.length; ++i) {
            if (!hidden[i].lines.length) {
              signal(hidden[i], "hide");
            }
          }
        }

        if (unhidden) {
          for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
            if (unhidden[i$1].lines.length) {
              signal(unhidden[i$1], "unhide");
            }
          }
        }

        if (display.wrapper.offsetHeight) {
          doc.scrollTop = cm.display.scroller.scrollTop;
        } // Fire change events, and delayed event handlers


        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }

        if (op.update) {
          op.update.finish();
        }
      } // Run the given function in an operation


      function runInOp(cm, f) {
        if (cm.curOp) {
          return f();
        }

        _startOperation(cm);

        try {
          return f();
        } finally {
          _endOperation(cm);
        }
      } // Wraps a function in an operation. Returns the wrapped function.


      function operation(cm, f) {
        return function () {
          if (cm.curOp) {
            return f.apply(cm, arguments);
          }

          _startOperation(cm);

          try {
            return f.apply(cm, arguments);
          } finally {
            _endOperation(cm);
          }
        };
      } // Used to add methods to editor and doc instances, wrapping them in
      // operations.


      function methodOp(f) {
        return function () {
          if (this.curOp) {
            return f.apply(this, arguments);
          }

          _startOperation(this);

          try {
            return f.apply(this, arguments);
          } finally {
            _endOperation(this);
          }
        };
      }

      function docMethodOp(f) {
        return function () {
          var cm = this.cm;

          if (!cm || cm.curOp) {
            return f.apply(this, arguments);
          }

          _startOperation(cm);

          try {
            return f.apply(this, arguments);
          } finally {
            _endOperation(cm);
          }
        };
      } // HIGHLIGHT WORKER


      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }

      function highlightWorker(cm) {
        var doc = cm.doc;

        if (doc.highlightFrontier >= cm.display.viewTo) {
          return;
        }

        var end = +new Date() + cm.options.workTime;
        var context = getContextBefore(cm, doc.highlightFrontier);
        var changedLines = [];
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
          if (context.line >= cm.display.viewFrom) {
            // Visible
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);

            if (resetState) {
              context.state = resetState;
            }

            line.styles = highlighted.styles;
            var oldCls = line.styleClasses,
                newCls = highlighted.classes;

            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }

            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);

            for (var i = 0; !ischange && i < oldStyles.length; ++i) {
              ischange = oldStyles[i] != line.styles[i];
            }

            if (ischange) {
              changedLines.push(context.line);
            }

            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, context);
            }

            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }

          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);

        if (changedLines.length) {
          runInOp(cm, function () {
            for (var i = 0; i < changedLines.length; i++) {
              regLineChange(cm, changedLines[i], "text");
            }
          });
        }
      } // DISPLAY DRAWING


      var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)

        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };

      DisplayUpdate.prototype.signal = function (emitter, type) {
        if (hasHandler(emitter, type)) {
          this.events.push(arguments);
        }
      };

      DisplayUpdate.prototype.finish = function () {
        for (var i = 0; i < this.events.length; i++) {
          signal.apply(null, this.events[i]);
        }
      };

      function maybeClipScrollbars(cm) {
        var display = cm.display;

        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }

      function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
          return null;
        }

        var active = activeElt();

        if (!active || !contains(cm.display.lineDiv, active)) {
          return null;
        }

        var result = {
          activeElt: active
        };

        if (window.getSelection) {
          var sel = window.getSelection();

          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }

        return result;
      }

      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
          return;
        }

        snapshot.activeElt.focus();

        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var sel = window.getSelection(),
              range = document.createRange();
          range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      } // Does the actual updating of the line display. Bails out
      // (returning false) when there is nothing to be done and forced is
      // false.


      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display,
            doc = cm.doc;

        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        } // Bail out if the visible area is already rendered and nothing changed.


        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }

        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        } // Compute a suitable new viewport (from & to)


        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);

        if (display.viewFrom < from && from - display.viewFrom < 20) {
          from = Math.max(doc.first, display.viewFrom);
        }

        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }

        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }

        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position

        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);

        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        } // For big changes, we hide the enclosing element during the
        // update, since that speeds up the operations on most browsers.


        var selSnapshot = selectionSnapshot(cm);

        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }

        patchDisplay(cm, display.updateLineNumbers, update.dims);

        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }

        display.renderedView = display.view; // There might have been a widget with a focused element that got
        // hidden or updated, if so re-focus it.

        restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll
        // width and height.

        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;

        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }

        display.updateLineNumbers = null;
        return true;
      }

      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;

        for (var first = true;; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            // Clip forced viewport to actual scrollable area.
            if (viewport && viewport.top != null) {
              viewport = {
                top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
              };
            } // Updated line heights might result in the drawn area not
            // actually covering the viewport. Keep looping until it does.


            update.visible = visibleLines(cm.display, cm.doc, viewport);

            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          } else if (first) {
            update.visible = visibleLines(cm.display, cm.doc, viewport);
          }

          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }

          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }

        update.signal(cm, "update", cm);

        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }

      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);

        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      } // Sync the actual display DOM structure with display.view, removing
      // nodes for lines that are no longer in view, and creating the ones
      // that are not there yet, and updating the ones that are out of
      // date.


      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv,
            cur = container.firstChild;

        function rm(node) {
          var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit

          if (webkit && mac && cm.display.currentWheelTarget == node) {
            node.style.display = "none";
          } else {
            node.parentNode.removeChild(node);
          }

          return next;
        }

        var view = display.view,
            lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
        // in display.lineDiv) with the view as we go.

        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {
            // Not drawn yet
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            // Already drawn
            while (cur != lineView.node) {
              cur = rm(cur);
            }

            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;

            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }

              updateLineForChanges(cm, lineView, lineN, dims);
            }

            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }

            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }

        while (cur) {
          cur = rm(cur);
        }
      }

      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px"; // Send an event to consumers responding to changes in gutter width.

        signalLater(display, "gutterChanged", display);
      }

      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      } // Re-align line numbers and gutter marks to compensate for
      // horizontal scrolling.


      function alignHorizontally(cm) {
        var display = cm.display,
            view = display.view;

        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }

        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            left = comp + "px";

        for (var i = 0; i < view.length; i++) {
          if (!view[i].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i].gutter) {
                view[i].gutter.style.left = left;
              }

              if (view[i].gutterBackground) {
                view[i].gutterBackground.style.left = left;
              }
            }

            var align = view[i].alignable;

            if (align) {
              for (var j = 0; j < align.length; j++) {
                align[j].style.left = left;
              }
            }
          }
        }

        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      } // Used to ensure that the line number gutter is still the right
      // size for the current document size. Returns true when an update
      // is needed.


      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }

        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;

        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true;
        }

        return false;
      }

      function getGutters(gutters, lineNumbers) {
        var result = [],
            sawLineNumbers = false;

        for (var i = 0; i < gutters.length; i++) {
          var name = gutters[i],
              style = null;

          if (typeof name != "string") {
            style = name.style;
            name = name.className;
          }

          if (name == "CodeMirror-linenumbers") {
            if (!lineNumbers) {
              continue;
            } else {
              sawLineNumbers = true;
            }
          }

          result.push({
            className: name,
            style: style
          });
        }

        if (lineNumbers && !sawLineNumbers) {
          result.push({
            className: "CodeMirror-linenumbers",
            style: null
          });
        }

        return result;
      } // Rebuild the gutter elements, ensure the margin to the left of the
      // code matches their width.


      function renderGutters(display) {
        var gutters = display.gutters,
            specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;

        for (var i = 0; i < specs.length; ++i) {
          var ref = specs[i];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));

          if (style) {
            gElt.style.cssText = style;
          }

          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }

        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }

      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      } // The display handles the DOM integration, both for input reading
      // and content drawing. It holds references to DOM nodes and
      // display-related state.


      function Display(place, doc, input, options) {
        var d = this;
        this.input = input; // Covers bottom-right square when both scrollbars are present.

        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
        // and h scrollbar is present.

        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true"); // Will contain the actual code, positioned to cover the viewport.

        d.lineDiv = eltP("div", null, "CodeMirror-code"); // Elements are added to these to represent selection and cursors.

        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.

        d.measure = elt("div", null, "CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.

        d.lineMeasure = elt("div", null, "CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system

        d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        var lines = eltP("div", [d.lineSpace], "CodeMirror-lines"); // Moved around its parent to cover visible view.

        d.mover = elt("div", [lines], null, "position: relative"); // Set to the height of the document, allowing scrolling.

        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is
        // inconsistent across browsers. This is used to ensure the
        // scrollable area is big enough.

        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"); // Will contain the gutters, if any.

        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null; // Actual scrollable element.

        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1"); // The element in which the editor lives.

        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"); // This attribute is respected by automatic translation systems such as Google Translate,
        // and may also be respected by tools used by human translators.

        d.wrapper.setAttribute('translate', 'no'); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)

        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }

        if (!webkit && !(gecko && mobile)) {
          d.scroller.draggable = true;
        }

        if (place) {
          if (place.appendChild) {
            place.appendChild(d.wrapper);
          } else {
            place(d.wrapper);
          }
        } // Current rendered range (may be bigger than the view window).


        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.

        d.view = [];
        d.renderedView = null; // Holds info about a single rendered line when it was rendered
        // for measurement, while not in view.

        d.externalMeasured = null; // Empty space (in pixels) above the view

        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when
        // the amount of lines crosses a boundary that makes its width change)

        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is
        // added. As an optimization, line widget aligning is skipped when
        // this is false.

        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar
        // can be kept static when scrolling.

        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false; // Used for measuring wheel scrolling granularity

        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.

        d.shift = false; // Used to track whether anything happened since the context menu
        // was opened.

        d.selForContextMenu = null;
        d.activeTouch = null;
        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);
        input.init(d);
      } // Since the delta values reported on mouse wheel events are
      // unstandardized between browsers and even browser versions, and
      // generally horribly unpredictable, this code starts by measuring
      // the scroll effect that the first few mouse wheel events have,
      // and, from that, detects the way it can convert deltas to pixel
      // offsets afterwards.
      //
      // The reason we want to know the amount a wheel event will scroll
      // is that it gives us a chance to update the display before the
      // actual scrolling happens, reducing flickering.


      var wheelSamples = 0,
          wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
      // know one. These don't have to be accurate -- the result of them
      // being wrong would just be a slight flicker on the first wheel
      // scroll (if it is large enough).

      if (ie) {
        wheelPixelsPerUnit = -.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }

      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;

        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
          dx = e.detail;
        }

        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
          dy = e.detail;
        } else if (dy == null) {
          dy = e.wheelDelta;
        }

        return {
          x: dx,
          y: dy
        };
      }

      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }

      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y;
        var pixelsPerUnit = wheelPixelsPerUnit;

        if (e.deltaMode === 0) {
          dx = e.deltaX;
          dy = e.deltaY;
          pixelsPerUnit = 1;
        }

        var display = cm.display,
            scroll = display.scroller; // Quit if there's nothing to scroll here

        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;

        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        } // Webkit browsers on OS X abort momentum scrolls when the target
        // of the scroll event is removed from the scrollable element.
        // This hack (see related code in patchDisplay) makes sure the
        // element is kept around.


        if (dy && mac && webkit) {
          outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        } // On some browsers, horizontal scrolling will cause redraws to
        // happen before the gutter has been realigned, causing it to
        // wriggle around in a most unseemly way. When we have an
        // estimated pixels/delta value, we just handle horizontal
        // scrolling entirely here. It'll be slightly off from native, but
        // better than glitching out.


        if (dx && !gecko && !presto && pixelsPerUnit != null) {
          if (dy && canScrollY) {
            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
          }

          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
          // actually possible. Otherwise, it causes vertical scroll
          // jitter on OSX trackpads when deltaX is small and deltaY
          // is large (issue #3579)

          if (!dy || dy && canScrollY) {
            e_preventDefault(e);
          }

          display.wheelStartX = null; // Abort measurement, if in progress

          return;
        } // 'Project' the visible viewport to cover the area that is being
        // scrolled into view (if we know enough to estimate it).


        if (dy && pixelsPerUnit != null) {
          var pixels = dy * pixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;

          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }

          updateDisplaySimple(cm, {
            top: top,
            bottom: bot
          });
        }

        if (wheelSamples < 20 && e.deltaMode !== 0) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) {
                return;
              }

              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;

              if (!sample) {
                return;
              }

              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      } // Selection objects are immutable. A new one is created every time
      // the selection changes. A selection is one or more non-overlapping
      // (and non-touching) ranges, sorted, and an integer that indicates
      // which one is the primary selection (the one that's scrolled into
      // view, that getCursor returns, etc).


      var Selection = function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };

      Selection.prototype.primary = function () {
        return this.ranges[this.primIndex];
      };

      Selection.prototype.equals = function (other) {
        if (other == this) {
          return true;
        }

        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
          return false;
        }

        for (var i = 0; i < this.ranges.length; i++) {
          var here = this.ranges[i],
              there = other.ranges[i];

          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
            return false;
          }
        }

        return true;
      };

      Selection.prototype.deepCopy = function () {
        var out = [];

        for (var i = 0; i < this.ranges.length; i++) {
          out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
        }

        return new Selection(out, this.primIndex);
      };

      Selection.prototype.somethingSelected = function () {
        for (var i = 0; i < this.ranges.length; i++) {
          if (!this.ranges[i].empty()) {
            return true;
          }
        }

        return false;
      };

      Selection.prototype.contains = function (pos, end) {
        if (!end) {
          end = pos;
        }

        for (var i = 0; i < this.ranges.length; i++) {
          var range = this.ranges[i];

          if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
            return i;
          }
        }

        return -1;
      };

      var Range = function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };

      Range.prototype.from = function () {
        return minPos(this.anchor, this.head);
      };

      Range.prototype.to = function () {
        return maxPos(this.anchor, this.head);
      };

      Range.prototype.empty = function () {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      }; // Take an unsorted, potentially overlapping set of ranges, and
      // build a selection out of it. 'Consumes' ranges array (modifying
      // it).


      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);

        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i],
              prev = ranges[i - 1];
          var diff = cmp(prev.to(), cur.from());

          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
            var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;

            if (i <= primIndex) {
              --primIndex;
            }

            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }

        return new Selection(ranges, primIndex);
      }

      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      } // Compute the position of the end of a change (its 'to' property
      // refers to the pre-change end).


      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }

        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      } // Adjust a position to refer to the post-change position of the
      // same text, or the end of the change if the change covers it.


      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }

        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }

        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
            ch = pos.ch;

        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }

        return Pos(line, ch);
      }

      function computeSelAfterChange(doc, change) {
        var out = [];

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }

        return normalizeSelection(doc.cm, out, doc.sel.primIndex);
      }

      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      } // Used by replaceSelections to allow moving the selection to the
      // start or around the replaced test. Hint may be "start" or "around".


      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev;

        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;

          if (hint == "around") {
            var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }

        return new Selection(out, doc.sel.primIndex);
      } // Used to get the editor into a consistent state again when options change.


      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }

      function resetModeState(cm) {
        cm.doc.iter(function (line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }

          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;

        if (cm.curOp) {
          regChange(cm);
        }
      } // DOCUMENT DATA STRUCTURE
      // By default, updates that start and end at the beginning of a line
      // are treated specially, in order to make the association of line
      // widgets and marker elements with the text behave more intuitive.


      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      } // Perform a change on the document data structure.


      function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }

        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }

        function linesFor(start, end) {
          var result = [];

          for (var i = start; i < end; ++i) {
            result.push(new Line(text[i], spansFor(i), estimateHeight));
          }

          return result;
        }

        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line; // Adjust the line structure

        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          // This is a whole-line replace. Treated specially to make
          // sure line objects move the way they are supposed to.
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);

          if (nlines) {
            doc.remove(from.line, nlines);
          }

          if (added.length) {
            doc.insert(from.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);

          if (nlines > 1) {
            doc.remove(from.line + 1, nlines - 1);
          }

          doc.insert(from.line + 1, added$2);
        }

        signalLater(doc, "change", doc, change);
      } // Call f for all linked documents.


      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) {
            for (var i = 0; i < doc.linked.length; ++i) {
              var rel = doc.linked[i];

              if (rel.doc == skip) {
                continue;
              }

              var shared = sharedHist && rel.sharedHist;

              if (sharedHistOnly && !shared) {
                continue;
              }

              f(rel.doc, shared);
              propagate(rel.doc, doc, shared);
            }
          }
        }

        propagate(doc, null, true);
      } // Attach a document to an editor.


      function attachDoc(cm, doc) {
        if (doc.cm) {
          throw new Error("This document is already in use.");
        }

        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        cm.options.direction = doc.direction;

        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }

        cm.options.mode = doc.modeOption;
        regChange(cm);
      }

      function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }

      function directionChanged(cm) {
        runInOp(cm, function () {
          setDirectionClass(cm);
          regChange(cm);
        });
      }

      function History(prev) {
        // Arrays of change events and selections. Doing something adds an
        // event to done and clears undo. Undoing moves events from done
        // to undone, redoing moves them in the other direction.
        this.done = [];
        this.undone = [];
        this.undoDepth = prev ? prev.undoDepth : Infinity; // Used to track when changes can be merged into a single undo
        // event

        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method

        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
      } // Create a history change event from an updateDoc-style change
      // object.


      function historyChangeFromChange(doc, change) {
        var histChange = {
          from: copyPos(change.from),
          to: changeEnd(change),
          text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
          return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      } // Pop all selection events off the end of a history array. Stop at
      // a change event.


      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);

          if (last.ranges) {
            array.pop();
          } else {
            break;
          }
        }
      } // Find the top change event in the history. Pop off selection
      // events that are in the way.


      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      } // Register a change in the history. Merges changes that are within
      // a single operation, or are close together with an origin that
      // allows merging (starting with "+") into a single event.


      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(),
            cur;
        var last;

        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          // Merge this change into the last event
          last = lst(cur.changes);

          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            // Optimized case for simple insertion -- don't want to add
            // new changesets for every character typed
            last.to = changeEnd(change);
          } else {
            // Add new sub-event
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          // Can not be merged, start a new event.
          var before = lst(hist.done);

          if (!before || !before.ranges) {
            pushSelectionToHistory(doc.sel, hist.done);
          }

          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);

          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();

            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }

        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;

        if (!last) {
          signal(doc, "historyAdded");
        }
      }

      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      } // Called whenever the selection changes, sets the new selection as
      // the pending selection in the history, and pushes the old pending
      // selection into the 'done' array when it was significantly
      // different (in number of selected ranges, emptiness, or time).


      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history,
            origin = options && options.origin; // A new event is started when the previous origin does not match
        // the current, or the origins don't allow matching. Origins
        // starting with * are always merged, those starting with + are
        // merged when similar and close together in time.

        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }

        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;

        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }

      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);

        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      } // Used to store marked span information in the history.


      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          }

          ++n;
        });
      } // When un/re-doing restores text containing marked spans, those
      // that have been explicitly cleared should not be restored.


      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }

        var out;

        for (var i = 0; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i);
            }
          } else if (out) {
            out.push(spans[i]);
          }
        }

        return !out ? spans : out.length ? out : null;
      } // Retrieve and filter the old marked spans stored in a change event.


      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];

        if (!found) {
          return null;
        }

        var nw = [];

        for (var i = 0; i < change.text.length; ++i) {
          nw.push(removeClearedSpans(found[i]));
        }

        return nw;
      } // Used for un/re-doing changes from the history. Combines the
      // result of computing the existing spans with the set of spans that
      // existed in the history (so that deleting around a span and then
      // undoing brings back the span).


      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);

        if (!old) {
          return stretched;
        }

        if (!stretched) {
          return old;
        }

        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];

          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];

              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }

              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }

        return old;
      } // Used both to provide a JSON-safe object in .getHistory, and, when
      // detaching a document, to split the history in two


      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];

        for (var i = 0; i < events.length; ++i) {
          var event = events[i];

          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }

          var changes = event.changes,
              newChanges = [];
          copy.push({
            changes: newChanges
          });

          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m = void 0;
            newChanges.push({
              from: change.from,
              to: change.to,
              text: change.text
            });

            if (newGroup) {
              for (var prop in change) {
                if (m = prop.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop] = change[prop];
                    delete change[prop];
                  }
                }
              }
            }
          }
        }

        return copy;
      } // The 'scroll' parameter given to many of these indicated whether
      // the new cursor position should be scrolled into view after
      // modifying the selection.
      // If shift is held or the extend flag is set, extends a range to
      // include a given position (and optionally a second position).
      // Otherwise, simply returns the range between the given positions.
      // Used for cursor motion and such.


      function extendRange(range, head, other, extend) {
        if (extend) {
          var anchor = range.anchor;

          if (other) {
            var posBefore = cmp(head, anchor) < 0;

            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }

          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      } // Extend the primary selection range, discard the rest.


      function extendSelection(doc, head, other, options, extend) {
        if (extend == null) {
          extend = doc.cm && (doc.cm.display.shift || doc.extend);
        }

        setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
      } // Extend all selections (pos is an array of selections with length
      // equal the number of selections)


      function extendSelections(doc, heads, options) {
        var out = [];
        var extend = doc.cm && (doc.cm.display.shift || doc.extend);

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
        }

        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      } // Updates a single range in the selection.


      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
      } // Reset the selection to a single range.


      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      } // Give beforeSelectionChange handlers a change to influence a
      // selection update.


      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function update(ranges) {
            this.ranges = [];

            for (var i = 0; i < ranges.length; i++) {
              this.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));
            }
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);

        if (doc.cm) {
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        }

        if (obj.ranges != sel.ranges) {
          return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }

      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done,
            last = lst(done);

        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      } // Set a new selection.


      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }

      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc, sel, options);
        }

        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

        if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
          ensureCursorVisible(doc.cm);
        }
      }

      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) {
          return;
        }

        doc.sel = sel;

        if (doc.cm) {
          doc.cm.curOp.updateInput = 1;
          doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }

        signalLater(doc, "cursorActivity", doc);
      } // Verify that the selection does not partially select any atomic
      // marked ranges.


      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
      } // Return a selection that does not partially select any atomic
      // ranges.


      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;

        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);

          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out) {
              out = sel.ranges.slice(0, i);
            }

            out[i] = new Range(newAnchor, newHead);
          }
        }

        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
      }

      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);

        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i],
                m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
            // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
            // is with selectLeft/Right

            var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
            var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;

            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");

                if (m.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i;
                    continue;
                  }
                }
              }

              if (!m.atomic) {
                continue;
              }

              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1),
                    diff = void 0;

                if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                  near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                }

                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                  return skipAtomicInner(doc, near, pos, dir, mayClear);
                }
              }

              var far = m.find(dir < 0 ? -1 : 1);

              if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                far = movePos(doc, far, dir, far.line == pos.line ? line : null);
              }

              return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
          }
        }

        return pos;
      } // Ensure a given position is not inside an atomic range.


      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);

        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0);
        }

        return found;
      }

      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first) {
            return _clipPos(doc, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }

      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      } // UPDATING
      // Allow "beforeChange" event handlers to influence a change


      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function cancel() {
            return obj.canceled = true;
          }
        };

        if (update) {
          obj.update = function (from, to, text, origin) {
            if (from) {
              obj.from = _clipPos(doc, from);
            }

            if (to) {
              obj.to = _clipPos(doc, to);
            }

            if (text) {
              obj.text = text;
            }

            if (origin !== undefined) {
              obj.origin = origin;
            }
          };
        }

        signal(doc, "beforeChange", doc, obj);

        if (doc.cm) {
          signal(doc.cm, "beforeChange", doc.cm, obj);
        }

        if (obj.canceled) {
          if (doc.cm) {
            doc.cm.curOp.updateInput = 2;
          }

          return null;
        }

        return {
          from: obj.from,
          to: obj.to,
          text: obj.text,
          origin: obj.origin
        };
      } // Apply a change to a document, and add it to the document's
      // history, and propagating it to all linked documents.


      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) {
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          }

          if (doc.cm.state.suppressEdits) {
            return;
          }
        }

        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);

          if (!change) {
            return;
          }
        } // Possibly split or suppress the update based on the presence
        // of read-only spans in its range.


        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);

        if (split) {
          for (var i = split.length - 1; i >= 0; --i) {
            makeChangeInner(doc, {
              from: split[i].from,
              to: split[i].to,
              text: i ? [""] : change.text,
              origin: change.origin
            });
          }
        } else {
          makeChangeInner(doc, change);
        }
      }

      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }

        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }

          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      } // Revert a change stored in a document's history.


      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        var suppress = doc.cm && doc.cm.state.suppressEdits;

        if (suppress && !allowSelectionOnly) {
          return;
        }

        var hist = doc.history,
            event,
            selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone,
            dest = type == "undo" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't
        // needlessly clear selection events)

        var i = 0;

        for (; i < source.length; i++) {
          event = source[i];

          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
            break;
          }
        }

        if (i == source.length) {
          return;
        }

        hist.lastOrigin = hist.lastSelOrigin = null;

        for (;;) {
          event = source.pop();

          if (event.ranges) {
            pushSelectionToHistory(event, dest);

            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, {
                clearRedo: false
              });
              return;
            }

            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return;
          } else {
            break;
          }
        } // Build up a reverse change object to add to the opposite history
        // stack (redo when undoing, and vice versa).


        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
          changes: antiChanges,
          generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

        var loop = function loop(i) {
          var change = event.changes[i];
          change.origin = type;

          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return {};
          }

          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));

          if (!i && doc.cm) {
            doc.cm.scrollIntoView({
              from: change.from,
              to: changeEnd(change)
            });
          }

          var rebased = []; // Propagate to the linked documents

          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }

            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        };

        for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
          var returned = loop(i$1);
          if (returned) return returned.v;
        }
      } // Sub-views need their line numbers shifted when text is added
      // above or below them in the parent document.


      function shiftDoc(doc, distance) {
        if (distance == 0) {
          return;
        }

        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) {
          return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);

        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);

          for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
            regLineChange(doc.cm, l, "gutter");
          }
        }
      } // More lower-level change function, handling only a single document
      // (not linked ones).


      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        }

        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }

        if (change.from.line > doc.lastLine()) {
          return;
        } // Clip the change to the size of this doc


        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }

        var last = doc.lastLine();

        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }

        change.removed = getBetween(doc, change.from, change.to);

        if (!selAfter) {
          selAfter = computeSelAfterChange(doc, change);
        }

        if (doc.cm) {
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        } else {
          updateDoc(doc, change, spans);
        }

        setSelectionNoUndo(doc, selAfter, sel_dontScroll);

        if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
          doc.cantEdit = false;
        }
      } // Handle the interaction of a change to a document with the editor
      // that this document is part of.


      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;
        var recomputeMaxLength = false,
            checkWidthStart = from.line;

        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }

        if (doc.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }

        updateDoc(doc, change, spans, estimateHeight(cm));

        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(line);

            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });

          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }

        retreatFrontier(doc, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display

        if (change.full) {
          regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from.line, "text");
        } else {
          regChange(cm, from.line, to.line + 1, lendiff);
        }

        var changesHandler = hasHandler(cm, "changes"),
            changeHandler = hasHandler(cm, "change");

        if (changeHandler || changesHandler) {
          var obj = {
            from: from,
            to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };

          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }

          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }

        cm.display.selForContextMenu = null;
      }

      function _replaceRange(doc, code, from, to, origin) {
        var assign;

        if (!to) {
          to = from;
        }

        if (cmp(to, from) < 0) {
          assign = [to, from], from = assign[0], to = assign[1];
        }

        if (typeof code == "string") {
          code = doc.splitLines(code);
        }

        makeChange(doc, {
          from: from,
          to: to,
          text: code,
          origin: origin
        });
      } // Rebasing/resetting history to deal with externally-sourced changes


      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      } // Tries to rebase an array of history events given a change in the
      // document. If the change touches the same lines as the event, the
      // event, and everything 'behind' it, is discarded. If the change is
      // before the event, the event's positions are updated. Uses a
      // copy-on-write scheme for the positions, to avoid having to
      // reallocate them all on every rebase, but also avoid problems with
      // shared position objects being unsafely updated.


      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;

          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i] = sub.deepCopy();
              sub.copied = true;
            }

            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }

            continue;
          }

          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];

            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }

          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }

      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      } // Utility for applying a change to a line by handle or number,
      // returning the number and optionally registering the line as
      // changed.


      function changeLine(doc, handle, changeType, op) {
        var no = handle,
            line = handle;

        if (typeof handle == "number") {
          line = getLine(doc, clipLine(doc, handle));
        } else {
          no = lineNo(handle);
        }

        if (no == null) {
          return null;
        }

        if (op(line, no) && doc.cm) {
          regLineChange(doc.cm, no, changeType);
        }

        return line;
      } // The document is represented as a BTree consisting of leaves, with
      // chunk of lines in them, and branches, with up to ten leaves or
      // other branch nodes below them. The top node is always a branch
      // node, and is the document object itself (meaning it has
      // additional methods and properties).
      //
      // All nodes have parent links. The tree is used both to go from
      // line numbers to line objects, and to go from objects to numbers.
      // It also indexes by height, and is used to convert between height
      // and line object, and to find the total height of the document.
      //
      // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html


      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;

        for (var i = 0; i < lines.length; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }

        this.height = height;
      }

      LeafChunk.prototype = {
        chunkSize: function chunkSize() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function removeInner(at, n) {
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }

          this.lines.splice(at, n);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function collapse(lines) {
          lines.push.apply(lines, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function insertInner(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

          for (var i = 0; i < lines.length; ++i) {
            lines[i].parent = this;
          }
        },
        // Used to iterate over a part of the tree.
        iterN: function iterN(at, n, op) {
          for (var e = at + n; at < e; ++at) {
            if (op(this.lines[at])) {
              return true;
            }
          }
        }
      };

      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;

        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }

        this.size = size;
        this.height = height;
        this.parent = null;
      }

      BranchChunk.prototype = {
        chunkSize: function chunkSize() {
          return this.size;
        },
        removeInner: function removeInner(at, n) {
          this.size -= n;

          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;

              if (sz == rm) {
                this.children.splice(i--, 1);
                child.parent = null;
              }

              if ((n -= rm) == 0) {
                break;
              }

              at = 0;
            } else {
              at -= sz;
            }
          } // If the result is smaller than 25 lines, ensure that it is a
          // single leaf node.


          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function collapse(lines) {
          for (var i = 0; i < this.children.length; ++i) {
            this.children[i].collapse(lines);
          }
        },
        insertInner: function insertInner(at, lines, height) {
          this.size += lines.length;
          this.height += height;

          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at <= sz) {
              child.insertInner(at, lines, height);

              if (child.lines && child.lines.length > 50) {
                // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
                // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
                var remaining = child.lines.length % 25 + 25;

                for (var pos = remaining; pos < child.lines.length;) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i, 0, leaf);
                  leaf.parent = this;
                }

                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }

              break;
            }

            at -= sz;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function maybeSpill() {
          if (this.children.length <= 10) {
            return;
          }

          var me = this;

          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);

            if (!me.parent) {
              // Become the parent node
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }

            sibling.parent = me.parent;
          } while (me.children.length > 10);

          me.parent.maybeSpill();
        },
        iterN: function iterN(at, n, op) {
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at < sz) {
              var used = Math.min(n, sz - at);

              if (child.iterN(at, used, op)) {
                return true;
              }

              if ((n -= used) == 0) {
                break;
              }

              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      }; // Line widgets are block elements displayed above or below a line.

      var LineWidget = function LineWidget(doc, node, options) {
        if (options) {
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              this[opt] = options[opt];
            }
          }
        }

        this.doc = doc;
        this.node = node;
      };

      LineWidget.prototype.clear = function () {
        var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line);

        if (no == null || !ws) {
          return;
        }

        for (var i = 0; i < ws.length; ++i) {
          if (ws[i] == this) {
            ws.splice(i--, 1);
          }
        }

        if (!ws.length) {
          line.widgets = null;
        }

        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));

        if (cm) {
          runInOp(cm, function () {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };

      LineWidget.prototype.changed = function () {
        var this$1 = this;
        var oldH = this.height,
            cm = this.doc.cm,
            line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;

        if (!diff) {
          return;
        }

        if (!lineIsHidden(this.doc, line)) {
          updateLineHeight(line, line.height + diff);
        }

        if (cm) {
          runInOp(cm, function () {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
          });
        }
      };

      eventMixin(LineWidget);

      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollTop(cm, diff);
        }
      }

      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;

        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }

        changeLine(doc, handle, "widget", function (line) {
          var widgets = line.widgets || (line.widgets = []);

          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
          }

          widget.line = line;

          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = _heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));

            if (aboveVisible) {
              addToScrollTop(cm, widget.height);
            }

            cm.curOp.forceUpdate = true;
          }

          return true;
        });

        if (cm) {
          signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }

        return widget;
      } // TEXTMARKERS
      // Created with markText and setBookmark methods. A TextMarker is a
      // handle that can be used to clear or find a marked position in the
      // document. Line objects hold arrays (markedSpans) containing
      // {from, to, marker} object pointing to such marker objects, and
      // indicating that such a marker is present on that line. Multiple
      // lines may point to the same marker when it spans across lines.
      // The spans will have null for their from/to properties when the
      // marker continues beyond the start/end of the line. Markers have
      // links back to the lines they currently touch.
      // Collapsed markers have unique ids, in order to be able to order
      // them, which is needed for uniquely determining an outer marker
      // when they overlap (they may nest, but not partially overlap).


      var nextMarkerId = 0;

      var TextMarker = function TextMarker(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      }; // Clear the marker.


      TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) {
          return;
        }

        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;

        if (withOp) {
          _startOperation(cm);
        }

        if (hasHandler(this, "clear")) {
          var found = this.find();

          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }

        var min = null,
            max = null;

        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);

          if (cm && !this.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max = lineNo(line);
            }

            if (span.from != null) {
              min = lineNo(line);
            }
          }

          line.markedSpans = removeMarkedSpan(line.markedSpans, span);

          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }

        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
            var visual = visualLine(this.lines[i$1]),
                len = lineLength(visual);

            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        }

        if (min != null && cm && this.collapsed) {
          regChange(cm, min, max + 1);
        }

        this.lines.length = 0;
        this.explicitlyCleared = true;

        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;

          if (cm) {
            reCheckSelection(cm.doc);
          }
        }

        if (cm) {
          signalLater(cm, "markerCleared", cm, this, min, max);
        }

        if (withOp) {
          _endOperation(cm);
        }

        if (this.parent) {
          this.parent.clear();
        }
      }; // Find the position of the marker in the document. Returns a {from,
      // to} object by default. Side can be passed to get a specific side
      // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
      // Pos objects returned contain a line object, rather than a line
      // number (used to prevent looking up the same line twice).


      TextMarker.prototype.find = function (side, lineObj) {
        if (side == null && this.type == "bookmark") {
          side = 1;
        }

        var from, to;

        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);

          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);

            if (side == -1) {
              return from;
            }
          }

          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);

            if (side == 1) {
              return to;
            }
          }
        }

        return from && {
          from: from,
          to: to
        };
      }; // Signals that the marker's widget changed, and surrounding layout
      // should be recomputed.


      TextMarker.prototype.changed = function () {
        var this$1 = this;
        var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm;

        if (!pos || !cm) {
          return;
        }

        runInOp(cm, function () {
          var line = pos.line,
              lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);

          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }

          cm.curOp.updateMaxLine = true;

          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;

            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }

          signalLater(cm, "markerChanged", cm, this$1);
        });
      };

      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;

          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }

        this.lines.push(line);
      };

      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);

        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };

      eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and

      function _markText(doc, from, to, options, type) {
        // Shared markers (across linked documents) are handled separately
        // (markTextShared will call out to this again, once per
        // document).
        if (options && options.shared) {
          return markTextShared(doc, from, to, options, type);
        } // Ensure we are in an operation.


        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, _markText)(doc, from, to, options, type);
        }

        var marker = new TextMarker(doc, type),
            diff = cmp(from, to);

        if (options) {
          copyObj(options, marker, false);
        } // Don't connect empty markers unless clearWhenEmpty is false


        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }

        if (marker.replacedWith) {
          // Showing up as a widget implies collapsed (widget replaces text)
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");

          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }

          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }

        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }

          seeCollapsedSpans();
        }

        if (marker.addToHistory) {
          addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
          }, doc.sel, NaN);
        }

        var curLine = from.line,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }

          if (marker.collapsed && curLine != from.line) {
            updateLineHeight(line, 0);
          }

          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
          ++curLine;
        }); // lineIsHidden depends on the presence of the spans, so needs a second pass

        if (marker.collapsed) {
          doc.iter(from.line, to.line + 1, function (line) {
            if (lineIsHidden(doc, line)) {
              updateLineHeight(line, 0);
            }
          });
        }

        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function () {
            return marker.clear();
          });
        }

        if (marker.readOnly) {
          seeReadOnlySpans();

          if (doc.history.done.length || doc.history.undone.length) {
            doc.clearHistory();
          }
        }

        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }

        if (cm) {
          // Sync editor state
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }

          if (marker.collapsed) {
            regChange(cm, from.line, to.line + 1);
          } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
            for (var i = from.line; i <= to.line; i++) {
              regLineChange(cm, i, "text");
            }
          }

          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }

          signalLater(cm, "markerAdded", cm, marker);
        }

        return marker;
      } // SHARED TEXTMARKERS
      // A shared marker spans multiple linked documents. It is
      // implemented as a meta-marker-object controlling multiple normal
      // markers.


      var SharedTextMarker = function SharedTextMarker(markers, primary) {
        this.markers = markers;
        this.primary = primary;

        for (var i = 0; i < markers.length; ++i) {
          markers[i].parent = this;
        }
      };

      SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) {
          return;
        }

        this.explicitlyCleared = true;

        for (var i = 0; i < this.markers.length; ++i) {
          this.markers[i].clear();
        }

        signalLater(this, "clear");
      };

      SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj);
      };

      eventMixin(SharedTextMarker);

      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [_markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }

          markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));

          for (var i = 0; i < doc.linked.length; ++i) {
            if (doc.linked[i].isParent) {
              return;
            }
          }

          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }

      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
          return m.parent;
        });
      }

      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              pos = marker.find();
          var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to);

          if (cmp(mFrom, mTo)) {
            var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);

            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }

      function detachSharedMarkers(markers) {
        var loop = function loop(i) {
          var marker = markers[i],
              linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function (d) {
            return linked.push(d);
          });

          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];

            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };

        for (var i = 0; i < markers.length; i++) {
          loop(i);
        }
      }

      var nextDocId = 0;

      var Doc = function Doc(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
          return new Doc(text, mode, firstLine, lineSep, direction);
        }

        if (firstLine == null) {
          firstLine = 0;
        }

        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;

        if (typeof text == "string") {
          text = this.splitLines(text);
        }

        updateDoc(this, {
          from: start,
          to: start,
          text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };

      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function iter(from, to, op) {
          if (op) {
            this.iterN(from - this.first, to - from, op);
          } else {
            this.iterN(this.first, this.first + this.size, from);
          }
        },
        // Non-public interface for adding and removing lines.
        insert: function insert(at, lines) {
          var height = 0;

          for (var i = 0; i < lines.length; ++i) {
            height += lines[i].height;
          }

          this.insertInner(at - this.first, lines, height);
        },
        remove: function remove(at, n) {
          this.removeInner(at - this.first, n);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function getValue(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);

          if (lineSep === false) {
            return lines;
          }

          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function (code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);

          if (this.cm) {
            scrollToCoords(this.cm, 0, 0);
          }

          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function replaceRange(code, from, to, origin) {
          from = _clipPos(this, from);
          to = to ? _clipPos(this, to) : from;

          _replaceRange(this, code, from, to, origin);
        },
        getRange: function getRange(from, to, lineSep) {
          var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));

          if (lineSep === false) {
            return lines;
          }

          if (lineSep === '') {
            return lines.join('');
          }

          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function getLine(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function getLineHandle(line) {
          if (isLine(this, line)) {
            return getLine(this, line);
          }
        },
        getLineNumber: function getLineNumber(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function getLineHandleVisualStart(line) {
          if (typeof line == "number") {
            line = getLine(this, line);
          }

          return visualLine(line);
        },
        lineCount: function lineCount() {
          return this.size;
        },
        firstLine: function firstLine() {
          return this.first;
        },
        lastLine: function lastLine() {
          return this.first + this.size - 1;
        },
        clipPos: function clipPos(pos) {
          return _clipPos(this, pos);
        },
        getCursor: function getCursor(start) {
          var range = this.sel.primary(),
              pos;

          if (start == null || start == "head") {
            pos = range.head;
          } else if (start == "anchor") {
            pos = range.anchor;
          } else if (start == "end" || start == "to" || start === false) {
            pos = range.to();
          } else {
            pos = range.from();
          }

          return pos;
        },
        listSelections: function listSelections() {
          return this.sel.ranges;
        },
        somethingSelected: function somethingSelected() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function (line, ch, options) {
          setSimpleSelection(this, _clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function (anchor, head, options) {
          setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function (head, other, options) {
          extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function (heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function (f, options) {
          var heads = map(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function (ranges, primary, options) {
          if (!ranges.length) {
            return;
          }

          var out = [];

          for (var i = 0; i < ranges.length; i++) {
            out[i] = new Range(_clipPos(this, ranges[i].anchor), _clipPos(this, ranges[i].head || ranges[i].anchor));
          }

          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }

          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function (anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function getSelection(lineSep) {
          var ranges = this.sel.ranges,
              lines;

          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }

          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function getSelections(lineSep) {
          var parts = [],
              ranges = this.sel.ranges;

          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());

            if (lineSep !== false) {
              sel = sel.join(lineSep || this.lineSeparator());
            }

            parts[i] = sel;
          }

          return parts;
        },
        replaceSelection: function replaceSelection(code, collapse, origin) {
          var dup = [];

          for (var i = 0; i < this.sel.ranges.length; i++) {
            dup[i] = code;
          }

          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function (code, collapse, origin) {
          var changes = [],
              sel = this.sel;

          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            changes[i] = {
              from: range.from(),
              to: range.to(),
              text: this.splitLines(code[i]),
              origin: origin
            };
          }

          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);

          for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
            makeChange(this, changes[i$1]);
          }

          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function () {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function () {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function setExtending(val) {
          this.extend = val;
        },
        getExtending: function getExtending() {
          return this.extend;
        },
        historySize: function historySize() {
          var hist = this.history,
              done = 0,
              undone = 0;

          for (var i = 0; i < hist.done.length; i++) {
            if (!hist.done[i].ranges) {
              ++done;
            }
          }

          for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
            if (!hist.undone[i$1].ranges) {
              ++undone;
            }
          }

          return {
            undo: done,
            redo: undone
          };
        },
        clearHistory: function clearHistory() {
          var this$1 = this;
          this.history = new History(this.history);
          linkedDocs(this, function (doc) {
            return doc.history = this$1.history;
          }, true);
        },
        markClean: function markClean() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function changeGeneration(forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }

          return this.history.generation;
        },
        isClean: function isClean(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function getHistory() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function setHistory(histData) {
          var hist = this.history = new History(this.history);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function (line, gutterID, value) {
          return changeLine(this, line, "gutter", function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;

            if (!value && isEmpty(markers)) {
              line.gutterMarkers = null;
            }

            return true;
          });
        }),
        clearGutter: docMethodOp(function (gutterID) {
          var this$1 = this;
          this.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1, line, "gutter", function () {
                line.gutterMarkers[gutterID] = null;

                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }

                return true;
              });
            }
          });
        }),
        lineInfo: function lineInfo(line) {
          var n;

          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }

            n = line;
            line = getLine(this, line);

            if (!line) {
              return null;
            }
          } else {
            n = lineNo(line);

            if (n == null) {
              return null;
            }
          }

          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";

            if (!line[prop]) {
              line[prop] = cls;
            } else if (classTest(cls).test(line[prop])) {
              return false;
            } else {
              line[prop] += " " + cls;
            }

            return true;
          });
        }),
        removeLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];

            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop] = null;
            } else {
              var found = cur.match(classTest(cls));

              if (!found) {
                return false;
              }

              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }

            return true;
          });
        }),
        addLineWidget: docMethodOp(function (handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function removeLineWidget(widget) {
          widget.clear();
        },
        markText: function markText(from, to, options) {
          return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function setBookmark(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = _clipPos(this, pos);
          return _markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function findMarksAt(pos) {
          pos = _clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;

          if (spans) {
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i];

              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }

          return markers;
        },
        findMarks: function findMarks(from, to, filter) {
          from = _clipPos(this, from);
          to = _clipPos(this, to);
          var found = [],
              lineNo = from.line;
          this.iter(from.line, to.line + 1, function (line) {
            var spans = line.markedSpans;

            if (spans) {
              for (var i = 0; i < spans.length; i++) {
                var span = spans[i];

                if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }

            ++lineNo;
          });
          return found;
        },
        getAllMarks: function getAllMarks() {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;

            if (sps) {
              for (var i = 0; i < sps.length; ++i) {
                if (sps[i].from != null) {
                  markers.push(sps[i].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function posFromIndex(off) {
          var ch,
              lineNo = this.first,
              sepSize = this.lineSeparator().length;
          this.iter(function (line) {
            var sz = line.text.length + sepSize;

            if (sz > off) {
              ch = off;
              return true;
            }

            off -= sz;
            ++lineNo;
          });
          return _clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function indexFromPos(coords) {
          coords = _clipPos(this, coords);
          var index = coords.ch;

          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }

          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function (line) {
            // iter aborts when callback returns a truthy value
            index += line.text.length + sepSize;
          });
          return index;
        },
        copy: function copy(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;

          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }

          return doc;
        },
        linkedDoc: function linkedDoc(options) {
          if (!options) {
            options = {};
          }

          var from = this.first,
              to = this.first + this.size;

          if (options.from != null && options.from > from) {
            from = options.from;
          }

          if (options.to != null && options.to < to) {
            to = options.to;
          }

          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);

          if (options.sharedHist) {
            copy.history = this.history;
          }

          (this.linked || (this.linked = [])).push({
            doc: copy,
            sharedHist: options.sharedHist
          });
          copy.linked = [{
            doc: this,
            isParent: true,
            sharedHist: options.sharedHist
          }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function unlinkDoc(other) {
          if (other instanceof CodeMirror) {
            other = other.doc;
          }

          if (this.linked) {
            for (var i = 0; i < this.linked.length; ++i) {
              var link = this.linked[i];

              if (link.doc != other) {
                continue;
              }

              this.linked.splice(i, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          } // If the histories were shared, split them again


          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) {
              return splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function iterLinkedDocs(f) {
          linkedDocs(this, f);
        },
        getMode: function getMode() {
          return this.mode;
        },
        getEditor: function getEditor() {
          return this.cm;
        },
        splitLines: function splitLines(str) {
          if (this.lineSep) {
            return str.split(this.lineSep);
          }

          return splitLinesAuto(str);
        },
        lineSeparator: function lineSeparator() {
          return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function (dir) {
          if (dir != "rtl") {
            dir = "ltr";
          }

          if (dir == this.direction) {
            return;
          }

          this.direction = dir;
          this.iter(function (line) {
            return line.order = null;
          });

          if (this.cm) {
            directionChanged(this.cm);
          }
        })
      }); // Public alias.

      Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes
      // re-fire a series of drag-related events right after the drop (#1551)

      var lastDrop = 0;

      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);

        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e_preventDefault(e);

        if (ie) {
          lastDrop = +new Date();
        }

        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;

        if (!pos || cm.isReadOnly()) {
          return;
        } // Might be a file drop, in which case we simply extract the text
        // and insert it.


        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;

          var markAsReadAndPasteIfAllFilesAreRead = function markAsReadAndPasteIfAllFilesAreRead() {
            if (++read == n) {
              operation(cm, function () {
                pos = _clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text.filter(function (t) {
                    return t != null;
                  }).join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(_clipPos(cm.doc, pos), _clipPos(cm.doc, changeEnd(change))));
              })();
            }
          };

          var readTextFromFile = function readTextFromFile(file, i) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }

            var reader = new FileReader();

            reader.onerror = function () {
              return markAsReadAndPasteIfAllFilesAreRead();
            };

            reader.onload = function () {
              var content = reader.result;

              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }

              text[i] = content;
              markAsReadAndPasteIfAllFilesAreRead();
            };

            reader.readAsText(file);
          };

          for (var i = 0; i < files.length; i++) {
            readTextFromFile(files[i], i);
          }
        } else {
          // Normal drop
          // Don't do a replace if the drop happened inside of the selected text.
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e); // Ensure the editor is re-focused

            setTimeout(function () {
              return cm.display.input.focus();
            }, 20);
            return;
          }

          try {
            var text$1 = e.dataTransfer.getData("Text");

            if (text$1) {
              var selected;

              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }

              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));

              if (selected) {
                for (var i$1 = 0; i$1 < selected.length; ++i$1) {
                  _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                }
              }

              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e$1) {}
        }
      }

      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);
          return;
        }

        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove"; // Use dummy image instead of default browsers image.
        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.

        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason

            img._top = img.offsetTop;
          }

          e.dataTransfer.setDragImage(img, 0, 0);

          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }

      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);

        if (!pos) {
          return;
        }

        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);

        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }

        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }

      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      } // These must be handled carefully, because naively registering a
      // handler for each editor will cause the editors to never be
      // garbage collected.


      function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) {
          return;
        }

        var byClass = document.getElementsByClassName("CodeMirror"),
            editors = [];

        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;

          if (cm) {
            editors.push(cm);
          }
        }

        if (editors.length) {
          editors[0].operation(function () {
            for (var i = 0; i < editors.length; i++) {
              f(editors[i]);
            }
          });
        }
      }

      var globalsRegistered = false;

      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }

        registerGlobalHandlers();
        globalsRegistered = true;
      }

      function registerGlobalHandlers() {
        // When the window resizes, we need to refresh active editors.
        var resizeTimer;
        on(window, "resize", function () {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function () {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        }); // When the window loses focus, we want to show the editor as blurred

        on(window, "blur", function () {
          return forEachCodeMirror(onBlur);
        });
      } // Called when the window resizes


      function onResize(cm) {
        var d = cm.display; // Might be a text scaling operation, clear size caches.

        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }

      var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }; // Number keys

      for (var i = 0; i < 10; i++) {
        keyNames[i + 48] = keyNames[i + 96] = String(i);
      } // Alphabetic keys


      for (var i$1 = 65; i$1 <= 90; i$1++) {
        keyNames[i$1] = String.fromCharCode(i$1);
      } // Function keys


      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }

      var keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      }; // Note that the save and find-related commands aren't defined by
      // default. User code or addons can define them. Unknown commands
      // are simply ignored.

      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
      }; // Very basic readline/emacs-style bindings, which are standard on Mac.

      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH

      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;

        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];

          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }

        if (alt) {
          name = "Alt-" + name;
        }

        if (ctrl) {
          name = "Ctrl-" + name;
        }

        if (cmd) {
          name = "Cmd-" + name;
        }

        if (shift) {
          name = "Shift-" + name;
        }

        return name;
      } // This is a kludge to keep keymaps mostly working as raw objects
      // (backwards compatibility) while at the same time support features
      // like normalization and multi-stroke key bindings. It compiles a
      // new normalized keymap, and then updates the old object to reflect
      // this.


      function normalizeKeyMap(keymap) {
        var copy = {};

        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];

            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }

            if (value == "...") {
              delete keymap[keyname];
              continue;
            }

            var keys = map(keyname.split(" "), normalizeKeyName);

            for (var i = 0; i < keys.length; i++) {
              var val = void 0,
                  name = void 0;

              if (i == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i + 1).join(" ");
                val = "...";
              }

              var prev = copy[name];

              if (!prev) {
                copy[name] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name);
              }
            }

            delete keymap[keyname];
          }
        }

        for (var prop in copy) {
          keymap[prop] = copy[prop];
        }

        return keymap;
      }

      function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];

        if (found === false) {
          return "nothing";
        }

        if (found === "...") {
          return "multi";
        }

        if (found != null && handle(found)) {
          return "handled";
        }

        if (map.fallthrough) {
          if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
            return lookupKey(key, map.fallthrough, handle, context);
          }

          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle, context);

            if (result) {
              return result;
            }
          }
        }
      } // Modifier key presses don't count as 'real' key presses for the
      // purpose of keymap fallthrough.


      function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }

      function addModifierNames(name, event, noShift) {
        var base = name;

        if (event.altKey && base != "Alt") {
          name = "Alt-" + name;
        }

        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
          name = "Ctrl-" + name;
        }

        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
          name = "Cmd-" + name;
        }

        if (!noShift && event.shiftKey && base != "Shift") {
          name = "Shift-" + name;
        }

        return name;
      } // Look up the name of a key as indicated by an event object.


      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }

        var name = keyNames[event.keyCode];

        if (name == null || event.altGraphKey) {
          return false;
        } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
        // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)


        if (event.keyCode == 3 && event.code) {
          name = event.code;
        }

        return addModifierNames(name, event, noShift);
      }

      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      } // Helper for deleting text near the selection(s), used to implement
      // backspace, delete, and similar functionality.


      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges,
            kill = []; // Build up a set of ranges to kill first, merging overlapping
        // ranges.

        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);

          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();

            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }

          kill.push(toKill);
        } // Next, remove those actual ranges.


        runInOp(cm, function () {
          for (var i = kill.length - 1; i >= 0; i--) {
            _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
          }

          ensureCursorVisible(cm);
        });
      }

      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
      }

      function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
      }

      function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
          if (cm.doc.direction == "rtl") {
            dir = -dir;
          }

          var order = getOrder(lineObj, cm.doc.direction);

          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = dir < 0 == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
            // it could be that the last bidi part is not on the last visual line,
            // since visual lines contain content order-consecutive chunks.
            // Thus, in rtl, we are looking for the first (content-order) character
            // in the rtl chunk that is on the last line (that is, the same line
            // as the last (content-order) character).

            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function (ch) {
                return measureCharPrepared(cm, prep, ch).top == targetTop;
              }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);

              if (sticky == "before") {
                ch = moveCharLogically(lineObj, ch, 1);
              }
            } else {
              ch = dir < 0 ? part.to : part.from;
            }

            return new Pos(lineNo, ch, sticky);
          }
        }

        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
      }

      function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);

        if (!bidi) {
          return moveLogically(line, start, dir);
        }

        if (start.ch >= line.text.length) {
          start.ch = line.text.length;
          start.sticky = "before";
        } else if (start.ch <= 0) {
          start.ch = 0;
          start.sticky = "after";
        }

        var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
            part = bidi[partPos];

        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
          // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
          // nothing interesting happens.
          return moveLogically(line, start, dir);
        }

        var mv = function mv(pos, dir) {
          return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
        };

        var prep;

        var getWrappedLineExtent = function getWrappedLineExtent(ch) {
          if (!cm.options.lineWrapping) {
            return {
              begin: 0,
              end: line.text.length
            };
          }

          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch);
        };

        var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = part.level == 1 == dir < 0;
          var ch = mv(start, moveInStorageOrder ? 1 : -1);

          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
            // Case 2: We move within an rtl part or in an rtl editor on the same visual line
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start.line, ch, sticky);
          }
        } // Case 3: Could not move within this bidi part in this visual line, so leave
        // the current bidi part


        var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {
          var getRes = function getRes(ch, moveInStorageOrder) {
            return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
          };

          for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
            var part = bidi[partPos];
            var moveInStorageOrder = dir > 0 == (part.level != 1);
            var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);

            if (part.from <= ch && ch < part.to) {
              return getRes(ch, moveInStorageOrder);
            }

            ch = moveInStorageOrder ? part.from : mv(part.to, -1);

            if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
              return getRes(ch, moveInStorageOrder);
            }
          }
        }; // Case 3a: Look for other bidi parts on the same visual line


        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);

        if (res) {
          return res;
        } // Case 3b: Look for other bidi parts on the next visual line


        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);

        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));

          if (res) {
            return res;
          }
        } // Case 4: Nowhere to move


        return null;
      } // Commands are parameter-less actions that can be performed on an
      // editor, mostly used for keybindings.


      var commands = {
        selectAll: selectAll,
        singleSelection: function singleSelection(cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function killLine(cm) {
          return deleteNearSelection(cm, function (range) {
            if (range.empty()) {
              var len = getLine(cm.doc, range.head.line).text.length;

              if (range.head.ch == len && range.head.line < cm.lastLine()) {
                return {
                  from: range.head,
                  to: Pos(range.head.line + 1, 0)
                };
              } else {
                return {
                  from: range.head,
                  to: Pos(range.head.line, len)
                };
              }
            } else {
              return {
                from: range.from(),
                to: range.to()
              };
            }
          });
        },
        deleteLine: function deleteLine(cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function delLineLeft(cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: range.from()
            };
          });
        },
        delWrappedLineLeft: function delWrappedLineLeft(cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var leftPos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            return {
              from: leftPos,
              to: range.from()
            };
          });
        },
        delWrappedLineRight: function delWrappedLineRight(cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var rightPos = cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
            return {
              from: range.from(),
              to: rightPos
            };
          });
        },
        undo: function undo(cm) {
          return cm.undo();
        },
        redo: function redo(cm) {
          return cm.redo();
        },
        undoSelection: function undoSelection(cm) {
          return cm.undoSelection();
        },
        redoSelection: function redoSelection(cm) {
          return cm.redoSelection();
        },
        goDocStart: function goDocStart(cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function goDocEnd(cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function goLineStart(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStart(cm, range.head.line);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineStartSmart: function goLineStartSmart(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStartSmart(cm, range.head);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineEnd: function goLineEnd(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineEnd(cm, range.head.line);
          }, {
            origin: "+move",
            bias: -1
          });
        },
        goLineRight: function goLineRight(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeft: function goLineLeft(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: 0,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function goLineLeftSmart(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            var pos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");

            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range.head);
            }

            return pos;
          }, sel_move);
        },
        goLineUp: function goLineUp(cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function goLineDown(cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function goPageUp(cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function goPageDown(cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function goCharLeft(cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function goCharRight(cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function goColumnLeft(cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function goColumnRight(cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function goWordLeft(cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function goGroupRight(cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function goGroupLeft(cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function goWordRight(cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function delCharBefore(cm) {
          return cm.deleteH(-1, "codepoint");
        },
        delCharAfter: function delCharAfter(cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function delWordBefore(cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function delWordAfter(cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function delGroupBefore(cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function delGroupAfter(cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function indentAuto(cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function indentMore(cm) {
          return cm.indentSelection("add");
        },
        indentLess: function indentLess(cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function insertTab(cm) {
          return cm.replaceSelection("\t");
        },
        insertSoftTab: function insertSoftTab(cm) {
          var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize;

          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }

          cm.replaceSelections(spaces);
        },
        defaultTab: function defaultTab(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function transposeChars(cm) {
          return runInOp(cm, function () {
            var ranges = cm.listSelections(),
                newSel = [];

            for (var i = 0; i < ranges.length; i++) {
              if (!ranges[i].empty()) {
                continue;
              }

              var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text;

              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }

                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;

                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                  }
                }
              }

              newSel.push(new Range(cur, cur));
            }

            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function newlineAndIndent(cm) {
          return runInOp(cm, function () {
            var sels = cm.listSelections();

            for (var i = sels.length - 1; i >= 0; i--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
            }

            sels = cm.listSelections();

            for (var i$1 = 0; i$1 < sels.length; i$1++) {
              cm.indentLine(sels[i$1].from().line, null, true);
            }

            ensureCursorVisible(cm);
          });
        },
        openLine: function openLine(cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function toggleOverwrite(cm) {
          return cm.toggleOverwrite();
        }
      };

      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);

        if (visual != line) {
          lineN = lineNo(visual);
        }

        return endOfLine(true, cm, visual, lineN, 1);
      }

      function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);

        if (visual != line) {
          lineN = lineNo(visual);
        }

        return endOfLine(true, cm, line, lineN, -1);
      }

      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);

        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }

        return start;
      } // Run a handler that was bound to a key.


      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];

          if (!bound) {
            return false;
          }
        } // Ensure previous input has been read, so that the handler sees a
        // consistent view of the document


        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift,
            done = false;

        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }

          if (dropShift) {
            cm.display.shift = false;
          }

          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }

        return done;
      }

      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);

          if (result) {
            return result;
          }
        }

        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
      } // Note that, despite the name, this function is also used to check
      // for bound mouse clicks.


      var stopSeq = new Delayed();

      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;

        if (seq) {
          if (isModifierKey(name)) {
            return "handled";
          }

          if (/\'$/.test(name)) {
            cm.state.keySeq = null;
          } else {
            stopSeq.set(50, function () {
              if (cm.state.keySeq == seq) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            });
          }

          if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
            return true;
          }
        }

        return dispatchKeyInner(cm, name, e, handle);
      }

      function dispatchKeyInner(cm, name, e, handle) {
        var result = lookupKeyForEditor(cm, name, handle);

        if (result == "multi") {
          cm.state.keySeq = name;
        }

        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name, e);
        }

        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }

        return !!result;
      } // Handle a key from the keydown event.


      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);

        if (!name) {
          return false;
        }

        if (e.shiftKey && !cm.state.keySeq) {
          // First try to resolve full name (including 'Shift-'). Failing
          // that, see if there is a cursor-motion command (starting with
          // 'go') bound to the keyname without 'Shift-'.
          return dispatchKey(cm, "Shift-" + name, e, function (b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e, function (b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name, e, function (b) {
            return doHandleBinding(cm, b);
          });
        }
      } // Handle a key from the keypress event


      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function (b) {
          return doHandleBinding(cm, b, true);
        });
      }

      var lastStoppedKey = null;

      function onKeyDown(e) {
        var cm = this;

        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }

        cm.curOp.focus = activeElt();

        if (signalDOMEvent(cm, e)) {
          return;
        } // IE does strange things with escape.


        if (ie && ie_version < 11 && e.keyCode == 27) {
          e.returnValue = false;
        }

        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);

        if (presto) {
          lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo

          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }

        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
          document.execCommand("cut");
        } // Turn mouse into crosshair when Alt is held on Mac.


        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }

      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");

        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }

        on(document, "keyup", up);
        on(document, "mouseover", up);
      }

      function onKeyUp(e) {
        if (e.keyCode == 16) {
          this.doc.sel.shift = false;
        }

        signalDOMEvent(this, e);
      }

      function onKeyPress(e) {
        var cm = this;

        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }

        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
          return;
        }

        var keyCode = e.keyCode,
            charCode = e.charCode;

        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }

        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
          return;
        }

        var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace

        if (ch == "\x08") {
          return;
        }

        if (handleCharBinding(cm, e, ch)) {
          return;
        }

        cm.display.input.onKeyPress(e);
      }

      var DOUBLECLICK_DELAY = 400;

      var PastClick = function PastClick(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };

      PastClick.prototype.compare = function (time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
      };

      var lastClick, lastDoubleClick;

      function clickRepeat(pos, button) {
        var now = +new Date();

        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple";
        } else if (lastClick && lastClick.compare(now, pos, button)) {
          lastDoubleClick = new PastClick(now, pos, button);
          lastClick = null;
          return "double";
        } else {
          lastClick = new PastClick(now, pos, button);
          lastDoubleClick = null;
          return "single";
        }
      } // A mouse down can be a single click, double click, triple click,
      // start of selection drag, start of text drag, new cursor
      // (ctrl-click), rectangle drag (alt-drag), or xwin
      // middle-click-paste. Or it might be a click on something we should
      // not interfere with, such as a scrollbar or widget.


      function onMouseDown(e) {
        var cm = this,
            display = cm.display;

        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }

        display.input.ensurePolled();
        display.shift = e.shiftKey;

        if (eventInWidget(display, e)) {
          if (!webkit) {
            // Briefly turn off draggability, to allow widgets to do
            // normal dragging things.
            display.scroller.draggable = false;
            setTimeout(function () {
              return display.scroller.draggable = true;
            }, 100);
          }

          return;
        }

        if (clickInGutter(cm, e)) {
          return;
        }

        var pos = posFromMouse(cm, e),
            button = e_button(e),
            repeat = pos ? clickRepeat(pos, button) : "single";
        window.focus(); // #3261: make sure, that we're not starting a second selection

        if (button == 1 && cm.state.selectingText) {
          cm.state.selectingText(e);
        }

        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
          return;
        }

        if (button == 1) {
          if (pos) {
            leftButtonDown(cm, pos, repeat, e);
          } else if (e_target(e) == display.scroller) {
            e_preventDefault(e);
          }
        } else if (button == 2) {
          if (pos) {
            extendSelection(cm.doc, pos);
          }

          setTimeout(function () {
            return display.input.focus();
          }, 20);
        } else if (button == 3) {
          if (captureRightClick) {
            cm.display.input.onContextMenu(e);
          } else {
            delayBlurEvent(cm);
          }
        }
      }

      function handleMappedButton(cm, button, pos, repeat, event) {
        var name = "Click";

        if (repeat == "double") {
          name = "Double" + name;
        } else if (repeat == "triple") {
          name = "Triple" + name;
        }

        name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
        return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
          if (typeof bound == "string") {
            bound = commands[bound];
          }

          if (!bound) {
            return false;
          }

          var done = false;

          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }

            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }

          return done;
        });
      }

      function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {};

        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }

        if (value.extend == null || cm.doc.extend) {
          value.extend = cm.doc.extend || event.shiftKey;
        }

        if (value.addNew == null) {
          value.addNew = mac ? event.metaKey : event.ctrlKey;
        }

        if (value.moveOnDrag == null) {
          value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }

        return value;
      }

      function leftButtonDown(cm, pos, repeat, event) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt();
        }

        var behavior = configureMouse(cm, repeat, event);
        var sel = cm.doc.sel,
            contained;

        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
          leftButtonStartDrag(cm, event, pos, behavior);
        } else {
          leftButtonSelect(cm, event, pos, behavior);
        }
      } // Start a text drag. When it ends, see if any dragging actually
      // happen, and treat as a click if it didn't.


      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display,
            moved = false;
        var dragEnd = operation(cm, function (e) {
          if (webkit) {
            display.scroller.draggable = false;
          }

          cm.state.draggingText = false;

          if (cm.state.delayingBlurEvent) {
            if (cm.hasFocus()) {
              cm.state.delayingBlurEvent = false;
            } else {
              delayBlurEvent(cm);
            }
          }

          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);

          if (!moved) {
            e_preventDefault(e);

            if (!behavior.addNew) {
              extendSelection(cm.doc, pos, null, null, behavior.extend);
            } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)


            if (webkit && !safari || ie && ie_version == 9) {
              setTimeout(function () {
                display.wrapper.ownerDocument.body.focus({
                  preventScroll: true
                });
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });

        var mouseMove = function mouseMove(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };

        var dragStart = function dragStart() {
          return moved = true;
        }; // Let the drag handler handle this.


        if (webkit) {
          display.scroller.draggable = true;
        }

        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        cm.state.delayingBlurEvent = true;
        setTimeout(function () {
          return display.input.focus();
        }, 20); // IE's approach to draggable

        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }
      }

      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
          return new Range(pos, pos);
        }

        if (unit == "word") {
          return cm.findWordAt(pos);
        }

        if (unit == "line") {
          return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }

        var result = unit(cm, pos);
        return new Range(result.from, result.to);
      } // Normal selection, as opposed to text dragging.


      function leftButtonSelect(cm, event, start, behavior) {
        if (ie) {
          delayBlurEvent(cm);
        }

        var display = cm.display,
            doc = cm.doc;
        e_preventDefault(event);
        var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges;

        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc.sel.contains(start);

          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range(start, start);
          }
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }

        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) {
            ourRange = new Range(start, start);
          }

          start = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range = rangeForUnit(cm, start, behavior.unit);

          if (behavior.extend) {
            ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);
          } else {
            ourRange = range;
          }
        }

        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {
            scroll: false,
            origin: "*mouse"
          });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: false,
            origin: "*mouse"
          });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }

        var lastPos = start;

        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }

          lastPos = pos;

          if (behavior.unit == "rectangle") {
            var ranges = [],
                tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol);

            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize);

              if (left == right) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text.length > leftPos) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
              }
            }

            if (!ranges.length) {
              ranges.push(new Range(start, start));
            }

            setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
              origin: "*mouse",
              scroll: false
            });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor,
                head;

            if (cmp(range.anchor, anchor) > 0) {
              head = range.head;
              anchor = minPos(oldRange.from(), range.anchor);
            } else {
              head = range.anchor;
              anchor = maxPos(oldRange.to(), range.head);
            }

            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));
            setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }

        var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
        // happened in the meantime (clearTimeout isn't reliable -- at
        // least on Chrome, the timeouts still happen even when cleared,
        // if the clear happens after their scheduled firing time).

        var counter = 0;

        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");

          if (!cur) {
            return;
          }

          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);

            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function () {
                if (counter == curCount) {
                  extend(e);
                }
              }), 150);
            }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;

            if (outside) {
              setTimeout(operation(cm, function () {
                if (counter != curCount) {
                  return;
                }

                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
            }
          }
        }

        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity; // If e is null or undefined we interpret this as someone trying
          // to explicitly cancel the selection rather than the user
          // letting go of the mouse button.

          if (e) {
            e_preventDefault(e);
            display.input.focus();
          }

          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }

        var move = operation(cm, function (e) {
          if (e.buttons === 0 || !e_button(e)) {
            done(e);
          } else {
            extend(e);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      } // Used when mouse-selecting to adjust the anchor to the proper side
      // of a bidi jump depending on the visual position of the head.


      function bidiSimplify(cm, range) {
        var anchor = range.anchor;
        var head = range.head;
        var anchorLine = getLine(cm.doc, anchor.line);

        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
          return range;
        }

        var order = getOrder(anchorLine);

        if (!order) {
          return range;
        }

        var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
            part = order[index];

        if (part.from != anchor.ch && part.to != anchor.ch) {
          return range;
        }

        var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);

        if (boundary == 0 || boundary == order.length) {
          return range;
        } // Compute the relative visual position of the head compared to the
        // anchor (<0 is to the left, >0 to the right)


        var leftSide;

        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);

          if (headIndex == boundary - 1 || headIndex == boundary) {
            leftSide = dir < 0;
          } else {
            leftSide = dir > 0;
          }
        }

        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to,
            sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
      } // Determines whether an event happened in the gutter, and fires the
      // handlers for the corresponding event.


      function gutterEvent(cm, e, type, prevent) {
        var mX, mY;

        if (e.touches) {
          mX = e.touches[0].clientX;
          mY = e.touches[0].clientY;
        } else {
          try {
            mX = e.clientX;
            mY = e.clientY;
          } catch (e$1) {
            return false;
          }
        }

        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }

        if (prevent) {
          e_preventDefault(e);
        }

        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();

        if (mY > lineBox.bottom || !hasHandler(cm, type)) {
          return e_defaultPrevented(e);
        }

        mY -= lineBox.top - display.viewOffset;

        for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
          var g = display.gutters.childNodes[i];

          if (g && g.getBoundingClientRect().right >= mX) {
            var line = _lineAtHeight(cm.doc, mY);

            var gutter = cm.display.gutterSpecs[i];
            signal(cm, type, cm, line, gutter.className, e);
            return e_defaultPrevented(e);
          }
        }
      }

      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      } // CONTEXT MENU HANDLING
      // To make the context menu work, we need to briefly unhide the
      // textarea (making it as unobtrusive as possible) to let the
      // right-click take effect on it.


      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
          return;
        }

        if (signalDOMEvent(cm, e, "contextmenu")) {
          return;
        }

        if (!captureRightClick) {
          cm.display.input.onContextMenu(e);
        }
      }

      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }

        return gutterEvent(cm, e, "gutterContextMenu", false);
      }

      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }

      var Init = {
        toString: function toString() {
          return "CodeMirror.Init";
        }
      };
      var defaults = {};
      var optionHandlers = {};

      function defineOptions(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;

        function option(name, deflt, handle, notOnInit) {
          CodeMirror.defaults[name] = deflt;

          if (handle) {
            optionHandlers[name] = notOnInit ? function (cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }

        CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.

        CodeMirror.Init = Init; // These two are, on init, called from the constructor because they
        // have to be initialized before the editor can start at all.

        option("value", "", function (cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function (cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function (cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function (cm, val) {
          cm.doc.lineSep = val;

          if (!val) {
            return;
          }

          var newBreaks = [],
              lineNo = cm.doc.first;
          cm.doc.iter(function (line) {
            for (var pos = 0;;) {
              var found = line.text.indexOf(val, pos);

              if (found == -1) {
                break;
              }

              pos = found + val.length;
              newBreaks.push(Pos(lineNo, found));
            }

            lineNo++;
          });

          for (var i = newBreaks.length - 1; i >= 0; i--) {
            _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");

          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
          throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
        }, true);
        option("spellcheck", false, function (cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function (cm, val) {
          return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function (cm, val) {
          return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function (cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function (cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);

          if (prev && prev.detach) {
            prev.detach(cm, next);
          }

          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function (cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function (cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function (cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function (cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function (cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function (integer) {
          return integer;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function (cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }

          cm.display.input.readOnlyChanged(val);
        });
        option("screenReaderLabel", null, function (cm, val) {
          val = val === '' ? null : val;
          cm.display.input.screenReaderLabelChanged(val);
        });
        option("disableInput", false, function (cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function (cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function (cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 10000, resetModeState, true);
        option("moveInputWithCursor", true, function (cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function (cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function (cm, val) {
          return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
      }

      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;

        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }

      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }

        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
          return updateScrollbars(cm);
        }, 100);
      } // A CodeMirror instance represents an editor. This is the object
      // that user code is usually dealing with.


      function CodeMirror(place, options) {
        var this$1 = this;

        if (!(this instanceof CodeMirror)) {
          return new CodeMirror(place, options);
        }

        this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.

        copyObj(defaults, options, false);
        var doc = options.value;

        if (typeof doc == "string") {
          doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
          doc.modeOption = options.mode;
        }

        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);

        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }

        initScrollbars(this);
        this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        };

        if (options.autofocus && !mobile) {
          display.input.focus();
        } // Override magic textarea content restore that IE sometimes does
        // on our hidden textarea on reload


        if (ie && ie_version < 11) {
          setTimeout(function () {
            return this$1.display.input.reset(true);
          }, 20);
        }

        registerEventHandlers(this);
        ensureGlobalHandlers();

        _startOperation(this);

        this.curOp.forceUpdate = true;
        attachDoc(this, doc);

        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(function () {
            if (this$1.hasFocus() && !this$1.state.focused) {
              onFocus(this$1);
            }
          }, 20);
        } else {
          onBlur(this);
        }

        for (var opt in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt)) {
            optionHandlers[opt](this, options[opt], Init);
          }
        }

        maybeUpdateLineNumberWidth(this);

        if (options.finishInit) {
          options.finishInit(this);
        }

        for (var i = 0; i < initHooks.length; ++i) {
          initHooks[i](this);
        }

        _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
        // measuring on line wrapping boundaries.


        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      } // The default configuration options.


      CodeMirror.defaults = defaults; // Functions to run when options are changed.

      CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor

      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click

        if (ie && ie_version < 11) {
          on(d.scroller, "dblclick", operation(cm, function (e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }

            var pos = posFromMouse(cm, e);

            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
              return;
            }

            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        } else {
          on(d.scroller, "dblclick", function (e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        } // Some browsers fire contextmenu *after* opening the menu, at
        // which point we can't mess with it anymore. Context menu is
        // handled in onMouseDown for these browsers.


        on(d.scroller, "contextmenu", function (e) {
          return onContextMenu(cm, e);
        });
        on(d.input.getField(), "contextmenu", function (e) {
          if (!d.scroller.contains(e.target)) {
            onContextMenu(cm, e);
          }
        }); // Used to suppress mouse event handling when a touch happens

        var touchFinished,
            prevTouch = {
          end: 0
        };

        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function () {
              return d.activeTouch = null;
            }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date();
          }
        }

        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) {
            return false;
          }

          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }

        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }

          var dx = other.left - touch.left,
              dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }

        on(d.scroller, "touchstart", function (e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +new Date();
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };

            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function () {
          if (d.activeTouch) {
            d.activeTouch.moved = true;
          }
        });
        on(d.scroller, "touchend", function (e) {
          var touch = d.activeTouch;

          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"),
                range;

            if (!touch.prev || farAway(touch, touch.prev)) // Single tap
              {
                range = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
              {
                range = cm.findWordAt(pos);
              } else // Triple tap
              {
                range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }

            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }

          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch); // Sync scrolling between fake scrollbars and real scrollable
        // area, ensure viewport is updated when scrolling.

        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            updateScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        }); // Listen to wheel events in order to try and update the viewport on time.

        on(d.scroller, "mousewheel", function (e) {
          return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function (e) {
          return onScrollWheel(cm, e);
        }); // Prevent wrapper from ever scrolling

        on(d.wrapper, "scroll", function () {
          return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function enter(e) {
            if (!signalDOMEvent(cm, e)) {
              e_stop(e);
            }
          },
          over: function over(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function start(e) {
            return onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function leave(e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function (e) {
          return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function (e) {
          return onFocus(cm, e);
        });
        on(inp, "blur", function (e) {
          return onBlur(cm, e);
        });
      }

      var initHooks = [];

      CodeMirror.defineInitHook = function (f) {
        return initHooks.push(f);
      }; // Indent the given line. The how parameter can be "smart",
      // "add"/null, "subtract", or "prev". When aggressive is false
      // (typically set to true for forced single-line indents), empty
      // lines are not indented, and places where the mode returns Pass
      // are left alone.


      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc,
            state;

        if (how == null) {
          how = "add";
        }

        if (how == "smart") {
          // Fall back to "prev" when the mode doesn't have an indentation
          // method.
          if (!doc.mode.indent) {
            how = "prev";
          } else {
            state = getContextBefore(cm, n).state;
          }
        }

        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);

        if (line.stateAfter) {
          line.stateAfter = null;
        }

        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;

        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);

          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }

            how = "prev";
          }
        }

        if (how == "prev") {
          if (n > doc.first) {
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }

        indentation = Math.max(0, indentation);
        var indentString = "",
            pos = 0;

        if (cm.options.indentWithTabs) {
          for (var i = Math.floor(indentation / tabSize); i; --i) {
            pos += tabSize;
            indentString += "\t";
          }
        }

        if (pos < indentation) {
          indentString += spaceStr(indentation - pos);
        }

        if (indentString != curSpaceString) {
          _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");

          line.stateAfter = null;
          return true;
        } else {
          // Ensure that, if the cursor was in the whitespace at the start
          // of the line, it is moved to the end of that space.
          for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];

            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
              break;
            }
          }
        }
      } // This will be set to a {lineWise: bool, text: [string]} object, so
      // that, when pasting, we know what kind of selections the copied
      // text was made out of.


      var lastCopied = null;

      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }

      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;

        if (!sel) {
          sel = doc.sel;
        }

        var recent = +new Date() - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted),
            multiPaste = null; // When pasting N lines into N selections, insert one line per selection

        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];

              for (var i = 0; i < lastCopied.text.length; i++) {
                multiPaste.push(doc.splitLines(lastCopied.text[i]));
              }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map(textLines, function (l) {
              return [l];
            });
          }
        }

        var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection

        for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
          var range = sel.ranges[i$1];
          var from = range.from(),
              to = range.to();

          if (range.empty()) {
            if (deleted && deleted > 0) // Handle deletion
              {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) // Handle overwrite
              {
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
              from = to = Pos(from.line, 0);
            }
          }

          var changeEvent = {
            from: from,
            to: to,
            text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }

        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }

        ensureCursorVisible(cm);

        if (cm.curOp.updateInput < 2) {
          cm.curOp.updateInput = updateInput;
        }

        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }

      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");

        if (pasted) {
          e.preventDefault();

          if (!cm.isReadOnly() && !cm.options.disableInput) {
            runInOp(cm, function () {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }

          return true;
        }
      }

      function triggerElectric(cm, inserted) {
        // When an 'electric' character is inserted, immediately trigger a reindent
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }

        var sel = cm.doc.sel;

        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];

          if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
            continue;
          }

          var mode = cm.getModeAt(range.head);
          var indented = false;

          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++) {
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
              indented = indentLine(cm, range.head.line, "smart");
            }
          }

          if (indented) {
            signalLater(cm, "electricInput", cm, range.head.line);
          }
        }
      }

      function copyableRanges(cm) {
        var text = [],
            ranges = [];

        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
            anchor: Pos(line, 0),
            head: Pos(line + 1, 0)
          };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }

        return {
          text: text,
          ranges: ranges
        };
      }

      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }

      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
        // fact that it'll be scrolled into view on input from scrolling
        // our fake cursor out of view. On webkit, when wrap=off, paste is
        // very slow. So make the area wide instead.

        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        } // If border: 0; -- iOS fails to open keyboard (issue #1287)


        if (ios) {
          te.style.border = "1px solid black";
        }

        disableBrowserMagic(te);
        return div;
      } // The publicly visible API. Note that methodOp(f) means
      // 'wrap f in an operation, performed on its `this` parameter'.
      // This is not the complete set of editor methods. Most of the
      // methods defined on the Doc type are also injected into
      // CodeMirror.prototype, for backwards compatibility and
      // convenience.


      function addEditorMethods(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        var helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
          constructor: CodeMirror,
          focus: function focus() {
            window.focus();
            this.display.input.focus();
          },
          setOption: function setOption(option, value) {
            var options = this.options,
                old = options[option];

            if (options[option] == value && option != "mode") {
              return;
            }

            options[option] = value;

            if (optionHandlers.hasOwnProperty(option)) {
              operation(this, optionHandlers[option])(this, value, old);
            }

            signal(this, "optionChange", this, option);
          },
          getOption: function getOption(option) {
            return this.options[option];
          },
          getDoc: function getDoc() {
            return this.doc;
          },
          addKeyMap: function addKeyMap(map, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
          },
          removeKeyMap: function removeKeyMap(map) {
            var maps = this.state.keyMaps;

            for (var i = 0; i < maps.length; ++i) {
              if (maps[i] == map || maps[i].name == map) {
                maps.splice(i, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);

            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }

            insertSorted(this.state.overlays, {
              mode: mode,
              modeSpec: spec,
              opaque: options && options.opaque,
              priority: options && options.priority || 0
            }, function (overlay) {
              return overlay.priority;
            });
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function (spec) {
            var overlays = this.state.overlays;

            for (var i = 0; i < overlays.length; ++i) {
              var cur = overlays[i].modeSpec;

              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i, 1);
                this.state.modeGen++;
                regChange(this);
                return;
              }
            }
          }),
          indentLine: methodOp(function (n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }

            if (isLine(this.doc, n)) {
              indentLine(this, n, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function (how) {
            var ranges = this.doc.sel.ranges,
                end = -1;

            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];

              if (!range.empty()) {
                var from = range.from(),
                    to = range.to();
                var start = Math.max(end, from.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

                for (var j = start; j < end; ++j) {
                  indentLine(this, j, how);
                }

                var newRanges = this.doc.sel.ranges;

                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
                  replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                }
              } else if (range.head.line > end) {
                indentLine(this, range.head.line, how, true);
                end = range.head.line;

                if (i == this.doc.sel.primIndex) {
                  ensureCursorVisible(this);
                }
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function getTokenAt(pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function getLineTokens(line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function getTokenTypeAt(pos) {
            pos = _clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0,
                after = (styles.length - 1) / 2,
                ch = pos.ch;
            var type;

            if (ch == 0) {
              type = styles[2];
            } else {
              for (;;) {
                var mid = before + after >> 1;

                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type = styles[mid * 2 + 2];
                  break;
                }
              }
            }

            var cut = type ? type.indexOf("overlay ") : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
          },
          getModeAt: function getModeAt(pos) {
            var mode = this.doc.mode;

            if (!mode.innerMode) {
              return mode;
            }

            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function getHelper(pos, type) {
            return this.getHelpers(pos, type)[0];
          },
          getHelpers: function getHelpers(pos, type) {
            var found = [];

            if (!helpers.hasOwnProperty(type)) {
              return found;
            }

            var help = helpers[type],
                mode = this.getModeAt(pos);

            if (typeof mode[type] == "string") {
              if (help[mode[type]]) {
                found.push(help[mode[type]]);
              }
            } else if (mode[type]) {
              for (var i = 0; i < mode[type].length; i++) {
                var val = help[mode[type][i]];

                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }

            for (var i$1 = 0; i$1 < help._global.length; i$1++) {
              var cur = help._global[i$1];

              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }

            return found;
          },
          getStateAfter: function getStateAfter(line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getContextBefore(this, line + 1, precise).state;
          },
          cursorCoords: function cursorCoords(start, mode) {
            var pos,
                range = this.doc.sel.primary();

            if (start == null) {
              pos = range.head;
            } else if (typeof start == "object") {
              pos = _clipPos(this.doc, start);
            } else {
              pos = start ? range.from() : range.to();
            }

            return _cursorCoords(this, pos, mode || "page");
          },
          charCoords: function charCoords(pos, mode) {
            return _charCoords(this, _clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function coordsChar(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return _coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function lineAtHeight(height, mode) {
            height = fromCoordSystem(this, {
              top: height,
              left: 0
            }, mode || "page").top;
            return _lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function heightAtLine(line, mode, includeWidgets) {
            var end = false,
                lineObj;

            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;

              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }

              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }

            return intoCoordSystem(this, lineObj, {
              top: 0,
              left: 0
            }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function defaultTextHeight() {
            return textHeight(this.display);
          },
          defaultCharWidth: function defaultCharWidth() {
            return charWidth(this.display);
          },
          getViewport: function getViewport() {
            return {
              from: this.display.viewFrom,
              to: this.display.viewTo
            };
          },
          addWidget: function addWidget(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = _cursorCoords(this, _clipPos(this.doc, pos));
            var top = pos.bottom,
                left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);

            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                  hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

              if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }

              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }

            node.style.top = top + "px";
            node.style.left = node.style.right = "";

            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }

              node.style.left = left + "px";
            }

            if (scroll) {
              scrollIntoView(this, {
                left: left,
                top: top,
                right: left + node.offsetWidth,
                bottom: top + node.offsetHeight
              });
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),
          execCommand: function execCommand(cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function (text) {
            triggerElectric(this, text);
          }),
          findPosH: function findPosH(from, amount, unit, visually) {
            var dir = 1;

            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }

            var cur = _clipPos(this.doc, from);

            for (var i = 0; i < amount; ++i) {
              cur = _findPosH(this.doc, cur, dir, unit, visually);

              if (cur.hitSide) {
                break;
              }
            }

            return cur;
          },
          moveH: methodOp(function (dir, unit) {
            var this$1 = this;
            this.extendSelectionsBy(function (range) {
              if (this$1.display.shift || this$1.doc.extend || range.empty()) {
                return _findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range.from() : range.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel,
                doc = this.doc;

            if (sel.somethingSelected()) {
              doc.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function (range) {
                var other = _findPosH(doc, range.head, dir, unit, false);

                return dir < 0 ? {
                  from: other,
                  to: range.head
                } : {
                  from: range.head,
                  to: other
                };
              });
            }
          }),
          findPosV: function findPosV(from, amount, unit, goalColumn) {
            var dir = 1,
                x = goalColumn;

            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }

            var cur = _clipPos(this.doc, from);

            for (var i = 0; i < amount; ++i) {
              var coords = _cursorCoords(this, cur, "div");

              if (x == null) {
                x = coords.left;
              } else {
                coords.left = x;
              }

              cur = _findPosV(this, coords, dir, unit);

              if (cur.hitSide) {
                break;
              }
            }

            return cur;
          },
          moveV: methodOp(function (dir, unit) {
            var this$1 = this;
            var doc = this.doc,
                goals = [];
            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range) {
              if (collapse) {
                return dir < 0 ? range.from() : range.to();
              }

              var headPos = _cursorCoords(this$1, range.head, "div");

              if (range.goalColumn != null) {
                headPos.left = range.goalColumn;
              }

              goals.push(headPos.left);

              var pos = _findPosV(this$1, headPos, dir, unit);

              if (unit == "page" && range == doc.sel.primary()) {
                addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top);
              }

              return pos;
            }, sel_move);

            if (goals.length) {
              for (var i = 0; i < doc.sel.ranges.length; i++) {
                doc.sel.ranges[i].goalColumn = goals[i];
              }
            }
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function findWordAt(pos) {
            var doc = this.doc,
                line = getLine(doc, pos.line).text;
            var start = pos.ch,
                end = pos.ch;

            if (line) {
              var helper = this.getHelper(pos, "wordChars");

              if ((pos.sticky == "before" || end == line.length) && start) {
                --start;
              } else {
                ++end;
              }

              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper) ? function (ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function (ch) {
                return /\s/.test(ch);
              } : function (ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };

              while (start > 0 && check(line.charAt(start - 1))) {
                --start;
              }

              while (end < line.length && check(line.charAt(end))) {
                ++end;
              }
            }

            return new Range(Pos(pos.line, start), Pos(pos.line, end));
          },
          toggleOverwrite: function toggleOverwrite(value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }

            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }

            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function hasFocus() {
            return this.display.input.getField() == activeElt();
          },
          isReadOnly: function isReadOnly() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function (x, y) {
            scrollToCoords(this, x, y);
          }),
          getScrollInfo: function getScrollInfo() {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function (range, margin) {
            if (range == null) {
              range = {
                from: this.doc.sel.primary().head,
                to: null
              };

              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range == "number") {
              range = {
                from: Pos(range, 0),
                to: null
              };
            } else if (range.from == null) {
              range = {
                from: range,
                to: null
              };
            }

            if (!range.to) {
              range.to = range.from;
            }

            range.margin = margin || 0;

            if (range.from.line != null) {
              scrollToRange(this, range);
            } else {
              scrollToCoordsRange(this, range.from, range.to, range.margin);
            }
          }),
          setSize: methodOp(function (width, height) {
            var this$1 = this;

            var interpret = function interpret(val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };

            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }

            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }

            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }

            var lineNo = this.display.viewFrom;
            this.doc.iter(lineNo, this.display.viewTo, function (line) {
              if (line.widgets) {
                for (var i = 0; i < line.widgets.length; i++) {
                  if (line.widgets[i].noHScroll) {
                    regLineChange(this$1, lineNo, "widget");
                    break;
                  }
                }
              }

              ++lineNo;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function operation(f) {
            return runInOp(this, f);
          },
          startOperation: function startOperation() {
            return _startOperation(this);
          },
          endOperation: function endOperation() {
            return _endOperation(this);
          },
          refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);

            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) {
              estimateLineHeights(this);
            }

            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function (doc) {
            var old = this.doc;
            old.cm = null; // Cancel the current text selection if any (#5821)

            if (this.state.selectingText) {
              this.state.selectingText();
            }

            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          phrase: function phrase(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
          },
          getInputField: function getInputField() {
            return this.display.input.getField();
          },
          getWrapperElement: function getWrapperElement() {
            return this.display.wrapper;
          },
          getScrollerElement: function getScrollerElement() {
            return this.display.scroller;
          },
          getGutterElement: function getGutterElement() {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror);

        CodeMirror.registerHelper = function (type, name, value) {
          if (!helpers.hasOwnProperty(type)) {
            helpers[type] = CodeMirror[type] = {
              _global: []
            };
          }

          helpers[type][name] = value;
        };

        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
          CodeMirror.registerHelper(type, name, value);

          helpers[type]._global.push({
            pred: predicate,
            val: value
          });
        };
      } // Used for horizontal relative motion. Dir is -1 or 1 (left or
      // right), unit can be "codepoint", "char", "column" (like char, but
      // doesn't cross line boundaries), "word" (across next word), or
      // "group" (to the start of next group of word or
      // non-word-non-whitespace chars). The visually param controls
      // whether, in right-to-left text, direction 1 means to move towards
      // the next index in the string, or towards the character to the right
      // of the current position. The resulting position will have a
      // hitSide=true property if it reached the end of the document.


      function _findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc, pos.line);
        var lineDir = visually && doc.direction == "rtl" ? -dir : dir;

        function findNextLine() {
          var l = pos.line + lineDir;

          if (l < doc.first || l >= doc.first + doc.size) {
            return false;
          }

          pos = new Pos(l, pos.ch, pos.sticky);
          return lineObj = getLine(doc, l);
        }

        function moveOnce(boundToLine) {
          var next;

          if (unit == "codepoint") {
            var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));

            if (isNaN(ch)) {
              next = null;
            } else {
              var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
              next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
            }
          } else if (visually) {
            next = moveVisually(doc.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }

          if (next == null) {
            if (!boundToLine && findNextLine()) {
              pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
            } else {
              return false;
            }
          } else {
            pos = next;
          }

          return true;
        }

        if (unit == "char" || unit == "codepoint") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }

            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";

            if (group && !first && !type) {
              type = "s";
            }

            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
                pos.sticky = "after";
              }

              break;
            }

            if (type) {
              sawType = type;
            }

            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }

        var result = skipAtomic(doc, pos, oldPos, origDir, true);

        if (equalCursorPos(oldPos, result)) {
          result.hitSide = true;
        }

        return result;
      } // For relative vertical movement. Dir may be -1 or 1. Unit can be
      // "page" or "line". The resulting position will have a hitSide=true
      // property if it reached the end of the document.


      function _findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;

        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }

        var target;

        for (;;) {
          target = _coordsChar(cm, x, y);

          if (!target.outside) {
            break;
          }

          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }

          y += dir * 5;
        }

        return target;
      } // CONTENTEDITABLE INPUT STYLE


      var ContentEditableInput = function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };

      ContentEditableInput.prototype.init = function (display) {
        var this$1 = this;
        var input = this,
            cm = input.cm;
        var div = input.div = display.lineDiv;
        div.contentEditable = true;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

        function belongsToInput(e) {
          for (var t = e.target; t; t = t.parentNode) {
            if (t == div) {
              return true;
            }

            if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
              break;
            }
          }

          return false;
        }

        on(div, "paste", function (e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          } // IE doesn't fire input events, so we schedule a read for the pasted content in this way


          if (ie_version <= 11) {
            setTimeout(operation(cm, function () {
              return this$1.updateFromDOM();
            }), 20);
          }
        });
        on(div, "compositionstart", function (e) {
          this$1.composing = {
            data: e.data,
            done: false
          };
        });
        on(div, "compositionupdate", function (e) {
          if (!this$1.composing) {
            this$1.composing = {
              data: e.data,
              done: false
            };
          }
        });
        on(div, "compositionend", function (e) {
          if (this$1.composing) {
            if (e.data != this$1.composing.data) {
              this$1.readFromDOMSoon();
            }

            this$1.composing.done = true;
          }
        });
        on(div, "touchstart", function () {
          return input.forceCompositionEnd();
        });
        on(div, "input", function () {
          if (!this$1.composing) {
            this$1.readFromDOMSoon();
          }
        });

        function onCopyCut(e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
            return;
          }

          if (cm.somethingSelected()) {
            setLastCopied({
              lineWise: false,
              text: cm.getSelections()
            });

            if (e.type == "cut") {
              cm.replaceSelection("", null, "cut");
            }
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({
              lineWise: true,
              text: ranges.text
            });

            if (e.type == "cut") {
              cm.operation(function () {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }

          if (e.clipboardData) {
            e.clipboardData.clearData();
            var content = lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it

            e.clipboardData.setData("Text", content);

            if (e.clipboardData.getData("Text") == content) {
              e.preventDefault();
              return;
            }
          } // Old-fashioned briefly-focus-a-textarea hack


          var kludge = hiddenTextarea(),
              te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = activeElt();
          selectInput(te);
          setTimeout(function () {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();

            if (hadFocus == div) {
              input.showPrimarySelection();
            }
          }, 50);
        }

        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };

      ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
        // Label for screenreaders, accessibility
        if (label) {
          this.div.setAttribute('aria-label', label);
        } else {
          this.div.removeAttribute('aria-label');
        }
      };

      ContentEditableInput.prototype.prepareSelection = function () {
        var result = prepareSelection(this.cm, false);
        result.focus = activeElt() == this.div;
        return result;
      };

      ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
          return;
        }

        if (info.focus || takeFocus) {
          this.showPrimarySelection();
        }

        this.showMultipleSelections(info);
      };

      ContentEditableInput.prototype.getSelection = function () {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      };

      ContentEditableInput.prototype.showPrimarySelection = function () {
        var sel = this.getSelection(),
            cm = this.cm,
            prim = cm.doc.sel.primary();
        var from = prim.from(),
            to = prim.to();

        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return;
        }

        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);

        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
          return;
        }

        var view = cm.display.view;
        var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
          node: view[0].measure.map[2],
          offset: 0
        };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);

        if (!end) {
          var measure = view[view.length - 1].measure;
          var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = {
            node: map[map.length - 1],
            offset: map[map.length - 2] - map[map.length - 3]
          };
        }

        if (!start || !end) {
          sel.removeAllRanges();
          return;
        }

        var old = sel.rangeCount && sel.getRangeAt(0),
            rng;

        try {
          rng = range(start.node, start.offset, end.offset, end.node);
        } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start.node, start.offset);

            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }

          if (old && sel.anchorNode == null) {
            sel.addRange(old);
          } else if (gecko) {
            this.startGracePeriod();
          }
        }

        this.rememberSelection();
      };

      ContentEditableInput.prototype.startGracePeriod = function () {
        var this$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function () {
          this$1.gracePeriod = false;

          if (this$1.selectionChanged()) {
            this$1.cm.operation(function () {
              return this$1.cm.curOp.selectionChanged = true;
            });
          }
        }, 20);
      };

      ContentEditableInput.prototype.showMultipleSelections = function (info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };

      ContentEditableInput.prototype.rememberSelection = function () {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
      };

      ContentEditableInput.prototype.selectionInEditor = function () {
        var sel = this.getSelection();

        if (!sel.rangeCount) {
          return false;
        }

        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
      };

      ContentEditableInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor() || activeElt() != this.div) {
            this.showSelection(this.prepareSelection(), true);
          }

          this.div.focus();
        }
      };

      ContentEditableInput.prototype.blur = function () {
        this.div.blur();
      };

      ContentEditableInput.prototype.getField = function () {
        return this.div;
      };

      ContentEditableInput.prototype.supportsTouch = function () {
        return true;
      };

      ContentEditableInput.prototype.receivedFocus = function () {
        var this$1 = this;
        var input = this;

        if (this.selectionInEditor()) {
          setTimeout(function () {
            return this$1.pollSelection();
          }, 20);
        } else {
          runInOp(this.cm, function () {
            return input.cm.curOp.selectionChanged = true;
          });
        }

        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }

        this.polling.set(this.cm.options.pollInterval, poll);
      };

      ContentEditableInput.prototype.selectionChanged = function () {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
      };

      ContentEditableInput.prototype.pollSelection = function () {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
          return;
        }

        var sel = this.getSelection(),
            cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
        // uneditable block element will put the cursor in that element,
        // and then, because it's not editable, hide the virtual keyboard.
        // Because Android doesn't allow us to actually detect backspace
        // presses in a sane way, this code checks for when that happens
        // and simulates a backspace press in this case.

        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({
            type: "keydown",
            keyCode: 8,
            preventDefault: Math.abs
          });
          this.blur();
          this.focus();
          return;
        }

        if (this.composing) {
          return;
        }

        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);

        if (anchor && head) {
          runInOp(cm, function () {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);

            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      };

      ContentEditableInput.prototype.pollContent = function () {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }

        var cm = this.cm,
            display = cm.display,
            sel = cm.doc.sel.primary();
        var from = sel.from(),
            to = sel.to();

        if (from.ch == 0 && from.line > cm.firstLine()) {
          from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
        }

        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
          to = Pos(to.line + 1, 0);
        }

        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
          return false;
        }

        var fromIndex, fromLine, fromNode;

        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }

        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;

        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }

        if (!fromNode) {
          return false;
        }

        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));

        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) {
            newText.pop();
            oldText.pop();
            toLine--;
          } else if (newText[0] == oldText[0]) {
            newText.shift();
            oldText.shift();
            fromLine++;
          } else {
            break;
          }
        }

        var cutFront = 0,
            cutEnd = 0;
        var newTop = newText[0],
            oldTop = oldText[0],
            maxCutFront = Math.min(newTop.length, oldTop.length);

        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
          ++cutFront;
        }

        var newBot = lst(newText),
            oldBot = lst(oldText);
        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

        while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          ++cutEnd;
        } // Try to move start of change to start of selection if ambiguous


        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
          while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }

        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);

        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          _replaceRange(cm.doc, newText, chFrom, chTo, "+input");

          return true;
        }
      };

      ContentEditableInput.prototype.ensurePolled = function () {
        this.forceCompositionEnd();
      };

      ContentEditableInput.prototype.reset = function () {
        this.forceCompositionEnd();
      };

      ContentEditableInput.prototype.forceCompositionEnd = function () {
        if (!this.composing) {
          return;
        }

        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };

      ContentEditableInput.prototype.readFromDOMSoon = function () {
        var this$1 = this;

        if (this.readDOMTimeout != null) {
          return;
        }

        this.readDOMTimeout = setTimeout(function () {
          this$1.readDOMTimeout = null;

          if (this$1.composing) {
            if (this$1.composing.done) {
              this$1.composing = null;
            } else {
              return;
            }
          }

          this$1.updateFromDOM();
        }, 80);
      };

      ContentEditableInput.prototype.updateFromDOM = function () {
        var this$1 = this;

        if (this.cm.isReadOnly() || !this.pollContent()) {
          runInOp(this.cm, function () {
            return regChange(this$1.cm);
          });
        }
      };

      ContentEditableInput.prototype.setUneditable = function (node) {
        node.contentEditable = "false";
      };

      ContentEditableInput.prototype.onKeyPress = function (e) {
        if (e.charCode == 0 || this.composing) {
          return;
        }

        e.preventDefault();

        if (!this.cm.isReadOnly()) {
          operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
      };

      ContentEditableInput.prototype.readOnlyChanged = function (val) {
        this.div.contentEditable = String(val != "nocursor");
      };

      ContentEditableInput.prototype.onContextMenu = function () {};

      ContentEditableInput.prototype.resetPosition = function () {};

      ContentEditableInput.prototype.needsContentAttribute = true;

      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);

        if (!view || view.hidden) {
          return null;
        }

        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction),
            side = "left";

        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }

        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }

      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode) {
          if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
            return true;
          }
        }

        return false;
      }

      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }

        return pos;
      }

      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "",
            closing = false,
            lineSep = cm.doc.lineSeparator(),
            extraLinebreak = false;

        function recognizeMarker(id) {
          return function (marker) {
            return marker.id == id;
          };
        }

        function close() {
          if (closing) {
            text += lineSep;

            if (extraLinebreak) {
              text += lineSep;
            }

            closing = extraLinebreak = false;
          }
        }

        function addText(str) {
          if (str) {
            close();
            text += str;
          }
        }

        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");

            if (cmText) {
              addText(cmText);
              return;
            }

            var markerID = node.getAttribute("cm-marker"),
                range;

            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));

              if (found.length && (range = found[0].find(0))) {
                addText(getBetween(cm.doc, range.from, range.to).join(lineSep));
              }

              return;
            }

            if (node.getAttribute("contenteditable") == "false") {
              return;
            }

            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);

            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
              return;
            }

            if (isBlock) {
              close();
            }

            for (var i = 0; i < node.childNodes.length; i++) {
              walk(node.childNodes[i]);
            }

            if (/^(pre|p)$/i.test(node.nodeName)) {
              extraLinebreak = true;
            }

            if (isBlock) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }

        for (;;) {
          walk(from);

          if (from == to) {
            break;
          }

          from = from.nextSibling;
          extraLinebreak = false;
        }

        return text;
      }

      function domToPos(cm, node, offset) {
        var lineNode;

        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];

          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }

          node = null;
          offset = 0;
        } else {
          for (lineNode = node;; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }

            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }

        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];

          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }

      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild,
            bad = false;

        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }

        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;

          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }

        var textNode = node.nodeType == 3 ? node : null,
            topNode = node;

        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;

          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }

        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }

        var measure = lineView.measure,
            maps = measure.maps;

        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map = i < 0 ? measure.map : maps[i];

            for (var j = 0; j < map.length; j += 3) {
              var curNode = map[j + 2];

              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map[j] + offset;

                if (offset < 0 || curNode != textNode) {
                  ch = map[j + (offset ? 1 : 0)];
                }

                return Pos(line, ch);
              }
            }
          }
        }

        var found = find(textNode, topNode, offset);

        if (found) {
          return badPos(found, bad);
        } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems


        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);

          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }

        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);

          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      } // TEXTAREA INPUT STYLE


      var TextareaInput = function TextareaInput(cm) {
        this.cm = cm; // See input.poll and input.reset

        this.prevInput = ""; // Flag that indicates whether we expect input to appear real soon
        // now (after some event like 'keypress' or 'input') and are
        // polling intensively.

        this.pollingFast = false; // Self-resetting timeout for the poller

        this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea

        this.hasSelection = false;
        this.composing = null;
      };

      TextareaInput.prototype.init = function (display) {
        var this$1 = this;
        var input = this,
            cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)

        if (ios) {
          te.style.width = "0px";
        }

        on(te, "input", function () {
          if (ie && ie_version >= 9 && this$1.hasSelection) {
            this$1.hasSelection = null;
          }

          input.poll();
        });
        on(te, "paste", function (e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }

          cm.state.pasteIncoming = +new Date();
          input.fastPoll();
        });

        function prepareCopyCut(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }

          if (cm.somethingSelected()) {
            setLastCopied({
              lineWise: false,
              text: cm.getSelections()
            });
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({
              lineWise: true,
              text: ranges.text
            });

            if (e.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }

          if (e.type == "cut") {
            cm.state.cutIncoming = +new Date();
          }
        }

        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function (e) {
          if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
            return;
          }

          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +new Date();
            input.focus();
            return;
          } // Pass the `paste` event to the textarea so it's handled by its event listener.


          var event = new Event("paste");
          event.clipboardData = e.clipboardData;
          te.dispatchEvent(event);
        }); // Prevent normal selection in the editor (we handle our own)

        on(display.lineSpace, "selectstart", function (e) {
          if (!eventInWidget(display, e)) {
            e_preventDefault(e);
          }
        });
        on(te, "compositionstart", function () {
          var start = cm.getCursor("from");

          if (input.composing) {
            input.composing.range.clear();
          }

          input.composing = {
            start: start,
            range: cm.markText(start, cm.getCursor("to"), {
              className: "CodeMirror-composing"
            })
          };
        });
        on(te, "compositionend", function () {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };

      TextareaInput.prototype.createField = function (_display) {
        // Wraps and hides input textarea
        this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is
        // focused, and receives input.

        this.textarea = this.wrapper.firstChild;
      };

      TextareaInput.prototype.screenReaderLabelChanged = function (label) {
        // Label for screenreaders, accessibility
        if (label) {
          this.textarea.setAttribute('aria-label', label);
        } else {
          this.textarea.removeAttribute('aria-label');
        }
      };

      TextareaInput.prototype.prepareSelection = function () {
        // Redraw the selection and/or cursor
        var cm = this.cm,
            display = cm.display,
            doc = cm.doc;
        var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts

        if (cm.options.moveInputWithCursor) {
          var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");

          var wrapOff = display.wrapper.getBoundingClientRect(),
              lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
          result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }

        return result;
      };

      TextareaInput.prototype.showSelection = function (drawn) {
        var cm = this.cm,
            display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);

        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      }; // Reset the input to correspond to the selection (or to be empty,
      // when not typing and nothing is selected)


      TextareaInput.prototype.reset = function (typing) {
        if (this.contextMenuPending || this.composing) {
          return;
        }

        var cm = this.cm;

        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;

          if (cm.state.focused) {
            selectInput(this.textarea);
          }

          if (ie && ie_version >= 9) {
            this.hasSelection = content;
          }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";

          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
        }
      };

      TextareaInput.prototype.getField = function () {
        return this.textarea;
      };

      TextareaInput.prototype.supportsTouch = function () {
        return false;
      };

      TextareaInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
          try {
            this.textarea.focus();
          } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM

        }
      };

      TextareaInput.prototype.blur = function () {
        this.textarea.blur();
      };

      TextareaInput.prototype.resetPosition = function () {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };

      TextareaInput.prototype.receivedFocus = function () {
        this.slowPoll();
      }; // Poll for input changes, using the normal rate of polling. This
      // runs as long as the editor is focused.


      TextareaInput.prototype.slowPoll = function () {
        var this$1 = this;

        if (this.pollingFast) {
          return;
        }

        this.polling.set(this.cm.options.pollInterval, function () {
          this$1.poll();

          if (this$1.cm.state.focused) {
            this$1.slowPoll();
          }
        });
      }; // When an event has just come in that is likely to add or change
      // something in the input textarea, we poll faster, to ensure that
      // the change appears on the screen quickly.


      TextareaInput.prototype.fastPoll = function () {
        var missed = false,
            input = this;
        input.pollingFast = true;

        function p() {
          var changed = input.poll();

          if (!changed && !missed) {
            missed = true;
            input.polling.set(60, p);
          } else {
            input.pollingFast = false;
            input.slowPoll();
          }
        }

        input.polling.set(20, p);
      }; // Read input from the textarea, and update the document to match.
      // When something is selected, it is present in the textarea, and
      // selected (unless it is huge, in which case a placeholder is
      // used). When nothing is selected, the cursor sits after previously
      // seen text (can be empty), which is stored in prevInput (we must
      // not reset the textarea when typing, because that breaks IME).


      TextareaInput.prototype.poll = function () {
        var this$1 = this;
        var cm = this.cm,
            input = this.textarea,
            prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
        // possible when it is clear that nothing happened. hasSelection
        // will be the case when there is a lot of text in the textarea,
        // in which case reading its value would be expensive.

        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
          return false;
        }

        var text = input.value; // If nothing changed, bail.

        if (text == prevInput && !cm.somethingSelected()) {
          return false;
        } // Work around nonsensical selection resetting in IE9/10, and
        // inexplicable appearance of private area unicode characters on
        // some key combos in Mac (#2689).


        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
          cm.display.input.reset();
          return false;
        }

        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text.charCodeAt(0);

          if (first == 0x200b && !prevInput) {
            prevInput = "\u200b";
          }

          if (first == 0x21da) {
            this.reset();
            return this.cm.execCommand("undo");
          }
        } // Find the part of the input that is actually new


        var same = 0,
            l = Math.min(prevInput.length, text.length);

        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
          ++same;
        }

        runInOp(cm, function () {
          applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null); // Don't leave long text in the textarea, since it makes further polling slow

          if (text.length > 1000 || text.indexOf("\n") > -1) {
            input.value = this$1.prevInput = "";
          } else {
            this$1.prevInput = text;
          }

          if (this$1.composing) {
            this$1.composing.range.clear();
            this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
              className: "CodeMirror-composing"
            });
          }
        });
        return true;
      };

      TextareaInput.prototype.ensurePolled = function () {
        if (this.pollingFast && this.poll()) {
          this.pollingFast = false;
        }
      };

      TextareaInput.prototype.onKeyPress = function () {
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }

        this.fastPoll();
      };

      TextareaInput.prototype.onContextMenu = function (e) {
        var input = this,
            cm = input.cm,
            display = cm.display,
            te = input.textarea;

        if (input.contextMenuPending) {
          input.contextMenuPending();
        }

        var pos = posFromMouse(cm, e),
            scrollPos = display.scroller.scrollTop;

        if (!pos || presto) {
          return;
        } // Opera is difficult.
        // Reset the current text selection only if the click is done outside of the selection
        // and 'resetSelectionOnContextMenu' option is true.


        var reset = cm.options.resetSelectionOnContextMenu;

        if (reset && cm.doc.sel.contains(pos) == -1) {
          operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }

        var oldCSS = te.style.cssText,
            oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;

        if (webkit) {
          oldScrollY = window.scrollY;
        } // Work around Chrome issue (#2712)


        display.input.focus();

        if (webkit) {
          window.scrollTo(null, oldScrollY);
        }

        display.input.reset(); // Adds "Select all" to context menu in FF

        if (!cm.somethingSelected()) {
          te.value = input.prevInput = " ";
        }

        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
        // this adds a zero-width space so that we can later check whether
        // it got selected.

        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "\u200b" + (selected ? te.value : "");
            te.value = "\u21da"; // Used to catch context-menu undo

            te.value = extval;
            input.prevInput = selected ? "" : "\u200b";
            te.selectionStart = 1;
            te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the
            // selection in the meantime.

            display.selForContextMenu = cm.doc.sel;
          }
        }

        function rehide() {
          if (input.contextMenuPending != rehide) {
            return;
          }

          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;

          if (ie && ie_version < 9) {
            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
          } // Try to detect the user choosing select-all


          if (te.selectionStart != null) {
            if (!ie || ie && ie_version < 9) {
              prepareSelectAllHack();
            }

            var i = 0,
                poll = function poll() {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
                operation(cm, selectAll)(cm);
              } else if (i++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };

            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }

        if (ie && ie_version >= 9) {
          prepareSelectAllHack();
        }

        if (captureRightClick) {
          e_stop(e);

          var mouseup = function mouseup() {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };

          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };

      TextareaInput.prototype.readOnlyChanged = function (val) {
        if (!val) {
          this.reset();
        }

        this.textarea.disabled = val == "nocursor";
        this.textarea.readOnly = !!val;
      };

      TextareaInput.prototype.setUneditable = function () {};

      TextareaInput.prototype.needsContentAttribute = false;

      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;

        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }

        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        } // Set autofocus to true if this textarea is focused, or if it has
        // autofocus and no other element is focused.


        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }

        function save() {
          textarea.value = cm.getValue();
        }

        var realSubmit;

        if (textarea.form) {
          on(textarea.form, "submit", save); // Deplorable hack to make the submit method do the right thing.

          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;

            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }

        options.finishInit = function (cm) {
          cm.save = save;

          cm.getTextArea = function () {
            return textarea;
          };

          cm.toTextArea = function () {
            cm.toTextArea = isNaN; // Prevent this from being ran twice

            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";

            if (textarea.form) {
              off(textarea.form, "submit", save);

              if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };

        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
          return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      }

      function addLegacyProps(CodeMirror) {
        CodeMirror.off = off;
        CodeMirror.on = on;
        CodeMirror.wheelEventPixels = wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = splitLinesAuto;
        CodeMirror.countColumn = countColumn;
        CodeMirror.findColumn = findColumn;
        CodeMirror.isWordChar = isWordCharBasic;
        CodeMirror.Pass = Pass;
        CodeMirror.signal = signal;
        CodeMirror.Line = Line;
        CodeMirror.changeEnd = changeEnd;
        CodeMirror.scrollbarModel = scrollbarModel;
        CodeMirror.Pos = Pos;
        CodeMirror.cmpPos = cmp;
        CodeMirror.modes = modes;
        CodeMirror.mimeModes = mimeModes;
        CodeMirror.resolveMode = resolveMode;
        CodeMirror.getMode = getMode;
        CodeMirror.modeExtensions = modeExtensions;
        CodeMirror.extendMode = extendMode;
        CodeMirror.copyState = copyState;
        CodeMirror.startState = startState;
        CodeMirror.innerMode = innerMode;
        CodeMirror.commands = commands;
        CodeMirror.keyMap = keyMap;
        CodeMirror.keyName = keyName;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.normalizeKeyMap = normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = SharedTextMarker;
        CodeMirror.TextMarker = TextMarker;
        CodeMirror.LineWidget = LineWidget;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        CodeMirror.e_stop = e_stop;
        CodeMirror.addClass = addClass;
        CodeMirror.contains = contains;
        CodeMirror.rmClass = rmClass;
        CodeMirror.keyNames = keyNames;
      } // EDITOR CONSTRUCTOR


      defineOptions(CodeMirror);
      addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.

      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");

      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror.prototype[prop] = function (method) {
            return function () {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }

      eventMixin(Doc);
      CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
      }; // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)

      CodeMirror.defineMode = function (name
      /*, mode, …*/
      ) {
        if (!CodeMirror.defaults.mode && name != "null") {
          CodeMirror.defaults.mode = name;
        }

        defineMode.apply(this, arguments);
      };

      CodeMirror.defineMIME = defineMIME; // Minimal default mode.

      CodeMirror.defineMode("null", function () {
        return {
          token: function token(stream) {
            return stream.skipToEnd();
          }
        };
      });
      CodeMirror.defineMIME("text/plain", "null"); // EXTENSIONS

      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };

      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };

      CodeMirror.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror);
      CodeMirror.version = "5.63.3";
      return CodeMirror;
    });
  });

  var javascript = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {

      CodeMirror.defineMode("javascript", function (config, parserConfig) {
        var indentUnit = config.indentUnit;
        var statementIndent = parserConfig.statementIndent;
        var jsonldMode = parserConfig.jsonld;
        var jsonMode = parserConfig.json || jsonldMode;
        var trackScope = parserConfig.trackScope !== false;
        var isTS = parserConfig.typescript;
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/; // Tokenizer

        var keywords = function () {
          function kw(type) {
            return {
              type: type,
              style: "keyword"
            };
          }

          var A = kw("keyword a"),
              B = kw("keyword b"),
              C = kw("keyword c"),
              D = kw("keyword d");
          var operator = kw("operator"),
              atom = {
            type: "atom",
            style: "atom"
          };
          return {
            "if": kw("if"),
            "while": A,
            "with": A,
            "else": B,
            "do": B,
            "try": B,
            "finally": B,
            "return": D,
            "break": D,
            "continue": D,
            "new": kw("new"),
            "delete": C,
            "void": C,
            "throw": C,
            "debugger": kw("debugger"),
            "var": kw("var"),
            "const": kw("var"),
            "let": kw("var"),
            "function": kw("function"),
            "catch": kw("catch"),
            "for": kw("for"),
            "switch": kw("switch"),
            "case": kw("case"),
            "default": kw("default"),
            "in": operator,
            "typeof": operator,
            "instanceof": operator,
            "true": atom,
            "false": atom,
            "null": atom,
            "undefined": atom,
            "NaN": atom,
            "Infinity": atom,
            "this": kw("this"),
            "class": kw("class"),
            "super": kw("atom"),
            "yield": C,
            "export": kw("export"),
            "import": kw("import"),
            "extends": C,
            "await": C
          };
        }();

        var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

        function readRegexp(stream) {
          var escaped = false,
              next,
              inSet = false;

          while ((next = stream.next()) != null) {
            if (!escaped) {
              if (next == "/" && !inSet) return;
              if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
            }

            escaped = !escaped && next == "\\";
          }
        } // Used as scratch variables to communicate multiple values without
        // consing up tons of objects.


        var type, content;

        function ret(tp, style, cont) {
          type = tp;
          content = cont;
          return style;
        }

        function tokenBase(stream, state) {
          var ch = stream.next();

          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
            return ret("number", "number");
          } else if (ch == "." && stream.match("..")) {
            return ret("spread", "meta");
          } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            return ret(ch);
          } else if (ch == "=" && stream.eat(">")) {
            return ret("=>", "operator");
          } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
            return ret("number", "number");
          } else if (/\d/.test(ch)) {
            stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
            return ret("number", "number");
          } else if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return tokenComment(stream, state);
            } else if (stream.eat("/")) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (expressionAllowed(stream, state, 1)) {
              readRegexp(stream);
              stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
              return ret("regexp", "string-2");
            } else {
              stream.eat("=");
              return ret("operator", "operator", stream.current());
            }
          } else if (ch == "`") {
            state.tokenize = tokenQuasi;
            return tokenQuasi(stream, state);
          } else if (ch == "#" && stream.peek() == "!") {
            stream.skipToEnd();
            return ret("meta", "meta");
          } else if (ch == "#" && stream.eatWhile(wordRE)) {
            return ret("variable", "property");
          } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (isOperatorChar.test(ch)) {
            if (ch != ">" || !state.lexical || state.lexical.type != ">") {
              if (stream.eat("=")) {
                if (ch == "!" || ch == "=") stream.eat("=");
              } else if (/[<>*+\-|&?]/.test(ch)) {
                stream.eat(ch);
                if (ch == ">") stream.eat(ch);
              }
            }

            if (ch == "?" && stream.eat(".")) return ret(".");
            return ret("operator", "operator", stream.current());
          } else if (wordRE.test(ch)) {
            stream.eatWhile(wordRE);
            var word = stream.current();

            if (state.lastType != ".") {
              if (keywords.propertyIsEnumerable(word)) {
                var kw = keywords[word];
                return ret(kw.type, kw.style, word);
              }

              if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false)) return ret("async", "keyword", word);
            }

            return ret("variable", "variable", word);
          }
        }

        function tokenString(quote) {
          return function (stream, state) {
            var escaped = false,
                next;

            if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
              state.tokenize = tokenBase;
              return ret("jsonld-keyword", "meta");
            }

            while ((next = stream.next()) != null) {
              if (next == quote && !escaped) break;
              escaped = !escaped && next == "\\";
            }

            if (!escaped) state.tokenize = tokenBase;
            return ret("string", "string");
          };
        }

        function tokenComment(stream, state) {
          var maybeEnd = false,
              ch;

          while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }

            maybeEnd = ch == "*";
          }

          return ret("comment", "comment");
        }

        function tokenQuasi(stream, state) {
          var escaped = false,
              next;

          while ((next = stream.next()) != null) {
            if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
              state.tokenize = tokenBase;
              break;
            }

            escaped = !escaped && next == "\\";
          }

          return ret("quasi", "string-2", stream.current());
        }

        var brackets = "([{}])"; // This is a crude lookahead trick to try and notice that we're
        // parsing the argument patterns for a fat-arrow function before we
        // actually hit the arrow token. It only works if the arrow is on
        // the same line as the arguments and there's no strange noise
        // (comments) in between. Fallback is to only notice when we hit the
        // arrow, and not declare the arguments as locals for the arrow
        // body.

        function findFatArrow(stream, state) {
          if (state.fatArrowAt) state.fatArrowAt = null;
          var arrow = stream.string.indexOf("=>", stream.start);
          if (arrow < 0) return;

          if (isTS) {
            // Try to skip TypeScript return type declarations after the arguments
            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
            if (m) arrow = m.index;
          }

          var depth = 0,
              sawSomething = false;

          for (var pos = arrow - 1; pos >= 0; --pos) {
            var ch = stream.string.charAt(pos);
            var bracket = brackets.indexOf(ch);

            if (bracket >= 0 && bracket < 3) {
              if (!depth) {
                ++pos;
                break;
              }

              if (--depth == 0) {
                if (ch == "(") sawSomething = true;
                break;
              }
            } else if (bracket >= 3 && bracket < 6) {
              ++depth;
            } else if (wordRE.test(ch)) {
              sawSomething = true;
            } else if (/["'\/`]/.test(ch)) {
              for (;; --pos) {
                if (pos == 0) return;
                var next = stream.string.charAt(pos - 1);

                if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                  pos--;
                  break;
                }
              }
            } else if (sawSomething && !depth) {
              ++pos;
              break;
            }
          }

          if (sawSomething && !depth) state.fatArrowAt = pos;
        } // Parser


        var atomicTypes = {
          "atom": true,
          "number": true,
          "variable": true,
          "string": true,
          "regexp": true,
          "this": true,
          "import": true,
          "jsonld-keyword": true
        };

        function JSLexical(indented, column, type, align, prev, info) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.prev = prev;
          this.info = info;
          if (align != null) this.align = align;
        }

        function inScope(state, varname) {
          if (!trackScope) return false;

          for (var v = state.localVars; v; v = v.next) {
            if (v.name == varname) return true;
          }

          for (var cx = state.context; cx; cx = cx.prev) {
            for (var v = cx.vars; v; v = v.next) {
              if (v.name == varname) return true;
            }
          }
        }

        function parseJS(state, style, type, content, stream) {
          var cc = state.cc; // Communicate our context to the combinators.
          // (Less wasteful than consing up a hundred closures on every call.)

          cx.state = state;
          cx.stream = stream;
          cx.marked = null, cx.cc = cc;
          cx.style = style;
          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

          while (true) {
            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;

            if (combinator(type, content)) {
              while (cc.length && cc[cc.length - 1].lex) {
                cc.pop()();
              }

              if (cx.marked) return cx.marked;
              if (type == "variable" && inScope(state, content)) return "variable-2";
              return style;
            }
          }
        } // Combinator utils


        var cx = {
          state: null,
          column: null,
          marked: null,
          cc: null
        };

        function pass() {
          for (var i = arguments.length - 1; i >= 0; i--) {
            cx.cc.push(arguments[i]);
          }
        }

        function cont() {
          pass.apply(null, arguments);
          return true;
        }

        function inList(name, list) {
          for (var v = list; v; v = v.next) {
            if (v.name == name) return true;
          }

          return false;
        }

        function register(varname) {
          var state = cx.state;
          cx.marked = "def";
          if (!trackScope) return;

          if (state.context) {
            if (state.lexical.info == "var" && state.context && state.context.block) {
              // FIXME function decls are also not block scoped
              var newContext = registerVarScoped(varname, state.context);

              if (newContext != null) {
                state.context = newContext;
                return;
              }
            } else if (!inList(varname, state.localVars)) {
              state.localVars = new Var(varname, state.localVars);
              return;
            }
          } // Fall through means this is global


          if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);
        }

        function registerVarScoped(varname, context) {
          if (!context) {
            return null;
          } else if (context.block) {
            var inner = registerVarScoped(varname, context.prev);
            if (!inner) return null;
            if (inner == context.prev) return context;
            return new Context(inner, context.vars, true);
          } else if (inList(varname, context.vars)) {
            return context;
          } else {
            return new Context(context.prev, new Var(varname, context.vars), false);
          }
        }

        function isModifier(name) {
          return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
        } // Combinators


        function Context(prev, vars, block) {
          this.prev = prev;
          this.vars = vars;
          this.block = block;
        }

        function Var(name, next) {
          this.name = name;
          this.next = next;
        }

        var defaultVars = new Var("this", new Var("arguments", null));

        function pushcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
          cx.state.localVars = defaultVars;
        }

        function pushblockcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
          cx.state.localVars = null;
        }

        function popcontext() {
          cx.state.localVars = cx.state.context.vars;
          cx.state.context = cx.state.context.prev;
        }

        popcontext.lex = true;

        function pushlex(type, info) {
          var result = function result() {
            var state = cx.state,
                indent = state.indented;
            if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) {
              indent = outer.indented;
            }
            state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
          };

          result.lex = true;
          return result;
        }

        function poplex() {
          var state = cx.state;

          if (state.lexical.prev) {
            if (state.lexical.type == ")") state.indented = state.lexical.indented;
            state.lexical = state.lexical.prev;
          }
        }

        poplex.lex = true;

        function expect(wanted) {
          function exp(type) {
            if (type == wanted) return cont();else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();else return cont(exp);
          }
          return exp;
        }

        function statement(type, value) {
          if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
          if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
          if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
          if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
          if (type == "debugger") return cont(expect(";"));
          if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
          if (type == ";") return cont();

          if (type == "if") {
            if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
            return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
          }

          if (type == "function") return cont(functiondef);
          if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);

          if (type == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form", type == "class" ? type : value), className, poplex);
          }

          if (type == "variable") {
            if (isTS && value == "declare") {
              cx.marked = "keyword";
              return cont(statement);
            } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
              cx.marked = "keyword";
              if (value == "enum") return cont(enumdef);else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
            } else if (isTS && value == "namespace") {
              cx.marked = "keyword";
              return cont(pushlex("form"), expression, statement, poplex);
            } else if (isTS && value == "abstract") {
              cx.marked = "keyword";
              return cont(statement);
            } else {
              return cont(pushlex("stat"), maybelabel);
            }
          }

          if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
          if (type == "case") return cont(expression, expect(":"));
          if (type == "default") return cont(expect(":"));
          if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
          if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
          if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
          if (type == "async") return cont(statement);
          if (value == "@") return cont(expression, statement);
          return pass(pushlex("stat"), expression, expect(";"), poplex);
        }

        function maybeCatchBinding(type) {
          if (type == "(") return cont(funarg, expect(")"));
        }

        function expression(type, value) {
          return expressionInner(type, value, false);
        }

        function expressionNoComma(type, value) {
          return expressionInner(type, value, true);
        }

        function parenExpr(type) {
          if (type != "(") return pass();
          return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
        }

        function expressionInner(type, value, noComma) {
          if (cx.state.fatArrowAt == cx.stream.start) {
            var body = noComma ? arrowBodyNoComma : arrowBody;
            if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
          }

          var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
          if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
          if (type == "function") return cont(functiondef, maybeop);

          if (type == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form"), classExpression, poplex);
          }

          if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
          if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
          if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
          if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
          if (type == "{") return contCommasep(objprop, "}", null, maybeop);
          if (type == "quasi") return pass(quasi, maybeop);
          if (type == "new") return cont(maybeTarget(noComma));
          return cont();
        }

        function maybeexpression(type) {
          if (type.match(/[;\}\)\],]/)) return pass();
          return pass(expression);
        }

        function maybeoperatorComma(type, value) {
          if (type == ",") return cont(maybeexpression);
          return maybeoperatorNoComma(type, value, false);
        }

        function maybeoperatorNoComma(type, value, noComma) {
          var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
          var expr = noComma == false ? expression : expressionNoComma;
          if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);

          if (type == "operator") {
            if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
            if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false)) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
            if (value == "?") return cont(expression, expect(":"), expr);
            return cont(expr);
          }

          if (type == "quasi") {
            return pass(quasi, me);
          }

          if (type == ";") return;
          if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
          if (type == ".") return cont(property, me);
          if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);

          if (isTS && value == "as") {
            cx.marked = "keyword";
            return cont(typeexpr, me);
          }

          if (type == "regexp") {
            cx.state.lastType = cx.marked = "operator";
            cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
            return cont(expr);
          }
        }

        function quasi(type, value) {
          if (type != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasi);
          return cont(maybeexpression, continueQuasi);
        }

        function continueQuasi(type) {
          if (type == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasi);
          }
        }

        function arrowBody(type) {
          findFatArrow(cx.stream, cx.state);
          return pass(type == "{" ? statement : expression);
        }

        function arrowBodyNoComma(type) {
          findFatArrow(cx.stream, cx.state);
          return pass(type == "{" ? statement : expressionNoComma);
        }

        function maybeTarget(noComma) {
          return function (type) {
            if (type == ".") return cont(noComma ? targetNoComma : target);else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);
          };
        }

        function target(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorComma);
          }
        }

        function targetNoComma(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorNoComma);
          }
        }

        function maybelabel(type) {
          if (type == ":") return cont(poplex, statement);
          return pass(maybeoperatorComma, expect(";"), poplex);
        }

        function property(type) {
          if (type == "variable") {
            cx.marked = "property";
            return cont();
          }
        }

        function objprop(type, value) {
          if (type == "async") {
            cx.marked = "property";
            return cont(objprop);
          } else if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            if (value == "get" || value == "set") return cont(getterSetter);
            var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params

            if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;
            return cont(afterprop);
          } else if (type == "number" || type == "string") {
            cx.marked = jsonldMode ? "property" : cx.style + " property";
            return cont(afterprop);
          } else if (type == "jsonld-keyword") {
            return cont(afterprop);
          } else if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type == "[") {
            return cont(expression, maybetype, expect("]"), afterprop);
          } else if (type == "spread") {
            return cont(expressionNoComma, afterprop);
          } else if (value == "*") {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type == ":") {
            return pass(afterprop);
          }
        }

        function getterSetter(type) {
          if (type != "variable") return pass(afterprop);
          cx.marked = "property";
          return cont(functiondef);
        }

        function afterprop(type) {
          if (type == ":") return cont(expressionNoComma);
          if (type == "(") return pass(functiondef);
        }

        function commasep(what, end, sep) {
          function proceed(type, value) {
            if (sep ? sep.indexOf(type) > -1 : type == ",") {
              var lex = cx.state.lexical;
              if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
              return cont(function (type, value) {
                if (type == end || value == end) return pass();
                return pass(what);
              }, proceed);
            }

            if (type == end || value == end) return cont();
            if (sep && sep.indexOf(";") > -1) return pass(what);
            return cont(expect(end));
          }

          return function (type, value) {
            if (type == end || value == end) return cont();
            return pass(what, proceed);
          };
        }

        function contCommasep(what, end, info) {
          for (var i = 3; i < arguments.length; i++) {
            cx.cc.push(arguments[i]);
          }

          return cont(pushlex(end, info), commasep(what, end), poplex);
        }

        function block(type) {
          if (type == "}") return cont();
          return pass(statement, block);
        }

        function maybetype(type, value) {
          if (isTS) {
            if (type == ":") return cont(typeexpr);
            if (value == "?") return cont(maybetype);
          }
        }

        function maybetypeOrIn(type, value) {
          if (isTS && (type == ":" || value == "in")) return cont(typeexpr);
        }

        function mayberettype(type) {
          if (isTS && type == ":") {
            if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);
          }
        }

        function isKW(_, value) {
          if (value == "is") {
            cx.marked = "keyword";
            return cont();
          }
        }

        function typeexpr(type, value) {
          if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
            cx.marked = "keyword";
            return cont(value == "typeof" ? expressionNoComma : typeexpr);
          }

          if (type == "variable" || value == "void") {
            cx.marked = "type";
            return cont(afterType);
          }

          if (value == "|" || value == "&") return cont(typeexpr);
          if (type == "string" || type == "number" || type == "atom") return cont(afterType);
          if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
          if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
          if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
          if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr);

          if (type == "quasi") {
            return pass(quasiType, afterType);
          }
        }

        function maybeReturnType(type) {
          if (type == "=>") return cont(typeexpr);
        }

        function typeprops(type) {
          if (type.match(/[\}\)\]]/)) return cont();
          if (type == "," || type == ";") return cont(typeprops);
          return pass(typeprop, typeprops);
        }

        function typeprop(type, value) {
          if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(typeprop);
          } else if (value == "?" || type == "number" || type == "string") {
            return cont(typeprop);
          } else if (type == ":") {
            return cont(typeexpr);
          } else if (type == "[") {
            return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
          } else if (type == "(") {
            return pass(functiondecl, typeprop);
          } else if (!type.match(/[;\}\)\],]/)) {
            return cont();
          }
        }

        function quasiType(type, value) {
          if (type != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasiType);
          return cont(typeexpr, continueQuasiType);
        }

        function continueQuasiType(type) {
          if (type == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasiType);
          }
        }

        function typearg(type, value) {
          if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
          if (type == ":") return cont(typeexpr);
          if (type == "spread") return cont(typearg);
          return pass(typeexpr);
        }

        function afterType(type, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          if (value == "|" || type == "." || value == "&") return cont(typeexpr);
          if (type == "[") return cont(typeexpr, expect("]"), afterType);

          if (value == "extends" || value == "implements") {
            cx.marked = "keyword";
            return cont(typeexpr);
          }

          if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
        }

        function maybeTypeArgs(_, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        }

        function typeparam() {
          return pass(typeexpr, maybeTypeDefault);
        }

        function maybeTypeDefault(_, value) {
          if (value == "=") return cont(typeexpr);
        }

        function vardef(_, value) {
          if (value == "enum") {
            cx.marked = "keyword";
            return cont(enumdef);
          }

          return pass(pattern, maybetype, maybeAssign, vardefCont);
        }

        function pattern(type, value) {
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(pattern);
          }

          if (type == "variable") {
            register(value);
            return cont();
          }

          if (type == "spread") return cont(pattern);
          if (type == "[") return contCommasep(eltpattern, "]");
          if (type == "{") return contCommasep(proppattern, "}");
        }

        function proppattern(type, value) {
          if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
            register(value);
            return cont(maybeAssign);
          }

          if (type == "variable") cx.marked = "property";
          if (type == "spread") return cont(pattern);
          if (type == "}") return pass();
          if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
          return cont(expect(":"), pattern, maybeAssign);
        }

        function eltpattern() {
          return pass(pattern, maybeAssign);
        }

        function maybeAssign(_type, value) {
          if (value == "=") return cont(expressionNoComma);
        }

        function vardefCont(type) {
          if (type == ",") return cont(vardef);
        }

        function maybeelse(type, value) {
          if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
        }

        function forspec(type, value) {
          if (value == "await") return cont(forspec);
          if (type == "(") return cont(pushlex(")"), forspec1, poplex);
        }

        function forspec1(type) {
          if (type == "var") return cont(vardef, forspec2);
          if (type == "variable") return cont(forspec2);
          return pass(forspec2);
        }

        function forspec2(type, value) {
          if (type == ")") return cont();
          if (type == ";") return cont(forspec2);

          if (value == "in" || value == "of") {
            cx.marked = "keyword";
            return cont(expression, forspec2);
          }

          return pass(expression, forspec2);
        }

        function functiondef(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondef);
          }

          if (type == "variable") {
            register(value);
            return cont(functiondef);
          }

          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
        }

        function functiondecl(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondecl);
          }

          if (type == "variable") {
            register(value);
            return cont(functiondecl);
          }

          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
        }

        function typename(type, value) {
          if (type == "keyword" || type == "variable") {
            cx.marked = "type";
            return cont(typename);
          } else if (value == "<") {
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
          }
        }

        function funarg(type, value) {
          if (value == "@") cont(expression, funarg);
          if (type == "spread") return cont(funarg);

          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(funarg);
          }

          if (isTS && type == "this") return cont(maybetype, maybeAssign);
          return pass(pattern, maybetype, maybeAssign);
        }

        function classExpression(type, value) {
          // Class expressions may have an optional name.
          if (type == "variable") return className(type, value);
          return classNameAfter(type, value);
        }

        function className(type, value) {
          if (type == "variable") {
            register(value);
            return cont(classNameAfter);
          }
        }

        function classNameAfter(type, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);

          if (value == "extends" || value == "implements" || isTS && type == ",") {
            if (value == "implements") cx.marked = "keyword";
            return cont(isTS ? typeexpr : expression, classNameAfter);
          }

          if (type == "{") return cont(pushlex("}"), classBody, poplex);
        }

        function classBody(type, value) {
          if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
            cx.marked = "keyword";
            return cont(classBody);
          }

          if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(classfield, classBody);
          }

          if (type == "number" || type == "string") return cont(classfield, classBody);
          if (type == "[") return cont(expression, maybetype, expect("]"), classfield, classBody);

          if (value == "*") {
            cx.marked = "keyword";
            return cont(classBody);
          }

          if (isTS && type == "(") return pass(functiondecl, classBody);
          if (type == ";" || type == ",") return cont(classBody);
          if (type == "}") return cont();
          if (value == "@") return cont(expression, classBody);
        }

        function classfield(type, value) {
          if (value == "!") return cont(classfield);
          if (value == "?") return cont(classfield);
          if (type == ":") return cont(typeexpr, maybeAssign);
          if (value == "=") return cont(expressionNoComma);
          var context = cx.state.lexical.prev,
              isInterface = context && context.info == "interface";
          return pass(isInterface ? functiondecl : functiondef);
        }

        function afterExport(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(maybeFrom, expect(";"));
          }

          if (value == "default") {
            cx.marked = "keyword";
            return cont(expression, expect(";"));
          }

          if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
          return pass(statement);
        }

        function exportField(type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(expect("variable"));
          }

          if (type == "variable") return pass(expressionNoComma, exportField);
        }

        function afterImport(type) {
          if (type == "string") return cont();
          if (type == "(") return pass(expression);
          if (type == ".") return pass(maybeoperatorComma);
          return pass(importSpec, maybeMoreImports, maybeFrom);
        }

        function importSpec(type, value) {
          if (type == "{") return contCommasep(importSpec, "}");
          if (type == "variable") register(value);
          if (value == "*") cx.marked = "keyword";
          return cont(maybeAs);
        }

        function maybeMoreImports(type) {
          if (type == ",") return cont(importSpec, maybeMoreImports);
        }

        function maybeAs(_type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(importSpec);
          }
        }

        function maybeFrom(_type, value) {
          if (value == "from") {
            cx.marked = "keyword";
            return cont(expression);
          }
        }

        function arrayLiteral(type) {
          if (type == "]") return cont();
          return pass(commasep(expressionNoComma, "]"));
        }

        function enumdef() {
          return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
        }

        function enummember() {
          return pass(pattern, maybeAssign);
        }

        function isContinuedStatement(state, textAfter) {
          return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
        }

        function expressionAllowed(stream, state, backUp) {
          return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
        } // Interface


        return {
          startState: function startState(basecolumn) {
            var state = {
              tokenize: tokenBase,
              lastType: "sof",
              cc: [],
              lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
              localVars: parserConfig.localVars,
              context: parserConfig.localVars && new Context(null, null, false),
              indented: basecolumn || 0
            };
            if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;
            return state;
          },
          token: function token(stream, state) {
            if (stream.sol()) {
              if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
              state.indented = stream.indentation();
              findFatArrow(stream, state);
            }

            if (state.tokenize != tokenComment && stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            if (type == "comment") return style;
            state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
            return parseJS(state, style, type, content, stream);
          },
          indent: function indent(state, textAfter) {
            if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
            if (state.tokenize != tokenBase) return 0;
            var firstChar = textAfter && textAfter.charAt(0),
                lexical = state.lexical,
                top; // Kludge to prevent 'maybelse' from blocking lexical scope pops

            if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
              var c = state.cc[i];
              if (c == poplex) lexical = lexical.prev;else if (c != maybeelse && c != popcontext) break;
            }

            while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) {
              lexical = lexical.prev;
            }

            if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
            var type = lexical.type,
                closing = firstChar == type;
            if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: jsonMode ? null : "/*",
          blockCommentEnd: jsonMode ? null : "*/",
          blockCommentContinue: jsonMode ? null : " * ",
          lineComment: jsonMode ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: jsonMode ? "json" : "javascript",
          jsonldMode: jsonldMode,
          jsonMode: jsonMode,
          expressionAllowed: expressionAllowed,
          skipExpression: function skipExpression(state) {
            parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null));
          }
        };
      });
      CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
      CodeMirror.defineMIME("text/javascript", "javascript");
      CodeMirror.defineMIME("text/ecmascript", "javascript");
      CodeMirror.defineMIME("application/javascript", "javascript");
      CodeMirror.defineMIME("application/x-javascript", "javascript");
      CodeMirror.defineMIME("application/ecmascript", "javascript");
      CodeMirror.defineMIME("application/json", {
        name: "javascript",
        json: true
      });
      CodeMirror.defineMIME("application/x-json", {
        name: "javascript",
        json: true
      });
      CodeMirror.defineMIME("application/manifest+json", {
        name: "javascript",
        json: true
      });
      CodeMirror.defineMIME("application/ld+json", {
        name: "javascript",
        jsonld: true
      });
      CodeMirror.defineMIME("text/typescript", {
        name: "javascript",
        typescript: true
      });
      CodeMirror.defineMIME("application/typescript", {
        name: "javascript",
        typescript: true
      });
    });
  });

  var searchcursor = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {

      var Pos = CodeMirror.Pos;

      function regexpFlags(regexp) {
        var flags = regexp.flags;
        return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
      }

      function ensureFlags(regexp, flags) {
        var current = regexpFlags(regexp),
            target = current;

        for (var i = 0; i < flags.length; i++) {
          if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);
        }

        return current == target ? regexp : new RegExp(regexp.source, target);
      }

      function maybeMultiline(regexp) {
        return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
      }

      function searchRegexpForward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");

        for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
          regexp.lastIndex = ch;
          var string = doc.getLine(line),
              match = regexp.exec(string);
          if (match) return {
            from: Pos(line, match.index),
            to: Pos(line, match.index + match[0].length),
            match: match
          };
        }
      }

      function searchRegexpForwardMultiline(doc, regexp, start) {
        if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);
        regexp = ensureFlags(regexp, "gm");
        var string,
            chunk = 1;

        for (var line = start.line, last = doc.lastLine(); line <= last;) {
          // This grows the search buffer in exponentially-sized chunks
          // between matches, so that nearby matches are fast and don't
          // require concatenating the whole document (in case we're
          // searching for something that has tons of matches), but at the
          // same time, the amount of retries is limited.
          for (var i = 0; i < chunk; i++) {
            if (line > last) break;
            var curLine = doc.getLine(line++);
            string = string == null ? curLine : string + "\n" + curLine;
          }

          chunk = chunk * 2;
          regexp.lastIndex = start.ch;
          var match = regexp.exec(string);

          if (match) {
            var before = string.slice(0, match.index).split("\n"),
                inside = match[0].split("\n");
            var startLine = start.line + before.length - 1,
                startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
              match: match
            };
          }
        }
      }

      function lastMatchIn(string, regexp, endMargin) {
        var match,
            from = 0;

        while (from <= string.length) {
          regexp.lastIndex = from;
          var newMatch = regexp.exec(string);
          if (!newMatch) break;
          var end = newMatch.index + newMatch[0].length;
          if (end > string.length - endMargin) break;
          if (!match || end > match.index + match[0].length) match = newMatch;
          from = newMatch.index + 1;
        }

        return match;
      }

      function searchRegexpBackward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");

        for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
          var string = doc.getLine(line);
          var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);
          if (match) return {
            from: Pos(line, match.index),
            to: Pos(line, match.index + match[0].length),
            match: match
          };
        }
      }

      function searchRegexpBackwardMultiline(doc, regexp, start) {
        if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start);
        regexp = ensureFlags(regexp, "gm");
        var string,
            chunkSize = 1,
            endMargin = doc.getLine(start.line).length - start.ch;

        for (var line = start.line, first = doc.firstLine(); line >= first;) {
          for (var i = 0; i < chunkSize && line >= first; i++) {
            var curLine = doc.getLine(line--);
            string = string == null ? curLine : curLine + "\n" + string;
          }

          chunkSize *= 2;
          var match = lastMatchIn(string, regexp, endMargin);

          if (match) {
            var before = string.slice(0, match.index).split("\n"),
                inside = match[0].split("\n");
            var startLine = line + before.length,
                startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
              match: match
            };
          }
        }
      }

      var doFold, noFold;

      if (String.prototype.normalize) {
        doFold = function doFold(str) {
          return str.normalize("NFD").toLowerCase();
        };

        noFold = function noFold(str) {
          return str.normalize("NFD");
        };
      } else {
        doFold = function doFold(str) {
          return str.toLowerCase();
        };

        noFold = function noFold(str) {
          return str;
        };
      } // Maps a position in a case-folded line back to a position in the original line
      // (compensating for codepoints increasing in number during folding)


      function adjustPos(orig, folded, pos, foldFunc) {
        if (orig.length == folded.length) return pos;

        for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
          if (min == max) return min;
          var mid = min + max >> 1;
          var len = foldFunc(orig.slice(0, mid)).length;
          if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;
        }
      }

      function searchStringForward(doc, query, start, caseFold) {
        // Empty string would match anything and never progress, so we
        // define it to match nothing instead.
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);

        search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
          var orig = doc.getLine(line).slice(ch),
              string = fold(orig);

          if (lines.length == 1) {
            var found = string.indexOf(lines[0]);
            if (found == -1) continue search;
            var start = adjustPos(orig, string, found, fold) + ch;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold) + ch),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
            };
          } else {
            var cutFrom = string.length - lines[0].length;
            if (string.slice(cutFrom) != lines[0]) continue search;

            for (var i = 1; i < lines.length - 1; i++) {
              if (fold(doc.getLine(line + i)) != lines[i]) continue search;
            }

            var end = doc.getLine(line + lines.length - 1),
                endString = fold(end),
                lastLine = lines[lines.length - 1];
            if (endString.slice(0, lastLine.length) != lastLine) continue search;
            return {
              from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
              to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
            };
          }
        }
      }

      function searchStringBackward(doc, query, start, caseFold) {
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);

        search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
          var orig = doc.getLine(line);
          if (ch > -1) orig = orig.slice(0, ch);
          var string = fold(orig);

          if (lines.length == 1) {
            var found = string.lastIndexOf(lines[0]);
            if (found == -1) continue search;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold)),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
            };
          } else {
            var lastLine = lines[lines.length - 1];
            if (string.slice(0, lastLine.length) != lastLine) continue search;

            for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) {
              if (fold(doc.getLine(start + i)) != lines[i]) continue search;
            }

            var top = doc.getLine(line + 1 - lines.length),
                topString = fold(top);
            if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
            return {
              from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
              to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
            };
          }
        }
      }

      function SearchCursor(doc, query, pos, options) {
        this.atOccurrence = false;
        this.afterEmptyMatch = false;
        this.doc = doc;
        pos = pos ? doc.clipPos(pos) : Pos(0, 0);
        this.pos = {
          from: pos,
          to: pos
        };
        var caseFold;

        if (typeof options == "object") {
          caseFold = options.caseFold;
        } else {
          // Backwards compat for when caseFold was the 4th argument
          caseFold = options;
          options = null;
        }

        if (typeof query == "string") {
          if (caseFold == null) caseFold = false;

          this.matches = function (reverse, pos) {
            return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);
          };
        } else {
          query = ensureFlags(query, "gm");
          if (!options || options.multiline !== false) this.matches = function (reverse, pos) {
            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);
          };else this.matches = function (reverse, pos) {
            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);
          };
        }
      }

      SearchCursor.prototype = {
        findNext: function findNext() {
          return this.find(false);
        },
        findPrevious: function findPrevious() {
          return this.find(true);
        },
        find: function find(reverse) {
          var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);

          if (this.afterEmptyMatch && this.atOccurrence) {
            // do not return the same 0 width match twice
            head = Pos(head.line, head.ch);

            if (reverse) {
              head.ch--;

              if (head.ch < 0) {
                head.line--;
                head.ch = (this.doc.getLine(head.line) || "").length;
              }
            } else {
              head.ch++;

              if (head.ch > (this.doc.getLine(head.line) || "").length) {
                head.ch = 0;
                head.line++;
              }
            }

            if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {
              return this.atOccurrence = false;
            }
          }

          var result = this.matches(reverse, head);
          this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0;

          if (result) {
            this.pos = result;
            this.atOccurrence = true;
            return this.pos.match || true;
          } else {
            var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
            this.pos = {
              from: end,
              to: end
            };
            return this.atOccurrence = false;
          }
        },
        from: function from() {
          if (this.atOccurrence) return this.pos.from;
        },
        to: function to() {
          if (this.atOccurrence) return this.pos.to;
        },
        replace: function replace(newText, origin) {
          if (!this.atOccurrence) return;
          var lines = CodeMirror.splitLines(newText);
          this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
          this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
        }
      };
      CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold);
      });
      CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold);
      });
      CodeMirror.defineExtension("selectMatches", function (query, caseFold) {
        var ranges = [];
        var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);

        while (cur.findNext()) {
          if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
          ranges.push({
            anchor: cur.from(),
            head: cur.to()
          });
        }

        if (ranges.length) this.setSelections(ranges, 0);
      });
    });
  });

  var matchbrackets = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {
      var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
      var Pos = CodeMirror.Pos;
      var matching = {
        "(": ")>",
        ")": "(<",
        "[": "]>",
        "]": "[<",
        "{": "}>",
        "}": "{<",
        "<": ">>",
        ">": "<<"
      };

      function bracketRegex(config) {
        return config && config.bracketRegex || /[(){}[\]]/;
      }

      function findMatchingBracket(cm, where, config) {
        var line = cm.getLineHandle(where.line),
            pos = where.ch - 1;
        var afterCursor = config && config.afterCursor;
        if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
        var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode
        // (i.e. not insert mode), the cursor is visually represented as a
        // highlighted box on top of the 2nd character. Otherwise, we allow matches
        // from before or after the cursor.

        var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
        if (!match) return null;
        var dir = match.charAt(1) == ">" ? 1 : -1;
        if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
        var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
        var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
        if (found == null) return null;
        return {
          from: Pos(where.line, pos),
          to: found && found.pos,
          match: found && found.ch == match.charAt(0),
          forward: dir > 0
        };
      } // bracketRegex is used to specify which type of bracket to scan
      // should be a regexp, e.g. /[[\]]/
      //
      // Note: If "where" is on an open bracket, then this bracket is ignored.
      //
      // Returns false when no bracket was found, null when it reached
      // maxScanLines and gave up


      function scanForBracket(cm, where, dir, style, config) {
        var maxScanLen = config && config.maxScanLineLength || 10000;
        var maxScanLines = config && config.maxScanLines || 1000;
        var stack = [];
        var re = bracketRegex(config);
        var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);

        for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
          var line = cm.getLine(lineNo);
          if (!line) continue;
          var pos = dir > 0 ? 0 : line.length - 1,
              end = dir > 0 ? line.length : -1;
          if (line.length > maxScanLen) continue;
          if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);

          for (; pos != end; pos += dir) {
            var ch = line.charAt(pos);

            if (re.test(ch) && (style === undefined || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
              var match = matching[ch];
              if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return {
                pos: Pos(lineNo, pos),
                ch: ch
              };else stack.pop();
            }
          }
        }

        return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
      }

      function matchBrackets(cm, autoclear, config) {
        // Disable brace matching in long lines, since it'll cause hugely slow updates
        var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,
            highlightNonMatching = config && config.highlightNonMatching;
        var marks = [],
            ranges = cm.listSelections();

        for (var i = 0; i < ranges.length; i++) {
          var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);

          if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
            var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
            marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
              className: style
            }));
            if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
              className: style
            }));
          }
        }

        if (marks.length) {
          // Kludge to work around the IE bug from issue #1193, where text
          // input stops going to the textarea whenever this fires.
          if (ie_lt8 && cm.state.focused) cm.focus();

          var clear = function clear() {
            cm.operation(function () {
              for (var i = 0; i < marks.length; i++) {
                marks[i].clear();
              }
            });
          };

          if (autoclear) setTimeout(clear, 800);else return clear;
        }
      }

      function doMatchBrackets(cm) {
        cm.operation(function () {
          if (cm.state.matchBrackets.currentlyHighlighted) {
            cm.state.matchBrackets.currentlyHighlighted();
            cm.state.matchBrackets.currentlyHighlighted = null;
          }

          cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
        });
      }

      function clearHighlighted(cm) {
        if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
          cm.state.matchBrackets.currentlyHighlighted();
          cm.state.matchBrackets.currentlyHighlighted = null;
        }
      }

      CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
        if (old && old != CodeMirror.Init) {
          cm.off("cursorActivity", doMatchBrackets);
          cm.off("focus", doMatchBrackets);
          cm.off("blur", clearHighlighted);
          clearHighlighted(cm);
        }

        if (val) {
          cm.state.matchBrackets = typeof val == "object" ? val : {};
          cm.on("cursorActivity", doMatchBrackets);
          cm.on("focus", doMatchBrackets);
          cm.on("blur", clearHighlighted);
        }
      });
      CodeMirror.defineExtension("matchBrackets", function () {
        matchBrackets(this, true);
      });
      CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
        // Backwards-compatibility kludge
        if (oldConfig || typeof config == "boolean") {
          if (!oldConfig) {
            config = config ? {
              strict: true
            } : null;
          } else {
            oldConfig.strict = config;
            config = oldConfig;
          }
        }

        return findMatchingBracket(this, pos, config);
      });
      CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
        return scanForBracket(this, pos, dir, style, config);
      });
    });
  });

  var sublime = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // A rough approximation of Sublime Text's keybindings
    // Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js
    (function (mod) {
      mod(codemirror, searchcursor, matchbrackets);
    })(function (CodeMirror) {

      var cmds = CodeMirror.commands;
      var Pos = CodeMirror.Pos; // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.

      function findPosSubword(doc, start, dir) {
        if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
        var line = doc.getLine(start.line);
        if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
        var state = "start",
            type,
            startPos = start.ch;

        for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
          var next = line.charAt(dir < 0 ? pos - 1 : pos);
          var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
          if (cat == "w" && next.toUpperCase() == next) cat = "W";

          if (state == "start") {
            if (cat != "o") {
              state = "in";
              type = cat;
            } else startPos = pos + dir;
          } else if (state == "in") {
            if (type != cat) {
              if (type == "w" && cat == "W" && dir < 0) pos--;

              if (type == "W" && cat == "w" && dir > 0) {
                // From uppercase to lowercase
                if (pos == startPos + 1) {
                  type = "w";
                  continue;
                } else pos--;
              }

              break;
            }
          }
        }

        return Pos(start.line, pos);
      }

      function moveSubword(cm, dir) {
        cm.extendSelectionsBy(function (range) {
          if (cm.display.shift || cm.doc.extend || range.empty()) return findPosSubword(cm.doc, range.head, dir);else return dir < 0 ? range.from() : range.to();
        });
      }

      cmds.goSubwordLeft = function (cm) {
        moveSubword(cm, -1);
      };

      cmds.goSubwordRight = function (cm) {
        moveSubword(cm, 1);
      };

      cmds.scrollLineUp = function (cm) {
        var info = cm.getScrollInfo();

        if (!cm.somethingSelected()) {
          var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
          if (cm.getCursor().line >= visibleBottomLine) cm.execCommand("goLineUp");
        }

        cm.scrollTo(null, info.top - cm.defaultTextHeight());
      };

      cmds.scrollLineDown = function (cm) {
        var info = cm.getScrollInfo();

        if (!cm.somethingSelected()) {
          var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;
          if (cm.getCursor().line <= visibleTopLine) cm.execCommand("goLineDown");
        }

        cm.scrollTo(null, info.top + cm.defaultTextHeight());
      };

      cmds.splitSelectionByLine = function (cm) {
        var ranges = cm.listSelections(),
            lineRanges = [];

        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(),
              to = ranges[i].to();

          for (var line = from.line; line <= to.line; ++line) {
            if (!(to.line > from.line && line == to.line && to.ch == 0)) lineRanges.push({
              anchor: line == from.line ? from : Pos(line, 0),
              head: line == to.line ? to : Pos(line)
            });
          }
        }

        cm.setSelections(lineRanges, 0);
      };

      cmds.singleSelectionTop = function (cm) {
        var range = cm.listSelections()[0];
        cm.setSelection(range.anchor, range.head, {
          scroll: false
        });
      };

      cmds.selectLine = function (cm) {
        var ranges = cm.listSelections(),
            extended = [];

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          extended.push({
            anchor: Pos(range.from().line, 0),
            head: Pos(range.to().line + 1, 0)
          });
        }

        cm.setSelections(extended);
      };

      function insertLine(cm, above) {
        if (cm.isReadOnly()) return CodeMirror.Pass;
        cm.operation(function () {
          var len = cm.listSelections().length,
              newSelection = [],
              last = -1;

          for (var i = 0; i < len; i++) {
            var head = cm.listSelections()[i].head;
            if (head.line <= last) continue;
            var at = Pos(head.line + (above ? 0 : 1), 0);
            cm.replaceRange("\n", at, null, "+insertLine");
            cm.indentLine(at.line, null, true);
            newSelection.push({
              head: at,
              anchor: at
            });
            last = head.line + 1;
          }

          cm.setSelections(newSelection);
        });
        cm.execCommand("indentAuto");
      }

      cmds.insertLineAfter = function (cm) {
        return insertLine(cm, false);
      };

      cmds.insertLineBefore = function (cm) {
        return insertLine(cm, true);
      };

      function wordAt(cm, pos) {
        var start = pos.ch,
            end = start,
            line = cm.getLine(pos.line);

        while (start && CodeMirror.isWordChar(line.charAt(start - 1))) {
          --start;
        }

        while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) {
          ++end;
        }

        return {
          from: Pos(pos.line, start),
          to: Pos(pos.line, end),
          word: line.slice(start, end)
        };
      }

      cmds.selectNextOccurrence = function (cm) {
        var from = cm.getCursor("from"),
            to = cm.getCursor("to");
        var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;

        if (CodeMirror.cmpPos(from, to) == 0) {
          var word = wordAt(cm, from);
          if (!word.word) return;
          cm.setSelection(word.from, word.to);
          fullWord = true;
        } else {
          var text = cm.getRange(from, to);
          var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
          var cur = cm.getSearchCursor(query, to);
          var found = cur.findNext();

          if (!found) {
            cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
            found = cur.findNext();
          }

          if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return;
          cm.addSelection(cur.from(), cur.to());
        }

        if (fullWord) cm.state.sublimeFindFullWord = cm.doc.sel;
      };

      cmds.skipAndSelectNextOccurrence = function (cm) {
        var prevAnchor = cm.getCursor("anchor"),
            prevHead = cm.getCursor("head");
        cmds.selectNextOccurrence(cm);

        if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {
          cm.doc.setSelections(cm.doc.listSelections().filter(function (sel) {
            return sel.anchor != prevAnchor || sel.head != prevHead;
          }));
        }
      };

      function addCursorToSelection(cm, dir) {
        var ranges = cm.listSelections(),
            newRanges = [];

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var newAnchor = cm.findPosV(range.anchor, dir, "line", range.anchor.goalColumn);
          var newHead = cm.findPosV(range.head, dir, "line", range.head.goalColumn);
          newAnchor.goalColumn = range.anchor.goalColumn != null ? range.anchor.goalColumn : cm.cursorCoords(range.anchor, "div").left;
          newHead.goalColumn = range.head.goalColumn != null ? range.head.goalColumn : cm.cursorCoords(range.head, "div").left;
          var newRange = {
            anchor: newAnchor,
            head: newHead
          };
          newRanges.push(range);
          newRanges.push(newRange);
        }

        cm.setSelections(newRanges);
      }

      cmds.addCursorToPrevLine = function (cm) {
        addCursorToSelection(cm, -1);
      };

      cmds.addCursorToNextLine = function (cm) {
        addCursorToSelection(cm, 1);
      };

      function isSelectedRange(ranges, from, to) {
        for (var i = 0; i < ranges.length; i++) {
          if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 && CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true;
        }

        return false;
      }

      var mirror = "(){}[]";

      function selectBetweenBrackets(cm) {
        var ranges = cm.listSelections(),
            newRanges = [];

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i],
              pos = range.head,
              opening = cm.scanForBracket(pos, -1);
          if (!opening) return false;

          for (;;) {
            var closing = cm.scanForBracket(pos, 1);
            if (!closing) return false;

            if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
              var startPos = Pos(opening.pos.line, opening.pos.ch + 1);

              if (CodeMirror.cmpPos(startPos, range.from()) == 0 && CodeMirror.cmpPos(closing.pos, range.to()) == 0) {
                opening = cm.scanForBracket(opening.pos, -1);
                if (!opening) return false;
              } else {
                newRanges.push({
                  anchor: startPos,
                  head: closing.pos
                });
                break;
              }
            }

            pos = Pos(closing.pos.line, closing.pos.ch + 1);
          }
        }

        cm.setSelections(newRanges);
        return true;
      }

      cmds.selectScope = function (cm) {
        selectBetweenBrackets(cm) || cm.execCommand("selectAll");
      };

      cmds.selectBetweenBrackets = function (cm) {
        if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
      };

      function puncType(type) {
        return !type ? null : /\bpunctuation\b/.test(type) ? type : undefined;
      }

      cmds.goToBracket = function (cm) {
        cm.extendSelectionsBy(function (range) {
          var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));
          if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
          var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));
          return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
        });
      };

      cmds.swapLineUp = function (cm) {
        if (cm.isReadOnly()) return CodeMirror.Pass;
        var ranges = cm.listSelections(),
            linesToMove = [],
            at = cm.firstLine() - 1,
            newSels = [];

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i],
              from = range.from().line - 1,
              to = range.to().line;
          newSels.push({
            anchor: Pos(range.anchor.line - 1, range.anchor.ch),
            head: Pos(range.head.line - 1, range.head.ch)
          });
          if (range.to().ch == 0 && !range.empty()) --to;
          if (from > at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
          at = to;
        }

        cm.operation(function () {
          for (var i = 0; i < linesToMove.length; i += 2) {
            var from = linesToMove[i],
                to = linesToMove[i + 1];
            var line = cm.getLine(from);
            cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
            if (to > cm.lastLine()) cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");else cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
          }

          cm.setSelections(newSels);
          cm.scrollIntoView();
        });
      };

      cmds.swapLineDown = function (cm) {
        if (cm.isReadOnly()) return CodeMirror.Pass;
        var ranges = cm.listSelections(),
            linesToMove = [],
            at = cm.lastLine() + 1;

        for (var i = ranges.length - 1; i >= 0; i--) {
          var range = ranges[i],
              from = range.to().line + 1,
              to = range.from().line;
          if (range.to().ch == 0 && !range.empty()) from--;
          if (from < at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
          at = to;
        }

        cm.operation(function () {
          for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
            var from = linesToMove[i],
                to = linesToMove[i + 1];
            var line = cm.getLine(from);
            if (from == cm.lastLine()) cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");else cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
            cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
          }

          cm.scrollIntoView();
        });
      };

      cmds.toggleCommentIndented = function (cm) {
        cm.toggleComment({
          indent: true
        });
      };

      cmds.joinLines = function (cm) {
        var ranges = cm.listSelections(),
            joined = [];

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i],
              from = range.from();
          var start = from.line,
              end = range.to().line;

          while (i < ranges.length - 1 && ranges[i + 1].from().line == end) {
            end = ranges[++i].to().line;
          }

          joined.push({
            start: start,
            end: end,
            anchor: !range.empty() && from
          });
        }

        cm.operation(function () {
          var offset = 0,
              ranges = [];

          for (var i = 0; i < joined.length; i++) {
            var obj = joined[i];
            var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch),
                head;

            for (var line = obj.start; line <= obj.end; line++) {
              var actual = line - offset;
              if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);

              if (actual < cm.lastLine()) {
                cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
                ++offset;
              }
            }

            ranges.push({
              anchor: anchor || head,
              head: head
            });
          }

          cm.setSelections(ranges, 0);
        });
      };

      cmds.duplicateLine = function (cm) {
        cm.operation(function () {
          var rangeCount = cm.listSelections().length;

          for (var i = 0; i < rangeCount; i++) {
            var range = cm.listSelections()[i];
            if (range.empty()) cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));else cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
          }

          cm.scrollIntoView();
        });
      };

      function sortLines(cm, caseSensitive, direction) {
        if (cm.isReadOnly()) return CodeMirror.Pass;
        var ranges = cm.listSelections(),
            toSort = [],
            selected;

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (range.empty()) continue;
          var from = range.from().line,
              to = range.to().line;

          while (i < ranges.length - 1 && ranges[i + 1].from().line == to) {
            to = ranges[++i].to().line;
          }

          if (!ranges[i].to().ch) to--;
          toSort.push(from, to);
        }

        if (toSort.length) selected = true;else toSort.push(cm.firstLine(), cm.lastLine());
        cm.operation(function () {
          var ranges = [];

          for (var i = 0; i < toSort.length; i += 2) {
            var from = toSort[i],
                to = toSort[i + 1];
            var start = Pos(from, 0),
                end = Pos(to);
            var lines = cm.getRange(start, end, false);
            if (caseSensitive) lines.sort(function (a, b) {
              return a < b ? -direction : a == b ? 0 : direction;
            });else lines.sort(function (a, b) {
              var au = a.toUpperCase(),
                  bu = b.toUpperCase();

              if (au != bu) {
                a = au;
                b = bu;
              }

              return a < b ? -direction : a == b ? 0 : direction;
            });
            cm.replaceRange(lines, start, end);
            if (selected) ranges.push({
              anchor: start,
              head: Pos(to + 1, 0)
            });
          }

          if (selected) cm.setSelections(ranges, 0);
        });
      }

      cmds.sortLines = function (cm) {
        sortLines(cm, true, 1);
      };

      cmds.reverseSortLines = function (cm) {
        sortLines(cm, true, -1);
      };

      cmds.sortLinesInsensitive = function (cm) {
        sortLines(cm, false, 1);
      };

      cmds.reverseSortLinesInsensitive = function (cm) {
        sortLines(cm, false, -1);
      };

      cmds.nextBookmark = function (cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) while (marks.length) {
          var current = marks.shift();
          var found = current.find();

          if (found) {
            marks.push(current);
            return cm.setSelection(found.from, found.to);
          }
        }
      };

      cmds.prevBookmark = function (cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) while (marks.length) {
          marks.unshift(marks.pop());
          var found = marks[marks.length - 1].find();
          if (!found) marks.pop();else return cm.setSelection(found.from, found.to);
        }
      };

      cmds.toggleBookmark = function (cm) {
        var ranges = cm.listSelections();
        var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);

        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(),
              to = ranges[i].to();
          var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);

          for (var j = 0; j < found.length; j++) {
            if (found[j].sublimeBookmark) {
              found[j].clear();

              for (var k = 0; k < marks.length; k++) {
                if (marks[k] == found[j]) marks.splice(k--, 1);
              }

              break;
            }
          }

          if (j == found.length) marks.push(cm.markText(from, to, {
            sublimeBookmark: true,
            clearWhenEmpty: false
          }));
        }
      };

      cmds.clearBookmarks = function (cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) for (var i = 0; i < marks.length; i++) {
          marks[i].clear();
        }
        marks.length = 0;
      };

      cmds.selectBookmarks = function (cm) {
        var marks = cm.state.sublimeBookmarks,
            ranges = [];
        if (marks) for (var i = 0; i < marks.length; i++) {
          var found = marks[i].find();
          if (!found) marks.splice(i--, 0);else ranges.push({
            anchor: found.from,
            head: found.to
          });
        }
        if (ranges.length) cm.setSelections(ranges, 0);
      };

      function modifyWordOrSelection(cm, mod) {
        cm.operation(function () {
          var ranges = cm.listSelections(),
              indices = [],
              replacements = [];

          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];

            if (range.empty()) {
              indices.push(i);
              replacements.push("");
            } else replacements.push(mod(cm.getRange(range.from(), range.to())));
          }

          cm.replaceSelections(replacements, "around", "case");

          for (var i = indices.length - 1, at; i >= 0; i--) {
            var range = ranges[indices[i]];
            if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
            var word = wordAt(cm, range.head);
            at = word.from;
            cm.replaceRange(mod(word.word), word.from, word.to);
          }
        });
      }

      cmds.smartBackspace = function (cm) {
        if (cm.somethingSelected()) return CodeMirror.Pass;
        cm.operation(function () {
          var cursors = cm.listSelections();
          var indentUnit = cm.getOption("indentUnit");

          for (var i = cursors.length - 1; i >= 0; i--) {
            var cursor = cursors[i].head;
            var toStartOfLine = cm.getRange({
              line: cursor.line,
              ch: 0
            }, cursor);
            var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize")); // Delete by one character by default

            var deletePos = cm.findPosH(cursor, -1, "char", false);

            if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
              var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit)); // Smart delete only if we found a valid prevIndent location

              if (prevIndent.ch != cursor.ch) deletePos = prevIndent;
            }

            cm.replaceRange("", deletePos, cursor, "+delete");
          }
        });
      };

      cmds.delLineRight = function (cm) {
        cm.operation(function () {
          var ranges = cm.listSelections();

          for (var i = ranges.length - 1; i >= 0; i--) {
            cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
          }

          cm.scrollIntoView();
        });
      };

      cmds.upcaseAtCursor = function (cm) {
        modifyWordOrSelection(cm, function (str) {
          return str.toUpperCase();
        });
      };

      cmds.downcaseAtCursor = function (cm) {
        modifyWordOrSelection(cm, function (str) {
          return str.toLowerCase();
        });
      };

      cmds.setSublimeMark = function (cm) {
        if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      };

      cmds.selectToSublimeMark = function (cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) cm.setSelection(cm.getCursor(), found);
      };

      cmds.deleteToSublimeMark = function (cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();

        if (found) {
          var from = cm.getCursor(),
              to = found;

          if (CodeMirror.cmpPos(from, to) > 0) {
            var tmp = to;
            to = from;
            from = tmp;
          }

          cm.state.sublimeKilled = cm.getRange(from, to);
          cm.replaceRange("", from, to);
        }
      };

      cmds.swapWithSublimeMark = function (cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();

        if (found) {
          cm.state.sublimeMark.clear();
          cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
          cm.setCursor(found);
        }
      };

      cmds.sublimeYank = function (cm) {
        if (cm.state.sublimeKilled != null) cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
      };

      cmds.showInCenter = function (cm) {
        var pos = cm.cursorCoords(null, "local");
        cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
      };

      function getTarget(cm) {
        var from = cm.getCursor("from"),
            to = cm.getCursor("to");

        if (CodeMirror.cmpPos(from, to) == 0) {
          var word = wordAt(cm, from);
          if (!word.word) return;
          from = word.from;
          to = word.to;
        }

        return {
          from: from,
          to: to,
          query: cm.getRange(from, to),
          word: word
        };
      }

      function findAndGoTo(cm, forward) {
        var target = getTarget(cm);
        if (!target) return;
        var query = target.query;
        var cur = cm.getSearchCursor(query, forward ? target.to : target.from);

        if (forward ? cur.findNext() : cur.findPrevious()) {
          cm.setSelection(cur.from(), cur.to());
        } else {
          cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));
          if (forward ? cur.findNext() : cur.findPrevious()) cm.setSelection(cur.from(), cur.to());else if (target.word) cm.setSelection(target.from, target.to);
        }
      }

      cmds.findUnder = function (cm) {
        findAndGoTo(cm, true);
      };

      cmds.findUnderPrevious = function (cm) {
        findAndGoTo(cm, false);
      };

      cmds.findAllUnder = function (cm) {
        var target = getTarget(cm);
        if (!target) return;
        var cur = cm.getSearchCursor(target.query);
        var matches = [];
        var primaryIndex = -1;

        while (cur.findNext()) {
          matches.push({
            anchor: cur.from(),
            head: cur.to()
          });
          if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch) primaryIndex++;
        }

        cm.setSelections(matches, primaryIndex);
      };

      var keyMap = CodeMirror.keyMap;
      keyMap.macSublime = {
        "Cmd-Left": "goLineStartSmart",
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-Left": "goSubwordLeft",
        "Ctrl-Right": "goSubwordRight",
        "Ctrl-Alt-Up": "scrollLineUp",
        "Ctrl-Alt-Down": "scrollLineDown",
        "Cmd-L": "selectLine",
        "Shift-Cmd-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Cmd-Enter": "insertLineAfter",
        "Shift-Cmd-Enter": "insertLineBefore",
        "Cmd-D": "selectNextOccurrence",
        "Shift-Cmd-Space": "selectScope",
        "Shift-Cmd-M": "selectBetweenBrackets",
        "Cmd-M": "goToBracket",
        "Cmd-Ctrl-Up": "swapLineUp",
        "Cmd-Ctrl-Down": "swapLineDown",
        "Cmd-/": "toggleCommentIndented",
        "Cmd-J": "joinLines",
        "Shift-Cmd-D": "duplicateLine",
        "F5": "sortLines",
        "Shift-F5": "reverseSortLines",
        "Cmd-F5": "sortLinesInsensitive",
        "Shift-Cmd-F5": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Cmd-F2": "toggleBookmark",
        "Shift-Cmd-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",
        "Cmd-K Cmd-K": "delLineRight",
        "Cmd-K Cmd-U": "upcaseAtCursor",
        "Cmd-K Cmd-L": "downcaseAtCursor",
        "Cmd-K Cmd-Space": "setSublimeMark",
        "Cmd-K Cmd-A": "selectToSublimeMark",
        "Cmd-K Cmd-W": "deleteToSublimeMark",
        "Cmd-K Cmd-X": "swapWithSublimeMark",
        "Cmd-K Cmd-Y": "sublimeYank",
        "Cmd-K Cmd-C": "showInCenter",
        "Cmd-K Cmd-G": "clearBookmarks",
        "Cmd-K Cmd-Backspace": "delLineLeft",
        "Cmd-K Cmd-1": "foldAll",
        "Cmd-K Cmd-0": "unfoldAll",
        "Cmd-K Cmd-J": "unfoldAll",
        "Ctrl-Shift-Up": "addCursorToPrevLine",
        "Ctrl-Shift-Down": "addCursorToNextLine",
        "Cmd-F3": "findUnder",
        "Shift-Cmd-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Cmd-[": "fold",
        "Shift-Cmd-]": "unfold",
        "Cmd-I": "findIncremental",
        "Shift-Cmd-I": "findIncrementalReverse",
        "Cmd-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "macDefault"
      };
      CodeMirror.normalizeKeyMap(keyMap.macSublime);
      keyMap.pcSublime = {
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-T": "transposeChars",
        "Alt-Left": "goSubwordLeft",
        "Alt-Right": "goSubwordRight",
        "Ctrl-Up": "scrollLineUp",
        "Ctrl-Down": "scrollLineDown",
        "Ctrl-L": "selectLine",
        "Shift-Ctrl-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Ctrl-Enter": "insertLineAfter",
        "Shift-Ctrl-Enter": "insertLineBefore",
        "Ctrl-D": "selectNextOccurrence",
        "Shift-Ctrl-Space": "selectScope",
        "Shift-Ctrl-M": "selectBetweenBrackets",
        "Ctrl-M": "goToBracket",
        "Shift-Ctrl-Up": "swapLineUp",
        "Shift-Ctrl-Down": "swapLineDown",
        "Ctrl-/": "toggleCommentIndented",
        "Ctrl-J": "joinLines",
        "Shift-Ctrl-D": "duplicateLine",
        "F9": "sortLines",
        "Shift-F9": "reverseSortLines",
        "Ctrl-F9": "sortLinesInsensitive",
        "Shift-Ctrl-F9": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Ctrl-F2": "toggleBookmark",
        "Shift-Ctrl-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",
        "Ctrl-K Ctrl-K": "delLineRight",
        "Ctrl-K Ctrl-U": "upcaseAtCursor",
        "Ctrl-K Ctrl-L": "downcaseAtCursor",
        "Ctrl-K Ctrl-Space": "setSublimeMark",
        "Ctrl-K Ctrl-A": "selectToSublimeMark",
        "Ctrl-K Ctrl-W": "deleteToSublimeMark",
        "Ctrl-K Ctrl-X": "swapWithSublimeMark",
        "Ctrl-K Ctrl-Y": "sublimeYank",
        "Ctrl-K Ctrl-C": "showInCenter",
        "Ctrl-K Ctrl-G": "clearBookmarks",
        "Ctrl-K Ctrl-Backspace": "delLineLeft",
        "Ctrl-K Ctrl-1": "foldAll",
        "Ctrl-K Ctrl-0": "unfoldAll",
        "Ctrl-K Ctrl-J": "unfoldAll",
        "Ctrl-Alt-Up": "addCursorToPrevLine",
        "Ctrl-Alt-Down": "addCursorToNextLine",
        "Ctrl-F3": "findUnder",
        "Shift-Ctrl-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Ctrl-[": "fold",
        "Shift-Ctrl-]": "unfold",
        "Ctrl-I": "findIncremental",
        "Shift-Ctrl-I": "findIncrementalReverse",
        "Ctrl-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "pcDefault"
      };
      CodeMirror.normalizeKeyMap(keyMap.pcSublime);
      var mac = keyMap.default == keyMap.macDefault;
      keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
    });
  });

  var dialog = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // Open simple dialogs on top of an editor. Relies on dialog.css.
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {
      function dialogDiv(cm, template, bottom) {
        var wrap = cm.getWrapperElement();
        var dialog;
        dialog = wrap.appendChild(document.createElement("div"));
        if (bottom) dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";else dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

        if (typeof template == "string") {
          dialog.innerHTML = template;
        } else {
          // Assuming it's a detached DOM element.
          dialog.appendChild(template);
        }

        CodeMirror.addClass(wrap, 'dialog-opened');
        return dialog;
      }

      function closeNotification(cm, newVal) {
        if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();
        cm.state.currentNotificationClose = newVal;
      }

      CodeMirror.defineExtension("openDialog", function (template, callback, options) {
        if (!options) options = {};
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options.bottom);
        var closed = false,
            me = this;

        function close(newVal) {
          if (typeof newVal == 'string') {
            inp.value = newVal;
          } else {
            if (closed) return;
            closed = true;
            CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
            dialog.parentNode.removeChild(dialog);
            me.focus();
            if (options.onClose) options.onClose(dialog);
          }
        }

        var inp = dialog.getElementsByTagName("input")[0],
            button;

        if (inp) {
          inp.focus();

          if (options.value) {
            inp.value = options.value;

            if (options.selectValueOnOpen !== false) {
              inp.select();
            }
          }

          if (options.onInput) CodeMirror.on(inp, "input", function (e) {
            options.onInput(e, inp.value, close);
          });
          if (options.onKeyUp) CodeMirror.on(inp, "keyup", function (e) {
            options.onKeyUp(e, inp.value, close);
          });
          CodeMirror.on(inp, "keydown", function (e) {
            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {
              return;
            }

            if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {
              inp.blur();
              CodeMirror.e_stop(e);
              close();
            }

            if (e.keyCode == 13) callback(inp.value, e);
          });
          if (options.closeOnBlur !== false) CodeMirror.on(dialog, "focusout", function (evt) {
            if (evt.relatedTarget !== null) close();
          });
        } else if (button = dialog.getElementsByTagName("button")[0]) {
          CodeMirror.on(button, "click", function () {
            close();
            me.focus();
          });
          if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);
          button.focus();
        }

        return close;
      });
      CodeMirror.defineExtension("openConfirm", function (template, callbacks, options) {
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var buttons = dialog.getElementsByTagName("button");
        var closed = false,
            me = this,
            blurring = 1;

        function close() {
          if (closed) return;
          closed = true;
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
          me.focus();
        }

        buttons[0].focus();

        for (var i = 0; i < buttons.length; ++i) {
          var b = buttons[i];

          (function (callback) {
            CodeMirror.on(b, "click", function (e) {
              CodeMirror.e_preventDefault(e);
              close();
              if (callback) callback(me);
            });
          })(callbacks[i]);

          CodeMirror.on(b, "blur", function () {
            --blurring;
            setTimeout(function () {
              if (blurring <= 0) close();
            }, 200);
          });
          CodeMirror.on(b, "focus", function () {
            ++blurring;
          });
        }
      });
      /*
       * openNotification
       * Opens a notification, that can be closed with an optional timer
       * (default 5000ms timer) and always closes on click.
       *
       * If a notification is opened while another is opened, it will close the
       * currently opened one and open the new one immediately.
       */

      CodeMirror.defineExtension("openNotification", function (template, options) {
        closeNotification(this, close);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var closed = false,
            doneTimer;
        var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

        function close() {
          if (closed) return;
          closed = true;
          clearTimeout(doneTimer);
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
        }

        CodeMirror.on(dialog, 'click', function (e) {
          CodeMirror.e_preventDefault(e);
          close();
        });
        if (duration) doneTimer = setTimeout(close, duration);
        return close;
      });
    });
  });

  var search = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // Define search commands. Depends on dialog.js or another
    // implementation of the openDialog method.
    // Replace works a little oddly -- it will do the replace on the next
    // Ctrl-G (or whatever is bound to findNext) press. You prevent a
    // replace by making sure the match is no longer selected when hitting
    // Ctrl-G.
    (function (mod) {
      mod(codemirror, searchcursor, dialog);
    })(function (CodeMirror) {

      CodeMirror.defineOption("search", {
        bottom: false
      });

      function searchOverlay(query, caseInsensitive) {
        if (typeof query == "string") query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");else if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");
        return {
          token: function token(stream) {
            query.lastIndex = stream.pos;
            var match = query.exec(stream.string);

            if (match && match.index == stream.pos) {
              stream.pos += match[0].length || 1;
              return "searching";
            } else if (match) {
              stream.pos = match.index;
            } else {
              stream.skipToEnd();
            }
          }
        };
      }

      function SearchState() {
        this.posFrom = this.posTo = this.lastQuery = this.query = null;
        this.overlay = null;
      }

      function getSearchState(cm) {
        return cm.state.search || (cm.state.search = new SearchState());
      }

      function queryCaseInsensitive(query) {
        return typeof query == "string" && query == query.toLowerCase();
      }

      function getSearchCursor(cm, query, pos) {
        // Heuristic: if the query string is all lowercase, do a case insensitive search.
        return cm.getSearchCursor(query, pos, {
          caseFold: queryCaseInsensitive(query),
          multiline: true
        });
      }

      function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
        cm.openDialog(text, onEnter, {
          value: deflt,
          selectValueOnOpen: true,
          closeOnEnter: false,
          onClose: function onClose() {
            clearSearch(cm);
          },
          onKeyDown: onKeyDown,
          bottom: cm.options.search.bottom
        });
      }

      function dialog(cm, text, shortText, deflt, f) {
        if (cm.openDialog) cm.openDialog(text, f, {
          value: deflt,
          selectValueOnOpen: true,
          bottom: cm.options.search.bottom
        });else f(prompt(shortText, deflt));
      }

      function confirmDialog(cm, text, shortText, fs) {
        if (cm.openConfirm) cm.openConfirm(text, fs);else if (confirm(shortText)) fs[0]();
      }

      function parseString(string) {
        return string.replace(/\\([nrt\\])/g, function (match, ch) {
          if (ch == "n") return "\n";
          if (ch == "r") return "\r";
          if (ch == "t") return "\t";
          if (ch == "\\") return "\\";
          return match;
        });
      }

      function parseQuery(query) {
        var isRE = query.match(/^\/(.*)\/([a-z]*)$/);

        if (isRE) {
          try {
            query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
          } catch (e) {} // Not a regular expression after all, do a string search

        } else {
          query = parseString(query);
        }

        if (typeof query == "string" ? query == "" : query.test("")) query = /x^/;
        return query;
      }

      function startSearch(cm, state, query) {
        state.queryText = query;
        state.query = parseQuery(query);
        cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
        cm.addOverlay(state.overlay);

        if (cm.showMatchesOnScrollbar) {
          if (state.annotate) {
            state.annotate.clear();
            state.annotate = null;
          }

          state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
        }
      }

      function doSearch(cm, rev, persistent, immediate) {
        var state = getSearchState(cm);
        if (state.query) return findNext(cm, rev);
        var q = cm.getSelection() || state.lastQuery;
        if (q instanceof RegExp && q.source == "x^") q = null;

        if (persistent && cm.openDialog) {
          var hiding = null;

          var searchNext = function searchNext(query, event) {
            CodeMirror.e_stop(event);
            if (!query) return;

            if (query != state.queryText) {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
            }

            if (hiding) hiding.style.opacity = 1;
            findNext(cm, event.shiftKey, function (_, to) {
              var dialog;
              if (to.line < 3 && document.querySelector && (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top) (hiding = dialog).style.opacity = .4;
            });
          };

          persistentDialog(cm, getQueryDialog(cm), q, searchNext, function (event, query) {
            var keyName = CodeMirror.keyName(event);
            var extra = cm.getOption('extraKeys'),
                cmd = extra && extra[keyName] || CodeMirror.keyMap[cm.getOption("keyMap")][keyName];

            if (cmd == "findNext" || cmd == "findPrev" || cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
              CodeMirror.e_stop(event);
              startSearch(cm, getSearchState(cm), query);
              cm.execCommand(cmd);
            } else if (cmd == "find" || cmd == "findPersistent") {
              CodeMirror.e_stop(event);
              searchNext(query, event);
            }
          });

          if (immediate && q) {
            startSearch(cm, state, q);
            findNext(cm, rev);
          }
        } else {
          dialog(cm, getQueryDialog(cm), "Search for:", q, function (query) {
            if (query && !state.query) cm.operation(function () {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
              findNext(cm, rev);
            });
          });
        }
      }

      function findNext(cm, rev, callback) {
        cm.operation(function () {
          var state = getSearchState(cm);
          var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);

          if (!cursor.find(rev)) {
            cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
            if (!cursor.find(rev)) return;
          }

          cm.setSelection(cursor.from(), cursor.to());
          cm.scrollIntoView({
            from: cursor.from(),
            to: cursor.to()
          }, 20);
          state.posFrom = cursor.from();
          state.posTo = cursor.to();
          if (callback) callback(cursor.from(), cursor.to());
        });
      }

      function clearSearch(cm) {
        cm.operation(function () {
          var state = getSearchState(cm);
          state.lastQuery = state.query;
          if (!state.query) return;
          state.query = state.queryText = null;
          cm.removeOverlay(state.overlay);

          if (state.annotate) {
            state.annotate.clear();
            state.annotate = null;
          }
        });
      }

      function el(tag, attrs) {
        var element = tag ? document.createElement(tag) : document.createDocumentFragment();

        for (var key in attrs) {
          element[key] = attrs[key];
        }

        for (var i = 2; i < arguments.length; i++) {
          var child = arguments[i];
          element.appendChild(typeof child == "string" ? document.createTextNode(child) : child);
        }

        return element;
      }

      function getQueryDialog(cm) {
        return el("", null, el("span", {
          className: "CodeMirror-search-label"
        }, cm.phrase("Search:")), " ", el("input", {
          type: "text",
          "style": "width: 10em",
          className: "CodeMirror-search-field"
        }), " ", el("span", {
          style: "color: #888",
          className: "CodeMirror-search-hint"
        }, cm.phrase("(Use /re/ syntax for regexp search)")));
      }

      function getReplaceQueryDialog(cm) {
        return el("", null, " ", el("input", {
          type: "text",
          "style": "width: 10em",
          className: "CodeMirror-search-field"
        }), " ", el("span", {
          style: "color: #888",
          className: "CodeMirror-search-hint"
        }, cm.phrase("(Use /re/ syntax for regexp search)")));
      }

      function getReplacementQueryDialog(cm) {
        return el("", null, el("span", {
          className: "CodeMirror-search-label"
        }, cm.phrase("With:")), " ", el("input", {
          type: "text",
          "style": "width: 10em",
          className: "CodeMirror-search-field"
        }));
      }

      function getDoReplaceConfirm(cm) {
        return el("", null, el("span", {
          className: "CodeMirror-search-label"
        }, cm.phrase("Replace?")), " ", el("button", {}, cm.phrase("Yes")), " ", el("button", {}, cm.phrase("No")), " ", el("button", {}, cm.phrase("All")), " ", el("button", {}, cm.phrase("Stop")));
      }

      function replaceAll(cm, query, text) {
        cm.operation(function () {
          for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
            if (typeof query != "string") {
              var match = cm.getRange(cursor.from(), cursor.to()).match(query);
              cursor.replace(text.replace(/\$(\d)/g, function (_, i) {
                return match[i];
              }));
            } else cursor.replace(text);
          }
        });
      }

      function replace(cm, all) {
        if (cm.getOption("readOnly")) return;
        var query = cm.getSelection() || getSearchState(cm).lastQuery;
        var dialogText = all ? cm.phrase("Replace all:") : cm.phrase("Replace:");
        var fragment = el("", null, el("span", {
          className: "CodeMirror-search-label"
        }, dialogText), getReplaceQueryDialog(cm));
        dialog(cm, fragment, dialogText, query, function (query) {
          if (!query) return;
          query = parseQuery(query);
          dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function (text) {
            text = parseString(text);

            if (all) {
              replaceAll(cm, query, text);
            } else {
              clearSearch(cm);
              var cursor = getSearchCursor(cm, query, cm.getCursor("from"));

              var advance = function advance() {
                var start = cursor.from(),
                    match;

                if (!(match = cursor.findNext())) {
                  cursor = getSearchCursor(cm, query);
                  if (!(match = cursor.findNext()) || start && cursor.from().line == start.line && cursor.from().ch == start.ch) return;
                }

                cm.setSelection(cursor.from(), cursor.to());
                cm.scrollIntoView({
                  from: cursor.from(),
                  to: cursor.to()
                });
                confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"), [function () {
                  doReplace(match);
                }, advance, function () {
                  replaceAll(cm, query, text);
                }]);
              };

              var doReplace = function doReplace(match) {
                cursor.replace(typeof query == "string" ? text : text.replace(/\$(\d)/g, function (_, i) {
                  return match[i];
                }));
                advance();
              };

              advance();
            }
          });
        });
      }

      CodeMirror.commands.find = function (cm) {
        clearSearch(cm);
        doSearch(cm);
      };

      CodeMirror.commands.findPersistent = function (cm) {
        clearSearch(cm);
        doSearch(cm, false, true);
      };

      CodeMirror.commands.findPersistentNext = function (cm) {
        doSearch(cm, false, true, true);
      };

      CodeMirror.commands.findPersistentPrev = function (cm) {
        doSearch(cm, true, true, true);
      };

      CodeMirror.commands.findNext = doSearch;

      CodeMirror.commands.findPrev = function (cm) {
        doSearch(cm, true);
      };

      CodeMirror.commands.clearSearch = clearSearch;
      CodeMirror.commands.replace = replace;

      CodeMirror.commands.replaceAll = function (cm) {
        replace(cm, true);
      };
    });
  });

  var jumpToLine = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // Defines jumpToLine command. Uses dialog.js if present.
    (function (mod) {
      mod(codemirror, dialog);
    })(function (CodeMirror) {

      CodeMirror.defineOption("search", {
        bottom: false
      });

      function dialog(cm, text, shortText, deflt, f) {
        if (cm.openDialog) cm.openDialog(text, f, {
          value: deflt,
          selectValueOnOpen: true,
          bottom: cm.options.search.bottom
        });else f(prompt(shortText, deflt));
      }

      function getJumpDialog(cm) {
        return cm.phrase("Jump to line:") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use line:column or scroll% syntax)") + '</span>';
      }

      function interpretLine(cm, string) {
        var num = Number(string);
        if (/^[-+]/.test(string)) return cm.getCursor().line + num;else return num - 1;
      }

      CodeMirror.commands.jumpToLine = function (cm) {
        var cur = cm.getCursor();
        dialog(cm, getJumpDialog(cm), cm.phrase("Jump to line:"), cur.line + 1 + ":" + cur.ch, function (posStr) {
          if (!posStr) return;
          var match;

          if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), Number(match[2]));
          } else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
            var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
            if (/^[-+]/.test(match[1])) line = cur.line + line + 1;
            cm.setCursor(line - 1, cur.ch);
          } else if (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), cur.ch);
          }
        });
      };

      CodeMirror.keyMap["default"]["Alt-G"] = "jumpToLine";
    });
  });

  var comment = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {

      var noOptions = {};
      var nonWS = /[^\s\u00a0]/;
      var Pos = CodeMirror.Pos,
          cmp = CodeMirror.cmpPos;

      function firstNonWS(str) {
        var found = str.search(nonWS);
        return found == -1 ? 0 : found;
      }

      CodeMirror.commands.toggleComment = function (cm) {
        cm.toggleComment();
      };

      CodeMirror.defineExtension("toggleComment", function (options) {
        if (!options) options = noOptions;
        var cm = this;
        var minLine = Infinity,
            ranges = this.listSelections(),
            mode = null;

        for (var i = ranges.length - 1; i >= 0; i--) {
          var from = ranges[i].from(),
              to = ranges[i].to();
          if (from.line >= minLine) continue;
          if (to.line >= minLine) to = Pos(minLine, 0);
          minLine = from.line;

          if (mode == null) {
            if (cm.uncomment(from, to, options)) mode = "un";else {
              cm.lineComment(from, to, options);
              mode = "line";
            }
          } else if (mode == "un") {
            cm.uncomment(from, to, options);
          } else {
            cm.lineComment(from, to, options);
          }
        }
      }); // Rough heuristic to try and detect lines that are part of multi-line string

      function probablyInsideString(cm, pos, line) {
        return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line);
      }

      function getMode(cm, pos) {
        var mode = cm.getMode();
        return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);
      }

      CodeMirror.defineExtension("lineComment", function (from, to, options) {
        if (!options) options = noOptions;
        var self = this,
            mode = getMode(self, from);
        var firstLine = self.getLine(from.line);
        if (firstLine == null || probablyInsideString(self, from, firstLine)) return;
        var commentString = options.lineComment || mode.lineComment;

        if (!commentString) {
          if (options.blockCommentStart || mode.blockCommentStart) {
            options.fullLines = true;
            self.blockComment(from, to, options);
          }

          return;
        }

        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
        var pad = options.padding == null ? " " : options.padding;
        var blankLines = options.commentBlankLines || from.line == to.line;
        self.operation(function () {
          if (options.indent) {
            var baseString = null;

            for (var i = from.line; i < end; ++i) {
              var line = self.getLine(i);
              var whitespace = line.slice(0, firstNonWS(line));

              if (baseString == null || baseString.length > whitespace.length) {
                baseString = whitespace;
              }
            }

            for (var i = from.line; i < end; ++i) {
              var line = self.getLine(i),
                  cut = baseString.length;
              if (!blankLines && !nonWS.test(line)) continue;
              if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
              self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
            }
          } else {
            for (var i = from.line; i < end; ++i) {
              if (blankLines || nonWS.test(self.getLine(i))) self.replaceRange(commentString + pad, Pos(i, 0));
            }
          }
        });
      });
      CodeMirror.defineExtension("blockComment", function (from, to, options) {
        if (!options) options = noOptions;
        var self = this,
            mode = getMode(self, from);
        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;

        if (!startString || !endString) {
          if ((options.lineComment || mode.lineComment) && options.fullLines != false) self.lineComment(from, to, options);
          return;
        }

        if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return;
        var end = Math.min(to.line, self.lastLine());
        if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;
        var pad = options.padding == null ? " " : options.padding;
        if (from.line > end) return;
        self.operation(function () {
          if (options.fullLines != false) {
            var lastLineHasText = nonWS.test(self.getLine(end));
            self.replaceRange(pad + endString, Pos(end));
            self.replaceRange(startString + pad, Pos(from.line, 0));
            var lead = options.blockCommentLead || mode.blockCommentLead;
            if (lead != null) for (var i = from.line + 1; i <= end; ++i) {
              if (i != end || lastLineHasText) self.replaceRange(lead + pad, Pos(i, 0));
            }
          } else {
            var atCursor = cmp(self.getCursor("to"), to) == 0,
                empty = !self.somethingSelected();
            self.replaceRange(endString, to);
            if (atCursor) self.setSelection(empty ? to : self.getCursor("from"), to);
            self.replaceRange(startString, from);
          }
        });
      });
      CodeMirror.defineExtension("uncomment", function (from, to, options) {
        if (!options) options = noOptions;
        var self = this,
            mode = getMode(self, from);
        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()),
            start = Math.min(from.line, end); // Try finding line comments

        var lineString = options.lineComment || mode.lineComment,
            lines = [];
        var pad = options.padding == null ? " " : options.padding,
            didSomething;

        lineComment: {
          if (!lineString) break lineComment;

          for (var i = start; i <= end; ++i) {
            var line = self.getLine(i);
            var found = line.indexOf(lineString);
            if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
            if (found == -1 && nonWS.test(line)) break lineComment;
            if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
            lines.push(line);
          }

          self.operation(function () {
            for (var i = start; i <= end; ++i) {
              var line = lines[i - start];
              var pos = line.indexOf(lineString),
                  endPos = pos + lineString.length;
              if (pos < 0) continue;
              if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
              didSomething = true;
              self.replaceRange("", Pos(i, pos), Pos(i, endPos));
            }
          });
          if (didSomething) return true;
        } // Try block comments


        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;
        if (!startString || !endString) return false;
        var lead = options.blockCommentLead || mode.blockCommentLead;
        var startLine = self.getLine(start),
            open = startLine.indexOf(startString);
        if (open == -1) return false;
        var endLine = end == start ? startLine : self.getLine(end);
        var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
        var insideStart = Pos(start, open + 1),
            insideEnd = Pos(end, close + 1);
        if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1) return false; // Avoid killing block comments completely outside the selection.
        // Positions of the last startString before the start of the selection, and the first endString after it.

        var lastStart = startLine.lastIndexOf(startString, from.ch);
        var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
        if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false; // Positions of the first endString after the end of the selection, and the last startString before it.

        firstEnd = endLine.indexOf(endString, to.ch);
        var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
        lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
        if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;
        self.operation(function () {
          self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));
          var openEnd = open + startString.length;
          if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
          self.replaceRange("", Pos(start, open), Pos(start, openEnd));
          if (lead) for (var i = start + 1; i <= end; ++i) {
            var line = self.getLine(i),
                found = line.indexOf(lead);
            if (found == -1 || nonWS.test(line.slice(0, found))) continue;
            var foundEnd = found + lead.length;
            if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
            self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
          }
        });
        return true;
      });
    });
  });

  var _templateObject$7;
  var cmStyles = r$1(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral(["\n/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 50px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -50px; margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n  outline: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n\n"])));

  var _templateObject$8;
  var monokaiTheme = r$1(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral(["\n/* Based on Sublime Text's Monokai theme */\n\n.cm-s-monokai.CodeMirror { background: #272822; color: #f8f8f2; }\n.cm-s-monokai div.CodeMirror-selected { background: #49483E; }\n.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }\n.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }\n.cm-s-monokai .CodeMirror-gutters { background: #272822; border-right: 0px; }\n.cm-s-monokai .CodeMirror-guttermarker { color: white; }\n.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\n.cm-s-monokai .CodeMirror-linenumber { color: #d0d0d0; }\n.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }\n\n.cm-s-monokai span.cm-comment { color: #75715e; }\n.cm-s-monokai span.cm-atom { color: #ae81ff; }\n.cm-s-monokai span.cm-number { color: #ae81ff; }\n\n.cm-s-monokai span.cm-comment.cm-attribute { color: #97b757; }\n.cm-s-monokai span.cm-comment.cm-def { color: #bc9262; }\n.cm-s-monokai span.cm-comment.cm-tag { color: #bc6283; }\n.cm-s-monokai span.cm-comment.cm-type { color: #5998a6; }\n\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }\n.cm-s-monokai span.cm-keyword { color: #f92672; }\n.cm-s-monokai span.cm-builtin { color: #66d9ef; }\n.cm-s-monokai span.cm-string { color: #e6db74; }\n\n.cm-s-monokai span.cm-variable { color: #f8f8f2; }\n.cm-s-monokai span.cm-variable-2 { color: #9effff; }\n.cm-s-monokai span.cm-variable-3, .cm-s-monokai span.cm-type { color: #66d9ef; }\n.cm-s-monokai span.cm-def { color: #fd971f; }\n.cm-s-monokai span.cm-bracket { color: #f8f8f2; }\n.cm-s-monokai span.cm-tag { color: #f92672; }\n.cm-s-monokai span.cm-header { color: #ae81ff; }\n.cm-s-monokai span.cm-link { color: #ae81ff; }\n.cm-s-monokai span.cm-error { background: #f92672; color: #f8f8f0; }\n\n.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }\n.cm-s-monokai .CodeMirror-matchingbracket {\n  text-decoration: underline;\n  color: white !important;\n}\n\n"])));

  var _templateObject$9;
  var addonDialog = r$1(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral(["\n.CodeMirror-dialog {\n  position: absolute;\n  left: 0; right: 0;\n  background: inherit;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: inherit;\n}\n\n.CodeMirror-dialog-top {\n  border-bottom: 1px solid #eee;\n  top: 0;\n}\n\n.CodeMirror-dialog-bottom {\n  border-top: 1px solid #eee;\n  bottom: 0;\n}\n\n.CodeMirror-dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}\n\n.CodeMirror-dialog button {\n  font-size: 70%;\n}\n\n"])));

  var _templateObject$a, _templateObject2$7;

  codemirror.commands.save = function (cm) {
    cm._scComponent.value = cm.getValue();
    var event = new CustomEvent('change', {
      bubbles: true,
      composed: true,
      detail: {
        value: cm._scComponent.value
      }
    });

    cm._scComponent.cleanDoc();

    cm._scComponent.dispatchEvent(event);
  };

  var ScEditor = /*#__PURE__*/function (_LitElement) {
    _inherits(ScEditor, _LitElement);

    var _super = _createSuper(ScEditor);

    function ScEditor() {
      var _this;

      _classCallCheck(this, ScEditor);

      _this = _super.call(this);
      _this._value = null;
      _this.width = 300;
      _this.height = 200;
      _this.fontSize = 11;
      _this.value = "";
      /** private */

      _this.$container = null;
      return _this;
    }

    _createClass(ScEditor, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        var _this2 = this;

        this._value = value !== null ? value : '';

        if (this.codeMirror) {
          var pos = this.codeMirror.getCursor();
          this.codeMirror.setValue(this._value);
          this.codeMirror.setCursor(pos);
          this.cleanDoc();
          setTimeout(function () {
            return _this2.codeMirror.refresh();
          }, 1);
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
        this._editorWidth = this._width - 3;

        if (this.codeMirror) {
          this.requestUpdate();
        }
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
        this._editorHeight = this._height - 2;

        if (this.codeMirror) {
          this.requestUpdate();
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (this.codeMirror) {
          // @note - a bit hardcore but more efficient than in setters
          // @todo - debounce
          this.codeMirror.setSize(this._editorWidth, this._editorHeight);
        }

        return $$1(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral(["\n      <div\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        @keydown=\"", "\"\n      >\n        <div\n          class=\"codemirror\"\n          style=\"\n            width: ", "px;\n            height: ", "px;\n            font-size: ", "px;\n          \"\n        ></div>\n        <sc-button\n          text=\"save\"\n          width=\"120\"\n          @input=\"", "\"\n          @release=\"", "\"\n        ></sc-button>\n      </div>\n    "])), this._width, this._height, this.onKeydown, this._editorWidth, this._editorHeight, this.fontSize, function (e) {
          return e.stopPropagation();
        }, this.save);
      }
    }, {
      key: "onKeydown",
      value: function onKeydown(e) {
        // manually do comment because opens Help menu otherwise...
        if (e.metaKey && e.shiftKey) {
          e.preventDefault();

          if (e.key === '/') {
            this.codeMirror.toggleComment();
          } // can't do anything for zoom, too deep in the system

        }
      } // need to copy same logic as for cmd + s / ctrl + s

    }, {
      key: "save",
      value: function save(e) {
        this._value = this.codeMirror.getValue();
        var event = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        });
        this.cleanDoc();
        this.dispatchEvent(event);
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated() {
        var _this3 = this;

        this.$container = this.shadowRoot.querySelector('div');
        this.$codeContainer = this.shadowRoot.querySelector('div .codemirror');
        this.codeMirror = codemirror(this.$codeContainer, {
          value: this._value,
          // init w/ markup value if any
          mode: 'javascript',
          theme: 'monokai',
          lineNumbers: true,
          tabSize: 2,
          keyMap: 'sublime'
        }); // monkey patch component in codeMirror to propagate save from keyboard

        this.codeMirror._scComponent = this; // set the size of the editor to match container

        this.codeMirror.setSize(this._editorWidth, this._editorHeight); // replace tabs with 2 spaces

        this.codeMirror.setOption('extraKeys', {
          Tab: function Tab(cm) {
            var spaces = '';

            for (var i = 0; i < cm.getOption('indentUnit'); i++) {
              spaces += ' ';
            }

            cm.replaceSelection(spaces);
          }
        }); // track if document is clean

        this.codeMirror.on('change', function () {
          if (!_this3.codeMirror.getDoc().isClean()) {
            _this3.$container.classList.add('dirty');
          }
        });
      }
    }, {
      key: "cleanDoc",
      value: function cleanDoc() {
        this.codeMirror.getDoc().markClean();
        this.$container.classList.remove('dirty');
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          height: {
            type: Number
          },
          width: {
            type: Number
          },
          fontSize: {
            type: Number,
            attribute: 'font-size'
          },
          value: {
            type: String
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        // this is very ugly
        // @todo - find a better solution to impor code mirror's css...
        return r$1(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n      }\n\n      :host > div {\n        box-sizing: border-box;\n        border: 1px solid ", ";\n        border-left: 2px solid ", ";\n        position: relative;\n        font-size: ", ";\n      }\n\n      :host > div.dirty {\n        border-left: 2px solid ", ";\n      }\n\n      /* highlight focused editor */\n      .CodeMirror { opacity: 0.9; }\n      .CodeMirror.CodeMirror-focused { opacity: 1; }\n\n      ", "\n      ", "\n      ", "\n\n      sc-button {\n        position: absolute;\n        right: 2px;\n        bottom: 2px;\n        z-index: 1;\n      }\n    "])), theme['--color-primary-2'], theme['--color-primary-2'], fontSize, theme['--color-secondary-3'], cmStyles, monokaiTheme, addonDialog);
      }
    }]);

    return ScEditor;
  }(s$4);

  customElements.define('sc-editor', ScEditor);

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var directives = new WeakMap();
  /**
   * Brands a function as a directive factory function so that lit-html will call
   * the function during template rendering, rather than passing as a value.
   *
   * A _directive_ is a function that takes a Part as an argument. It has the
   * signature: `(part: Part) => void`.
   *
   * A directive _factory_ is a function that takes arguments for data and
   * configuration and returns a directive. Users of directive usually refer to
   * the directive factory as the directive. For example, "The repeat directive".
   *
   * Usually a template author will invoke a directive factory in their template
   * with relevant arguments, which will then return a directive function.
   *
   * Here's an example of using the `repeat()` directive factory that takes an
   * array and a function to render an item:
   *
   * ```js
   * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
   * ```
   *
   * When `repeat` is invoked, it returns a directive function that closes over
   * `items` and the template function. When the outer template is rendered, the
   * return directive function is called with the Part for the expression.
   * `repeat` then performs it's custom logic to render multiple items.
   *
   * @param f The directive factory function. Must be a function that returns a
   * function of the signature `(part: Part) => void`. The returned function will
   * be called with the part object.
   *
   * @example
   *
   * import {directive, html} from 'lit-html';
   *
   * const immutable = directive((v) => (part) => {
   *   if (part.value !== v) {
   *     part.setValue(v)
   *   }
   * });
   */

  var directive = function directive(f) {
    return function () {
      var d = f.apply(void 0, arguments);
      directives.set(d, true);
      return d;
    };
  };
  var isDirective = function isDirective(o) {
    return typeof o === 'function' && directives.has(o);
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * True if the custom elements polyfill is in use.
   */
  var isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
  /**
   * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
   * `container`.
   */

  var removeNodes = function removeNodes(container, start) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    while (start !== end) {
      var n = start.nextSibling;
      container.removeChild(start);
      start = n;
    }
  };

  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  var noChange = {};
  /**
   * A sentinel value that signals a NodePart to fully clear its content.
   */

  var nothing = {};

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  var marker = "{{lit-".concat(String(Math.random()).slice(2), "}}");
  /**
   * An expression marker used text-positions, multi-binding attributes, and
   * attributes with markup-like text values.
   */

  var nodeMarker = "<!--".concat(marker, "-->");
  /**
   * Suffix appended to all bound attribute names.
   */

  var boundAttributeSuffix = '$lit$';

  var isTemplatePartActive = function isTemplatePartActive(part) {
    return part.index !== -1;
  }; // Allows `document.createComment('')` to be renamed for a
  // small manual size-savings.

  var createMarker = function createMarker() {
    return document.createComment('');
  };
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#elements-attributes
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-characters
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
   * space character except " ".
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */

  var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */

  var TemplateInstance = /*#__PURE__*/function () {
    function TemplateInstance(template, processor, options) {
      _classCallCheck(this, TemplateInstance);

      this.__parts = [];
      this.template = template;
      this.processor = processor;
      this.options = options;
    }

    _createClass(TemplateInstance, [{
      key: "update",
      value: function update(values) {
        var i = 0;

        var _iterator = _createForOfIteratorHelper(this.__parts),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var part = _step.value;

            if (part !== undefined) {
              part.setValue(values[i]);
            }

            i++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(this.__parts),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _part = _step2.value;

            if (_part !== undefined) {
              _part.commit();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_clone",
      value: function _clone() {
        // There are a number of steps in the lifecycle of a template instance's
        // DOM fragment:
        //  1. Clone - create the instance fragment
        //  2. Adopt - adopt into the main document
        //  3. Process - find part markers and create parts
        //  4. Upgrade - upgrade custom elements
        //  5. Update - set node, attribute, property, etc., values
        //  6. Connect - connect to the document. Optional and outside of this
        //     method.
        //
        // We have a few constraints on the ordering of these steps:
        //  * We need to upgrade before updating, so that property values will pass
        //    through any property setters.
        //  * We would like to process before upgrading so that we're sure that the
        //    cloned fragment is inert and not disturbed by self-modifying DOM.
        //  * We want custom elements to upgrade even in disconnected fragments.
        //
        // Given these constraints, with full custom elements support we would
        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
        //
        // But Safari does not implement CustomElementRegistry#upgrade, so we
        // can not implement that order and still have upgrade-before-update and
        // upgrade disconnected fragments. So we instead sacrifice the
        // process-before-upgrade constraint, since in Custom Elements v1 elements
        // must not modify their light DOM in the constructor. We still have issues
        // when co-existing with CEv0 elements like Polymer 1, and with polyfills
        // that don't strictly adhere to the no-modification rule because shadow
        // DOM, which may be created in the constructor, is emulated by being placed
        // in the light DOM.
        //
        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
        // in one step.
        //
        // The Custom Elements v1 polyfill supports upgrade(), so the order when
        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
        // Connect.
        var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
        var stack = [];
        var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

        var walker = document.createTreeWalker(fragment, 133
        /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
        , null, false);
        var partIndex = 0;
        var nodeIndex = 0;
        var part;
        var node = walker.nextNode(); // Loop through all the nodes and parts of a template

        while (partIndex < parts.length) {
          part = parts[partIndex];

          if (!isTemplatePartActive(part)) {
            this.__parts.push(undefined);

            partIndex++;
            continue;
          } // Progress the tree walker until we find our next part's node.
          // Note that multiple parts may share the same node (attribute parts
          // on a single element), so this loop may not run at all.


          while (nodeIndex < part.index) {
            nodeIndex++;

            if (node.nodeName === 'TEMPLATE') {
              stack.push(node);
              walker.currentNode = node.content;
            }

            if ((node = walker.nextNode()) === null) {
              // We've exhausted the content inside a nested template element.
              // Because we still have parts (the outer for-loop), we know:
              // - There is a template in the stack
              // - The walker will find a nextNode outside the template
              walker.currentNode = stack.pop();
              node = walker.nextNode();
            }
          } // We've arrived at our part's node.


          if (part.type === 'node') {
            var _part2 = this.processor.handleTextExpression(this.options);

            _part2.insertAfterNode(node.previousSibling);

            this.__parts.push(_part2);
          } else {
            var _this$__parts;

            (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));
          }

          partIndex++;
        }

        if (isCEPolyfill) {
          document.adoptNode(fragment);
          customElements.upgrade(fragment);
        }

        return fragment;
      }
    }]);

    return TemplateInstance;
  }();

  /**
   * Our TrustedTypePolicy for HTML which is declared using the html template
   * tag function.
   *
   * That HTML is a developer-authored constant, and is parsed with innerHTML
   * before any untrusted expressions have been mixed in. Therefor it is
   * considered safe by construction.
   */

  var policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {
    createHTML: function createHTML(s) {
      return s;
    }
  });
  var commentMarker = " ".concat(marker, " ");
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */

  var TemplateResult = /*#__PURE__*/function () {
    function TemplateResult(strings, values, type, processor) {
      _classCallCheck(this, TemplateResult);

      this.strings = strings;
      this.values = values;
      this.type = type;
      this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a `<template>` element.
     */


    _createClass(TemplateResult, [{
      key: "getHTML",
      value: function getHTML() {
        var l = this.strings.length - 1;
        var html = '';
        var isCommentBinding = false;

        for (var i = 0; i < l; i++) {
          var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
          // into the template source before it's parsed by the browser's HTML
          // parser. The marker type is based on whether the expression is in an
          // attribute, text, or comment position.
          //   * For node-position bindings we insert a comment with the marker
          //     sentinel as its text content, like <!--{{lit-guid}}-->.
          //   * For attribute bindings we insert just the marker sentinel for the
          //     first binding, so that we support unquoted attribute bindings.
          //     Subsequent bindings can use a comment marker because multi-binding
          //     attributes must be quoted.
          //   * For comment bindings we insert just the marker sentinel so we don't
          //     close the comment.
          //
          // The following code scans the template source, but is *not* an HTML
          // parser. We don't need to track the tree structure of the HTML, only
          // whether a binding is inside a comment, and if not, if it appears to be
          // the first binding in an attribute.

          var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
          // comment close. Because <-- can appear in an attribute value there can
          // be false positives.

          isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
          // expression. This can match "name=value" like structures in text,
          // comments, and attribute values, so there can be false-positives.

          var attributeMatch = lastAttributeNameRegex.exec(s);

          if (attributeMatch === null) {
            // We're only in this branch if we don't have a attribute-like
            // preceding sequence. For comments, this guards against unusual
            // attribute values like <div foo="<!--${'bar'}">. Cases like
            // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
            // below.
            html += s + (isCommentBinding ? commentMarker : nodeMarker);
          } else {
            // For attributes we use just a marker sentinel, and also append a
            // $lit$ suffix to the name to opt-out of attribute-specific parsing
            // that IE and Edge do for style and certain SVG attributes.
            html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
          }
        }

        html += this.strings[l];
        return html;
      }
    }, {
      key: "getTemplateElement",
      value: function getTemplateElement() {
        var template = document.createElement('template');
        var value = this.getHTML();

        if (policy !== undefined) {
          // this is secure because `this.strings` is a TemplateStringsArray.
          // TODO: validate this when
          // https://github.com/tc39/proposal-array-is-template-object is
          // implemented.
          value = policy.createHTML(value);
        }

        template.innerHTML = value;
        return template;
      }
    }]);

    return TemplateResult;
  }();

  var isPrimitive = function isPrimitive(value) {
    return value === null || !(typeof value === 'object' || typeof value === 'function');
  };
  var isIterable = function isIterable(value) {
    return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!(value && value[Symbol.iterator]);
  };
  /**
   * Writes attribute values to the DOM for a group of AttributeParts bound to a
   * single attribute. The value is only set once even if there are multiple parts
   * for an attribute.
   */

  var AttributeCommitter = /*#__PURE__*/function () {
    function AttributeCommitter(element, name, strings) {
      _classCallCheck(this, AttributeCommitter);

      this.dirty = true;
      this.element = element;
      this.name = name;
      this.strings = strings;
      this.parts = [];

      for (var i = 0; i < strings.length - 1; i++) {
        this.parts[i] = this._createPart();
      }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */


    _createClass(AttributeCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new AttributePart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        var strings = this.strings;
        var l = strings.length - 1;
        var parts = this.parts; // If we're assigning an attribute via syntax like:
        //    attr="${foo}"  or  attr=${foo}
        // but not
        //    attr="${foo} ${bar}" or attr="${foo} baz"
        // then we don't want to coerce the attribute value into one long
        // string. Instead we want to just return the value itself directly,
        // so that sanitizeDOMValue can get the actual value rather than
        // String(value)
        // The exception is if v is an array, in which case we do want to smash
        // it together into a string without calling String() on the array.
        //
        // This also allows trusted values (when using TrustedTypes) being
        // assigned to DOM sinks without being stringified in the process.

        if (l === 1 && strings[0] === '' && strings[1] === '') {
          var v = parts[0].value;

          if (typeof v === 'symbol') {
            return String(v);
          }

          if (typeof v === 'string' || !isIterable(v)) {
            return v;
          }
        }

        var text = '';

        for (var i = 0; i < l; i++) {
          text += strings[i];
          var part = parts[i];

          if (part !== undefined) {
            var _v = part.value;

            if (isPrimitive(_v) || !isIterable(_v)) {
              text += typeof _v === 'string' ? _v : String(_v);
            } else {
              var _iterator = _createForOfIteratorHelper(_v),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var t = _step.value;
                  text += typeof t === 'string' ? t : String(t);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          }
        }

        text += strings[l];
        return text;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false;
          this.element.setAttribute(this.name, this._getValue());
        }
      }
    }]);

    return AttributeCommitter;
  }();
  /**
   * A Part that controls all or part of an attribute value.
   */

  var AttributePart = /*#__PURE__*/function () {
    function AttributePart(committer) {
      _classCallCheck(this, AttributePart);

      this.value = undefined;
      this.committer = committer;
    }

    _createClass(AttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
          this.value = value; // If the value is a not a directive, dirty the committer so that it'll
          // call setAttribute. If the value is a directive, it'll dirty the
          // committer if it calls setValue().

          if (!isDirective(value)) {
            this.committer.dirty = true;
          }
        }
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.value)) {
          var directive = this.value;
          this.value = noChange;
          directive(this);
        }

        if (this.value === noChange) {
          return;
        }

        this.committer.commit();
      }
    }]);

    return AttributePart;
  }();
  /**
   * A Part that controls a location within a Node tree. Like a Range, NodePart
   * has start and end locations and can set and update the Nodes between those
   * locations.
   *
   * NodeParts support several value types: primitives, Nodes, TemplateResults,
   * as well as arrays and iterables of those types.
   */

  var NodePart = /*#__PURE__*/function () {
    function NodePart(options) {
      _classCallCheck(this, NodePart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.options = options;
    }
    /**
     * Appends this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */


    _createClass(NodePart, [{
      key: "appendInto",
      value: function appendInto(container) {
        this.startNode = container.appendChild(createMarker());
        this.endNode = container.appendChild(createMarker());
      }
      /**
       * Inserts this part after the `ref` node (between `ref` and `ref`'s next
       * sibling). Both `ref` and its next sibling must be static, unchanging nodes
       * such as those that appear in a literal section of a template.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterNode",
      value: function insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
      }
      /**
       * Appends this part into a parent part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "appendIntoPart",
      value: function appendIntoPart(part) {
        part.__insert(this.startNode = createMarker());

        part.__insert(this.endNode = createMarker());
      }
      /**
       * Inserts this part after the `ref` part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterPart",
      value: function insertAfterPart(ref) {
        ref.__insert(this.startNode = createMarker());

        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.startNode.parentNode === null) {
          return;
        }

        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        var value = this.__pendingValue;

        if (value === noChange) {
          return;
        }

        if (isPrimitive(value)) {
          if (value !== this.value) {
            this.__commitText(value);
          }
        } else if (value instanceof TemplateResult) {
          this.__commitTemplateResult(value);
        } else if (value instanceof Node) {
          this.__commitNode(value);
        } else if (isIterable(value)) {
          this.__commitIterable(value);
        } else if (value === nothing) {
          this.value = nothing;
          this.clear();
        } else {
          // Fallback, will render the string representation
          this.__commitText(value);
        }
      }
    }, {
      key: "__insert",
      value: function __insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
      }
    }, {
      key: "__commitNode",
      value: function __commitNode(value) {
        if (this.value === value) {
          return;
        }

        this.clear();

        this.__insert(value);

        this.value = value;
      }
    }, {
      key: "__commitText",
      value: function __commitText(value) {
        var node = this.startNode.nextSibling;
        value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
        // it can't be implicitly converted - i.e. it's a symbol.

        var valueAsString = typeof value === 'string' ? value : String(value);

        if (node === this.endNode.previousSibling && node.nodeType === 3
        /* Node.TEXT_NODE */
        ) {
          // If we only have a single text node between the markers, we can just
          // set its value, rather than replacing it.
          // TODO(justinfagnani): Can we just check if this.value is primitive?
          node.data = valueAsString;
        } else {
          this.__commitNode(document.createTextNode(valueAsString));
        }

        this.value = value;
      }
    }, {
      key: "__commitTemplateResult",
      value: function __commitTemplateResult(value) {
        var template = this.options.templateFactory(value);

        if (this.value instanceof TemplateInstance && this.value.template === template) {
          this.value.update(value.values);
        } else {
          // Make sure we propagate the template processor from the TemplateResult
          // so that we use its syntax extension, etc. The template factory comes
          // from the render function options so that it can control template
          // caching and preprocessing.
          var instance = new TemplateInstance(template, value.processor, this.options);

          var fragment = instance._clone();

          instance.update(value.values);

          this.__commitNode(fragment);

          this.value = instance;
        }
      }
    }, {
      key: "__commitIterable",
      value: function __commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
          this.value = [];
          this.clear();
        } // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render


        var itemParts = this.value;
        var partIndex = 0;
        var itemPart;

        var _iterator2 = _createForOfIteratorHelper(value),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            // Try to reuse an existing part
            itemPart = itemParts[partIndex]; // If no existing part, create a new one

            if (itemPart === undefined) {
              itemPart = new NodePart(this.options);
              itemParts.push(itemPart);

              if (partIndex === 0) {
                itemPart.appendIntoPart(this);
              } else {
                itemPart.insertAfterPart(itemParts[partIndex - 1]);
              }
            }

            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        if (partIndex < itemParts.length) {
          // Truncate the parts array so _value reflects the current state
          itemParts.length = partIndex;
          this.clear(itemPart && itemPart.endNode);
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
      }
    }]);

    return NodePart;
  }();
  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */

  var BooleanAttributePart = /*#__PURE__*/function () {
    function BooleanAttributePart(element, name, strings) {
      _classCallCheck(this, BooleanAttributePart);

      this.value = undefined;
      this.__pendingValue = undefined;

      if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
        throw new Error('Boolean attributes can only contain a single expression');
      }

      this.element = element;
      this.name = name;
      this.strings = strings;
    }

    _createClass(BooleanAttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var value = !!this.__pendingValue;

        if (this.value !== value) {
          if (value) {
            this.element.setAttribute(this.name, '');
          } else {
            this.element.removeAttribute(this.name);
          }

          this.value = value;
        }

        this.__pendingValue = noChange;
      }
    }]);

    return BooleanAttributePart;
  }();
  /**
   * Sets attribute values for PropertyParts, so that the value is only set once
   * even if there are multiple parts for a property.
   *
   * If an expression controls the whole property value, then the value is simply
   * assigned to the property under control. If there are string literals or
   * multiple expressions, then the strings are expressions are interpolated into
   * a string first.
   */

  var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {
    _inherits(PropertyCommitter, _AttributeCommitter);

    var _super = _createSuper(PropertyCommitter);

    function PropertyCommitter(element, name, strings) {
      var _this;

      _classCallCheck(this, PropertyCommitter);

      _this = _super.call(this, element, name, strings);
      _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
      return _this;
    }

    _createClass(PropertyCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new PropertyPart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        if (this.single) {
          return this.parts[0].value;
        }

        return _get(_getPrototypeOf(PropertyCommitter.prototype), "_getValue", this).call(this);
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.element[this.name] = this._getValue();
        }
      }
    }]);

    return PropertyCommitter;
  }(AttributeCommitter);
  var PropertyPart = /*#__PURE__*/function (_AttributePart) {
    _inherits(PropertyPart, _AttributePart);

    var _super2 = _createSuper(PropertyPart);

    function PropertyPart() {
      _classCallCheck(this, PropertyPart);

      return _super2.apply(this, arguments);
    }

    return _createClass(PropertyPart);
  }(AttributePart); // Detect event listener options support. If the `capture` property is read
  // from the options object, then options are supported. If not, then the third
  // argument to add/removeEventListener is interpreted as the boolean capture
  // value so we should only pass the `capture` property.

  var eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
  // blocks right into the body of a module

  (function () {
    try {
      var options = {
        get capture() {
          eventOptionsSupported = true;
          return false;
        }

      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.removeEventListener('test', options, options);
    } catch (_e) {// event options not supported
    }
  })();

  var EventPart = /*#__PURE__*/function () {
    function EventPart(element, eventName, eventContext) {
      var _this2 = this;

      _classCallCheck(this, EventPart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.element = element;
      this.eventName = eventName;
      this.eventContext = eventContext;

      this.__boundHandleEvent = function (e) {
        return _this2.handleEvent(e);
      };
    }

    _createClass(EventPart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var newListener = this.__pendingValue;
        var oldListener = this.value;
        var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
        var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

        if (shouldRemoveListener) {
          this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        if (shouldAddListener) {
          this.__options = getOptions(newListener);
          this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        this.value = newListener;
        this.__pendingValue = noChange;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (typeof this.value === 'function') {
          this.value.call(this.eventContext || this.element, event);
        } else {
          this.value.handleEvent(event);
        }
      }
    }]);

    return EventPart;
  }(); // We copy options because of the inconsistent behavior of browsers when reading
  // the third argument of add/removeEventListener. IE11 doesn't support options
  // at all. Chrome 41 only reads `capture` if the argument is an object.

  var getOptions = function getOptions(o) {
    return o && (eventOptionsSupported ? {
      capture: o.capture,
      passive: o.passive,
      once: o.once
    } : o.capture);
  };

  /**
   * Creates Parts when a template is instantiated.
   */

  var DefaultTemplateProcessor = /*#__PURE__*/function () {
    function DefaultTemplateProcessor() {
      _classCallCheck(this, DefaultTemplateProcessor);
    }

    _createClass(DefaultTemplateProcessor, [{
      key: "handleAttributeExpressions",
      value:
      /**
       * Create parts for an attribute-position binding, given the event, attribute
       * name, and string literals.
       *
       * @param element The element containing the binding
       * @param name  The attribute name
       * @param strings The string literals. There are always at least two strings,
       *   event for fully-controlled bindings with a single expression.
       */
      function handleAttributeExpressions(element, name, strings, options) {
        var prefix = name[0];

        if (prefix === '.') {
          var _committer = new PropertyCommitter(element, name.slice(1), strings);

          return _committer.parts;
        }

        if (prefix === '@') {
          return [new EventPart(element, name.slice(1), options.eventContext)];
        }

        if (prefix === '?') {
          return [new BooleanAttributePart(element, name.slice(1), strings)];
        }

        var committer = new AttributeCommitter(element, name, strings);
        return committer.parts;
      }
      /**
       * Create parts for a text-position binding.
       * @param templateFactory
       */

    }, {
      key: "handleTextExpression",
      value: function handleTextExpression(options) {
        return new NodePart(options);
      }
    }]);

    return DefaultTemplateProcessor;
  }();
  var defaultTemplateProcessor = new DefaultTemplateProcessor();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // This line will be used in regexes to search for lit-html usage.
  // TODO(justinfagnani): inject version number at build time

  if (typeof window !== 'undefined') {
    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
  }

  var ClassList = /*#__PURE__*/function () {
    function ClassList(element) {
      _classCallCheck(this, ClassList);

      this.classes = new Set();
      this.changed = false;
      this.element = element;
      var classList = (element.getAttribute('class') || '').split(/\s+/);

      var _iterator = _createForOfIteratorHelper(classList),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var cls = _step.value;
          this.classes.add(cls);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    _createClass(ClassList, [{
      key: "add",
      value: function add(cls) {
        this.classes.add(cls);
        this.changed = true;
      }
    }, {
      key: "remove",
      value: function remove(cls) {
        this.classes.delete(cls);
        this.changed = true;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.changed) {
          var classString = '';
          this.classes.forEach(function (cls) {
            return classString += cls + ' ';
          });
          this.element.setAttribute('class', classString);
        }
      }
    }]);

    return ClassList;
  }();
  /**
   * Stores the ClassInfo object applied to a given AttributePart.
   * Used to unset existing values when a new ClassInfo object is applied.
   */


  var previousClassesCache = new WeakMap();
  /**
   * A directive that applies CSS classes. This must be used in the `class`
   * attribute and must be the only part used in the attribute. It takes each
   * property in the `classInfo` argument and adds the property name to the
   * element's `class` if the property value is truthy; if the property value is
   * falsey, the property name is removed from the element's `class`. For example
   * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
   * @param classInfo {ClassInfo}
   */

  var classMap = directive(function (classInfo) {
    return function (part) {
      if (!(part instanceof AttributePart) || part instanceof PropertyPart || part.committer.name !== 'class' || part.committer.parts.length > 1) {
        throw new Error('The `classMap` directive must be used in the `class` attribute ' + 'and must be the only part in the attribute.');
      }

      var committer = part.committer;
      var element = committer.element;
      var previousClasses = previousClassesCache.get(part);

      if (previousClasses === undefined) {
        // Write static classes once
        // Use setAttribute() because className isn't a string on SVG elements
        element.setAttribute('class', committer.strings.join(' '));
        previousClassesCache.set(part, previousClasses = new Set());
      }

      var classList = element.classList || new ClassList(element); // Remove old classes that no longer apply
      // We use forEach() instead of for-of so that re don't require down-level
      // iteration.

      previousClasses.forEach(function (name) {
        if (!(name in classInfo)) {
          classList.remove(name);
          previousClasses.delete(name);
        }
      }); // Add or remove classes based on their classMap value

      for (var name in classInfo) {
        var value = classInfo[name];

        if (value != previousClasses.has(name)) {
          // We explicitly want a loose truthy check of `value` because it seems
          // more convenient that '' and 0 are skipped.
          if (value) {
            classList.add(name);
            previousClasses.add(name);
          } else {
            classList.remove(name);
            previousClasses.delete(name);
          }
        }
      }

      if (typeof classList.commit === 'function') {
        classList.commit();
      }
    };
  });

  var _templateObject$b, _templateObject2$8;

  var ScText = /*#__PURE__*/function (_ScElement) {
    _inherits(ScText, _ScElement);

    var _super = _createSuper(ScText);

    function ScText() {
      var _this;

      _classCallCheck(this, ScText);

      _this = _super.call(this);
      _this.width = 200;
      _this.height = 30;
      _this.value = '';
      _this.readonly = false;
      _this._dirty = false;
      return _this;
    }

    _createClass(ScText, [{
      key: "render",
      value: function render() {
        var classes = {
          dirty: this._dirty
        };
        return $$1(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral(["\n      <textarea\n        class=", "\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        .value=\"", "\"\n        ?readonly=", "\n        @blur=", "\n        @keydown=", "\n        @keyup=", "\n        @contextmenu=\"", "\"\n      ></textarea>\n    "])), classMap(classes), this.width, this.height, this.value, this.readonly, this.updateValue, this.onKeyDown, this.onKeyUp, this._preventContextMenu);
      }
    }, {
      key: "focus",
      value: function focus() {
        var $textarea = this.shadowRoot.querySelector('textarea');

        if ($textarea) {
          $textarea.focus();
        }
      }
    }, {
      key: "onKeyDown",
      value: function onKeyDown(e) {
        // manually do comment because opens Help menu otherwise...
        if (e.metaKey && e.key === 's') {
          e.preventDefault();
          this.updateValue(e, true);
        }
      }
    }, {
      key: "onKeyUp",
      value: function onKeyUp(e) {
        if (e.target.value !== this.value && this._dirty === false) {
          this._dirty = true;
          this.requestUpdate();
        } else if (e.target.value === this.value && this._dirty === true) {
          this._dirty = false;
          this.requestUpdate();
        }
      }
    }, {
      key: "updateValue",
      value: function updateValue(e) {
        var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        e.preventDefault();
        e.stopPropagation();

        if (this._dirty || forceUpdate) {
          this.value = e.target.value;
          this._dirty = false;
          var event = new CustomEvent('change', {
            bubbles: true,
            composed: true,
            detail: {
              value: this.value
            }
          });
          this.dispatchEvent(event);
          this.requestUpdate();
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          value: {
            type: String
          },
          readonly: {
            type: Boolean,
            reflect: true
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        vertical-align: top;\n        font-size: 0;\n      }\n\n      textarea {\n        vertical-align: top;\n        box-sizing: border-box;\n        background-color: ", ";\n        border: 1px dotted ", ";\n        color: white;\n        font-family: ", ";\n        padding: 6px 2px 6px 6px;\n        border-radius: 2px;\n        font-size: ", ";\n        line-height: ", "px;\n        resize: none;\n      }\n\n      textarea:focus {\n        outline: none;\n        border: 1px solid ", ";\n      }\n\n      textarea.dirty {\n        border: 1px solid ", ";\n      }\n\n      textarea[readonly], textarea[readonly]:focus {\n        background-color: ", ";\n        border: 1px solid ", ";\n      }\n    "])), theme['--color-primary-2'], theme['--color-primary-4'], fontFamily, fontSize, 16, theme['--color-primary-4'], theme['--color-secondary-3'], theme['--color-primary-3'], theme['--color-primary-3']);
      }
    }]);

    return ScText;
  }(ScElement);

  customElements.define('sc-text', ScText);

  var _templateObject$c, _templateObject2$9, _templateObject3$4;

  var ScBang = /*#__PURE__*/function (_ScElement) {
    _inherits(ScBang, _ScElement);

    var _super = _createSuper(ScBang);

    function ScBang() {
      var _this;

      _classCallCheck(this, ScBang);

      _this = _super.call(this);
      _this.width = 30;
      _this.height = 30;
      _this.value = true, _this._active = false;
      _this._timeoutId = null;
      return _this;
    }

    _createClass(ScBang, [{
      key: "width",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "height",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "active",
      set: function set(value) {
        var _this2 = this;

        clearTimeout(this._timeoutId);

        if (value === true) {
          this._active = true;
          this.requestUpdate();
          this._timeoutId = setTimeout(function () {
            _this2._active = false;

            _this2.requestUpdate();
          }, 50);
        } else {
          this._active = false;
          this.requestUpdate();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var size = this._size - 2;
        return $$1(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral(["\n      <svg\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        viewbox=\"0 0 100 100\"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      >\n        <circle\n          cx=\"50\"\n          cy=\"50\"\n          r=\"34\"\n          stroke-width=\"8\"\n          stroke=\"", "\"\n          fill=\"", "\"\n        ></circle>\n        ", "\n      </svg>\n    "])), this._size, this._size, this._triggerEvent, this._triggerEvent, this._preventContextMenu, theme['--color-primary-3'], theme['--color-primary-1'], this._active ? y(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteral(["\n            <circle\n              cx=\"50\"\n              cy=\"50\"\n              r=\"20\"\n              fill=\"", "\"\n            ></circle>\n          "])), theme['--color-primary-4']) : w$1);
      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent(e) {
        e.preventDefault();
        var inputEvent = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.active = true;
        this.dispatchEvent(inputEvent);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          active: {
            type: Boolean
          },
          value: {}
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        background-color: ", ";\n        font-size: 0 !important;\n      }\n\n      svg {\n        box-sizing: border-box;\n        border: 1px solid ", ";\n      }\n    "])), theme['--color-primary-1'], theme['--color-primary-2']);
      }
    }]);

    return ScBang;
  }(ScElement);

  customElements.define('sc-bang', ScBang);

  var _templateObject$d, _templateObject2$a, _templateObject3$5;

  var ScSignal = /*#__PURE__*/function (_ScElement) {
    _inherits(ScSignal, _ScElement);

    var _super = _createSuper(ScSignal);

    function ScSignal() {
      var _this;

      _classCallCheck(this, ScSignal);

      _this = _super.call(this);
      _this.width = 300;
      _this.height = 150;
      _this.duration = 1;
      _this.colors = ['#4682B4', '#ffa500', '#00e600', '#ff0000', '#800080', '#224153'];
      _this.displayMinMax = false;
      _this.min = -1;
      _this.max = 1;
      _this._frameStack = [];
      _this._pixelIndex = null;
      _this._dirty = true;
      _this._maxValue = -Infinity;
      _this._minValue = +Infinity;
      _this._renderSignal = _this._renderSignal.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(ScSignal, [{
      key: "value",
      set: function set(frame) {
        frame.data = Array.isArray(frame.data) ? frame.data : [frame.data]; // need to copy values at some point

        this._frameStack.push(frame);

        if (this.displayMinMax) {
          var changed = false;

          for (var i = 0; i < frame.data.length; i++) {
            if (frame.data[i] > this._maxValue) {
              this._maxValue = frame.data[i];
              changed = true;
            }

            if (frame.data[i] < this._minValue) {
              this._minValue = frame.data[i];
              changed = true;
            }
          }

          if (changed) {
            this.requestUpdate();
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        return $$1(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral(["\n      <div\n        @contextmenu=\"", "\"\n      >\n        <canvas\n          style=\"\n            width: ", "px;\n            height: ", "px;\n          \"\n        ></canvas>\n        ", "\n      </div>\n    "])), this._preventContextMenu, this.width, this.height, this.displayMinMax ? $$1(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteral(["\n            <span class=\"max\">", "</span>\n            <span class=\"min\">", "</span>\n            "])), this._maxValue.toFixed(3), this._minValue.toFixed(3)) : w$1);
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated() {
        this.canvas = this.shadowRoot.querySelector('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.cachedCanvas = document.createElement('canvas');
        this.cachedCtx = this.cachedCanvas.getContext('2d'); // debug cached canvas
        // this.cachedCanvas.style.position = 'absolute';
        // this.cachedCanvas.style.top = 0;
        // this.cachedCanvas.style.right = 0;
        // this.cachedCanvas.style.outline = '1px solid red';
        // document.body.appendChild(this.cachedCanvas);

        _get(_getPrototypeOf(ScSignal.prototype), "firstUpdated", this).call(this);
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        this._frameStack.length = 0;
        this._pixelIndex = null;

        _get(_getPrototypeOf(ScSignal.prototype), "connectedCallback", this).call(this);

        this.rAFId = window.requestAnimationFrame(this._renderSignal);
      }
    }, {
      key: "update",
      value: function update(changedProperties) {
        this._dirty = true;

        _get(_getPrototypeOf(ScSignal.prototype), "update", this).call(this, changedProperties);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.cancelAnimationFrame(this.rAFId);
        this._frameStack.length = 0;
        this.ctx.clearRect(0, 0, this._logicalWidth, this._logicalHeight);
        this.cachedCtx.clearRect(0, 0, this._logicalWidth, this._logicalHeight);

        _get(_getPrototypeOf(ScSignal.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "_renderSignal",
      value: function _renderSignal() {
        if (this._dirty) {
          // @todo - fix weird behavior when updating `width`
          var scale = window.devicePixelRatio;
          this._logicalWidth = this.width * scale;
          this._logicalHeight = this.height * scale;
          this.canvas.width = this._logicalWidth;
          this.canvas.height = this._logicalHeight;
          this.cachedCanvas.width = this._logicalWidth;
          this.cachedCanvas.height = this._logicalHeight; // create y scale (should be called on height, min or max change)

          var min = this.min;
          var max = this.max;
          var height = this._logicalHeight;
          var a = (0 - height) / (max - min);
          var b = height - a * min;

          this._getYPosition = function (x) {
            return a * x + b;
          };

          this._frameStack.length = 0;
          this._pixelIndex = null;
          this.ctx.clearRect(0, 0, this._logicalWidth, this._logicalHeight);
          this.cachedCtx.clearRect(0, 0, this._logicalWidth, this._logicalHeight);
          this._dirty = false;
        }

        var frameStackSize = this._frameStack.length;

        if (frameStackSize > 0) {
          var shiftCanvasPixels = 0;
          var abort = false;
          var pixelDuration = this.duration / this.width;

          if (this._pixelIndex === null) {
            this._pixelIndex = Math.floor(this._frameStack[0].time / pixelDuration);
          } // while we have some frames to display, we go through pixels and display


          while (this._frameStack.length > 0) {
            shiftCanvasPixels += 1;
            var pixelStartTime = this._pixelIndex * pixelDuration;
            var pixelStopTime = (this._pixelIndex + 1) * pixelDuration; // console.log(pixelStartTime, pixelStopTime, this._pixelIndex);

            var candidateIndex = null; // find candidates for display in current pixel

            for (var i = 0; i < this._frameStack.length; i++) {
              var frame = this._frameStack[i];
              var frameTime = frame.time; // ignore old pixel

              if (frameTime < pixelStartTime) {
                // if last frame in stack, abort and wait for new frames
                if (i + 1 === this._frameStack.length) {
                  // console.log('im there', frameTime, pixelStartTime, this._frameStack.length, i);
                  this._frameStack.length = 0;
                  abort = true;
                } // we take the last frame we find in the pixel time interval

              } else if (frameTime >= pixelStartTime && frameTime < pixelStopTime) {
                candidateIndex = i;
              }
            } // we abort before incrementing this._pixelIndex,
            // as we want to recheck the same pixel with new data later


            if (abort) {
              break;
            } // @note - there is probably room for optimizations here as
            // we store and retrieve the comlete canvas at each pixel. This could
            // probably be batched in some way.


            if (candidateIndex !== null) {
              var _frame = this._frameStack[candidateIndex]; // draw line since last frame

              if (this.lastFrame) {
                var width = this._logicalWidth;
                var _height = this._logicalHeight;
                var lastFramePixel = width - shiftCanvasPixels; // shift canvas from `shiftCanvasPixels`

                this.ctx.clearRect(0, 0, width, _height);
                this.ctx.drawImage(this.cachedCanvas, shiftCanvasPixels, 0, lastFramePixel, _height, 0, 0, lastFramePixel, _height);
                this.ctx.lineWidth = this.lineWidth;
                this.ctx.lineCap = 'round';

                for (var _i = 0; _i < _frame.data.length; _i++) {
                  this.ctx.strokeStyle = this.colors[_i]; // draw line between lastFrame (width - shiftCanvasPixels, y)
                  // and currentFrame (width, y)

                  var lastY = this._getYPosition(this.lastFrame.data[_i]);

                  var currentY = this._getYPosition(_frame.data[_i]);

                  this.ctx.beginPath();
                  this.ctx.moveTo(lastFramePixel, lastY);
                  this.ctx.lineTo(width, currentY);
                  this.ctx.stroke();
                } // save currentState into cache


                this.cachedCtx.clearRect(0, 0, width, _height);
                this.cachedCtx.drawImage(this.canvas, 0, 0, width, _height);
              }

              this.lastFrame = _frame;
              shiftCanvasPixels = 0; // remove frames from stack including rendered candidate

              this._frameStack.splice(0, candidateIndex + 1);
            }

            this._pixelIndex += 1;
          } // end while

        } // end if


        this.rAFId = window.requestAnimationFrame(this._renderSignal);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          duration: {
            type: Number
          },
          min: {
            type: Number
          },
          max: {
            type: Number,
            reflect: true
          },
          colors: {
            type: Array
          },
          lineWidth: {
            type: Number,
            reflect: true,
            attribute: 'line-width'
          },
          displayMinMax: {
            type: Boolean,
            attribute: 'display-min-max',
            reflect: true
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        background-color: white;\n        line-height: 0;\n        outline: 1px solid ", ";\n        position: relative;\n      }\n\n      canvas {\n        margin: 0;\n      }\n\n      .min, .max {\n        display: block;\n        width: 50px;\n        height: 14px;\n        line-height: 14px;\n        font-size: 10px;\n        font-family: ", ";\n        position: absolute;\n        right: 0px;\n        text-align: right;\n        padding-right: 2px;\n        color: ", ";;\n      }\n\n      .min {\n        bottom: 0px;\n      }\n\n      .max {\n        top: 0px;\n      }\n    "])), theme['--color-primary-2'], fontFamily, theme['--color-primary-0']);
      }
    }]);

    return ScSignal;
  }(ScElement);

  customElements.define('sc-signal', ScSignal);

  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */

  var i$7 = R.H,
      e$5 = function e() {
    return document.createComment("");
  },
      u$2 = function u(o, t, n) {
    var v;
    var l = o._$AA.parentNode,
        d = void 0 === t ? o._$AB : t._$AA;

    if (void 0 === n) {
      var _t = l.insertBefore(e$5(), d),
          _v = l.insertBefore(e$5(), d);

      n = new i$7(_t, _v, o, o.options);
    } else {
      var _i = n._$AB.nextSibling,
          _t2 = n._$AM,
          _r = _t2 !== o;

      if (_r) {
        var _i2;

        null === (v = n._$AQ) || void 0 === v || v.call(n, o), n._$AM = o, void 0 !== n._$AP && (_i2 = o._$AU) !== _t2._$AU && n._$AP(_i2);
      }

      if (_i !== d || _r) {
        var _o = n._$AA;

        for (; _o !== _i;) {
          var _i3 = _o.nextSibling;
          l.insertBefore(_o, d), _o = _i3;
        }
      }
    }

    return n;
  },
      c$2 = function c(o, i) {
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : o;
    return o._$AI(i, t), o;
  },
      f$b = {},
      s$5 = function s(o) {
    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : f$b;
    return o._$AH = i;
  },
      a$3 = function a(o) {
    return o._$AH;
  },
      m$2 = function m(o) {
    var i;
    null === (i = o._$AP) || void 0 === i || i.call(o, !1, !0);
    var t = o._$AA;
    var n = o._$AB.nextSibling;

    for (; t !== n;) {
      var _o2 = t.nextSibling;
      t.remove(), t = _o2;
    }
  };

  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */

  var u$3 = function u(e, s, t) {
    var r = new Map();

    for (var _l = s; _l <= t; _l++) {
      r.set(e[_l], _l);
    }

    return r;
  },
      c$3 = e$4( /*#__PURE__*/function (_t) {
    _inherits(_class, _t);

    var _super = _createSuper(_class);

    function _class(e) {
      var _this;

      _classCallCheck(this, _class);

      if (_this = _super.call(this, e), e.type !== t$3.CHILD) throw Error("repeat() can only be used in text expressions");
      return _possibleConstructorReturn(_this);
    }

    _createClass(_class, [{
      key: "dt",
      value: function dt(e, s, t) {
        var r;
        void 0 === t ? t = s : void 0 !== s && (r = s);
        var l = [],
            o = [];
        var i = 0;

        var _iterator = _createForOfIteratorHelper(e),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _s = _step.value;
            l[i] = r ? r(_s, i) : i, o[i] = t(_s, i), i++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return {
          values: o,
          keys: l
        };
      }
    }, {
      key: "render",
      value: function render(e, s, t) {
        return this.dt(e, s, t).values;
      }
    }, {
      key: "update",
      value: function update(s, _ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            t = _ref2[0],
            r = _ref2[1],
            c = _ref2[2];

        var d;

        var a = a$3(s),
            _this$dt = this.dt(t, r, c),
            p = _this$dt.values,
            v = _this$dt.keys;

        if (!Array.isArray(a)) return this.ut = v, p;
        var h = null !== (d = this.ut) && void 0 !== d ? d : this.ut = [],
            m = [];
        var y,
            x,
            j = 0,
            k = a.length - 1,
            w = 0,
            A = p.length - 1;

        for (; j <= k && w <= A;) {
          if (null === a[j]) j++;else if (null === a[k]) k--;else if (h[j] === v[w]) m[w] = c$2(a[j], p[w]), j++, w++;else if (h[k] === v[A]) m[A] = c$2(a[k], p[A]), k--, A--;else if (h[j] === v[A]) m[A] = c$2(a[j], p[A]), u$2(s, m[A + 1], a[j]), j++, A--;else if (h[k] === v[w]) m[w] = c$2(a[k], p[w]), u$2(s, a[j], a[k]), k--, w++;else if (void 0 === y && (y = u$3(v, w, A), x = u$3(h, j, k)), y.has(h[j])) {
            if (y.has(h[k])) {
              var _e = x.get(v[w]),
                  _t2 = void 0 !== _e ? a[_e] : null;

              if (null === _t2) {
                var _e2 = u$2(s, a[j]);

                c$2(_e2, p[w]), m[w] = _e2;
              } else m[w] = c$2(_t2, p[w]), u$2(s, a[j], _t2), a[_e] = null;

              w++;
            } else m$2(a[k]), k--;
          } else m$2(a[j]), j++;
        }

        for (; w <= A;) {
          var _e3 = u$2(s, m[A + 1]);

          c$2(_e3, p[w]), m[w++] = _e3;
        }

        for (; j <= k;) {
          var _e4 = a[j++];
          null !== _e4 && m$2(_e4);
        }

        return this.ut = v, s$5(s, m), b$1;
      }
    }]);

    return _class;
  }(i$6));

  var _templateObject$e, _templateObject2$b, _templateObject3$6, _templateObject4$3;

  var ScDotMap = /*#__PURE__*/function (_LitElement) {
    _inherits(ScDotMap, _LitElement);

    var _super = _createSuper(ScDotMap);

    function ScDotMap() {
      var _this;

      _classCallCheck(this, ScDotMap);

      _this = _super.call(this);
      _this.value = [];
      _this.color = theme['--color-secondary-2'];
      _this.defaultRadius = 5;
      _this.radius = null;
      _this.radiusRel = null;
      _this.opacity = 1;
      _this.maxSize = +Infinity;
      _this.xRange = [0, 1];
      _this.yRange = [0, 1];
      _this.width = 300;
      _this.height = 300;
      _this.captureEvents = false;
      _this.persistEvents = false; // can be overriden to 'none'

      _this.backgroundColor = theme['--color-primary-1'];
      _this.backgroundOpacity = 1;
      _this.backgroundImage = '';
      _this._dirty = false;
      return _this;
    }

    _createClass(ScDotMap, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        this._dirty = true;

        _get(_getPrototypeOf(ScDotMap.prototype), "connectedCallback", this).call(this);
      }
    }, {
      key: "update",
      value: function update(changedProperties) {
        if (changedProperties.has('width') || changedProperties.has('height') || changedProperties.has('xRange') || changedProperties.has('yRange')) {
          this._dirty = true;
        }

        _get(_getPrototypeOf(ScDotMap.prototype), "update", this).call(this, changedProperties);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        if (this._dirty) {
          var xDelta = Math.abs(this.xRange[1] - this.xRange[0]);
          var yDelta = Math.abs(this.yRange[1] - this.yRange[0]); // define which side is th limiting one

          var deltaRatio = xDelta / yDelta;
          var pxRatio = this.width / this.height;
          var limitingSize;
          var limitingDelta;

          if (deltaRatio > pxRatio) {
            limitingSize = this.width;
            limitingDelta = xDelta;
          } else {
            limitingSize = this.height;
            limitingDelta = yDelta;
          } // define svg size


          this.svgWidth = limitingSize / limitingDelta * xDelta;
          this.svgHeight = limitingSize / limitingDelta * yDelta; // x2px and y2px should share the same slope (a), only offset (b) should differ

          {
            var a = this.svgWidth / (this.xRange[1] - this.xRange[0]);
            var b = -(this.xRange[0] * a);

            this.x2px = function (x) {
              return a * x + b;
            };
          }
          {
            var _a = this.svgHeight / (this.yRange[1] - this.yRange[0]);

            var _b = -(this.yRange[0] * _a);

            this.y2px = function (y) {
              return _a * y + _b;
            };
          } // for radius as we don't want any offset, we just pick the slope of one of the others

          {
            var _a2 = Math.abs(this.svgHeight / (this.yRange[1] - this.yRange[0]));

            this.radius2px = function (r) {
              return _a2 * r;
            };
          }
          this._dirty = false;
        }

        var dotsRadius = this.defaultRadius;

        if (this.radius) {
          dotsRadius = this.radius;
        } else if (this.radiusRel) {
          dotsRadius = this.radius2px(this.radiusRel);
        }

        return $$1(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral(["\n      <div\n        style=\"width: ", "px; height: ", "px;\">\n        ", "\n        <div\n          style=\"\n            width: ", "px;\n            height: ", "px;\n            position: absolute;\n            left: ", "px;\n            top: ", "px;\n            background-color: ", ";\n            background-image: ", ";\n            background-size: contain;\n            background-position: 50% 50%;\n            background-repeat: no-repeat;\n            opacity: ", ";\n          \"\n        ></div>\n        <svg\n          style=\"\n            width: ", "px;\n            height: ", "px;\n            left: ", "px;\n            top: ", "px;\n          \"\n          viewBox=\"0 0 ", " ", "\"\n        >\n\n          <!-- dots -->\n          ", "\n        </svg>\n\n      </div>\n    "])), this.width, this.height, this.captureEvents ? $$1(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteral(["\n            <sc-position-surface\n              width=\"", "\"\n              height=\"", "\"\n              x-range=\"", "\"\n              y-range=\"", "\"\n              @input=\"", "\"\n              style=\"\n                left: ", "px;\n                top: ", "px;\"\n            ></sc-position-surface>\n          "])), this.svgWidth, this.svgHeight, JSON.stringify(this.xRange), JSON.stringify(this.yRange), this.updatePositions, (this.width - this.svgWidth) / 2, (this.height - this.svgHeight) / 2) : '', this.svgWidth, this.svgHeight, (this.width - this.svgWidth) / 2, (this.height - this.svgHeight) / 2, this.backgroundColor, this.backgroundImage !== '' ? "url(".concat(this.backgroundImage, ")") : 'none', this.backgroundOpacity, this.svgWidth, this.svgHeight, (this.width - this.svgWidth) / 2, (this.height - this.svgHeight) / 2, this.svgWidth, this.svgHeight, c$3(this.value, function (d) {
          return "".concat(d.x, "-").concat(d.y);
        }, function (d) {
          return y(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteral(["<circle\n              r=\"", "\"\n              fill=\"", "\"\n              cx=\"", "\"\n              cy=\"", "\"\n              style=\"pointer-event: none; fill-opacity: ", "\"\n            ></circle>"])), dotsRadius, d.color || _this2.color, _this2.x2px(d.x), _this2.y2px(d.y), _this2.opacity);
        }));
      }
    }, {
      key: "updatePositions",
      value: function updatePositions(e) {
        var _this3 = this;

        e.stopPropagation(); // ignore mouseup and touchend events

        if (this.persistEvents && e.detail.value.length === 0) {
          return;
        } // remove the pointerId from origin event


        var value = e.detail.value.map(function (pointer) {
          // keep in boundaries
          var minX = Math.min(_this3.xRange[0], _this3.xRange[1]);
          var maxX = Math.max(_this3.xRange[0], _this3.xRange[1]);
          var minY = Math.min(_this3.yRange[0], _this3.yRange[1]);
          var maxY = Math.max(_this3.yRange[0], _this3.yRange[1]);
          var x = Math.min(maxX, Math.max(minX, pointer.x));
          var y = Math.min(maxY, Math.max(minY, pointer.y));
          return {
            x,
            y
          };
        });

        if (value > this.maxSize) {
          value.splice(this.maxSize);
        }

        this.value = value;
        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.dispatchEvent(event);
        this.requestUpdate();
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          xRange: {
            type: Array,
            attribute: 'x-range'
          },
          yRange: {
            type: Array,
            attribute: 'y-range'
          },
          value: {
            type: Array,

            hasChanged(newVal, oldVal) {
              return true;
            }

          },
          maxSize: {
            type: Number,
            attribute: 'max-size'
          },
          color: {
            type: String,
            attribute: 'color'
          },
          radius: {
            // in pixels (precedence over radiusRel)
            type: Number,
            attribute: 'radius'
          },
          radiusRel: {
            // according to ranges
            type: Number,
            attribute: 'radius-rel'
          },
          opacity: {
            type: Number,
            attribute: 'opacity'
          },
          backgroundColor: {
            type: String,
            attribute: 'background-color'
          },
          backgroundOpacity: {
            type: Number,
            attribute: 'background-opacity'
          },
          backgroundImage: {
            type: String,
            attribute: 'background-image'
          },
          captureEvents: {
            type: Boolean,
            attribute: 'capture-events'
          },
          persistEvents: {
            type: Boolean,
            attribute: 'persist-events'
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteral(["\n      :host {\n        display: inline-block;\n        box-sizing: border-box;\n        line-height: 0;\n        vertical-align: top;\n      }\n\n      :host > div {\n        position: relative;\n      }\n\n      sc-position-surface {\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 1;\n      }\n\n      svg {\n        position: relative;\n      }\n    "])));
      }
    }]);

    return ScDotMap;
  }(s$4);

  customElements.define('sc-dot-map', ScDotMap);

  var _templateObject$f, _templateObject2$c;
  var AudioContext = window.AudioContext || window.webkitAudioContext;
  var audioContext = new AudioContext();
  /**
   * @todo - enable integration inside an upload system
   */

  var ScDragNDrop = /*#__PURE__*/function (_ScElement) {
    _inherits(ScDragNDrop, _ScElement);

    var _super = _createSuper(ScDragNDrop);

    function ScDragNDrop() {
      var _this;

      _classCallCheck(this, ScDragNDrop);

      _this = _super.call(this);
      _this.width = 300;
      _this.height = 200;
      _this.label = 'Drag and drop Files';
      _this.status = 'idle'; // 'drag' | 'decoding'

      _this.format = 'load';
      return _this;
    }

    _createClass(ScDragNDrop, [{
      key: "render",
      value: function render() {
        var classes = {
          'drop-zone': true,
          'drag': this.status === 'drag',
          'processing': this.status === 'processing'
        };
        return $$1(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral(["\n      <div class=\"", "\"\n        style=\"\n          width: ", "px;\n          height: ", "px;\n          line-height: ", "px;\n        \"\n        @dragover=\"", "\"\n        @dragleave=\"", "\"\n        @drop=\"", "\"\n      >", "</div>\n    "])), o$5(classes), this.width, this.height, this.height, this.onDragOver, this.onDragLeave, this.onDrop, this.status !== 'processing' ? this.label : 'Processing...');
      }
    }, {
      key: "onDragOver",
      value: function onDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        this.status = 'drag';
      }
    }, {
      key: "onDragLeave",
      value: function onDragLeave(e) {
        e.preventDefault();
        this.status = 'idle';
      }
    }, {
      key: "onDrop",
      value: function onDrop(e) {
        var _this2 = this;

        e.preventDefault();
        this.status = 'processing';

        if (this.format === 'load') {
          var files = Array.from(e.dataTransfer.files);
          var results = {};
          var counter = 0;
          files.forEach(function (file, index) {
            var type;
            var reader = new FileReader();

            if (/^audio/.test(file.type)) {
              type = 'audio';
            } else if (/json$/.test(file.type)) {
              type = 'json';
            } else if (/^image/.test(file.type)) {
              type = 'image';
            } else if (/^text/.test(file.type)) {
              type = 'text';
            } else {
              type = 'unknown';
            }

            reader.onload = /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
                var buffer, $img, changeEvent;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.t0 = type;
                        _context.next = _context.t0 === 'audio' ? 3 : _context.t0 === 'json' ? 15 : _context.t0 === 'image' ? 17 : _context.t0 === 'text' ? 21 : 23;
                        break;

                      case 3:
                        _context.prev = 3;
                        _context.next = 6;
                        return audioContext.decodeAudioData(reader.result);

                      case 6:
                        buffer = _context.sent;
                        results[file.name] = buffer;
                        _context.next = 14;
                        break;

                      case 10:
                        _context.prev = 10;
                        _context.t1 = _context["catch"](3);
                        console.log(_context.t1);
                        results[file.name] = null;

                      case 14:
                        return _context.abrupt("break", 25);

                      case 15:
                        results[file.name] = JSON.parse(reader.result);
                        return _context.abrupt("break", 25);

                      case 17:
                        $img = new Image();
                        $img.src = reader.result;
                        results[file.name] = $img;
                        return _context.abrupt("break", 25);

                      case 21:
                        results[file.name] = reader.result;
                        return _context.abrupt("break", 25);

                      case 23:
                        results[file.name] = reader.result;
                        return _context.abrupt("break", 25);

                      case 25:
                        counter += 1;

                        if (counter === files.length) {
                          _this2.value = results;
                          changeEvent = new CustomEvent('change', {
                            bubbles: true,
                            composed: true,
                            detail: {
                              value: _this2.value
                            }
                          });

                          _this2.dispatchEvent(changeEvent);

                          _this2.status = 'idle';
                        }

                      case 27:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[3, 10]]);
              }));

              return function (_x) {
                return _ref.apply(this, arguments);
              };
            }();

            switch (type) {
              case 'audio':
                reader.readAsArrayBuffer(file);
                break;

              case 'json':
                reader.readAsText(file);
                break;

              case 'image':
                reader.readAsDataURL(file);
                break;

              case 'text':
                reader.readAsText(file);
                break;

              default:
                reader.readAsText(file);
                break;
            }
          });
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          label: {
            type: String
          },
          status: {
            type: String
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2$c || (_templateObject2$c = _taggedTemplateLiteral(["\n      :host {\n        display: inline-block;\n        box-sizing: border-box;\n        user-select: none;\n        vertical-align: middle;\n      }\n\n      .drop-zone {\n        background-color: red;\n        text-align: center;\n        vertical-align: middle;\n        background-color: ", ";\n        border: 1px solid ", ";\n        box-sizing: border-box;\n        border-radius: 2px;\n        color: white;\n        font-family: ", ";\n      }\n\n      .drop-zone.drag {\n        background-color: ", ";\n      }\n\n      .drop-zone.processing {\n        background-color: ", ";\n      }\n    "])), theme['--color-primary-1'], theme['--color-primary-2'], fontFamily, theme['--color-primary-2'], theme['--color-secondary-3']);
      }
    }]);

    return ScDragNDrop;
  }(ScElement);

  customElements.define('sc-dragndrop', ScDragNDrop);

  var _templateObject$g, _templateObject2$d, _templateObject3$7;
  /**
   * Dsiplay matrix, the data should follow a row-first convention with the 0 index
   * deing displayed at the bottom of the matrix
   * ```
   * [
   *    [0, 0, 0, 1],`
   *    [0, 1, 0, 0],`
   *    // ...
   * ]
   */

  var ScMatrix = /*#__PURE__*/function (_ScElement) {
    _inherits(ScMatrix, _ScElement);

    var _super = _createSuper(ScMatrix);

    function ScMatrix() {
      var _this;

      _classCallCheck(this, ScMatrix);

      _this = _super.call(this);
      _this.width = 300;
      _this.height = 150;
      _this._value = [];
      _this._entries = [0, 1];
      _this.columns = 8;
      _this.rows = 4;
      return _this;
    }

    _createClass(ScMatrix, [{
      key: "rows",
      get: function get() {
        return this._rows;
      },
      set: function set(value) {
        this._rows = value;

        this._resizeMatrix();
      }
    }, {
      key: "columns",
      get: function get() {
        return this._columns;
      },
      set: function set(value) {
        this._columns = value;

        this._resizeMatrix();
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        this._value = value; // if we replace the internal data matrix with an external one, we want
        // to keep the matrix description consistent

        this._rows = this._value.length;
        this._columns = this._value[0].length; // `requestUpdate` because in many cases `value` might be the same instance

        this.requestUpdate();
      }
    }, {
      key: "reset",
      get: function get() {
        return undefined;
      },
      set: function set(value) {
        var _this2 = this;

        // we actually don't care of the value
        this._value.forEach(function (row) {
          for (var i = 0; i < row.length; i++) {
            row[i] = _this2._entries[0];
          }
        });

        this._emitChange();

        this.requestUpdate();
      }
    }, {
      key: "entries",
      get: function get() {
        return this._entries;
      },
      set: function set(entries) {
        var _this3 = this;

        this._entries = entries; // check existing values against new entries

        for (var y = 0; y < this._value.length; y++) {
          var row = this._value[y];

          var _loop = function _loop(x) {
            var currentValue = row[x]; // find closest entry

            if (_this3._entries.indexOf(currentValue) === -1) {
              // @note on`reduce` - by default accumulator (here `a`) is the first
              // element of the array
              var closest = _this3.entries.reduce(function (a, b) {
                return Math.abs(b - currentValue) < Math.abs(a - currentValue) ? b : a;
              });

              _this3._value[y][x] = closest;
            }
          };

          for (var x = 0; x < row.length; x++) {
            _loop(x);
          }
        }

        this._emitChange();

        this.requestUpdate();
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        var cellWidth = this.width / this.columns;
        var cellHeight = this.height / this.rows;
        var minValue = this._entries[0];
        var maxValue = this._entries[this._entries.length - 1];
        return $$1(_templateObject$g || (_templateObject$g = _taggedTemplateLiteral(["\n      <svg\n        style=\"width: ", "px; height: ", "px;\"\n        @contextmenu=\"", "\"\n      >\n        ", "\n      </svg>\n    "])), this.width, this.height, this._preventContextMenu, this.value.map(function (row, rowIndex) {
          var y$1 = cellHeight * rowIndex;
          return row.map(function (value, columnIndex) {
            var x = cellWidth * columnIndex;
            var opacity = (value - minValue) / (maxValue - minValue);
            return y(_templateObject2$d || (_templateObject2$d = _taggedTemplateLiteral(["\n              <rect\n                stroke=\"#787878\"\n                fill=\"#ffffff\"\n                fill-opacity=\"", "\"\n                width=\"", "\"\n                height=\"", "\"\n                x=\"", "\"\n                y=\"", "\"\n                data-row-index=\"", "\"\n                data-column-index=\"", "\"\n                @mousedown=\"", "\"\n              ></rect>\n            "])), opacity, cellWidth, cellHeight, x, y$1, rowIndex, columnIndex, _this4._updateCell);
          });
        }));
      }
    }, {
      key: "_resizeMatrix",
      value: function _resizeMatrix() {
        var _this5 = this;

        var value = this.value; // remove additionnal rows

        for (var y = value.length - 1; y >= this.rows; y--) {
          value.splice(y, 1);
        } // remove additionnal columns


        value.forEach(function (row) {
          for (var x = row.length - 1; x >= _this5.columns; x--) {
            row.splice(x, 1);
          }
        }); // add new rows and columns

        var currentNumRows = value.length;

        for (var _y = 0; _y < this.rows; _y++) {
          if (_y < currentNumRows) {
            // check _rows
            value.forEach(function (row) {
              for (var x = row.length; x < _this5.columns; x++) {
                row[x] = _this5._entries[0];
              }
            });
          } else {
            // new row
            var row = new Array(this.columns).fill(this._entries[0]);
            value[_y] = row;
          }
        }

        this.requestUpdate();
      }
    }, {
      key: "_updateCell",
      value: function _updateCell(e) {
        var _e$target$dataset = e.target.dataset,
            rowIndex = _e$target$dataset.rowIndex,
            columnIndex = _e$target$dataset.columnIndex;

        var currentIndex = this._entries.indexOf(this.value[rowIndex][columnIndex]); // handle situations where _entries as changed in between two interactions


        var nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % this._entries.length;
        this.value[rowIndex][columnIndex] = this._entries[nextIndex];

        this._emitChange();

        this.requestUpdate();
      }
    }, {
      key: "_emitChange",
      value: function _emitChange() {
        var event = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.value
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          columns: {
            type: Number
          },
          rows: {
            type: Number
          },
          // @note - `cellValues` is bad name..., `entries` better ?
          // @todo - updates values when updated
          entries: {
            type: Array
          },
          value: {
            type: Array
          },
          reset: {
            type: Boolean
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        user-select: none;\n        font-size: 0 !important;\n      }\n\n      svg {\n        box-sizing: border-box;\n        background-color: ", ";\n        border: 1px solid ", ";\n      }\n    "])), theme['--color-primary-1'], theme['--color-primary-2']);
      }
    }]);

    return ScMatrix;
  }(ScElement);

  customElements.define('sc-matrix', ScMatrix);

  var _templateObject$h, _templateObject2$e, _templateObject3$8;

  var ScContextMenu = /*#__PURE__*/function (_ScElement) {
    _inherits(ScContextMenu, _ScElement);

    var _super = _createSuper(ScContextMenu);

    function ScContextMenu() {
      var _this;

      _classCallCheck(this, ScContextMenu);

      _this = _super.call(this);
      _this.visible = false;
      _this.value = [];
      _this._posX = 0;
      _this._posY = 0;
      _this.hide = _this.hide.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(ScContextMenu, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        return $$1(_templateObject$h || (_templateObject$h = _taggedTemplateLiteral(["\n      <nav\n        style=\"\n          top: ", "px;\n          left: ", "px;\n        \"\n      >\n        <ul>\n        ", "\n        <p>\n      </nav>\n    "])), this._posY, this._posX, this.value.map(function (entry) {
          return $$1(_templateObject2$e || (_templateObject2$e = _taggedTemplateLiteral(["\n            <li\n              @click=\"", "\"\n            >", "</li>\n          "])), function (e) {
            return _this2.triggerEvent(entry.action);
          }, entry.label);
        }));
      }
    }, {
      key: "show",
      value: function show(e) {
        this.visible = true;
        document.addEventListener('click', this.hide);
        this._posX = e.clientX;
        this._posY = e.clientY;
        this.requestUpdate();
        this.classList.add('show');
      }
    }, {
      key: "hide",
      value: function hide() {
        this.visible = false;
        document.removeEventListener('click', this.hide);
        this.classList.remove('show'); // this.requestUpdate();
      }
    }, {
      key: "triggerEvent",
      value: function triggerEvent(action) {
        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: action
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          value: {
            type: Array
          } // [{ action, label }, ...]

        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteral(["\n      :host {\n        display: none;\n        box-sizing: border-box;\n        font-size: 0 !important;\n        height: 0;\n        width: 0;\n        position: absolute;\n      }\n\n      :host(.show) {\n        display: inline-block;\n      }\n\n      nav {\n        width: 250px;\n        display: block;\n        background-color: rgba(0, 0, 0, 0.8);\n        border-radius: 4px;\n        box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.2), 0px 0px 3px 0px rgba(255,255,255,0.8) inset;\n        position: fixed;\n      }\n\n      ul {\n        list-style-type: none;\n        padding: 12px 10px;\n      }\n\n      li {\n        font-size: ", ";\n        padding: 4px 8px;\n        color: white;\n        border-radius: 2px;\n        cursor: default;\n      }\n\n      li:hover {\n        background-color: rgb(97, 141, 201);\n      }\n\n      li:active {\n        background-color: rgb(97, 141, 201, 0.5);\n      }\n    "])), fontSize);
      }
    }]);

    return ScContextMenu;
  }(ScElement);

  customElements.define('sc-context-menu', ScContextMenu);

  var _templateObject$i, _templateObject2$f, _templateObject3$9, _templateObject4$4;

  var ScFileTree = /*#__PURE__*/function (_ScElement) {
    _inherits(ScFileTree, _ScElement);

    var _super = _createSuper(ScFileTree);

    function ScFileTree() {
      var _this;

      _classCallCheck(this, ScFileTree);

      _this = _super.call(this);
      _this.value = null;
      _this.width = 300;
      _this.height = 200;
      _this._currentActive = null;
      return _this;
    }

    _createClass(ScFileTree, [{
      key: "_renderNode",
      value: function _renderNode(node, depth) {
        var _this2 = this;

        if (!node) {
          return w$1;
        }

        var classes = {
          directory: node.type === 'directory',
          open: depth === 0
        };
        return $$1(_templateObject$i || (_templateObject$i = _taggedTemplateLiteral(["\n      <li\n        style=\"\n          text-indent: ", "px;\n        \"\n        class=\"", "\"\n        @click=\"", "\"\n      >\n        <div class=\"hover\"></div>\n        <div class=\"hover-bg\"></div><!-- must be after .hover -->\n        <div class=\"content\">\n          <span style=\"\n            text-indent: ", "px;\n          \">", "</span>\n        </div>\n      </li>\n      ", "\n    "])), depth * 20, o$5(classes), function (e) {
          return _this2._onItemClick(e, node);
        }, node.type === 'directory' ? 20 : 0, node.name, node.type === 'directory' ? $$1(_templateObject2$f || (_templateObject2$f = _taggedTemplateLiteral(["\n          <li>\n            <ul>\n              ", "\n            </ul>\n          </li>\n        "])), node.children.map(function (child) {
          return _this2._renderNode(child, depth + 1);
        })) : w$1);
      }
    }, {
      key: "render",
      value: function render() {
        return $$1(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteral(["\n      <nav style=\"\n        width: ", "px;\n        height: ", "px;\n      \">\n        <ul>\n          ", "\n        </ul>\n      </nav>\n    "])), this.width, this.height, this._renderNode(this.value, 0));
      }
    }, {
      key: "_onItemClick",
      value: function _onItemClick(e, node) {
        e.stopPropagation();

        if (node.type === 'directory') {
          e.currentTarget.classList.toggle('open');
        } else {
          if (this._currentActive) {
            this._currentActive.classList.toggle('active');
          }

          e.currentTarget.classList.toggle('active');
          this._currentActive = e.currentTarget;

          this._triggerInput(node);
        }
      }
    }, {
      key: "_triggerInput",
      value: function _triggerInput(node) {
        var event = new CustomEvent('input', {
          bubbles: true,
          composed: true,
          detail: {
            value: node
          }
        });
        this.dispatchEvent(event);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          value: {
            type: Object
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteral(["\n      :host {\n        display: inline-block;\n        box-sizing: border-box;\n        font-size: 0 !important;\n        border: 1px solid ", ";\n      }\n\n      nav {\n        /*background-color: ", ";*/\n        background-color: #ebedef;\n        color: black;\n        height: 100%;\n        width: 100%;\n        display: inline-block;\n        overflow: auto;\n      }\n\n      ul {\n        font-size: ", ";\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n\n      li {\n        cursor: default;\n        position: relative;\n        min-height: 22px;\n        vertical-align: middle;\n      }\n\n      li span {\n        height: 22px;\n        line-height: 22px;\n        display: inline-block;\n      }\n\n      li .hover, li .hover-bg {\n        position: absolute;\n        top: 0;\n        left: 0;\n        height: 22px;\n        width: 100%;\n        background-color: transparent;\n        z-index: 0;\n      }\n\n      li .content {\n        position: relative;\n        z-index: 1;\n      }\n\n      li .hover {\n        z-index: 2;\n      }\n\n      li .hover:hover + .hover-bg {\n        /*background-color: ", ";*/\n        background-color: #dbdde0;\n      }\n\n      li.active > .hover-bg, li.active .hover:hover + .hover-bg {\n        /*background-color: ", ";*/\n        background-color: #c6cbd2;\n      }\n\n      li.directory + li {\n        display: none;\n      }\n\n      li.open + li {\n        display: block;\n      }\n\n\n      /*li.open > ul {\n        display: block;\n      }*/\n\n      li.directory::before {\n        content: '';\n        display: inline-block;\n        font-size: 0;\n        background-image: url(", ");\n        background-position: 0 50%;\n        background-size: 14px;\n        background-repeat: no-repeat;\n        position: absolute;\n        width: 22px;\n        height: 22px;\n        z-index: 1;\n        /*left: -22px;*/\n      }\n\n      li.directory.open::before {\n        background-image: url(", ");\n        background-position: 20% 70%;\n      }\n    "])), theme['--color-primary-4'], theme['--color-primary-4'], fontSize, theme['--color-primary-3'], theme['--color-primary-2'], arrowRight, arrowDown);
      }
    }]);

    return ScFileTree;
  }(ScElement);

  customElements.define('sc-file-tree', ScFileTree);

  var _templateObject$j, _templateObject2$g, _templateObject3$a, _templateObject4$5, _templateObject5$2;

  var ScTransport = /*#__PURE__*/function (_ScElement) {
    _inherits(ScTransport, _ScElement);

    var _super = _createSuper(ScTransport);

    function ScTransport() {
      var _this;

      _classCallCheck(this, ScTransport);

      _this = _super.call(this);
      _this.width = 30;
      _this.height = 30;
      _this.value = true;
      _this.buttons = "";
      _this.state = undefined;
      _this.renderFunctions = {
        play: _this.renderPlay.bind(_assertThisInitialized(_this)),
        pause: _this.renderPause.bind(_assertThisInitialized(_this)),
        stop: _this.renderStop.bind(_assertThisInitialized(_this))
      };
      return _this;
    }

    _createClass(ScTransport, [{
      key: "width",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "height",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "buttons",
      set: function set(value) {
        var replace = value.replace(/[\[\]\s]/g, '');
        this._buttons = replace.split(',');
        this.requestUpdate();
      }
    }, {
      key: "renderPlay",
      value: function renderPlay(size) {
        var _this2 = this;

        return $$1(_templateObject$j || (_templateObject$j = _taggedTemplateLiteral(["\n      <svg \n        class=\"play ", "\"\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        viewbox=\"0 0 20 20\"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      >\n        <polygon class=\"play-shape\" points=\"6, 5, 15, 10, 6, 15\"></polygon>\n      </svg>\n    "])), this.state === 'play' ? 'active' : '', size, size, function (e) {
          return _this2._onChange(e, 'play');
        }, function (e) {
          return _this2._onChange(e, 'play');
        }, this._preventContextMenu);
      }
    }, {
      key: "renderPause",
      value: function renderPause(size) {
        var _this3 = this;

        return $$1(_templateObject2$g || (_templateObject2$g = _taggedTemplateLiteral(["\n      <svg \n        class=\"pause ", "\"\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        viewbox=\"0 0 20 20\"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      >\n        <rect class=\"left\" x=\"5\" y=\"5\" width=\"3\" height=\"10\"></rect>\n        <rect class=\"right\" x=\"12\" y=\"5\" width=\"3\" height=\"10\"></rect>\n      </svg>\n    "])), this.state === 'pause' ? 'active' : '', size, size, function (e) {
          return _this3._onChange(e, 'pause');
        }, function (e) {
          return _this3._onChange(e, 'stop');
        }, this._preventContextMenu);
      }
    }, {
      key: "renderStop",
      value: function renderStop(size) {
        var _this4 = this;

        return $$1(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteral(["\n      <svg \n        class=\"stop ", "\"\n        style=\"\n          width: ", "px;\n          height: ", "px;\n        \"\n        viewbox=\"0 0 20 20\"\n        @mousedown=\"", "\"\n        @touchstart=\"", "\"\n        @contextmenu=\"", "\"\n      >\n        <rect class=\"stop-shape\" x=\"6\" y=\"6\" width=\"8\" height=\"8\"></rect>\n      </svg>\n    "])), this.state === 'stop' ? 'active' : '', size, size, function (e) {
          return _this4._onChange(e, 'stop');
        }, function (e) {
          return _this4._onChange(e, 'stop');
        }, this._preventContextMenu);
      } // renderRecord(context) {
      //   const size = context._size - 2;
      //   return html`
      //     <div>
      //       <svg 
      //         style="
      //           width: ${size}px;
      //           height: ${size}px;
      //         "
      //         viewbox="0 0 20 20"
      //         @mousedown="${context._triggerEvent}"
      //         @touchstart="${context._triggerEvent}"
      //         @contextmenu="${context._preventContextMenu}"
      //       >
      //         ${context.state === 'play'
      //           ? svg`
      //               <circle 
      //                 style="fill: ${theme['--color-secondary-3']}"
      //                 class="record-shape" 
      //                 cx="10" 
      //                 cy="10" 
      //                 r="5"
      //               ></circle>
      //             `
      //           : svg`
      //               <circle 
      //                 style="fill: 
      //                 class="record-shape" 
      //                 cx="10" 
      //                 cy="10" 
      //                 r="5"
      //               ></circle>
      //             `
      //         }
      //       </svg>
      //     </div>
      //   `
      // }

    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        var size = this._size - 2;
        return $$1(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteral(["\n      ", "\n    "])), this._buttons.map(function (type) {
          return _this5.renderFunctions[type](size);
        }));
      }
    }, {
      key: "_onChange",
      value: function _onChange(e, value) {
        e.preventDefault();
        e.stopPropagation();

        if (this.state !== value) {
          this.state = value;
          var changeEvent = new CustomEvent('change', {
            bubbles: true,
            composed: true,
            detail: {
              value: this.state
            }
          });
          this.dispatchEvent(changeEvent);
          this.requestUpdate();
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          buttons: {},
          state: {
            type: String
          },
          value: {}
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        font-size: 0 !important;\n        cursor: pointer;\n      }\n\n      svg {\n        margin-right: 5px;\n        box-sizing: border-box;\n        border-radius: 2px;\n        border: 1px solid ", ";\n        background-color: ", ";\n        fill:  #ffffff;\n      }\n\n      svg.active {\n        background-color: ", ";\n      }\n\n      svg.play.active {\n        fill: ", ";\n      }\n\n      svg.pause.active {\n        fill: ", ";\n      }\n\n      svg.stop.active {\n        fill: ", ";\n      }\n    "])), theme['--color-primary-2'], theme['--color-primary-2'], theme['--color-primary-0'], theme['--color-secondary-4'], theme['--color-secondary-2'], theme['--color-secondary-3']);
      }
    }]);

    return ScTransport;
  }(ScElement);

  customElements.define('sc-transport', ScTransport);

  var _templateObject$k, _templateObject2$h;

  var ScRecord = /*#__PURE__*/function (_ScElement) {
    _inherits(ScRecord, _ScElement);

    var _super = _createSuper(ScRecord);

    function ScRecord() {
      var _this;

      _classCallCheck(this, ScRecord);

      _this = _super.call(this);
      _this.width = 30;
      _this.active = false;
      return _this;
    }

    _createClass(ScRecord, [{
      key: "width",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "height",
      get: function get() {
        return this._size;
      } // alias active for consistency and genericity with other components
      ,
      set: function set(value) {
        this._size = value;
        this.requestUpdate();
      }
    }, {
      key: "value",
      get: function get() {
        return this.active;
      },
      set: function set(active) {
        this.active = active;
      }
    }, {
      key: "render",
      value: function render() {
        var size = this._size - 2;
        return $$1(_templateObject$k || (_templateObject$k = _taggedTemplateLiteral(["\n      <div>\n        <svg\n          class=\"", "\"\n          style=\"\n            width: ", "px;\n            height: ", "px;\n          \"\n          viewbox=\"0 0 20 20\"\n          @mousedown=\"", "\"\n          @touchstart=\"", "\"\n          @contextmenu=\"", "\"\n        >\n          <circle class=\"record-shape\" cx=\"10\" cy=\"10\" r=\"5\"></circle>  \n        </svg>\n      </div>\n    "])), this.active ? 'active' : '', size, size, this._onChange, this._onChange, this._preventContextMenu);
      }
    }, {
      key: "_onChange",
      value: function _onChange(e) {
        e.preventDefault();
        e.stopPropagation();
        this.active = !this.active;
        var changeEvent = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this.active
          }
        });
        this.dispatchEvent(changeEvent);
        this.requestUpdate();
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          width: {
            type: Number
          },
          height: {
            type: Number
          },
          active: {
            type: Boolean,
            reflect: true
          },
          value: {
            type: Boolean
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return r$1(_templateObject2$h || (_templateObject2$h = _taggedTemplateLiteral(["\n      :host {\n        vertical-align: top;\n        display: inline-block;\n        box-sizing: border-box;\n        font-size: 0 !important;\n        cursor: pointer;\n      }\n\n      svg {\n        margin-right: 5px;\n        box-sizing: border-box;\n        border-radius: 2px;\n        border: 1px solid ", ";\n        background-color: ", ";\n        fill:  #ffffff;\n      }\n\n      svg.active {\n        background-color: ", ";\n        fill: ", ";\n      }\n    "])), theme['--color-primary-2'], theme['--color-primary-2'], theme['--color-primary-0'], theme['--color-secondary-3']);
      }
    }]);

    return ScRecord;
  }(ScElement);

  customElements.define('sc-record', ScRecord);

  var _templateObject$l;
  function matrix () {
    // dirty hack to make sure the element is in the DOM
    // setInterval(() => {
    //   const $matrix = document.querySelector('#test-matrix');
    //   const value = $matrix.value;
    //   for (let i = 0; i < 20; i++) {
    //     const rowIndex = Math.floor(Math.random() * value.length);
    //     const colIndex = Math.floor(Math.random() * value[rowIndex].length);
    //     const cellValue = $matrix.entries[Math.floor(Math.random() * $matrix.entries.length)];
    //     value[rowIndex][colIndex] = cellValue;
    //     $matrix.value = value;
    //   }
    // }, 50);
    return $(_templateObject$l || (_templateObject$l = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-matrix.js';\n\n", "\n    </code></pre>\n\n    <sc-matrix\n      id=\"test-matrix\"\n      @change=\"", "\"\n    >\n    </sc-matrix>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text\n        id=\"matrix-change\"\n        width=\"400\"\n        height=\"150\"\n        readonly\n      ></sc-text>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"600\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[rows=4]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        max=\"10\"\n        value=\"4\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[columns=8]\"></sc-text>\n      <sc-number\n        min=\"4\"\n        max=\"16\"\n        value=\"8\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[entries=[0, 1]]\"></sc-text>\n      <sc-text\n        value=\"[0, 1]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[reset]\"></sc-text>\n      <sc-bang\n        value=\"[0, 1]\"\n        @input=\"", "\"\n      ></sc-bang>\n    </p>\n  "])), "<sc-matrix></sc-matrix>", function (e) {
      var $change = document.querySelector('#matrix-change');
      $change.value = e.detail.value.map(function (row) {
        return row.join(', ');
      }).join('\n');
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      $component.rows = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      $component.columns = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      console.log(e.detail.value);
      $component.entries = JSON.parse(e.detail.value);
    }, function (e) {
      var $component = document.querySelector('#test-matrix');
      $component.reset = true;
    });
  }

  var _templateObject$m;
  function dragndrop () {
    return $(_templateObject$m || (_templateObject$m = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-dragndrop.js';\n\n", "\n    </code></pre>\n\n    <sc-dragndrop\n      id=\"test-dragndrop\"\n      width=\"300\"\n      height=\"200\"\n      @change=\"", "\"\n    >\n    </sc-dragndrop>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text\n        id=\"dragndrop-change\"\n        width=\"400\"\n        height=\"200\"\n        readonly\n        value=\"see console to see the non-stringified version\"\n      ></sc-text>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"600\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text width=\"250\" readonly value=\"[label='Drag and Drop Files']\"></sc-text>\n      <sc-text\n        value=\"Drag and Drop Files\"\n        @change=\"", "\"\n      ></sc-number>\n    </p>\n  "])), "<sc-dragndrop></sc-dragndrop>", function (e) {
      var $change = document.querySelector('#dragndrop-change');
      var txt = '{';

      for (var name in e.detail.value) {
        txt += "\n  ".concat(name, ": \"").concat(e.detail.value[name], "\",");
      }

      txt += '\n}';
      $change.value = txt;
    }, function (e) {
      var $component = document.querySelector('#test-dragndrop');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-dragndrop');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-dragndrop');
      $component.label = e.detail.value;
    });
  }

  var _templateObject$n;
  function bang () {
    return $(_templateObject$n || (_templateObject$n = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-bang.js';\n\n", "\n    </code></pre>\n\n    <sc-bang\n      id=\"test-bang\"\n      @input=\"", "\"\n    ></sc-bang>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input\"></sc-text>\n      <sc-bang id=\"bang-input\"></sc-bang>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[active=false]\"></sc-text>\n      <sc-bang\n        @input=\"", "\"\n      ></sc-bang>\n    </p>\n  "])), "<sc-bang></sc-bang>", function (e) {
      var $event = document.querySelector('#bang-input');
      $event.active = true;
    }, function (e) {
      var $component = document.querySelector('#test-bang');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-bang');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-bang');
      $component.active = true;
    });
  }

  var _templateObject$o;
  function button () {
    var timeoutIdInput;
    var timeoutIdPress;
    var timeoutIdRelease;
    return $(_templateObject$o || (_templateObject$o = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-button.js';\n\n", "\n    </code></pre>\n\n    <sc-button\n      id=\"test-button\"\n      value=\"my-value\"\n      text=\"my button\"\n      @input=\"", "\"\n      @press=\"", "\"\n      @release=\"", "\"\n    ></sc-button>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input (e.detail.value)\"></sc-text>\n      <sc-bang id=\"button-input\"></sc-bang>\n      <sc-text readonly id=\"button-value-input\"></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"@press (e.detail.value)\"></sc-text>\n      <sc-bang id=\"button-press\"></sc-bang>\n      <sc-text readonly id=\"button-value-press\"></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"@release (e.detail.value)\"></sc-text>\n      <sc-bang id=\"button-release\"></sc-bang>\n      <sc-text readonly id=\"button-value-release\"></sc-text>\n    </p>\n\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=200]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[value=null]\"></sc-text>\n      <sc-text\n        value=\"my-value\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[text=this.value]\"></sc-text>\n      <sc-text\n        value=\"my button\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[selected=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n  "])), "<sc-button></sc-button>", function (e) {
      var $event = document.querySelector('#button-input');
      $event.active = true;
      clearTimeout(timeoutIdInput);
      var $value = document.querySelector('#button-value-input');
      $value.value = e.detail.value;
      timeoutIdInput = setTimeout(function () {
        return $value.value = '';
      }, 500);
    }, function (e) {
      var $event = document.querySelector('#button-press');
      $event.active = true;
      clearTimeout(timeoutIdPress);
      var $value = document.querySelector('#button-value-press');
      $value.value = e.detail.value;
      timeoutIdPress = setTimeout(function () {
        return $value.value = '';
      }, 500);
    }, function (e) {
      var $event = document.querySelector('#button-release');
      $event.active = true;
      clearTimeout(timeoutIdRelease);
      var $value = document.querySelector('#button-value-release');
      $value.value = e.detail.value;
      timeoutIdRelease = setTimeout(function () {
        return $value.value = '';
      }, 500);
    }, function (e) {
      var $component = document.querySelector('#test-button');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-button');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-button');
      $component.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-button');
      $component.text = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-button');
      $component.selected = e.detail.value;
    });
  }

  var _templateObject$p;

  var exampleCode = "function add(a, b) {\n  return a + b;\n}\n";
  function editor () {
    return $(_templateObject$p || (_templateObject$p = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-editor.js';\n\n", "\n    </code></pre>\n\n    <sc-editor\n      id=\"test-editor\"\n      value=\"", "\"\n      @change=\"", "\"\n    ></sc-editor>\n\n    <h3>Events</h3>\n    <div>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text readonly width=\"300\" height=\"200\" id=\"editor-change\"></sc-text>\n      <p><i>@change event is triggered on \"cmd + s\" and when clicking the \"save\" button</i></p>\n    </div>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=300]\"></sc-text>\n      <sc-number\n        min=\"200\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=200]\"></sc-text>\n      <sc-number\n        min=\"100\"\n        max=\"500\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[font-size=11]\"></sc-text>\n      <sc-number\n        min=\"8\"\n        max=\"20\"\n        value=\"11\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[value='']\"></sc-text>\n      <sc-editor\n        value=\"", "\"\n        @change=\"", "\"\n      ></sc-editor>\n\n    </p>\n  "])), "<sc-editor></sc-editor>", exampleCode, function (e) {
      var $event = document.querySelector('#editor-change');
      $event.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-editor');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-editor');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-editor');
      $component.fontSize = e.detail.value;
    }, exampleCode, function (e) {
      var $editor = document.querySelector('#test-editor');
      $editor.value = e.detail.value;
    });
  }

  var _templateObject$q;
  function number () {
    return $(_templateObject$q || (_templateObject$q = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-number.js';\n\n", "\n    </code></pre>\n\n    <sc-number\n      id=\"test-number\"\n      value=\"0\"\n      @input=\"", "\"\n      @change=\"", "\"\n    ></sc-number>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input (e.detail.value)\"></sc-text>\n      <sc-number id=\"number-input\"></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"@change (e.detail.value)\"></sc-text>\n      <sc-number id=\"number-change\"></sc-number>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=100]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"100\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[min=-Infinity]\"></sc-text>\n      <sc-number\n        max=\"0\"\n        value=\"-9999\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[max=+Infinity]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        value=\"9999\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[value=0]\"></sc-text>\n      <sc-number\n        value=\"0\"\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[integer=false]\"></sc-text>\n      <sc-toggle\n        id=\"test-number\"\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n  "])), "<sc-number></sc-number>", function (e) {
      var $event = document.querySelector('#number-input');
      $event.value = e.detail.value;
    }, function (e) {
      var $event = document.querySelector('#number-change');
      $event.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.min = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.max = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-number');
      $component.integer = e.detail.value;
    });
  }

  var _templateObject$r;
  function slider () {
    return $(_templateObject$r || (_templateObject$r = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-slider.js';\n\n", "\n    </code></pre>\n\n    <sc-slider\n      id=\"test-slider\"\n      @input=\"", "\"\n      @change=\"", "\"\n    ></sc-slider>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input => e.detail.value\"></sc-text>\n      <sc-number id=\"slider-input\"></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"@change => e.detail.value\"></sc-text>\n      <sc-number id=\"slider-change\"></sc-number>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[value=0.5]\"></sc-text>\n      <sc-number\n        value=\"0.5\"\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[width=200]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[min=-1]\"></sc-text>\n      <sc-number\n        min=\"-200\"\n        max=\"0\"\n        value=\"0\"\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[max=1]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        max=\"200\"\n        value=\"1\"\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[orientation=horizontal]\"></sc-text>\n      <sc-button\n        value=\"horizontal\"\n        @input=\"", "\"\n      ></sc-button>\n      <sc-button\n        value=\"vertical\"\n        @input=\"", "\"\n      ></sc-button>\n    </p>\n    <p>\n      <sc-text readonly value=\"[display-number=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n    <p>\n      <sc-text readonly value=\"[color=#dededeff]\"></sc-text>\n      <sc-text\n        value=\"#dededeff\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n\n  "])), "<sc-slider></sc-slider>", function (e) {
      var $display = document.querySelector('#slider-input');
      $display.value = e.detail.value;
    }, function (e) {
      var $display = document.querySelector('#slider-change');
      $display.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.min = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.max = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.orientation = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.orientation = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.displayNumber = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-slider');
      $component.color = e.detail.value;
    });
  }

  var _templateObject$s;
  function text () {
    return $(_templateObject$s || (_templateObject$s = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-text.js';\n\n", "\n    </code></pre>\n\n    <sc-text\n      id=\"test-text\"\n      width=\"300\"\n      height=\"200\"\n      @change=\"", "\"\n      value=\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\ntempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,\nquis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo\nconsequat. Duis aute irure dolor in reprehenderit in voluptate velit esse\ncillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\nproident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n    ></sc-text>\n\n    <h3>Events</h3>\n    <div>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text readonly width=\"300\" height=\"200\" id=\"text-change\"></sc-text>\n      <p><i>@change event is triggered on blur and on \"cmd + s\" </i></p>\n    </div>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=200]\"></sc-text>\n      <sc-number\n        min=\"100\"\n        max=\"500\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"200\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[value='']\"></sc-text>\n      <sc-text\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[readonly=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n  "])), "<sc-text></sc-text>", function (e) {
      var $event = document.querySelector('#text-change');
      $event.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-text');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-text');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-text');
      $component.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-text');
      $component.readonly = e.detail.value;
    });
  }

  var _templateObject$t;
  function toggle () {
    return $(_templateObject$t || (_templateObject$t = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-toggle.js';\n\n", "\n    </code></pre>\n\n    <sc-toggle\n      id=\"test-toggle\"\n      @change=\"", "\"\n    ></sc-toggle>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-toggle id=\"toggle-change\"></sc-toggle>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[active=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n  "])), "<sc-toggle></sc-toggle>", function (e) {
      var $event = document.querySelector('#toggle-change');
      $event.active = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-toggle');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-toggle');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-toggle');
      $component.active = e.detail.value;
    });
  }

  var _templateObject$u;
  function dotMap () {
    // dirty hack to make sure the element is in the DOM
    setTimeout(function () {
      var $dotMap = document.querySelector('#test-dot-map');
      var $dotMapDots = document.querySelector('#dot-map-dots');
      var dots = [];
      setInterval(function () {
        if (dots.length > 20) {
          var removeIndex = Math.floor(Math.random() * dots.length);
          dots.splice(removeIndex, 1);
        }

        var xRange = $dotMap.xRange;
        var yRange = $dotMap.yRange;
        var x = Math.random() * (xRange[1] - xRange[0]) + xRange[0];
        var y = Math.random() * (yRange[1] - yRange[0]) + yRange[0];
        dots.push({
          x,
          y
        });
        $dotMap.value = dots;
        $dotMapDots.value = JSON.stringify(dots, null, 2);
      }, 500);
    }, 150);
    return $(_templateObject$u || (_templateObject$u = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-dot-map.js';\n\n", "\n    </code></pre>\n\n    <sc-dot-map\n      id=\"test-dot-map\"\n      style=\"outline: 1px solid #454545\"\n    ></sc-dot-map>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=300]\"></sc-text>\n      <sc-number\n        min=\"150\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=300]\"></sc-text>\n      <sc-number\n        min=\"150\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[x-range=[0, 1]] (l -> r)\"></sc-text>\n      <sc-text\n        value=\"[0, 1]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[y-range=[0, 1]] (t -> b)\"></sc-text>\n      <sc-text\n        value=\"[0, 1]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly height=\"42\" value=\"[dots=[]] \n(dot={ x, y[, color, ...])\"></sc-text>\n      <sc-text id=\"dot-map-dots\" width=\"300\" height=\"150\" readonly></sc-text>\n    </p>\n\n    <h4>As input</h4>\n    <p>\n      <sc-text readonly value=\"[capture-event=false]\"></sc-text>\n      <sc-toggle\n        active\n        @change=\"", "\"\n      ></sc-toggle>\n      <sc-dot-map\n        id=\"test-dot-map-2\"\n        capture-events\n        @input=\"", "\"\n      ></sc-dot-map>\n    </p>\n    <p>\n      <sc-text readonly value=\"[persist-event=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n    <p>\n      <sc-text readonly value=\"[background-image=null]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text id=\"dot-map-change\" width=\"300\" height=\"120\" readonly></sc-text>\n    </p>\n  "], ["\n    <pre><code>\nimport '@ircam/simple-components/sc-dot-map.js';\n\n", "\n    </code></pre>\n\n    <sc-dot-map\n      id=\"test-dot-map\"\n      style=\"outline: 1px solid #454545\"\n    ></sc-dot-map>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=300]\"></sc-text>\n      <sc-number\n        min=\"150\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=300]\"></sc-text>\n      <sc-number\n        min=\"150\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[x-range=[0, 1]] (l -> r)\"></sc-text>\n      <sc-text\n        value=\"[0, 1]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[y-range=[0, 1]] (t -> b)\"></sc-text>\n      <sc-text\n        value=\"[0, 1]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly height=\"42\" value=\"[dots=[]] \\n(dot={ x, y[, color, ...])\"></sc-text>\n      <sc-text id=\"dot-map-dots\" width=\"300\" height=\"150\" readonly></sc-text>\n    </p>\n\n    <h4>As input</h4>\n    <p>\n      <sc-text readonly value=\"[capture-event=false]\"></sc-text>\n      <sc-toggle\n        active\n        @change=\"", "\"\n      ></sc-toggle>\n      <sc-dot-map\n        id=\"test-dot-map-2\"\n        capture-events\n        @input=\"", "\"\n      ></sc-dot-map>\n    </p>\n    <p>\n      <sc-text readonly value=\"[persist-event=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n    <p>\n      <sc-text readonly value=\"[background-image=null]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text id=\"dot-map-change\" width=\"300\" height=\"120\" readonly></sc-text>\n    </p>\n  "])), "<sc-dot-map></sc-dot-map>", function (e) {
      var $component = document.querySelector('#test-dot-map');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-dot-map');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-dot-map');
      $component.xRange = JSON.parse(e.detail.value);
    }, function (e) {
      var $component = document.querySelector('#test-dot-map');
      $component.yRange = JSON.parse(e.detail.value);
    }, function (e) {
      var $component = document.querySelector('#test-dot-map-2');
      $component.captureEvents = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#dot-map-change');
      $component.value = JSON.stringify(e.detail.value, null, 2);
    }, function (e) {
      var $component = document.querySelector('#test-dot-map-2');
      $component.persistEvents = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-dot-map-2');

      if (e.detail.value === true) {
        $component.backgroundImage = 'images/seating-map.png';
      } else {
        $component.backgroundImage = null;
      }
    });
  }

  var _templateObject$v;
  function contextMenu () {
    var context = [{
      action: 'edit',
      label: 'Edit'
    }, {
      action: 'save',
      label: 'Save'
    }, {
      action: 'delete',
      label: 'Delete'
    }];
    return $(_templateObject$v || (_templateObject$v = _taggedTemplateLiteral(["\n    <sc-context-menu\n      id=\"test-context-menu\"\n      value=\"", "\"\n      @input=\"", "\"\n    ></sc-context-menu>\n    <div\n      style=\"\n        width: 400px;\n        height: 300px;\n        text-align: center;\n        line-height: 300px;\n        background-color: #efefef;\n      \"\n      @contextmenu=\"", "\"\n    >\n      right-click to open the context menu\n    </div>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input (e.detail.value)\"></sc-text>\n      <sc-bang id=\"context-menu-input\"></sc-bang>\n      <sc-text readonly id=\"context-menu-value-input\"></sc-text>\n    </p>\n\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"value=null\"></sc-text>\n      <sc-text\n        width=\"300\"\n        height=\"300\"\n        value=\"", "\"\n        @change=\"", "\"\n      ></sc-number>\n    </p>\n  "])), JSON.stringify(context), function (e) {
      document.querySelector('#context-menu-input').active = true;
      document.querySelector('#context-menu-value-input').value = e.detail.value;
    }, function (e) {
      e.preventDefault();
      var $component = document.querySelector('#test-context-menu');
      $component.show(e);
    }, JSON.stringify(context, null, 2), function (e) {
      var $component = document.querySelector('#test-context-menu');
      $component.value = JSON.parse(e.detail.value);
    });
  }

  var _templateObject$w;
  function fileTree () {
    var tree = {
      path: 'docs',
      name: 'docs',
      children: [{
        path: 'inner/docs',
        name: 'inner',
        children: [{
          path: 'docs/inner/niap.md',
          name: 'niap.md',
          size: 1584,
          extension: '.md',
          type: 'file'
        }, {
          path: 'docs/inner/test.md',
          name: 'test.md',
          size: 1588,
          extension: '.md',
          type: 'file'
        }],
        size: 3172,
        type: 'directory'
      }, {
        path: 'docs/niap.md',
        name: 'niap.md',
        size: 1584,
        extension: '.md',
        type: 'file'
      }, {
        path: 'docs/test.md',
        name: 'test.md',
        size: 1588,
        extension: '.md',
        type: 'file'
      }],
      size: 3172,
      type: 'directory'
    };
    return $(_templateObject$w || (_templateObject$w = _taggedTemplateLiteral(["\n    <sc-file-tree\n      id=\"test-file-tree\"\n      value=\"", "\"\n      @input=\"", "\"\n      @change=\"", "\"\n    ></sc-file-tree>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@input (e.detail.value)\"></sc-text>\n      <sc-bang id=\"file-tree-input\"></sc-bang>\n      <sc-text readonly id=\"file-tree-value-input\" height=\"130\" width=\"300\"></sc-text>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"value=null\"></sc-text>\n      <sc-text\n        width=\"300\"\n        height=\"300\"\n        value=\"", "\"\n        @change=\"", "\"\n      ></sc-number>\n    </p>\n  "])), JSON.stringify(tree), function (e) {
      var $bang = document.querySelector('#file-tree-input');
      $bang.active = true;
      var $text = document.querySelector('#file-tree-value-input');
      $text.value = JSON.stringify(e.detail.value, null, 2);
    }, function (e) {
      console.log(e);
    }, JSON.stringify(tree, null, 2), function (e) {
      var $component = document.querySelector('#test-file-tree');
      $component.value = JSON.parse(e.detail.value);
    });
  }

  var _templateObject$x;
  function transport () {
    return $(_templateObject$x || (_templateObject$x = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-transport.js';\n\n", "\n    </code></pre>\n\n    <sc-transport\n      id=\"test-transport\"\n      buttons=\"[play, pause, stop]\"\n      @change=\"", "\"\n    ></sc-transport>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-text id=\"transport-change\" readonly value=\"undefined\"></sc-text>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[buttons=[]]\"></sc-text>\n      <sc-text\n        value=\"[play, pause, stop]\"\n        @change=\"", "\"\n      ></sc-text>\n    </p>\n    <p>\n      <sc-text readonly value=\"[state='']\"></sc-text>\n      <sc-button\n        value=\"play\"\n        width=\"100\"\n        @input=\"", "\"\n      ></sc-button>\n      <sc-button\n        value=\"pause\"\n        width=\"100\"\n        @input=\"", "\"\n      ></sc-button>\n      <sc-button\n        value=\"stop\"\n        width=\"100\"\n        @input=\"", "\"\n      ></sc-button>\n    </p>\n\n  "])), "<sc-transport></sc-transport>", function (e) {
      var $event = document.querySelector('#transport-change');
      $event.value = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.buttons = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.state = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.state = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-transport');
      $component.state = e.detail.value;
    });
  }

  var _templateObject$y;
  function record () {
    return $(_templateObject$y || (_templateObject$y = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-record.js';\n\n", "\n    </code></pre>\n\n    <sc-record\n      id=\"test-record\"\n      @change=\"", "\"\n    ></sc-record>\n\n    <h3>Events</h3>\n    <p>\n      <sc-text readonly value=\"@change\"></sc-text>\n      <sc-toggle id=\"record-change\"></sc-toggle>\n    </p>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=30]\"></sc-text>\n      <sc-number\n        min=\"30\"\n        max=\"300\"\n        value=\"30\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[active=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n  "])), "<sc-record></sc-record>", function (e) {
      var $event = document.querySelector('#record-change');
      $event.active = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-record');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-record');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-record');
      $component.active = e.detail.value;
    });
  }

  function sineGenerator(frequency, sampleRate, blockSize, callback) {
    var nbrBlocks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
    var self = {};
    var block = new Float32Array(blockSize);
    var tIncr = blockSize / sampleRate;

    var _2PI = 2 * Math.PI;

    var pIncr = frequency / sampleRate;
    var phase = 0;
    var timeoutId = null;
    var time = 0;
    var counter = 0;

    self.frequency = function (frequency) {
      // mult = _2PI * frequency;
      pIncr = frequency / sampleRate;
    };

    self.start = function () {
      (function createBlock() {
        for (var i = 0; i < blockSize; i++) {
          var value = Math.sin(phase * _2PI);
          block[i] = value;
          phase = (phase + pIncr) % 1;
        }

        callback(time, block);
        time += tIncr;
        counter += 1;

        if (counter < nbrBlocks) {
          timeoutId = setTimeout(createBlock, tIncr * 1000);
        }
      })();
    };

    self.stop = function () {
      clearTimeout(timeoutId);
    };

    return self;
  }

  var _templateObject$z;
  function signal () {
    // dirty hack to make sure the element is in the DOM
    setTimeout(function () {
      var $signal = document.querySelector('#test-signal');
      var frame = null;
      var sine1 = sineGenerator(0.5, 25, 1, function (time, data) {
        frame = {
          time,
          data: Array.from(data)
        };
      });
      var sine2 = sineGenerator(1, 25, 1, function (time, data) {
        frame.data[1] = data[0] * 0.5;
        $signal.value = frame;
      });
      sine1.start();
      sine2.start(); // setTimeout(() => {
      //   sine1.stop();
      //   sine2.stop();
      // }, 2000);
    }, 150);
    return $(_templateObject$z || (_templateObject$z = _taggedTemplateLiteral(["\n    <pre><code>\nimport '@ircam/simple-components/sc-signal.js';\n\n", "\n    </code></pre>\n\n    <sc-signal id=\"test-signal\"></sc-signal>\n\n    <h3>Attributes</h3>\n    <p>\n      <sc-text readonly value=\"[width=300]\"></sc-text>\n      <sc-number\n        min=\"100\"\n        max=\"600\"\n        value=\"300\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[height=150]\"></sc-text>\n      <sc-number\n        min=\"75\"\n        max=\"300\"\n        value=\"150\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[min=-1]\"></sc-text>\n      <sc-number\n        min=\"-10\"\n        max=\"-1\"\n        value=\"-1\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[max=1]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        max=\"10\"\n        value=\"1\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[duration=-1]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        max=\"10\"\n        value=\"1\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[line-width=1]\"></sc-text>\n      <sc-number\n        min=\"1\"\n        max=\"10\"\n        value=\"1\"\n        integer\n        @input=\"", "\"\n      ></sc-number>\n    </p>\n    <p>\n      <sc-text readonly value=\"[display-min-max=false]\"></sc-text>\n      <sc-toggle\n        @change=\"", "\"\n      ></sc-toggle>\n    </p>\n\n    <h3>Properties</h3>\n    <p>\n      <sc-text readonly width=\"350\" value=\"value={ time<Number>(seconds), data<Array> }\"></sc-text>\n    <p>\n  "])), "<sc-signal></sc-signal>", function (e) {
      var $component = document.querySelector('#test-signal');
      $component.width = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.height = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.min = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.max = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.duration = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.lineWidth = e.detail.value;
    }, function (e) {
      var $component = document.querySelector('#test-signal');
      $component.displayMinMax = e.detail.value;
    });
  }

  var _templateObject$A, _templateObject2$i, _templateObject3$b;
  var docs = {
    'sc-bang': bang,
    'sc-toggle': toggle,
    'sc-number': number,
    'sc-slider': slider,
    'sc-button': button,
    'sc-text': text,
    'sc-transport': transport,
    'sc-record': record,
    'sc-editor': editor,
    'sc-matrix': matrix,
    'sc-dot-map': dotMap,
    'sc-dragndrop': dragndrop,
    'sc-context-menu': contextMenu,
    'sc-signal': signal,
    'sc-file-tree': fileTree,
    'sc-transport': transport
  };

  function setTheme(name) {
    switch (name) {
      case 'light':
        document.body.classList.remove('dark');
        document.body.classList.add('light');
        break;

      case 'dark':
        document.body.classList.remove('light');
        document.body.classList.add('dark');
        break;
    }
  }

  setTheme('light');
  x($(_templateObject$A || (_templateObject$A = _taggedTemplateLiteral(["\n  <section class=\"menu\">\n    <a href=\"https://github.com/ircam-ismm/simple-components\">\n      <sc-button text=\"Github\"></sc-button>\n    </a>\n    <sc-button text=\"dark background\" @press=\"", "\"></sc-button>\n    <sc-button text=\"light background\" @press=\"", "\"></sc-button>\n\n    ", "\n\n  </section>\n  <section class=\"content\">\n    <h1>sc-components</h1>\n\n    <pre><code>\nnpm install @ircam/simple-components --save\n    </code></pre>\n\n    ", "\n\n    <div style=\"height: 300px\">&nbsp;</div>\n  </section>\n"])), function (e) {
    return setTheme('dark');
  }, function (e) {
    return setTheme('light');
  }, Object.keys(docs).map(function (name) {
    return $(_templateObject2$i || (_templateObject2$i = _taggedTemplateLiteral(["<a href=\"#", "\">&lt;", "&gt;</a>"])), name, name);
  }), Object.keys(docs).map(function (name) {
    return $(_templateObject3$b || (_templateObject3$b = _taggedTemplateLiteral(["\n        <div class=\"component\">\n          <div class=\"doc\">\n            <h2><a href=\"#", "\" id=\"", "\" name=\"", "\">#</a> ", "</h2>\n            ", "\n          </div>\n        </div>\n      "])), name, name, name, name, docs[name]());
  })), document.querySelector('#container'));

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGF0dGVuLWludG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2FycmF5L2ZsYXQtbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zdHJpbmcvcGFkLXN0YXJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zdHJpbmcvcGFkLWVuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zdHJpbmcvdHJpbS1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vc3RyaW5nL3RyaW0tZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vc3ltYm9sL2FzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvdmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL3Byb21pc2UvZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcG9seWZpbGwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpdC9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGl0LWh0bWwuanMiLCIuLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L2Nzcy10YWcuanMiLCIuLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L3JlYWN0aXZlLWVsZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0L25vZGVfbW9kdWxlcy9saXQtaHRtbC9saXQtaHRtbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9saXQvbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpdC1lbGVtZW50LmpzIiwiLi4vU2NFbGVtZW50LmpzIiwiLi4vc2MtcG9zaXRpb24tc3VyZmFjZS5qcyIsIi4uL3NjLXNwZWVkLXN1cmZhY2UuanMiLCIuLi9zdHlsZXMuanMiLCIuLi9zYy1idXR0b24uanMiLCIuLi9zYy10b2dnbGUuanMiLCIuLi91dGlscy9nZXRTY2FsZS5qcyIsIi4uL3V0aWxzL2dldENsaXBwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0L25vZGVfbW9kdWxlcy9saXQtaHRtbC9kaXJlY3RpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0L25vZGVfbW9kdWxlcy9saXQtaHRtbC9kaXJlY3RpdmVzL2NsYXNzLW1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9udW1iZXItcHJlY2lzaW9uL2J1aWxkL2luZGV4LmVzLmpzIiwiLi4vc2MtbnVtYmVyLmpzIiwiLi4vc2Mtc2xpZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9rZXltYXAvc3VibGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2RpYWxvZy9kaWFsb2cuanMiLCIuLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9zZWFyY2gvc2VhcmNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2VhcmNoL2p1bXAtdG8tbGluZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2NvbW1lbnQvY29tbWVudC5qcyIsIi4uL3ZlbmRvcnMvY29kZW1pcnJvci1jc3MuanMiLCIuLi92ZW5kb3JzL3RoZW1lLW1vbm9rYWktY3NzLmpzIiwiLi4vdmVuZG9ycy9hZGRvbi1kaWFsb2ctY3NzLmpzIiwiLi4vc2MtZWRpdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kaXJlY3RpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcGFydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1yZXN1bHQuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3BhcnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saXQtaHRtbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9kaXJlY3RpdmVzL2NsYXNzLW1hcC5qcyIsIi4uL3NjLXRleHQuanMiLCIuLi9zYy1iYW5nLmpzIiwiLi4vc2Mtc2lnbmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xpdC9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGlyZWN0aXZlLWhlbHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbGl0L25vZGVfbW9kdWxlcy9saXQtaHRtbC9kaXJlY3RpdmVzL3JlcGVhdC5qcyIsIi4uL3NjLWRvdC1tYXAuanMiLCIuLi9zYy1kcmFnbmRyb3AuanMiLCIuLi9zYy1tYXRyaXguanMiLCIuLi9zYy1jb250ZXh0LW1lbnUuanMiLCIuLi9zYy1maWxlLXRyZWUuanMiLCIuLi9zYy10cmFuc3BvcnQuanMiLCIuLi9zYy1yZWNvcmQuanMiLCJzcmMvc2MtbWF0cml4LWV4YW1wbGUuanMiLCJzcmMvc2MtZHJhZ25kcm9wLWV4YW1wbGUuanMiLCJzcmMvc2MtYmFuZy1leGFtcGxlLmpzIiwic3JjL3NjLWJ1dHRvbi1leGFtcGxlLmpzIiwic3JjL3NjLWVkaXRvci1leGFtcGxlLmpzIiwic3JjL3NjLW51bWJlci1leGFtcGxlLmpzIiwic3JjL3NjLXNsaWRlci1leGFtcGxlLmpzIiwic3JjL3NjLXRleHQtZXhhbXBsZS5qcyIsInNyYy9zYy10b2dnbGUtZXhhbXBsZS5qcyIsInNyYy9zYy1kb3QtbWFwLWV4YW1wbGUuanMiLCJzcmMvc2MtY29udGV4dC1tZW51LWV4YW1wbGUuanMiLCJzcmMvc2MtZmlsZS10cmVlLWV4YW1wbGUuanMiLCJzcmMvc2MtdHJhbnNwb3J0LWV4YW1wbGUuanMiLCJzcmMvc2MtcmVjb3JkLWV4YW1wbGUuanMiLCJzcmMvdXRpbHMvc2luZUdlbmVyYXRvci5qcyIsInNyYy9zYy1zaWduYWwtZXhhbXBsZS5qcyIsInNyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEyJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi9fZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkR09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNwYWNlcyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nO1xudmFyIG5vbiA9ICdcXHUyMDBiXFx1MDA4NSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgdmFyIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcbiIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG4iLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGxvZzFwID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgJGFjb3NoID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7IGFzaW5oOiBhc2luaCB9KTtcbiIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpIHtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBmcm91bmQ6IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJykgfSk7XG4iLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGltdWwgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJykgfSk7XG4iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreCk7XG4gICAgdmFyIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsXG4gICAgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG4iLCJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcbiIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuXG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG4iLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHsgaXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKSB9KTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGlmIChodG1sKSBhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmIChrbGFzcyA9PSAnQXJyYXknKSByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuKTtcbiAgICB2YXIgdXBUbyA9IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbik7XG4gICAgdmFyIHNpemUgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpO1xuICAgIHZhciBjbG9uZWQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBTVFJJQ1QgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgJG5hdGl2ZSA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleHBGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG5cbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xuLy8gVGhpcyBhbHdheXMgcmVmZXJzIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIGJlY2F1c2UgdGhlXG4vLyBTdHJpbmcjcmVwbGFjZSBwb2x5ZmlsbCB1c2VzIC4vZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyxcbi8vIHdoaWNoIGxvYWRzIHRoaXMgZmlsZSBiZWZvcmUgcGF0Y2hpbmcgdGhlIG1ldGhvZC5cbnZhciBuYXRpdmVSZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xuXG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xuXG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLyxcbiAgICAgIHJlMiA9IC9iKi9nO1xuICBuYXRpdmVFeGVjLmNhbGwocmUxLCAnYScpO1xuICBuYXRpdmVFeGVjLmNhbGwocmUyLCAnYScpO1xuICByZXR1cm4gcmUxW0xBU1RfSU5ERVhdICE9PSAwIHx8IHJlMltMQVNUX0lOREVYXSAhPT0gMDtcbn0pKCk7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZVtMQVNUX0lOREVYXTtcblxuICAgIG1hdGNoID0gbmF0aXZlRXhlYy5jYWxsKHJlLCBzdHIpO1xuXG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuICAgICAgcmVbTEFTVF9JTkRFWF0gPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4gLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gYXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKFxuICAgICAgZGVmaW5lZCxcbiAgICAgIFNZTUJPTCxcbiAgICAgICcnW0tFWV0sXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuICAgIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRtYXRjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIEFbbl0gPSBtYXRjaFN0cjtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcbiAgICB9XG4gIF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNlYXJjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRzZWFyY2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gICAgfVxuICBdO1xufSk7XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG52YXIgTUFYX1VJTlQzMiA9IDB4ZmZmZmZmZmY7XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgU1VQUE9SVFNfWSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7IFJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZVxuICAgICAgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDBcbiAgICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgSVNfSUUxMSA9ICFnbG9iYWwuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gYnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwgeyBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyIH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICgkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW4gLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9IH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvclxuICAgICAgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7IH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwgeyBzZXQ6ICRzZXQgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwgeyBzbGljZTogJHNsaWNlIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7IHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmcgfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgICAgICAvLyBrZXlzXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHsgdmFsdWU6IGtleSwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG4iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIH0gZWxzZSBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlRGVzYygwLCBWKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG4iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5pbmNsdWRlcztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBjdHgobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgc3ByZWFkYWJsZTtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgc3ByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIHNwcmVhZGFibGUgPSBlbGVtZW50W0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICAgICAgc3ByZWFkYWJsZSA9IHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxZmZmZmZmZmZmZmZmZikgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZsYXRNYXA7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbnZhciBXRUJLSVRfQlVHID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogV0VCS0lUX0JVRywgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TdHJpbmcucGFkU3RhcnQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxudmFyIFdFQktJVF9CVUcgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBXRUJLSVRfQlVHLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TdHJpbmcucGFkRW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN0cmluZy50cmltTGVmdDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3RyaW5nLnRyaW1SaWdodDtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChPLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnZhbHVlcztcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5lbnRyaWVzO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlWydmaW5hbGx5J107XG4iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEyJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuZ2xvYmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuL25vQ29uZmxpY3RcIik7XG5cbnZhciBfZ2xvYmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dsb2JhbFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5pZiAoX2dsb2JhbFtcImRlZmF1bHRcIl0uX2JhYmVsUG9seWZpbGwgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gIGNvbnNvbGUud2FybihcIkBiYWJlbC9wb2x5ZmlsbCBpcyBsb2FkZWQgbW9yZSB0aGFuIG9uY2Ugb24gdGhpcyBwYWdlLiBUaGlzIGlzIHByb2JhYmx5IG5vdCBkZXNpcmFibGUvaW50ZW5kZWQgXCIgKyBcImFuZCBtYXkgaGF2ZSBjb25zZXF1ZW5jZXMgaWYgZGlmZmVyZW50IHZlcnNpb25zIG9mIHRoZSBwb2x5ZmlsbHMgYXJlIGFwcGxpZWQgc2VxdWVudGlhbGx5LiBcIiArIFwiSWYgeW91IGRvIG5lZWQgdG8gbG9hZCB0aGUgcG9seWZpbGwgbW9yZSB0aGFuIG9uY2UsIHVzZSBAYmFiZWwvcG9seWZpbGwvbm9Db25mbGljdCBcIiArIFwiaW5zdGVhZCB0byBieXBhc3MgdGhlIHdhcm5pbmcuXCIpO1xufVxuXG5fZ2xvYmFsW1wiZGVmYXVsdFwiXS5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7IiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG52YXIgdDtjb25zdCBpPWdsb2JhbFRoaXMudHJ1c3RlZFR5cGVzLHM9aT9pLmNyZWF0ZVBvbGljeShcImxpdC1odG1sXCIse2NyZWF0ZUhUTUw6dD0+dH0pOnZvaWQgMCxlPWBsaXQkJHsoTWF0aC5yYW5kb20oKStcIlwiKS5zbGljZSg5KX0kYCxvPVwiP1wiK2Usbj1gPCR7b30+YCxsPWRvY3VtZW50LGg9KHQ9XCJcIik9PmwuY3JlYXRlQ29tbWVudCh0KSxyPXQ9Pm51bGw9PT10fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdCxkPUFycmF5LmlzQXJyYXksdT10PT57dmFyIGk7cmV0dXJuIGQodCl8fFwiZnVuY3Rpb25cIj09dHlwZW9mKG51bGw9PT0oaT10KXx8dm9pZCAwPT09aT92b2lkIDA6aVtTeW1ib2wuaXRlcmF0b3JdKX0sYz0vPCg/OighLS18XFwvW15hLXpBLVpdKXwoXFwvP1thLXpBLVpdW14+XFxzXSopfChcXC8/JCkpL2csdj0vLS0+L2csYT0vPi9nLGY9Lz58WyBcdFxcblxmXFxyXSg/OihbXlxcc1wiJz49L10rKShbIFx0XFxuXGZcXHJdKj1bIFx0XFxuXGZcXHJdKig/OlteIFx0XFxuXGZcXHJcIidgPD49XXwoXCJ8Jyl8KSl8JCkvZyxfPS8nL2csbT0vXCIvZyxnPS9eKD86c2NyaXB0fHN0eWxlfHRleHRhcmVhfHRpdGxlKSQvaSxwPXQ9PihpLC4uLnMpPT4oe18kbGl0VHlwZSQ6dCxzdHJpbmdzOmksdmFsdWVzOnN9KSwkPXAoMSkseT1wKDIpLGI9U3ltYm9sLmZvcihcImxpdC1ub0NoYW5nZVwiKSx3PVN5bWJvbC5mb3IoXCJsaXQtbm90aGluZ1wiKSxUPW5ldyBXZWFrTWFwLHg9KHQsaSxzKT0+e3ZhciBlLG87Y29uc3Qgbj1udWxsIT09KGU9bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1lP2U6aTtsZXQgbD1uLl8kbGl0UGFydCQ7aWYodm9pZCAwPT09bCl7Y29uc3QgdD1udWxsIT09KG89bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1vP286bnVsbDtuLl8kbGl0UGFydCQ9bD1uZXcgTihpLmluc2VydEJlZm9yZShoKCksdCksdCx2b2lkIDAsbnVsbCE9cz9zOnt9KX1yZXR1cm4gbC5fJEFJKHQpLGx9LEE9bC5jcmVhdGVUcmVlV2Fsa2VyKGwsMTI5LG51bGwsITEpLEM9KHQsaSk9Pntjb25zdCBvPXQubGVuZ3RoLTEsbD1bXTtsZXQgaCxyPTI9PT1pP1wiPHN2Zz5cIjpcIlwiLGQ9Yztmb3IobGV0IGk9MDtpPG87aSsrKXtjb25zdCBzPXRbaV07bGV0IG8sdSxwPS0xLCQ9MDtmb3IoOyQ8cy5sZW5ndGgmJihkLmxhc3RJbmRleD0kLHU9ZC5leGVjKHMpLG51bGwhPT11KTspJD1kLmxhc3RJbmRleCxkPT09Yz9cIiEtLVwiPT09dVsxXT9kPXY6dm9pZCAwIT09dVsxXT9kPWE6dm9pZCAwIT09dVsyXT8oZy50ZXN0KHVbMl0pJiYoaD1SZWdFeHAoXCI8L1wiK3VbMl0sXCJnXCIpKSxkPWYpOnZvaWQgMCE9PXVbM10mJihkPWYpOmQ9PT1mP1wiPlwiPT09dVswXT8oZD1udWxsIT1oP2g6YyxwPS0xKTp2b2lkIDA9PT11WzFdP3A9LTI6KHA9ZC5sYXN0SW5kZXgtdVsyXS5sZW5ndGgsbz11WzFdLGQ9dm9pZCAwPT09dVszXT9mOidcIic9PT11WzNdP206Xyk6ZD09PW18fGQ9PT1fP2Q9ZjpkPT09dnx8ZD09PWE/ZD1jOihkPWYsaD12b2lkIDApO2NvbnN0IHk9ZD09PWYmJnRbaSsxXS5zdGFydHNXaXRoKFwiLz5cIik/XCIgXCI6XCJcIjtyKz1kPT09Yz9zK246cD49MD8obC5wdXNoKG8pLHMuc2xpY2UoMCxwKStcIiRsaXQkXCIrcy5zbGljZShwKStlK3kpOnMrZSsoLTI9PT1wPyhsLnB1c2godm9pZCAwKSxpKTp5KX1jb25zdCB1PXIrKHRbb118fFwiPD8+XCIpKygyPT09aT9cIjwvc3ZnPlwiOlwiXCIpO2lmKCFBcnJheS5pc0FycmF5KHQpfHwhdC5oYXNPd25Qcm9wZXJ0eShcInJhd1wiKSl0aHJvdyBFcnJvcihcImludmFsaWQgdGVtcGxhdGUgc3RyaW5ncyBhcnJheVwiKTtyZXR1cm5bdm9pZCAwIT09cz9zLmNyZWF0ZUhUTUwodSk6dSxsXX07Y2xhc3MgRXtjb25zdHJ1Y3Rvcih7c3RyaW5nczp0LF8kbGl0VHlwZSQ6c30sbil7bGV0IGw7dGhpcy5wYXJ0cz1bXTtsZXQgcj0wLGQ9MDtjb25zdCB1PXQubGVuZ3RoLTEsYz10aGlzLnBhcnRzLFt2LGFdPUModCxzKTtpZih0aGlzLmVsPUUuY3JlYXRlRWxlbWVudCh2LG4pLEEuY3VycmVudE5vZGU9dGhpcy5lbC5jb250ZW50LDI9PT1zKXtjb25zdCB0PXRoaXMuZWwuY29udGVudCxpPXQuZmlyc3RDaGlsZDtpLnJlbW92ZSgpLHQuYXBwZW5kKC4uLmkuY2hpbGROb2Rlcyl9Zm9yKDtudWxsIT09KGw9QS5uZXh0Tm9kZSgpKSYmYy5sZW5ndGg8dTspe2lmKDE9PT1sLm5vZGVUeXBlKXtpZihsLmhhc0F0dHJpYnV0ZXMoKSl7Y29uc3QgdD1bXTtmb3IoY29uc3QgaSBvZiBsLmdldEF0dHJpYnV0ZU5hbWVzKCkpaWYoaS5lbmRzV2l0aChcIiRsaXQkXCIpfHxpLnN0YXJ0c1dpdGgoZSkpe2NvbnN0IHM9YVtkKytdO2lmKHQucHVzaChpKSx2b2lkIDAhPT1zKXtjb25zdCB0PWwuZ2V0QXR0cmlidXRlKHMudG9Mb3dlckNhc2UoKStcIiRsaXQkXCIpLnNwbGl0KGUpLGk9LyhbLj9AXSk/KC4qKS8uZXhlYyhzKTtjLnB1c2goe3R5cGU6MSxpbmRleDpyLG5hbWU6aVsyXSxzdHJpbmdzOnQsY3RvcjpcIi5cIj09PWlbMV0/TTpcIj9cIj09PWlbMV0/SDpcIkBcIj09PWlbMV0/STpTfSl9ZWxzZSBjLnB1c2goe3R5cGU6NixpbmRleDpyfSl9Zm9yKGNvbnN0IGkgb2YgdClsLnJlbW92ZUF0dHJpYnV0ZShpKX1pZihnLnRlc3QobC50YWdOYW1lKSl7Y29uc3QgdD1sLnRleHRDb250ZW50LnNwbGl0KGUpLHM9dC5sZW5ndGgtMTtpZihzPjApe2wudGV4dENvbnRlbnQ9aT9pLmVtcHR5U2NyaXB0OlwiXCI7Zm9yKGxldCBpPTA7aTxzO2krKylsLmFwcGVuZCh0W2ldLGgoKSksQS5uZXh0Tm9kZSgpLGMucHVzaCh7dHlwZToyLGluZGV4Oisrcn0pO2wuYXBwZW5kKHRbc10saCgpKX19fWVsc2UgaWYoOD09PWwubm9kZVR5cGUpaWYobC5kYXRhPT09byljLnB1c2goe3R5cGU6MixpbmRleDpyfSk7ZWxzZXtsZXQgdD0tMTtmb3IoOy0xIT09KHQ9bC5kYXRhLmluZGV4T2YoZSx0KzEpKTspYy5wdXNoKHt0eXBlOjcsaW5kZXg6cn0pLHQrPWUubGVuZ3RoLTF9cisrfX1zdGF0aWMgY3JlYXRlRWxlbWVudCh0LGkpe2NvbnN0IHM9bC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7cmV0dXJuIHMuaW5uZXJIVE1MPXQsc319ZnVuY3Rpb24gUCh0LGkscz10LGUpe3ZhciBvLG4sbCxoO2lmKGk9PT1iKXJldHVybiBpO2xldCBkPXZvaWQgMCE9PWU/bnVsbD09PShvPXMuXyRDbCl8fHZvaWQgMD09PW8/dm9pZCAwOm9bZV06cy5fJEN1O2NvbnN0IHU9cihpKT92b2lkIDA6aS5fJGxpdERpcmVjdGl2ZSQ7cmV0dXJuKG51bGw9PWQ/dm9pZCAwOmQuY29uc3RydWN0b3IpIT09dSYmKG51bGw9PT0obj1udWxsPT1kP3ZvaWQgMDpkLl8kQU8pfHx2b2lkIDA9PT1ufHxuLmNhbGwoZCwhMSksdm9pZCAwPT09dT9kPXZvaWQgMDooZD1uZXcgdSh0KSxkLl8kQVQodCxzLGUpKSx2b2lkIDAhPT1lPyhudWxsIT09KGw9KGg9cykuXyRDbCkmJnZvaWQgMCE9PWw/bDpoLl8kQ2w9W10pW2VdPWQ6cy5fJEN1PWQpLHZvaWQgMCE9PWQmJihpPVAodCxkLl8kQVModCxpLnZhbHVlcyksZCxlKSksaX1jbGFzcyBWe2NvbnN0cnVjdG9yKHQsaSl7dGhpcy52PVtdLHRoaXMuXyRBTj12b2lkIDAsdGhpcy5fJEFEPXQsdGhpcy5fJEFNPWl9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5fJEFNLnBhcmVudE5vZGV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9cCh0KXt2YXIgaTtjb25zdHtlbDp7Y29udGVudDpzfSxwYXJ0czplfT10aGlzLl8kQUQsbz0obnVsbCE9PShpPW51bGw9PXQ/dm9pZCAwOnQuY3JlYXRpb25TY29wZSkmJnZvaWQgMCE9PWk/aTpsKS5pbXBvcnROb2RlKHMsITApO0EuY3VycmVudE5vZGU9bztsZXQgbj1BLm5leHROb2RlKCksaD0wLHI9MCxkPWVbMF07Zm9yKDt2b2lkIDAhPT1kOyl7aWYoaD09PWQuaW5kZXgpe2xldCBpOzI9PT1kLnR5cGU/aT1uZXcgTihuLG4ubmV4dFNpYmxpbmcsdGhpcyx0KToxPT09ZC50eXBlP2k9bmV3IGQuY3RvcihuLGQubmFtZSxkLnN0cmluZ3MsdGhpcyx0KTo2PT09ZC50eXBlJiYoaT1uZXcgTChuLHRoaXMsdCkpLHRoaXMudi5wdXNoKGkpLGQ9ZVsrK3JdfWghPT0obnVsbD09ZD92b2lkIDA6ZC5pbmRleCkmJihuPUEubmV4dE5vZGUoKSxoKyspfXJldHVybiBvfW0odCl7bGV0IGk9MDtmb3IoY29uc3QgcyBvZiB0aGlzLnYpdm9pZCAwIT09cyYmKHZvaWQgMCE9PXMuc3RyaW5ncz8ocy5fJEFJKHQscyxpKSxpKz1zLnN0cmluZ3MubGVuZ3RoLTIpOnMuXyRBSSh0W2ldKSksaSsrfX1jbGFzcyBOe2NvbnN0cnVjdG9yKHQsaSxzLGUpe3ZhciBvO3RoaXMudHlwZT0yLHRoaXMuXyRBSD13LHRoaXMuXyRBTj12b2lkIDAsdGhpcy5fJEFBPXQsdGhpcy5fJEFCPWksdGhpcy5fJEFNPXMsdGhpcy5vcHRpb25zPWUsdGhpcy5fJENnPW51bGw9PT0obz1udWxsPT1lP3ZvaWQgMDplLmlzQ29ubmVjdGVkKXx8dm9pZCAwPT09b3x8b31nZXQgXyRBVSgpe3ZhciB0LGk7cmV0dXJuIG51bGwhPT0oaT1udWxsPT09KHQ9dGhpcy5fJEFNKXx8dm9pZCAwPT09dD92b2lkIDA6dC5fJEFVKSYmdm9pZCAwIT09aT9pOnRoaXMuXyRDZ31nZXQgcGFyZW50Tm9kZSgpe2xldCB0PXRoaXMuXyRBQS5wYXJlbnROb2RlO2NvbnN0IGk9dGhpcy5fJEFNO3JldHVybiB2b2lkIDAhPT1pJiYxMT09PXQubm9kZVR5cGUmJih0PWkucGFyZW50Tm9kZSksdH1nZXQgc3RhcnROb2RlKCl7cmV0dXJuIHRoaXMuXyRBQX1nZXQgZW5kTm9kZSgpe3JldHVybiB0aGlzLl8kQUJ9XyRBSSh0LGk9dGhpcyl7dD1QKHRoaXMsdCxpKSxyKHQpP3Q9PT13fHxudWxsPT10fHxcIlwiPT09dD8odGhpcy5fJEFIIT09dyYmdGhpcy5fJEFSKCksdGhpcy5fJEFIPXcpOnQhPT10aGlzLl8kQUgmJnQhPT1iJiZ0aGlzLiQodCk6dm9pZCAwIT09dC5fJGxpdFR5cGUkP3RoaXMuVCh0KTp2b2lkIDAhPT10Lm5vZGVUeXBlP3RoaXMuayh0KTp1KHQpP3RoaXMuUyh0KTp0aGlzLiQodCl9TSh0LGk9dGhpcy5fJEFCKXtyZXR1cm4gdGhpcy5fJEFBLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsaSl9ayh0KXt0aGlzLl8kQUghPT10JiYodGhpcy5fJEFSKCksdGhpcy5fJEFIPXRoaXMuTSh0KSl9JCh0KXt0aGlzLl8kQUghPT13JiZyKHRoaXMuXyRBSCk/dGhpcy5fJEFBLm5leHRTaWJsaW5nLmRhdGE9dDp0aGlzLmsobC5jcmVhdGVUZXh0Tm9kZSh0KSksdGhpcy5fJEFIPXR9VCh0KXt2YXIgaTtjb25zdHt2YWx1ZXM6cyxfJGxpdFR5cGUkOmV9PXQsbz1cIm51bWJlclwiPT10eXBlb2YgZT90aGlzLl8kQUModCk6KHZvaWQgMD09PWUuZWwmJihlLmVsPUUuY3JlYXRlRWxlbWVudChlLmgsdGhpcy5vcHRpb25zKSksZSk7aWYoKG51bGw9PT0oaT10aGlzLl8kQUgpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLl8kQUQpPT09byl0aGlzLl8kQUgubShzKTtlbHNle2NvbnN0IHQ9bmV3IFYobyx0aGlzKSxpPXQucCh0aGlzLm9wdGlvbnMpO3QubShzKSx0aGlzLmsoaSksdGhpcy5fJEFIPXR9fV8kQUModCl7bGV0IGk9VC5nZXQodC5zdHJpbmdzKTtyZXR1cm4gdm9pZCAwPT09aSYmVC5zZXQodC5zdHJpbmdzLGk9bmV3IEUodCkpLGl9Uyh0KXtkKHRoaXMuXyRBSCl8fCh0aGlzLl8kQUg9W10sdGhpcy5fJEFSKCkpO2NvbnN0IGk9dGhpcy5fJEFIO2xldCBzLGU9MDtmb3IoY29uc3QgbyBvZiB0KWU9PT1pLmxlbmd0aD9pLnB1c2gocz1uZXcgTih0aGlzLk0oaCgpKSx0aGlzLk0oaCgpKSx0aGlzLHRoaXMub3B0aW9ucykpOnM9aVtlXSxzLl8kQUkobyksZSsrO2U8aS5sZW5ndGgmJih0aGlzLl8kQVIocyYmcy5fJEFCLm5leHRTaWJsaW5nLGUpLGkubGVuZ3RoPWUpfV8kQVIodD10aGlzLl8kQUEubmV4dFNpYmxpbmcsaSl7dmFyIHM7Zm9yKG51bGw9PT0ocz10aGlzLl8kQVApfHx2b2lkIDA9PT1zfHxzLmNhbGwodGhpcywhMSwhMCxpKTt0JiZ0IT09dGhpcy5fJEFCOyl7Y29uc3QgaT10Lm5leHRTaWJsaW5nO3QucmVtb3ZlKCksdD1pfX1zZXRDb25uZWN0ZWQodCl7dmFyIGk7dm9pZCAwPT09dGhpcy5fJEFNJiYodGhpcy5fJENnPXQsbnVsbD09PShpPXRoaXMuXyRBUCl8fHZvaWQgMD09PWl8fGkuY2FsbCh0aGlzLHQpKX19Y2xhc3MgU3tjb25zdHJ1Y3Rvcih0LGkscyxlLG8pe3RoaXMudHlwZT0xLHRoaXMuXyRBSD13LHRoaXMuXyRBTj12b2lkIDAsdGhpcy5lbGVtZW50PXQsdGhpcy5uYW1lPWksdGhpcy5fJEFNPWUsdGhpcy5vcHRpb25zPW8scy5sZW5ndGg+Mnx8XCJcIiE9PXNbMF18fFwiXCIhPT1zWzFdPyh0aGlzLl8kQUg9QXJyYXkocy5sZW5ndGgtMSkuZmlsbChuZXcgU3RyaW5nKSx0aGlzLnN0cmluZ3M9cyk6dGhpcy5fJEFIPXd9Z2V0IHRhZ05hbWUoKXtyZXR1cm4gdGhpcy5lbGVtZW50LnRhZ05hbWV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9XyRBSSh0LGk9dGhpcyxzLGUpe2NvbnN0IG89dGhpcy5zdHJpbmdzO2xldCBuPSExO2lmKHZvaWQgMD09PW8pdD1QKHRoaXMsdCxpLDApLG49IXIodCl8fHQhPT10aGlzLl8kQUgmJnQhPT1iLG4mJih0aGlzLl8kQUg9dCk7ZWxzZXtjb25zdCBlPXQ7bGV0IGwsaDtmb3IodD1vWzBdLGw9MDtsPG8ubGVuZ3RoLTE7bCsrKWg9UCh0aGlzLGVbcytsXSxpLGwpLGg9PT1iJiYoaD10aGlzLl8kQUhbbF0pLG58fChuPSFyKGgpfHxoIT09dGhpcy5fJEFIW2xdKSxoPT09dz90PXc6dCE9PXcmJih0Kz0obnVsbCE9aD9oOlwiXCIpK29bbCsxXSksdGhpcy5fJEFIW2xdPWh9biYmIWUmJnRoaXMuQyh0KX1DKHQpe3Q9PT13P3RoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKTp0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSxudWxsIT10P3Q6XCJcIil9fWNsYXNzIE0gZXh0ZW5kcyBTe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9M31DKHQpe3RoaXMuZWxlbWVudFt0aGlzLm5hbWVdPXQ9PT13P3ZvaWQgMDp0fX1jb25zdCBrPWk/aS5lbXB0eVNjcmlwdDpcIlwiO2NsYXNzIEggZXh0ZW5kcyBTe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9NH1DKHQpe3QmJnQhPT13P3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLGspOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKX19Y2xhc3MgSSBleHRlbmRzIFN7Y29uc3RydWN0b3IodCxpLHMsZSxvKXtzdXBlcih0LGkscyxlLG8pLHRoaXMudHlwZT01fV8kQUkodCxpPXRoaXMpe3ZhciBzO2lmKCh0PW51bGwhPT0ocz1QKHRoaXMsdCxpLDApKSYmdm9pZCAwIT09cz9zOncpPT09YilyZXR1cm47Y29uc3QgZT10aGlzLl8kQUgsbz10PT09dyYmZSE9PXd8fHQuY2FwdHVyZSE9PWUuY2FwdHVyZXx8dC5vbmNlIT09ZS5vbmNlfHx0LnBhc3NpdmUhPT1lLnBhc3NpdmUsbj10IT09dyYmKGU9PT13fHxvKTtvJiZ0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyxlKSxuJiZ0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyx0KSx0aGlzLl8kQUg9dH1oYW5kbGVFdmVudCh0KXt2YXIgaSxzO1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuXyRBSD90aGlzLl8kQUguY2FsbChudWxsIT09KHM9bnVsbD09PShpPXRoaXMub3B0aW9ucyl8fHZvaWQgMD09PWk/dm9pZCAwOmkuaG9zdCkmJnZvaWQgMCE9PXM/czp0aGlzLmVsZW1lbnQsdCk6dGhpcy5fJEFILmhhbmRsZUV2ZW50KHQpfX1jbGFzcyBMe2NvbnN0cnVjdG9yKHQsaSxzKXt0aGlzLmVsZW1lbnQ9dCx0aGlzLnR5cGU9Nix0aGlzLl8kQU49dm9pZCAwLHRoaXMuXyRBTT1pLHRoaXMub3B0aW9ucz1zfWdldCBfJEFVKCl7cmV0dXJuIHRoaXMuXyRBTS5fJEFVfV8kQUkodCl7UCh0aGlzLHQpfX1jb25zdCBSPXtMOlwiJGxpdCRcIixQOmUsVjpvLEk6MSxOOkMsUjpWLGo6dSxEOlAsSDpOLEY6UyxPOkgsVzpJLEI6TSxaOkx9LHo9d2luZG93LmxpdEh0bWxQb2x5ZmlsbFN1cHBvcnQ7bnVsbD09enx8eihFLE4pLChudWxsIT09KHQ9Z2xvYmFsVGhpcy5saXRIdG1sVmVyc2lvbnMpJiZ2b2lkIDAhPT10P3Q6Z2xvYmFsVGhpcy5saXRIdG1sVmVyc2lvbnM9W10pLnB1c2goXCIyLjIuM1wiKTtleHBvcnR7UiBhcyBfJExILCQgYXMgaHRtbCxiIGFzIG5vQ2hhbmdlLHcgYXMgbm90aGluZyx4IGFzIHJlbmRlcix5IGFzIHN2Z307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtaHRtbC5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuY29uc3QgdD13aW5kb3cuU2hhZG93Um9vdCYmKHZvaWQgMD09PXdpbmRvdy5TaGFkeUNTU3x8d2luZG93LlNoYWR5Q1NTLm5hdGl2ZVNoYWRvdykmJlwiYWRvcHRlZFN0eWxlU2hlZXRzXCJpbiBEb2N1bWVudC5wcm90b3R5cGUmJlwicmVwbGFjZVwiaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUsZT1TeW1ib2woKSxuPW5ldyBNYXA7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LG4pe2lmKHRoaXMuXyRjc3NSZXN1bHQkPSEwLG4hPT1lKXRocm93IEVycm9yKFwiQ1NTUmVzdWx0IGlzIG5vdCBjb25zdHJ1Y3RhYmxlLiBVc2UgYHVuc2FmZUNTU2Agb3IgYGNzc2AgaW5zdGVhZC5cIik7dGhpcy5jc3NUZXh0PXR9Z2V0IHN0eWxlU2hlZXQoKXtsZXQgZT1uLmdldCh0aGlzLmNzc1RleHQpO3JldHVybiB0JiZ2b2lkIDA9PT1lJiYobi5zZXQodGhpcy5jc3NUZXh0LGU9bmV3IENTU1N0eWxlU2hlZXQpLGUucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KSksZX10b1N0cmluZygpe3JldHVybiB0aGlzLmNzc1RleHR9fWNvbnN0IG89dD0+bmV3IHMoXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp0K1wiXCIsZSkscj0odCwuLi5uKT0+e2NvbnN0IG89MT09PXQubGVuZ3RoP3RbMF06bi5yZWR1Y2UoKChlLG4scyk9PmUrKHQ9PntpZighMD09PXQuXyRjc3NSZXN1bHQkKXJldHVybiB0LmNzc1RleHQ7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQ7dGhyb3cgRXJyb3IoXCJWYWx1ZSBwYXNzZWQgdG8gJ2NzcycgZnVuY3Rpb24gbXVzdCBiZSBhICdjc3MnIGZ1bmN0aW9uIHJlc3VsdDogXCIrdCtcIi4gVXNlICd1bnNhZmVDU1MnIHRvIHBhc3Mgbm9uLWxpdGVyYWwgdmFsdWVzLCBidXQgdGFrZSBjYXJlIHRvIGVuc3VyZSBwYWdlIHNlY3VyaXR5LlwiKX0pKG4pK3RbcysxXSksdFswXSk7cmV0dXJuIG5ldyBzKG8sZSl9LGk9KGUsbik9Pnt0P2UuYWRvcHRlZFN0eWxlU2hlZXRzPW4ubWFwKCh0PT50IGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldD90OnQuc3R5bGVTaGVldCkpOm4uZm9yRWFjaCgodD0+e2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLHM9d2luZG93LmxpdE5vbmNlO3ZvaWQgMCE9PXMmJm4uc2V0QXR0cmlidXRlKFwibm9uY2VcIixzKSxuLnRleHRDb250ZW50PXQuY3NzVGV4dCxlLmFwcGVuZENoaWxkKG4pfSkpfSxTPXQ/dD0+dDp0PT50IGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldD8odD0+e2xldCBlPVwiXCI7Zm9yKGNvbnN0IG4gb2YgdC5jc3NSdWxlcyllKz1uLmNzc1RleHQ7cmV0dXJuIG8oZSl9KSh0KTp0O2V4cG9ydHtzIGFzIENTU1Jlc3VsdCxpIGFzIGFkb3B0U3R5bGVzLHIgYXMgY3NzLFMgYXMgZ2V0Q29tcGF0aWJsZVN0eWxlLHQgYXMgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzLG8gYXMgdW5zYWZlQ1NTfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy10YWcuanMubWFwXG4iLCJpbXBvcnR7Z2V0Q29tcGF0aWJsZVN0eWxlIGFzIHQsYWRvcHRTdHlsZXMgYXMgaX1mcm9tXCIuL2Nzcy10YWcuanNcIjtleHBvcnR7Q1NTUmVzdWx0LGFkb3B0U3R5bGVzLGNzcyxnZXRDb21wYXRpYmxlU3R5bGUsc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzLHVuc2FmZUNTU31mcm9tXCIuL2Nzcy10YWcuanNcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL3ZhciBzO2NvbnN0IGU9d2luZG93LnRydXN0ZWRUeXBlcyxyPWU/ZS5lbXB0eVNjcmlwdDpcIlwiLGg9d2luZG93LnJlYWN0aXZlRWxlbWVudFBvbHlmaWxsU3VwcG9ydCxvPXt0b0F0dHJpYnV0ZSh0LGkpe3N3aXRjaChpKXtjYXNlIEJvb2xlYW46dD10P3I6bnVsbDticmVhaztjYXNlIE9iamVjdDpjYXNlIEFycmF5OnQ9bnVsbD09dD90OkpTT04uc3RyaW5naWZ5KHQpfXJldHVybiB0fSxmcm9tQXR0cmlidXRlKHQsaSl7bGV0IHM9dDtzd2l0Y2goaSl7Y2FzZSBCb29sZWFuOnM9bnVsbCE9PXQ7YnJlYWs7Y2FzZSBOdW1iZXI6cz1udWxsPT09dD9udWxsOk51bWJlcih0KTticmVhaztjYXNlIE9iamVjdDpjYXNlIEFycmF5OnRyeXtzPUpTT04ucGFyc2UodCl9Y2F0Y2godCl7cz1udWxsfX1yZXR1cm4gc319LG49KHQsaSk9PmkhPT10JiYoaT09aXx8dD09dCksbD17YXR0cmlidXRlOiEwLHR5cGU6U3RyaW5nLGNvbnZlcnRlcjpvLHJlZmxlY3Q6ITEsaGFzQ2hhbmdlZDpufTtjbGFzcyBhIGV4dGVuZHMgSFRNTEVsZW1lbnR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuXyRFdD1uZXcgTWFwLHRoaXMuaXNVcGRhdGVQZW5kaW5nPSExLHRoaXMuaGFzVXBkYXRlZD0hMSx0aGlzLl8kRWk9bnVsbCx0aGlzLm8oKX1zdGF0aWMgYWRkSW5pdGlhbGl6ZXIodCl7dmFyIGk7bnVsbCE9PShpPXRoaXMubCkmJnZvaWQgMCE9PWl8fCh0aGlzLmw9W10pLHRoaXMubC5wdXNoKHQpfXN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7dGhpcy5maW5hbGl6ZSgpO2NvbnN0IHQ9W107cmV0dXJuIHRoaXMuZWxlbWVudFByb3BlcnRpZXMuZm9yRWFjaCgoKGkscyk9Pntjb25zdCBlPXRoaXMuXyRFaChzLGkpO3ZvaWQgMCE9PWUmJih0aGlzLl8kRXUuc2V0KGUscyksdC5wdXNoKGUpKX0pKSx0fXN0YXRpYyBjcmVhdGVQcm9wZXJ0eSh0LGk9bCl7aWYoaS5zdGF0ZSYmKGkuYXR0cmlidXRlPSExKSx0aGlzLmZpbmFsaXplKCksdGhpcy5lbGVtZW50UHJvcGVydGllcy5zZXQodCxpKSwhaS5ub0FjY2Vzc29yJiYhdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkodCkpe2NvbnN0IHM9XCJzeW1ib2xcIj09dHlwZW9mIHQ/U3ltYm9sKCk6XCJfX1wiK3QsZT10aGlzLmdldFByb3BlcnR5RGVzY3JpcHRvcih0LHMsaSk7dm9pZCAwIT09ZSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLHQsZSl9fXN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IodCxpLHMpe3JldHVybntnZXQoKXtyZXR1cm4gdGhpc1tpXX0sc2V0KGUpe2NvbnN0IHI9dGhpc1t0XTt0aGlzW2ldPWUsdGhpcy5yZXF1ZXN0VXBkYXRlKHQscixzKX0sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9fXN0YXRpYyBnZXRQcm9wZXJ0eU9wdGlvbnModCl7cmV0dXJuIHRoaXMuZWxlbWVudFByb3BlcnRpZXMuZ2V0KHQpfHxsfXN0YXRpYyBmaW5hbGl6ZSgpe2lmKHRoaXMuaGFzT3duUHJvcGVydHkoXCJmaW5hbGl6ZWRcIikpcmV0dXJuITE7dGhpcy5maW5hbGl6ZWQ9ITA7Y29uc3QgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7aWYodC5maW5hbGl6ZSgpLHRoaXMuZWxlbWVudFByb3BlcnRpZXM9bmV3IE1hcCh0LmVsZW1lbnRQcm9wZXJ0aWVzKSx0aGlzLl8kRXU9bmV3IE1hcCx0aGlzLmhhc093blByb3BlcnR5KFwicHJvcGVydGllc1wiKSl7Y29uc3QgdD10aGlzLnByb3BlcnRpZXMsaT1bLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCksLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KV07Zm9yKGNvbnN0IHMgb2YgaSl0aGlzLmNyZWF0ZVByb3BlcnR5KHMsdFtzXSl9cmV0dXJuIHRoaXMuZWxlbWVudFN0eWxlcz10aGlzLmZpbmFsaXplU3R5bGVzKHRoaXMuc3R5bGVzKSwhMH1zdGF0aWMgZmluYWxpemVTdHlsZXMoaSl7Y29uc3Qgcz1bXTtpZihBcnJheS5pc0FycmF5KGkpKXtjb25zdCBlPW5ldyBTZXQoaS5mbGF0KDEvMCkucmV2ZXJzZSgpKTtmb3IoY29uc3QgaSBvZiBlKXMudW5zaGlmdCh0KGkpKX1lbHNlIHZvaWQgMCE9PWkmJnMucHVzaCh0KGkpKTtyZXR1cm4gc31zdGF0aWMgXyRFaCh0LGkpe2NvbnN0IHM9aS5hdHRyaWJ1dGU7cmV0dXJuITE9PT1zP3ZvaWQgMDpcInN0cmluZ1wiPT10eXBlb2Ygcz9zOlwic3RyaW5nXCI9PXR5cGVvZiB0P3QudG9Mb3dlckNhc2UoKTp2b2lkIDB9bygpe3ZhciB0O3RoaXMuXyRFcD1uZXcgUHJvbWlzZSgodD0+dGhpcy5lbmFibGVVcGRhdGluZz10KSksdGhpcy5fJEFMPW5ldyBNYXAsdGhpcy5fJEVtKCksdGhpcy5yZXF1ZXN0VXBkYXRlKCksbnVsbD09PSh0PXRoaXMuY29uc3RydWN0b3IubCl8fHZvaWQgMD09PXR8fHQuZm9yRWFjaCgodD0+dCh0aGlzKSkpfWFkZENvbnRyb2xsZXIodCl7dmFyIGksczsobnVsbCE9PShpPXRoaXMuXyRFZykmJnZvaWQgMCE9PWk/aTp0aGlzLl8kRWc9W10pLnB1c2godCksdm9pZCAwIT09dGhpcy5yZW5kZXJSb290JiZ0aGlzLmlzQ29ubmVjdGVkJiYobnVsbD09PShzPXQuaG9zdENvbm5lY3RlZCl8fHZvaWQgMD09PXN8fHMuY2FsbCh0KSl9cmVtb3ZlQ29udHJvbGxlcih0KXt2YXIgaTtudWxsPT09KGk9dGhpcy5fJEVnKXx8dm9pZCAwPT09aXx8aS5zcGxpY2UodGhpcy5fJEVnLmluZGV4T2YodCk+Pj4wLDEpfV8kRW0oKXt0aGlzLmNvbnN0cnVjdG9yLmVsZW1lbnRQcm9wZXJ0aWVzLmZvckVhY2goKCh0LGkpPT57dGhpcy5oYXNPd25Qcm9wZXJ0eShpKSYmKHRoaXMuXyRFdC5zZXQoaSx0aGlzW2ldKSxkZWxldGUgdGhpc1tpXSl9KSl9Y3JlYXRlUmVuZGVyUm9vdCgpe3ZhciB0O2NvbnN0IHM9bnVsbCE9PSh0PXRoaXMuc2hhZG93Um9vdCkmJnZvaWQgMCE9PXQ/dDp0aGlzLmF0dGFjaFNoYWRvdyh0aGlzLmNvbnN0cnVjdG9yLnNoYWRvd1Jvb3RPcHRpb25zKTtyZXR1cm4gaShzLHRoaXMuY29uc3RydWN0b3IuZWxlbWVudFN0eWxlcyksc31jb25uZWN0ZWRDYWxsYmFjaygpe3ZhciB0O3ZvaWQgMD09PXRoaXMucmVuZGVyUm9vdCYmKHRoaXMucmVuZGVyUm9vdD10aGlzLmNyZWF0ZVJlbmRlclJvb3QoKSksdGhpcy5lbmFibGVVcGRhdGluZyghMCksbnVsbD09PSh0PXRoaXMuXyRFZyl8fHZvaWQgMD09PXR8fHQuZm9yRWFjaCgodD0+e3ZhciBpO3JldHVybiBudWxsPT09KGk9dC5ob3N0Q29ubmVjdGVkKXx8dm9pZCAwPT09aT92b2lkIDA6aS5jYWxsKHQpfSkpfWVuYWJsZVVwZGF0aW5nKHQpe31kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3ZhciB0O251bGw9PT0odD10aGlzLl8kRWcpfHx2b2lkIDA9PT10fHx0LmZvckVhY2goKHQ9Pnt2YXIgaTtyZXR1cm4gbnVsbD09PShpPXQuaG9zdERpc2Nvbm5lY3RlZCl8fHZvaWQgMD09PWk/dm9pZCAwOmkuY2FsbCh0KX0pKX1hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodCxpLHMpe3RoaXMuXyRBSyh0LHMpfV8kRVModCxpLHM9bCl7dmFyIGUscjtjb25zdCBoPXRoaXMuY29uc3RydWN0b3IuXyRFaCh0LHMpO2lmKHZvaWQgMCE9PWgmJiEwPT09cy5yZWZsZWN0KXtjb25zdCBuPShudWxsIT09KHI9bnVsbD09PShlPXMuY29udmVydGVyKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS50b0F0dHJpYnV0ZSkmJnZvaWQgMCE9PXI/cjpvLnRvQXR0cmlidXRlKShpLHMudHlwZSk7dGhpcy5fJEVpPXQsbnVsbD09bj90aGlzLnJlbW92ZUF0dHJpYnV0ZShoKTp0aGlzLnNldEF0dHJpYnV0ZShoLG4pLHRoaXMuXyRFaT1udWxsfX1fJEFLKHQsaSl7dmFyIHMsZSxyO2NvbnN0IGg9dGhpcy5jb25zdHJ1Y3RvcixuPWguXyRFdS5nZXQodCk7aWYodm9pZCAwIT09biYmdGhpcy5fJEVpIT09bil7Y29uc3QgdD1oLmdldFByb3BlcnR5T3B0aW9ucyhuKSxsPXQuY29udmVydGVyLGE9bnVsbCE9PShyPW51bGwhPT0oZT1udWxsPT09KHM9bCl8fHZvaWQgMD09PXM/dm9pZCAwOnMuZnJvbUF0dHJpYnV0ZSkmJnZvaWQgMCE9PWU/ZTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2w6bnVsbCkmJnZvaWQgMCE9PXI/cjpvLmZyb21BdHRyaWJ1dGU7dGhpcy5fJEVpPW4sdGhpc1tuXT1hKGksdC50eXBlKSx0aGlzLl8kRWk9bnVsbH19cmVxdWVzdFVwZGF0ZSh0LGkscyl7bGV0IGU9ITA7dm9pZCAwIT09dCYmKCgocz1zfHx0aGlzLmNvbnN0cnVjdG9yLmdldFByb3BlcnR5T3B0aW9ucyh0KSkuaGFzQ2hhbmdlZHx8bikodGhpc1t0XSxpKT8odGhpcy5fJEFMLmhhcyh0KXx8dGhpcy5fJEFMLnNldCh0LGkpLCEwPT09cy5yZWZsZWN0JiZ0aGlzLl8kRWkhPT10JiYodm9pZCAwPT09dGhpcy5fJEVDJiYodGhpcy5fJEVDPW5ldyBNYXApLHRoaXMuXyRFQy5zZXQodCxzKSkpOmU9ITEpLCF0aGlzLmlzVXBkYXRlUGVuZGluZyYmZSYmKHRoaXMuXyRFcD10aGlzLl8kRV8oKSl9YXN5bmMgXyRFXygpe3RoaXMuaXNVcGRhdGVQZW5kaW5nPSEwO3RyeXthd2FpdCB0aGlzLl8kRXB9Y2F0Y2godCl7UHJvbWlzZS5yZWplY3QodCl9Y29uc3QgdD10aGlzLnNjaGVkdWxlVXBkYXRlKCk7cmV0dXJuIG51bGwhPXQmJmF3YWl0IHQsIXRoaXMuaXNVcGRhdGVQZW5kaW5nfXNjaGVkdWxlVXBkYXRlKCl7cmV0dXJuIHRoaXMucGVyZm9ybVVwZGF0ZSgpfXBlcmZvcm1VcGRhdGUoKXt2YXIgdDtpZighdGhpcy5pc1VwZGF0ZVBlbmRpbmcpcmV0dXJuO3RoaXMuaGFzVXBkYXRlZCx0aGlzLl8kRXQmJih0aGlzLl8kRXQuZm9yRWFjaCgoKHQsaSk9PnRoaXNbaV09dCkpLHRoaXMuXyRFdD12b2lkIDApO2xldCBpPSExO2NvbnN0IHM9dGhpcy5fJEFMO3RyeXtpPXRoaXMuc2hvdWxkVXBkYXRlKHMpLGk/KHRoaXMud2lsbFVwZGF0ZShzKSxudWxsPT09KHQ9dGhpcy5fJEVnKXx8dm9pZCAwPT09dHx8dC5mb3JFYWNoKCh0PT57dmFyIGk7cmV0dXJuIG51bGw9PT0oaT10Lmhvc3RVcGRhdGUpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmNhbGwodCl9KSksdGhpcy51cGRhdGUocykpOnRoaXMuXyRFVSgpfWNhdGNoKHQpe3Rocm93IGk9ITEsdGhpcy5fJEVVKCksdH1pJiZ0aGlzLl8kQUUocyl9d2lsbFVwZGF0ZSh0KXt9XyRBRSh0KXt2YXIgaTtudWxsPT09KGk9dGhpcy5fJEVnKXx8dm9pZCAwPT09aXx8aS5mb3JFYWNoKCh0PT57dmFyIGk7cmV0dXJuIG51bGw9PT0oaT10Lmhvc3RVcGRhdGVkKXx8dm9pZCAwPT09aT92b2lkIDA6aS5jYWxsKHQpfSkpLHRoaXMuaGFzVXBkYXRlZHx8KHRoaXMuaGFzVXBkYXRlZD0hMCx0aGlzLmZpcnN0VXBkYXRlZCh0KSksdGhpcy51cGRhdGVkKHQpfV8kRVUoKXt0aGlzLl8kQUw9bmV3IE1hcCx0aGlzLmlzVXBkYXRlUGVuZGluZz0hMX1nZXQgdXBkYXRlQ29tcGxldGUoKXtyZXR1cm4gdGhpcy5nZXRVcGRhdGVDb21wbGV0ZSgpfWdldFVwZGF0ZUNvbXBsZXRlKCl7cmV0dXJuIHRoaXMuXyRFcH1zaG91bGRVcGRhdGUodCl7cmV0dXJuITB9dXBkYXRlKHQpe3ZvaWQgMCE9PXRoaXMuXyRFQyYmKHRoaXMuXyRFQy5mb3JFYWNoKCgodCxpKT0+dGhpcy5fJEVTKGksdGhpc1tpXSx0KSkpLHRoaXMuXyRFQz12b2lkIDApLHRoaXMuXyRFVSgpfXVwZGF0ZWQodCl7fWZpcnN0VXBkYXRlZCh0KXt9fWEuZmluYWxpemVkPSEwLGEuZWxlbWVudFByb3BlcnRpZXM9bmV3IE1hcCxhLmVsZW1lbnRTdHlsZXM9W10sYS5zaGFkb3dSb290T3B0aW9ucz17bW9kZTpcIm9wZW5cIn0sbnVsbD09aHx8aCh7UmVhY3RpdmVFbGVtZW50OmF9KSwobnVsbCE9PShzPWdsb2JhbFRoaXMucmVhY3RpdmVFbGVtZW50VmVyc2lvbnMpJiZ2b2lkIDAhPT1zP3M6Z2xvYmFsVGhpcy5yZWFjdGl2ZUVsZW1lbnRWZXJzaW9ucz1bXSkucHVzaChcIjEuMy4yXCIpO2V4cG9ydHthIGFzIFJlYWN0aXZlRWxlbWVudCxvIGFzIGRlZmF1bHRDb252ZXJ0ZXIsbiBhcyBub3RFcXVhbH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdGl2ZS1lbGVtZW50LmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG52YXIgdDtjb25zdCBpPWdsb2JhbFRoaXMudHJ1c3RlZFR5cGVzLHM9aT9pLmNyZWF0ZVBvbGljeShcImxpdC1odG1sXCIse2NyZWF0ZUhUTUw6dD0+dH0pOnZvaWQgMCxlPWBsaXQkJHsoTWF0aC5yYW5kb20oKStcIlwiKS5zbGljZSg5KX0kYCxvPVwiP1wiK2Usbj1gPCR7b30+YCxsPWRvY3VtZW50LGg9KHQ9XCJcIik9PmwuY3JlYXRlQ29tbWVudCh0KSxyPXQ9Pm51bGw9PT10fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdCxkPUFycmF5LmlzQXJyYXksdT10PT57dmFyIGk7cmV0dXJuIGQodCl8fFwiZnVuY3Rpb25cIj09dHlwZW9mKG51bGw9PT0oaT10KXx8dm9pZCAwPT09aT92b2lkIDA6aVtTeW1ib2wuaXRlcmF0b3JdKX0sYz0vPCg/OighLS18XFwvW15hLXpBLVpdKXwoXFwvP1thLXpBLVpdW14+XFxzXSopfChcXC8/JCkpL2csdj0vLS0+L2csYT0vPi9nLGY9Lz58WyBcdFxcblxmXFxyXSg/OihbXlxcc1wiJz49L10rKShbIFx0XFxuXGZcXHJdKj1bIFx0XFxuXGZcXHJdKig/OlteIFx0XFxuXGZcXHJcIidgPD49XXwoXCJ8Jyl8KSl8JCkvZyxfPS8nL2csbT0vXCIvZyxnPS9eKD86c2NyaXB0fHN0eWxlfHRleHRhcmVhfHRpdGxlKSQvaSxwPXQ9PihpLC4uLnMpPT4oe18kbGl0VHlwZSQ6dCxzdHJpbmdzOmksdmFsdWVzOnN9KSwkPXAoMSkseT1wKDIpLGI9U3ltYm9sLmZvcihcImxpdC1ub0NoYW5nZVwiKSx3PVN5bWJvbC5mb3IoXCJsaXQtbm90aGluZ1wiKSxUPW5ldyBXZWFrTWFwLHg9KHQsaSxzKT0+e3ZhciBlLG87Y29uc3Qgbj1udWxsIT09KGU9bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1lP2U6aTtsZXQgbD1uLl8kbGl0UGFydCQ7aWYodm9pZCAwPT09bCl7Y29uc3QgdD1udWxsIT09KG89bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1vP286bnVsbDtuLl8kbGl0UGFydCQ9bD1uZXcgTihpLmluc2VydEJlZm9yZShoKCksdCksdCx2b2lkIDAsbnVsbCE9cz9zOnt9KX1yZXR1cm4gbC5fJEFJKHQpLGx9LEE9bC5jcmVhdGVUcmVlV2Fsa2VyKGwsMTI5LG51bGwsITEpLEM9KHQsaSk9Pntjb25zdCBvPXQubGVuZ3RoLTEsbD1bXTtsZXQgaCxyPTI9PT1pP1wiPHN2Zz5cIjpcIlwiLGQ9Yztmb3IobGV0IGk9MDtpPG87aSsrKXtjb25zdCBzPXRbaV07bGV0IG8sdSxwPS0xLCQ9MDtmb3IoOyQ8cy5sZW5ndGgmJihkLmxhc3RJbmRleD0kLHU9ZC5leGVjKHMpLG51bGwhPT11KTspJD1kLmxhc3RJbmRleCxkPT09Yz9cIiEtLVwiPT09dVsxXT9kPXY6dm9pZCAwIT09dVsxXT9kPWE6dm9pZCAwIT09dVsyXT8oZy50ZXN0KHVbMl0pJiYoaD1SZWdFeHAoXCI8L1wiK3VbMl0sXCJnXCIpKSxkPWYpOnZvaWQgMCE9PXVbM10mJihkPWYpOmQ9PT1mP1wiPlwiPT09dVswXT8oZD1udWxsIT1oP2g6YyxwPS0xKTp2b2lkIDA9PT11WzFdP3A9LTI6KHA9ZC5sYXN0SW5kZXgtdVsyXS5sZW5ndGgsbz11WzFdLGQ9dm9pZCAwPT09dVszXT9mOidcIic9PT11WzNdP206Xyk6ZD09PW18fGQ9PT1fP2Q9ZjpkPT09dnx8ZD09PWE/ZD1jOihkPWYsaD12b2lkIDApO2NvbnN0IHk9ZD09PWYmJnRbaSsxXS5zdGFydHNXaXRoKFwiLz5cIik/XCIgXCI6XCJcIjtyKz1kPT09Yz9zK246cD49MD8obC5wdXNoKG8pLHMuc2xpY2UoMCxwKStcIiRsaXQkXCIrcy5zbGljZShwKStlK3kpOnMrZSsoLTI9PT1wPyhsLnB1c2godm9pZCAwKSxpKTp5KX1jb25zdCB1PXIrKHRbb118fFwiPD8+XCIpKygyPT09aT9cIjwvc3ZnPlwiOlwiXCIpO2lmKCFBcnJheS5pc0FycmF5KHQpfHwhdC5oYXNPd25Qcm9wZXJ0eShcInJhd1wiKSl0aHJvdyBFcnJvcihcImludmFsaWQgdGVtcGxhdGUgc3RyaW5ncyBhcnJheVwiKTtyZXR1cm5bdm9pZCAwIT09cz9zLmNyZWF0ZUhUTUwodSk6dSxsXX07Y2xhc3MgRXtjb25zdHJ1Y3Rvcih7c3RyaW5nczp0LF8kbGl0VHlwZSQ6c30sbil7bGV0IGw7dGhpcy5wYXJ0cz1bXTtsZXQgcj0wLGQ9MDtjb25zdCB1PXQubGVuZ3RoLTEsYz10aGlzLnBhcnRzLFt2LGFdPUModCxzKTtpZih0aGlzLmVsPUUuY3JlYXRlRWxlbWVudCh2LG4pLEEuY3VycmVudE5vZGU9dGhpcy5lbC5jb250ZW50LDI9PT1zKXtjb25zdCB0PXRoaXMuZWwuY29udGVudCxpPXQuZmlyc3RDaGlsZDtpLnJlbW92ZSgpLHQuYXBwZW5kKC4uLmkuY2hpbGROb2Rlcyl9Zm9yKDtudWxsIT09KGw9QS5uZXh0Tm9kZSgpKSYmYy5sZW5ndGg8dTspe2lmKDE9PT1sLm5vZGVUeXBlKXtpZihsLmhhc0F0dHJpYnV0ZXMoKSl7Y29uc3QgdD1bXTtmb3IoY29uc3QgaSBvZiBsLmdldEF0dHJpYnV0ZU5hbWVzKCkpaWYoaS5lbmRzV2l0aChcIiRsaXQkXCIpfHxpLnN0YXJ0c1dpdGgoZSkpe2NvbnN0IHM9YVtkKytdO2lmKHQucHVzaChpKSx2b2lkIDAhPT1zKXtjb25zdCB0PWwuZ2V0QXR0cmlidXRlKHMudG9Mb3dlckNhc2UoKStcIiRsaXQkXCIpLnNwbGl0KGUpLGk9LyhbLj9AXSk/KC4qKS8uZXhlYyhzKTtjLnB1c2goe3R5cGU6MSxpbmRleDpyLG5hbWU6aVsyXSxzdHJpbmdzOnQsY3RvcjpcIi5cIj09PWlbMV0/TTpcIj9cIj09PWlbMV0/SDpcIkBcIj09PWlbMV0/STpTfSl9ZWxzZSBjLnB1c2goe3R5cGU6NixpbmRleDpyfSl9Zm9yKGNvbnN0IGkgb2YgdClsLnJlbW92ZUF0dHJpYnV0ZShpKX1pZihnLnRlc3QobC50YWdOYW1lKSl7Y29uc3QgdD1sLnRleHRDb250ZW50LnNwbGl0KGUpLHM9dC5sZW5ndGgtMTtpZihzPjApe2wudGV4dENvbnRlbnQ9aT9pLmVtcHR5U2NyaXB0OlwiXCI7Zm9yKGxldCBpPTA7aTxzO2krKylsLmFwcGVuZCh0W2ldLGgoKSksQS5uZXh0Tm9kZSgpLGMucHVzaCh7dHlwZToyLGluZGV4Oisrcn0pO2wuYXBwZW5kKHRbc10saCgpKX19fWVsc2UgaWYoOD09PWwubm9kZVR5cGUpaWYobC5kYXRhPT09byljLnB1c2goe3R5cGU6MixpbmRleDpyfSk7ZWxzZXtsZXQgdD0tMTtmb3IoOy0xIT09KHQ9bC5kYXRhLmluZGV4T2YoZSx0KzEpKTspYy5wdXNoKHt0eXBlOjcsaW5kZXg6cn0pLHQrPWUubGVuZ3RoLTF9cisrfX1zdGF0aWMgY3JlYXRlRWxlbWVudCh0LGkpe2NvbnN0IHM9bC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7cmV0dXJuIHMuaW5uZXJIVE1MPXQsc319ZnVuY3Rpb24gUCh0LGkscz10LGUpe3ZhciBvLG4sbCxoO2lmKGk9PT1iKXJldHVybiBpO2xldCBkPXZvaWQgMCE9PWU/bnVsbD09PShvPXMuXyRDbCl8fHZvaWQgMD09PW8/dm9pZCAwOm9bZV06cy5fJEN1O2NvbnN0IHU9cihpKT92b2lkIDA6aS5fJGxpdERpcmVjdGl2ZSQ7cmV0dXJuKG51bGw9PWQ/dm9pZCAwOmQuY29uc3RydWN0b3IpIT09dSYmKG51bGw9PT0obj1udWxsPT1kP3ZvaWQgMDpkLl8kQU8pfHx2b2lkIDA9PT1ufHxuLmNhbGwoZCwhMSksdm9pZCAwPT09dT9kPXZvaWQgMDooZD1uZXcgdSh0KSxkLl8kQVQodCxzLGUpKSx2b2lkIDAhPT1lPyhudWxsIT09KGw9KGg9cykuXyRDbCkmJnZvaWQgMCE9PWw/bDpoLl8kQ2w9W10pW2VdPWQ6cy5fJEN1PWQpLHZvaWQgMCE9PWQmJihpPVAodCxkLl8kQVModCxpLnZhbHVlcyksZCxlKSksaX1jbGFzcyBWe2NvbnN0cnVjdG9yKHQsaSl7dGhpcy52PVtdLHRoaXMuXyRBTj12b2lkIDAsdGhpcy5fJEFEPXQsdGhpcy5fJEFNPWl9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5fJEFNLnBhcmVudE5vZGV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9cCh0KXt2YXIgaTtjb25zdHtlbDp7Y29udGVudDpzfSxwYXJ0czplfT10aGlzLl8kQUQsbz0obnVsbCE9PShpPW51bGw9PXQ/dm9pZCAwOnQuY3JlYXRpb25TY29wZSkmJnZvaWQgMCE9PWk/aTpsKS5pbXBvcnROb2RlKHMsITApO0EuY3VycmVudE5vZGU9bztsZXQgbj1BLm5leHROb2RlKCksaD0wLHI9MCxkPWVbMF07Zm9yKDt2b2lkIDAhPT1kOyl7aWYoaD09PWQuaW5kZXgpe2xldCBpOzI9PT1kLnR5cGU/aT1uZXcgTihuLG4ubmV4dFNpYmxpbmcsdGhpcyx0KToxPT09ZC50eXBlP2k9bmV3IGQuY3RvcihuLGQubmFtZSxkLnN0cmluZ3MsdGhpcyx0KTo2PT09ZC50eXBlJiYoaT1uZXcgTChuLHRoaXMsdCkpLHRoaXMudi5wdXNoKGkpLGQ9ZVsrK3JdfWghPT0obnVsbD09ZD92b2lkIDA6ZC5pbmRleCkmJihuPUEubmV4dE5vZGUoKSxoKyspfXJldHVybiBvfW0odCl7bGV0IGk9MDtmb3IoY29uc3QgcyBvZiB0aGlzLnYpdm9pZCAwIT09cyYmKHZvaWQgMCE9PXMuc3RyaW5ncz8ocy5fJEFJKHQscyxpKSxpKz1zLnN0cmluZ3MubGVuZ3RoLTIpOnMuXyRBSSh0W2ldKSksaSsrfX1jbGFzcyBOe2NvbnN0cnVjdG9yKHQsaSxzLGUpe3ZhciBvO3RoaXMudHlwZT0yLHRoaXMuXyRBSD13LHRoaXMuXyRBTj12b2lkIDAsdGhpcy5fJEFBPXQsdGhpcy5fJEFCPWksdGhpcy5fJEFNPXMsdGhpcy5vcHRpb25zPWUsdGhpcy5fJENnPW51bGw9PT0obz1udWxsPT1lP3ZvaWQgMDplLmlzQ29ubmVjdGVkKXx8dm9pZCAwPT09b3x8b31nZXQgXyRBVSgpe3ZhciB0LGk7cmV0dXJuIG51bGwhPT0oaT1udWxsPT09KHQ9dGhpcy5fJEFNKXx8dm9pZCAwPT09dD92b2lkIDA6dC5fJEFVKSYmdm9pZCAwIT09aT9pOnRoaXMuXyRDZ31nZXQgcGFyZW50Tm9kZSgpe2xldCB0PXRoaXMuXyRBQS5wYXJlbnROb2RlO2NvbnN0IGk9dGhpcy5fJEFNO3JldHVybiB2b2lkIDAhPT1pJiYxMT09PXQubm9kZVR5cGUmJih0PWkucGFyZW50Tm9kZSksdH1nZXQgc3RhcnROb2RlKCl7cmV0dXJuIHRoaXMuXyRBQX1nZXQgZW5kTm9kZSgpe3JldHVybiB0aGlzLl8kQUJ9XyRBSSh0LGk9dGhpcyl7dD1QKHRoaXMsdCxpKSxyKHQpP3Q9PT13fHxudWxsPT10fHxcIlwiPT09dD8odGhpcy5fJEFIIT09dyYmdGhpcy5fJEFSKCksdGhpcy5fJEFIPXcpOnQhPT10aGlzLl8kQUgmJnQhPT1iJiZ0aGlzLiQodCk6dm9pZCAwIT09dC5fJGxpdFR5cGUkP3RoaXMuVCh0KTp2b2lkIDAhPT10Lm5vZGVUeXBlP3RoaXMuayh0KTp1KHQpP3RoaXMuUyh0KTp0aGlzLiQodCl9TSh0LGk9dGhpcy5fJEFCKXtyZXR1cm4gdGhpcy5fJEFBLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsaSl9ayh0KXt0aGlzLl8kQUghPT10JiYodGhpcy5fJEFSKCksdGhpcy5fJEFIPXRoaXMuTSh0KSl9JCh0KXt0aGlzLl8kQUghPT13JiZyKHRoaXMuXyRBSCk/dGhpcy5fJEFBLm5leHRTaWJsaW5nLmRhdGE9dDp0aGlzLmsobC5jcmVhdGVUZXh0Tm9kZSh0KSksdGhpcy5fJEFIPXR9VCh0KXt2YXIgaTtjb25zdHt2YWx1ZXM6cyxfJGxpdFR5cGUkOmV9PXQsbz1cIm51bWJlclwiPT10eXBlb2YgZT90aGlzLl8kQUModCk6KHZvaWQgMD09PWUuZWwmJihlLmVsPUUuY3JlYXRlRWxlbWVudChlLmgsdGhpcy5vcHRpb25zKSksZSk7aWYoKG51bGw9PT0oaT10aGlzLl8kQUgpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLl8kQUQpPT09byl0aGlzLl8kQUgubShzKTtlbHNle2NvbnN0IHQ9bmV3IFYobyx0aGlzKSxpPXQucCh0aGlzLm9wdGlvbnMpO3QubShzKSx0aGlzLmsoaSksdGhpcy5fJEFIPXR9fV8kQUModCl7bGV0IGk9VC5nZXQodC5zdHJpbmdzKTtyZXR1cm4gdm9pZCAwPT09aSYmVC5zZXQodC5zdHJpbmdzLGk9bmV3IEUodCkpLGl9Uyh0KXtkKHRoaXMuXyRBSCl8fCh0aGlzLl8kQUg9W10sdGhpcy5fJEFSKCkpO2NvbnN0IGk9dGhpcy5fJEFIO2xldCBzLGU9MDtmb3IoY29uc3QgbyBvZiB0KWU9PT1pLmxlbmd0aD9pLnB1c2gocz1uZXcgTih0aGlzLk0oaCgpKSx0aGlzLk0oaCgpKSx0aGlzLHRoaXMub3B0aW9ucykpOnM9aVtlXSxzLl8kQUkobyksZSsrO2U8aS5sZW5ndGgmJih0aGlzLl8kQVIocyYmcy5fJEFCLm5leHRTaWJsaW5nLGUpLGkubGVuZ3RoPWUpfV8kQVIodD10aGlzLl8kQUEubmV4dFNpYmxpbmcsaSl7dmFyIHM7Zm9yKG51bGw9PT0ocz10aGlzLl8kQVApfHx2b2lkIDA9PT1zfHxzLmNhbGwodGhpcywhMSwhMCxpKTt0JiZ0IT09dGhpcy5fJEFCOyl7Y29uc3QgaT10Lm5leHRTaWJsaW5nO3QucmVtb3ZlKCksdD1pfX1zZXRDb25uZWN0ZWQodCl7dmFyIGk7dm9pZCAwPT09dGhpcy5fJEFNJiYodGhpcy5fJENnPXQsbnVsbD09PShpPXRoaXMuXyRBUCl8fHZvaWQgMD09PWl8fGkuY2FsbCh0aGlzLHQpKX19Y2xhc3MgU3tjb25zdHJ1Y3Rvcih0LGkscyxlLG8pe3RoaXMudHlwZT0xLHRoaXMuXyRBSD13LHRoaXMuXyRBTj12b2lkIDAsdGhpcy5lbGVtZW50PXQsdGhpcy5uYW1lPWksdGhpcy5fJEFNPWUsdGhpcy5vcHRpb25zPW8scy5sZW5ndGg+Mnx8XCJcIiE9PXNbMF18fFwiXCIhPT1zWzFdPyh0aGlzLl8kQUg9QXJyYXkocy5sZW5ndGgtMSkuZmlsbChuZXcgU3RyaW5nKSx0aGlzLnN0cmluZ3M9cyk6dGhpcy5fJEFIPXd9Z2V0IHRhZ05hbWUoKXtyZXR1cm4gdGhpcy5lbGVtZW50LnRhZ05hbWV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9XyRBSSh0LGk9dGhpcyxzLGUpe2NvbnN0IG89dGhpcy5zdHJpbmdzO2xldCBuPSExO2lmKHZvaWQgMD09PW8pdD1QKHRoaXMsdCxpLDApLG49IXIodCl8fHQhPT10aGlzLl8kQUgmJnQhPT1iLG4mJih0aGlzLl8kQUg9dCk7ZWxzZXtjb25zdCBlPXQ7bGV0IGwsaDtmb3IodD1vWzBdLGw9MDtsPG8ubGVuZ3RoLTE7bCsrKWg9UCh0aGlzLGVbcytsXSxpLGwpLGg9PT1iJiYoaD10aGlzLl8kQUhbbF0pLG58fChuPSFyKGgpfHxoIT09dGhpcy5fJEFIW2xdKSxoPT09dz90PXc6dCE9PXcmJih0Kz0obnVsbCE9aD9oOlwiXCIpK29bbCsxXSksdGhpcy5fJEFIW2xdPWh9biYmIWUmJnRoaXMuQyh0KX1DKHQpe3Q9PT13P3RoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKTp0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSxudWxsIT10P3Q6XCJcIil9fWNsYXNzIE0gZXh0ZW5kcyBTe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9M31DKHQpe3RoaXMuZWxlbWVudFt0aGlzLm5hbWVdPXQ9PT13P3ZvaWQgMDp0fX1jb25zdCBrPWk/aS5lbXB0eVNjcmlwdDpcIlwiO2NsYXNzIEggZXh0ZW5kcyBTe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9NH1DKHQpe3QmJnQhPT13P3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLGspOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKX19Y2xhc3MgSSBleHRlbmRzIFN7Y29uc3RydWN0b3IodCxpLHMsZSxvKXtzdXBlcih0LGkscyxlLG8pLHRoaXMudHlwZT01fV8kQUkodCxpPXRoaXMpe3ZhciBzO2lmKCh0PW51bGwhPT0ocz1QKHRoaXMsdCxpLDApKSYmdm9pZCAwIT09cz9zOncpPT09YilyZXR1cm47Y29uc3QgZT10aGlzLl8kQUgsbz10PT09dyYmZSE9PXd8fHQuY2FwdHVyZSE9PWUuY2FwdHVyZXx8dC5vbmNlIT09ZS5vbmNlfHx0LnBhc3NpdmUhPT1lLnBhc3NpdmUsbj10IT09dyYmKGU9PT13fHxvKTtvJiZ0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyxlKSxuJiZ0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyx0KSx0aGlzLl8kQUg9dH1oYW5kbGVFdmVudCh0KXt2YXIgaSxzO1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuXyRBSD90aGlzLl8kQUguY2FsbChudWxsIT09KHM9bnVsbD09PShpPXRoaXMub3B0aW9ucyl8fHZvaWQgMD09PWk/dm9pZCAwOmkuaG9zdCkmJnZvaWQgMCE9PXM/czp0aGlzLmVsZW1lbnQsdCk6dGhpcy5fJEFILmhhbmRsZUV2ZW50KHQpfX1jbGFzcyBMe2NvbnN0cnVjdG9yKHQsaSxzKXt0aGlzLmVsZW1lbnQ9dCx0aGlzLnR5cGU9Nix0aGlzLl8kQU49dm9pZCAwLHRoaXMuXyRBTT1pLHRoaXMub3B0aW9ucz1zfWdldCBfJEFVKCl7cmV0dXJuIHRoaXMuXyRBTS5fJEFVfV8kQUkodCl7UCh0aGlzLHQpfX1jb25zdCBSPXtMOlwiJGxpdCRcIixQOmUsVjpvLEk6MSxOOkMsUjpWLGo6dSxEOlAsSDpOLEY6UyxPOkgsVzpJLEI6TSxaOkx9LHo9d2luZG93LmxpdEh0bWxQb2x5ZmlsbFN1cHBvcnQ7bnVsbD09enx8eihFLE4pLChudWxsIT09KHQ9Z2xvYmFsVGhpcy5saXRIdG1sVmVyc2lvbnMpJiZ2b2lkIDAhPT10P3Q6Z2xvYmFsVGhpcy5saXRIdG1sVmVyc2lvbnM9W10pLnB1c2goXCIyLjIuM1wiKTtleHBvcnR7UiBhcyBfJExILCQgYXMgaHRtbCxiIGFzIG5vQ2hhbmdlLHcgYXMgbm90aGluZyx4IGFzIHJlbmRlcix5IGFzIHN2Z307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtaHRtbC5qcy5tYXBcbiIsImltcG9ydHtSZWFjdGl2ZUVsZW1lbnQgYXMgdH1mcm9tXCJAbGl0L3JlYWN0aXZlLWVsZW1lbnRcIjtleHBvcnQqZnJvbVwiQGxpdC9yZWFjdGl2ZS1lbGVtZW50XCI7aW1wb3J0e3JlbmRlciBhcyBlLG5vQ2hhbmdlIGFzIGl9ZnJvbVwibGl0LWh0bWxcIjtleHBvcnQqZnJvbVwibGl0LWh0bWxcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL3ZhciBsLG87Y29uc3Qgcj10O2NsYXNzIHMgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnJlbmRlck9wdGlvbnM9e2hvc3Q6dGhpc30sdGhpcy5fJER0PXZvaWQgMH1jcmVhdGVSZW5kZXJSb290KCl7dmFyIHQsZTtjb25zdCBpPXN1cGVyLmNyZWF0ZVJlbmRlclJvb3QoKTtyZXR1cm4gbnVsbCE9PSh0PShlPXRoaXMucmVuZGVyT3B0aW9ucykucmVuZGVyQmVmb3JlKSYmdm9pZCAwIT09dHx8KGUucmVuZGVyQmVmb3JlPWkuZmlyc3RDaGlsZCksaX11cGRhdGUodCl7Y29uc3QgaT10aGlzLnJlbmRlcigpO3RoaXMuaGFzVXBkYXRlZHx8KHRoaXMucmVuZGVyT3B0aW9ucy5pc0Nvbm5lY3RlZD10aGlzLmlzQ29ubmVjdGVkKSxzdXBlci51cGRhdGUodCksdGhpcy5fJER0PWUoaSx0aGlzLnJlbmRlclJvb3QsdGhpcy5yZW5kZXJPcHRpb25zKX1jb25uZWN0ZWRDYWxsYmFjaygpe3ZhciB0O3N1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCksbnVsbD09PSh0PXRoaXMuXyREdCl8fHZvaWQgMD09PXR8fHQuc2V0Q29ubmVjdGVkKCEwKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3ZhciB0O3N1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCksbnVsbD09PSh0PXRoaXMuXyREdCl8fHZvaWQgMD09PXR8fHQuc2V0Q29ubmVjdGVkKCExKX1yZW5kZXIoKXtyZXR1cm4gaX19cy5maW5hbGl6ZWQ9ITAscy5fJGxpdEVsZW1lbnQkPSEwLG51bGw9PT0obD1nbG9iYWxUaGlzLmxpdEVsZW1lbnRIeWRyYXRlU3VwcG9ydCl8fHZvaWQgMD09PWx8fGwuY2FsbChnbG9iYWxUaGlzLHtMaXRFbGVtZW50OnN9KTtjb25zdCBuPWdsb2JhbFRoaXMubGl0RWxlbWVudFBvbHlmaWxsU3VwcG9ydDtudWxsPT1ufHxuKHtMaXRFbGVtZW50OnN9KTtjb25zdCBoPXtfJEFLOih0LGUsaSk9Pnt0Ll8kQUsoZSxpKX0sXyRBTDp0PT50Ll8kQUx9OyhudWxsIT09KG89Z2xvYmFsVGhpcy5saXRFbGVtZW50VmVyc2lvbnMpJiZ2b2lkIDAhPT1vP286Z2xvYmFsVGhpcy5saXRFbGVtZW50VmVyc2lvbnM9W10pLnB1c2goXCIzLjIuMFwiKTtleHBvcnR7cyBhcyBMaXRFbGVtZW50LHIgYXMgVXBkYXRpbmdFbGVtZW50LGggYXMgXyRMRX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtZWxlbWVudC5qcy5tYXBcbiIsIi8qXG5hbGwgZWxlbWVudCBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MgdG8gaGFuZGxlIGdsb2JhbCB0aGluZ3Mgc3VjaCBhc1xudXNlclNlbGVjdCwgaWRzLCBldGMuXG4qL1xuaW1wb3J0IHsgTGl0RWxlbWVudCB9IGZyb20gJ2xpdCc7XG5cbi8vIGV4dGVuZGluZyBsaXQtZWxlbWVudCBleGFtcGxlcyA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9saXQtZWxlbWVudC9pc3N1ZXMvNDUwXG5cbmxldCBpZCA9IDA7XG5cbmNvbnN0IHVzZXJTZWxlY3ROb25lT25Cb2R5UmVnaXN0ZXIgPSBuZXcgU2V0KCk7XG5cbmNsYXNzIFNjRWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc2NJZCA9IGAke3RoaXMuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpfS0ke2lkKyt9YDtcbiAgfVxuXG4gIF9wcmV2ZW50Q29udGV4dE1lbnUoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIF9yZXF1ZXN0VXNlclNlbGVjdE5vbmVPbkJvZHkoKSB7XG4gICAgaWYgKHVzZXJTZWxlY3ROb25lT25Cb2R5UmVnaXN0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHVzZXJTZWxlY3ROb25lT25Cb2R5UmVnaXN0ZXIuYWRkKHRoaXMuX3NjSWQpO1xuICB9XG5cbiAgX2NhbmNlbFVzZXJTZWxlY3ROb25lT25Cb2R5KCnCoHtcbiAgICB1c2VyU2VsZWN0Tm9uZU9uQm9keVJlZ2lzdGVyLmRlbGV0ZSh0aGlzLl9zY0lkKTtcblxuICAgIGlmICh1c2VyU2VsZWN0Tm9uZU9uQm9keVJlZ2lzdGVyLnNpemUgPT09IDApIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9ICdhdXRvJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NFbGVtZW50O1xuIiwiaW1wb3J0IHsgaHRtbCwgY3NzIH0gZnJvbSAnbGl0JztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuXG5jbGFzcyBTY1Bvc2l0aW9uU3VyZmFjZSBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeFJhbmdlOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBhdHRyaWJ1dGU6ICd4LXJhbmdlJyxcbiAgICAgIH0sXG4gICAgICB5UmFuZ2U6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGF0dHJpYnV0ZTogJ3ktcmFuZ2UnLFxuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBjbGFtcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBhdHRyaWJ1dGU6ICdjbGFtcCcsXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIH07XG4gICAgYDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnhSYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnlSYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLmNsYW1wUG9zaXRpb25zID0gZmFsc2U7XG5cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucG9pbnRlcklkcyA9IFtdOyAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIG9yZGVyIG9mIGFwcGVhcmFuY2UgY29uc2lzdGFudFxuXG4gICAgdGhpcy5tb3VzZU1vdmUgPSB0aGlzLm1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubW91c2VVcCA9IHRoaXMubW91c2VVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG91Y2hTdGFydCA9IHRoaXMudG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG91Y2hNb3ZlID0gdGhpcy50b3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRvdWNoRW5kID0gdGhpcy50b3VjaEVuZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVWYWx1ZXMgPSB0aGlzLnByb3BhZ2F0ZVZhbHVlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgaXMgb2sgYXMgdGhlIHN1cmZhY2UgaXMgbm90IHJlbmRlcmVkIG9mdGVuXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlKCkge1xuICAgIGNvbnN0IHhEZWx0YSA9IHRoaXMueFJhbmdlWzFdIC0gdGhpcy54UmFuZ2VbMF07XG4gICAgY29uc3QgeURlbHRhID0gdGhpcy55UmFuZ2VbMV0gLSB0aGlzLnlSYW5nZVswXTtcblxuICAgIHRoaXMucHgyeCA9IChweCkgPT4ge1xuICAgICAgbGV0IHZhbCA9IHB4IC8gdGhpcy53aWR0aCAqIHhEZWx0YSArIHRoaXMueFJhbmdlWzBdO1xuXG4gICAgICBpZiAodGhpcy5jbGFtcFBvc2l0aW9ucykge1xuICAgICAgICB2YWwgPSBNYXRoLm1pbih0aGlzLnhSYW5nZVsxXSwgTWF0aC5tYXgodGhpcy54UmFuZ2VbMF0sIHZhbCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHRoaXMucHgyeSA9IChweCkgPT4ge1xuICAgICAgbGV0IHZhbCA9IHB4IC8gdGhpcy5oZWlnaHQgKiB5RGVsdGEgKyB0aGlzLnlSYW5nZVswXTtcblxuICAgICAgaWYgKHRoaXMuY2xhbXBQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFsID0gTWF0aC5taW4odGhpcy55UmFuZ2VbMV0sIE1hdGgubWF4KHRoaXMueVJhbmdlWzBdLCB2YWwpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBzdXBlci5wZXJmb3JtVXBkYXRlKCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPVwid2lkdGg6ICR7dGhpcy53aWR0aH1weDsgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1wiXG5cbiAgICAgICAgQG1vdXNlZG93bj1cIiR7dGhpcy5tb3VzZURvd259XCJcbiAgICAgICAgQHRvdWNoc3RhcnQ9XCIke3tcbiAgICAgICAgICBoYW5kbGVFdmVudDogdGhpcy50b3VjaFN0YXJ0LFxuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9fVwiXG4gICAgICAgIEBjb250ZXh0bWVudT1cIiR7dGhpcy5fcHJldmVudENvbnRleHRNZW51fVwiXG4gICAgICA+PC9kaXY+XG4gICAgYFxuICB9XG5cbiAgbW91c2VEb3duKGUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuXG4gICAgdGhpcy5wb2ludGVySWRzLnB1c2goJ21vdXNlJyk7XG4gICAgdGhpcy5hY3RpdmVQb2ludGVycy5zZXQoJ21vdXNlJywgZSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0VXNlclNlbGVjdE5vbmVPbkJvZHkoKTtcblxuICAgIHRoaXMucmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyhlKTtcbiAgfVxuXG4gIG1vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5hY3RpdmVQb2ludGVycy5zZXQoJ21vdXNlJywgZSk7XG4gICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKGUpO1xuICB9XG5cbiAgbW91c2VVcChlKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2VVcCk7XG5cbiAgICB0aGlzLnBvaW50ZXJJZHMuc3BsaWNlKHRoaXMucG9pbnRlcklkcy5pbmRleE9mKCdtb3VzZScpKTtcbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzLmRlbGV0ZSgnbW91c2UnKTtcblxuICAgIHRoaXMuX2NhbmNlbFVzZXJTZWxlY3ROb25lT25Cb2R5KCk7XG5cbiAgICAvLyBwcm9wYWdhdGUgb3V0c2lkZSB0aGUgc2hhZG93IGRvbSBib3VkYXJpZXNcbiAgICAvLyBjZi4gaHR0cHM6Ly9saXQtZWxlbWVudC5wb2x5bWVyLXByb2plY3Qub3JnL2d1aWRlL2V2ZW50cyNjdXN0b20tZXZlbnRzXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3BvaW50ZXJlbmQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgcG9pbnRlcklkOiAnbW91c2UnIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKGUpO1xuICB9XG5cbiAgdG91Y2hTdGFydChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpT1MgbmVlZHMgdGhhdCB0byBwcmV2ZW50IHNjcm9sbGluZ1xuXG4gICAgaWYgKHRoaXMucG9pbnRlcklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnRvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy50b3VjaEVuZCk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RVc2VyU2VsZWN0Tm9uZU9uQm9keSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IHRvdWNoIG9mIGUuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgIGNvbnN0IGlkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHRoaXMucG9pbnRlcklkcy5wdXNoKGlkKTtcbiAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnMuc2V0KGlkLCB0b3VjaCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKGUpO1xuICB9XG5cbiAgdG91Y2hNb3ZlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cbiAgICBmb3IgKGxldCB0b3VjaCBvZiBlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBjb25zdCBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAvLyBvbmx5IGNvbnNpZGVyIHRvdWNoZXMgdGhhdCBzdGFydGVkIGluIHRoZSBhcmVhXG4gICAgICBpZiAodGhpcy5wb2ludGVySWRzLmluZGV4T2YoaWQpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzLnNldChpZCwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyhlKTtcbiAgfVxuXG4gIHRvdWNoRW5kKGUpIHtcbiAgICBmb3IgKGxldCB0b3VjaCBvZiBlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBjb25zdCBwb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBvaW50ZXJJZHMuaW5kZXhPZihwb2ludGVySWQpO1xuICAgICAgLy8gb25seSBjb25zaWRlciB0cmFja2VkIHRvdWNoZXNcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5wb2ludGVySWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG5cbiAgICAgICAgLy8gcHJvcGFnYXRlIG91dHNpZGUgdGhlIHNoYWRvdyBkb20gYm91ZGFyaWVzXG4gICAgICAgIC8vIGNmLiBodHRwczovL2xpdC1lbGVtZW50LnBvbHltZXItcHJvamVjdC5vcmcvZ3VpZGUvZXZlbnRzI2N1c3RvbS1ldmVudHNcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3BvaW50ZXJlbmQnLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICBkZXRhaWw6IHsgcG9pbnRlcklkIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhhdCdzIHRoZSBsYXN0IHRyYWNrZWQgZXZlbnQgcmVtb3ZlIGxpc3RlbmVyc1xuICAgIGlmICh0aGlzLnBvaW50ZXJJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy50b3VjaEVuZCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLnRvdWNoRW5kKTtcblxuICAgICAgdGhpcy5fY2FuY2VsVXNlclNlbGVjdE5vbmVPbkJvZHkoZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKGUpO1xuICB9XG5cbiAgcmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyhlKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgIHRoaXMucmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucHJvcGFnYXRlVmFsdWVzKGUpKTtcbiAgfVxuXG4gIHByb3BhZ2F0ZVZhbHVlcyhlKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnBvaW50ZXJJZHMubWFwKHBvaW50ZXJJZCA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYWN0aXZlUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCk7XG4gICAgICAvLyB0aGlzIHNlZW1zIHF1aXRlIHJvYnVzdFxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU2NzcvaG93LWRvLWktZ2V0LXRoZS1jb29yZGluYXRlcy1vZi1hLW1vdXNlLWNsaWNrLW9uLWEtY2FudmFzLWVsZW1lbnQvMTgwNTM2NDIjMTgwNTM2NDJcbiAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3Qgc2NhbGVkWCA9IHRoaXMucHgyeCh4KTtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICBjb25zdCBzY2FsZWRZID0gdGhpcy5weDJ5KHkpO1xuXG4gICAgICByZXR1cm4geyB4OiBzY2FsZWRYLCB5OiBzY2FsZWRZLCBwb2ludGVySWQgfTtcbiAgICB9KTtcblxuICAgIC8vIHByb3BhZ2F0ZSBvdXRzaWRlIHRoZSBzaGFkb3cgZG9tIGJvdWRhcmllc1xuICAgIC8vIGNmLiBodHRwczovL2xpdC1lbGVtZW50LnBvbHltZXItcHJvamVjdC5vcmcvZ3VpZGUvZXZlbnRzI2N1c3RvbS1ldmVudHNcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnaW5wdXQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgdmFsdWU6IHZhbHVlcyB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjLXBvc2l0aW9uLXN1cmZhY2UnLCBTY1Bvc2l0aW9uU3VyZmFjZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjUG9zaXRpb25TdXJmYWNlO1xuIiwiaW1wb3J0IHsgaHRtbCwgY3NzIH0gZnJvbSAnbGl0JztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuXG5mdW5jdGlvbiBnZXRUaW1lKCkge1xuICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxufVxuXG5jbGFzcyBTY1NwZWVkU3VyZmFjZSBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIH07XG4gICAgYDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLndpZHRoID0gMjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMjAwO1xuXG4gICAgdGhpcy5wb2ludGVySWQgPSBudWxsO1xuICAgIHRoaXMubGFzdFBvaW50ZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdFRpbWUgPSBudWxsO1xuXG4gICAgdGhpcy5tb3VzZU1vdmUgPSB0aGlzLm1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubW91c2VVcCA9IHRoaXMubW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50b3VjaFN0YXJ0ID0gdGhpcy50b3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy50b3VjaE1vdmUgPSB0aGlzLnRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG91Y2hFbmQgPSB0aGlzLnRvdWNoRW5kLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVZhbHVlcyA9IHRoaXMucHJvcGFnYXRlVmFsdWVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgIFwiXG4gICAgICAgIEBtb3VzZWRvd249XCIke3RoaXMubW91c2VEb3dufVwiXG4gICAgICAgIEB0b3VjaHN0YXJ0PVwiJHt7XG4gICAgICAgICAgaGFuZGxlRXZlbnQ6IHRoaXMudG91Y2hTdGFydCxcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgfX1cIlxuICAgICAgICBAY29udGV4dG1lbnU9XCIke3RoaXMuX3ByZXZlbnRDb250ZXh0TWVudX1cIlxuICAgICAgPjwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBtb3VzZURvd24oZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuXG4gICAgdGhpcy5fcmVxdWVzdFVzZXJTZWxlY3ROb25lT25Cb2R5KCk7XG4gICAgdGhpcy5wb2ludGVySWQgPSAnbW91c2UnO1xuXG4gICAgdGhpcy5sYXN0VGltZSA9IGdldFRpbWUoKTtcbiAgICB0aGlzLmxhc3RQb2ludGVyID0gZTtcbiAgfVxuXG4gIG1vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKGUpO1xuICB9XG5cbiAgbW91c2VVcChlKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2VVcCk7XG5cbiAgICB0aGlzLl9jYW5jZWxVc2VyU2VsZWN0Tm9uZU9uQm9keSgpO1xuICAgIHRoaXMucmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyhlKTtcbiAgICAvLyB3ZSB3YW50IHRvIGhhdmUgeyBkeDogMCwgZHk6IDAgfSBvbiBtb3VzZSB1cCxcbiAgICAvLyB3aXRoIDIwbXMsIHdlIHNob3VsZCBiZSBpbiB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucG9pbnRlcklkID0gbnVsbDtcbiAgICAgIHRoaXMucmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyhlKTtcbiAgICB9LCAyMCk7XG4gIH1cblxuICAvLyBAZXZlbnRPcHRpb25zKHsgcGFzc2l2ZTogZmFsc2UgfSlcbiAgdG91Y2hTdGFydChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXG4gICAgaWYgKHRoaXMucG9pbnRlcklkID09PSBudWxsKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICB0aGlzLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXI7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnRvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy50b3VjaEVuZCk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RVc2VyU2VsZWN0Tm9uZU9uQm9keSgpO1xuXG4gICAgICB0aGlzLmxhc3RUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgdGhpcy5sYXN0UG9pbnRlciA9IHRvdWNoO1xuICAgIH1cbiAgfVxuXG4gIHRvdWNoTW92ZShlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXG4gICAgZm9yIChsZXQgdG91Y2ggb2YgZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucG9pbnRlcklkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFByb3BhZ2F0ZVZhbHVlcyh0b3VjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG91Y2hFbmQoZSkge1xuICAgIGZvciAobGV0IHRvdWNoIG9mIGUuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnBvaW50ZXJJZCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnRvdWNoRW5kKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy50b3VjaEVuZCk7XG5cbiAgICAgICAgdGhpcy5fY2FuY2VsVXNlclNlbGVjdE5vbmVPbkJvZHkoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKHRvdWNoKTtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBoYXZlIHsgZHg6IDAsIGR5OiAwIH0gb24gbW91c2UgdXAsXG4gICAgICAgIC8vIHdpdGggMjBtcywgd2Ugc2hvdWxkIGJlIGluIHRoZSBuZXh0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0UHJvcGFnYXRlVmFsdWVzKHRvdWNoKTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RQcm9wYWdhdGVWYWx1ZXMoZSkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICB0aGlzLnJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnByb3BhZ2F0ZVZhbHVlcyhlKSk7XG4gIH1cblxuICAvLyByZXR1cm4gc3BlZWQgaW4gcHggLyBtc1xuICBwcm9wYWdhdGVWYWx1ZXMoZSkge1xuICAgIGNvbnN0IGxhc3RYID0gdGhpcy5sYXN0UG9pbnRlci5zY3JlZW5YO1xuICAgIGNvbnN0IGxhc3RZID0gdGhpcy5sYXN0UG9pbnRlci5zY3JlZW5ZO1xuICAgIGNvbnN0IHggPSBlLnNjcmVlblg7XG4gICAgY29uc3QgeSA9IGUuc2NyZWVuWTtcblxuICAgIGNvbnN0IG5vdyA9IGdldFRpbWUoKTtcbiAgICBjb25zdCBkdCA9ICh0aGlzLmxhc3RUaW1lIC0gbm93KTtcblxuICAgIGNvbnN0IGR4ID0gKHggLSBsYXN0WCkgLyBkdDtcbiAgICBjb25zdCBkeSA9ICh5IC0gbGFzdFkpIC8gZHQ7XG5cbiAgICB0aGlzLmxhc3RUaW1lID0gbm93O1xuICAgIHRoaXMubGFzdFBvaW50ZXIgPSBlO1xuICAgIC8vIHByb3BhZ2F0ZSBvdXRzaWRlIHRoZSBzaGFkb3cgZG9tIGJvdWRhcmllc1xuICAgIC8vIGNmLiBodHRwczovL2xpdC1lbGVtZW50LnBvbHltZXItcHJvamVjdC5vcmcvZ3VpZGUvZXZlbnRzI2N1c3RvbS1ldmVudHNcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnaW5wdXQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgZHgsIGR5LCBwb2ludGVySWQ6IHRoaXMucG9pbnRlcklkIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc2Mtc3BlZWQtc3VyZmFjZScsIFNjU3BlZWRTdXJmYWNlKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NTcGVlZFN1cmZhY2U7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdsaXQnO1xuXG4vLyBAdG9kbyAtIHJldmlldyB0aGF0Li4uIG5vdCBjbGVhblxuZXhwb3J0IGNvbnN0IGZvbnRGYW1pbHkgPSBjc3NgQ29uc29sYXMsIG1vbmFjbywgbW9ub3NwYWNlYDtcbmV4cG9ydCBjb25zdCBmb250U2l6ZSA9IGNzc2AxMXB4YDtcblxuZXhwb3J0IGNvbnN0IHRoZW1lID0ge307XG50aGVtZVsnLS1jb2xvci1wcmltYXJ5LTAnXSA9IGNzc2AjMTIxMjEyZmZgO1xudGhlbWVbJy0tY29sb3ItcHJpbWFyeS0xJ10gPSBjc3NgIzI3MjgyMmZmYDtcbnRoZW1lWyctLWNvbG9yLXByaW1hcnktMiddID0gY3NzYCMzZDNlMzlmZmA7XG50aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXSA9IGNzc2AjNmE2YTY5ZmZgO1xudGhlbWVbJy0tY29sb3ItcHJpbWFyeS00J10gPSBjc3NgI2RlZGVkZWZmYDtcbnRoZW1lWyctLWNvbG9yLXNlY29uZGFyeS0xJ10gPSBjc3NgI2YwZGI0ZmZmYDsgLy8geWVsbG93XG50aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMiddID0gY3NzYCMxYzc4YzBmZmA7IC8vIGJsdWVcbnRoZW1lWyctLWNvbG9yLXNlY29uZGFyeS0zJ10gPSBjc3NgI2Q5NTM0ZmZmYDsgLy8gcmVkXG50aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktNCddID0gY3NzYCM1ZWM0NTFmZmA7IC8vIGdyZWVuXG5cbi8vIGV4cG9ydCBjb25zdCB1c2VyU2VsZWN0Tm9uZSA9IGNzc2Bcbi8vICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXG4vLyAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXG4vLyAgICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsgLyogS29ucXVlcm9yIEhUTUwgKi9cbi8vICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBPbGQgdmVyc2lvbnMgb2YgRmlyZWZveCAqL1xuLy8gICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cbi8vICAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lOyAvKiBOb24tcHJlZml4ZWQgdmVyc2lvbiwgY3VycmVudGx5XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkIGJ5IENocm9tZSwgRWRnZSwgT3BlcmEgYW5kIEZpcmVmb3ggKi9cbi8vIGBcblxuLy8gZXhwb3J0IGNvbnN0IGxhcmdlQnRuID0gY3NzYFxuLy8gICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcbi8vICAgY29sb3I6IHdoaXRlO1xuLy8gICBmb250LXNpemU6IDEuNnJlbTtcbi8vICAgd2lkdGg6IDEwMCU7XG4vLyAgIGJvcmRlcjogMXB4IHNvbGlkICM2NzY3Njc7XG4vLyAgIGJvcmRlci1yYWRpdXM6IDJweDtcbi8vICAgYmFja2dyb3VuZC1jb2xvcjogIzEyMTIxMjtcbi8vICAgaGVpZ2h0OiAzNnB4O1xuLy8gICBsaW5lLWhlaWdodDogMzZweDtcbi8vIGA7XG5cbi8vIGV4cG9ydCBjb25zdCBpbmZvID0gY3NzYFxuLy8gICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcbi8vICAgY29sb3I6IHdoaXRlO1xuLy8gICBmb250LXNpemU6IDEuMnJlbTtcbi8vICAgd2lkdGg6IDEwMCU7XG4vLyAgIHRleHQtYWxpZ246IGNlbnRlcjtcbi8vICAgaGVpZ2h0OiAzNnB4O1xuLy8gICBsaW5lLWhlaWdodDogMzZweDtcbi8vIGA7XG5cbmV4cG9ydCBjb25zdCBhcnJvdyA9IGNzc2BkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQVFBQUFEWmM3Si9BQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQ0JqU0ZKTkFBQjZKZ0FBZ0lRQUFQb0FBQUNBNkFBQWRUQUFBT3BnQUFBNm1BQUFGM0NjdWxFOEFBQUFBbUpMUjBRQS80ZVB6TDhBQUFBSmNFaFpjd0FBRHNRQUFBN0VBWlVyRGhzQUFBQUhkRWxOUlFma0NBVUtCVEwrbUdqVUFBQUFlVWxFUVZSSXgrM09NUTZBSUJCRTBhOTNzTUxFazFoNFk3V3c5bVJpUlVJTTZqSlVHb2I2L1FYcWZyQ0drYmJBSHcwYkUxNCt2OFBBakJmZndnRGdXQ1MrNHNKWGxFVEVsY1NGNXlZU1BDZHh3NjJKQjI1SnZQQzNoSUUvSll6OExwSEJVNGxNZmswSVBFNklQQ1JXZXBVRGRIUWx2TzRqT3dGd2d1MU5DckJvL3dBQUFDVjBSVmgwWkdGMFpUcGpjbVZoZEdVQU1qQXlNQzB3T0Mwd05WUXhNRG93TlRvME9Tc3dNRG93TUJXUXgzb0FBQUFsZEVWWWRHUmhkR1U2Ylc5a2FXWjVBREl3TWpBdE1EZ3RNRFZVTVRBNk1EVTZORGtyTURBNk1EQmt6WC9HQUFBQUlIUkZXSFJ6YjJaMGQyRnlaUUJvZEhSd2N6b3ZMMmx0WVdkbGJXRm5hV05yTG05eVo3elBIWjBBQUFBWWRFVllkRlJvZFcxaU9qcEViMk4xYldWdWREbzZVR0ZuWlhNQU1hZi91eThBQUFBWWRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNlNHVnBaMmgwQURVeE1vK05VNEVBQUFBWGRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNlYybGtkR2dBTlRFeUhId0QzQUFBQUJsMFJWaDBWR2gxYldJNk9rMXBiV1YwZVhCbEFHbHRZV2RsTDNCdVp6K3lWazRBQUFBWGRFVllkRlJvZFcxaU9qcE5WR2x0WlFBeE5UazJOakl4T1RRNVFWbjhnQUFBQUJKMFJWaDBWR2gxYldJNk9sTnBlbVVBTXpJMk1FSkN3MGxrK2dBQUFGUjBSVmgwVkdoMWJXSTZPbFZTU1FCbWFXeGxPaTh2TGk5MWNHeHZZV1J6THpVMkwyVjRkSGczYkdRdk1qUTFOaTlwYm1ScFkyRjBiM0pmWVhKeWIzZGZkSEpwWVc1bmJHVmZhV052Ymw4eE5Ea3dNakF1Y0c1bjJHdnhpQUFBQUFCSlJVNUVya0pnZ2c9PWA7XG5cbmV4cG9ydCBjb25zdCBhcnJvd1JpZ2h0ID0gY3NzYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRUFBQUFCQUNBUUFBQUFBWUxsVkFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFDQmpTRkpOQUFCNkpnQUFnSVFBQVBvQUFBQ0E2QUFBZFRBQUFPcGdBQUE2bUFBQUYzQ2N1bEU4QUFBQUFtSkxSMFFBLzRlUHpMOEFBQUFKY0VoWmN3QUE3RGdBQU93NEFYRXJ5amdBQUFBSGRFbE5SUWZsQXhRTERTOEFyRFo4QUFBQ2drbEVRVlJvM3UzWlQwZ1VVUnpBOGUrc3N0Z1NsbXRnOU1lQ0lvS0tJSVFDdTBUWklieElCZG1oS0R4Wmh3N21RWUlDUVJDc1UxQjRDQThSZUpFZytuTXBLUWpCVFQwVUVSSGxZbVFHR1VXWW1PdDBhSG05SWMyWk43LzlMWVJ2Ym52WStmRG16L2U5WFZnYVJSNGw4Mzdxa1NiRmRQRlloM25HRUdkWVVaelRWekNJajg4TXQ5bE5RaDlRVFJZL2YzeWdsVlhGQlBqTThvQzl1dk1RQlBqNFRIQ0oxZnFBS2NhWXl4TnlQS2FPVWwzQUtBZTV3WGN6RDVOMHNrNFRrS1dhSkkyTW1IbVlJME1EU1UwQXdFYXU4ZFhNd3pldXNra1hBRWthR0NSbkVNODV6akpOQU1CYXV2aHNDRlAwc0UwWEFDVWM0cWsxRDY4NXpYSk5BRUFWN1V3WXdqUzk3TUxUQkVDQ2ZUeGsxaUN5bkpXTzFyOEJBSlcwOGQ0UXhLTzFPQUE4OW5DSG1jSkVLd3dBb0p4enZDdEV0TUlDd0dNbnZmeVFqbFo0QUVDS0psNFpRbzRuOGFNVkRRQ3dsUjdKYUVVSFFKbGt0RndBSUJndFY0Qll0TndCSUJLdGVBQ0JhTVVGUU14b1NRQitSK3RSSUZxTnVnQ0FORzE4TVlRTTZmbWNoUjAvOGFPZlMrb1MxSExmdWdSam5OSUVWSEdCajlaTjJFZU4zazFZeWdINnJjZndEYzJhaitFYTJnTXZvbHRzai9vVmNWN0Y5UXlZSlBtODRLVG1xM2dEbHdNeDZtYXp3d3c2QXNvNHdyQ1Y0MkdPYXVaNEM5MkJCY2tWMXJ1ZVBEb2d4UWxlV2t1eUFlcjFsbVFlTzdocExVby8wYUc1S0Mybm1iZldzcnlmL1hyTDhnUTE5RmtiazNFdWFtNU1LbWtKYk0zdVVhdTNOZnM3TXEyc2xEdjVZb0JZa1lrTGlCMlplQUNCeUxnRGhDTGpDaENMakFzZ0tSbVpxSUJSNnJndUdabW9nT0NQMVFLUmlRcjRjd2hGeGcwZ0dCa1hnR2hrd280MG1YeGs3c3BHSnZ3NHhoQWpuTmY0Mjg1YjROTUtQQ2F0ZmQzUytIL0hMd3VzUFdrem1GU0FBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURJeExUQXpMVEl3VkRFeE9qRXpPalEzS3pBd09qQXdSeE40R0FBQUFDVjBSVmgwWkdGMFpUcHRiMlJwWm5rQU1qQXlNUzB3TXkweU1GUXhNVG94TXpvME55c3dNRG93TURaT3dLUUFBQUFnZEVWWWRITnZablIzWVhKbEFHaDBkSEJ6T2k4dmFXMWhaMlZ0WVdkcFkyc3ViM0pudk04ZG5RQUFBQmgwUlZoMFZHaDFiV0k2T2tSdlkzVnRaVzUwT2pwUVlXZGxjd0F4cC8rN0x3QUFBQmgwUlZoMFZHaDFiV0k2T2tsdFlXZGxPanBJWldsbmFIUUFOVEV5ajQxVGdRQUFBQmQwUlZoMFZHaDFiV0k2T2tsdFlXZGxPanBYYVdSMGFBQTFNVEljZkFQY0FBQUFHWFJGV0hSVWFIVnRZam82VFdsdFpYUjVjR1VBYVcxaFoyVXZjRzVuUDdKV1RnQUFBQmQwUlZoMFZHaDFiV0k2T2sxVWFXMWxBREUyTVRZeU16ZzRNamZBNkI5cUFBQUFFblJGV0hSVWFIVnRZam82VTJsNlpRQTFNVFU1UWtKUDFHbFdBQUFBVUhSRldIUlVhSFZ0WWpvNlZWSkpBR1pwYkdVNkx5OHVMM1Z3Ykc5aFpITXZOVFl2YUVwSVpuVnhjQzh5T1RBeUwyRnljbTkzWDNKcFoyaDBYM1J5YVdGdVoyeGxYMmxqYjI1Zk1UZ3pNVEl4TG5CdVo4R2dsWlFBQUFBQVNVVk9SSzVDWUlJPWA7XG5cbmV4cG9ydCBjb25zdCBhcnJvd0Rvd24gPSBjc3NgZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFZ0FBQUJJQ0FRQUFBRC81SHZNQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk5BQUI2SmdBQWdJUUFBUG9BQUFDQTZBQUFkVEFBQU9wZ0FBQTZtQUFBRjNDY3VsRThBQUFBQW1KTFIwUUEvNGVQekw4QUFBQUpjRWhaY3dBQTdEZ0FBT3c0QVhFcnlqZ0FBQUFIZEVsTlJRZmxBeFFMRFI4bWRRYlFBQUFEb2tsRVFWUm8zdTJaWFVnVVVSaUduMjAxVnluTkc3VXIwZFNnSDAwaVNGRHNQMEdpd0N5S0NvdWdrQWdNaWlDaHJ2cTdFSTJndWlqb3g2SWZpcUlMSVpLUUtBZ3ZLb3hJeXJLOE1DckZ6REoxMnk0NmZqdHF1anN6WjNhOW1IZHZabWUvN3ozdmZOK1pzKytjQVJjdVhMaHdNYm5oR2ZGdEt0NG9hUEF6OEQ5QnNheG5FMGtFSWw2U0hxNXhpOEhSUDZ5Z20wQ1VQdDJVRHN1WUlvS3ltUkhoMmdReGcrS3hndDd5UFdxQ2Vta2FQb3lSazAzY1lLYzZIdUlGdmFNbXZGNEVtRTZlakg2ZEIyTUYvZVlFaTVrSGdJZXJuSGIwanZPemh3WHF1SVdUL1A1LzJGWitxV24yaHJrT3lvRTV2RkVqL1dMYitHRUpYSlNaZnhtZlkzSjhYSkp4THBJd1VXZ3ViU3J3SnpzY0U3U1puMnFVTm5KREJWZlNyNEpmTTlzUk9UbTBxQkg2cVF3ZFBvMmJVczZ6RHJUTngxbmh2OG0wY0ZMeWFWY0pQeWpUTHFpTUg0cTluZnh3ay9ZenBKS2FTZGNxSjUxbXhUekVnZkRUa3JrdlpUMWxXS3ZzSW9ZNjRiMVBzcG5VSWpwVjRqZEt0QWtxNFp0aTdhVElYS3FIZy9oVjhsTm1hcEV6a3llSzBjOUI4MzlNS1RSS2VZOXArQnZ4Y3BRL2l1OHhxVllvbHZCRkVYeGxsVzFCSy9rcWJLdXRYdE14YWR0RGE5Y2tTT1dodE10R3ZkTjRyR2orVUczRGpuaW9OclFyemM2VnJhVkhFWFZRWUptbGdBN0Ywc002TzNJZ2xscVoyZzNtVmc1Qk1nM0NVVXVzUFVHUXlYTkZObWpsWmdYMk1xQVlucE5wVnc1QU9iMks4Qk1MVFdjdjVLUEs3bVdERGprUXh6a3ArUjBTVGVVbWNsdHl6eEduUnhCa2lvTVpZTGVwek4zU3JoWm02WklEVUNFZXI1VzhzTE55YVJYL3VWMm5ISWczdU8wckU3dGdRODRWeWJsRXZGNUJNSjkzaXJ5UExXRmxiS0ZQWmJ4anZtNDVBTHNNOHlFclpIU1c1WGtYTmhLNUlTMDRIOEp0K3pndnNYZE4zcGtta005N1dWUEtKNHdNcmwwZldPU1VISUFxYVZzekdlTkdaWWh6SHFES1NUbVF5RDFwUmQwNGJ0dm9uTzg1MTY1aEZJdmI3Z3B1TTQxQUtWM2luSXROc2x1QWgwTVR1dTAwbm9vVk8rVG9sbzRnaFVkaTIwNk9hcHVYSXlMM2tVMlhhUUpMRFc1NytZaGZsaHVjODdKSXlRRXZ4OFdTTnBKaXFGMmoxTzU0WkxlWTB3elBXTlZ5TmppN25taDZsak9CTlhJdmRWQUlRS0U0NXk3V1JGb09lS2t4UEtjbmtXVFlENmlKeWhzQk1neHVleDlWRE9wMXpsYXdVUXhHbHpTd2o0M1JrZ054bkJuem11Q0NnNXVsWVNCYlhNKy96eXR5b2lrSG9FTGFGcUNQaW1qTEFSLzFJcWhldjNPMmd1Rm5pOWJRZTg2aG9XTzkrTXhMZkxSd21HZlJyazBRTVJxM1JsMjRjT0hDeGFUR1gwMXVFcHNpZTBNVkFBQUFKWFJGV0hSa1lYUmxPbU55WldGMFpRQXlNREl4TFRBekxUSXdWREV4T2pFek9qTXhLekF3T2pBd0xnWkVPd0FBQUNWMFJWaDBaR0YwWlRwdGIyUnBabmtBTWpBeU1TMHdNeTB5TUZReE1Ub3hNem96TVNzd01Eb3dNRjliL0ljQUFBQWdkRVZZZEhOdlpuUjNZWEpsQUdoMGRIQnpPaTh2YVcxaFoyVnRZV2RwWTJzdWIzSm52TThkblFBQUFCaDBSVmgwVkdoMWJXSTZPa1J2WTNWdFpXNTBPanBRWVdkbGN3QXhwLys3THdBQUFCaDBSVmgwVkdoMWJXSTZPa2x0WVdkbE9qcElaV2xuYUhRQU5URXlqNDFUZ1FBQUFCZDBSVmgwVkdoMWJXSTZPa2x0WVdkbE9qcFhhV1IwYUFBMU1USWNmQVBjQUFBQUdYUkZXSFJVYUhWdFlqbzZUV2x0WlhSNWNHVUFhVzFoWjJVdmNHNW5QN0pXVGdBQUFCZDBSVmgwVkdoMWJXSTZPazFVYVcxbEFERTJNVFl5TXpnNE1URUNwdW1jQUFBQUVuUkZXSFJVYUhWdFlqbzZVMmw2WlFBNE1EUTBRa0orVHFjT0FBQUFUM1JGV0hSVWFIVnRZam82VlZKSkFHWnBiR1U2THk4dUwzVndiRzloWkhNdk5UWXZhRXBJWm5WeGNDOHlPVEF5TDJGeWNtOTNYMlJ2ZDI1ZmRISnBZVzVuYkdWZmFXTnZibDh4T0RNd09UVXVjRzVuL0pyaXhnQUFBQUJKUlU1RXJrSmdnZz09YDtcbiIsImltcG9ydCB7IGh0bWwsIGNzcyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgU2NFbGVtZW50IGZyb20gJy4vU2NFbGVtZW50LmpzJztcbmltcG9ydCB7IGZvbnRGYW1pbHksIGZvbnRTaXplLCB0aGVtZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcblxuY2xhc3MgU2NCdXR0b24gZXh0ZW5kcyBTY0VsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuXG4gICAgICBidXR0b24ge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcbiAgICAgICAgZm9udC1zaXplOiAke2ZvbnRTaXplfTtcbiAgICAgICAgY29sb3I6ICNmZmZmZmY7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0xJ119O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMiddfTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogIDFweDtcbiAgICAgICAgZm9udC1zaXplOiAxM3B4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgfVxuXG4gICAgICBidXR0b246aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMiddfTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgfVxuXG4gICAgICBidXR0b246YWN0aXZlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXX07XG4gICAgICB9XG5cblxuICAgICAgYnV0dG9uLnNlbGVjdGVkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMyddfTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMyddfTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90IHJlYWxseSB2aXNpYmxlXG4gICAgICBidXR0b246Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMudGV4dCA9ICcnO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3ByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyAtIGFkZCBgZG93bmAgYW5kIGB1cGAgZXZlbnRzXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMudmFsdWU7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxidXR0b25cbiAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICB3aWR0aDogJHt0aGlzLndpZHRofXB4O1xuICAgICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICBsaW5lLWhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgXCJcbiAgICAgICAgY2xhc3M9XCIke3RoaXMuc2VsZWN0ZWQgPyAnc2VsZWN0ZWQnIDogJyd9XCJcbiAgICAgICAgQG1vdXNlZG93bj1cIiR7dGhpcy5vbkV2ZW50fVwiXG4gICAgICAgIEBtb3VzZXVwPVwiJHt0aGlzLm9uRXZlbnR9XCJcblxuICAgICAgICBAdG91Y2hzdGFydD1cIiR7e1xuICAgICAgICAgIGhhbmRsZUV2ZW50OnRoaXMub25FdmVudCxcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgfX1cIlxuICAgICAgICBAdG91Y2hlbmQ9XCIke3RoaXMub25FdmVudH1cIlxuICAgICAgICBAY29udGV4dG1lbnU9XCIke3RoaXMuX3ByZXZlbnRDb250ZXh0TWVudX1cIlxuICAgICAgPiR7dGV4dH08L2J1dHRvbj5cbiAgICBgO1xuICB9XG5cbiAgb25FdmVudChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBldmVudE5hbWU7XG5cbiAgICBpZiAoZS50eXBlID09PSAndG91Y2hlbmQnIHx8wqBlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgZXZlbnROYW1lID0gJ3JlbGVhc2UnO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudE5hbWUgPSAncHJlc3MnXG4gICAgfVxuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgcmVsZWFzZSBpZiBubyBwcmVzc2VkIGhhcyBiZWVuIHJlY29yZGVkXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JlbGVhc2UnICYmIHRoaXMuX3ByZXNzZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcHJlc3NlZCA9IChldmVudE5hbWUgPT09ICdwcmVzcycpO1xuXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgdmFsdWU6IHRoaXMudmFsdWUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAncHJlc3MnKSB7XG4gICAgICBjb25zdCBpbnB1dEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdpbnB1dCcsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy52YWx1ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChpbnB1dEV2ZW50KTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy1idXR0b24nLCBTY0J1dHRvbik7XG5cbmV4cG9ydCBkZWZhdWx0IFNjQnV0dG9uO1xuIiwiaW1wb3J0IHsgaHRtbCwgc3ZnLCBjc3MgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgdGhlbWUgfSBmcm9tICcuL3N0eWxlcy5qcyc7XG5pbXBvcnQgU2NFbGVtZW50IGZyb20gJy4vU2NFbGVtZW50LmpzJztcblxuY2xhc3MgU2NUb2dnbGUgZXh0ZW5kcyBTY0VsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWZsZWN0OiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgOmhvc3Qge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBmb250LXNpemU6IDAgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgc3ZnIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICB9XG4gICAgYDtcbiAgfVxuXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9zaXplID0gdmFsdWU7XG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgLy8gYWxpYXMgYWN0aXZlIGZvciBjb25zaXN0ZW5jeSBhbmQgZ2VuZXJpY2l0eSB3aXRoIG90aGVyIGNvbXBvbmVudHNcbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZShhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLndpZHRoID0gMzA7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQodGhpcyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IDI1O1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gMTA7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdmdcbiAgICAgICAgc3R5bGU9XCJ3aWR0aDogJHt0aGlzLl9zaXplfXB4OyBoZWlnaHQ6ICR7dGhpcy5fc2l6ZX1weDtcIlxuICAgICAgICB2aWV3Ym94PVwiMCAwIDEwMCAxMDBcIlxuICAgICAgICBAbW91c2Vkb3duPVwiJHt0aGlzLnVwZGF0ZVZhbHVlfVwiXG4gICAgICAgIEB0b3VjaHN0YXJ0PVwiJHt7XG4gICAgICAgICAgaGFuZGxlRXZlbnQ6IHRoaXMudXBkYXRlVmFsdWUsXG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH19XCJcblxuICAgICAgICBAY29udGV4dG1lbnU9XCIke3RoaXMuX3ByZXZlbnRDb250ZXh0TWVudX1cIlxuICAgICAgPlxuICAgICAgICA8cmVjdFxuICAgICAgICAgIHg9XCIwXCJcbiAgICAgICAgICB5PVwiMFwiXG4gICAgICAgICAgd2lkdGg9XCIxMDBcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMFwiXG4gICAgICAgICAgZmlsbD1cIiR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0xJ119XCJcbiAgICAgICAgPjwvcmVjdD5cbiAgICAgICAgJHt0aGlzLmFjdGl2ZVxuICAgICAgICAgID8gc3ZnYFxuICAgICAgICAgICAgICA8bGluZVxuICAgICAgICAgICAgICAgIHgxPVwiJHtwYWRkaW5nfVwiXG4gICAgICAgICAgICAgICAgeTE9XCIke3BhZGRpbmd9XCJcbiAgICAgICAgICAgICAgICB4Mj1cIiR7MTAwIC0gcGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHkyPVwiJHsxMDAgLSBwYWRkaW5nfVwiXG4gICAgICAgICAgICAgICAgc3R5bGU9XCJzdHJva2Utd2lkdGg6JHtzdHJva2VXaWR0aH07IHN0cm9rZTojZmZmZmZmO1wiIC8+XG4gICAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgICAgeDE9XCIke3BhZGRpbmd9XCJcbiAgICAgICAgICAgICAgICB5MT1cIiR7MTAwIC0gcGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHgyPVwiJHsxMDAgLSBwYWRkaW5nfVwiXG4gICAgICAgICAgICAgICAgeTI9XCIke3BhZGRpbmd9XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cInN0cm9rZS13aWR0aDoke3N0cm9rZVdpZHRofTsgc3Ryb2tlOiNmZmZmZmY7XCIgLz5cbiAgICAgICAgICAgIGBcbiAgICAgICAgICA6IHN2Z2BcbiAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICB4MT1cIiR7cGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHkxPVwiJHtwYWRkaW5nfVwiXG4gICAgICAgICAgICAgICAgeDI9XCIkezEwMCAtIHBhZGRpbmd9XCJcbiAgICAgICAgICAgICAgICB5Mj1cIiR7MTAwIC0gcGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHN0eWxlPVwic3Ryb2tlLXdpZHRoOiR7c3Ryb2tlV2lkdGh9OyBzdHJva2U6JHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXX07XCIgLz5cbiAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICB4MT1cIiR7cGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHkxPVwiJHsxMDAgLSBwYWRkaW5nfVwiXG4gICAgICAgICAgICAgICAgeDI9XCIkezEwMCAtIHBhZGRpbmd9XCJcbiAgICAgICAgICAgICAgICB5Mj1cIiR7cGFkZGluZ31cIlxuICAgICAgICAgICAgICAgIHN0eWxlPVwic3Ryb2tlLXdpZHRoOiR7c3Ryb2tlV2lkdGh9OyBzdHJva2U6JHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXX07XCIgLz5cbiAgICAgICAgICAgIGBcbiAgICAgICAgfVxuICAgICAgPC9zdmc+XG4gICAgYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuYWN0aXZlID0gIXRoaXMuYWN0aXZlO1xuXG4gICAgY29uc3QgY2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy5hY3RpdmUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy10b2dnbGUnLCBTY1RvZ2dsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjVG9nZ2xlO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2NhbGUoZG9tYWluLCByYW5nZSkge1xuICBjb25zdCBzbG9wZSA9IChyYW5nZVsxXSAtIHJhbmdlWzBdKSAvIChkb21haW5bMV0gLSBkb21haW5bMF0pO1xuICBjb25zdCBpbnRlcmNlcHQgPSByYW5nZVswXSAtIHNsb3BlICogZG9tYWluWzBdO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHZhbCkge1xuICAgIHJldHVybiBzbG9wZSAqIHZhbCArIGludGVyY2VwdDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsIC0gaW50ZXJjZXB0KSAvIHNsb3BlO1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBlcihtaW4sIG1heCwgc3RlcCkge1xuICByZXR1cm4gKHZhbCkgPT4ge1xuICAgIGNvbnN0IGNsaXBwZWRWYWx1ZSA9IE1hdGgucm91bmQodmFsIC8gc3RlcCkgKiBzdGVwO1xuICAgIGNvbnN0IGZpeGVkID0gTWF0aC5tYXgoTWF0aC5sb2cxMCgxIC8gc3RlcCksIDApO1xuICAgIGNvbnN0IGZpeGVkVmFsdWUgPSBjbGlwcGVkVmFsdWUudG9GaXhlZChmaXhlZCk7IC8vIGZpeCBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHBhcnNlRmxvYXQoZml4ZWRWYWx1ZSkpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5jb25zdCB0PXtBVFRSSUJVVEU6MSxDSElMRDoyLFBST1BFUlRZOjMsQk9PTEVBTl9BVFRSSUJVVEU6NCxFVkVOVDo1LEVMRU1FTlQ6Nn0sZT10PT4oLi4uZSk9Pih7XyRsaXREaXJlY3RpdmUkOnQsdmFsdWVzOmV9KTtjbGFzcyBpe2NvbnN0cnVjdG9yKHQpe31nZXQgXyRBVSgpe3JldHVybiB0aGlzLl8kQU0uXyRBVX1fJEFUKHQsZSxpKXt0aGlzLl8kQ3Q9dCx0aGlzLl8kQU09ZSx0aGlzLl8kQ2k9aX1fJEFTKHQsZSl7cmV0dXJuIHRoaXMudXBkYXRlKHQsZSl9dXBkYXRlKHQsZSl7cmV0dXJuIHRoaXMucmVuZGVyKC4uLmUpfX1leHBvcnR7aSBhcyBEaXJlY3RpdmUsdCBhcyBQYXJ0VHlwZSxlIGFzIGRpcmVjdGl2ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmUuanMubWFwXG4iLCJpbXBvcnR7bm9DaGFuZ2UgYXMgdH1mcm9tXCIuLi9saXQtaHRtbC5qc1wiO2ltcG9ydHtkaXJlY3RpdmUgYXMgaSxEaXJlY3RpdmUgYXMgcyxQYXJ0VHlwZSBhcyByfWZyb21cIi4uL2RpcmVjdGl2ZS5qc1wiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovY29uc3Qgbz1pKGNsYXNzIGV4dGVuZHMgc3tjb25zdHJ1Y3Rvcih0KXt2YXIgaTtpZihzdXBlcih0KSx0LnR5cGUhPT1yLkFUVFJJQlVURXx8XCJjbGFzc1wiIT09dC5uYW1lfHwobnVsbD09PShpPXQuc3RyaW5ncyl8fHZvaWQgMD09PWk/dm9pZCAwOmkubGVuZ3RoKT4yKXRocm93IEVycm9yKFwiYGNsYXNzTWFwKClgIGNhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBjbGFzc2AgYXR0cmlidXRlIGFuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgaW4gdGhlIGF0dHJpYnV0ZS5cIil9cmVuZGVyKHQpe3JldHVyblwiIFwiK09iamVjdC5rZXlzKHQpLmZpbHRlcigoaT0+dFtpXSkpLmpvaW4oXCIgXCIpK1wiIFwifXVwZGF0ZShpLFtzXSl7dmFyIHIsbztpZih2b2lkIDA9PT10aGlzLmV0KXt0aGlzLmV0PW5ldyBTZXQsdm9pZCAwIT09aS5zdHJpbmdzJiYodGhpcy5zdD1uZXcgU2V0KGkuc3RyaW5ncy5qb2luKFwiIFwiKS5zcGxpdCgvXFxzLykuZmlsdGVyKCh0PT5cIlwiIT09dCkpKSk7Zm9yKGNvbnN0IHQgaW4gcylzW3RdJiYhKG51bGw9PT0ocj10aGlzLnN0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5oYXModCkpJiZ0aGlzLmV0LmFkZCh0KTtyZXR1cm4gdGhpcy5yZW5kZXIocyl9Y29uc3QgZT1pLmVsZW1lbnQuY2xhc3NMaXN0O3RoaXMuZXQuZm9yRWFjaCgodD0+e3QgaW4gc3x8KGUucmVtb3ZlKHQpLHRoaXMuZXQuZGVsZXRlKHQpKX0pKTtmb3IoY29uc3QgdCBpbiBzKXtjb25zdCBpPSEhc1t0XTtpPT09dGhpcy5ldC5oYXModCl8fChudWxsPT09KG89dGhpcy5zdCl8fHZvaWQgMD09PW8/dm9pZCAwOm8uaGFzKHQpKXx8KGk/KGUuYWRkKHQpLHRoaXMuZXQuYWRkKHQpKTooZS5yZW1vdmUodCksdGhpcy5ldC5kZWxldGUodCkpKX1yZXR1cm4gdH19KTtleHBvcnR7byBhcyBjbGFzc01hcH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy1tYXAuanMubWFwXG4iLCIvKipcclxuICogQGRlc2Mg6Kej5Yaz5rWu5Yqo6L+Q566X6Zeu6aKY77yM6YG/5YWN5bCP5pWw54K55ZCO5Lqn55Sf5aSa5L2N5pWw5ZKM6K6h566X57K+5bqm5o2f5aSx44CCXHJcbiAqIOmXrumimOekuuS+i++8mjIuMyArIDIuNCA9IDQuNjk5OTk5OTk5OTk5OTk577yMMS4wIC0gMC45ID0gMC4wOTk5OTk5OTk5OTk5OTk5OFxyXG4gKi9cclxuLyoqXHJcbiAqIOaKiumUmeivr+eahOaVsOaNrui9rOato1xyXG4gKiBzdHJpcCgwLjA5OTk5OTk5OTk5OTk5OTk4KT0wLjFcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwKG51bSwgcHJlY2lzaW9uKSB7XHJcbiAgICBpZiAocHJlY2lzaW9uID09PSB2b2lkIDApIHsgcHJlY2lzaW9uID0gMTU7IH1cclxuICAgIHJldHVybiArcGFyc2VGbG9hdChOdW1iZXIobnVtKS50b1ByZWNpc2lvbihwcmVjaXNpb24pKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGRpZ2l0cyBsZW5ndGggb2YgYSBudW1iZXJcclxuICogQHBhcmFtIHsqbnVtYmVyfSBudW0gSW5wdXQgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBkaWdpdExlbmd0aChudW0pIHtcclxuICAgIC8vIEdldCBkaWdpdCBsZW5ndGggb2YgZVxyXG4gICAgdmFyIGVTcGxpdCA9IG51bS50b1N0cmluZygpLnNwbGl0KC9bZUVdLyk7XHJcbiAgICB2YXIgbGVuID0gKGVTcGxpdFswXS5zcGxpdCgnLicpWzFdIHx8ICcnKS5sZW5ndGggLSArKGVTcGxpdFsxXSB8fCAwKTtcclxuICAgIHJldHVybiBsZW4gPiAwID8gbGVuIDogMDtcclxufVxyXG4vKipcclxuICog5oqK5bCP5pWw6L2s5oiQ5pW05pWw77yM5pSv5oyB56eR5a2m6K6h5pWw5rOV44CC5aaC5p6c5piv5bCP5pWw5YiZ5pS+5aSn5oiQ5pW05pWwXHJcbiAqIEBwYXJhbSB7Km51bWJlcn0gbnVtIOi+k+WFpeaVsFxyXG4gKi9cclxuZnVuY3Rpb24gZmxvYXQyRml4ZWQobnVtKSB7XHJcbiAgICBpZiAobnVtLnRvU3RyaW5nKCkuaW5kZXhPZignZScpID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIobnVtLnRvU3RyaW5nKCkucmVwbGFjZSgnLicsICcnKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZExlbiA9IGRpZ2l0TGVuZ3RoKG51bSk7XHJcbiAgICByZXR1cm4gZExlbiA+IDAgPyBzdHJpcChOdW1iZXIobnVtKSAqIE1hdGgucG93KDEwLCBkTGVuKSkgOiBOdW1iZXIobnVtKTtcclxufVxyXG4vKipcclxuICog5qOA5rWL5pWw5a2X5piv5ZCm6LaK55WM77yM5aaC5p6c6LaK55WM57uZ5Ye65o+Q56S6XHJcbiAqIEBwYXJhbSB7Km51bWJlcn0gbnVtIOi+k+WFpeaVsFxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tCb3VuZGFyeShudW0pIHtcclxuICAgIGlmIChfYm91bmRhcnlDaGVja2luZ1N0YXRlKSB7XHJcbiAgICAgICAgaWYgKG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG51bSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihudW0gKyBcIiBpcyBiZXlvbmQgYm91bmRhcnkgd2hlbiB0cmFuc2ZlciB0byBpbnRlZ2VyLCB0aGUgcmVzdWx0cyBtYXkgbm90IGJlIGFjY3VyYXRlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICog6L+t5Luj5pON5L2cXHJcbiAqL1xyXG5mdW5jdGlvbiBpdGVyYXRvck9wZXJhdGlvbihhcnIsIG9wZXJhdGlvbikge1xyXG4gICAgdmFyIG51bTEgPSBhcnJbMF0sIG51bTIgPSBhcnJbMV0sIG90aGVycyA9IGFyci5zbGljZSgyKTtcclxuICAgIHZhciByZXMgPSBvcGVyYXRpb24obnVtMSwgbnVtMik7XHJcbiAgICBvdGhlcnMuZm9yRWFjaChmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmVzID0gb3BlcmF0aW9uKHJlcywgbnVtKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKipcclxuICog57K+56Gu5LmY5rOVXHJcbiAqL1xyXG5mdW5jdGlvbiB0aW1lcygpIHtcclxuICAgIHZhciBudW1zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG51bXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChudW1zLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3JPcGVyYXRpb24obnVtcywgdGltZXMpO1xyXG4gICAgfVxyXG4gICAgdmFyIG51bTEgPSBudW1zWzBdLCBudW0yID0gbnVtc1sxXTtcclxuICAgIHZhciBudW0xQ2hhbmdlZCA9IGZsb2F0MkZpeGVkKG51bTEpO1xyXG4gICAgdmFyIG51bTJDaGFuZ2VkID0gZmxvYXQyRml4ZWQobnVtMik7XHJcbiAgICB2YXIgYmFzZU51bSA9IGRpZ2l0TGVuZ3RoKG51bTEpICsgZGlnaXRMZW5ndGgobnVtMik7XHJcbiAgICB2YXIgbGVmdFZhbHVlID0gbnVtMUNoYW5nZWQgKiBudW0yQ2hhbmdlZDtcclxuICAgIGNoZWNrQm91bmRhcnkobGVmdFZhbHVlKTtcclxuICAgIHJldHVybiBsZWZ0VmFsdWUgLyBNYXRoLnBvdygxMCwgYmFzZU51bSk7XHJcbn1cclxuLyoqXHJcbiAqIOeyvuehruWKoOazlVxyXG4gKi9cclxuZnVuY3Rpb24gcGx1cygpIHtcclxuICAgIHZhciBudW1zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG51bXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChudW1zLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3JPcGVyYXRpb24obnVtcywgcGx1cyk7XHJcbiAgICB9XHJcbiAgICB2YXIgbnVtMSA9IG51bXNbMF0sIG51bTIgPSBudW1zWzFdO1xyXG4gICAgLy8g5Y+W5pyA5aSn55qE5bCP5pWw5L2NXHJcbiAgICB2YXIgYmFzZU51bSA9IE1hdGgucG93KDEwLCBNYXRoLm1heChkaWdpdExlbmd0aChudW0xKSwgZGlnaXRMZW5ndGgobnVtMikpKTtcclxuICAgIC8vIOaKiuWwj+aVsOmDvei9rOS4uuaVtOaVsOeEtuWQjuWGjeiuoeeul1xyXG4gICAgcmV0dXJuICh0aW1lcyhudW0xLCBiYXNlTnVtKSArIHRpbWVzKG51bTIsIGJhc2VOdW0pKSAvIGJhc2VOdW07XHJcbn1cclxuLyoqXHJcbiAqIOeyvuehruWHj+azlVxyXG4gKi9cclxuZnVuY3Rpb24gbWludXMoKSB7XHJcbiAgICB2YXIgbnVtcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBudW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAobnVtcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yT3BlcmF0aW9uKG51bXMsIG1pbnVzKTtcclxuICAgIH1cclxuICAgIHZhciBudW0xID0gbnVtc1swXSwgbnVtMiA9IG51bXNbMV07XHJcbiAgICB2YXIgYmFzZU51bSA9IE1hdGgucG93KDEwLCBNYXRoLm1heChkaWdpdExlbmd0aChudW0xKSwgZGlnaXRMZW5ndGgobnVtMikpKTtcclxuICAgIHJldHVybiAodGltZXMobnVtMSwgYmFzZU51bSkgLSB0aW1lcyhudW0yLCBiYXNlTnVtKSkgLyBiYXNlTnVtO1xyXG59XHJcbi8qKlxyXG4gKiDnsr7noa7pmaTms5VcclxuICovXHJcbmZ1bmN0aW9uIGRpdmlkZSgpIHtcclxuICAgIHZhciBudW1zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG51bXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChudW1zLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3JPcGVyYXRpb24obnVtcywgZGl2aWRlKTtcclxuICAgIH1cclxuICAgIHZhciBudW0xID0gbnVtc1swXSwgbnVtMiA9IG51bXNbMV07XHJcbiAgICB2YXIgbnVtMUNoYW5nZWQgPSBmbG9hdDJGaXhlZChudW0xKTtcclxuICAgIHZhciBudW0yQ2hhbmdlZCA9IGZsb2F0MkZpeGVkKG51bTIpO1xyXG4gICAgY2hlY2tCb3VuZGFyeShudW0xQ2hhbmdlZCk7XHJcbiAgICBjaGVja0JvdW5kYXJ5KG51bTJDaGFuZ2VkKTtcclxuICAgIC8vIGZpeDog57G75Ly8IDEwICoqIC00IOS4uiAwLjAwMDA5OTk5OTk5OTk5OTk5OTk577yMc3RyaXAg5L+u5q2jXHJcbiAgICByZXR1cm4gdGltZXMobnVtMUNoYW5nZWQgLyBudW0yQ2hhbmdlZCwgc3RyaXAoTWF0aC5wb3coMTAsIGRpZ2l0TGVuZ3RoKG51bTIpIC0gZGlnaXRMZW5ndGgobnVtMSkpKSk7XHJcbn1cclxuLyoqXHJcbiAqIOWbm+iIjeS6lOWFpVxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQobnVtLCByYXRpbykge1xyXG4gICAgdmFyIGJhc2UgPSBNYXRoLnBvdygxMCwgcmF0aW8pO1xyXG4gICAgdmFyIHJlc3VsdCA9IGRpdmlkZShNYXRoLnJvdW5kKE1hdGguYWJzKHRpbWVzKG51bSwgYmFzZSkpKSwgYmFzZSk7XHJcbiAgICBpZiAobnVtIDwgMCAmJiByZXN1bHQgIT09IDApIHtcclxuICAgICAgICByZXN1bHQgPSB0aW1lcyhyZXN1bHQsIC0xKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxudmFyIF9ib3VuZGFyeUNoZWNraW5nU3RhdGUgPSB0cnVlO1xyXG4vKipcclxuICog5piv5ZCm6L+b6KGM6L6555WM5qOA5p+l77yM6buY6K6k5byA5ZCvXHJcbiAqIEBwYXJhbSBmbGFnIOagh+iusOW8gOWFs++8jHRydWUg5Li65byA5ZCv77yMZmFsc2Ug5Li65YWz6Zet77yM6buY6K6k5Li6IHRydWVcclxuICovXHJcbmZ1bmN0aW9uIGVuYWJsZUJvdW5kYXJ5Q2hlY2tpbmcoZmxhZykge1xyXG4gICAgaWYgKGZsYWcgPT09IHZvaWQgMCkgeyBmbGFnID0gdHJ1ZTsgfVxyXG4gICAgX2JvdW5kYXJ5Q2hlY2tpbmdTdGF0ZSA9IGZsYWc7XHJcbn1cclxudmFyIGluZGV4ID0ge1xyXG4gICAgc3RyaXA6IHN0cmlwLFxyXG4gICAgcGx1czogcGx1cyxcclxuICAgIG1pbnVzOiBtaW51cyxcclxuICAgIHRpbWVzOiB0aW1lcyxcclxuICAgIGRpdmlkZTogZGl2aWRlLFxyXG4gICAgcm91bmQ6IHJvdW5kLFxyXG4gICAgZGlnaXRMZW5ndGg6IGRpZ2l0TGVuZ3RoLFxyXG4gICAgZmxvYXQyRml4ZWQ6IGZsb2F0MkZpeGVkLFxyXG4gICAgZW5hYmxlQm91bmRhcnlDaGVja2luZzogZW5hYmxlQm91bmRhcnlDaGVja2luZyxcclxufTtcblxuZXhwb3J0IHsgc3RyaXAsIHBsdXMsIG1pbnVzLCB0aW1lcywgZGl2aWRlLCByb3VuZCwgZGlnaXRMZW5ndGgsIGZsb2F0MkZpeGVkLCBlbmFibGVCb3VuZGFyeUNoZWNraW5nIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsImltcG9ydCB7IGh0bWwsIGNzcywgbm90aGluZyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBjbGFzc01hcCB9IGZyb20gJ2xpdC9kaXJlY3RpdmVzL2NsYXNzLW1hcC5qcyc7XG5pbXBvcnQgTlAgZnJvbSAnbnVtYmVyLXByZWNpc2lvbic7XG5pbXBvcnQgU2NFbGVtZW50IGZyb20gJy4vU2NFbGVtZW50LmpzJztcbmltcG9ydCB7IGZvbnRGYW1pbHksIGZvbnRTaXplLCB0aGVtZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcbmltcG9ydCAnLi9zYy1zcGVlZC1zdXJmYWNlLmpzJztcblxuY2xhc3MgU2NOdW1iZXIgZXh0ZW5kcyBTY0VsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIG1pbjoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgaW50ZWdlcjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWZsZWN0OiB0cnVlLFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgOmhvc3Qge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gZGl2IHtcbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0xJ119O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMiddfTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XG4gICAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLmNvbnRhaW5lcjpmb2N1cyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIC5pbmZvIHtcbiAgICAgICAgd2lkdGg6IDE1cHg7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICB9XG5cbiAgICAgIC5jb250YWluZXI6Zm9jdXMgLmluZm8ge1xuICAgICAgICBvdXRsaW5lOiAycHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMiddfTtcbiAgICAgIH1cblxuICAgICAgLmluZm8uZWRpdGVkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXX07XG4gICAgICB9XG5cbiAgICAgIC5jb250ZW50IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMTVweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIH1cblxuICAgICAgLnoge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmb250LXNpemU6ICR7Zm9udFNpemV9O1xuICAgICAgfVxuXG4gICAgICAuejpmaXJzdC1jaGlsZCB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAzcHg7XG4gICAgICB9XG5cbiAgICAgIC56IHNjLXNwZWVkLXN1cmZhY2Uge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgc2V0IG1pbih2YWx1ZSkge1xuICAgIHRoaXMuX21pbiA9IE1hdGgubWluKHZhbHVlLCB0aGlzLl9tYXgpO1xuXG4gICAgaWYgKHRoaXMuX3ZhbHVlIDwgdGhpcy5fbWluKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fbWluO1xuICAgICAgdGhpcy5fZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBtaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgfVxuXG4gIHNldCBtYXgodmFsdWUpIHtcbiAgICB0aGlzLl9tYXggPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5fbWluKTtcblxuICAgIGlmICh0aGlzLl92YWx1ZSA+IHRoaXMuX21heCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX21heDtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWF4KCkge1xuICAgIHJldHVybiB0aGlzLl9tYXg7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgdmFsID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIHZhbCkpO1xuXG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fZGlzcGxheVZhbHVlID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMud2lkdGggPSAxMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLmludGVnZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9taW4gPSAtSW5maW5pdHk7XG4gICAgdGhpcy5fbWF4ID0gK0luZmluaXR5O1xuICAgIHRoaXMuX3ZhbHVlID0gMDtcbiAgICB0aGlzLl9kaXNwbGF5VmFsdWUgPSAnMCc7XG5cbiAgICAvLyBpbml0IHRocm91Z2ggc2V0dGVyc1xuICAgIC8vIHRoaXMubWluID0gLUluZmluaXR5O1xuICAgIC8vIHRoaXMubWF4ID0gK0luZmluaXR5O1xuICAgIC8vIHRoaXMudmFsdWUgPSAwO1xuXG4gICAgdGhpcy5fdmFsdWVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl91cGRhdGVWYWx1ZTEgPSB0aGlzLnVwZGF0ZVZhbHVlRnJvbVBvaW50ZXIoMSk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUwMSA9IHRoaXMudXBkYXRlVmFsdWVGcm9tUG9pbnRlcigwLjEpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlMDAxID0gdGhpcy51cGRhdGVWYWx1ZUZyb21Qb2ludGVyKDAuMDEpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlMDAwMSA9IHRoaXMudXBkYXRlVmFsdWVGcm9tUG9pbnRlcigwLjAwMSk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUwMDAwMSA9IHRoaXMudXBkYXRlVmFsdWVGcm9tUG9pbnRlcigwLjAwMDEpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlMDAwMDAxID0gdGhpcy51cGRhdGVWYWx1ZUZyb21Qb2ludGVyKDAuMDAwMDEpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlMDAwMDAwMSA9IHRoaXMudXBkYXRlVmFsdWVGcm9tUG9pbnRlcigwLjAwMDAwMSk7XG5cblxuICAgIHRoaXMuX251bUtleVByZXNzZWQgPSAwO1xuICAgIHRoaXMub25LZXlEb3duID0gdGhpcy5vbktleURvd24uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbm90ZTogZG8gbm90IHJlbW92ZSBzcGFjZXMgYmV0d2VlbiA8c3Bhbj4gdG8gYXZvaWQgd2hpdGUgc3BhY2VcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTA3ODIzOS9ob3ctZG8taS1yZW1vdmUtdGhlLXNwYWNlLWJldHdlZW4taW5saW5lLWlubGluZS1ibG9jay1lbGVtZW50c1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fZGlzcGxheVZhbHVlLnNwbGl0KCcuJyk7XG5cbiAgICBpZiAoIXBhcnRzWzFdKSB7XG4gICAgICBwYXJ0c1sxXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGVtcHR5U3BhY2UgPSAnICc7XG4gICAgY29uc3QgY2hhcmFjdGVyV2lkdGggPSA3OyAvLyBpbiBwaXhlbHNcblxuICAgIGNvbnN0IGlzRWRpdGVkID0geyBlZGl0ZWQ6ICh0aGlzLl9udW1LZXlQcmVzc2VkICE9PSAwKSB9O1xuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8ZGl2XG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBjbGFzcz1cImNvbnRhaW5lclwiXG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgIFwiXG4gICAgICAgIEBmb2N1cz1cIiR7dGhpcy5vbkZvY3VzfVwiXG4gICAgICAgIEBibHVyPVwiJHt0aGlzLm9uQmx1cn1cIlxuICAgICAgICBAdG91Y2hzdGFydD1cIiR7dGhpcy50cmlnZ2VyRm9jdXN9XCJcbiAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzPVwiaW5mbyAke2NsYXNzTWFwKGlzRWRpdGVkKX1cIlxuICAgICAgICAgIHN0eWxlPVwiaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1wiXG4gICAgICAgID48L2Rpdj5cblxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3M9XCJjb250ZW50XCJcbiAgICAgICAgICBzdHlsZT1cImhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcIlxuICAgICAgICA+XG5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInpcIlxuICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICBsaW5lLWhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgICAgd2lkdGg6ICR7Y2hhcmFjdGVyV2lkdGggKiBwYXJ0c1swXS5sZW5ndGh9cHg7XG4gICAgICAgICAgICBcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgICR7cGFydHNbMF19XG4gICAgICAgICAgICA8c2Mtc3BlZWQtc3VyZmFjZVxuICAgICAgICAgICAgICB3aWR0aD1cIiR7Y2hhcmFjdGVyV2lkdGggKiBNYXRoLm1heChwYXJ0c1swXS5sZW5ndGgsIDIpfVwiXG4gICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJcbiAgICAgICAgICAgICAgQGlucHV0PVwiJHt0aGlzLl91cGRhdGVWYWx1ZTF9XCJcbiAgICAgICAgICAgID48L3NjLXNwZWVkLXN1cmZhY2U+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICR7IXRoaXMuaW50ZWdlclxuICAgICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInpcIiBzdHlsZT1cImhlaWdodDogJHt0aGlzLmhlaWdodH1weDsgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHhcIj5cbiAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ6XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogJHtjaGFyYWN0ZXJXaWR0aH1weDtcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgJHtwYXJ0c1sxXVswXSB8fCBlbXB0eVNwYWNlfVxuICAgICAgICAgICAgICAgIDxzYy1zcGVlZC1zdXJmYWNlXG4gICAgICAgICAgICAgICAgICB3aWR0aD1cIiR7Y2hhcmFjdGVyV2lkdGh9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJcbiAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIiR7dGhpcy5fdXBkYXRlVmFsdWUwMX1cIlxuICAgICAgICAgICAgICAgID48L3NjLXNwZWVkLXN1cmZhY2U+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ6XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogJHtjaGFyYWN0ZXJXaWR0aH1weDtcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgJHtwYXJ0c1sxXVsxXSB8fCBlbXB0eVNwYWNlfVxuICAgICAgICAgICAgICAgIDxzYy1zcGVlZC1zdXJmYWNlXG4gICAgICAgICAgICAgICAgICB3aWR0aD1cIiR7Y2hhcmFjdGVyV2lkdGh9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJcbiAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIiR7dGhpcy5fdXBkYXRlVmFsdWUwMDF9XCJcbiAgICAgICAgICAgICAgICA+PC9zYy1zcGVlZC1zdXJmYWNlPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwielwiXG4gICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7Y2hhcmFjdGVyV2lkdGh9cHg7XG4gICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICR7cGFydHNbMV1bMl0gfHwgZW1wdHlTcGFjZX1cbiAgICAgICAgICAgICAgICA8c2Mtc3BlZWQtc3VyZmFjZVxuICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke2NoYXJhY3RlcldpZHRofVwiXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9XCIke3RoaXMuaGVpZ2h0fVwiXG4gICAgICAgICAgICAgICAgICBAaW5wdXQ9XCIke3RoaXMuX3VwZGF0ZVZhbHVlMDAwMX1cIlxuICAgICAgICAgICAgICAgID48L3NjLXNwZWVkLXN1cmZhY2U+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ6XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogJHtjaGFyYWN0ZXJXaWR0aH1weDtcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgJHtwYXJ0c1sxXVszXSB8fCBlbXB0eVNwYWNlfVxuICAgICAgICAgICAgICAgIDxzYy1zcGVlZC1zdXJmYWNlXG4gICAgICAgICAgICAgICAgICB3aWR0aD1cIiR7Y2hhcmFjdGVyV2lkdGh9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJcbiAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIiR7dGhpcy5fdXBkYXRlVmFsdWUwMDAwMX1cIlxuICAgICAgICAgICAgICAgID48L3NjLXNwZWVkLXN1cmZhY2U+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ6XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogJHtjaGFyYWN0ZXJXaWR0aH1weDtcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgJHtwYXJ0c1sxXVs0XSB8fCBlbXB0eVNwYWNlfVxuICAgICAgICAgICAgICAgIDxzYy1zcGVlZC1zdXJmYWNlXG4gICAgICAgICAgICAgICAgICB3aWR0aD1cIiR7Y2hhcmFjdGVyV2lkdGh9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJcbiAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIiR7dGhpcy5fdXBkYXRlVmFsdWUwMDAwMDF9XCJcbiAgICAgICAgICAgICAgICA+PC9zYy1zcGVlZC1zdXJmYWNlPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwielwiXG4gICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7Y2hhcmFjdGVyV2lkdGh9cHg7XG4gICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICR7cGFydHNbMV1bNV0gfHwgZW1wdHlTcGFjZX1cbiAgICAgICAgICAgICAgICA8c2Mtc3BlZWQtc3VyZmFjZVxuICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke2NoYXJhY3RlcldpZHRofVwiXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9XCIke3RoaXMuaGVpZ2h0fVwiXG4gICAgICAgICAgICAgICAgICBAaW5wdXQ9XCIke3RoaXMuX3VwZGF0ZVZhbHVlMDAwMDAwMX1cIlxuICAgICAgICAgICAgICAgID48L3NjLXNwZWVkLXN1cmZhY2U+XG4gICAgICAgICAgICAgIDwvc3Bhbj5gXG4gICAgICAgICAgICA6IG5vdGhpbmd9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIC8vIGZvcmNlIGZvY3VzIGZvciB0b3VjaHN0YXJ0IChpcyBwcmV2ZW50ZWQgYnkgc3BlZWQtc3VyZmFjZXMuLi4pXG4gIHRyaWdnZXJGb2N1cygpIHtcbiAgICBjb25zdCAkY29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcbiAgICAkY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cblxuICAvLyBrZXlib2FyZCBpbnRlcmFjdGlvbnNcbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLl9udW1LZXlQcmVzc2VkID0gMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duKTtcbiAgfVxuXG4gIG9uQmx1cigpIHtcbiAgICB0aGlzLnVwZGF0ZVZhbHVlRnJvbURpc3BsYXlWYWx1ZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pO1xuICB9XG5cbiAgb25LZXlEb3duKGUpIHtcbiAgICBjb25zdCB2YWxpZFN5bWJvbHMgPSB0aGlzLmludGVnZXJcbiAgICAgID8gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJy0nXVxuICAgICAgOiBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLScsICcuJywgJywnXTtcblxuICAgIGlmICh2YWxpZFN5bWJvbHMuaW5kZXhPZihlLmtleSkgIT09IC0xKSB7XG4gICAgICBpZiAodGhpcy5fbnVtS2V5UHJlc3NlZCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kaXNwbGF5VmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgbGV0IHN5bWJvbCA9IGUua2V5O1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnLCcpIHtcbiAgICAgICAgc3ltYm9sID0gJy4nXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rpc3BsYXlWYWx1ZSArPSBzeW1ib2w7XG4gICAgICB0aGlzLl9udW1LZXlQcmVzc2VkICs9IDE7XG5cbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBiYWNrc3BhY2VcbiAgICBpZiAoZS5rZXkgPT09ICdCYWNrc3BhY2UnIHx8IGUud2hpY2ggPT09IDgpIHtcbiAgICAgIC8vIGlmIGxhc3QgY2hhcmFjdGVyIGlzICcuJyByZW1vdmUgaXQgYXV0b21hdGljYWxseVxuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlWYWx1ZVt0aGlzLl9kaXNwbGF5VmFsdWUubGVuZ3RoIC0xXSA9PT0gJy4nKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlWYWx1ZSA9IHRoaXMuX2Rpc3BsYXlWYWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5fZGlzcGxheVZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kaXNwbGF5VmFsdWUgPSB0aGlzLl9kaXNwbGF5VmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuX2Rpc3BsYXlWYWx1ZS5sZW5ndGggLSAxKTtcblxuICAgICAgdGhpcy5fbnVtS2V5UHJlc3NlZCArPSAxO1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gVGFiIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgaXQgdHJpZ2dlcnMgYmx1clxuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyB8fCBlLndoaWNoID09PSAxMykge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZUZyb21EaXNwbGF5VmFsdWUoKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVWYWx1ZUZyb21EaXNwbGF5VmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuX251bUtleVByZXNzZWQgPiAwKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuaW50ZWdlclxuICAgICAgICA/IHBhcnNlSW50KHRoaXMuX2Rpc3BsYXlWYWx1ZSlcbiAgICAgICAgOiBwYXJzZUZsb2F0KHRoaXMuX2Rpc3BsYXlWYWx1ZSk7XG5cbiAgICAgIC8vIG1vZGlmeSBkaXNwbGF5VmFsdWUgb25seSBpZiBuZWVkZWRcbiAgICAgIGlmICh0aGlzLl92YWx1ZSA8IHRoaXMuX21pbiB8fCB0aGlzLl92YWx1ZSA+IHRoaXMuX21heCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IE1hdGgubWF4KHRoaXMuX21pbiwgTWF0aC5taW4odGhpcy5fbWF4LCB0aGlzLl92YWx1ZSkpO1xuICAgICAgICB0aGlzLl9kaXNwbGF5VmFsdWUgPSB0aGlzLl92YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9udW1LZXlQcmVzc2VkID0gMDtcblxuICAgICAgdGhpcy5fZW1pdElucHV0KCk7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlKCk7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVWYWx1ZUZyb21Qb2ludGVyKHN0ZXApIHtcbiAgICByZXR1cm4gZSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyBkbyBhbGwgY29tcHV0YXRpb24gaWYgbm90IG1vdXNldXAgb3IgdG91Y2hlbmQsXG4gICAgICAvLyBlbHNlIG9ubHkgcHJvcGFnYXRlIHRoZSBgY2hhbmdlIGV2ZW50YFxuICAgICAgaWYgKGUuZGV0YWlsLnBvaW50ZXJJZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBpZ25vcmUgdmVyeSBzbWFsbCBtb3ZlbWVudHNcbiAgICAgICAgaWYgKE1hdGguYWJzKGUuZGV0YWlsLmR5KSA8IDAuMDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSB0aGlzLl92YWx1ZTtcblxuICAgICAgICBjb25zdCBzaWduID0gZS5kZXRhaWwuZHkgPCAwID8gLTEgOiAxO1xuICAgICAgICAvLyBoZXVyaXN0aWNhbGx5IGFkanVzdCBzZW5zaWJsaXR5XG4gICAgICAgIGNvbnN0IHNjYWxlID0gODtcbiAgICAgICAgY29uc3QgZXhwb25lbnQgPSAxLjI7XG4gICAgICAgIC8vIGFwcGx5IHNjYWxlIGFuZCBleHBvbmVudCBmYWN0b3JzXG4gICAgICAgIGxldCBkeSA9IE1hdGgucG93KE1hdGguYWJzKGUuZGV0YWlsLmR5ICogc2NhbGUpLCBleHBvbmVudCk7XG4gICAgICAgIC8vIGNsYW1wIGF0IDFcbiAgICAgICAgZHkgPSBNYXRoLm1heCgxLCBkeSk7XG4gICAgICAgIC8vIHJlYXBwbHkgc2lnblxuICAgICAgICBkeSA9IGR5ICogc2lnbjtcblxuICAgICAgICB0aGlzLl92YWx1ZSArPSBzdGVwICogZHk7XG4gICAgICAgIC8vIGNyb3AgYXQgc3RlcCAodXNlIHByZWNpc2lvbiBhcnl0aG1ldGljcylcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBOUC50aW1lcyhNYXRoLnJvdW5kKHRoaXMuX3ZhbHVlIC8gc3RlcCksIHN0ZXApO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IE1hdGgubWF4KHRoaXMuX21pbiwgTWF0aC5taW4odGhpcy5fbWF4LCB0aGlzLl92YWx1ZSkpO1xuXG4gICAgICAgIC8vIGZvcm1hdCBkaXNwbGF5IHZhbHVlIHRvIHNob3cgdHJhaWxpbmcgemVyb3MuLi4pXG4gICAgICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IHRoaXMuX3ZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlUGFydHMgPSBkaXNwbGF5VmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCBzdGVwRGVjaW1hbHMgPSBzdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXTtcblxuICAgICAgICBpZiAoc3RlcERlY2ltYWxzKSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZVBhcnRzWzFdKSB7XG4gICAgICAgICAgICB2YWx1ZVBhcnRzWzFdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKHZhbHVlUGFydHNbMV0ubGVuZ3RoIDwgc3RlcERlY2ltYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWVQYXJ0c1sxXSArPSAnMCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheVZhbHVlID0gdmFsdWVQYXJ0cy5qb2luKCcuJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX2VtaXRJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHRyaWdnZXJzIGEgY2hhbmdlIHdoZW4gd2Ugc2VsZWN0IHRoZSBib3ggd2l0aG91dCBjaGFuZ2luZyB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2VtaXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfZW1pdElucHV0KCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdpbnB1dCcsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy5fdmFsdWUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBfZW1pdENoYW5nZSgpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLl92YWx1ZSB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjLW51bWJlcicsIFNjTnVtYmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NOdW1iZXI7XG4iLCJpbXBvcnQgeyBodG1sLCBzdmcsIGNzcywgbm90aGluZyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgU2NFbGVtZW50IGZyb20gJy4vU2NFbGVtZW50LmpzJztcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSAnLi9zdHlsZXMuanMnO1xuaW1wb3J0IGdldFNjYWxlIGZyb20gJy4vdXRpbHMvZ2V0U2NhbGUuanMnO1xuaW1wb3J0IGdldENsaXBwZXIgZnJvbSAnLi91dGlscy9nZXRDbGlwcGVyLmpzJztcbmltcG9ydCAnLi9zYy1wb3NpdGlvbi1zdXJmYWNlLmpzJztcbmltcG9ydCAnLi9zYy1udW1iZXIuanMnO1xuXG5jbGFzcyBTY1NsaWRlciBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gbW9kZToge1xuICAgICAgLy8gICB0eXBlOiBTdHJpbmdcbiAgICAgIC8vIH0sXG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBtaW46IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgc3RlcDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOdW1iZXI6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgYXR0cmlidXRlOiAnZGlzcGxheS1udW1iZXInLFxuICAgICAgICByZWZsZWN0OiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBmb250LXNpemU6IDAgIWltcG9ydGFudDtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IGRpdiB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBmb250LXNpemU6IDA7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0yJ119O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgfVxuXG4gICAgICBzYy1wb3NpdGlvbi1zdXJmYWNlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgIHJlY3QuZm9yZWdyb3VuZCB7fVxuXG4gICAgICByZWN0LmJhY2tncm91bmQge1xuICAgICAgICBmaWxsOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMSddfTtcbiAgICAgIH1cblxuICAgICAgc2MtbnVtYmVyIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5tb2RlID0gJ2p1bXAnOyAvLyBAdG9kbzogcmVsYXRpdmVcbiAgICB0aGlzLndpZHRoID0gMjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMzA7XG4gICAgdGhpcy5taW4gPSAwO1xuICAgIHRoaXMubWF4ID0gMTtcbiAgICB0aGlzLnN0ZXAgPSAwLjAwMTtcbiAgICB0aGlzLnZhbHVlID0gMC41O1xuICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgdGhpcy5kaXNwbGF5TnVtYmVyID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvciA9IHRoZW1lWyctLWNvbG9yLXByaW1hcnktNCddO1xuXG4gICAgdGhpcy5fbWFyZ2luU2xpZGVyTnVtYmVyID0gMztcbiAgICB0aGlzLl9udW1iZXJXaWR0aCA9IDgwO1xuXG4gICAgdGhpcy5fcG9pbnRlcklkID0gbnVsbDtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcykge1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBzdXBlci51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB0aGlzLl9zbGlkZXJXaWR0aCA9IHRoaXMuZGlzcGxheU51bWJlclxuICAgICAgICAgID8gdGhpcy53aWR0aCAtIHRoaXMuX251bWJlcldpZHRoIC0gdGhpcy5fbWFyZ2luU2xpZGVyTnVtYmVyXG4gICAgICAgICAgOiB0aGlzLndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRvZG8gLSBjbGVhbiB2ZXJ0aWNhbCB3LyBudW1iZXIgYm94XG4gICAgICAgIHRoaXMuX3NsaWRlcldpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2xpZGVyV2lkdGggLT0gMjsgLy8gdGFrZSBib3JkZXJzIGludG8gYWNjb3VudFxuICAgICAgdGhpcy5fc2xpZGVySGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSAyOyAvLyB0YWtlIGJvcmRlcnMgaW50byBhY2NvdW50XG5cbiAgICAgIGlmICh0aGlzLm1heCA8IHRoaXMubWluKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMubWF4O1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubWluO1xuICAgICAgICB0aGlzLm1pbiA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgLy8gZGVmaW5lIHRyYW5zZmVydCBmdW5jdGlvbnMgYW5kIHNjYWxlc1xuICAgICAgdGhpcy5zY2FsZSA9IGdldFNjYWxlKFxuICAgICAgICBbdGhpcy5taW4sIHRoaXMubWF4XSxcbiAgICAgICAgWzAsIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHRoaXMuX3NsaWRlcldpZHRoIDogdGhpcy5fc2xpZGVySGVpZ2h0XVxuICAgICAgKTtcblxuICAgICAgdGhpcy5jbGlwcGVyID0gZ2V0Q2xpcHBlcih0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuc3RlcCk7XG5cbiAgICAgIC8vIGNsZWFuIGRlZmF1bHQgdmFsdWVcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmNsaXBwZXIodGhpcy52YWx1ZSk7XG5cbiAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8ZGl2XG4gICAgICAgIEBjb250ZXh0bWVudT1cIiR7dGhpcy5fcHJldmVudENvbnRleHRNZW51fVwiXG4gICAgICAgIHN0eWxlPVwid2lkdGg6ICR7dGhpcy5fc2xpZGVyV2lkdGh9cHg7IGhlaWdodDogJHt0aGlzLl9zbGlkZXJIZWlnaHR9cHhcIlxuICAgICAgPlxuICAgICAgICA8c3ZnXG4gICAgICAgICAgc3R5bGU9XCJ3aWR0aDogJHt0aGlzLl9zbGlkZXJXaWR0aH1weDsgaGVpZ2h0OiAke3RoaXMuX3NsaWRlckhlaWdodH1weFwiXG4gICAgICAgICAgdmlld3BvcnQ9XCIwIDAgJHt0aGlzLl9zbGlkZXJXaWR0aH0gJHt0aGlzLl9zbGlkZXJIZWlnaHR9XCJcbiAgICAgICAgPlxuICAgICAgICAgICR7dGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHN2Z2BcbiAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJiYWNrZ3JvdW5kXCIgd2lkdGg9XCIke3RoaXMuX3NsaWRlcldpZHRofVwiIGhlaWdodD1cIiR7dGhpcy5fc2xpZGVySGVpZ2h0fVwiPjwvcmVjdD5cbiAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJmb3JlZ3JvdW5kXCIgd2lkdGg9XCIke01hdGgubWF4KDAsIHRoaXMuc2NhbGUodGhpcy52YWx1ZSkpfVwiIGhlaWdodD1cIiR7dGhpcy5fc2xpZGVySGVpZ2h0fVwiIGZpbGw9XCIke3RoaXMuY29sb3J9XCI+PC9yZWN0PlxuICAgICAgICAgICAgYCA6XG4gICAgICAgICAgICBzdmdgXG4gICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiZm9yZWdyb3VuZFwiIHdpZHRoPVwiJHt0aGlzLl9zbGlkZXJXaWR0aH1cIiBoZWlnaHQ9XCIke3RoaXMuX3NsaWRlckhlaWdodH1cIiBmaWxsPVwiJHt0aGlzLmNvbG9yfVwiPjwvcmVjdD5cbiAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJiYWNrZ3JvdW5kXCIgd2lkdGg9XCIke3RoaXMuX3NsaWRlcldpZHRofVwiIGhlaWdodD1cIiR7TWF0aC5tYXgoMCwgdGhpcy5fc2xpZGVySGVpZ2h0IC0gdGhpcy5zY2FsZSh0aGlzLnZhbHVlKSl9XCI+PC9yZWN0PlxuICAgICAgICAgICAgYFxuICAgICAgICAgIH1cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxzYy1wb3NpdGlvbi1zdXJmYWNlXG4gICAgICAgICAgd2lkdGg9XCIke3RoaXMuX3NsaWRlcldpZHRofVwiXG4gICAgICAgICAgaGVpZ2h0PVwiJHt0aGlzLl9zbGlkZXJIZWlnaHR9XCJcbiAgICAgICAgICBjbGFtcFxuICAgICAgICAgIHgtcmFuZ2U9XCIke0pTT04uc3RyaW5naWZ5KFt0aGlzLm1pbiwgdGhpcy5tYXhdKX1cIlxuICAgICAgICAgIHktcmFuZ2U9XCIke0pTT04uc3RyaW5naWZ5KFt0aGlzLm1heCwgdGhpcy5taW5dKX1cIlxuICAgICAgICAgIEBpbnB1dD1cIiR7dGhpcy51cGRhdGVWYWx1ZX1cIlxuICAgICAgICAgIEBwb2ludGVyZW5kPVwiJHt0aGlzLmNoYW5nZVZhbHVlfVwiXG4gICAgICAgID48L3NjLXBvc2l0aW9uLXN1cmZhY2U+XG4gICAgICA8L2Rpdj5cbiAgICAgICR7dGhpcy5kaXNwbGF5TnVtYmVyXG4gICAgICAgID8gaHRtbGBcbiAgICAgICAgICA8c2MtbnVtYmVyXG4gICAgICAgICAgICBzdHlsZT1cIm1hcmdpbi1sZWZ0OiAke3RoaXMuX21hcmdpblNsaWRlck51bWJlcn1weFwiXG4gICAgICAgICAgICB3aWR0aD1cIiR7dGhpcy5fbnVtYmVyV2lkdGh9XCJcbiAgICAgICAgICAgIG1pbj1cIiR7dGhpcy5taW59XCJcbiAgICAgICAgICAgIG1heD1cIiR7dGhpcy5tYXh9XCJcbiAgICAgICAgICAgIHZhbHVlPVwiJHt0aGlzLnZhbHVlfVwiXG4gICAgICAgICAgICBAaW5wdXQ9XCIke3RoaXMudXBkYXRlVmFsdWVGcm9tTnVtYmVyfVwiXG4gICAgICAgICAgPjwvc2MtbnVtYmVyPlxuICAgICAgICBgXG4gICAgICAgIDogbm90aGluZ1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZUZyb21OdW1iZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5jbGlwcGVyKGUuZGV0YWlsLnZhbHVlKTtcblxuICAgIGNvbnN0IGlucHV0RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2lucHV0Jywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLnZhbHVlIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoaW5wdXRFdmVudCk7XG5cbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLnZhbHVlIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICBjaGFuZ2VWYWx1ZShlKSB7XG4gICAgaWYgKGUuZGV0YWlsLnBvaW50ZXJJZCA9PT0gdGhpcy5fcG9pbnRlcklkKSB7XG4gICAgICB0aGlzLl9wb2ludGVySWQgPSBudWxsO1xuXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLnZhbHVlIH0sXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVWYWx1ZShlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gb3ZlcnJpZGUgZXZlbnQgZnJvbSBzYy1wb3NpdGlvbi1zdXJmYWNlXG5cbiAgICAvLyBjb25zaWRlciBvbmx5IGZpcnN0IHBvaW50ZXIgaW4gbGlzdCwgd2UgZG9uJ3Qgd2FudCBhIG11bHRpdG91Y2ggc2xpZGVyLi4uXG4gICAgaWYgKFxuICAgICAgZS5kZXRhaWwudmFsdWVbMF0gJiZcbiAgICAgICh0aGlzLl9wb2ludGVySWQgPT09IG51bGwgfHwgZS5kZXRhaWwudmFsdWVbMF0ucG9pbnRlcklkID09PSB0aGlzLl9wb2ludGVySWQpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHgsIHksIHBvaW50ZXJJZCB9ID0gZS5kZXRhaWwudmFsdWVbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHggOiB5O1xuICAgICAgdGhpcy5fcG9pbnRlcklkID0gcG9pbnRlcklkO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY2xpcHBlcih2YWx1ZSk7XG5cbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdpbnB1dCcsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy52YWx1ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy1zbGlkZXInLCBTY1NsaWRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IFNjU2xpZGVyO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gVGhpcyBpcyBDb2RlTWlycm9yIChodHRwczovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxuLy8gaW1wbGVtZW50ZWQgaW4gSmF2YVNjcmlwdCBvbiB0b3Agb2YgdGhlIGJyb3dzZXIncyBET00uXG4vL1xuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcbi8vIGF0IGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy8jY20taW50ZXJuYWxzIC5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Db2RlTWlycm9yID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxuICAvLyBkZXRlY3RlZCBhcmUgZW5hYmxlZCBiYXNlZCBvbiB1c2VyQWdlbnQgZXRjIHNuaWZmaW5nLlxuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtO1xuXG4gIHZhciBnZWNrbyA9IC9nZWNrb1xcL1xcZC9pLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICB2YXIgZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XG4gIHZhciBpZSA9IGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGVkZ2U7XG4gIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogKyhlZGdlIHx8IGllXzExdXApWzFdKTtcbiAgdmFyIHdlYmtpdCA9ICFlZGdlICYmIC9XZWJLaXRcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHF0d2Via2l0ID0gd2Via2l0ICYmIC9RdFxcL1xcZCtcXC5cXGQrLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBjaHJvbWUgPSAhZWRnZSAmJiAvQ2hyb21lXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBwcmVzdG8gPSAvT3BlcmFcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHNhZmFyaSA9IC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiAgdmFyIGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QodXNlckFnZW50KSB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyKTtcbiAgdmFyIGFuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpO1xuICAvLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgYW5kcm9pZCB8fCAvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChwbGF0Zm9ybSk7XG4gIHZhciBjaHJvbWVPUyA9IC9cXGJDck9TXFxiLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciB3aW5kb3dzID0gL3dpbi9pLnRlc3QocGxhdGZvcm0pO1xuXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7XG4gIGlmIChwcmVzdG9fdmVyc2lvbikgeyBwcmVzdG9fdmVyc2lvbiA9IE51bWJlcihwcmVzdG9fdmVyc2lvblsxXSk7IH1cbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG4gIHZhciBmbGlwQ3RybENtZCA9IG1hYyAmJiAocXR3ZWJraXQgfHwgcHJlc3RvICYmIChwcmVzdG9fdmVyc2lvbiA9PSBudWxsIHx8IHByZXN0b192ZXJzaW9uIDwgMTIuMTEpKTtcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XG5cbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKSB9XG5cbiAgdmFyIHJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXCJcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcbiAgICBmb3IgKHZhciBjb3VudCA9IGUuY2hpbGROb2Rlcy5sZW5ndGg7IGNvdW50ID4gMDsgLS1jb3VudClcbiAgICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xuICAgIHJldHVybiByZW1vdmVDaGlsZHJlbihwYXJlbnQpLmFwcGVuZENoaWxkKGUpXG4gIH1cblxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuICAgIGlmIChzdHlsZSkgeyBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSB7IGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpOyB9XG4gICAgZWxzZSBpZiAoY29udGVudCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIHsgZS5hcHBlbmRDaGlsZChjb250ZW50W2ldKTsgfSB9XG4gICAgcmV0dXJuIGVcbiAgfVxuICAvLyB3cmFwcGVyIGZvciBlbHQsIHdoaWNoIHJlbW92ZXMgdGhlIGVsdCBmcm9tIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWVcbiAgZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICB2YXIgZSA9IGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpO1xuICAgIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgdmFyIHJhbmdlO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKTtcbiAgICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcbiAgICByZXR1cm4gclxuICB9OyB9XG4gIGVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gciB9XG4gICAgci5jb2xsYXBzZSh0cnVlKTtcbiAgICByLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMykgLy8gQW5kcm9pZCBicm93c2VyIGFsd2F5cyByZXR1cm5zIGZhbHNlIHdoZW4gY2hpbGQgaXMgYSB0ZXh0bm9kZVxuICAgICAgeyBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7IH1cbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgeyByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSB9XG4gICAgZG8ge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7IGNoaWxkID0gY2hpbGQuaG9zdDsgfVxuICAgICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xuICAgIC8vIElFIGFuZCBFZGdlIG1heSB0aHJvdyBhbiBcIlVuc3BlY2lmaWVkIEVycm9yXCIgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5cbiAgICAvLyBJRSA8IDEwIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCB3aGlsZSB0aGUgcGFnZSBpcyBsb2FkaW5nIG9yIGluIGFuIGlmcmFtZS5cbiAgICAvLyBJRSA+IDkgYW5kIEVkZ2Ugd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIGluIGFuIGlmcmFtZSBpZiBkb2N1bWVudC5ib2R5IGlzIHVuYXZhaWxhYmxlLlxuICAgIHZhciBhY3RpdmVFbGVtZW50O1xuICAgIHRyeSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IG51bGw7XG4gICAgfVxuICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgIHsgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50OyB9XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSB7IG5vZGUuY2xhc3NOYW1lICs9IChjdXJyZW50ID8gXCIgXCIgOiBcIlwiKSArIGNsczsgfVxuICB9XG4gIGZ1bmN0aW9uIGpvaW5DbGFzc2VzKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgeyBiICs9IFwiIFwiICsgYXNbaV07IH0gfVxuICAgIHJldHVybiBiXG4gIH1cblxuICB2YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCk7IH07XG4gIGlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9OyB9XG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG4gICAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTsgfVxuXG4gIGZ1bmN0aW9uIGJpbmQoZikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xuICAgIGlmICghdGFyZ2V0KSB7IHRhcmdldCA9IHt9OyB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXG4gICAgICB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG92ZXJ3cml0ZSAhPT0gZmFsc2UgfHwgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkpXG4gICAgICAgIHsgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdOyB9IH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbiAgLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbiAgZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXgsIHN0YXJ0VmFsdWUpIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgIGlmIChlbmQgPT0gLTEpIHsgZW5kID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcbiAgICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXCJcXHRcIiwgaSk7XG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXG4gICAgICAgIHsgcmV0dXJuIG4gKyAoZW5kIC0gaSkgfVxuICAgICAgbiArPSBuZXh0VGFiIC0gaTtcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICBpID0gbmV4dFRhYiArIDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB0aGlzLmYgPSBudWxsO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5oYW5kbGVyID0gYmluZCh0aGlzLm9uVGltZW91dCwgdGhpcyk7XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLm9uVGltZW91dCA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgc2VsZi5pZCA9IDA7XG4gICAgaWYgKHNlbGYudGltZSA8PSArbmV3IERhdGUpIHtcbiAgICAgIHNlbGYuZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHNlbGYuaGFuZGxlciwgc2VsZi50aW1lIC0gK25ldyBEYXRlKTtcbiAgICB9XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtcywgZikge1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUgKyBtcztcbiAgICBpZiAoIXRoaXMuaWQgfHwgdGltZSA8IHRoaXMudGltZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVyLCBtcyk7XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoYXJyYXlbaV0gPT0gZWx0KSB7IHJldHVybiBpIH0gfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHBpeGVscyBhZGRlZCB0byBzY3JvbGxlciBhbmQgc2l6ZXIgdG8gaGlkZSBzY3JvbGxiYXJcbiAgdmFyIHNjcm9sbGVyR2FwID0gNTA7XG5cbiAgLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxuICAvLyBoYW5kbGluZyB0aGlzJy5cbiAgdmFyIFBhc3MgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5QYXNzXCJ9fTtcblxuICAvLyBSZXVzZWQgb3B0aW9uIG9iamVjdHMgZm9yIHNldFNlbGVjdGlvbiAmIGZyaWVuZHNcbiAgdmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9LCBzZWxfbW91c2UgPSB7b3JpZ2luOiBcIiptb3VzZVwifSwgc2VsX21vdmUgPSB7b3JpZ2luOiBcIittb3ZlXCJ9O1xuXG4gIC8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXG4gIGZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XG4gICAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIHBvcyk7XG4gICAgICBpZiAobmV4dFRhYiA9PSAtMSkgeyBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgaWYgKG5leHRUYWIgPT0gc3RyaW5nLmxlbmd0aCB8fCBjb2wgKyBza2lwcGVkID49IGdvYWwpXG4gICAgICAgIHsgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpIH1cbiAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSk7XG4gICAgICBwb3MgPSBuZXh0VGFiICsgMTtcbiAgICAgIGlmIChjb2wgPj0gZ29hbCkgeyByZXR1cm4gcG9zIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3BhY2VTdHJzID0gW1wiXCJdO1xuICBmdW5jdGlvbiBzcGFjZVN0cihuKSB7XG4gICAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcbiAgICAgIHsgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcIiBcIik7IH1cbiAgICByZXR1cm4gc3BhY2VTdHJzW25dXG4gIH1cblxuICBmdW5jdGlvbiBsc3QoYXJyKSB7IHJldHVybiBhcnJbYXJyLmxlbmd0aC0xXSB9XG5cbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gZihhcnJheVtpXSwgaSk7IH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xuICAgIHZhciBwb3MgPSAwLCBwcmlvcml0eSA9IHNjb3JlKHZhbHVlKTtcbiAgICB3aGlsZSAocG9zIDwgYXJyYXkubGVuZ3RoICYmIHNjb3JlKGFycmF5W3Bvc10pIDw9IHByaW9yaXR5KSB7IHBvcysrOyB9XG4gICAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aGluZygpIHt9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XG4gICAgdmFyIGluc3Q7XG4gICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XG4gICAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKTtcbiAgICB9XG4gICAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpOyB9XG4gICAgcmV0dXJuIGluc3RcbiAgfVxuXG4gIHZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbiAgZnVuY3Rpb24gaXNXb3JkQ2hhckJhc2ljKGNoKSB7XG4gICAgcmV0dXJuIC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmXG4gICAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKVxuICB9XG4gIGZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xuICAgIGlmICghaGVscGVyKSB7IHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpIH1cbiAgICBpZiAoaGVscGVyLnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikgPiAtMSAmJiBpc1dvcmRDaGFyQmFzaWMoY2gpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gaGVscGVyLnRlc3QoY2gpXG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSB7IGlmIChvYmouaGFzT3duUHJvcGVydHkobikgJiYgb2JqW25dKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xuICAvLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXG4gIC8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXG4gIC8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXG4gIC8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXG4gIHZhciBleHRlbmRpbmdDaGFycyA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztcbiAgZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApID49IDc2OCAmJiBleHRlbmRpbmdDaGFycy50ZXN0KGNoKSB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBmcm9tIHRoZSByYW5nZSBbYDBgOyBgc3RyLmxlbmd0aGBdIHVubGVzcyBgcG9zYCBpcyBvdXRzaWRlIHRoYXQgcmFuZ2UuXG4gIGZ1bmN0aW9uIHNraXBFeHRlbmRpbmdDaGFycyhzdHIsIHBvcywgZGlyKSB7XG4gICAgd2hpbGUgKChkaXIgPCAwID8gcG9zID4gMCA6IHBvcyA8IHN0ci5sZW5ndGgpICYmIGlzRXh0ZW5kaW5nQ2hhcihzdHIuY2hhckF0KHBvcykpKSB7IHBvcyArPSBkaXI7IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSByYW5nZSBbYGZyb21gOyBgdG9gXSB0aGF0IHNhdGlzZmllc1xuICAvLyBgcHJlZGAgYW5kIGlzIGNsb3Nlc3QgdG8gYGZyb21gLiBBc3N1bWVzIHRoYXQgYXQgbGVhc3QgYHRvYFxuICAvLyBzYXRpc2ZpZXMgYHByZWRgLiBTdXBwb3J0cyBgZnJvbWAgYmVpbmcgZ3JlYXRlciB0aGFuIGB0b2AuXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdChwcmVkLCBmcm9tLCB0bykge1xuICAgIC8vIEF0IGFueSBwb2ludCB3ZSBhcmUgY2VydGFpbiBgdG9gIHNhdGlzZmllcyBgcHJlZGAsIGRvbid0IGtub3dcbiAgICAvLyB3aGV0aGVyIGBmcm9tYCBkb2VzLlxuICAgIHZhciBkaXIgPSBmcm9tID4gdG8gPyAtMSA6IDE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHsgcmV0dXJuIGZyb20gfVxuICAgICAgdmFyIG1pZEYgPSAoZnJvbSArIHRvKSAvIDIsIG1pZCA9IGRpciA8IDAgPyBNYXRoLmNlaWwobWlkRikgOiBNYXRoLmZsb29yKG1pZEYpO1xuICAgICAgaWYgKG1pZCA9PSBmcm9tKSB7IHJldHVybiBwcmVkKG1pZCkgPyBmcm9tIDogdG8gfVxuICAgICAgaWYgKHByZWQobWlkKSkgeyB0byA9IG1pZDsgfVxuICAgICAgZWxzZSB7IGZyb20gPSBtaWQgKyBkaXI7IH1cbiAgICB9XG4gIH1cblxuICAvLyBCSURJIEhFTFBFUlNcblxuICBmdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGYoZnJvbSwgdG8sIFwibHRyXCIsIDApIH1cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XG4gICAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcInJ0bFwiIDogXCJsdHJcIiwgaSk7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgeyBmKGZyb20sIHRvLCBcImx0clwiKTsgfVxuICB9XG5cbiAgdmFyIGJpZGlPdGhlciA9IG51bGw7XG4gIGZ1bmN0aW9uIGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoLCBzdGlja3kpIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgYmlkaU90aGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY3VyID0gb3JkZXJbaV07XG4gICAgICBpZiAoY3VyLmZyb20gPCBjaCAmJiBjdXIudG8gPiBjaCkgeyByZXR1cm4gaSB9XG4gICAgICBpZiAoY3VyLnRvID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ID09IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcbiAgICAgICAgaWYgKGN1ci5mcm9tICE9IGN1ci50byAmJiBzdGlja3kgIT0gXCJiZWZvcmVcIikgeyBmb3VuZCA9IGk7IH1cbiAgICAgICAgZWxzZSB7IGJpZGlPdGhlciA9IGk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kICE9IG51bGwgPyBmb3VuZCA6IGJpZGlPdGhlclxuICB9XG5cbiAgLy8gQmlkaXJlY3Rpb25hbCBvcmRlcmluZyBhbGdvcml0aG1cbiAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxuICAvLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cblxuICAvLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XG4gIC8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcbiAgLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxuICAvLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xuICAvLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcbiAgLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxuICAvLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxuICAvLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXG4gIC8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXG4gIC8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcbiAgLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxuICAvLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gIC8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXG4gIC8vIHcgKFdTKTogIFdoaXRlc3BhY2VcbiAgLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcblxuICAvLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxuICAvLyAobGVmdC10by1yaWdodCksIG9yIGFuIGFycmF5IG9mIHNlY3Rpb25zICh7ZnJvbSwgdG8sIGxldmVsfVxuICAvLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cbiAgdmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXG4gICAgdmFyIGxvd1R5cGVzID0gXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiO1xuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuICAgIHZhciBhcmFiaWNUeXBlcyA9IFwibm5ubm5uTk5yJSVyLHJOTm1tbW1tbW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbW1tbm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1uTm1tbW1tbXJybW1ObW1tbXJyMTExMTExMTExMVwiO1xuICAgIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHsgcmV0dXJuIGxvd1R5cGVzLmNoYXJBdChjb2RlKSB9XG4gICAgICBlbHNlIGlmICgweDU5MCA8PSBjb2RlICYmIGNvZGUgPD0gMHg1ZjQpIHsgcmV0dXJuIFwiUlwiIH1cbiAgICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZmOSkgeyByZXR1cm4gYXJhYmljVHlwZXMuY2hhckF0KGNvZGUgLSAweDYwMCkgfVxuICAgICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSB7IHJldHVybiBcInJcIiB9XG4gICAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgeyByZXR1cm4gXCJ3XCIgfVxuICAgICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHsgcmV0dXJuIFwiYlwiIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gXCJMXCIgfVxuICAgIH1cblxuICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuICAgIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS87XG5cbiAgICBmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gXCJsdHJcIiA/IFwiTFwiIDogXCJSXCI7XG5cbiAgICAgIGlmIChzdHIubGVuZ3RoID09IDAgfHwgZGlyZWN0aW9uID09IFwibHRyXCIgJiYgIWJpZGlSRS50ZXN0KHN0cikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgeyB0eXBlcy5wdXNoKGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSk7IH1cblxuICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpJDEgPCBsZW47ICsraSQxKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaSQxXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJtXCIpIHsgdHlwZXNbaSQxXSA9IHByZXY7IH1cbiAgICAgICAgZWxzZSB7IHByZXYgPSB0eXBlOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgIC8vIG51bWJlci5cbiAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgICAgZm9yICh2YXIgaSQyID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpJDIgPCBsZW47ICsraSQyKSB7XG4gICAgICAgIHZhciB0eXBlJDEgPSB0eXBlc1tpJDJdO1xuICAgICAgICBpZiAodHlwZSQxID09IFwiMVwiICYmIGN1ciA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJuXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDEpKSB7IGN1ciA9IHR5cGUkMTsgaWYgKHR5cGUkMSA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJSXCI7IH0gfVxuICAgICAgfVxuXG4gICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcbiAgICAgIC8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xuICAgICAgICB2YXIgdHlwZSQyID0gdHlwZXNbaSQzXTtcbiAgICAgICAgaWYgKHR5cGUkMiA9PSBcIitcIiAmJiBwcmV2JDEgPT0gXCIxXCIgJiYgdHlwZXNbaSQzKzFdID09IFwiMVwiKSB7IHR5cGVzW2kkM10gPSBcIjFcIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDIgPT0gXCIsXCIgJiYgcHJldiQxID09IHR5cGVzW2kkMysxXSAmJlxuICAgICAgICAgICAgICAgICAocHJldiQxID09IFwiMVwiIHx8IHByZXYkMSA9PSBcIm5cIikpIHsgdHlwZXNbaSQzXSA9IHByZXYkMTsgfVxuICAgICAgICBwcmV2JDEgPSB0eXBlJDI7XG4gICAgICB9XG5cbiAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgIC8vIE5ldXRyYWwuXG4gICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBsZW47ICsraSQ0KSB7XG4gICAgICAgIHZhciB0eXBlJDMgPSB0eXBlc1tpJDRdO1xuICAgICAgICBpZiAodHlwZSQzID09IFwiLFwiKSB7IHR5cGVzW2kkNF0gPSBcIk5cIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDMgPT0gXCIlXCIpIHtcbiAgICAgICAgICB2YXIgZW5kID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQgPSBpJDQgKyAxOyBlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIiVcIjsgKytlbmQpIHt9XG4gICAgICAgICAgdmFyIHJlcGxhY2UgPSAoaSQ0ICYmIHR5cGVzW2kkNC0xXSA9PSBcIiFcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiMVwiKSA/IFwiMVwiIDogXCJOXCI7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7IHR5cGVzW2pdID0gcmVwbGFjZTsgfVxuICAgICAgICAgIGkkNCA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcbiAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICBmb3IgKHZhciBpJDUgPSAwLCBjdXIkMSA9IG91dGVyVHlwZTsgaSQ1IDwgbGVuOyArK2kkNSkge1xuICAgICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XTtcbiAgICAgICAgaWYgKGN1ciQxID09IFwiTFwiICYmIHR5cGUkNCA9PSBcIjFcIikgeyB0eXBlc1tpJDVdID0gXCJMXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDQpKSB7IGN1ciQxID0gdHlwZSQ0OyB9XG4gICAgICB9XG5cbiAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xuICAgICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaSQ2XSkpIHtcbiAgICAgICAgICB2YXIgZW5kJDEgPSAodm9pZCAwKTtcbiAgICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkkNiA/IHR5cGVzW2kkNi0xXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIGFmdGVyID0gKGVuZCQxIDwgbGVuID8gdHlwZXNbZW5kJDFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcbiAgICAgICAgICB2YXIgcmVwbGFjZSQxID0gYmVmb3JlID09IGFmdGVyID8gKGJlZm9yZSA/IFwiTFwiIDogXCJSXCIpIDogb3V0ZXJUeXBlO1xuICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkNjsgaiQxIDwgZW5kJDE7ICsraiQxKSB7IHR5cGVzW2okMV0gPSByZXBsYWNlJDE7IH1cbiAgICAgICAgICBpJDYgPSBlbmQkMSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxuICAgICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cbiAgICAgIHZhciBvcmRlciA9IFtdLCBtO1xuICAgICAgZm9yICh2YXIgaSQ3ID0gMDsgaSQ3IDwgbGVuOykge1xuICAgICAgICBpZiAoY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSkpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpJDc7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBzdGFydCwgaSQ3KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGkkNywgYXQgPSBvcmRlci5sZW5ndGgsIGlzUlRMID0gZGlyZWN0aW9uID09IFwicnRsXCIgPyAxIDogMDtcbiAgICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcIkxcIjsgKytpJDcpIHt9XG4gICAgICAgICAgZm9yICh2YXIgaiQyID0gcG9zOyBqJDIgPCBpJDc7KSB7XG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKSkge1xuICAgICAgICAgICAgICBpZiAocG9zIDwgaiQyKSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaiQyKSk7IGF0ICs9IGlzUlRMOyB9XG4gICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqJDI7XG4gICAgICAgICAgICAgIGZvciAoKytqJDI7IGokMiA8IGkkNyAmJiBjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pOyArK2okMikge31cbiAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqJDIpKTtcbiAgICAgICAgICAgICAgYXQgKz0gaXNSVEw7XG4gICAgICAgICAgICAgIHBvcyA9IGokMjtcbiAgICAgICAgICAgIH0gZWxzZSB7ICsraiQyOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPCBpJDcpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpJDcpKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09IFwibHRyXCIpIHtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXHMrLykpKSB7XG4gICAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDAsIDAsIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcbiAgICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIGxlbiAtIG1bMF0ubGVuZ3RoLCBsZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwicnRsXCIgPyBvcmRlci5yZXZlcnNlKCkgOiBvcmRlclxuICAgIH1cbiAgfSkoKTtcblxuICAvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXG4gIC8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcbiAgLy8gQmlkaVNwYW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvcmRlciA9IGxpbmUub3JkZXI7XG4gICAgaWYgKG9yZGVyID09IG51bGwpIHsgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCwgZGlyZWN0aW9uKTsgfVxuICAgIHJldHVybiBvcmRlclxuICB9XG5cbiAgLy8gRVZFTlQgSEFORExJTkdcblxuICAvLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxuICAvLyByZWdpc3RlcmluZyBuYXRpdmUgRE9NIGhhbmRsZXJzLlxuXG4gIHZhciBub0hhbmRsZXJzID0gW107XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xuICAgIGlmIChlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbWl0dGVyLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMgfHwgKGVtaXR0ZXIuX2hhbmRsZXJzID0ge30pO1xuICAgICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV0gfHwgbm9IYW5kbGVyc1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5kZXRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAgJiYgbWFwW3R5cGVdO1xuICAgICAgaWYgKGFycikge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKGFyciwgZik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgIHsgbWFwW3R5cGVdID0gYXJyLnNsaWNlKDAsIGluZGV4KS5jb25jYXQoYXJyLnNsaWNlKGluZGV4ICsgMSkpOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSk7XG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7ICsraSkgeyBoYW5kbGVyc1tpXS5hcHBseShudWxsLCBhcmdzKTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcbiAgLy8gcmVnaXN0ZXJpbmcgYSAobm9uLURPTSkgaGFuZGxlciBvbiB0aGUgZWRpdG9yIGZvciB0aGUgZXZlbnQgbmFtZSxcbiAgLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxuICBmdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHsgZSA9IHt0eXBlOiBlLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19OyB9XG4gICAgc2lnbmFsKGNtLCBvdmVycmlkZSB8fCBlLnR5cGUsIGNtLCBlKTtcbiAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtcbiAgICBpZiAoIWFycikgeyByZXR1cm4gfVxuICAgIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7IGlmIChpbmRleE9mKHNldCwgYXJyW2ldKSA9PSAtMSlcbiAgICAgIHsgc2V0LnB1c2goYXJyW2ldKTsgfSB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gQWRkIG9uIGFuZCBvZmYgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLCB0byBtYWtlXG4gIC8vIHJlZ2lzdGVyaW5nIGV2ZW50cyBvbiBzdWNoIG9iamVjdHMgbW9yZSBjb252ZW5pZW50LlxuICBmdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvbih0aGlzLCB0eXBlLCBmKTt9O1xuICAgIGN0b3IucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvZmYodGhpcywgdHlwZSwgZik7fTtcbiAgfVxuXG4gIC8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxuXG4gIGZ1bmN0aW9uIGVfcHJldmVudERlZmF1bHQoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIGVsc2UgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgfVxuICBmdW5jdGlvbiBlX3N0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cbiAgICBlbHNlIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9kZWZhdWx0UHJldmVudGVkKGUpIHtcbiAgICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wKGUpIHtlX3ByZXZlbnREZWZhdWx0KGUpOyBlX3N0b3BQcm9wYWdhdGlvbihlKTt9XG5cbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnR9XG4gIGZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcbiAgICB2YXIgYiA9IGUud2hpY2g7XG4gICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgaWYgKGUuYnV0dG9uICYgMSkgeyBiID0gMTsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSB7IGIgPSAzOyB9XG4gICAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDQpIHsgYiA9IDI7IH1cbiAgICB9XG4gICAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSB7IGIgPSAzOyB9XG4gICAgcmV0dXJuIGJcbiAgfVxuXG4gIC8vIERldGVjdCBkcmFnLWFuZC1kcm9wXG4gIHZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZXJlIGlzICpzb21lKiBraW5kIG9mIGRyYWctYW5kLWRyb3Agc3VwcG9ydCBpbiBJRTYtOCwgYnV0IElcbiAgICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGRpdiA9IGVsdCgnZGl2Jyk7XG4gICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZGl2IHx8IFwiZHJhZ0Ryb3BcIiBpbiBkaXZcbiAgfSgpO1xuXG4gIHZhciB6d3NwU3VwcG9ydGVkO1xuICBmdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcbiAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICB2YXIgdGVzdCA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDBiXCIpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBbdGVzdCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpO1xuICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcbiAgICAgICAgeyB6d3NwU3VwcG9ydGVkID0gdGVzdC5vZmZzZXRXaWR0aCA8PSAxICYmIHRlc3Qub2Zmc2V0SGVpZ2h0ID4gMiAmJiAhKGllICYmIGllX3ZlcnNpb24gPCA4KTsgfVxuICAgIH1cbiAgICB2YXIgbm9kZSA9IHp3c3BTdXBwb3J0ZWQgPyBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKSA6XG4gICAgICBlbHQoXCJzcGFuXCIsIFwiXFx1MDBhMFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLy8gRmVhdHVyZS1kZXRlY3QgSUUncyBjcnVtbXkgY2xpZW50IHJlY3QgcmVwb3J0aW5nIGZvciBiaWRpIHRleHRcbiAgdmFyIGJhZEJpZGlSZWN0cztcbiAgZnVuY3Rpb24gaGFzQmFkQmlkaVJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XG4gICAgdmFyIHR4dCA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQVxcdTA2MmVBXCIpKTtcbiAgICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByMSA9IHJhbmdlKHR4dCwgMSwgMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmVtb3ZlQ2hpbGRyZW4obWVhc3VyZSk7XG4gICAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSB7IHJldHVybiBmYWxzZSB9IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXG4gICAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMylcbiAgfVxuXG4gIC8vIFNlZSBpZiBcIlwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cbiAgLy8gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwbGl0IGxpbmVzLlxuICB2YXIgc3BsaXRMaW5lc0F1dG8gPSBcIlxcblxcbmJcIi5zcGxpdCgvXFxuLykubGVuZ3RoICE9IDMgPyBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDw9IGwpIHtcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICBpZiAobmwgPT0gLTEpIHsgbmwgPSBzdHJpbmcubGVuZ3RoOyB9XG4gICAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcIlxcclwiID8gbmwgLSAxIDogbmwpO1xuICAgICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFwiXFxyXCIpO1xuICAgICAgaWYgKHJ0ICE9IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcbiAgICAgICAgcG9zICs9IHJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBwb3MgPSBubCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyXFxuP3xcXG4vKTsgfTtcblxuICB2YXIgaGFzU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IGZ1bmN0aW9uICh0ZSkge1xuICAgIHRyeSB7IHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfSA6IGZ1bmN0aW9uICh0ZSkge1xuICAgIHZhciByYW5nZTtcbiAgICB0cnkge3JhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTt9XG4gICAgY2F0Y2goZSkge31cbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCByYW5nZSkgIT0gMFxuICB9O1xuXG4gIHZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xuICAgIGlmIChcIm9uY29weVwiIGluIGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFwiZnVuY3Rpb25cIlxuICB9KSgpO1xuXG4gIHZhciBiYWRab29tZWRSZWN0cyA9IG51bGw7XG4gIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxuICAgIHZhciBub2RlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBcInhcIikpO1xuICAgIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gYmFkWm9vbWVkUmVjdHMgPSBNYXRoLmFicyhub3JtYWwubGVmdCAtIGZyb21SYW5nZS5sZWZ0KSA+IDFcbiAgfVxuXG4gIC8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXG4gIHZhciBtb2RlcyA9IHt9LCBtaW1lTW9kZXMgPSB7fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgeyBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7IH1cbiAgICBtb2Rlc1tuYW1lXSA9IG1vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVNSU1FKG1pbWUsIHNwZWMpIHtcbiAgICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxuICAvLyBzdHJpbmcsIHJldHVybiBhIG1vZGUgY29uZmlnIG9iamVjdC5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZGUoc3BlYykge1xuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xuICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcbiAgICB9IGVsc2UgaWYgKHNwZWMgJiYgdHlwZW9mIHNwZWMubmFtZSA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXCJzdHJpbmdcIikgeyBmb3VuZCA9IHtuYW1lOiBmb3VuZH07IH1cbiAgICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xuICAgICAgc3BlYy5uYW1lID0gZm91bmQubmFtZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCt4bWwkLy50ZXN0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCtqc29uJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24vanNvblwiKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIikgeyByZXR1cm4ge25hbWU6IHNwZWN9IH1cbiAgICBlbHNlIHsgcmV0dXJuIHNwZWMgfHwge25hbWU6IFwibnVsbFwifSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBhbiBhY3R1YWwgbW9kZSBvYmplY3QuXG4gIGZ1bmN0aW9uIGdldE1vZGUob3B0aW9ucywgc3BlYykge1xuICAgIHNwZWMgPSByZXNvbHZlTW9kZShzcGVjKTtcbiAgICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdO1xuICAgIGlmICghbWZhY3RvcnkpIHsgcmV0dXJuIGdldE1vZGUob3B0aW9ucywgXCJ0ZXh0L3BsYWluXCIpIH1cbiAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xuICAgIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zW3NwZWMubmFtZV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcbiAgICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3ApKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsgbW9kZU9ialtcIl9cIiArIHByb3BdID0gbW9kZU9ialtwcm9wXTsgfVxuICAgICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZU9iai5uYW1lID0gc3BlYy5uYW1lO1xuICAgIGlmIChzcGVjLmhlbHBlclR5cGUpIHsgbW9kZU9iai5oZWxwZXJUeXBlID0gc3BlYy5oZWxwZXJUeXBlOyB9XG4gICAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcbiAgICAgIHsgbW9kZU9ialtwcm9wJDFdID0gc3BlYy5tb2RlUHJvcHNbcHJvcCQxXTsgfSB9XG5cbiAgICByZXR1cm4gbW9kZU9ialxuICB9XG5cbiAgLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxuICAvLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxuICB2YXIgbW9kZUV4dGVuc2lvbnMgPSB7fTtcbiAgZnVuY3Rpb24gZXh0ZW5kTW9kZShtb2RlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShtb2RlKSA/IG1vZGVFeHRlbnNpb25zW21vZGVdIDogKG1vZGVFeHRlbnNpb25zW21vZGVdID0ge30pO1xuICAgIGNvcHlPYmoocHJvcGVydGllcywgZXh0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U3RhdGUobW9kZSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHRydWUpIHsgcmV0dXJuIHN0YXRlIH1cbiAgICBpZiAobW9kZS5jb3B5U3RhdGUpIHsgcmV0dXJuIG1vZGUuY29weVN0YXRlKHN0YXRlKSB9XG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gc3RhdGUpIHtcbiAgICAgIHZhciB2YWwgPSBzdGF0ZVtuXTtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgeyB2YWwgPSB2YWwuY29uY2F0KFtdKTsgfVxuICAgICAgbnN0YXRlW25dID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbnN0YXRlXG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxuICAvLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxuICBmdW5jdGlvbiBpbm5lck1vZGUobW9kZSwgc3RhdGUpIHtcbiAgICB2YXIgaW5mbztcbiAgICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcbiAgICAgIGluZm8gPSBtb2RlLmlubmVyTW9kZShzdGF0ZSk7XG4gICAgICBpZiAoIWluZm8gfHwgaW5mby5tb2RlID09IG1vZGUpIHsgYnJlYWsgfVxuICAgICAgc3RhdGUgPSBpbmZvLnN0YXRlO1xuICAgICAgbW9kZSA9IGluZm8ubW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm8gfHwge21vZGU6IG1vZGUsIHN0YXRlOiBzdGF0ZX1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RhdGUobW9kZSwgYTEsIGEyKSB7XG4gICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxuICB9XG5cbiAgLy8gU1RSSU5HIFNUUkVBTVxuXG4gIC8vIEZlZCB0byB0aGUgbW9kZSBwYXJzZXJzLCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1ha2VcbiAgLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxuXG4gIHZhciBTdHJpbmdTdHJlYW0gPSBmdW5jdGlvbihzdHJpbmcsIHRhYlNpemUsIGxpbmVPcmFjbGUpIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgODtcbiAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMubGluZU9yYWNsZSA9IGxpbmVPcmFjbGU7XG4gIH07XG5cbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc29sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspIH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICB2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgIHZhciBvaztcbiAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpIHsgb2sgPSBjaCA9PSBtYXRjaDsgfVxuICAgIGVsc2UgeyBvayA9IGNoICYmIChtYXRjaC50ZXN0ID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpOyB9XG4gICAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNofVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFdoaWxlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSl7fVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0U3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpIHsgKyt0aGlzLnBvczsgfVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvRW5kID0gZnVuY3Rpb24gKCkge3RoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgIGlmIChmb3VuZCA+IC0xKSB7dGhpcy5wb3MgPSBmb3VuZDsgcmV0dXJuIHRydWV9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFja1VwID0gZnVuY3Rpb24gKG4pIHt0aGlzLnBvcyAtPSBuO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSkgLVxuICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFyIGNhc2VkID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7IH07XG4gICAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoOyB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyl9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmhpZGVGaXJzdENoYXJzID0gZnVuY3Rpb24gKG4sIGlubmVyKSB7XG4gICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcbiAgICB0cnkgeyByZXR1cm4gaW5uZXIoKSB9XG4gICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG47IH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUubG9va0FoZWFkKG4pXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUuYmFzZVRva2VuKHRoaXMucG9zKVxuICB9O1xuXG4gIC8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBnZXRMaW5lKGRvYywgbikge1xuICAgIG4gLT0gZG9jLmZpcnN0O1xuICAgIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB7IHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpIH1cbiAgICB2YXIgY2h1bmsgPSBkb2M7XG4gICAgd2hpbGUgKCFjaHVuay5saW5lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChuIDwgc3opIHsgY2h1bmsgPSBjaGlsZDsgYnJlYWsgfVxuICAgICAgICBuIC09IHN6O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmsubGluZXNbbl1cbiAgfVxuXG4gIC8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcbiAgLy8gc3RyaW5ncy5cbiAgZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xuICAgIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciB0ZXh0ID0gbGluZS50ZXh0O1xuICAgICAgaWYgKG4gPT0gZW5kLmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTsgfVxuICAgICAgaWYgKG4gPT0gc3RhcnQubGluZSkgeyB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7IH1cbiAgICAgIG91dC5wdXNoKHRleHQpO1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRcbiAgfVxuICAvLyBHZXQgdGhlIGxpbmVzIGJldHdlZW4gZnJvbSBhbmQgdG8sIGFzIGFycmF5IG9mIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldExpbmVzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZG9jLml0ZXIoZnJvbSwgdG8sIGZ1bmN0aW9uIChsaW5lKSB7IG91dC5wdXNoKGxpbmUudGV4dCk7IH0pOyAvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxuICAvLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcbiAgICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0O1xuICAgIGlmIChkaWZmKSB7IGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIHsgbi5oZWlnaHQgKz0gZGlmZjsgfSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcbiAgLy8gaXRzIHBhcmVudCBsaW5rcy5cbiAgZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcbiAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKTtcbiAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIHsgYnJlYWsgfVxuICAgICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxuICAvLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cbiAgZnVuY3Rpb24gbGluZUF0SGVpZ2h0KGNodW5rLCBoKSB7XG4gICAgdmFyIG4gPSBjaHVuay5maXJzdDtcbiAgICBvdXRlcjogZG8ge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpJDFdLCBjaCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlciB9XG4gICAgICAgIGggLT0gY2g7XG4gICAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH0gd2hpbGUgKCFjaHVuay5saW5lcylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXSwgbGggPSBsaW5lLmhlaWdodDtcbiAgICAgIGlmIChoIDwgbGgpIHsgYnJlYWsgfVxuICAgICAgaCAtPSBsaDtcbiAgICB9XG4gICAgcmV0dXJuIG4gKyBpXG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZX1cblxuICBmdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcbiAgICByZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKVxuICB9XG5cbiAgLy8gQSBQb3MgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gUG9zKGxpbmUsIGNoLCBzdGlja3kpIHtcbiAgICBpZiAoIHN0aWNreSA9PT0gdm9pZCAwICkgc3RpY2t5ID0gbnVsbDtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSB7IHJldHVybiBuZXcgUG9zKGxpbmUsIGNoLCBzdGlja3kpIH1cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY2ggPSBjaDtcbiAgICB0aGlzLnN0aWNreSA9IHN0aWNreTtcbiAgfVxuXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbiAgLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoIH1cblxuICBmdW5jdGlvbiBlcXVhbEN1cnNvclBvcyhhLCBiKSB7IHJldHVybiBhLnN0aWNreSA9PSBiLnN0aWNreSAmJiBjbXAoYSwgYikgPT0gMCB9XG5cbiAgZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpfVxuICBmdW5jdGlvbiBtYXhQb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGIgOiBhIH1cbiAgZnVuY3Rpb24gbWluUG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYiB9XG5cbiAgLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKX1cbiAgZnVuY3Rpb24gY2xpcFBvcyhkb2MsIHBvcykge1xuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCkgeyByZXR1cm4gUG9zKGRvYy5maXJzdCwgMCkgfVxuICAgIHZhciBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChwb3MubGluZSA+IGxhc3QpIHsgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpIH1cbiAgICByZXR1cm4gY2xpcFRvTGVuKHBvcywgZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0Lmxlbmd0aClcbiAgfVxuICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XG4gICAgdmFyIGNoID0gcG9zLmNoO1xuICAgIGlmIChjaCA9PSBudWxsIHx8IGNoID4gbGluZWxlbikgeyByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKSB9XG4gICAgZWxzZSBpZiAoY2ggPCAwKSB7IHJldHVybiBQb3MocG9zLmxpbmUsIDApIH1cbiAgICBlbHNlIHsgcmV0dXJuIHBvcyB9XG4gIH1cbiAgZnVuY3Rpb24gY2xpcFBvc0FycmF5KGRvYywgYXJyYXkpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBjbGlwUG9zKGRvYywgYXJyYXlbaV0pOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgdmFyIFNhdmVkQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXRlLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gIH07XG5cbiAgdmFyIENvbnRleHQgPSBmdW5jdGlvbihkb2MsIHN0YXRlLCBsaW5lLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLm1heExvb2tBaGVhZCA9IGxvb2tBaGVhZCB8fCAwO1xuICAgIHRoaXMuYmFzZVRva2VucyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVG9rZW5Qb3MgPSAxO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2tBaGVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHRoaXMubGluZSArIG4pO1xuICAgIGlmIChsaW5lICE9IG51bGwgJiYgbiA+IHRoaXMubWF4TG9va0FoZWFkKSB7IHRoaXMubWF4TG9va0FoZWFkID0gbjsgfVxuICAgIHJldHVybiBsaW5lXG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVRva2VucykgeyByZXR1cm4gbnVsbCB9XG4gICAgd2hpbGUgKHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10gPD0gbilcbiAgICAgIHsgdGhpcy5iYXNlVG9rZW5Qb3MgKz0gMjsgfVxuICAgIHZhciB0eXBlID0gdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zICsgMV07XG4gICAgcmV0dXJuIHt0eXBlOiB0eXBlICYmIHR5cGUucmVwbGFjZSgvKCB8XilvdmVybGF5IC4qLywgXCJcIiksXG4gICAgICAgICAgICBzaXplOiB0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIC0gbn1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpbmUrKztcbiAgICBpZiAodGhpcy5tYXhMb29rQWhlYWQgPiAwKSB7IHRoaXMubWF4TG9va0FoZWFkLS07IH1cbiAgfTtcblxuICBDb250ZXh0LmZyb21TYXZlZCA9IGZ1bmN0aW9uIChkb2MsIHNhdmVkLCBsaW5lKSB7XG4gICAgaWYgKHNhdmVkIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0KVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkLnN0YXRlKSwgbGluZSwgc2F2ZWQubG9va0FoZWFkKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkKSwgbGluZSkgfVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoY29weSkge1xuICAgIHZhciBzdGF0ZSA9IGNvcHkgIT09IGZhbHNlID8gY29weVN0YXRlKHRoaXMuZG9jLm1vZGUsIHRoaXMuc3RhdGUpIDogdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdGhpcy5tYXhMb29rQWhlYWQgPiAwID8gbmV3IFNhdmVkQ29udGV4dChzdGF0ZSwgdGhpcy5tYXhMb29rQWhlYWQpIDogc3RhdGVcbiAgfTtcblxuXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxuICAvLyAtLSBmb3IgaW52YWxpZGF0aW9uIC0tIGZvbGxvd2VkIGJ5IHBhaXJzIG9mIGVuZCBwb3NpdGlvbnMgYW5kXG4gIC8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxuICAvLyBsaW5lLlxuICBmdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCBmb3JjZVRvRW5kKSB7XG4gICAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxuICAgIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cbiAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XG4gICAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcbiAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkgeyByZXR1cm4gc3QucHVzaChlbmQsIHN0eWxlKTsgfSxcbiAgICAgICAgICAgIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKTtcbiAgICB2YXIgc3RhdGUgPSBjb250ZXh0LnN0YXRlO1xuXG4gICAgLy8gUnVuIG92ZXJsYXlzLCBhZGp1c3Qgc3R5bGUgYXJyYXkuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG8gKSB7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBzdDtcbiAgICAgIHZhciBvdmVybGF5ID0gY20uc3RhdGUub3ZlcmxheXNbb10sIGkgPSAxLCBhdCA9IDA7XG4gICAgICBjb250ZXh0LnN0YXRlID0gdHJ1ZTtcbiAgICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcbiAgICAgICAgd2hpbGUgKGF0IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIGlfZW5kID0gc3RbaV07XG4gICAgICAgICAgaWYgKGlfZW5kID4gZW5kKVxuICAgICAgICAgICAgeyBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCk7IH1cbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XG4gICAgICAgIGlmIChvdmVybGF5Lm9wYXF1ZSkge1xuICAgICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFwib3ZlcmxheSBcIiArIHN0eWxlKTtcbiAgICAgICAgICBpID0gc3RhcnQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCsxXTtcbiAgICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFwiIFwiIDogXCJcIikgKyBcIm92ZXJsYXkgXCIgKyBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGxpbmVDbGFzc2VzKTtcbiAgICAgIGNvbnRleHQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIGNvbnRleHQuYmFzZVRva2VucyA9IG51bGw7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlblBvcyA9IDE7XG4gICAgfTtcblxuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgY20uc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK28pIGxvb3AoIG8gKTtcblxuICAgIHJldHVybiB7c3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGx9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xuICAgIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xuICAgICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBsaW5lTm8obGluZSkpO1xuICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggJiYgY29weVN0YXRlKGNtLmRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZXNldFN0YXRlKSB7IGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlOyB9XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoIXJlc2V0U3RhdGUpO1xuICAgICAgbGluZS5zdHlsZXMgPSByZXN1bHQuc3R5bGVzO1xuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7IH1cbiAgICAgIGVsc2UgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxuICAgICAgaWYgKHVwZGF0ZUZyb250aWVyID09PSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIpXG4gICAgICAgIHsgY20uZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGNtLmRvYy5tb2RlRnJvbnRpZXIsICsrY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKTsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZS5zdHlsZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRCZWZvcmUoY20sIG4sIHByZWNpc2UpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRvYy5tb2RlLnN0YXJ0U3RhdGUpIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgdHJ1ZSwgbikgfVxuICAgIHZhciBzdGFydCA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpO1xuICAgIHZhciBzYXZlZCA9IHN0YXJ0ID4gZG9jLmZpcnN0ICYmIGdldExpbmUoZG9jLCBzdGFydCAtIDEpLnN0YXRlQWZ0ZXI7XG4gICAgdmFyIGNvbnRleHQgPSBzYXZlZCA/IENvbnRleHQuZnJvbVNhdmVkKGRvYywgc2F2ZWQsIHN0YXJ0KSA6IG5ldyBDb250ZXh0KGRvYywgc3RhcnRTdGF0ZShkb2MubW9kZSksIHN0YXJ0KTtcblxuICAgIGRvYy5pdGVyKHN0YXJ0LCBuLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgY29udGV4dCk7XG4gICAgICB2YXIgcG9zID0gY29udGV4dC5saW5lO1xuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbyA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICB9KTtcbiAgICBpZiAocHJlY2lzZSkgeyBkb2MubW9kZUZyb250aWVyID0gY29udGV4dC5saW5lOyB9XG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfVxuXG4gIC8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxuICAvLyBhcmVuJ3QgY3VycmVudGx5IHZpc2libGUuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBjb250ZXh0LCBzdGFydEF0KSB7XG4gICAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUsIGNvbnRleHQpO1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgPSBzdGFydEF0IHx8IDA7XG4gICAgaWYgKHRleHQgPT0gXCJcIikgeyBjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpOyB9XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxuICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIH1cbiAgICB2YXIgaW5uZXIgPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpO1xuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gaW5uZXIubW9kZS5ibGFua0xpbmUoaW5uZXIuc3RhdGUpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgaWYgKGlubmVyKSB7IGlubmVyWzBdID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlOyB9XG4gICAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpIHsgcmV0dXJuIHN0eWxlIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBcIiArIG1vZGUubmFtZSArIFwiIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIilcbiAgfVxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uKHN0cmVhbSwgdHlwZSwgc3RhdGUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RyZWFtLnN0YXJ0OyB0aGlzLmVuZCA9IHN0cmVhbS5wb3M7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xuICBmdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XG4gICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLCBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgdG9rZW5zO1xuICAgIGlmIChhc0FycmF5KSB7IHRva2VucyA9IFtdOyB9XG4gICAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgaWYgKGFzQXJyYXkpIHsgdG9rZW5zLnB1c2gobmV3IFRva2VuKHN0cmVhbSwgc3R5bGUsIGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkpKTsgfVxuICAgIH1cbiAgICByZXR1cm4gYXNBcnJheSA/IHRva2VucyA6IG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb250ZXh0LnN0YXRlKVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xuICAgIGlmICh0eXBlKSB7IGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lQ2xhc3MgPSB0eXBlLm1hdGNoKC8oPzpefFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFMrKS8pO1xuICAgICAgaWYgKCFsaW5lQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgbGluZUNsYXNzLmluZGV4KSArIHR5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4ICsgbGluZUNsYXNzWzBdLmxlbmd0aCk7XG4gICAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFwiYmdDbGFzc1wiIDogXCJ0ZXh0Q2xhc3NcIjtcbiAgICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcbiAgICAgICAgeyBvdXRwdXRbcHJvcF0gPSBsaW5lQ2xhc3NbMl07IH1cbiAgICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIgKyBsaW5lQ2xhc3NbMl0gKyBcIig/OiR8XFxcXHMpXCIpKS50ZXN0KG91dHB1dFtwcm9wXSkpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdICs9IFwiIFwiICsgbGluZUNsYXNzWzJdOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxuICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBjb250ZXh0LCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xuICAgIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFucztcbiAgICBpZiAoZmxhdHRlblNwYW5zID09IG51bGwpIHsgZmxhdHRlblNwYW5zID0gY20ub3B0aW9ucy5mbGF0dGVuU3BhbnM7IH1cbiAgICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgc3R5bGU7XG4gICAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgY29udGV4dC5zdGF0ZSksIGxpbmVDbGFzc2VzKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlO1xuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgeyBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RyZWFtLnBvcyk7IH1cbiAgICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgICBzdHlsZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlLCBpbm5lciksIGxpbmVDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbm5lcikge1xuICAgICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lO1xuICAgICAgICBpZiAobU5hbWUpIHsgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gTWF0aC5taW4oc3RyZWFtLnN0YXJ0LCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJTdHlsZSA9IHN0eWxlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xuICAgICAgLy8gV2Via2l0IHNlZW1zIHRvIHJlZnVzZSB0byByZW5kZXIgdGV4dCBub2RlcyBsb25nZXIgdGhhbiA1NzQ0NFxuICAgICAgLy8gY2hhcmFjdGVycywgYW5kIHJldHVybnMgaW5hY2N1cmF0ZSBtZWFzdXJlbWVudHMgaW4gbm9kZXNcbiAgICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxuICAgICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMCk7XG4gICAgICBmKHBvcywgY3VyU3R5bGUpO1xuICAgICAgY3VyU3RhcnQgPSBwb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZHMgdGhlIGxpbmUgdG8gc3RhcnQgd2l0aCB3aGVuIHN0YXJ0aW5nIGEgcGFyc2UuIFRyaWVzIHRvXG4gIC8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcbiAgLy8gdmFsaWQgc3RhdGUuIElmIHRoYXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIGxpbmUgd2l0aCB0aGVcbiAgLy8gc21hbGxlc3QgaW5kZW50YXRpb24sIHdoaWNoIHRlbmRzIHRvIG5lZWQgdGhlIGxlYXN0IGNvbnRleHQgdG9cbiAgLy8gcGFyc2UgY29ycmVjdGx5LlxuICBmdW5jdGlvbiBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIG1pbmluZGVudCwgbWlubGluZSwgZG9jID0gY20uZG9jO1xuICAgIHZhciBsaW0gPSBwcmVjaXNlID8gLTEgOiBuIC0gKGNtLmRvYy5tb2RlLmlubmVyTW9kZSA/IDEwMDAgOiAxMDApO1xuICAgIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcbiAgICAgIGlmIChzZWFyY2ggPD0gZG9jLmZpcnN0KSB7IHJldHVybiBkb2MuZmlyc3QgfVxuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgc2VhcmNoIC0gMSksIGFmdGVyID0gbGluZS5zdGF0ZUFmdGVyO1xuICAgICAgaWYgKGFmdGVyICYmICghcHJlY2lzZSB8fCBzZWFyY2ggKyAoYWZ0ZXIgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQgPyBhZnRlci5sb29rQWhlYWQgOiAwKSA8PSBkb2MubW9kZUZyb250aWVyKSlcbiAgICAgICAgeyByZXR1cm4gc2VhcmNoIH1cbiAgICAgIHZhciBpbmRlbnRlZCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgY20ub3B0aW9ucy50YWJTaXplKTtcbiAgICAgIGlmIChtaW5saW5lID09IG51bGwgfHwgbWluaW5kZW50ID4gaW5kZW50ZWQpIHtcbiAgICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDE7XG4gICAgICAgIG1pbmluZGVudCA9IGluZGVudGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWlubGluZVxuICB9XG5cbiAgZnVuY3Rpb24gcmV0cmVhdEZyb250aWVyKGRvYywgbikge1xuICAgIGRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1pbihkb2MubW9kZUZyb250aWVyLCBuKTtcbiAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgbiAtIDEwKSB7IHJldHVybiB9XG4gICAgdmFyIHN0YXJ0ID0gZG9jLmZpcnN0O1xuICAgIGZvciAodmFyIGxpbmUgPSBuIC0gMTsgbGluZSA+IHN0YXJ0OyBsaW5lLS0pIHtcbiAgICAgIHZhciBzYXZlZCA9IGdldExpbmUoZG9jLCBsaW5lKS5zdGF0ZUFmdGVyO1xuICAgICAgLy8gY2hhbmdlIGlzIG9uIDNcbiAgICAgIC8vIHN0YXRlIG9uIGxpbmUgMSBsb29rZWQgYWhlYWQgMiAtLSBzbyBzYXcgM1xuICAgICAgLy8gdGVzdCAxICsgMiA8IDMgc2hvdWxkIGNvdmVyIHRoaXNcbiAgICAgIGlmIChzYXZlZCAmJiAoIShzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dCkgfHwgbGluZSArIHNhdmVkLmxvb2tBaGVhZCA8IG4pKSB7XG4gICAgICAgIHN0YXJ0ID0gbGluZSArIDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IE1hdGgubWluKGRvYy5oaWdobGlnaHRGcm9udGllciwgc3RhcnQpO1xuICB9XG5cbiAgLy8gT3B0aW1pemUgc29tZSBjb2RlIHdoZW4gdGhlc2UgZmVhdHVyZXMgYXJlIG5vdCB1c2VkLlxuICB2YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlLCBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XG4gICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVDb2xsYXBzZWRTcGFucygpIHtcbiAgICBzYXdDb2xsYXBzZWRTcGFucyA9IHRydWU7XG4gIH1cblxuICAvLyBURVhUTUFSS0VSIFNQQU5TXG5cbiAgZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XG4gICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xuICB9XG5cbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cbiAgZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XG4gICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSB7IHJldHVybiBzcGFuIH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhIHNwYW4gZnJvbSBhbiBhcnJheSwgcmV0dXJuaW5nIHVuZGVmaW5lZCBpZiBubyBzcGFucyBhcmVcbiAgLy8gbGVmdCAod2UgZG9uJ3Qgc3RvcmUgYXJyYXlzIGZvciBsaW5lcyB3aXRob3V0IHNwYW5zKS5cbiAgZnVuY3Rpb24gcmVtb3ZlTWFya2VkU3BhbihzcGFucywgc3Bhbikge1xuICAgIHZhciByO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IGlmIChzcGFuc1tpXSAhPSBzcGFuKSB7IChyIHx8IChyID0gW10pKS5wdXNoKHNwYW5zW2ldKTsgfSB9XG4gICAgcmV0dXJuIHJcbiAgfVxuXG4gIC8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxuICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4sIG9wKSB7XG4gICAgdmFyIGluVGhpc09wID0gb3AgJiYgd2luZG93LldlYWtTZXQgJiYgKG9wLm1hcmtlZFNwYW5zIHx8IChvcC5tYXJrZWRTcGFucyA9IG5ldyBXZWFrU2V0KSk7XG4gICAgaWYgKGluVGhpc09wICYmIGluVGhpc09wLmhhcyhsaW5lLm1hcmtlZFNwYW5zKSkge1xuICAgICAgbGluZS5tYXJrZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgICBpZiAoaW5UaGlzT3ApIHsgaW5UaGlzT3AuYWRkKGxpbmUubWFya2VkU3BhbnMpOyB9XG4gICAgfVxuICAgIHNwYW4ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XG4gIH1cblxuICAvLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIFRoZXNlIGZ1bmN0aW9ucyBjdXQgYW4gYXJyYXkgb2Ygc3BhbnMgYXQgYSBnaXZlblxuICAvLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxuICAvLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNCZWZvcmUob2xkLCBzdGFydENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcbiAgICAgIGlmIChzdGFydHNCZWZvcmUgfHwgc3Bhbi5mcm9tID09IHN0YXJ0Q2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gbndcbiAgfVxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0FmdGVyKG9sZCwgZW5kQ2gsIGlzSW5zZXJ0KSB7XG4gICAgdmFyIG53O1xuICAgIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xuICAgICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHN0YXJ0c0JlZm9yZSA/IG51bGwgOiBzcGFuLmZyb20gLSBlbmRDaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cblxuICAvLyBHaXZlbiBhIGNoYW5nZSBvYmplY3QsIGNvbXB1dGUgdGhlIG5ldyBzZXQgb2YgbWFya2VyIHNwYW5zIHRoYXRcbiAgLy8gY292ZXIgdGhlIGxpbmUgaW4gd2hpY2ggdGhlIGNoYW5nZSB0b29rIHBsYWNlLiBSZW1vdmVzIHNwYW5zXG4gIC8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcbiAgLy8gc2FtZSBtYXJrZXIgdGhhdCBhcHBlYXIgb24gYm90aCBzaWRlcyBvZiB0aGUgY2hhbmdlLCBhbmQgY3V0cyBvZmZcbiAgLy8gc3BhbnMgcGFydGlhbGx5IHdpdGhpbiB0aGUgY2hhbmdlLiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYW5cbiAgLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcbiAgICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgIGlmICghb2xkRmlyc3QgJiYgIW9sZExhc3QpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIHN0YXJ0Q2ggPSBjaGFuZ2UuZnJvbS5jaCwgZW5kQ2ggPSBjaGFuZ2UudG8uY2gsIGlzSW5zZXJ0ID0gY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDA7XG4gICAgLy8gR2V0IHRoZSBzcGFucyB0aGF0ICdzdGljayBvdXQnIG9uIGJvdGggc2lkZXNcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xuICAgIHZhciBsYXN0ID0gbWFya2VkU3BhbnNBZnRlcihvbGRMYXN0LCBlbmRDaCwgaXNJbnNlcnQpO1xuXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcbiAgICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMCk7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBmaXJzdFtpXTtcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IobGFzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQpIHsgc3Bhbi50byA9IHN0YXJ0Q2g7IH1cbiAgICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgeyBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0KSB7XG4gICAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxhc3QubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgc3BhbiQxID0gbGFzdFtpJDFdO1xuICAgICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHsgc3BhbiQxLnRvICs9IG9mZnNldDsgfVxuICAgICAgICBpZiAoc3BhbiQxLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCQxID0gZ2V0TWFya2VkU3BhbkZvcihmaXJzdCwgc3BhbiQxLm1hcmtlcik7XG4gICAgICAgICAgaWYgKCFmb3VuZCQxKSB7XG4gICAgICAgICAgICBzcGFuJDEuZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhbiQxLmZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgZGlkbid0IGNyZWF0ZSBhbnkgemVyby1sZW5ndGggc3BhbnNcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpOyB9XG4gICAgaWYgKGxhc3QgJiYgbGFzdCAhPSBmaXJzdCkgeyBsYXN0ID0gY2xlYXJFbXB0eVNwYW5zKGxhc3QpOyB9XG5cbiAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XG4gICAgaWYgKCFzYW1lTGluZSkge1xuICAgICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXG4gICAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcbiAgICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxuICAgICAgICB7IGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpcnN0Lmxlbmd0aDsgKytpJDIpXG4gICAgICAgICAgeyBpZiAoZmlyc3RbaSQyXS50byA9PSBudWxsKVxuICAgICAgICAgICAgeyAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpJDJdLm1hcmtlciwgbnVsbCwgbnVsbCkpOyB9IH0gfVxuICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2FwOyArK2kkMylcbiAgICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7IH1cbiAgICAgIG5ld01hcmtlcnMucHVzaChsYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcmtlcnNcbiAgfVxuXG4gIC8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XG4gIC8vIG9wdGlvbiBvZiBmYWxzZS5cbiAgZnVuY3Rpb24gY2xlYXJFbXB0eVNwYW5zKHNwYW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICAgIHsgc3BhbnMuc3BsaWNlKGktLSwgMSk7IH1cbiAgICB9XG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBzcGFuc1xuICB9XG5cbiAgLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cbiAgZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xuICAgIHZhciBtYXJrZXJzID0gbnVsbDtcbiAgICBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXI7XG4gICAgICAgIGlmIChtYXJrLnJlYWRPbmx5ICYmICghbWFya2VycyB8fCBpbmRleE9mKG1hcmtlcnMsIG1hcmspID09IC0xKSlcbiAgICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspOyB9XG4gICAgICB9IH1cbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlcnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHAgPSBwYXJ0c1tqXTtcbiAgICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pO1xuICAgICAgICBpZiAoZGZyb20gPCAwIHx8ICFtay5pbmNsdXNpdmVMZWZ0ICYmICFkZnJvbSlcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pOyB9XG4gICAgICAgIGlmIChkdG8gPiAwIHx8ICFtay5pbmNsdXNpdmVSaWdodCAmJiAhZHRvKVxuICAgICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KTsgfVxuICAgICAgICBwYXJ0cy5zcGxpY2UuYXBwbHkocGFydHMsIG5ld1BhcnRzKTtcbiAgICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHNcbiAgfVxuXG4gIC8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cbiAgZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSkge1xuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSwgc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHsgc3BhbnNbaV0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7IH1cbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XG4gIH1cblxuICAvLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cbiAgLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxuICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IC0xIDogMCB9XG4gIGZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcbiAgLy8gc3BhbnMgaXMgbGFyZ2VyIChhbmQgdGh1cyBpbmNsdWRlcyB0aGUgb3RoZXIpLiBGYWxscyBiYWNrIHRvXG4gIC8vIGNvbXBhcmluZyBpZHMgd2hlbiB0aGUgc3BhbnMgY292ZXIgZXhhY3RseSB0aGUgc2FtZSByYW5nZS5cbiAgZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xuICAgIHZhciBsZW5EaWZmID0gYS5saW5lcy5sZW5ndGggLSBiLmxpbmVzLmxlbmd0aDtcbiAgICBpZiAobGVuRGlmZiAhPSAwKSB7IHJldHVybiBsZW5EaWZmIH1cbiAgICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKCk7XG4gICAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKTtcbiAgICBpZiAoZnJvbUNtcCkgeyByZXR1cm4gLWZyb21DbXAgfVxuICAgIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKTtcbiAgICBpZiAodG9DbXApIHsgcmV0dXJuIHRvQ21wIH1cbiAgICByZXR1cm4gYi5pZCAtIGEuaWRcbiAgfVxuXG4gIC8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXG4gIC8vIHNvLCByZXR1cm4gdGhlIG1hcmtlciBmb3IgdGhhdCBzcGFuLlxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxuICAgICAgICB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIGZhbHNlKSB9XG5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkFyb3VuZChsaW5lLCBjaCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3AuZnJvbSA9PSBudWxsIHx8IHNwLmZyb20gPCBjaCkgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBjaCkgJiZcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpIHsgZm91bmQgPSBzcC5tYXJrZXI7IH1cbiAgICB9IH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxuICAvLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cbiAgLy8gU3VjaCBvdmVybGFwIGlzIG5vdCBhbGxvd2VkLlxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKTtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgdmFyIGZvdW5kID0gc3AubWFya2VyLmZpbmQoMCk7XG4gICAgICB2YXIgZnJvbUNtcCA9IGNtcChmb3VuZC5mcm9tLCBmcm9tKSB8fCBleHRyYUxlZnQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpO1xuICAgICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpO1xuICAgICAgaWYgKGZyb21DbXAgPj0gMCAmJiB0b0NtcCA8PSAwIHx8IGZyb21DbXAgPD0gMCAmJiB0b0NtcCA+PSAwKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxuICAgICAgICAgIGZyb21DbXAgPj0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLmZyb20sIHRvKSA8PSAwIDogY21wKGZvdW5kLmZyb20sIHRvKSA8IDApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIEEgdmlzdWFsIGxpbmUgaXMgYSBsaW5lIGFzIGRyYXduIG9uIHRoZSBzY3JlZW4uIEZvbGRpbmcsIGZvclxuICAvLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcbiAgLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIGlzIHBhcnQgb2YgKHVzdWFsbHkgdGhhdCBpcyB0aGUgbGluZSBpdHNlbGYpLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmQobGluZSkge1xuICAgIHZhciBtZXJnZWQ7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXG4gIC8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVDb250aW51ZWQobGluZSkge1xuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lXG4gICAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBudW1iZXIgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIHZpcyA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XG4gICAgcmV0dXJuIGxpbmVObyh2aXMpXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxuICAvLyB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZE5vKGRvYywgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gbGluZU4gfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkO1xuICAgIGlmICghbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxuICAgICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lTm8obGluZSkgKyAxXG4gIH1cblxuICAvLyBDb21wdXRlIHdoZXRoZXIgYSBsaW5lIGlzIGhpZGRlbi4gTGluZXMgY291bnQgYXMgaGlkZGVuIHdoZW4gdGhleVxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXG4gIC8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSAwICYmIHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0ICYmIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwYW4pIHtcbiAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpXG4gICAgfVxuICAgIGlmIChzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBzcGFuLnRvID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmICFzcC5tYXJrZXIud2lkZ2V0Tm9kZSAmJiBzcC5mcm9tID09IHNwYW4udG8gJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXG4gICAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxuICAgICAgICAgIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIGhlaWdodEF0TGluZShsaW5lT2JqKSB7XG4gICAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iaik7XG5cbiAgICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXTtcbiAgICAgIGlmIChsaW5lID09IGxpbmVPYmopIHsgYnJlYWsgfVxuICAgICAgZWxzZSB7IGggKz0gbGluZS5oZWlnaHQ7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baSQxXTtcbiAgICAgICAgaWYgKGN1ciA9PSBjaHVuaykgeyBicmVhayB9XG4gICAgICAgIGVsc2UgeyBoICs9IGN1ci5oZWlnaHQ7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgYSBsaW5lLCB0YWtpbmcgaW50byBhY2NvdW50XG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxuICAvLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxuICBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgeyByZXR1cm4gMCB9XG4gICAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBjdXIgPSBmb3VuZC5mcm9tLmxpbmU7XG4gICAgICBsZW4gKz0gZm91bmQuZnJvbS5jaCAtIGZvdW5kLnRvLmNoO1xuICAgIH1cbiAgICBjdXIgPSBsaW5lO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kJDEgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLmZyb20uY2g7XG4gICAgICBjdXIgPSBmb3VuZCQxLnRvLmxpbmU7XG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS50by5jaDtcbiAgICB9XG4gICAgcmV0dXJuIGxlblxuICB9XG5cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcbiAgICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSk7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBsZW4gPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgIGQubWF4TGluZSA9IGxpbmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBMSU5FIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcbiAgLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxuICB2YXIgTGluZSA9IGZ1bmN0aW9uKHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgYXR0YWNoTWFya2VkU3BhbnModGhpcywgbWFya2VkU3BhbnMpO1xuICAgIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDE7XG4gIH07XG5cbiAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZU5vKHRoaXMpIH07XG4gIGV2ZW50TWl4aW4oTGluZSk7XG5cbiAgLy8gQ2hhbmdlIHRoZSBjb250ZW50ICh0ZXh0LCBtYXJrZXJzKSBvZiBhIGxpbmUuIEF1dG9tYXRpY2FsbHlcbiAgLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcbiAgLy8gbGluZSdzIGhlaWdodC5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICBsaW5lLnRleHQgPSB0ZXh0O1xuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGw7IH1cbiAgICBpZiAobGluZS5vcmRlciAhPSBudWxsKSB7IGxpbmUub3JkZXIgPSBudWxsOyB9XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gICAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpO1xuICAgIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcbiAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICB9XG5cbiAgLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cbiAgZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xuICAgIGxpbmUucGFyZW50ID0gbnVsbDtcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxuICAvLyBhbmQgYWxzbyBsb29rcyBmb3IgbGluZS13aWRlIHN0eWxlcy5cbiAgdmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge30sIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghc3R5bGUgfHwgL15cXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuYWRkTW9kZUNsYXNzID8gc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA6IHN0eWxlVG9DbGFzc0NhY2hlO1xuICAgIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcbiAgICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFMrL2csIFwiY20tJCZcIikpXG4gIH1cblxuICAvLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXG4gIC8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcbiAgLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cbiAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcbiAgLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxuICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXG4gICAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXG4gICAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cbiAgICB2YXIgY29udGVudCA9IGVsdFAoXCJzcGFuXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFwicGFkZGluZy1yaWdodDogLjFweFwiIDogbnVsbCk7XG4gICAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHRQKFwicHJlXCIsIFtjb250ZW50XSwgXCJDb2RlTWlycm9yLWxpbmVcIiksIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgY29sOiAwLCBwb3M6IDAsIGNtOiBjbSxcbiAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICBzcGxpdFNwYWNlczogY20uZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpfTtcbiAgICBsaW5lVmlldy5tZWFzdXJlID0ge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGxvZ2ljYWwgbGluZXMgdGhhdCBtYWtlIHVwIHRoaXMgdmlzdWFsIGxpbmUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSAodm9pZCAwKTtcbiAgICAgIGJ1aWxkZXIucG9zID0gMDtcbiAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuO1xuICAgICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXG4gICAgICAvLyBhbGdvcml0aG0sIHRvIGRlYWwgd2l0aCBicm93c2VyIHF1aXJrcy5cbiAgICAgIGlmIChoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSAmJiAob3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSkpXG4gICAgICAgIHsgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTsgfVxuICAgICAgYnVpbGRlci5tYXAgPSBbXTtcbiAgICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKTtcbiAgICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKTtcbiAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcykge1xuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxuICAgICAgICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXG4gICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXG4gICAgICAgIHsgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7IH1cblxuICAgICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLm1hcCA9IGJ1aWxkZXIubWFwO1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XG4gICAgICB9IGVsc2Uge1xuICAobGluZVZpZXcubWVhc3VyZS5tYXBzIHx8IChsaW5lVmlldy5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goYnVpbGRlci5tYXApXG4gICAgICAgIDsobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZWUgaXNzdWUgIzI5MDFcbiAgICBpZiAod2Via2l0KSB7XG4gICAgICB2YXIgbGFzdCA9IGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoL1xcYmNtLXRhYlxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSkgfHwgKGxhc3QucXVlcnlTZWxlY3RvciAmJiBsYXN0LnF1ZXJ5U2VsZWN0b3IoXCIuY20tdGFiXCIpKSlcbiAgICAgICAgeyBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCI7IH1cbiAgICB9XG5cbiAgICBzaWduYWwoY20sIFwicmVuZGVyTGluZVwiLCBjbSwgbGluZVZpZXcubGluZSwgYnVpbGRlci5wcmUpO1xuICAgIGlmIChidWlsZGVyLnByZS5jbGFzc05hbWUpXG4gICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuXG4gICAgcmV0dXJuIGJ1aWxkZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XG4gICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBcIlxcdTIwMjJcIiwgXCJjbS1pbnZhbGlkY2hhclwiKTtcbiAgICB0b2tlbi50aXRsZSA9IFwiXFxcXHVcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgIHRva2VuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9rZW4udGl0bGUpO1xuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cbiAgLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgIGlmICghdGV4dCkgeyByZXR1cm4gfVxuICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dDtcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xuICAgIHZhciBjb250ZW50O1xuICAgIGlmICghc3BlY2lhbC50ZXN0KHRleHQpKSB7XG4gICAgICBidWlsZGVyLmNvbCArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dCk7XG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBtdXN0V3JhcCA9IHRydWU7IH1cbiAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcbiAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBza2lwcGVkID0gbSA/IG0uaW5kZXggLSBwb3MgOiB0ZXh0Lmxlbmd0aCAtIHBvcztcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KTsgfVxuICAgICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xuICAgICAgICAgIGJ1aWxkZXIucG9zICs9IHNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtKSB7IGJyZWFrIH1cbiAgICAgICAgcG9zICs9IHNraXBwZWQgKyAxO1xuICAgICAgICB2YXIgdHh0JDEgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKG1bMF0gPT0gXCJcXHRcIikge1xuICAgICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZTtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBzcGFjZVN0cih0YWJXaWR0aCksIFwiY20tdGFiXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcXHRcIik7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gdGFiV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcIlxcclwiIHx8IG1bMF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIG1bMF0gPT0gXCJcXHJcIiA/IFwiXFx1MjQwZFwiIDogXCJcXHUyNDI0XCIsIFwiY20taW52YWxpZGNoYXJcIikpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eHQkMSA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0JDFdKSk7IH1cbiAgICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQkMSk7IH1cbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgMSwgdHh0JDEpO1xuICAgICAgICBidWlsZGVyLnBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBkaXNwbGF5VGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSkgPT0gMzI7XG4gICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzIHx8IGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBmdWxsU3R5bGUgPSBzdHlsZSB8fCBcIlwiO1xuICAgICAgaWYgKHN0YXJ0U3R5bGUpIHsgZnVsbFN0eWxlICs9IHN0YXJ0U3R5bGU7IH1cbiAgICAgIGlmIChlbmRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gZW5kU3R5bGU7IH1cbiAgICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgW2NvbnRlbnRdLCBmdWxsU3R5bGUsIGNzcyk7XG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJpYnV0ZXMpIHsgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgYXR0ciAhPSBcInN0eWxlXCIgJiYgYXR0ciAhPSBcImNsYXNzXCIpXG4gICAgICAgICAgeyB0b2tlbi5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7IH0gfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh0b2tlbilcbiAgICB9XG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gQ2hhbmdlIHNvbWUgc3BhY2VzIHRvIE5CU1AgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNvbGxhcHNpbmdcbiAgLy8gdHJhaWxpbmcgc3BhY2VzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIHdoZW4gcmVuZGVyaW5nIHRleHQgKGlzc3VlICMxMzYyKS5cbiAgZnVuY3Rpb24gc3BsaXRTcGFjZXModGV4dCwgdHJhaWxpbmdCZWZvcmUpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmICEvICAvLnRlc3QodGV4dCkpIHsgcmV0dXJuIHRleHQgfVxuICAgIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICBpZiAoY2ggPT0gXCIgXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxuICAgICAgICB7IGNoID0gXCJcXHUwMGEwXCI7IH1cbiAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgIHNwYWNlQmVmb3JlID0gY2ggPT0gXCIgXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNlIGRpbWVuc2lvbnMgYmVpbmcgcmVwb3J0ZWQgZm9yIHN0cmV0Y2hlcyBvZlxuICAvLyByaWdodC10by1sZWZ0IHRleHQuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW5CYWRCaWRpKGlubmVyLCBvcmRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHN0eWxlID0gc3R5bGUgPyBzdHlsZSArIFwiIGNtLWZvcmNlLWJvcmRlclwiIDogXCJjbS1mb3JjZS1ib3JkZXJcIjtcbiAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICAvLyBGaW5kIHRoZSBwYXJ0IHRoYXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgdGhpcyB0ZXh0XG4gICAgICAgIHZhciBwYXJ0ID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgeyByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIH1cbiAgICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgc3RhcnRTdHlsZSA9IG51bGw7XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBhcnQudG8gLSBzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gcGFydC50bztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcbiAgICB2YXIgd2lkZ2V0ID0gIWlnbm9yZVdpZGdldCAmJiBtYXJrZXIud2lkZ2V0Tm9kZTtcbiAgICBpZiAod2lkZ2V0KSB7IGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KTsgfVxuICAgIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICB7IHdpZGdldCA9IGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7IH1cbiAgICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiwgbWFya2VyLmlkKTtcbiAgICB9XG4gICAgaWYgKHdpZGdldCkge1xuICAgICAgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUod2lkZ2V0KTtcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgIH1cbiAgICBidWlsZGVyLnBvcyArPSBzaXplO1xuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBzdHlsZXMpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDA7XG4gICAgaWYgKCFzcGFucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgc3R5bGVzLmxlbmd0aDsgaSQxKz0yKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcIlwiLCBzdHlsZSwgY3NzO1xuICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCBjb2xsYXBzZWQsIGF0dHJpYnV0ZXM7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcbiAgICAgICAgc3BhblN0eWxlID0gc3BhbkVuZFN0eWxlID0gc3BhblN0YXJ0U3R5bGUgPSBjc3MgPSBcIlwiO1xuICAgICAgICBhdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgY29sbGFwc2VkID0gbnVsbDsgbmV4dENoYW5nZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3BhbnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3AgPSBzcGFuc1tqXSwgbSA9IHNwLm1hcmtlcjtcbiAgICAgICAgICBpZiAobS50eXBlID09IFwiYm9va21hcmtcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kQm9va21hcmtzLnB1c2gobSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tIDw9IHBvcyAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IHBvcyB8fCBtLmNvbGxhcHNlZCAmJiBzcC50byA9PSBwb3MgJiYgc3AuZnJvbSA9PSBwb3MpKSB7XG4gICAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XG4gICAgICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC50bztcbiAgICAgICAgICAgICAgc3BhbkVuZFN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgeyBzcGFuU3R5bGUgKz0gXCIgXCIgKyBtLmNsYXNzTmFtZTsgfVxuICAgICAgICAgICAgaWYgKG0uY3NzKSB7IGNzcyA9IChjc3MgPyBjc3MgKyBcIjtcIiA6IFwiXCIpICsgbS5jc3M7IH1cbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHsgc3BhblN0YXJ0U3R5bGUgKz0gXCIgXCIgKyBtLnN0YXJ0U3R5bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmVuZFN0eWxlICYmIHNwLnRvID09IG5leHRDaGFuZ2UpIHsgKGVuZFN0eWxlcyB8fCAoZW5kU3R5bGVzID0gW10pKS5wdXNoKG0uZW5kU3R5bGUsIHNwLnRvKTsgfVxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgdGhlIG9sZCB0aXRsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvQ29kZU1pcnJvci9wdWxsLzU2NzNcbiAgICAgICAgICAgIGlmIChtLnRpdGxlKSB7IChhdHRyaWJ1dGVzIHx8IChhdHRyaWJ1dGVzID0ge30pKS50aXRsZSA9IG0udGl0bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSlbYXR0cl0gPSBtLmF0dHJpYnV0ZXNbYXR0cl07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNvbGxhcHNlZCAmJiAoIWNvbGxhcHNlZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhjb2xsYXBzZWQubWFya2VyLCBtKSA8IDApKVxuICAgICAgICAgICAgICB7IGNvbGxhcHNlZCA9IHNwOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tID4gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC5mcm9tKSB7XG4gICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AuZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0eWxlcykgeyBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBlbmRTdHlsZXMubGVuZ3RoOyBqJDEgKz0gMilcbiAgICAgICAgICB7IGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkgeyBzcGFuRW5kU3R5bGUgKz0gXCIgXCIgKyBlbmRTdHlsZXNbaiQxXTsgfSB9IH1cblxuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCBjb2xsYXBzZWQuZnJvbSA9PSBwb3MpIHsgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2okMilcbiAgICAgICAgICB7IGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqJDJdKTsgfSB9XG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xuICAgICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAoY29sbGFwc2VkLnRvID09IG51bGwgPyBsZW4gKyAxIDogY29sbGFwc2VkLnRvKSAtIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBwb3MpIHsgY29sbGFwc2VkID0gZmFsc2U7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSBsZW4pIHsgYnJlYWsgfVxuXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dDtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZCA+PSB1cHRvKSB7dGV4dCA9IHRleHQuc2xpY2UodXB0byAtIHBvcyk7IHBvcyA9IHVwdG87IGJyZWFrfVxuICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pO1xuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxuICAvLyBwYXJ0IG9mIHRoZSBkb2N1bWVudC4gQSBMaW5lVmlldyBtYXkgY29ycmVzcG9uZCB0byBtdWx0aXBsZVxuICAvLyBsb2dpY2FsIGxpbmVzLCBpZiB0aG9zZSBhcmUgY29ubmVjdGVkIGJ5IGNvbGxhcHNlZCByYW5nZXMuXG4gIGZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcbiAgICAvLyBUaGUgc3RhcnRpbmcgbGluZVxuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XG4gICAgdGhpcy5yZXN0ID0gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKTtcbiAgICAvLyBOdW1iZXIgb2YgbG9naWNhbCBsaW5lcyBpbiB0aGlzIHZpc3VhbCBsaW5lXG4gICAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XG4gICAgdGhpcy5ub2RlID0gdGhpcy50ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmhpZGRlbiA9IGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmFuZ2Ugb2YgTGluZVZpZXcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIGxpbmVzLlxuICBmdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgYXJyYXkgPSBbXSwgbmV4dFBvcztcbiAgICBmb3IgKHZhciBwb3MgPSBmcm9tOyBwb3MgPCB0bzsgcG9zID0gbmV4dFBvcykge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKTtcbiAgICAgIG5leHRQb3MgPSBwb3MgKyB2aWV3LnNpemU7XG4gICAgICBhcnJheS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIHZhciBvcGVyYXRpb25Hcm91cCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xuICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAub3BzLnB1c2gob3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcC5vd25zR3JvdXAgPSBvcGVyYXRpb25Hcm91cCA9IHtcbiAgICAgICAgb3BzOiBbb3BdLFxuICAgICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XG4gICAgLy8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXG4gICAgLy8gbmV3IG9uZXMgYXBwZWFyXG4gICAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGZvciAoOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpOyB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb3AgPSBncm91cC5vcHNbal07XG4gICAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKVxuICAgICAgICAgIHsgd2hpbGUgKG9wLmN1cnNvckFjdGl2aXR5Q2FsbGVkIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGgpXG4gICAgICAgICAgICB7IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnNbb3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10uY2FsbChudWxsLCBvcC5jbSk7IH0gfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoT3BlcmF0aW9uKG9wLCBlbmRDYikge1xuICAgIHZhciBncm91cCA9IG9wLm93bnNHcm91cDtcbiAgICBpZiAoIWdyb3VwKSB7IHJldHVybiB9XG5cbiAgICB0cnkgeyBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgICAgZW5kQ2IoZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcblxuICAvLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxuICAvLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXG4gIC8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XG4gIC8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxuICAvLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcbiAgLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cbiAgLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXG4gIGZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGFyciA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgbGlzdDtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSBpZiAob3JwaGFuRGVsYXllZENhbGxiYWNrcykge1xuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICBzZXRUaW1lb3V0KGZpcmVPcnBoYW5EZWxheWVkLCAwKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICBsaXN0LnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyW2ldLmFwcGx5KG51bGwsIGFyZ3MpOyB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICBsb29wKCBpICk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcbiAgICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSB7IGRlbGF5ZWRbaV0oKTsgfVxuICB9XG5cbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXG4gIC8vIGxpbmVWaWV3LmNoYW5nZXMuIFRoaXMgdXBkYXRlcyB0aGUgcmVsZXZhbnQgcGFydCBvZiB0aGUgbGluZSdzXG4gIC8vIERPTSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVWaWV3LmNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXTtcbiAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB7IHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJndXR0ZXJcIikgeyB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiY2xhc3NcIikgeyB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwid2lkZ2V0XCIpIHsgdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTsgfVxuICAgIH1cbiAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICBsaW5lVmlldy5ub2RlID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcbiAgICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpOyB9XG4gICAgICBsaW5lVmlldy5ub2RlLmFwcGVuZENoaWxkKGxpbmVWaWV3LnRleHQpO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZVZpZXcubm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXCIgXCIgKyAobGluZVZpZXcubGluZS5iZ0NsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS5iZ0NsYXNzO1xuICAgIGlmIChjbHMpIHsgY2xzICs9IFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIjsgfVxuICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzOyB9XG4gICAgICBlbHNlIHsgbGluZVZpZXcuYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3LmJhY2tncm91bmQpOyBsaW5lVmlldy5iYWNrZ3JvdW5kID0gbnVsbDsgfVxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3LmJhY2tncm91bmQgPSB3cmFwLmluc2VydEJlZm9yZShlbHQoXCJkaXZcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShsaW5lVmlldy5iYWNrZ3JvdW5kKTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxuICAvLyBpbiBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgd2hlbiBwb3NzaWJsZS5cbiAgZnVuY3Rpb24gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGV4dC5saW5lID09IGxpbmVWaWV3LmxpbmUpIHtcbiAgICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XG4gICAgICByZXR1cm4gZXh0LmJ1aWx0XG4gICAgfVxuICAgIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcbiAgfVxuXG4gIC8vIFJlZHJhdyB0aGUgbGluZSdzIHRleHQuIEludGVyYWN0cyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGFuZCB0ZXh0XG4gIC8vIGNsYXNzZXMgYmVjYXVzZSB0aGUgbW9kZSBtYXkgb3V0cHV0IHRva2VucyB0aGF0IGluZmx1ZW5jZSB0aGVzZVxuICAvLyBjbGFzc2VzLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgY2xzID0gbGluZVZpZXcudGV4dC5jbGFzc05hbWU7XG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSB7IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7IH1cbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XG4gICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTtcbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KSB7XG4gICAgdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpXG4gICAgICB7IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzczsgfVxuICAgIGVsc2UgaWYgKGxpbmVWaWV3Lm5vZGUgIT0gbGluZVZpZXcudGV4dClcbiAgICAgIHsgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiOyB9XG4gICAgdmFyIHRleHRDbGFzcyA9IGxpbmVWaWV3LnRleHRDbGFzcyA/IGxpbmVWaWV3LnRleHRDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS50ZXh0Q2xhc3M7XG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSB0ZXh0Q2xhc3MgfHwgXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcbiAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHg7IHdpZHRoOiBcIiArIChkaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XG4gICAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KTtcbiAgICB9XG4gICAgdmFyIG1hcmtlcnMgPSBsaW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnM7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xuICAgICAgdmFyIHdyYXAkMSA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLCAoXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBndXR0ZXJXcmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKTtcbiAgICAgIHdyYXAkMS5pbnNlcnRCZWZvcmUoZ3V0dGVyV3JhcCwgbGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcbiAgICAgICAgeyBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7IH1cbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKVxuICAgICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGVsdChcImRpdlwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcbiAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pICsgXCJweDsgd2lkdGg6IFwiICsgKGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgpICsgXCJweFwiKSkpOyB9XG4gICAgICBpZiAobWFya2VycykgeyBmb3IgKHZhciBrID0gMDsgayA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1trXS5jbGFzc05hbWUsIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtmb3VuZF0sIFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXCJweFwiKSkpOyB9XG4gICAgICB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSB7IGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7IH1cbiAgICB2YXIgaXNXaWRnZXQgPSBjbGFzc1Rlc3QoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9ICh2b2lkIDApOyBub2RlOyBub2RlID0gbmV4dCkge1xuICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoaXNXaWRnZXQudGVzdChub2RlLmNsYXNzTmFtZSkpIHsgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgIH1cbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICB9XG5cbiAgLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxuICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xuICAgIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzOyB9XG4gICAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7IH1cblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgIHJldHVybiBsaW5lVmlldy5ub2RlXG4gIH1cblxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XG4gICAgaWYgKCFsaW5lLndpZGdldHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIgKyAod2lkZ2V0LmNsYXNzTmFtZSA/IFwiIFwiICsgd2lkZ2V0LmNsYXNzTmFtZSA6IFwiXCIpKTtcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSB7IG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcbiAgICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpOyB9XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBkaW1zLmZpeGVkUG9zICsgXCJweFwiO1xuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH1cbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSB7IG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gd2lkZ2V0LmhlaWdodCB9XG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcbiAgICBpZiAoIWNtKSB7IHJldHVybiAwIH1cbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwibWFyZ2luLWxlZnQ6IC1cIiArIGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwid2lkdGg6IFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXCJweDtcIjsgfVxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IChuLm5vZGVUeXBlID09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIpID09IFwidHJ1ZVwiKSB8fFxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XG4gIGZ1bmN0aW9uIHBhZGRpbmdWZXJ0KGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5tb3Zlci5vZmZzZXRIZWlnaHQgLSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRIZWlnaHR9XG4gIGZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XG4gICAgdmFyIGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIGVsdChcInByZVwiLCBcInhcIiwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIHsgZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IGRhdGE7IH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGggfVxuICBmdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXG4gIH1cbiAgZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xuICAgIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIHsgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXG4gIC8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxuICAvLyBjb250YWluIG11bHRpcGxlIGxpbmVzIHdoZW4gY29sbGFwc2VkIHJhbmdlcyBhcmUgcHJlc2VudC4pXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcbiAgICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxuICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXX0gfSB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkkMSsrKVxuICAgICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcbiAgICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2kkMV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpJDFdLCBiZWZvcmU6IHRydWV9IH0gfVxuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICAvLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXG4gIC8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XG4gICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSksIGNoLCBiaWFzKVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTikge1xuICAgIGlmIChsaW5lTiA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIGxpbmVOIDwgY20uZGlzcGxheS52aWV3VG8pXG4gICAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyByZXR1cm4gZXh0IH1cbiAgfVxuXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XG4gIC8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxuICAvLyBjaGFyYWN0ZXIuIEZ1bmN0aW9ucyBsaWtlIGNvb3Jkc0NoYXIsIHRoYXQgbmVlZCB0byBkbyBhIGxvdCBvZlxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xuICAvLyBvbmx5IGRvbmUgb25jZS5cbiAgZnVuY3Rpb24gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSB7XG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xuICAgICAgdmlldyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xuICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIHZpZXcsIGxpbmVOLCBnZXREaW1lbnNpb25zKGNtKSk7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgIHsgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpOyB9XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxuICAvLyBhY3R1YWwgY2hhcmFjdGVyIChvciBmZXRjaGVzIGl0IGZyb20gdGhlIGNhY2hlKS5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcbiAgICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTE7IH1cbiAgICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcIlwiKSwgZm91bmQ7XG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGZvdW5kID0gcHJlcGFyZWQuY2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxuICAgICAgICB7IHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xuICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHZhckhlaWdodCA/IGZvdW5kLnJ0b3AgOiBmb3VuZC50b3AsXG4gICAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XG4gIH1cblxuICB2YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfTtcblxuICBmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2UsIG1TdGFydCwgbUVuZDtcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxuICAgIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBtU3RhcnQgPSBtYXBbaV07XG4gICAgICBtRW5kID0gbWFwW2kgKyAxXTtcbiAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xuICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xuICAgICAgICBpZiAoY2ggPj0gbUVuZCkgeyBjb2xsYXBzZSA9IFwicmlnaHRcIjsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG1hcFtpICsgMl07XG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXG4gICAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXM7IH1cbiAgICAgICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIgJiYgc3RhcnQgPT0gMClcbiAgICAgICAgICB7IHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxuICAgICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSArPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xuICAgIHZhciByZWN0ID0gbnVsbFJlY3Q7XG4gICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9IGVsc2UgeyBmb3IgKHZhciBpJDEgPSByZWN0cy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XG4gICAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2U7XG5cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpXG4gICAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpOyB9XG4gICAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTsgfVxuICAgIH0gZWxzZSB7IC8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXG4gICAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjsgfVxuICAgICAgdmFyIHJlY3RzO1xuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcbiAgICAgICAgeyByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgIH1cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xuICAgICAgdmFyIHJTcGFuID0gbm9kZS5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICBpZiAoclNwYW4pXG4gICAgICAgIHsgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlY3QgPSBudWxsUmVjdDsgfVxuICAgIH1cblxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xuICAgIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xuICAgIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcImxlZnRcIiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fTtcbiAgICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlOyB9XG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXG4gIC8vIHJldHVybmVkIGluY29ycmVjdGx5IHdoZW4gem9vbWVkIG9uIElFMTAgYW5kIGJlbG93LlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcbiAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcbiAgICAgICAgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSlcbiAgICAgIHsgcmV0dXJuIHJlY3QgfVxuICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcbiAgICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUEk7XG4gICAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQgKiBzY2FsZVgsIHJpZ2h0OiByZWN0LnJpZ2h0ICogc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubWVhc3VyZSkge1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXSA9IHt9OyB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKSB7XG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGNtLmRpc3BsYXkudmlld1tpXSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlOyB9XG4gICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDg5MjA2XG4gICAgLy8gd2hpY2ggY2F1c2VzIHBhZ2VfT2Zmc2V0IGFuZCBib3VuZGluZyBjbGllbnQgcmVjdHMgdG8gdXNlXG4gICAgLy8gZGlmZmVyZW50IHJlZmVyZW5jZSB2aWV3cG9ydHMgYW5kIGludmFsaWRhdGUgb3VyIGNhbGN1bGF0aW9ucy5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHsgcmV0dXJuIC0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSkgfVxuICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0XG4gIH1cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7XG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7IHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5Ub3ApKSB9XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcFxuICB9XG5cbiAgZnVuY3Rpb24gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBpZiAobGluZU9iai53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU9iai53aWRnZXRzLmxlbmd0aDsgKytpKSB7IGlmIChsaW5lT2JqLndpZGdldHNbaV0uYWJvdmUpXG4gICAgICB7IGhlaWdodCArPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTsgfSB9IH1cbiAgICByZXR1cm4gaGVpZ2h0XG4gIH1cblxuICAvLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcbiAgLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcbiAgLy8gXCJsaW5lXCIsIFwiZGl2XCIgKGRpc3BsYXkubGluZURpdiksIFwibG9jYWxcIi4vbnVsbCAoZWRpdG9yKSwgXCJ3aW5kb3dcIixcbiAgLy8gb3IgXCJwYWdlXCIuXG4gIGZ1bmN0aW9uIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgcmVjdCwgY29udGV4dCwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICBpZiAoIWluY2x1ZGVXaWRnZXRzKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgICAgcmVjdC50b3AgKz0gaGVpZ2h0OyByZWN0LmJvdHRvbSArPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IFwibGluZVwiKSB7IHJldHVybiByZWN0IH1cbiAgICBpZiAoIWNvbnRleHQpIHsgY29udGV4dCA9IFwibG9jYWxcIjsgfVxuICAgIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIGlmIChjb250ZXh0ID09IFwibG9jYWxcIikgeyB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7IH1cbiAgICBlbHNlIHsgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7IH1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIiB8fCBjb250ZXh0ID09IFwid2luZG93XCIpIHtcbiAgICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcbiAgICAgIHJlY3QubGVmdCArPSB4T2ZmOyByZWN0LnJpZ2h0ICs9IHhPZmY7XG4gICAgfVxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIENvdmVydHMgYSBib3ggZnJvbSBcImRpdlwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAvLyBDb250ZXh0IG1heSBiZSBcIndpbmRvd1wiLCBcInBhZ2VcIiwgXCJkaXZcIiwgb3IgXCJsb2NhbFwiLi9udWxsLlxuICBmdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09IFwiZGl2XCIpIHsgcmV0dXJuIGNvb3JkcyB9XG4gICAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcDtcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIikge1xuICAgICAgbGVmdCAtPSBwYWdlU2Nyb2xsWCgpO1xuICAgICAgdG9wIC09IHBhZ2VTY3JvbGxZKCk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcbiAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcbiAgICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7IH1cbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxuICAvLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXG4gIC8vIG9uIGEgYmlkaSBib3VuZGFyeS5cbiAgLy8gQSBjdXJzb3IgUG9zKGxpbmUsIGNoYXIsIFwiYmVmb3JlXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyIC0gMWBcbiAgLy8gYW5kIGFmdGVyIGBjaGFyIC0gMWAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhciAtIDFgXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImFmdGVyXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyYFxuICAvLyBhbmQgYmVmb3JlIGBjaGFyYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyYFxuICAvLyBFeGFtcGxlcyAodXBwZXItY2FzZSBsZXR0ZXJzIGFyZSBSVEwsIGxvd2VyLWNhc2UgYXJlIExUUik6XG4gIC8vICAgICBQb3MoMCwgMSwgLi4uKVxuICAvLyAgICAgYmVmb3JlICAgYWZ0ZXJcbiAgLy8gYWIgICAgIGF8YiAgICAgYXxiXG4gIC8vIGFCICAgICBhfEIgICAgIGFCfFxuICAvLyBBYiAgICAgfEFiICAgICBBfGJcbiAgLy8gQUIgICAgIEJ8QSAgICAgQnxBXG4gIC8vIEV2ZXJ5IHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGNoYXJhY3RlciBvbiBhIGxpbmUgaXMgY29uc2lkZXJlZCB0byBzdGlja1xuICAvLyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUuXG4gIGZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xuICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcbiAgICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcbiAgICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0OyB9XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KVxuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKSwgY2ggPSBwb3MuY2gsIHN0aWNreSA9IHBvcy5zdGlja3k7XG4gICAgaWYgKGNoID49IGxpbmVPYmoudGV4dC5sZW5ndGgpIHtcbiAgICAgIGNoID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChjaCA8PSAwKSB7XG4gICAgICBjaCA9IDA7XG4gICAgICBzdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChzdGlja3kgPT0gXCJiZWZvcmVcIiA/IGNoIC0gMSA6IGNoLCBzdGlja3kgPT0gXCJiZWZvcmVcIikgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcywgaW52ZXJ0KSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgPT0gMTtcbiAgICAgIHJldHVybiBnZXQoaW52ZXJ0ID8gY2ggLSAxIDogY2gsIHJpZ2h0ICE9IGludmVydClcbiAgICB9XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcbiAgICB2YXIgb3RoZXIgPSBiaWRpT3RoZXI7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MsIHN0aWNreSA9PSBcImJlZm9yZVwiKTtcbiAgICBpZiAob3RoZXIgIT0gbnVsbCkgeyB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBvdGhlciwgc3RpY2t5ICE9IFwiYmVmb3JlXCIpOyB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDsgfVxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH1cbiAgfVxuXG4gIC8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cbiAgLy8geFJlbCBpcyB0aGUgcmVsYXRpdmUgeCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQgY29vcmRpbmF0ZXMgY29tcGFyZWRcbiAgLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXG4gIC8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxuICAvLyBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoZSBjb29yZGluYXRlcyBsaWUgb3V0c2lkZSB0aGUgbGluZSdzXG4gIC8vIHZlcnRpY2FsIHJhbmdlLlxuICBmdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XG4gICAgdmFyIHBvcyA9IFBvcyhsaW5lLCBjaCwgc3RpY2t5KTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSBvdXRzaWRlOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCBudWxsLCAtMSwgLTEpIH1cbiAgICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAobGluZU4gPiBsYXN0KVxuICAgICAgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIG51bGwsIDEsIDEpIH1cbiAgICBpZiAoeCA8IDApIHsgeCA9IDA7IH1cblxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcbiAgICAgIHZhciBjb2xsYXBzZWQgPSBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmVPYmosIGZvdW5kLmNoICsgKGZvdW5kLnhSZWwgPiAwIHx8IGZvdW5kLm91dHNpZGUgPiAwID8gMSA6IDApKTtcbiAgICAgIGlmICghY29sbGFwc2VkKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBjb2xsYXBzZWQuZmluZCgxKTtcbiAgICAgIGlmIChyYW5nZUVuZC5saW5lID09IGxpbmVOKSB7IHJldHVybiByYW5nZUVuZCB9XG4gICAgICBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOID0gcmFuZ2VFbmQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xuICAgIHkgLT0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBiZWdpbiA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAxKS5ib3R0b20gPD0geTsgfSwgZW5kLCAwKTtcbiAgICBlbmQgPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKS50b3AgPiB5OyB9LCBiZWdpbiwgZW5kKTtcbiAgICByZXR1cm4ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSB7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIHZhciB0YXJnZXRUb3AgPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSwgXCJsaW5lXCIpLnRvcDtcbiAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0VG9wKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzaWRlIG9mIGEgYm94IGlzIGFmdGVyIHRoZSBnaXZlblxuICAvLyBjb29yZGluYXRlcywgaW4gdG9wLXRvLWJvdHRvbSwgbGVmdC10by1yaWdodCBvcmRlci5cbiAgZnVuY3Rpb24gYm94SXNBZnRlcihib3gsIHgsIHksIGxlZnQpIHtcbiAgICByZXR1cm4gYm94LmJvdHRvbSA8PSB5ID8gZmFsc2UgOiBib3gudG9wID4geSA/IHRydWUgOiAobGVmdCA/IGJveC5sZWZ0IDogYm94LnJpZ2h0KSA+IHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XG4gICAgLy8gTW92ZSB5IGludG8gbGluZS1sb2NhbCBjb29yZGluYXRlIHNwYWNlXG4gICAgeSAtPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgLy8gV2hlbiBkaXJlY3RseSBjYWxsaW5nIGBtZWFzdXJlQ2hhclByZXBhcmVkYCwgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAvLyBmb3IgdGhlIHdpZGdldHMgYXQgdGhpcyBsaW5lLlxuICAgIHZhciB3aWRnZXRIZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aCwgbHRyID0gdHJ1ZTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIC8vIElmIHRoZSBsaW5lIGlzbid0IHBsYWluIGxlZnQtdG8tcmlnaHQgdGV4dCwgZmlyc3QgZmlndXJlIG91dFxuICAgIC8vIHdoaWNoIGJpZGkgc2VjdGlvbiB0aGUgY29vcmRpbmF0ZXMgZmFsbCBpbnRvLlxuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnQgPSAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgPyBjb29yZHNCaWRpUGFydFdyYXBwZWQgOiBjb29yZHNCaWRpUGFydClcbiAgICAgICAgICAgICAgICAgICAoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSk7XG4gICAgICBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICAvLyBUaGUgYXdrd2FyZCAtMSBvZmZzZXRzIGFyZSBuZWVkZWQgYmVjYXVzZSBmaW5kRmlyc3QgKGNhbGxlZFxuICAgICAgLy8gb24gdGhlc2UgYmVsb3cpIHdpbGwgdHJlYXQgaXRzIGZpcnN0IGJvdW5kIGFzIGluY2x1c2l2ZSxcbiAgICAgIC8vIHNlY29uZCBhcyBleGNsdXNpdmUsIGJ1dCB3ZSB3YW50IHRvIGFjdHVhbGx5IGFkZHJlc3MgdGhlXG4gICAgICAvLyBjaGFyYWN0ZXJzIGluIHRoZSBwYXJ0J3MgcmFuZ2VcbiAgICAgIGJlZ2luID0gbHRyID8gcGFydC5mcm9tIDogcGFydC50byAtIDE7XG4gICAgICBlbmQgPSBsdHIgPyBwYXJ0LnRvIDogcGFydC5mcm9tIC0gMTtcbiAgICB9XG5cbiAgICAvLyBBIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdob3NlIGJvdW5kaW5nIGJveFxuICAgIC8vIHN0YXJ0cyBhZnRlciB0aGUgY29vcmRpbmF0ZXMuIElmIHdlIHJ1biBhY3Jvc3MgYW55IHdob3NlIGJveCB3cmFwXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBzdG9yZSB0aGF0LlxuICAgIHZhciBjaEFyb3VuZCA9IG51bGwsIGJveEFyb3VuZCA9IG51bGw7XG4gICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkge1xuICAgICAgdmFyIGJveCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpO1xuICAgICAgYm94LnRvcCArPSB3aWRnZXRIZWlnaHQ7IGJveC5ib3R0b20gKz0gd2lkZ2V0SGVpZ2h0O1xuICAgICAgaWYgKCFib3hJc0FmdGVyKGJveCwgeCwgeSwgZmFsc2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoYm94LnRvcCA8PSB5ICYmIGJveC5sZWZ0IDw9IHgpIHtcbiAgICAgICAgY2hBcm91bmQgPSBjaDtcbiAgICAgICAgYm94QXJvdW5kID0gYm94O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LCBiZWdpbiwgZW5kKTtcblxuICAgIHZhciBiYXNlWCwgc3RpY2t5LCBvdXRzaWRlID0gZmFsc2U7XG4gICAgLy8gSWYgYSBib3ggYXJvdW5kIHRoZSBjb29yZGluYXRlcyB3YXMgZm91bmQsIHVzZSB0aGF0XG4gICAgaWYgKGJveEFyb3VuZCkge1xuICAgICAgLy8gRGlzdGluZ3Vpc2ggY29vcmRpbmF0ZXMgbmVhcmVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGJveFxuICAgICAgdmFyIGF0TGVmdCA9IHggLSBib3hBcm91bmQubGVmdCA8IGJveEFyb3VuZC5yaWdodCAtIHgsIGF0U3RhcnQgPSBhdExlZnQgPT0gbHRyO1xuICAgICAgY2ggPSBjaEFyb3VuZCArIChhdFN0YXJ0ID8gMCA6IDEpO1xuICAgICAgc3RpY2t5ID0gYXRTdGFydCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICBiYXNlWCA9IGF0TGVmdCA/IGJveEFyb3VuZC5sZWZ0IDogYm94QXJvdW5kLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAoQWRqdXN0IGZvciBleHRlbmRlZCBib3VuZCwgaWYgbmVjZXNzYXJ5LilcbiAgICAgIGlmICghbHRyICYmIChjaCA9PSBlbmQgfHwgY2ggPT0gYmVnaW4pKSB7IGNoKys7IH1cbiAgICAgIC8vIFRvIGRldGVybWluZSB3aGljaCBzaWRlIHRvIGFzc29jaWF0ZSB3aXRoLCBnZXQgdGhlIGJveCB0byB0aGVcbiAgICAgIC8vIGxlZnQgb2YgdGhlIGNoYXJhY3RlciBhbmQgY29tcGFyZSBpdCdzIHZlcnRpY2FsIHBvc2l0aW9uIHRvIHRoZVxuICAgICAgLy8gY29vcmRpbmF0ZXNcbiAgICAgIHN0aWNreSA9IGNoID09IDAgPyBcImFmdGVyXCIgOiBjaCA9PSBsaW5lT2JqLnRleHQubGVuZ3RoID8gXCJiZWZvcmVcIiA6XG4gICAgICAgIChtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gKGx0ciA/IDEgOiAwKSkuYm90dG9tICsgd2lkZ2V0SGVpZ2h0IDw9IHkpID09IGx0ciA/XG4gICAgICAgIFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAvLyBOb3cgZ2V0IGFjY3VyYXRlIGNvb3JkaW5hdGVzIGZvciB0aGlzIHBsYWNlLCBpbiBvcmRlciB0byBnZXQgYVxuICAgICAgLy8gYmFzZSBYIHBvc2l0aW9uXG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBjaCwgc3RpY2t5KSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICBiYXNlWCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgb3V0c2lkZSA9IHkgPCBjb29yZHMudG9wID8gLTEgOiB5ID49IGNvb3Jkcy5ib3R0b20gPyAxIDogMDtcbiAgICB9XG5cbiAgICBjaCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lT2JqLnRleHQsIGNoLCAxKTtcbiAgICByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4IC0gYmFzZVgpXG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydChjbSwgbGluZU9iaiwgbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgLy8gQmlkaSBwYXJ0cyBhcmUgc29ydGVkIGxlZnQtdG8tcmlnaHQsIGFuZCBpbiBhIG5vbi1saW5lLXdyYXBwaW5nXG4gICAgLy8gc2l0dWF0aW9uLCB3ZSBjYW4gdGFrZSB0aGlzIG9yZGVyaW5nIHRvIGNvcnJlc3BvbmQgdG8gdGhlIHZpc3VhbFxuICAgIC8vIG9yZGVyaW5nLiBUaGlzIGZpbmRzIHRoZSBmaXJzdCBwYXJ0IHdob3NlIGVuZCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgICAvLyBjb29yZGluYXRlcy5cbiAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV0sIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIHJldHVybiBib3hJc0FmdGVyKGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSwgbHRyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSksIHgsIHksIHRydWUpXG4gICAgfSwgMCwgb3JkZXIubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgLy8gSWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgcGFydCwgdGhlIHBhcnQncyBzdGFydCBpcyBhbHNvIGFmdGVyXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBhbmQgdGhlIGNvb3JkaW5hdGVzIGFyZW4ndCBvbiB0aGUgc2FtZSBsaW5lIGFzXG4gICAgLy8gdGhhdCBzdGFydCwgbW92ZSBvbmUgcGFydCBiYWNrLlxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHZhciBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICB2YXIgc3RhcnQgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8sIGx0ciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgaWYgKGJveElzQWZ0ZXIoc3RhcnQsIHgsIHksIHRydWUpICYmIHN0YXJ0LnRvcCA+IHkpXG4gICAgICAgIHsgcGFydCA9IG9yZGVyW2luZGV4IC0gMV07IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZChjbSwgbGluZU9iaiwgX2xpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEluIGEgd3JhcHBlZCBsaW5lLCBydGwgdGV4dCBvbiB3cmFwcGluZyBib3VuZGFyaWVzIGNhbiBkbyB0aGluZ3NcbiAgICAvLyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gdGhlIG9yZGVyaW5nIGluIG91ciBgb3JkZXJgIGFycmF5IGF0XG4gICAgLy8gYWxsLCBzbyBhIGJpbmFyeSBzZWFyY2ggZG9lc24ndCB3b3JrLCBhbmQgd2Ugd2FudCB0byByZXR1cm4gYVxuICAgIC8vIHBhcnQgdGhhdCBvbmx5IHNwYW5zIG9uZSBsaW5lIHNvIHRoYXQgdGhlIGJpbmFyeSBzZWFyY2ggaW5cbiAgICAvLyBjb29yZHNDaGFySW5uZXIgaXMgc2FmZS4gQXMgc3VjaCwgd2UgZmlyc3QgZmluZCB0aGUgZXh0ZW50IG9mIHRoZVxuICAgIC8vIHdyYXBwZWQgbGluZSwgYW5kIHRoZW4gZG8gYSBmbGF0IHNlYXJjaCBpbiB3aGljaCB3ZSBkaXNjYXJkIGFueVxuICAgIC8vIHNwYW5zIHRoYXQgYXJlbid0IG9uIHRoZSBsaW5lLlxuICAgIHZhciByZWYgPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KTtcbiAgICB2YXIgYmVnaW4gPSByZWYuYmVnaW47XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgaWYgKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChlbmQgLSAxKSkpIHsgZW5kLS07IH1cbiAgICB2YXIgcGFydCA9IG51bGwsIGNsb3Nlc3REaXN0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHAuZnJvbSA+PSBlbmQgfHwgcC50byA8PSBiZWdpbikgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbHRyID0gcC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIGVuZFggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGx0ciA/IE1hdGgubWluKGVuZCwgcC50bykgLSAxIDogTWF0aC5tYXgoYmVnaW4sIHAuZnJvbSkpLnJpZ2h0O1xuICAgICAgLy8gV2VpZ2ggYWdhaW5zdCBzcGFucyBlbmRpbmcgYmVmb3JlIHRoaXMsIHNvIHRoYXQgdGhleSBhcmUgb25seVxuICAgICAgLy8gcGlja2VkIGlmIG5vdGhpbmcgZW5kcyBhZnRlclxuICAgICAgdmFyIGRpc3QgPSBlbmRYIDwgeCA/IHggLSBlbmRYICsgMWU5IDogZW5kWCAtIHg7XG4gICAgICBpZiAoIXBhcnQgfHwgY2xvc2VzdERpc3QgPiBkaXN0KSB7XG4gICAgICAgIHBhcnQgPSBwO1xuICAgICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFydCkgeyBwYXJ0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBDbGlwIHRoZSBwYXJ0IHRvIHRoZSB3cmFwcGVkIGxpbmUuXG4gICAgaWYgKHBhcnQuZnJvbSA8IGJlZ2luKSB7IHBhcnQgPSB7ZnJvbTogYmVnaW4sIHRvOiBwYXJ0LnRvLCBsZXZlbDogcGFydC5sZXZlbH07IH1cbiAgICBpZiAocGFydC50byA+IGVuZCkgeyBwYXJ0ID0ge2Zyb206IHBhcnQuZnJvbSwgdG86IGVuZCwgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgfVxuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgLy8gTWVhc3VyZSBhIGJ1bmNoIG9mIGxpbmVzLCBmb3IgYnJvd3NlcnMgdGhhdCBjb21wdXRlXG4gICAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO1xuICAgICAgfVxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XG4gICAgdmFyIGhlaWdodCA9IG1lYXN1cmVUZXh0Lm9mZnNldEhlaWdodCAvIDUwO1xuICAgIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDsgfVxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cbiAgZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggfVxuICAgIHZhciBhbmNob3IgPSBlbHQoXCJzcGFuXCIsIFwieHh4eHh4eHh4eFwiKTtcbiAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKTtcbiAgICB2YXIgcmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAxMDtcbiAgICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7IH1cbiAgICByZXR1cm4gd2lkdGggfHwgMTBcbiAgfVxuXG4gIC8vIERvIGEgYnVsay1yZWFkIG9mIHRoZSBET00gcG9zaXRpb25zIGFuZCBzaXplcyBuZWVkZWQgdG8gZHJhdyB0aGVcbiAgLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9O1xuICAgIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xuICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXS5jbGFzc05hbWU7XG4gICAgICBsZWZ0W2lkXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnQ7XG4gICAgICB3aWR0aFtpZF0gPSBuLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4ge2ZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcbiAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXG4gICAgICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cbiAgfVxuXG4gIC8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcbiAgLy8gcmVzdWx0LlxuICBmdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbiAgLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHsgcmV0dXJuIDAgfVxuXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XG4gICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodDsgfVxuICAgICAgfSB9XG5cbiAgICAgIGlmICh3cmFwcGluZylcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGggfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgdGggfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSk7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxuICAvLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxuICAvLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxuICAvLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFsaWJlcmFsICYmIGVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpID09IFwidHJ1ZVwiKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cbiAgICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcDsgfVxuICAgIGNhdGNoIChlJDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZHMgPSBjb29yZHNDaGFyKGNtLCB4LCB5KSwgbGluZTtcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA+IDAgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkc1xuICB9XG5cbiAgLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxuICAvLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcbiAgICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gbnVsbCB9XG4gICAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuIC09IHZpZXdbaV0uc2l6ZTtcbiAgICAgIGlmIChuIDwgMCkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0OyB9XG4gICAgaWYgKHRvID09IG51bGwpIHsgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTsgfVxuICAgIGlmICghbGVuZGlmZikgeyBsZW5kaWZmID0gMDsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tOyB9XG5cbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAoZnJvbSA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBDaGFuZ2UgYWZ0ZXJcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxuICAgICAgICB7IHJlc2V0VmlldyhjbSk7IH1cbiAgICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tICs9IGxlbmRpZmY7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gRnVsbCBvdmVybGFwXG4gICAgICByZXNldFZpZXcoY20pO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFRvcCBvdmVybGFwXG4gICAgICB2YXIgY3V0ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShjdXQuaW5kZXgpO1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tID0gY3V0LmxpbmVOO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXG4gICAgICB2YXIgY3V0JDEgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICBpZiAoY3V0JDEpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcbiAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0VG9wICYmIGN1dEJvdCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxuICAgICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcbiAgICAgICAgICAuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0KSB7XG4gICAgICBpZiAodG8gPCBleHQubGluZU4pXG4gICAgICAgIHsgZXh0LmxpbmVOICs9IGxlbmRpZmY7IH1cbiAgICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cblxuICAgIGlmIChsaW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBsaW5lID49IGRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgdmFyIGFyciA9IGxpbmVWaWV3LmNoYW5nZXMgfHwgKGxpbmVWaWV3LmNoYW5nZXMgPSBbXSk7XG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKTsgfVxuICB9XG5cbiAgLy8gQ2xlYXIgdGhlIHZpZXcuXG4gIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xuICAgIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcbiAgICBjbS5kaXNwbGF5LnZpZXcgPSBbXTtcbiAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKVxuICAgICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cbiAgICB2YXIgbiA9IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgeyBuICs9IHZpZXdbaV0uc2l6ZTsgfVxuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XG4gIH1cblxuICAvLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XG4gIC8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cbiAgZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSk7IH1cbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7IH1cbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eTsgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgaWYgKCBwcmltYXJ5ID09PSB2b2lkIDAgKSBwcmltYXJ5ID0gdHJ1ZTtcblxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xuICAgIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBzZWxGcmFnbWVudCA9IHJlc3VsdC5zZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByaW1hcnkgJiYgaSA9PSBkb2Muc2VsLnByaW1JbmRleCkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5mcm9tKCkubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCByYW5nZS50bygpLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBjb2xsYXBzZWQgPSByYW5nZS5lbXB0eSgpO1xuICAgICAgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKVxuICAgICAgICB7IGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLmhlYWQsIGN1ckZyYWdtZW50KTsgfVxuICAgICAgaWYgKCFjb2xsYXBzZWQpXG4gICAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAoL1xcYmNtLWZhdC1jdXJzb3JcXGIvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpKSB7XG4gICAgICB2YXIgY2hhclBvcyA9IGNoYXJDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwpO1xuICAgICAgaWYgKGNoYXJQb3MucmlnaHQgLSBjaGFyUG9zLmxlZnQgPiAwKSB7XG4gICAgICAgIGN1cnNvci5zdHlsZS53aWR0aCA9IChjaGFyUG9zLnJpZ2h0IC0gY2hhclBvcy5sZWZ0KSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zLm90aGVyKSB7XG4gICAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcbiAgICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcIikpO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbXBDb29yZHMoYSwgYikgeyByZXR1cm4gYS50b3AgLSBiLnRvcCB8fCBhLmxlZnQgLSBiLmxlZnQgfVxuXG4gIC8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBvdXRwdXQpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nSChjbS5kaXNwbGF5KSwgbGVmdFNpZGUgPSBwYWRkaW5nLmxlZnQ7XG4gICAgdmFyIHJpZ2h0U2lkZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXJXaWR0aCwgZGlzcGxheVdpZHRoKGNtKSAtIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCkgLSBwYWRkaW5nLnJpZ2h0O1xuICAgIHZhciBkb2NMVFIgPSBkb2MuZGlyZWN0aW9uID09IFwibHRyXCI7XG5cbiAgICBmdW5jdGlvbiBhZGQobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tKSB7XG4gICAgICBpZiAodG9wIDwgMCkgeyB0b3AgPSAwOyB9XG4gICAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLnJvdW5kKGJvdHRvbSk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNlbGVjdGVkXCIsIChcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgKyBsZWZ0ICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIgKyB0b3AgKyBcInB4OyB3aWR0aDogXCIgKyAod2lkdGggPT0gbnVsbCA/IHJpZ2h0U2lkZSAtIGxlZnQgOiB3aWR0aCkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIChib3R0b20gLSB0b3ApICsgXCJweFwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGxpbmUsIGZyb21BcmcsIHRvQXJnKSB7XG4gICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lTGVuID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBzdGFydCwgZW5kO1xuICAgICAgZnVuY3Rpb24gY29vcmRzKGNoLCBiaWFzKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29vcmRzKGNtLCBQb3MobGluZSwgY2gpLCBcImRpdlwiLCBsaW5lT2JqLCBiaWFzKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3cmFwWChwb3MsIGRpciwgc2lkZSkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gd3JhcHBlZExpbmVFeHRlbnRDaGFyKGNtLCBsaW5lT2JqLCBudWxsLCBwb3MpO1xuICAgICAgICB2YXIgcHJvcCA9IChkaXIgPT0gXCJsdHJcIikgPT0gKHNpZGUgPT0gXCJhZnRlclwiKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgICAgICB2YXIgY2ggPSBzaWRlID09IFwiYWZ0ZXJcIiA/IGV4dGVudC5iZWdpbiA6IGV4dGVudC5lbmQgLSAoL1xccy8udGVzdChsaW5lT2JqLnRleHQuY2hhckF0KGV4dGVudC5lbmQgLSAxKSkgPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb29yZHMoY2gsIHByb3ApW3Byb3BdXG4gICAgICB9XG5cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGRvYy5kaXJlY3Rpb24pO1xuICAgICAgaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbUFyZyB8fCAwLCB0b0FyZyA9PSBudWxsID8gbGluZUxlbiA6IHRvQXJnLCBmdW5jdGlvbiAoZnJvbSwgdG8sIGRpciwgaSkge1xuICAgICAgICB2YXIgbHRyID0gZGlyID09IFwibHRyXCI7XG4gICAgICAgIHZhciBmcm9tUG9zID0gY29vcmRzKGZyb20sIGx0ciA/IFwibGVmdFwiIDogXCJyaWdodFwiKTtcbiAgICAgICAgdmFyIHRvUG9zID0gY29vcmRzKHRvIC0gMSwgbHRyID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuXG4gICAgICAgIHZhciBvcGVuU3RhcnQgPSBmcm9tQXJnID09IG51bGwgJiYgZnJvbSA9PSAwLCBvcGVuRW5kID0gdG9BcmcgPT0gbnVsbCAmJiB0byA9PSBsaW5lTGVuO1xuICAgICAgICB2YXIgZmlyc3QgPSBpID09IDAsIGxhc3QgPSAhb3JkZXIgfHwgaSA9PSBvcmRlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodG9Qb3MudG9wIC0gZnJvbVBvcy50b3AgPD0gMykgeyAvLyBTaW5nbGUgbGluZVxuICAgICAgICAgIHZhciBvcGVuTGVmdCA9IChkb2NMVFIgPyBvcGVuU3RhcnQgOiBvcGVuRW5kKSAmJiBmaXJzdDtcbiAgICAgICAgICB2YXIgb3BlblJpZ2h0ID0gKGRvY0xUUiA/IG9wZW5FbmQgOiBvcGVuU3RhcnQpICYmIGxhc3Q7XG4gICAgICAgICAgdmFyIGxlZnQgPSBvcGVuTGVmdCA/IGxlZnRTaWRlIDogKGx0ciA/IGZyb21Qb3MgOiB0b1BvcykubGVmdDtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBvcGVuUmlnaHQgPyByaWdodFNpZGUgOiAobHRyID8gdG9Qb3MgOiBmcm9tUG9zKS5yaWdodDtcbiAgICAgICAgICBhZGQobGVmdCwgZnJvbVBvcy50b3AsIHJpZ2h0IC0gbGVmdCwgZnJvbVBvcy5ib3R0b20pO1xuICAgICAgICB9IGVsc2UgeyAvLyBNdWx0aXBsZSBsaW5lc1xuICAgICAgICAgIHZhciB0b3BMZWZ0LCB0b3BSaWdodCwgYm90TGVmdCwgYm90UmlnaHQ7XG4gICAgICAgICAgaWYgKGx0cikge1xuICAgICAgICAgICAgdG9wTGVmdCA9IGRvY0xUUiAmJiBvcGVuU3RhcnQgJiYgZmlyc3QgPyBsZWZ0U2lkZSA6IGZyb21Qb3MubGVmdDtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIGJvdExlZnQgPSBkb2NMVFIgPyBsZWZ0U2lkZSA6IHdyYXBYKHRvLCBkaXIsIFwiYWZ0ZXJcIik7XG4gICAgICAgICAgICBib3RSaWdodCA9IGRvY0xUUiAmJiBvcGVuRW5kICYmIGxhc3QgPyByaWdodFNpZGUgOiB0b1Bvcy5yaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wTGVmdCA9ICFkb2NMVFIgPyBsZWZ0U2lkZSA6IHdyYXBYKGZyb20sIGRpciwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICB0b3BSaWdodCA9ICFkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gcmlnaHRTaWRlIDogZnJvbVBvcy5yaWdodDtcbiAgICAgICAgICAgIGJvdExlZnQgPSAhZG9jTFRSICYmIG9wZW5FbmQgJiYgbGFzdCA/IGxlZnRTaWRlIDogdG9Qb3MubGVmdDtcbiAgICAgICAgICAgIGJvdFJpZ2h0ID0gIWRvY0xUUiA/IHJpZ2h0U2lkZSA6IHdyYXBYKHRvLCBkaXIsIFwiYWZ0ZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZCh0b3BMZWZ0LCBmcm9tUG9zLnRvcCwgdG9wUmlnaHQgLSB0b3BMZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgICAgaWYgKGZyb21Qb3MuYm90dG9tIDwgdG9Qb3MudG9wKSB7IGFkZChsZWZ0U2lkZSwgZnJvbVBvcy5ib3R0b20sIG51bGwsIHRvUG9zLnRvcCk7IH1cbiAgICAgICAgICBhZGQoYm90TGVmdCwgdG9Qb3MudG9wLCBib3RSaWdodCAtIGJvdExlZnQsIHRvUG9zLmJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXJ0IHx8IGNtcENvb3Jkcyhmcm9tUG9zLCBzdGFydCkgPCAwKSB7IHN0YXJ0ID0gZnJvbVBvczsgfVxuICAgICAgICBpZiAoY21wQ29vcmRzKHRvUG9zLCBzdGFydCkgPCAwKSB7IHN0YXJ0ID0gdG9Qb3M7IH1cbiAgICAgICAgaWYgKCFlbmQgfHwgY21wQ29vcmRzKGZyb21Qb3MsIGVuZCkgPCAwKSB7IGVuZCA9IGZyb21Qb3M7IH1cbiAgICAgICAgaWYgKGNtcENvb3Jkcyh0b1BvcywgZW5kKSA8IDApIHsgZW5kID0gdG9Qb3M7IH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfVxuICAgIH1cblxuICAgIHZhciBzRnJvbSA9IHJhbmdlLmZyb20oKSwgc1RvID0gcmFuZ2UudG8oKTtcbiAgICBpZiAoc0Zyb20ubGluZSA9PSBzVG8ubGluZSkge1xuICAgICAgZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNUby5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcm9tTGluZSA9IGdldExpbmUoZG9jLCBzRnJvbS5saW5lKSwgdG9MaW5lID0gZ2V0TGluZShkb2MsIHNUby5saW5lKTtcbiAgICAgIHZhciBzaW5nbGVWTGluZSA9IHZpc3VhbExpbmUoZnJvbUxpbmUpID09IHZpc3VhbExpbmUodG9MaW5lKTtcbiAgICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kO1xuICAgICAgdmFyIHJpZ2h0U3RhcnQgPSBkcmF3Rm9yTGluZShzVG8ubGluZSwgc2luZ2xlVkxpbmUgPyAwIDogbnVsbCwgc1RvLmNoKS5zdGFydDtcbiAgICAgIGlmIChzaW5nbGVWTGluZSkge1xuICAgICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIG51bGwsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgICBhZGQobGVmdFNpZGUsIHJpZ2h0U3RhcnQudG9wLCByaWdodFN0YXJ0LmxlZnQsIHJpZ2h0U3RhcnQuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIHJpZ2h0U3RhcnQubGVmdCAtIGxlZnRFbmQucmlnaHQsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlZnRFbmQuYm90dG9tIDwgcmlnaHRTdGFydC50b3ApXG4gICAgICAgIHsgYWRkKGxlZnRTaWRlLCBsZWZ0RW5kLmJvdHRvbSwgbnVsbCwgcmlnaHRTdGFydC50b3ApOyB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgfVxuXG4gIC8vIEN1cnNvci1ibGlua2luZ1xuICBmdW5jdGlvbiByZXN0YXJ0QmxpbmsoY20pIHtcbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgY2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpO1xuICAgIHZhciBvbiA9IHRydWU7XG4gICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlID4gMClcbiAgICAgIHsgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNtLmhhc0ZvY3VzKCkpIHsgb25CbHVyKGNtKTsgfVxuICAgICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFwiXCIgOiBcImhpZGRlblwiO1xuICAgICAgfSwgY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpOyB9XG4gICAgZWxzZSBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPCAwKVxuICAgICAgeyBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pIHtcbiAgICBpZiAoIWNtLmhhc0ZvY3VzKCkpIHtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBvbkZvY3VzKGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGF5Qmx1ckV2ZW50KGNtKSB7XG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBvbkJsdXIoY20pOyB9XG4gICAgfSB9LCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1cyhjbSwgZSkge1xuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0KSB7IGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7IH1cblxuICAgIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ID09IFwibm9jdXJzb3JcIikgeyByZXR1cm4gfVxuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImZvY3VzXCIsIGNtLCBlKTtcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgIC8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XG4gICAgICAvLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXG4gICAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxuICAgICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ICE9IGNtLmRvYy5zZWwpIHtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBpZiAod2Via2l0KSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9IC8vIElzc3VlICMxNzMwXG4gICAgICB9XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKTtcbiAgICB9XG4gICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgfVxuICBmdW5jdGlvbiBvbkJsdXIoY20sIGUpIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgcmV0dXJuIH1cblxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICBzaWduYWwoY20sIFwiYmx1clwiLCBjbSwgZSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTsgfSB9LCAxNTApO1xuICB9XG5cbiAgLy8gUmVhZCB0aGUgYWN0dWFsIGhlaWdodHMgb2YgdGhlIHJlbmRlcmVkIGxpbmVzLCBhbmQgdXBkYXRlIHRoZWlyXG4gIC8vIHN0b3JlZCBoZWlnaHRzIHRvIG1hdGNoLlxuICBmdW5jdGlvbiB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgcHJldkJvdHRvbSA9IGRpc3BsYXkubGluZURpdi5vZmZzZXRUb3A7XG4gICAgdmFyIHZpZXdUb3AgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgdmFyIG9sZEhlaWdodCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgdmFyIG11c3RTY3JvbGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgICAgdmFyIGhlaWdodCA9ICh2b2lkIDApLCB3aWR0aCA9IDA7XG4gICAgICBpZiAoY3VyLmhpZGRlbikgeyBjb250aW51ZSB9XG4gICAgICBvbGRIZWlnaHQgKz0gY3VyLmxpbmUuaGVpZ2h0O1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7XG4gICAgICAgIHZhciBib3QgPSBjdXIubm9kZS5vZmZzZXRUb3AgKyBjdXIubm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b207XG4gICAgICAgIHByZXZCb3R0b20gPSBib3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYm94ID0gY3VyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wO1xuICAgICAgICAvLyBDaGVjayB0aGF0IGxpbmVzIGRvbid0IGV4dGVuZCBwYXN0IHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxuICAgICAgICAvLyBlZGl0b3Igd2lkdGhcbiAgICAgICAgaWYgKCF3cmFwcGluZyAmJiBjdXIudGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgIHsgd2lkdGggPSBjdXIudGV4dC5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gYm94LmxlZnQgLSAxOyB9XG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcbiAgICAgIGlmIChkaWZmID4gLjAwNSB8fCBkaWZmIDwgLS4wMDUpIHtcbiAgICAgICAgaWYgKG9sZEhlaWdodCA8IHZpZXdUb3ApIHsgbXVzdFNjcm9sbCAtPSBkaWZmOyB9XG4gICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQoY3VyLmxpbmUsIGhlaWdodCk7XG4gICAgICAgIHVwZGF0ZVdpZGdldEhlaWdodChjdXIubGluZSk7XG4gICAgICAgIGlmIChjdXIucmVzdCkgeyBmb3IgKHZhciBqID0gMDsgaiA8IGN1ci5yZXN0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgIHsgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5yZXN0W2pdKTsgfSB9XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPiBjbS5kaXNwbGF5LnNpemVyV2lkdGgpIHtcbiAgICAgICAgdmFyIGNoV2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpO1xuICAgICAgICBpZiAoY2hXaWR0aCA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGNoV2lkdGg7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gY3VyLmxpbmU7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKG11c3RTY3JvbGwpID4gMikgeyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCArPSBtdXN0U2Nyb2xsOyB9XG4gIH1cblxuICAvLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gIC8vIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZVdpZGdldEhlaWdodChsaW5lKSB7XG4gICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHcgPSBsaW5lLndpZGdldHNbaV0sIHBhcmVudCA9IHcubm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudCkgeyB3LmhlaWdodCA9IHBhcmVudC5vZmZzZXRIZWlnaHQ7IH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGxpbmVzIHRoYXQgYXJlIHZpc2libGUgaW4gYSBnaXZlbiB2aWV3cG9ydCAoZGVmYXVsdHNcbiAgLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcbiAgLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MsIHZpZXdwb3J0KSB7XG4gICAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XG4gICAgdmFyIGJvdHRvbSA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LmJvdHRvbSAhPSBudWxsID8gdmlld3BvcnQuYm90dG9tIDogdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgIHZhciBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgdG9wKSwgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBib3R0b20pO1xuICAgIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcbiAgICAvLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cbiAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XG4gICAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7XG4gICAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcbiAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XG4gICAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5taW4oZW5zdXJlVG8sIGRvYy5sYXN0TGluZSgpKSA+PSB0bykge1xuICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIHRvID0gZW5zdXJlVG87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XG4gIH1cblxuICAvLyBTQ1JPTExJTkcgVEhJTkdTIElOVE8gVklFV1xuXG4gIC8vIElmIGFuIGVkaXRvciBzaXRzIG9uIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB3aW5kb3csIHBhcnRpYWxseVxuICAvLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxuICBmdW5jdGlvbiBtYXliZVNjcm9sbFdpbmRvdyhjbSwgcmVjdCkge1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgXCJzY3JvbGxDdXJzb3JJbnRvVmlld1wiKSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBib3ggPSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb1Njcm9sbCA9IG51bGw7XG4gICAgaWYgKHJlY3QudG9wICsgYm94LnRvcCA8IDApIHsgZG9TY3JvbGwgPSB0cnVlOyB9XG4gICAgZWxzZSBpZiAocmVjdC5ib3R0b20gKyBib3gudG9wID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSkgeyBkb1Njcm9sbCA9IGZhbHNlOyB9XG4gICAgaWYgKGRvU2Nyb2xsICE9IG51bGwgJiYgIXBoYW50b20pIHtcbiAgICAgIHZhciBzY3JvbGxOb2RlID0gZWx0KFwiZGl2XCIsIFwiXFx1MjAwYlwiLCBudWxsLCAoXCJwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIgKyAocmVjdC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQgLSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpKSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAocmVjdC5ib3R0b20gLSByZWN0LnRvcCArIHNjcm9sbEdhcChjbSkgKyBkaXNwbGF5LmJhckhlaWdodCkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIiArIChyZWN0LmxlZnQpICsgXCJweDsgd2lkdGg6IFwiICsgKE1hdGgubWF4KDIsIHJlY3QucmlnaHQgLSByZWN0LmxlZnQpKSArIFwicHg7XCIpKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xuICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChzY3JvbGxOb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBwb3NpdGlvbiBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KSwgdmVyaWZ5aW5nIHRoYXRcbiAgLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxuICAvLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXG4gIGZ1bmN0aW9uIHNjcm9sbFBvc0ludG9WaWV3KGNtLCBwb3MsIGVuZCwgbWFyZ2luKSB7XG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IDA7IH1cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHBvcyA9PSBlbmQpIHtcbiAgICAgIC8vIFNldCBwb3MgYW5kIGVuZCB0byB0aGUgY3Vyc29yIHBvc2l0aW9ucyBhcm91bmQgdGhlIGNoYXJhY3RlciBwb3Mgc3RpY2tzIHRvXG4gICAgICAvLyBJZiBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIsIHRoYXQgaXMgYXJvdW5kIHBvcy5jaCAtIDEsIG90aGVyd2lzZSBhcm91bmQgcG9zLmNoXG4gICAgICAvLyBJZiBwb3MgPT0gUG9zKF8sIDAsIFwiYmVmb3JlXCIpLCBwb3MgYW5kIGVuZCBhcmUgdW5jaGFuZ2VkXG4gICAgICBlbmQgPSBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBQb3MocG9zLmxpbmUsIHBvcy5jaCArIDEsIFwiYmVmb3JlXCIpIDogcG9zO1xuICAgICAgcG9zID0gcG9zLmNoID8gUG9zKHBvcy5saW5lLCBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBwb3MuY2ggLSAxIDogcG9zLmNoLCBcImFmdGVyXCIpIDogcG9zO1xuICAgIH1cbiAgICBmb3IgKHZhciBsaW1pdCA9IDA7IGxpbWl0IDwgNTsgbGltaXQrKykge1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcyk7XG4gICAgICB2YXIgZW5kQ29vcmRzID0gIWVuZCB8fCBlbmQgPT0gcG9zID8gY29vcmRzIDogY3Vyc29yQ29vcmRzKGNtLCBlbmQpO1xuICAgICAgcmVjdCA9IHtsZWZ0OiBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICB0b3A6IE1hdGgubWluKGNvb3Jkcy50b3AsIGVuZENvb3Jkcy50b3ApIC0gbWFyZ2luLFxuICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgoY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChjb29yZHMuYm90dG9tLCBlbmRDb29yZHMuYm90dG9tKSArIG1hcmdpbn07XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHN0YXJ0VG9wKSA+IDEpIHsgY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0IC0gc3RhcnRMZWZ0KSA+IDEpIHsgY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIGlmICghY2hhbmdlZCkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiByZWN0XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMgaW50byB2aWV3IChpbW1lZGlhdGVseSkuXG4gIGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNtLCByZWN0KSB7XG4gICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCk7XG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkgeyB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApOyB9XG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHsgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpOyB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXG4gIC8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxuICAvLyBzY3JvbGxMZWZ0IHByb3BlcnRpZXMuIFdoZW4gdGhlc2UgYXJlIHVuZGVmaW5lZCwgdGhlXG4gIC8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzbmFwTWFyZ2luID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KTtcbiAgICBpZiAocmVjdC50b3AgPCAwKSB7IHJlY3QudG9wID0gMDsgfVxuICAgIHZhciBzY3JlZW50b3AgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3AgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbFRvcCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JlZW4gPSBkaXNwbGF5SGVpZ2h0KGNtKSwgcmVzdWx0ID0ge307XG4gICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBzY3JlZW4pIHsgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHNjcmVlbjsgfVxuICAgIHZhciBkb2NCb3R0b20gPSBjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoZGlzcGxheSk7XG4gICAgdmFyIGF0VG9wID0gcmVjdC50b3AgPCBzbmFwTWFyZ2luLCBhdEJvdHRvbSA9IHJlY3QuYm90dG9tID4gZG9jQm90dG9tIC0gc25hcE1hcmdpbjtcbiAgICBpZiAocmVjdC50b3AgPCBzY3JlZW50b3ApIHtcbiAgICAgIHJlc3VsdC5zY3JvbGxUb3AgPSBhdFRvcCA/IDAgOiByZWN0LnRvcDtcbiAgICB9IGVsc2UgaWYgKHJlY3QuYm90dG9tID4gc2NyZWVudG9wICsgc2NyZWVuKSB7XG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHJlY3QuYm90dG9tKSAtIHNjcmVlbik7XG4gICAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgeyByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wOyB9XG4gICAgfVxuXG4gICAgdmFyIGd1dHRlclNwYWNlID0gY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IDAgOiBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHNjcmVlbmxlZnQgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxMZWZ0IDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IC0gZ3V0dGVyU3BhY2U7XG4gICAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciB0b29XaWRlID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdCA+IHNjcmVlbnc7XG4gICAgaWYgKHRvb1dpZGUpIHsgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHNjcmVlbnc7IH1cbiAgICBpZiAocmVjdC5sZWZ0IDwgMTApXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gMDsgfVxuICAgIGVsc2UgaWYgKHJlY3QubGVmdCA8IHNjcmVlbmxlZnQpXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0ICsgZ3V0dGVyU3BhY2UgLSAodG9vV2lkZSA/IDAgOiAxMCkpOyB9XG4gICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSByZWN0LnJpZ2h0ICsgKHRvb1dpZGUgPyAwIDogMTApIC0gc2NyZWVudzsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFN0b3JlIGEgcmVsYXRpdmUgYWRqdXN0bWVudCB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XG4gIC8vIG9wZXJhdGlvbiAodG8gYmUgYXBwbGllZCB3aGVuIHRoZSBvcGVyYXRpb24gZmluaXNoZXMpLlxuICBmdW5jdGlvbiBhZGRUb1Njcm9sbFRvcChjbSwgdG9wKSB7XG4gICAgaWYgKHRvcCA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb3AgPSAoY20uY3VyT3Auc2Nyb2xsVG9wID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsVG9wIDogY20uY3VyT3Auc2Nyb2xsVG9wKSArIHRvcDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiB0aGUgY3VycmVudCBjdXJzb3IgaXNcbiAgLy8gc2hvd24uXG4gIGZ1bmN0aW9uIGVuc3VyZUN1cnNvclZpc2libGUoY20pIHtcbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBjdXIsIHRvOiBjdXIsIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW59O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9Db29yZHMoY20sIHgsIHkpIHtcbiAgICBpZiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pOyB9XG4gICAgaWYgKHggIT0gbnVsbCkgeyBjbS5jdXJPcC5zY3JvbGxMZWZ0ID0geDsgfVxuICAgIGlmICh5ICE9IG51bGwpIHsgY20uY3VyT3Auc2Nyb2xsVG9wID0geTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShjbSwgcmFuZ2UpIHtcbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gcmFuZ2U7XG4gIH1cblxuICAvLyBXaGVuIGFuIG9wZXJhdGlvbiBoYXMgaXRzIHNjcm9sbFRvUG9zIHByb3BlcnR5IHNldCwgYW5kIGFub3RoZXJcbiAgLy8gc2Nyb2xsIGFjdGlvbiBpcyBhcHBsaWVkIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24sIHRoaXNcbiAgLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xuICAvLyB0aGF0IHRoZSBlZmZlY3Qgb2YgaW50ZXJtZWRpYXRlIHNjcm9sbCBjb21tYW5kcyBpcyBub3QgaWdub3JlZC5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKSB7XG4gICAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IG51bGw7XG4gICAgICB2YXIgZnJvbSA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS5mcm9tKSwgdG8gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UudG8pO1xuICAgICAgc2Nyb2xsVG9Db29yZHNSYW5nZShjbSwgZnJvbSwgdG8sIHJhbmdlLm1hcmdpbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9Db29yZHNSYW5nZShjbSwgZnJvbSwgdG8sIG1hcmdpbikge1xuICAgIHZhciBzUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihmcm9tLmxlZnQsIHRvLmxlZnQpLFxuICAgICAgdG9wOiBNYXRoLm1pbihmcm9tLnRvcCwgdG8udG9wKSAtIG1hcmdpbixcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChmcm9tLnJpZ2h0LCB0by5yaWdodCksXG4gICAgICBib3R0b206IE1hdGgubWF4KGZyb20uYm90dG9tLCB0by5ib3R0b20pICsgbWFyZ2luXG4gICAgfSk7XG4gICAgc2Nyb2xsVG9Db29yZHMoY20sIHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xuICB9XG5cbiAgLy8gU3luYyB0aGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBzY3JvbGxiYXJzLCBlbnN1cmUgdGhlIHZpZXdwb3J0XG4gIC8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxUb3AoY20sIHZhbCkge1xuICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gdmFsKSA8IDIpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pOyB9XG4gICAgc2V0U2Nyb2xsVG9wKGNtLCB2YWwsIHRydWUpO1xuICAgIGlmIChnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtKTsgfVxuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2Nyb2xsVG9wKGNtLCB2YWwsIGZvcmNlU2Nyb2xsKSB7XG4gICAgdmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCwgdmFsKSk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID09IHZhbCAmJiAhZm9yY2VTY3JvbGwpIHsgcmV0dXJuIH1cbiAgICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsO1xuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodmFsKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gdmFsOyB9XG4gIH1cblxuICAvLyBTeW5jIHNjcm9sbGVyIGFuZCBzY3JvbGxiYXIsIGVuc3VyZSB0aGUgZ3V0dGVyIGVsZW1lbnRzIGFyZVxuICAvLyBhbGlnbmVkLlxuICBmdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KGNtLCB2YWwsIGlzU2Nyb2xsZXIsIGZvcmNlU2Nyb2xsKSB7XG4gICAgdmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsLCBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCkpO1xuICAgIGlmICgoaXNTY3JvbGxlciA/IHZhbCA9PSBjbS5kb2Muc2Nyb2xsTGVmdCA6IE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0IC0gdmFsKSA8IDIpICYmICFmb3JjZVNjcm9sbCkgeyByZXR1cm4gfVxuICAgIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IHZhbCkgeyBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSB2YWw7IH1cbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdCh2YWwpO1xuICB9XG5cbiAgLy8gU0NST0xMQkFSU1xuXG4gIC8vIFByZXBhcmUgRE9NIHJlYWRzIG5lZWRlZCB0byB1cGRhdGUgdGhlIHNjcm9sbGJhcnMuIERvbmUgaW4gb25lXG4gIC8vIHNob3QgdG8gbWluaW1pemUgdXBkYXRlL21lYXN1cmUgcm91bmR0cmlwcy5cbiAgZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGd1dHRlclcgPSBkLmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGRvY0ggPSBNYXRoLnJvdW5kKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXG4gICAgICB2aWV3SGVpZ2h0OiBkLndyYXBwZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IGQuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgsIGNsaWVudFdpZHRoOiBkLnNjcm9sbGVyLmNsaWVudFdpZHRoLFxuICAgICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXG4gICAgICBiYXJMZWZ0OiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZ3V0dGVyVyA6IDAsXG4gICAgICBkb2NIZWlnaHQ6IGRvY0gsXG4gICAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXG4gICAgICBuYXRpdmVCYXJXaWR0aDogZC5uYXRpdmVCYXJXaWR0aCxcbiAgICAgIGd1dHRlcldpZHRoOiBndXR0ZXJXXG4gICAgfVxuICB9XG5cbiAgdmFyIE5hdGl2ZVNjcm9sbGJhcnMgPSBmdW5jdGlvbihwbGFjZSwgc2Nyb2xsLCBjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICB2YXIgdmVydCA9IHRoaXMudmVydCA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwibWluLXdpZHRoOiAxcHhcIildLCBcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKTtcbiAgICB2YXIgaG9yaXogPSB0aGlzLmhvcml6ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJoZWlnaHQ6IDEwMCU7IG1pbi1oZWlnaHQ6IDFweFwiKV0sIFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXCIpO1xuICAgIHZlcnQudGFiSW5kZXggPSBob3Jpei50YWJJbmRleCA9IC0xO1xuICAgIHBsYWNlKHZlcnQpOyBwbGFjZShob3Jpeik7XG5cbiAgICBvbih2ZXJ0LCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodmVydC5jbGllbnRIZWlnaHQpIHsgc2Nyb2xsKHZlcnQuc2Nyb2xsVG9wLCBcInZlcnRpY2FsXCIpOyB9XG4gICAgfSk7XG4gICAgb24oaG9yaXosIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkgeyBzY3JvbGwoaG9yaXouc2Nyb2xsTGVmdCwgXCJob3Jpem9udGFsXCIpOyB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSBmYWxzZTtcbiAgICAvLyBOZWVkIHRvIHNldCBhIG1pbmltdW0gd2lkdGggdG8gc2VlIHRoZSBzY3JvbGxiYXIgb24gSUU3IChidXQgbXVzdCBub3Qgc2V0IGl0IG9uIElFOCkuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXCIxOHB4XCI7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgIHZhciBuZWVkc0ggPSBtZWFzdXJlLnNjcm9sbFdpZHRoID4gbWVhc3VyZS5jbGllbnRXaWR0aCArIDE7XG4gICAgdmFyIG5lZWRzViA9IG1lYXN1cmUuc2Nyb2xsSGVpZ2h0ID4gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyAxO1xuICAgIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoO1xuXG4gICAgaWYgKG5lZWRzVikge1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMCk7XG4gICAgICAvLyBBIGJ1ZyBpbiBJRTggY2FuIGNhdXNlIHRoaXMgdmFsdWUgdG8gYmUgbmVnYXRpdmUsIHNvIGd1YXJkIGl0LlxuICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cbiAgICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxIZWlnaHQgLSBtZWFzdXJlLmNsaWVudEhlaWdodCArIHRvdGFsSGVpZ2h0KSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzSCkge1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5yaWdodCA9IG5lZWRzViA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgICAgdmFyIHRvdGFsV2lkdGggPSBtZWFzdXJlLnZpZXdXaWR0aCAtIG1lYXN1cmUuYmFyTGVmdCAtIChuZWVkc1YgPyBzV2lkdGggOiAwKTtcbiAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9XG4gICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hlY2tlZFplcm9XaWR0aCAmJiBtZWFzdXJlLmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgIGlmIChzV2lkdGggPT0gMCkgeyB0aGlzLnplcm9XaWR0aEhhY2soKTsgfVxuICAgICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlSG9yaXopIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3JpeiwgdGhpcy5kaXNhYmxlSG9yaXosIFwiaG9yaXpcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMudmVydC5zY3JvbGxUb3AgIT0gcG9zKSB7IHRoaXMudmVydC5zY3JvbGxUb3AgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQsIFwidmVydFwiKTsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnplcm9XaWR0aEhhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHcgPSBtYWMgJiYgIW1hY19nZU1vdW50YWluTGlvbiA/IFwiMTJweFwiIDogXCIxOHB4XCI7XG4gICAgdGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUud2lkdGggPSB3O1xuICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRGVsYXllZDtcbiAgICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWQ7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyID0gZnVuY3Rpb24gKGJhciwgZGVsYXksIHR5cGUpIHtcbiAgICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGZ1bmN0aW9uIG1heWJlRGlzYWJsZSgpIHtcbiAgICAgIC8vIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIHNjcm9sbGJhciBpcyBzdGlsbCB2aXNpYmxlLCB3ZVxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCB1bmRlciB0aGUgcGl4ZWwgaW4gdGhlIGJvdHRvbVxuICAgICAgLy8gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JvbGxiYXIgYm94IGlzIHRoZSBzY3JvbGxiYXIgYm94XG4gICAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXG4gICAgICAvLyAod2hlbiB0aGUgYmFyIGlzIGhpZGRlbikuIElmIGl0IGlzIHN0aWxsIHZpc2libGUsIHdlIGtlZXBcbiAgICAgIC8vIGl0IGVuYWJsZWQsIGlmIGl0J3MgaGlkZGVuLCB3ZSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBlbHQgPSB0eXBlID09IFwidmVydFwiID8gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gucmlnaHQgLSAxLCAoYm94LnRvcCArIGJveC5ib3R0b20pIC8gMilcbiAgICAgICAgICA6IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoKGJveC5yaWdodCArIGJveC5sZWZ0KSAvIDIsIGJveC5ib3R0b20gLSAxKTtcbiAgICAgIGlmIChlbHQgIT0gYmFyKSB7IGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IH1cbiAgICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTsgfVxuICAgIH1cbiAgICBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTtcbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KTtcbiAgfTtcblxuICB2YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xuICAgIGlmICghbWVhc3VyZSkgeyBtZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pOyB9XG4gICAgdmFyIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoLCBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCB8fCBzdGFydEhlaWdodCAhPSBjbS5kaXNwbGF5LmJhckhlaWdodDsgaSsrKSB7XG4gICAgICBpZiAoc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxuICAgICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkpO1xuICAgICAgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGg7IHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUmUtc3luY2hyb25pemUgdGhlIGZha2Ugc2Nyb2xsYmFycyB3aXRoIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGVcbiAgLy8gY29udGVudC5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSk7XG5cbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IChkLmJhcldpZHRoID0gc2l6ZXMucmlnaHQpICsgXCJweFwiO1xuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IChkLmJhckhlaWdodCA9IHNpemVzLmJvdHRvbSkgKyBcInB4XCI7XG4gICAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiO1xuXG4gICAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBpZiAoc2l6ZXMuYm90dG9tICYmIGNtLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgJiYgY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFwicHhcIjtcbiAgICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICB9XG5cbiAgdmFyIHNjcm9sbGJhck1vZGVsID0ge1wibmF0aXZlXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFwibnVsbFwiOiBOdWxsU2Nyb2xsYmFyc307XG5cbiAgZnVuY3Rpb24gaW5pdFNjcm9sbGJhcnMoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICAgIHsgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgICB9XG5cbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMgPSBuZXcgc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgY20uZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpO1xuICAgICAgLy8gUHJldmVudCBjbGlja3MgaW4gdGhlIHNjcm9sbGJhcnMgZnJvbSBraWxsaW5nIGZvY3VzXG4gICAgICBvbihub2RlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTsgfVxuICAgICAgfSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PSBcImhvcml6b250YWxcIikgeyBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpOyB9XG4gICAgICBlbHNlIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBwb3MpOyB9XG4gICAgfSwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICB7IGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTsgfVxuICB9XG5cbiAgLy8gT3BlcmF0aW9ucyBhcmUgdXNlZCB0byB3cmFwIGEgc2VyaWVzIG9mIGNoYW5nZXMgdG8gdGhlIGVkaXRvclxuICAvLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXG4gIC8vIGN1cnNvciBhbmQgZGlzcGxheSAod2hpY2ggd291bGQgYmUgYXdrd2FyZCwgc2xvdywgYW5kXG4gIC8vIGVycm9yLXByb25lKS4gSW5zdGVhZCwgZGlzcGxheSB1cGRhdGVzIGFyZSBiYXRjaGVkIGFuZCB0aGVuIGFsbFxuICAvLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cblxuICB2YXIgbmV4dE9wSWQgPSAwO1xuICAvLyBTdGFydCBhIG5ldyBvcGVyYXRpb24uXG4gIGZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XG4gICAgY20uY3VyT3AgPSB7XG4gICAgICBjbTogY20sXG4gICAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAgICAgIC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcbiAgICAgIHVwZGF0ZUlucHV0OiAwLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXG4gICAgICBjaGFuZ2VPYmpzOiBudWxsLCAgICAgICAgLy8gQWNjdW11bGF0ZWQgY2hhbmdlcywgZm9yIGZpcmluZyBjaGFuZ2UgZXZlbnRzXG4gICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XG4gICAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgZm9jdXM6IGZhbHNlLFxuICAgICAgaWQ6ICsrbmV4dE9wSWQsICAgICAgICAgIC8vIFVuaXF1ZSBJRFxuICAgICAgbWFya0FycmF5czogbnVsbCAgICAgICAgIC8vIFVzZWQgYnkgYWRkTWFya2VkU3BhblxuICAgIH07XG4gICAgcHVzaE9wZXJhdGlvbihjbS5jdXJPcCk7XG4gIH1cblxuICAvLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xuICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcbiAgICB2YXIgb3AgPSBjbS5jdXJPcDtcbiAgICBpZiAob3ApIHsgZmluaXNoT3BlcmF0aW9uKG9wLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7IH1cbiAgICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xuICAgIH0pOyB9XG4gIH1cblxuICAvLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25zKGdyb3VwKSB7XG4gICAgdmFyIG9wcyA9IGdyb3VwLm9wcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSk7IH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHMubGVuZ3RoOyBpJDErKykgLy8gV3JpdGUgRE9NIChtYXliZSlcbiAgICAgIHsgZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKTsgfVxuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG9wcy5sZW5ndGg7IGkkMisrKSAvLyBSZWFkIERPTVxuICAgICAgeyBlbmRPcGVyYXRpb25fUjIob3BzW2kkMl0pOyB9XG4gICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgb3BzLmxlbmd0aDsgaSQzKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSk7IH1cbiAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBvcHMubGVuZ3RoOyBpJDQrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMShvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKTtcbiAgICBpZiAob3AudXBkYXRlTWF4TGluZSkgeyBmaW5kTWF4TGluZShjbSk7IH1cblxuICAgIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fFxuICAgICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fFxuICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICBvcC51cGRhdGUgPSBvcC5tdXN0VXBkYXRlICYmXG4gICAgICBuZXcgRGlzcGxheVVwZGF0ZShjbSwgb3AubXVzdFVwZGF0ZSAmJiB7dG9wOiBvcC5zY3JvbGxUb3AsIGVuc3VyZTogb3Auc2Nyb2xsVG9Qb3N9LCBvcC5mb3JjZVVwZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcbiAgICBvcC51cGRhdGVkRGlzcGxheSA9IG9wLm11c3RVcGRhdGUgJiYgdXBkYXRlRGlzcGxheUlmTmVlZGVkKG9wLmNtLCBvcC51cGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cblxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG5cbiAgICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXG4gICAgLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcbiAgICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbztcbiAgICAgIG9wLmJhck1lYXN1cmUuc2Nyb2xsV2lkdGggPVxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xuICAgICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcbiAgICB9XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc2VsZWN0aW9uQ2hhbmdlZClcbiAgICAgIHsgb3AucHJlcGFyZWRTZWxlY3Rpb24gPSBkaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY207XG5cbiAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbyArIFwicHhcIjtcbiAgICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXG4gICAgICAgIHsgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7IH1cbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFrZUZvY3VzID0gb3AuZm9jdXMgJiYgb3AuZm9jdXMgPT0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cyk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodClcbiAgICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpXG4gICAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKTsgfVxuXG4gICAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHsgcmVzdGFydEJsaW5rKGNtKTsgfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTsgfVxuICAgIGlmICh0YWtlRm9jdXMpIHsgZW5zdXJlRm9jdXMob3AuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7IH1cblxuICAgIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XG4gICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggIT0gbnVsbCAmJiAob3Auc2Nyb2xsVG9wICE9IG51bGwgfHwgb3Auc2Nyb2xsTGVmdCAhPSBudWxsIHx8IG9wLnNjcm9sbFRvUG9zKSlcbiAgICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsOyB9XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCkgeyBzZXRTY3JvbGxUb3AoY20sIG9wLnNjcm9sbFRvcCwgb3AuZm9yY2VTY3JvbGwpOyB9XG5cbiAgICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIG9wLnNjcm9sbExlZnQsIHRydWUsIHRydWUpOyB9XG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxuICAgIGlmIChvcC5zY3JvbGxUb1Bvcykge1xuICAgICAgdmFyIHJlY3QgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pO1xuICAgICAgbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpO1xuICAgIH1cblxuICAgIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcbiAgICAvLyB1bmRvaW5nXG4gICAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2VycztcbiAgICBpZiAoaGlkZGVuKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXCJoaWRlXCIpOyB9IH0gfVxuICAgIGlmICh1bmhpZGRlbikgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB1bmhpZGRlbi5sZW5ndGg7ICsraSQxKVxuICAgICAgeyBpZiAodW5oaWRkZW5baSQxXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKHVuaGlkZGVuW2kkMV0sIFwidW5oaWRlXCIpOyB9IH0gfVxuXG4gICAgaWYgKGRpc3BsYXkud3JhcHBlci5vZmZzZXRIZWlnaHQpXG4gICAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDsgfVxuXG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgeyBzaWduYWwoY20sIFwiY2hhbmdlc1wiLCBjbSwgb3AuY2hhbmdlT2Jqcyk7IH1cbiAgICBpZiAob3AudXBkYXRlKVxuICAgICAgeyBvcC51cGRhdGUuZmluaXNoKCk7IH1cbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXG4gIGZ1bmN0aW9uIHJ1bkluT3AoY20sIGYpIHtcbiAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XG4gICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgIHRyeSB7IHJldHVybiBmKCkgfVxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gIH1cbiAgLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIG9wZXJhdGlvbihjbSwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuICAvLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxuICAvLyBvcGVyYXRpb25zLlxuICBmdW5jdGlvbiBtZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbih0aGlzKTsgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gSElHSExJR0hUIFdPUktFUlxuXG4gIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XG4gICAgaWYgKGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyBjbS5zdGF0ZS5oaWdobGlnaHQuc2V0KHRpbWUsIGJpbmQoaGlnaGxpZ2h0V29ya2VyLCBjbSkpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGlmIChkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIGRvYy5oaWdobGlnaHRGcm9udGllcik7XG4gICAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdO1xuXG4gICAgZG9jLml0ZXIoY29udGV4dC5saW5lLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgY20uZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNvbnRleHQubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFZpc2libGVcbiAgICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzO1xuICAgICAgICB2YXIgcmVzZXRTdGF0ZSA9IGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkgOiBudWxsO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc2V0U3RhdGUpIHsgY29udGV4dC5zdGF0ZSA9IHJlc2V0U3RhdGU7IH1cbiAgICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXM7XG4gICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgaWYgKG5ld0NscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NsczsgfVxuICAgICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcbiAgICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSB7IGlzY2hhbmdlID0gb2xkU3R5bGVzW2ldICE9IGxpbmUuc3R5bGVzW2ldOyB9XG4gICAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChjb250ZXh0LmxpbmUpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aClcbiAgICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQubGluZSAlIDUgPT0gMCA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IGNvbnRleHQubGluZTtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5tYXgoZG9jLm1vZGVGcm9udGllciwgY29udGV4dC5saW5lKTtcbiAgICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFwidGV4dFwiKTsgfVxuICAgIH0pOyB9XG4gIH1cblxuICAvLyBESVNQTEFZIERSQVdJTkdcblxuICB2YXIgRGlzcGxheVVwZGF0ZSA9IGZ1bmN0aW9uKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgLy8gU3RvcmUgc29tZSB2YWx1ZXMgdGhhdCB3ZSdsbCBuZWVkIGxhdGVyIChidXQgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHJlbGF5b3V0IGZvcilcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53cmFwcGVySGVpZ2h0ID0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XG4gICAgdGhpcy5mb3JjZSA9IGZvcmNlO1xuICAgIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gIH07XG5cbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcbiAgICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpOyB9XG4gIH07XG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pOyB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xuICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLWRpc3BsYXkubmF0aXZlQmFyV2lkdGggKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uU25hcHNob3QoY20pIHtcbiAgICBpZiAoY20uaGFzRm9jdXMoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGFjdGl2ZSA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmICghYWN0aXZlIHx8ICFjb250YWlucyhjbS5kaXNwbGF5LmxpbmVEaXYsIGFjdGl2ZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciByZXN1bHQgPSB7YWN0aXZlRWx0OiBhY3RpdmV9O1xuICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIHNlbC5leHRlbmQgJiYgY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgcmVzdWx0LmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgcmVzdWx0LmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICByZXN1bHQuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24oc25hcHNob3QpIHtcbiAgICBpZiAoIXNuYXBzaG90IHx8ICFzbmFwc2hvdC5hY3RpdmVFbHQgfHwgc25hcHNob3QuYWN0aXZlRWx0ID09IGFjdGl2ZUVsdCgpKSB7IHJldHVybiB9XG4gICAgc25hcHNob3QuYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgaWYgKCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KHNuYXBzaG90LmFjdGl2ZUVsdC5ub2RlTmFtZSkgJiZcbiAgICAgICAgc25hcHNob3QuYW5jaG9yTm9kZSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5hbmNob3JOb2RlKSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5mb2N1c05vZGUpKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZXRFbmQoc25hcHNob3QuYW5jaG9yTm9kZSwgc25hcHNob3QuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWwuZXh0ZW5kKHNuYXBzaG90LmZvY3VzTm9kZSwgc25hcHNob3QuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvZXMgdGhlIGFjdHVhbCB1cGRhdGluZyBvZiB0aGUgbGluZSBkaXNwbGF5LiBCYWlscyBvdXRcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xuICAvLyBmYWxzZS5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcblxuICAgIGlmICh1cGRhdGUuZWRpdG9ySXNIaWRkZW4pIHtcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxuICAgICAgICB1cGRhdGUudmlzaWJsZS5mcm9tID49IGRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSAmJlxuICAgICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXG4gICAgdmFyIGVuZCA9IGRvYy5maXJzdCArIGRvYy5zaXplO1xuICAgIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdCk7XG4gICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSB7IGZyb20gPSBNYXRoLm1heChkb2MuZmlyc3QsIGRpc3BsYXkudmlld0Zyb20pOyB9XG4gICAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7IH1cbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMpIHtcbiAgICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKTtcbiAgICAgIHRvID0gdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8pO1xuICAgIH1cblxuICAgIHZhciBkaWZmZXJlbnQgPSBmcm9tICE9IGRpc3BsYXkudmlld0Zyb20gfHwgdG8gIT0gZGlzcGxheS52aWV3VG8gfHxcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgIT0gdXBkYXRlLndyYXBwZXJIZWlnaHQgfHwgZGlzcGxheS5sYXN0V3JhcFdpZHRoICE9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xuXG4gICAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XG4gICAgLy8gUG9zaXRpb24gdGhlIG1vdmVyIGRpdiB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgIGNtLmRpc3BsYXkubW92ZXIuc3R5bGUudG9wID0gZGlzcGxheS52aWV3T2Zmc2V0ICsgXCJweFwiO1xuXG4gICAgdmFyIHRvVXBkYXRlID0gY291bnREaXJ0eVZpZXcoY20pO1xuICAgIGlmICghZGlmZmVyZW50ICYmIHRvVXBkYXRlID09IDAgJiYgIXVwZGF0ZS5mb3JjZSAmJiBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxuICAgIC8vIHVwZGF0ZSwgc2luY2UgdGhhdCBzcGVlZHMgdXAgdGhlIG9wZXJhdGlvbnMgb24gbW9zdCBicm93c2Vycy5cbiAgICB2YXIgc2VsU25hcHNob3QgPSBzZWxlY3Rpb25TbmFwc2hvdChjbSk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9IGRpc3BsYXkudmlldztcbiAgICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxuICAgIC8vIGhpZGRlbiBvciB1cGRhdGVkLCBpZiBzbyByZS1mb2N1cyBpdC5cbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbFNuYXBzaG90KTtcblxuICAgIC8vIFByZXZlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCB0aGUgc2Nyb2xsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodC5cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5zZWxlY3Rpb25EaXYpO1xuICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XG5cbiAgICBpZiAoZGlmZmVyZW50KSB7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHQ7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwV2lkdGggPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XG4gICAgfVxuXG4gICAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSkge1xuICAgIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcblxuICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgIGlmICghZmlyc3QgfHwgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nIHx8IHVwZGF0ZS5vbGREaXNwbGF5V2lkdGggPT0gZGlzcGxheVdpZHRoKGNtKSkge1xuICAgICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxuICAgICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpXG4gICAgICAgICAgeyB2aWV3cG9ydCA9IHt0b3A6IE1hdGgubWluKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSAtIGRpc3BsYXlIZWlnaHQoY20pLCB2aWV3cG9ydC50b3ApfTsgfVxuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XG4gICAgICAgIC8vIGFjdHVhbGx5IGNvdmVyaW5nIHRoZSB2aWV3cG9ydC4gS2VlcCBsb29waW5nIHVudGlsIGl0IGRvZXMuXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgICAgIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZvcmNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ1cGRhdGVcIiwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdGcm9tICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSB8fCBjbS5kaXNwbGF5LnZpZXdUbyAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKSB7XG4gICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInZpZXdwb3J0Q2hhbmdlXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XG4gICAgICBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvID0gY20uZGlzcGxheS52aWV3VG87XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgdmlld3BvcnQpIHtcbiAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcbiAgICBpZiAodXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4gIC8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcbiAgLy8gZGF0ZS5cbiAgZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xuICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcbiAgICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgICAgcmV0dXJuIG5leHRcbiAgICB9XG5cbiAgICB2YXIgdmlldyA9IGRpc3BsYXkudmlldywgbGluZU4gPSBkaXNwbGF5LnZpZXdGcm9tO1xuICAgIC8vIExvb3Agb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIHZpZXcsIHN5bmNpbmcgY3VyICh0aGUgRE9NIG5vZGVzXG4gICAgLy8gaW4gZGlzcGxheS5saW5lRGl2KSB3aXRoIHRoZSB2aWV3IGFzIHdlIGdvLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcbiAgICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIDsgZWxzZSBpZiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcubm9kZS5wYXJlbnROb2RlICE9IGNvbnRhaW5lcikgeyAvLyBOb3QgZHJhd24geWV0XG4gICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBjdXIpO1xuICAgICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxuICAgICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIHsgY3VyID0gcm0oY3VyKTsgfVxuICAgICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxuICAgICAgICAgIHVwZGF0ZU51bWJlcnNGcm9tIDw9IGxpbmVOICYmIGxpbmVWaWV3LmxpbmVOdW1iZXI7XG4gICAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobGluZVZpZXcuY2hhbmdlcywgXCJndXR0ZXJcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZTsgfVxuICAgICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtcbiAgICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbGluZVZpZXcubm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XG4gICAgfVxuICAgIHdoaWxlIChjdXIpIHsgY3VyID0gcm0oY3VyKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVyU3BhY2UoZGlzcGxheSkge1xuICAgIHZhciB3aWR0aCA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFwicHhcIjtcbiAgICAvLyBTZW5kIGFuIGV2ZW50IHRvIGNvbnN1bWVycyByZXNwb25kaW5nIHRvIGNoYW5nZXMgaW4gZ3V0dGVyIHdpZHRoLlxuICAgIHNpZ25hbExhdGVyKGRpc3BsYXksIFwiZ3V0dGVyQ2hhbmdlZFwiLCBkaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERvY3VtZW50SGVpZ2h0KGNtLCBtZWFzdXJlKSB7XG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gKG1lYXN1cmUuZG9jSGVpZ2h0ICsgY20uZGlzcGxheS5iYXJIZWlnaHQgKyBzY3JvbGxHYXAoY20pKSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFJlLWFsaWduIGxpbmUgbnVtYmVycyBhbmQgZ3V0dGVyIG1hcmtzIHRvIGNvbXBlbnNhdGUgZm9yXG4gIC8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxuICBmdW5jdGlvbiBhbGlnbkhvcml6b250YWxseShjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlldztcbiAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSB7IHJldHVybiB9XG4gICAgdmFyIGNvbXAgPSBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSAtIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFwicHhcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyKVxuICAgICAgICAgIHsgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZClcbiAgICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0ID0gbGVmdDsgfVxuICAgICAgfVxuICAgICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGU7XG4gICAgICBpZiAoYWxpZ24pIHsgZm9yICh2YXIgaiA9IDA7IGogPCBhbGlnbi5sZW5ndGg7IGorKylcbiAgICAgICAgeyBhbGlnbltqXS5zdHlsZS5sZWZ0ID0gbGVmdDsgfSB9XG4gICAgfSB9XG4gICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpXG4gICAgICB7IGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFwicHhcIjsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxuICAvLyBzaXplIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBzaXplLiBSZXR1cm5zIHRydWUgd2hlbiBhbiB1cGRhdGVcbiAgLy8gaXMgbmVlZGVkLlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkb2MgPSBjbS5kb2MsIGxhc3QgPSBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSksIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xuICAgICAgdmFyIHRlc3QgPSBkaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbGFzdCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiKSk7XG4gICAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyVztcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID0gTWF0aC5tYXgoaW5uZXJXLCBkaXNwbGF5LmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBwYWRkaW5nKSArIDE7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xuICAgICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMTtcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXCJweFwiO1xuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UoY20uZGlzcGxheSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEd1dHRlcnMoZ3V0dGVycywgbGluZU51bWJlcnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIHNhd0xpbmVOdW1iZXJzID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBndXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGd1dHRlcnNbaV0sIHN0eWxlID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSBcInN0cmluZ1wiKSB7IHN0eWxlID0gbmFtZS5zdHlsZTsgbmFtZSA9IG5hbWUuY2xhc3NOYW1lOyB9XG4gICAgICBpZiAobmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIikge1xuICAgICAgICBpZiAoIWxpbmVOdW1iZXJzKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZWxzZSB7IHNhd0xpbmVOdW1iZXJzID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogbmFtZSwgc3R5bGU6IHN0eWxlfSk7XG4gICAgfVxuICAgIGlmIChsaW5lTnVtYmVycyAmJiAhc2F3TGluZU51bWJlcnMpIHsgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIsIHN0eWxlOiBudWxsfSk7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxuICAvLyBjb2RlIG1hdGNoZXMgdGhlaXIgd2lkdGguXG4gIGZ1bmN0aW9uIHJlbmRlckd1dHRlcnMoZGlzcGxheSkge1xuICAgIHZhciBndXR0ZXJzID0gZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGRpc3BsYXkuZ3V0dGVyU3BlY3M7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7XG4gICAgZGlzcGxheS5saW5lR3V0dGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcmVmID0gc3BlY3NbaV07XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlciBcIiArIGNsYXNzTmFtZSkpO1xuICAgICAgaWYgKHN0eWxlKSB7IGdFbHQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgICBpZiAoY2xhc3NOYW1lID09IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKSB7XG4gICAgICAgIGRpc3BsYXkubGluZUd1dHRlciA9IGdFbHQ7XG4gICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IHNwZWNzLmxlbmd0aCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShkaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlcnMoY20pIHtcbiAgICByZW5kZXJHdXR0ZXJzKGNtLmRpc3BsYXkpO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICB9XG5cbiAgLy8gVGhlIGRpc3BsYXkgaGFuZGxlcyB0aGUgRE9NIGludGVncmF0aW9uLCBib3RoIGZvciBpbnB1dCByZWFkaW5nXG4gIC8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxuICAvLyBkaXNwbGF5LXJlbGF0ZWQgc3RhdGUuXG5cbiAgZnVuY3Rpb24gRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkID0gdGhpcztcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cbiAgICBkLnNjcm9sbGJhckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTtcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gQ292ZXJzIGJvdHRvbSBvZiBndXR0ZXIgd2hlbiBjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciBpcyBvblxuICAgIC8vIGFuZCBoIHNjcm9sbGJhciBpcyBwcmVzZW50LlxuICAgIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO1xuICAgIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBjb2RlLCBwb3NpdGlvbmVkIHRvIGNvdmVyIHRoZSB2aWV3cG9ydC5cbiAgICBkLmxpbmVEaXYgPSBlbHRQKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xuICAgIGQuY3Vyc29yRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO1xuICAgIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGQubGluZVNwYWNlID0gZWx0UChcImRpdlwiLCBbZC5tZWFzdXJlLCBkLmxpbmVNZWFzdXJlLCBkLnNlbGVjdGlvbkRpdiwgZC5jdXJzb3JEaXYsIGQubGluZURpdl0sXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcIik7XG4gICAgdmFyIGxpbmVzID0gZWx0UChcImRpdlwiLCBbZC5saW5lU3BhY2VdLCBcIkNvZGVNaXJyb3ItbGluZXNcIik7XG4gICAgLy8gTW92ZWQgYXJvdW5kIGl0cyBwYXJlbnQgdG8gY292ZXIgdmlzaWJsZSB2aWV3LlxuICAgIGQubW92ZXIgPSBlbHQoXCJkaXZcIiwgW2xpbmVzXSwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XG4gICAgLy8gU2V0IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LCBhbGxvd2luZyBzY3JvbGxpbmcuXG4gICAgZC5zaXplciA9IGVsdChcImRpdlwiLCBbZC5tb3Zlcl0sIFwiQ29kZU1pcnJvci1zaXplclwiKTtcbiAgICBkLnNpemVyV2lkdGggPSBudWxsO1xuICAgIC8vIEJlaGF2aW9yIG9mIGVsdHMgd2l0aCBvdmVyZmxvdzogYXV0byBhbmQgcGFkZGluZyBpc1xuICAgIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXG4gICAgLy8gc2Nyb2xsYWJsZSBhcmVhIGlzIGJpZyBlbm91Z2guXG4gICAgZC5oZWlnaHRGb3JjZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXCIgKyBzY3JvbGxlckdhcCArIFwicHg7IHdpZHRoOiAxcHg7XCIpO1xuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxuICAgIGQuZ3V0dGVycyA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyc1wiKTtcbiAgICBkLmxpbmVHdXR0ZXIgPSBudWxsO1xuICAgIC8vIEFjdHVhbCBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gICAgZC5zY3JvbGxlciA9IGVsdChcImRpdlwiLCBbZC5zaXplciwgZC5oZWlnaHRGb3JjZXIsIGQuZ3V0dGVyc10sIFwiQ29kZU1pcnJvci1zY3JvbGxcIik7XG4gICAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpO1xuICAgIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXG4gICAgZC53cmFwcGVyID0gZWx0KFwiZGl2XCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcIkNvZGVNaXJyb3JcIik7XG5cbiAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyByZXNwZWN0ZWQgYnkgYXV0b21hdGljIHRyYW5zbGF0aW9uIHN5c3RlbXMgc3VjaCBhcyBHb29nbGUgVHJhbnNsYXRlLFxuICAgIC8vIGFuZCBtYXkgYWxzbyBiZSByZXNwZWN0ZWQgYnkgdG9vbHMgdXNlZCBieSBodW1hbiB0cmFuc2xhdG9ycy5cbiAgICBkLndyYXBwZXIuc2V0QXR0cmlidXRlKCd0cmFuc2xhdGUnLCAnbm8nKTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7IH1cbiAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG5cbiAgICBpZiAocGxhY2UpIHtcbiAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpOyB9XG4gICAgICBlbHNlIHsgcGxhY2UoZC53cmFwcGVyKTsgfVxuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxuICAgIGQudmlld0Zyb20gPSBkLnZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0O1xuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbiAgICBkLnZpZXcgPSBbXTtcbiAgICBkLnJlbmRlcmVkVmlldyA9IG51bGw7XG4gICAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXG4gICAgLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cbiAgICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XG4gICAgZC52aWV3T2Zmc2V0ID0gMDtcbiAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcbiAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xuICAgIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxuICAgIC8vIHRoaXMgaXMgZmFsc2UuXG4gICAgZC5hbGlnbldpZGdldHMgPSBmYWxzZTtcblxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG5cbiAgICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcbiAgICAvLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXG4gICAgZC5tYXhMaW5lID0gbnVsbDtcbiAgICBkLm1heExpbmVMZW5ndGggPSAwO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcbiAgICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGw7XG5cbiAgICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxuICAgIGQuc2hpZnQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XG4gICAgLy8gd2FzIG9wZW5lZC5cbiAgICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcblxuICAgIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xuXG4gICAgZC5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMob3B0aW9ucy5ndXR0ZXJzLCBvcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICByZW5kZXJHdXR0ZXJzKGQpO1xuXG4gICAgaW5wdXQuaW5pdChkKTtcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxuICAvLyB1bnN0YW5kYXJkaXplZCBiZXR3ZWVuIGJyb3dzZXJzIGFuZCBldmVuIGJyb3dzZXIgdmVyc2lvbnMsIGFuZFxuICAvLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcbiAgLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxuICAvLyBhbmQsIGZyb20gdGhhdCwgZGV0ZWN0cyB0aGUgd2F5IGl0IGNhbiBjb252ZXJ0IGRlbHRhcyB0byBwaXhlbFxuICAvLyBvZmZzZXRzIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gd2Ugd2FudCB0byBrbm93IHRoZSBhbW91bnQgYSB3aGVlbCBldmVudCB3aWxsIHNjcm9sbFxuICAvLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXG4gIC8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cblxuICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcbiAgLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcbiAgLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXG4gIC8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcbiAgLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxuICBpZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MzsgfVxuICBlbHNlIGlmIChnZWNrbykgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAxNTsgfVxuICBlbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43OyB9XG4gIGVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zOyB9XG5cbiAgZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWw7IH1cbiAgICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWw7IH1cbiAgICBlbHNlIGlmIChkeSA9PSBudWxsKSB7IGR5ID0gZS53aGVlbERlbHRhOyB9XG4gICAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XG4gIH1cbiAgZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xuICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnk7XG4gICAgdmFyIHBpeGVsc1BlclVuaXQgPSB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgaWYgKGUuZGVsdGFNb2RlID09PSAwKSB7XG4gICAgICBkeCA9IGUuZGVsdGFYO1xuICAgICAgZHkgPSBlLmRlbHRhWTtcbiAgICAgIHBpeGVsc1BlclVuaXQgPSAxO1xuICAgIH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlcjtcbiAgICAvLyBRdWl0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzY3JvbGwgaGVyZVxuICAgIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoO1xuICAgIHZhciBjYW5TY3JvbGxZID0gc2Nyb2xsLnNjcm9sbEhlaWdodCA+IHNjcm9sbC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCEoZHggJiYgY2FuU2Nyb2xsWCB8fCBkeSAmJiBjYW5TY3JvbGxZKSkgeyByZXR1cm4gfVxuXG4gICAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcbiAgICAvLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXG4gICAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cbiAgICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xuICAgICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodmlld1tpXS5ub2RlID09IGN1cikge1xuICAgICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXI7XG4gICAgICAgICAgICBicmVhayBvdXRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xuICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cbiAgICAvLyB3cmlnZ2xlIGFyb3VuZCBpbiBhIG1vc3QgdW5zZWVtbHkgd2F5LiBXaGVuIHdlIGhhdmUgYW5cbiAgICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXG4gICAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XG4gICAgLy8gYmV0dGVyIHRoYW4gZ2xpdGNoaW5nIG91dC5cbiAgICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgcGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICBpZiAoZHkgJiYgY2FuU2Nyb2xsWSlcbiAgICAgICAgeyB1cGRhdGVTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHBpeGVsc1BlclVuaXQpKTsgfVxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5tYXgoMCwgc2Nyb2xsLnNjcm9sbExlZnQgKyBkeCAqIHBpeGVsc1BlclVuaXQpKTtcbiAgICAgIC8vIE9ubHkgcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBpZiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXNcbiAgICAgIC8vIGFjdHVhbGx5IHBvc3NpYmxlLiBPdGhlcndpc2UsIGl0IGNhdXNlcyB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcbiAgICAgIC8vIGlzIGxhcmdlIChpc3N1ZSAjMzU3OSlcbiAgICAgIGlmICghZHkgfHwgKGR5ICYmIGNhblNjcm9sbFkpKVxuICAgICAgICB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBudWxsOyAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vICdQcm9qZWN0JyB0aGUgdmlzaWJsZSB2aWV3cG9ydCB0byBjb3ZlciB0aGUgYXJlYSB0aGF0IGlzIGJlaW5nXG4gICAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXG4gICAgaWYgKGR5ICYmIHBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgdmFyIHBpeGVscyA9IGR5ICogcGl4ZWxzUGVyVW5pdDtcbiAgICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKHBpeGVscyA8IDApIHsgdG9wID0gTWF0aC5tYXgoMCwgdG9wICsgcGl4ZWxzIC0gNTApOyB9XG4gICAgICBlbHNlIHsgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApOyB9XG4gICAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSk7XG4gICAgfVxuXG4gICAgaWYgKHdoZWVsU2FtcGxlcyA8IDIwICYmIGUuZGVsdGFNb2RlICE9PSAwKSB7XG4gICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBzY3JvbGwuc2Nyb2xsTGVmdDsgZGlzcGxheS53aGVlbFN0YXJ0WSA9IHNjcm9sbC5zY3JvbGxUb3A7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIHZhciBtb3ZlZFggPSBzY3JvbGwuc2Nyb2xsTGVmdCAtIGRpc3BsYXkud2hlZWxTdGFydFg7XG4gICAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZO1xuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XG4gICAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpO1xuICAgICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgeyByZXR1cm4gfVxuICAgICAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9ICh3aGVlbFBpeGVsc1BlclVuaXQgKiB3aGVlbFNhbXBsZXMgKyBzYW1wbGUpIC8gKHdoZWVsU2FtcGxlcyArIDEpO1xuICAgICAgICAgICsrd2hlZWxTYW1wbGVzO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuICAvLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbiAgdmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5wcmltYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG90aGVyLnByaW1JbmRleCAhPSB0aGlzLnByaW1JbmRleCB8fCBvdGhlci5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZXJlID0gdGhpcy5yYW5nZXNbaV0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2ldO1xuICAgICAgaWYgKCFlcXVhbEN1cnNvclBvcyhoZXJlLmFuY2hvciwgdGhlcmUuYW5jaG9yKSB8fCAhZXF1YWxDdXJzb3JQb3MoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleClcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLnNvbWV0aGluZ1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmICghdGhpcy5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHBvcywgZW5kKSB7XG4gICAgaWYgKCFlbmQpIHsgZW5kID0gcG9zOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XG4gICAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXG4gICAgICAgIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfTtcblxuICB2YXIgUmFuZ2UgPSBmdW5jdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjsgdGhpcy5oZWFkID0gaGVhZDtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xuICBSYW5nZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfTtcbiAgUmFuZ2UucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oZWFkLmxpbmUgPT0gdGhpcy5hbmNob3IubGluZSAmJiB0aGlzLmhlYWQuY2ggPT0gdGhpcy5hbmNob3IuY2ggfTtcblxuICAvLyBUYWtlIGFuIHVuc29ydGVkLCBwb3RlbnRpYWxseSBvdmVybGFwcGluZyBzZXQgb2YgcmFuZ2VzLCBhbmRcbiAgLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXG4gIC8vIGl0KS5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHZhciBtYXlUb3VjaCA9IGNtICYmIGNtLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO1xuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KTtcbiAgICBwcmltSW5kZXggPSBpbmRleE9mKHJhbmdlcywgcHJpbSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xuICAgICAgdmFyIGRpZmYgPSBjbXAocHJldi50bygpLCBjdXIuZnJvbSgpKTtcbiAgICAgIGlmIChtYXlUb3VjaCAmJiAhY3VyLmVtcHR5KCkgPyBkaWZmID4gMCA6IGRpZmYgPj0gMCkge1xuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZDtcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSB7IC0tcHJpbUluZGV4OyB9XG4gICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpXG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGEgY2hhbmdlIChpdHMgJ3RvJyBwcm9wZXJ0eVxuICAvLyByZWZlcnMgdG8gdGhlIHByZS1jaGFuZ2UgZW5kKS5cbiAgZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xuICAgIGlmICghY2hhbmdlLnRleHQpIHsgcmV0dXJuIGNoYW5nZS50byB9XG4gICAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSlcbiAgfVxuXG4gIC8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcbiAgLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXG4gIGZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSB7IHJldHVybiBwb3MgfVxuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UudG8pIDw9IDApIHsgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpIH1cblxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoO1xuICAgIGlmIChwb3MubGluZSA9PSBjaGFuZ2UudG8ubGluZSkgeyBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDsgfVxuICAgIHJldHVybiBQb3MobGluZSwgY2gpXG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvciwgY2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldFBvcyhwb3MsIG9sZCwgbncpIHtcbiAgICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XG4gIH1cblxuICAvLyBVc2VkIGJ5IHJlcGxhY2VTZWxlY3Rpb25zIHRvIGFsbG93IG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAvLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFwic3RhcnRcIiBvciBcImFyb3VuZFwiLlxuICBmdW5jdGlvbiBjb21wdXRlUmVwbGFjZWRTZWwoZG9jLCBjaGFuZ2VzLCBoaW50KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBvbGRQcmV2ID0gUG9zKGRvYy5maXJzdCwgMCksIG5ld1ByZXYgPSBvbGRQcmV2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICB2YXIgdG8gPSBvZmZzZXRQb3MoY2hhbmdlRW5kKGNoYW5nZSksIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgb2xkUHJldiA9IGNoYW5nZS50bztcbiAgICAgIG5ld1ByZXYgPSB0bztcbiAgICAgIGlmIChoaW50ID09IFwiYXJvdW5kXCIpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV0sIGludiA9IGNtcChyYW5nZS5oZWFkLCByYW5nZS5hbmNob3IpIDwgMDtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShmcm9tLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cblxuICBmdW5jdGlvbiBsb2FkTW9kZShjbSkge1xuICAgIGNtLmRvYy5tb2RlID0gZ2V0TW9kZShjbS5vcHRpb25zLCBjbS5kb2MubW9kZU9wdGlvbik7XG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcbiAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgfSk7XG4gICAgY20uZG9jLm1vZGVGcm9udGllciA9IGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA9IGNtLmRvYy5maXJzdDtcbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgICBjbS5zdGF0ZS5tb2RlR2VuKys7XG4gICAgaWYgKGNtLmN1ck9wKSB7IHJlZ0NoYW5nZShjbSk7IH1cbiAgfVxuXG4gIC8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gQnkgZGVmYXVsdCwgdXBkYXRlcyB0aGF0IHN0YXJ0IGFuZCBlbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcbiAgLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXG4gIC8vIHdpZGdldHMgYW5kIG1hcmtlciBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IGJlaGF2ZSBtb3JlIGludHVpdGl2ZS5cbiAgZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gY2hhbmdlLmZyb20uY2ggPT0gMCAmJiBjaGFuZ2UudG8uY2ggPT0gMCAmJiBsc3QoY2hhbmdlLnRleHQpID09IFwiXCIgJiZcbiAgICAgICghZG9jLmNtIHx8IGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSlcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGx9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XG4gICAgICBzaWduYWxMYXRlcihsaW5lLCBcImNoYW5nZVwiLCBsaW5lLCBjaGFuZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSlcbiAgICAgICAgeyByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKTsgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHZhciBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvLCB0ZXh0ID0gY2hhbmdlLnRleHQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcbiAgICB2YXIgbGFzdFRleHQgPSBsc3QodGV4dCksIGxhc3RTcGFucyA9IHNwYW5zRm9yKHRleHQubGVuZ3RoIC0gMSksIG5saW5lcyA9IHRvLmxpbmUgLSBmcm9tLmxpbmU7XG5cbiAgICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7XG4gICAgICBkb2MuaW5zZXJ0KDAsIGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoKSk7XG4gICAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxuICAgICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxuICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdExpbmUudGV4dCwgbGFzdFNwYW5zKTtcbiAgICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcyk7IH1cbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIHsgZG9jLmluc2VydChmcm9tLmxpbmUsIGFkZGVkKTsgfVxuICAgIH0gZWxzZSBpZiAoZmlyc3RMaW5lID09IGxhc3RMaW5lKSB7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICBhZGRlZCQxLnB1c2gobmV3IExpbmUobGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucywgZXN0aW1hdGVIZWlnaHQpKTtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0gKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgc3BhbnNGb3IoMCkpO1xuICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdFRleHQgKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgIHZhciBhZGRlZCQyID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7IH1cbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMik7XG4gICAgfVxuXG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcImNoYW5nZVwiLCBkb2MsIGNoYW5nZSk7XG4gIH1cblxuICAvLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGUoZG9jLCBza2lwLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoZG9jLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV07XG4gICAgICAgIGlmIChyZWwuZG9jID09IHNraXApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdDtcbiAgICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIHsgY29udGludWUgfVxuICAgICAgICBmKHJlbC5kb2MsIHNoYXJlZCk7XG4gICAgICAgIHByb3BhZ2F0ZShyZWwuZG9jLCBkb2MsIHNoYXJlZCk7XG4gICAgICB9IH1cbiAgICB9XG4gICAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXG4gIGZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XG4gICAgaWYgKGRvYy5jbSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKSB9XG4gICAgY20uZG9jID0gZG9jO1xuICAgIGRvYy5jbSA9IGNtO1xuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIGxvYWRNb2RlKGNtKTtcbiAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgY20ub3B0aW9ucy5kaXJlY3Rpb24gPSBkb2MuZGlyZWN0aW9uO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZmluZE1heExpbmUoY20pOyB9XG4gICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERpcmVjdGlvbkNsYXNzKGNtKSB7XG4gIChjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIgPyBhZGRDbGFzcyA6IHJtQ2xhc3MpKGNtLmRpc3BsYXkubGluZURpdiwgXCJDb2RlTWlycm9yLXJ0bFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpcmVjdGlvbkNoYW5nZWQoY20pIHtcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gSGlzdG9yeShwcmV2KSB7XG4gICAgLy8gQXJyYXlzIG9mIGNoYW5nZSBldmVudHMgYW5kIHNlbGVjdGlvbnMuIERvaW5nIHNvbWV0aGluZyBhZGRzIGFuXG4gICAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxuICAgIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gICAgdGhpcy5kb25lID0gW107IHRoaXMudW5kb25lID0gW107XG4gICAgdGhpcy51bmRvRGVwdGggPSBwcmV2ID8gcHJldi51bmRvRGVwdGggOiBJbmZpbml0eTtcbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZW4gY2hhbmdlcyBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUgdW5kb1xuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xuICAgIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsO1xuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHByZXYgPyBwcmV2Lm1heEdlbmVyYXRpb24gOiAxO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXG4gIC8vIG9iamVjdC5cbiAgZnVuY3Rpb24gaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9O1xuICAgIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO1xuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTsgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGhpc3RDaGFuZ2VcbiAgfVxuXG4gIC8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcbiAgLy8gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xuICAgICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHRvcCBjaGFuZ2UgZXZlbnQgaW4gdGhlIGhpc3RvcnkuIFBvcCBvZmYgc2VsZWN0aW9uXG4gIC8vIGV2ZW50cyB0aGF0IGFyZSBpbiB0aGUgd2F5LlxuICBmdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QuZG9uZSk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoID4gMSAmJiAhaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAyXS5yYW5nZXMpIHtcbiAgICAgIGhpc3QuZG9uZS5wb3AoKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cbiAgLy8gYSBzaW5nbGUgb3BlcmF0aW9uLCBvciBhcmUgY2xvc2UgdG9nZXRoZXIgd2l0aCBhbiBvcmlnaW4gdGhhdFxuICAvLyBhbGxvd3MgbWVyZ2luZyAoc3RhcnRpbmcgd2l0aCBcIitcIikgaW50byBhIHNpbmdsZSBldmVudC5cbiAgZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgb3BJZCkge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XG4gICAgaGlzdC51bmRvbmUubGVuZ3RoID0gMDtcbiAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSwgY3VyO1xuICAgIHZhciBsYXN0O1xuXG4gICAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XG4gICAgICAgICBoaXN0Lmxhc3RPcmlnaW4gPT0gY2hhbmdlLm9yaWdpbiAmJiBjaGFuZ2Uub3JpZ2luICYmXG4gICAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiK1wiICYmIGhpc3QubGFzdE1vZFRpbWUgPiB0aW1lIC0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKSkgfHxcbiAgICAgICAgICBjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcIipcIikpICYmXG4gICAgICAgIChjdXIgPSBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgaGlzdC5sYXN0T3AgPT0gb3BJZCkpKSB7XG4gICAgICAvLyBNZXJnZSB0aGlzIGNoYW5nZSBpbnRvIHRoZSBsYXN0IGV2ZW50XG4gICAgICBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKTtcbiAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcbiAgICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcbiAgICAgICAgLy8gbmV3IGNoYW5nZXNldHMgZm9yIGV2ZXJ5IGNoYXJhY3RlciB0eXBlZFxuICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbmV3IHN1Yi1ldmVudFxuICAgICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cbiAgICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKTtcbiAgICAgIGlmICghYmVmb3JlIHx8ICFiZWZvcmUucmFuZ2VzKVxuICAgICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKTsgfVxuICAgICAgY3VyID0ge2NoYW5nZXM6IFtoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSldLFxuICAgICAgICAgICAgIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn07XG4gICAgICBoaXN0LmRvbmUucHVzaChjdXIpO1xuICAgICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xuICAgICAgICBoaXN0LmRvbmUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGhpc3QuZG9uZS5wdXNoKHNlbEFmdGVyKTtcbiAgICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvbjtcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XG4gICAgaGlzdC5sYXN0T3AgPSBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpbjtcblxuICAgIGlmICghbGFzdCkgeyBzaWduYWwoZG9jLCBcImhpc3RvcnlBZGRlZFwiKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gY2ggPT0gXCIqXCIgfHxcbiAgICAgIGNoID09IFwiK1wiICYmXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApXG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBzZXRzIHRoZSBuZXcgc2VsZWN0aW9uIGFzXG4gIC8vIHRoZSBwZW5kaW5nIHNlbGVjdGlvbiBpbiB0aGUgaGlzdG9yeSwgYW5kIHB1c2hlcyB0aGUgb2xkIHBlbmRpbmdcbiAgLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XG4gIC8vIGRpZmZlcmVudCAoaW4gbnVtYmVyIG9mIHNlbGVjdGVkIHJhbmdlcywgZW1wdGluZXNzLCBvciB0aW1lKS5cbiAgZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgb3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbjtcblxuICAgIC8vIEEgbmV3IGV2ZW50IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb3JpZ2luIGRvZXMgbm90IG1hdGNoXG4gICAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXG4gICAgLy8gc3RhcnRpbmcgd2l0aCAqIGFyZSBhbHdheXMgbWVyZ2VkLCB0aG9zZSBzdGFydGluZyB3aXRoICsgYXJlXG4gICAgLy8gbWVyZ2VkIHdoZW4gc2ltaWxhciBhbmQgY2xvc2UgdG9nZXRoZXIgaW4gdGltZS5cbiAgICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxuICAgICAgICAob3JpZ2luICYmIGhpc3QubGFzdFNlbE9yaWdpbiA9PSBvcmlnaW4gJiZcbiAgICAgICAgIChoaXN0Lmxhc3RNb2RUaW1lID09IGhpc3QubGFzdFNlbFRpbWUgJiYgaGlzdC5sYXN0T3JpZ2luID09IG9yaWdpbiB8fFxuICAgICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXG4gICAgICB7IGhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMV0gPSBzZWw7IH1cbiAgICBlbHNlXG4gICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpOyB9XG5cbiAgICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlO1xuICAgIGhpc3QubGFzdFNlbE9yaWdpbiA9IG9yaWdpbjtcbiAgICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxuICAgICAgeyBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XG4gICAgdmFyIHRvcCA9IGxzdChkZXN0KTtcbiAgICBpZiAoISh0b3AgJiYgdG9wLnJhbmdlcyAmJiB0b3AuZXF1YWxzKHNlbCkpKVxuICAgICAgeyBkZXN0LnB1c2goc2VsKTsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucylcbiAgICAgICAgeyAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7IH1cbiAgICAgICsrbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcbiAgLy8gdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBjbGVhcmVkIHNob3VsZCBub3QgYmUgcmVzdG9yZWQuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCkgeyBpZiAoIW91dCkgeyBvdXQgPSBzcGFucy5zbGljZSgwLCBpKTsgfSB9XG4gICAgICBlbHNlIGlmIChvdXQpIHsgb3V0LnB1c2goc3BhbnNbaV0pOyB9XG4gICAgfVxuICAgIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxuICB9XG5cbiAgLy8gUmV0cmlldmUgYW5kIGZpbHRlciB0aGUgb2xkIG1hcmtlZCBzcGFucyBzdG9yZWQgaW4gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgIGlmICghZm91bmQpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBudyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXG4gICAgICB7IG53LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSk7IH1cbiAgICByZXR1cm4gbndcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHVuL3JlLWRvaW5nIGNoYW5nZXMgZnJvbSB0aGUgaGlzdG9yeS4gQ29tYmluZXMgdGhlXG4gIC8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxuICAvLyB1bmRvaW5nIGJyaW5ncyBiYWNrIHRoZSBzcGFuKS5cbiAgZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XG4gICAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGlmICghb2xkKSB7IHJldHVybiBzdHJldGNoZWQgfVxuICAgIGlmICghc3RyZXRjaGVkKSB7IHJldHVybiBvbGQgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XG4gICAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgc3BhbnM6IGZvciAodmFyIGogPSAwOyBqIDwgc3RyZXRjaEN1ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraylcbiAgICAgICAgICAgIHsgaWYgKG9sZEN1cltrXS5tYXJrZXIgPT0gc3Bhbi5tYXJrZXIpIHsgY29udGludWUgc3BhbnMgfSB9XG4gICAgICAgICAgb2xkQ3VyLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xuICAgICAgICBvbGRbaV0gPSBzdHJldGNoQ3VyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkXG4gIH1cblxuICAvLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxuICAvLyBkZXRhY2hpbmcgYSBkb2N1bWVudCwgdG8gc3BsaXQgdGhlIGhpc3RvcnkgaW4gdHdvXG4gIGZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcbiAgICB2YXIgY29weSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIGNvcHkucHVzaChpbnN0YW50aWF0ZVNlbCA/IFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChldmVudCkgOiBldmVudCk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtID0gKHZvaWQgMCk7XG4gICAgICAgIG5ld0NoYW5nZXMucHVzaCh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2UudG8sIHRleHQ6IGNoYW5nZS50ZXh0fSk7XG4gICAgICAgIGlmIChuZXdHcm91cCkgeyBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgeyBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfVxuXG4gIC8vIFRoZSAnc2Nyb2xsJyBwYXJhbWV0ZXIgZ2l2ZW4gdG8gbWFueSBvZiB0aGVzZSBpbmRpY2F0ZWQgd2hldGhlclxuICAvLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXG4gIC8vIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLlxuXG4gIC8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXG4gIC8vIGluY2x1ZGUgYSBnaXZlbiBwb3NpdGlvbiAoYW5kIG9wdGlvbmFsbHkgYSBzZWNvbmQgcG9zaXRpb24pLlxuICAvLyBPdGhlcndpc2UsIHNpbXBseSByZXR1cm5zIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gIC8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXG4gIGZ1bmN0aW9uIGV4dGVuZFJhbmdlKHJhbmdlLCBoZWFkLCBvdGhlciwgZXh0ZW5kKSB7XG4gICAgaWYgKGV4dGVuZCkge1xuICAgICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcjtcbiAgICAgIGlmIChvdGhlcikge1xuICAgICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xuICAgICAgICBpZiAocG9zQmVmb3JlICE9IChjbXAob3RoZXIsIGFuY2hvcikgPCAwKSkge1xuICAgICAgICAgIGFuY2hvciA9IGhlYWQ7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc0JlZm9yZSAhPSAoY21wKGhlYWQsIG90aGVyKSA8IDApKSB7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zLCBleHRlbmQpIHtcbiAgICBpZiAoZXh0ZW5kID09IG51bGwpIHsgZXh0ZW5kID0gZG9jLmNtICYmIChkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKTsgfVxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYy5zZWwucHJpbWFyeSgpLCBoZWFkLCBvdGhlciwgZXh0ZW5kKV0sIDApLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcbiAgLy8gZXF1YWwgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zKVxuICBmdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYywgaGVhZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLnNlbC5yYW5nZXNbaV0sIGhlYWRzW2ldLCBudWxsLCBleHRlbmQpOyB9XG4gICAgdmFyIG5ld1NlbCA9IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciByYW5nZXMgPSBkb2Muc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICByYW5nZXNbaV0gPSByYW5nZTtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCByYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyB0aGlzLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5oZWFkKSk7IH1cbiAgICAgIH0sXG4gICAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cbiAgICB9O1xuICAgIHNpZ25hbChkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYywgb2JqKTtcbiAgICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTsgfVxuICAgIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHsgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSkgfVxuICAgIGVsc2UgeyByZXR1cm4gc2VsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvbmUgPSBkb2MuaGlzdG9yeS5kb25lLCBsYXN0ID0gbHN0KGRvbmUpO1xuICAgIGlmIChsYXN0ICYmIGxhc3QucmFuZ2VzKSB7XG4gICAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XG4gICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBhIG5ldyBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgZG9jLnNlbCwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSlcbiAgICAgIHsgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKTsgfVxuXG4gICAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxuICAgICAgKGNtcChzZWwucHJpbWFyeSgpLmhlYWQsIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQpIDwgMCA/IC0xIDogMSk7XG4gICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIHRydWUpKTtcblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JvbGwgPT09IGZhbHNlKSAmJiBkb2MuY20gJiYgZG9jLmNtLmdldE9wdGlvbihcInJlYWRPbmx5XCIpICE9IFwibm9jdXJzb3JcIilcbiAgICAgIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSB7IHJldHVybiB9XG5cbiAgICBkb2Muc2VsID0gc2VsO1xuXG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMTtcbiAgICAgIGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gcmFuZ2VzLlxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICB2YXIgbmV3SGVhZCA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gc2VsLnJhbmdlcy5zbGljZSgwLCBpKTsgfVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UobmV3QW5jaG9yLCBuZXdIZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dCA/IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlcjtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBwcmV2ZW50IHRoZSBjdXJzb3IgYmVpbmcgcGxhY2VkIHRvIHRoZSBsZWZ0L3JpZ2h0IG9mIGFuIGF0b21pYyBtYXJrZXJcbiAgICAgIC8vIEhpc3RvcmljYWxseSB0aGlzIHdhcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSBpbmNsdXNpdmVMZWZ0L1JpZ2h0IG9wdGlvbiwgYnV0IHRoZSBuZXcgd2F5IHRvIGNvbnRyb2wgaXRcbiAgICAgIC8vIGlzIHdpdGggc2VsZWN0TGVmdC9SaWdodFxuICAgICAgdmFyIHByZXZlbnRDdXJzb3JMZWZ0ID0gKFwic2VsZWN0TGVmdFwiIGluIG0pID8gIW0uc2VsZWN0TGVmdCA6IG0uaW5jbHVzaXZlTGVmdDtcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yUmlnaHQgPSAoXCJzZWxlY3RSaWdodFwiIGluIG0pID8gIW0uc2VsZWN0UmlnaHQgOiBtLmluY2x1c2l2ZVJpZ2h0O1xuXG4gICAgICBpZiAoKHNwLmZyb20gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvckxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XG4gICAgICAgIGlmIChtYXlDbGVhcikge1xuICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxuICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtLmF0b21pYykgeyBjb250aW51ZSB9XG5cbiAgICAgICAgaWYgKG9sZFBvcykge1xuICAgICAgICAgIHZhciBuZWFyID0gbS5maW5kKGRpciA8IDAgPyAxIDogLTEpLCBkaWZmID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yUmlnaHQgOiBwcmV2ZW50Q3Vyc29yTGVmdClcbiAgICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKVxuICAgICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFyID0gbS5maW5kKGRpciA8IDAgPyAtMSA6IDEpO1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHByZXZlbnRDdXJzb3JMZWZ0IDogcHJldmVudEN1cnNvclJpZ2h0KVxuICAgICAgICAgIHsgZmFyID0gbW92ZVBvcyhkb2MsIGZhciwgZGlyLCBmYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxuICBmdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCB0cnVlKSkgfHxcbiAgICAgICAgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIG1heUNsZWFyKSB8fFxuICAgICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSk7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKVxuICAgIH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVQb3MoZG9jLCBwb3MsIGRpciwgbGluZSkge1xuICAgIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxuICAgICAgZWxzZSB7IHJldHVybiBudWxsIH1cbiAgICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XG4gICAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gVVBEQVRJTkdcblxuICAvLyBBbGxvdyBcImJlZm9yZUNoYW5nZVwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcbiAgICAgIHRvOiBjaGFuZ2UudG8sXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqLmNhbmNlbGVkID0gdHJ1ZTsgfVxuICAgIH07XG4gICAgaWYgKHVwZGF0ZSkgeyBvYmoudXBkYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcbiAgICAgIGlmIChmcm9tKSB7IG9iai5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pOyB9XG4gICAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKTsgfVxuICAgICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0OyB9XG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHsgb2JqLm9yaWdpbiA9IG9yaWdpbjsgfVxuICAgIH07IH1cbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cblxuICAgIGlmIChvYmouY2FuY2VsZWQpIHtcbiAgICAgIGlmIChkb2MuY20pIHsgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMjsgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cbiAgfVxuXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcbiAgLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKSkge1xuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcbiAgICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHsgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcIlwiXSA6IGNoYW5nZS50ZXh0LCBvcmlnaW46IGNoYW5nZS5vcmlnaW59KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICByZWJhc2VIaXN0KGRvYy5oaXN0b3J5LCBjaGFuZ2UpO1xuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgfVxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XG4gICAgdmFyIHN1cHByZXNzID0gZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO1xuICAgIGlmIChzdXBwcmVzcyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XG5cbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgIHZhciBzb3VyY2UgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmU7XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XG4gICAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgZXZlbnQgPSBzb3VyY2VbaV07XG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxuICAgICAgICB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGw7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XG4gICAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN1cHByZXNzKSB7XG4gICAgICAgIHNvdXJjZS5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XG4gICAgLy8gc3RhY2sgKHJlZG8gd2hlbiB1bmRvaW5nLCBhbmQgdmljZSB2ZXJzYSkuXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XG4gICAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSk7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcblxuICAgIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4ge31cbiAgICAgIH1cblxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIGlmICghaSAmJiBkb2MuY20pIHsgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7IH1cbiAgICAgIHZhciByZWJhc2VkID0gW107XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0byB0aGUgbGlua2VkIGRvY3VtZW50c1xuICAgICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpJDEgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyAtLWkkMSkge1xuICAgICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XG5cbiAgICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgICB9XG4gIH1cblxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcbiAgLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XG4gICAgaWYgKGRpc3RhbmNlID09IDApIHsgcmV0dXJuIH1cbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxuICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxuICAgICk7IH0pLCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcbiAgLy8gKG5vdCBsaW5rZWQgb25lcykuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcbiAgICAgIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIH1cblxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgc2hpZnREb2MoZG9jLCBzaGlmdCk7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XG4gICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgY2hhbmdlID0ge2Zyb206IGNoYW5nZS5mcm9tLCB0bzogUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG5cbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcblxuICAgIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpOyB9XG4gICAgaWYgKGRvYy5jbSkgeyBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICBpZiAoZG9jLmNhbnRFZGl0ICYmIHNraXBBdG9taWMoZG9jLCBQb3MoZG9jLmZpcnN0TGluZSgpLCAwKSkpXG4gICAgICB7IGRvYy5jYW50RWRpdCA9IGZhbHNlOyB9XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGludGVyYWN0aW9uIG9mIGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgZWRpdG9yXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bztcblxuICAgIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXG4gICAgICB7IHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTsgfVxuXG4gICAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKTtcblxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIHsgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICByZXRyZWF0RnJvbnRpZXIoZG9jLCBmcm9tLmxpbmUpO1xuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XG4gICAgaWYgKGNoYW5nZS5mdWxsKVxuICAgICAgeyByZWdDaGFuZ2UoY20pOyB9XG4gICAgZWxzZSBpZiAoZnJvbS5saW5lID09IHRvLmxpbmUgJiYgY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgIWlzV2hvbGVMaW5lVXBkYXRlKGNtLmRvYywgY2hhbmdlKSlcbiAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7IH1cblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFwiY2hhbmdlXCIsIGNtLCBvYmopOyB9XG4gICAgICBpZiAoY2hhbmdlc0hhbmRsZXIpIHsgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTsgfVxuICAgIH1cbiAgICBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICB2YXIgYXNzaWduO1xuXG4gICAgaWYgKCF0bykgeyB0byA9IGZyb207IH1cbiAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgKGFzc2lnbiA9IFt0bywgZnJvbV0sIGZyb20gPSBhc3NpZ25bMF0sIHRvID0gYXNzaWduWzFdKTsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSB7IGNvZGUgPSBkb2Muc3BsaXRMaW5lcyhjb2RlKTsgfVxuICAgIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xuICB9XG5cbiAgLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XG4gICAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lID0gZnJvbTtcbiAgICAgIHBvcy5jaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXG4gIC8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXG4gIC8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXG4gIC8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cbiAgLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcbiAgLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlO1xuICAgICAgaWYgKHN1Yi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuY29waWVkKSB7IHN1YiA9IGFycmF5W2ldID0gc3ViLmRlZXBDb3B5KCk7IHN1Yi5jb3BpZWQgPSB0cnVlOyB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBzdWIuY2hhbmdlcy5sZW5ndGg7ICsraiQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdChoaXN0LCBjaGFuZ2UpIHtcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XG4gICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXG4gIC8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXG4gIC8vIGNoYW5nZWQuXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XG4gICAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpOyB9XG4gICAgZWxzZSB7IG5vID0gbGluZU5vKGhhbmRsZSk7IH1cbiAgICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxuICAvLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXG4gIC8vXG4gIC8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XG4gIC8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXG5cbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgICAgdGhpcy5oZWlnaHQgLT0gbGluZS5oZWlnaHQ7XG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xuICAgICAgICBzaWduYWxMYXRlcihsaW5lLCBcImRlbGV0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcbiAgICB9LFxuXG4gICAgLy8gSGVscGVyIHVzZWQgdG8gY29sbGFwc2UgYSBzbWFsbCBicmFuY2ggaW50byBhIHNpbmdsZSBsZWFmLlxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgfSxcblxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcbiAgICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7IH1cbiAgICB9LFxuXG4gICAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcbiAgICAgICAgeyBpZiAob3AodGhpcy5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xuICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBCcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZSB9LFxuXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICB0aGlzLnNpemUgLT0gbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciBybSA9IE1hdGgubWluKG4sIHN6IC0gYXQpLCBvbGRIZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKTtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgaWYgKHN6ID09IHJtKSB7IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXG4gICAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgeyB0aGlzLmNoaWxkcmVuW2ldLmNvbGxhcHNlKGxpbmVzKTsgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDw9IHN6KSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0SW5uZXIoYXQsIGxpbmVzLCBoZWlnaHQpO1xuICAgICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNTtcbiAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKTtcbiAgICAgICAgICAgICAgY2hpbGQuaGVpZ2h0IC09IGxlYWYuaGVpZ2h0O1xuICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2ksIDAsIGxlYWYpO1xuICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3BpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBhdCAtPSBzejtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cbiAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xuICAgICAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvcHkucGFyZW50ID0gbWU7XG4gICAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XG4gICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKVxuICAgICAgbWUucGFyZW50Lm1heWJlU3BpbGwoKTtcbiAgICB9LFxuXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxuXG4gIHZhciBMaW5lV2lkZ2V0ID0gZnVuY3Rpb24oZG9jLCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdOyB9IH0gfVxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIHsgaWYgKHdzW2ldID09IHRoaXMpIHsgd3Muc3BsaWNlKGktLSwgMSk7IH0gfVxuICAgIGlmICghd3MubGVuZ3RoKSB7IGxpbmUud2lkZ2V0cyA9IG51bGw7IH1cbiAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpO1xuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodCk7XG4gICAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcIndpZGdldFwiKTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENsZWFyZWRcIiwgY20sIHRoaXMsIG5vKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xuICAgIGlmICghZGlmZikgeyByZXR1cm4gfVxuICAgIGlmICghbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZik7IH1cbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENoYW5nZWRcIiwgY20sIHRoaXMkMSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcblxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XG4gICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcbiAgICAgIHsgYWRkVG9TY3JvbGxUb3AoY20sIGRpZmYpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucyk7XG4gICAgdmFyIGNtID0gZG9jLmNtO1xuICAgIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTsgfVxuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pO1xuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB7IHdpZGdldHMucHVzaCh3aWRnZXQpOyB9XG4gICAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGgsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpOyB9XG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XG4gICAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wO1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xuICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7IGFkZFRvU2Nyb2xsVG9wKGNtLCB3aWRnZXQuaGVpZ2h0KTsgfVxuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXCJsaW5lV2lkZ2V0QWRkZWRcIiwgY20sIHdpZGdldCwgdHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiID8gaGFuZGxlIDogbGluZU5vKGhhbmRsZSkpOyB9XG4gICAgcmV0dXJuIHdpZGdldFxuICB9XG5cbiAgLy8gVEVYVE1BUktFUlNcblxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4gIC8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4gIC8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuICAvLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXG5cbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXG4gIC8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XG5cbiAgdmFyIFRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmlkID0gKytuZXh0TWFya2VySWQ7XG4gIH07XG5cbiAgLy8gQ2xlYXIgdGhlIG1hcmtlci5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpIHsgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiLCBmb3VuZC5mcm9tLCBmb3VuZC50byk7IH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObyhsaW5lKSwgXCJ0ZXh0XCIpOyB9XG4gICAgICBlbHNlIGlmIChjbSkge1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHsgbWluID0gbGluZU5vKGxpbmUpOyB9XG4gICAgICB9XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcbiAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSAmJiBjbSlcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpOyB9XG4gICAgfVxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZSh0aGlzLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbDtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IH1cblxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgeyByZWdDaGFuZ2UoY20sIG1pbiwgbWF4ICsgMSk7IH1cbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0KSB7XG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xuICAgICAgaWYgKGNtKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgIH1cbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcywgbWluLCBtYXgpOyB9XG4gICAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7IHRoaXMucGFyZW50LmNsZWFyKCk7IH1cbiAgfTtcblxuICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxuICAvLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxuICAvLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxuICAvLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcImJvb2ttYXJrXCIpIHsgc2lkZSA9IDE7IH1cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxuICAgICAgfVxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xuICAgICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XG4gICAgICAgIGlmIChzaWRlID09IDEpIHsgcmV0dXJuIHRvIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb20gJiYge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfTtcblxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4gIC8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcbiAgICBpZiAoIXBvcyB8fCAhY20pIHsgcmV0dXJuIH1cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGRIZWlnaHQpXG4gICAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7IH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNoYW5nZWRcIiwgY20sIHRoaXMkMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXG4gICAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTsgfVxuICAgIH1cbiAgICB0aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLCBsaW5lKSwgMSk7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcbiAgICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgfVxuICB9O1xuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xuXG4gIC8vIENyZWF0ZSBhIG1hcmtlciwgd2lyZSBpdCB1cCB0byB0aGUgcmlnaHQgbGluZXMsIGFuZFxuICBmdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gKG1hcmtUZXh0U2hhcmVkIHdpbGwgY2FsbCBvdXQgdG8gdGhpcyBhZ2Fpbiwgb25jZSBwZXJcbiAgICAvLyBkb2N1bWVudCkuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHsgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIH1cbiAgICAvLyBFbnN1cmUgd2UgYXJlIGluIGFuIG9wZXJhdGlvbi5cbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG5cbiAgICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKG9wdGlvbnMpIHsgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTsgfVxuICAgIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBtYXJrZXIgfVxuICAgIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHRQKFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpIH1cbiAgICAgIHNlZUNvbGxhcHNlZFNwYW5zKCk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlci5hZGRUb0hpc3RvcnkpXG4gICAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTsgfVxuXG4gICAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lO1xuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApOyB9XG4gICAgICBhZGRNYXJrZWRTcGFuKGxpbmUsIG5ldyBNYXJrZWRTcGFuKG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSwgZG9jLmNtICYmIGRvYy5jbS5jdXJPcCk7XG4gICAgICArK2N1ckxpbmU7XG4gICAgfSk7XG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7IGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgIH0pOyB9XG5cbiAgICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFwiYmVmb3JlQ3Vyc29yRW50ZXJcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya2VyLmNsZWFyKCk7IH0pOyB9XG5cbiAgICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XG4gICAgICBzZWVSZWFkT25seVNwYW5zKCk7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCk7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICAgICAgbWFya2VyLmF0b21pYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjbSkge1xuICAgICAgLy8gU3luYyBlZGl0b3Igc3RhdGVcbiAgICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZClcbiAgICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpOyB9XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzIHx8XG4gICAgICAgICAgICAgICBtYXJrZXIuYXR0cmlidXRlcyB8fCBtYXJrZXIudGl0bGUpXG4gICAgICAgIHsgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHsgcmVnTGluZUNoYW5nZShjbSwgaSwgXCJ0ZXh0XCIpOyB9IH1cbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJcbiAgfVxuXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xuXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbiAgLy8gbWFya2Vycy5cbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgbWFya2Vyc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gIH07XG5cbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7IH1cbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2lkZSwgbGluZU9iaikge1xuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKVxuICB9O1xuICBldmVudE1peGluKFNoYXJlZFRleHRNYXJrZXIpO1xuXG4gIGZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcbiAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xuICAgIHZhciBtYXJrZXJzID0gW21hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpXSwgcHJpbWFyeSA9IG1hcmtlcnNbMF07XG4gICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xuICAgICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpOyB9XG4gICAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgeyBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgeyByZXR1cm4gfSB9XG4gICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U2hhcmVkTWFya2Vycyhkb2MsIG1hcmtlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xuICAgICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pO1xuICAgICAgaWYgKGNtcChtRnJvbSwgbVRvKSkge1xuICAgICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xuICAgICAgICBtYXJrZXIubWFya2Vycy5wdXNoKHN1Yk1hcmspO1xuICAgICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hTaGFyZWRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXTtcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbGlua2VkLnB1c2goZCk7IH0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgIGlmIChpbmRleE9mKGxpbmtlZCwgc3ViTWFya2VyLmRvYykgPT0gLTEpIHtcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxuXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xuICB2YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgeyByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXAsIGRpcmVjdGlvbikgfVxuICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgeyBmaXJzdExpbmUgPSAwOyB9XG5cbiAgICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcIlwiLCBudWxsKV0pXSk7XG4gICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICB0aGlzLm1vZGVGcm9udGllciA9IHRoaXMuaGlnaGxpZ2h0RnJvbnRpZXIgPSBmaXJzdExpbmU7XG4gICAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XG4gICAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xuICAgIHRoaXMuaWQgPSArK25leHREb2NJZDtcbiAgICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlO1xuICAgIHRoaXMubGluZVNlcCA9IGxpbmVTZXA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09IFwicnRsXCIpID8gXCJydGxcIiA6IFwibHRyXCI7XG4gICAgdGhpcy5leHRlbmQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKSB7IHRleHQgPSB0aGlzLnNwbGl0TGluZXModGV4dCk7IH1cbiAgICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KTtcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9O1xuXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IERvYyxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcbiAgICAvLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xuICAgICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApOyB9XG4gICAgICBlbHNlIHsgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTsgfVxuICAgIH0sXG5cbiAgICAvLyBOb24tcHVibGljIGludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBsaW5lcy5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7IH1cbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxuXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuICAgIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgIH0sXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciB0b3AgPSBQb3ModGhpcy5maXJzdCwgMCksIGxhc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcInNldFZhbHVlXCIsIGZ1bGw6IHRydWV9LCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLmNtKSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMuY20sIDAsIDApOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICB9KSxcbiAgICByZXBsYWNlUmFuZ2U6IGZ1bmN0aW9uKGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcbiAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0QmV0d2Vlbih0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSk7XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIGlmIChsaW5lU2VwID09PSAnJykgeyByZXR1cm4gbGluZXMuam9pbignJykgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICB9LFxuXG4gICAgZ2V0TGluZTogZnVuY3Rpb24obGluZSkge3ZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpOyByZXR1cm4gbCAmJiBsLnRleHR9LFxuXG4gICAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge2lmIChpc0xpbmUodGhpcywgbGluZSkpIHsgcmV0dXJuIGdldExpbmUodGhpcywgbGluZSkgfX0sXG4gICAgZ2V0TGluZU51bWJlcjogZnVuY3Rpb24obGluZSkge3JldHVybiBsaW5lTm8obGluZSl9LFxuXG4gICAgZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikgeyBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTsgfVxuICAgICAgcmV0dXJuIHZpc3VhbExpbmUobGluZSlcbiAgICB9LFxuXG4gICAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zaXplfSxcbiAgICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0fSxcbiAgICBsYXN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxfSxcblxuICAgIGNsaXBQb3M6IGZ1bmN0aW9uKHBvcykge3JldHVybiBjbGlwUG9zKHRoaXMsIHBvcyl9LFxuXG4gICAgZ2V0Q3Vyc29yOiBmdW5jdGlvbihzdGFydCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3M7XG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydCA9PSBcImhlYWRcIikgeyBwb3MgPSByYW5nZS5oZWFkOyB9XG4gICAgICBlbHNlIGlmIChzdGFydCA9PSBcImFuY2hvclwiKSB7IHBvcyA9IHJhbmdlLmFuY2hvcjsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJlbmRcIiB8fCBzdGFydCA9PSBcInRvXCIgfHwgc3RhcnQgPT09IGZhbHNlKSB7IHBvcyA9IHJhbmdlLnRvKCk7IH1cbiAgICAgIGVsc2UgeyBwb3MgPSByYW5nZS5mcm9tKCk7IH1cbiAgICAgIHJldHVybiBwb3NcbiAgICB9LFxuICAgIGxpc3RTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsLnJhbmdlcyB9LFxuICAgIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKX0sXG5cbiAgICBzZXRDdXJzb3I6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGNoLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgaGVhZCksIG90aGVyICYmIGNsaXBQb3ModGhpcywgb3RoZXIpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkcywgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpO1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihyYW5nZXMsIHByaW1hcnksIG9wdGlvbnMpIHtcbiAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5oZWFkIHx8IHJhbmdlc1tpXS5hbmNob3IpKTsgfVxuICAgICAgaWYgKHByaW1hcnkgPT0gbnVsbCkgeyBwcmltYXJ5ID0gTWF0aC5taW4ocmFuZ2VzLmxlbmd0aCAtIDEsIHRoaXMuc2VsLnByaW1JbmRleCk7IH1cbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgb3V0LCBwcmltYXJ5KSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpO1xuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCByYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucyk7XG4gICAgfSksXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMsIGxpbmVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XG4gICAgICB9XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSB9XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHsgc2VsID0gc2VsLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7IH1cbiAgICAgICAgcGFydHNbaV0gPSBzZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHNcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBkdXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGR1cFtpXSA9IGNvZGU7IH1cbiAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMoZHVwLCBjb2xsYXBzZSwgb3JpZ2luIHx8IFwiK2lucHV0XCIpO1xuICAgIH0sXG4gICAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gW10sIHNlbCA9IHRoaXMuc2VsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGNoYW5nZXNbaV0gPSB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKSwgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXCJlbmRcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pXG4gICAgICAgIHsgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2kkMV0pOyB9XG4gICAgICBpZiAobmV3U2VsKSB7IHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KHRoaXMsIG5ld1NlbCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTsgfVxuICAgIH0pLFxuICAgIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIik7fSksXG4gICAgcmVkbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiKTt9KSxcbiAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIsIHRydWUpO30pLFxuICAgIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIiwgdHJ1ZSk7fSksXG5cbiAgICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsO30sXG4gICAgZ2V0RXh0ZW5kaW5nOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5leHRlbmR9LFxuXG4gICAgaGlzdG9yeVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXN0LmRvbmUubGVuZ3RoOyBpKyspIHsgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSB7ICsrZG9uZTsgfSB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoaXN0LnVuZG9uZS5sZW5ndGg7IGkkMSsrKSB7IGlmICghaGlzdC51bmRvbmVbaSQxXS5yYW5nZXMpIHsgKyt1bmRvbmU7IH0gfVxuICAgICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XG4gICAgfSxcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeSk7XG4gICAgICBsaW5rZWREb2NzKHRoaXMsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGRvYy5oaXN0b3J5ID0gdGhpcyQxLmhpc3Rvcnk7IH0sIHRydWUpO1xuICAgIH0sXG5cbiAgICBtYXJrQ2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7XG4gICAgfSxcbiAgICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XG4gICAgICBpZiAoZm9yY2VTcGxpdClcbiAgICAgICAgeyB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uXG4gICAgfSxcbiAgICBpc0NsZWFuOiBmdW5jdGlvbiAoZ2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb24gPT0gKGdlbiB8fCB0aGlzLmNsZWFuR2VuZXJhdGlvbilcbiAgICB9LFxuXG4gICAgZ2V0SGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxuICAgICAgICAgICAgICB1bmRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9XG4gICAgfSxcbiAgICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkpO1xuICAgICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRHdXR0ZXJNYXJrZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGd1dHRlcklELCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KTtcbiAgICAgICAgbWFya2Vyc1tndXR0ZXJJRF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBpc0VtcHR5KG1hcmtlcnMpKSB7IGxpbmUuZ3V0dGVyTWFya2VycyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICBjbGVhckd1dHRlcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZ3V0dGVySUQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuZ3V0dGVyTWFya2VycyAmJiBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdKSB7XG4gICAgICAgICAgY2hhbmdlTGluZSh0aGlzJDEsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkobGluZS5ndXR0ZXJNYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgbiA9IGxpbmU7XG4gICAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpO1xuICAgICAgICBpZiAoIWxpbmUpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGxpbmVObyhsaW5lKTtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXG4gICAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcbiAgICAgICAgICAgICAgd2lkZ2V0czogbGluZS53aWRnZXRzfVxuICAgIH0sXG5cbiAgICBhZGRMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcInRleHRcIiA/IFwidGV4dENsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImJhY2tncm91bmRcIiA/IFwiYmdDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgIGlmICghbGluZVtwcm9wXSkgeyBsaW5lW3Byb3BdID0gY2xzOyB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSB7IGxpbmVbcHJvcF0gKz0gXCIgXCIgKyBjbHM7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICB2YXIgY3VyID0gbGluZVtwcm9wXTtcbiAgICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIHsgbGluZVtwcm9wXSA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY3VyLm1hdGNoKGNsYXNzVGVzdChjbHMpKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgdmFyIGVuZCA9IGZvdW5kLmluZGV4ICsgZm91bmRbMF0ubGVuZ3RoO1xuICAgICAgICAgIGxpbmVbcHJvcF0gPSBjdXIuc2xpY2UoMCwgZm91bmQuaW5kZXgpICsgKCFmb3VuZC5pbmRleCB8fCBlbmQgPT0gY3VyLmxlbmd0aCA/IFwiXCIgOiBcIiBcIikgKyBjdXIuc2xpY2UoZW5kKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpOyB9LFxuXG4gICAgbWFya1RleHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0byksIG9wdGlvbnMsIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IFwicmFuZ2VcIilcbiAgICB9LFxuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudHM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcImJvb2ttYXJrXCIpXG4gICAgfSxcbiAgICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxuICAgICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXG4gICAgICAgICAgeyBtYXJrZXJzLnB1c2goc3Bhbi5tYXJrZXIucGFyZW50IHx8IHNwYW4ubWFya2VyKTsgfVxuICAgICAgfSB9XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTsgdG8gPSBjbGlwUG9zKHRoaXMsIHRvKTtcbiAgICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmU7XG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICAgIGlmICghKHNwYW4udG8gIT0gbnVsbCAmJiBsaW5lTm8gPT0gZnJvbS5saW5lICYmIGZyb20uY2ggPj0gc3Bhbi50byB8fFxuICAgICAgICAgICAgICAgIHNwYW4uZnJvbSA9PSBudWxsICYmIGxpbmVObyAhPSBmcm9tLmxpbmUgfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gIT0gbnVsbCAmJiBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPj0gdG8uY2gpICYmXG4gICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlcihzcGFuLm1hcmtlcikpKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgICAgfSB9XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmRcbiAgICB9LFxuICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwcyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgeyBpZiAoc3BzW2ldLmZyb20gIT0gbnVsbCkgeyBtYXJrZXJzLnB1c2goc3BzW2ldLm1hcmtlcik7IH0gfSB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrZXJzXG4gICAgfSxcblxuICAgIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XG4gICAgICB2YXIgY2gsIGxpbmVObyA9IHRoaXMuZmlyc3QsIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XG4gICAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWUgfVxuICAgICAgICBvZmYgLT0gc3o7XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vLCBjaCkpXG4gICAgfSxcbiAgICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgIGNvb3JkcyA9IGNsaXBQb3ModGhpcywgY29vcmRzKTtcbiAgICAgIHZhciBpbmRleCA9IGNvb3Jkcy5jaDtcbiAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgeyByZXR1cm4gMCB9XG4gICAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDtcbiAgICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlXG4gICAgICAgIGluZGV4ICs9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlT3B0aW9uLCB0aGlzLmZpcnN0LCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDsgZG9jLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgICBkb2Muc2VsID0gdGhpcy5zZWw7XG4gICAgICBkb2MuZXh0ZW5kID0gZmFsc2U7XG4gICAgICBpZiAoY29weUhpc3RvcnkpIHtcbiAgICAgICAgZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aDtcbiAgICAgICAgZG9jLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvY1xuICAgIH0sXG5cbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cbiAgICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplO1xuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPSBudWxsICYmIG9wdGlvbnMuZnJvbSA+IGZyb20pIHsgZnJvbSA9IG9wdGlvbnMuZnJvbTsgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHsgdG8gPSBvcHRpb25zLnRvOyB9XG4gICAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tLCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIHsgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5XG4gICAgICA7IH0odGhpcy5saW5rZWQgfHwgKHRoaXMubGlua2VkID0gW10pKS5wdXNoKHtkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH0pO1xuICAgICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xuICAgICAgY29weVNoYXJlZE1hcmtlcnMoY29weSwgZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xuICAgICAgcmV0dXJuIGNvcHlcbiAgICB9LFxuICAgIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIHsgb3RoZXIgPSBvdGhlci5kb2M7IH1cbiAgICAgIGlmICh0aGlzLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaV07XG4gICAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgeyBjb250aW51ZSB9XG4gICAgICAgIHRoaXMubGlua2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMpO1xuICAgICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gfVxuICAgICAgLy8gSWYgdGhlIGhpc3RvcmllcyB3ZXJlIHNoYXJlZCwgc3BsaXQgdGhlbSBhZ2FpblxuICAgICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XG4gICAgICAgIHZhciBzcGxpdElkcyA9IFtvdGhlci5pZF07XG4gICAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXG5cbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlfSxcbiAgICBnZXRFZGl0b3I6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmNtfSxcblxuICAgIHNwbGl0TGluZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHRoaXMubGluZVNlcCkgeyByZXR1cm4gc3RyLnNwbGl0KHRoaXMubGluZVNlcCkgfVxuICAgICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cilcbiAgICB9LFxuICAgIGxpbmVTZXBhcmF0b3I6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lU2VwIHx8IFwiXFxuXCIgfSxcblxuICAgIHNldERpcmVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24gKGRpcikge1xuICAgICAgaWYgKGRpciAhPSBcInJ0bFwiKSB7IGRpciA9IFwibHRyXCI7IH1cbiAgICAgIGlmIChkaXIgPT0gdGhpcy5kaXJlY3Rpb24pIHsgcmV0dXJuIH1cbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lLm9yZGVyID0gbnVsbDsgfSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBkaXJlY3Rpb25DaGFuZ2VkKHRoaXMuY20pOyB9XG4gICAgfSlcbiAgfSk7XG5cbiAgLy8gUHVibGljIGFsaWFzLlxuICBEb2MucHJvdG90eXBlLmVhY2hMaW5lID0gRG9jLnByb3RvdHlwZS5pdGVyO1xuXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xuICAvLyByZS1maXJlIGEgc2VyaWVzIG9mIGRyYWctcmVsYXRlZCBldmVudHMgcmlnaHQgYWZ0ZXIgdGhlIGRyb3AgKCMxNTUxKVxuICB2YXIgbGFzdERyb3AgPSAwO1xuXG4gIGZ1bmN0aW9uIG9uRHJvcChlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBjbGVhckRyYWdDdXJzb3IoY20pO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIGlmIChpZSkgeyBsYXN0RHJvcCA9ICtuZXcgRGF0ZTsgfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUpLCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmICghcG9zIHx8IGNtLmlzUmVhZE9ubHkoKSkgeyByZXR1cm4gfVxuICAgIC8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XG4gICAgLy8gYW5kIGluc2VydCBpdC5cbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKSB7XG4gICAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMDtcbiAgICAgIHZhciBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCsrcmVhZCA9PSBuKSB7XG4gICAgICAgICAgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjbS5kb2Muc3BsaXRMaW5lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICE9IG51bGw7IH0pLmpvaW4oY20uZG9jLmxpbmVTZXBhcmF0b3IoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwicGFzdGVcIn07XG4gICAgICAgICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGNsaXBQb3MoY20uZG9jLCBwb3MpLCBjbGlwUG9zKGNtLmRvYywgY2hhbmdlRW5kKGNoYW5nZSkpKSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciByZWFkVGV4dEZyb21GaWxlID0gZnVuY3Rpb24gKGZpbGUsIGkpIHtcbiAgICAgICAgaWYgKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzICYmXG4gICAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKSB7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTsgfTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgaWYgKC9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dFtpXSA9IGNvbnRlbnQ7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykgeyByZWFkVGV4dEZyb21GaWxlKGZpbGVzW2ldLCBpKTsgfVxuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXG4gICAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxuICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGV4dCQxID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0JDEpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0LmNvcHkpXG4gICAgICAgICAgICB7IHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKTsgfVxuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSQxKVxuICAgICAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBzZWxlY3RlZFtpJDFdLmFuY2hvciwgc2VsZWN0ZWRbaSQxXS5oZWFkLCBcImRyYWdcIik7IH0gfVxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCQxLCBcImFyb3VuZFwiLCBcInBhc3RlXCIpO1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZSQxKXt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcbiAgICBpZiAoaWUgJiYgKCFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgfHwgK25ldyBEYXRlIC0gbGFzdERyb3AgPCAxMDApKSB7IGVfc3RvcChlKTsgcmV0dXJuIH1cbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGNtLmdldFNlbGVjdGlvbigpKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuXG4gICAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XG4gICAgICB2YXIgaW1nID0gZWx0KFwiaW1nXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XCIpO1xuICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDE7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXG4gICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgaWYgKHByZXN0bykgeyBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnT3ZlcihjbSwgZSkge1xuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgIGlmICghcG9zKSB7IHJldHVybiB9XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKTtcbiAgICBpZiAoIWNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIik7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdik7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZyk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRyYWdDdXJzb3IoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpO1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxuICAvLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXG4gIC8vIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG4gIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHsgcmV0dXJuIH1cbiAgICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpLCBlZGl0b3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY20gPSBieUNsYXNzW2ldLkNvZGVNaXJyb3I7XG4gICAgICBpZiAoY20pIHsgZWRpdG9ycy5wdXNoKGNtKTsgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGgpIHsgZWRpdG9yc1swXS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0b3JzLmxlbmd0aDsgaSsrKSB7IGYoZWRpdG9yc1tpXSk7IH1cbiAgICB9KTsgfVxuICB9XG5cbiAgdmFyIGdsb2JhbHNSZWdpc3RlcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xuICAgIGlmIChnbG9iYWxzUmVnaXN0ZXJlZCkgeyByZXR1cm4gfVxuICAgIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcbiAgICBnbG9iYWxzUmVnaXN0ZXJlZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpIHtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgbmVlZCB0byByZWZyZXNoIGFjdGl2ZSBlZGl0b3JzLlxuICAgIHZhciByZXNpemVUaW1lcjtcbiAgICBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXNpemVUaW1lciA9PSBudWxsKSB7IHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgZm9yRWFjaENvZGVNaXJyb3Iob25SZXNpemUpO1xuICAgICAgfSwgMTAwKTsgfVxuICAgIH0pO1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBsb3NlcyBmb2N1cywgd2Ugd2FudCB0byBzaG93IHRoZSBlZGl0b3IgYXMgYmx1cnJlZFxuICAgIG9uKHdpbmRvdywgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvckVhY2hDb2RlTWlycm9yKG9uQmx1cik7IH0pO1xuICB9XG4gIC8vIENhbGxlZCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplc1xuICBmdW5jdGlvbiBvblJlc2l6ZShjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICAvLyBNaWdodCBiZSBhIHRleHQgc2NhbGluZyBvcGVyYXRpb24sIGNsZWFyIHNpemUgY2FjaGVzLlxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuICAgIGNtLnNldFNpemUoKTtcbiAgfVxuXG4gIHZhciBrZXlOYW1lcyA9IHtcbiAgICAzOiBcIlBhdXNlXCIsIDg6IFwiQmFja3NwYWNlXCIsIDk6IFwiVGFiXCIsIDEzOiBcIkVudGVyXCIsIDE2OiBcIlNoaWZ0XCIsIDE3OiBcIkN0cmxcIiwgMTg6IFwiQWx0XCIsXG4gICAgMTk6IFwiUGF1c2VcIiwgMjA6IFwiQ2Fwc0xvY2tcIiwgMjc6IFwiRXNjXCIsIDMyOiBcIlNwYWNlXCIsIDMzOiBcIlBhZ2VVcFwiLCAzNDogXCJQYWdlRG93blwiLCAzNTogXCJFbmRcIixcbiAgICAzNjogXCJIb21lXCIsIDM3OiBcIkxlZnRcIiwgMzg6IFwiVXBcIiwgMzk6IFwiUmlnaHRcIiwgNDA6IFwiRG93blwiLCA0NDogXCJQcmludFNjcm5cIiwgNDU6IFwiSW5zZXJ0XCIsXG4gICAgNDY6IFwiRGVsZXRlXCIsIDU5OiBcIjtcIiwgNjE6IFwiPVwiLCA5MTogXCJNb2RcIiwgOTI6IFwiTW9kXCIsIDkzOiBcIk1vZFwiLFxuICAgIDEwNjogXCIqXCIsIDEwNzogXCI9XCIsIDEwOTogXCItXCIsIDExMDogXCIuXCIsIDExMTogXCIvXCIsIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gICAgMTczOiBcIi1cIiwgMTg2OiBcIjtcIiwgMTg3OiBcIj1cIiwgMTg4OiBcIixcIiwgMTg5OiBcIi1cIiwgMTkwOiBcIi5cIiwgMTkxOiBcIi9cIiwgMTkyOiBcImBcIiwgMjE5OiBcIltcIiwgMjIwOiBcIlxcXFxcIixcbiAgICAyMjE6IFwiXVwiLCAyMjI6IFwiJ1wiLCAyMjQ6IFwiTW9kXCIsIDYzMjMyOiBcIlVwXCIsIDYzMjMzOiBcIkRvd25cIiwgNjMyMzQ6IFwiTGVmdFwiLCA2MzIzNTogXCJSaWdodFwiLCA2MzI3MjogXCJEZWxldGVcIixcbiAgICA2MzI3MzogXCJIb21lXCIsIDYzMjc1OiBcIkVuZFwiLCA2MzI3NjogXCJQYWdlVXBcIiwgNjMyNzc6IFwiUGFnZURvd25cIiwgNjMzMDI6IFwiSW5zZXJ0XCJcbiAgfTtcblxuICAvLyBOdW1iZXIga2V5c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHsga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7IH1cbiAgLy8gQWxwaGFiZXRpYyBrZXlzXG4gIGZvciAodmFyIGkkMSA9IDY1OyBpJDEgPD0gOTA7IGkkMSsrKSB7IGtleU5hbWVzW2kkMV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkkMSk7IH1cbiAgLy8gRnVuY3Rpb24ga2V5c1xuICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7IGtleU5hbWVzW2kkMiArIDExMV0gPSBrZXlOYW1lc1tpJDIgKyA2MzIzNV0gPSBcIkZcIiArIGkkMjsgfVxuXG4gIHZhciBrZXlNYXAgPSB7fTtcblxuICBrZXlNYXAuYmFzaWMgPSB7XG4gICAgXCJMZWZ0XCI6IFwiZ29DaGFyTGVmdFwiLCBcIlJpZ2h0XCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJVcFwiOiBcImdvTGluZVVwXCIsIFwiRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkVuZFwiOiBcImdvTGluZUVuZFwiLCBcIkhvbWVcIjogXCJnb0xpbmVTdGFydFNtYXJ0XCIsIFwiUGFnZVVwXCI6IFwiZ29QYWdlVXBcIiwgXCJQYWdlRG93blwiOiBcImdvUGFnZURvd25cIixcbiAgICBcIkRlbGV0ZVwiOiBcImRlbENoYXJBZnRlclwiLCBcIkJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJTaGlmdC1CYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgXCJUYWJcIjogXCJkZWZhdWx0VGFiXCIsIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50QXV0b1wiLFxuICAgIFwiRW50ZXJcIjogXCJuZXdsaW5lQW5kSW5kZW50XCIsIFwiSW5zZXJ0XCI6IFwidG9nZ2xlT3ZlcndyaXRlXCIsXG4gICAgXCJFc2NcIjogXCJzaW5nbGVTZWxlY3Rpb25cIlxuICB9O1xuICAvLyBOb3RlIHRoYXQgdGhlIHNhdmUgYW5kIGZpbmQtcmVsYXRlZCBjb21tYW5kcyBhcmVuJ3QgZGVmaW5lZCBieVxuICAvLyBkZWZhdWx0LiBVc2VyIGNvZGUgb3IgYWRkb25zIGNhbiBkZWZpbmUgdGhlbS4gVW5rbm93biBjb21tYW5kc1xuICAvLyBhcmUgc2ltcGx5IGlnbm9yZWQuXG4gIGtleU1hcC5wY0RlZmF1bHQgPSB7XG4gICAgXCJDdHJsLUFcIjogXCJzZWxlY3RBbGxcIiwgXCJDdHJsLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ3RybC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUN0cmwtWlwiOiBcInJlZG9cIiwgXCJDdHJsLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDdHJsLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkN0cmwtVXBcIjogXCJnb0xpbmVVcFwiLCBcIkN0cmwtRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkN0cmwtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsIFwiQ3RybC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJBbHQtUmlnaHRcIjogXCJnb0xpbmVFbmRcIixcbiAgICBcIkN0cmwtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIiwgXCJDdHJsLURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDdHJsLVNcIjogXCJzYXZlXCIsIFwiQ3RybC1GXCI6IFwiZmluZFwiLFxuICAgIFwiQ3RybC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DdHJsLUdcIjogXCJmaW5kUHJldlwiLCBcIlNoaWZ0LUN0cmwtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DdHJsLVJcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDdHJsLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ3RybC1dXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgIFwiQ3RybC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUN0cmwtVVwiOiBcInJlZG9TZWxlY3Rpb25cIiwgXCJBbHQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFwiYmFzaWNcIlxuICB9O1xuICAvLyBWZXJ5IGJhc2ljIHJlYWRsaW5lL2VtYWNzLXN0eWxlIGJpbmRpbmdzLCB3aGljaCBhcmUgc3RhbmRhcmQgb24gTWFjLlxuICBrZXlNYXAuZW1hY3N5ID0ge1xuICAgIFwiQ3RybC1GXCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJDdHJsLUJcIjogXCJnb0NoYXJMZWZ0XCIsIFwiQ3RybC1QXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLU5cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUFcIjogXCJnb0xpbmVTdGFydFwiLCBcIkN0cmwtRVwiOiBcImdvTGluZUVuZFwiLCBcIkN0cmwtVlwiOiBcImdvUGFnZURvd25cIiwgXCJTaGlmdC1DdHJsLVZcIjogXCJnb1BhZ2VVcFwiLFxuICAgIFwiQ3RybC1EXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQ3RybC1IXCI6IFwiZGVsQ2hhckJlZm9yZVwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxXb3JkQmVmb3JlXCIsIFwiQ3RybC1LXCI6IFwia2lsbExpbmVcIixcbiAgICBcIkN0cmwtVFwiOiBcInRyYW5zcG9zZUNoYXJzXCIsIFwiQ3RybC1PXCI6IFwib3BlbkxpbmVcIlxuICB9O1xuICBrZXlNYXAubWFjRGVmYXVsdCA9IHtcbiAgICBcIkNtZC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ21kLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ21kLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ21kLVpcIjogXCJyZWRvXCIsIFwiQ21kLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDbWQtSG9tZVwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLUVuZFwiOiBcImdvRG9jRW5kXCIsIFwiQ21kLURvd25cIjogXCJnb0RvY0VuZFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIixcbiAgICBcIkFsdC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkNtZC1MZWZ0XCI6IFwiZ29MaW5lTGVmdFwiLCBcIkNtZC1SaWdodFwiOiBcImdvTGluZVJpZ2h0XCIsIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDbWQtU1wiOiBcInNhdmVcIiwgXCJDbWQtRlwiOiBcImZpbmRcIixcbiAgICBcIkNtZC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DbWQtR1wiOiBcImZpbmRQcmV2XCIsIFwiQ21kLUFsdC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUNtZC1BbHQtRlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkNtZC1dXCI6IFwiaW5kZW50TW9yZVwiLCBcIkNtZC1CYWNrc3BhY2VcIjogXCJkZWxXcmFwcGVkTGluZUxlZnRcIiwgXCJDbWQtRGVsZXRlXCI6IFwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFxuICAgIFwiQ21kLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQ3RybC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLURvd25cIjogXCJnb0RvY0VuZFwiLFxuICAgIFwiZmFsbHRocm91Z2hcIjogW1wiYmFzaWNcIiwgXCJlbWFjc3lcIl1cbiAgfTtcbiAga2V5TWFwW1wiZGVmYXVsdFwiXSA9IG1hYyA/IGtleU1hcC5tYWNEZWZhdWx0IDoga2V5TWFwLnBjRGVmYXVsdDtcblxuICAvLyBLRVlNQVAgRElTUEFUQ0hcblxuICBmdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIG1vZCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgeyBjbWQgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgeyBjdHJsID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHsgc2hpZnQgPSB0cnVlOyB9XG4gICAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKSB9XG4gICAgfVxuICAgIGlmIChhbHQpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmIChjdHJsKSB7IG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lOyB9XG4gICAgaWYgKGNtZCkgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKHNoaWZ0KSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xuICAvLyAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgc3VwcG9ydCBmZWF0dXJlc1xuICAvLyBsaWtlIG5vcm1hbGl6YXRpb24gYW5kIG11bHRpLXN0cm9rZSBrZXkgYmluZGluZ3MuIEl0IGNvbXBpbGVzIGFcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcbiAgLy8gdGhpcy5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TWFwKGtleW1hcCkge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgZm9yICh2YXIga2V5bmFtZSBpbiBrZXltYXApIHsgaWYgKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdO1xuICAgICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAodmFsdWUgPT0gXCIuLi5cIikgeyBkZWxldGUga2V5bWFwW2tleW5hbWVdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsID0gKHZvaWQgMCksIG5hbWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKGkgPT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IFwiLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSBjb3B5W25hbWVdO1xuICAgICAgICBpZiAoIXByZXYpIHsgY29weVtuYW1lXSA9IHZhbDsgfVxuICAgICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFwiICsgbmFtZSkgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXTtcbiAgICB9IH1cbiAgICBmb3IgKHZhciBwcm9wIGluIGNvcHkpIHsga2V5bWFwW3Byb3BdID0gY29weVtwcm9wXTsgfVxuICAgIHJldHVybiBrZXltYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcCwgaGFuZGxlLCBjb250ZXh0KSB7XG4gICAgbWFwID0gZ2V0S2V5TWFwKG1hcCk7XG4gICAgdmFyIGZvdW5kID0gbWFwLmNhbGwgPyBtYXAuY2FsbChrZXksIGNvbnRleHQpIDogbWFwW2tleV07XG4gICAgaWYgKGZvdW5kID09PSBmYWxzZSkgeyByZXR1cm4gXCJub3RoaW5nXCIgfVxuICAgIGlmIChmb3VuZCA9PT0gXCIuLi5cIikgeyByZXR1cm4gXCJtdWx0aVwiIH1cbiAgICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG5cbiAgICBpZiAobWFwLmZhbGx0aHJvdWdoKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1hcC5mYWxsdGhyb3VnaCkgIT0gXCJbb2JqZWN0IEFycmF5XVwiKVxuICAgICAgICB7IHJldHVybiBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2gsIGhhbmRsZSwgY29udGV4dCkgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuZmFsbHRocm91Z2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaFtpXSwgaGFuZGxlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxuICAvLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cbiAgZnVuY3Rpb24gaXNNb2RpZmllcktleSh2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IGtleU5hbWVzW3ZhbHVlLmtleUNvZGVdO1xuICAgIHJldHVybiBuYW1lID09IFwiQ3RybFwiIHx8IG5hbWUgPT0gXCJBbHRcIiB8fCBuYW1lID09IFwiU2hpZnRcIiB8fCBuYW1lID09IFwiTW9kXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpIHtcbiAgICB2YXIgYmFzZSA9IG5hbWU7XG4gICAgaWYgKGV2ZW50LmFsdEtleSAmJiBiYXNlICE9IFwiQWx0XCIpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcIkN0cmxcIikgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcIk1vZFwiKSB7IG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7IH1cbiAgICBpZiAoIW5vU2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkgJiYgYmFzZSAhPSBcIlNoaWZ0XCIpIHsgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lOyB9XG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cbiAgZnVuY3Rpb24ga2V5TmFtZShldmVudCwgbm9TaGlmdCkge1xuICAgIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcImNoYXJcIl0pIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmFtZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdO1xuICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBDdHJsLVNjcm9sbExvY2sgaGFzIGtleUNvZGUgMywgc2FtZSBhcyBDdHJsLVBhdXNlLFxuICAgIC8vIHNvIHdlJ2xsIHVzZSBldmVudC5jb2RlIHdoZW4gYXZhaWxhYmxlIChDaHJvbWUgNDgrLCBGRiAzOCssIFNhZmFyaSAxMC4xKylcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzICYmIGV2ZW50LmNvZGUpIHsgbmFtZSA9IGV2ZW50LmNvZGU7IH1cbiAgICByZXR1cm4gYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCwgbm9TaGlmdClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8ga2V5TWFwW3ZhbF0gOiB2YWxcbiAgfVxuXG4gIC8vIEhlbHBlciBmb3IgZGVsZXRpbmcgdGV4dCBuZWFyIHRoZSBzZWxlY3Rpb24ocyksIHVzZWQgdG8gaW1wbGVtZW50XG4gIC8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxuICBmdW5jdGlvbiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBjb21wdXRlKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmRvYy5zZWwucmFuZ2VzLCBraWxsID0gW107XG4gICAgLy8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcbiAgICAvLyByYW5nZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b0tpbGwgPSBjb21wdXRlKHJhbmdlc1tpXSk7XG4gICAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKTtcbiAgICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgdG9LaWxsLmZyb20gPSByZXBsYWNlZC5mcm9tO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtpbGwucHVzaCh0b0tpbGwpO1xuICAgIH1cbiAgICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0ga2lsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBraWxsW2ldLmZyb20sIGtpbGxbaV0udG8sIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBjaCwgZGlyKSB7XG4gICAgdmFyIHRhcmdldCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lLnRleHQsIGNoICsgZGlyLCBkaXIpO1xuICAgIHJldHVybiB0YXJnZXQgPCAwIHx8IHRhcmdldCA+IGxpbmUudGV4dC5sZW5ndGggPyBudWxsIDogdGFyZ2V0XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgY2ggPSBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBzdGFydC5jaCwgZGlyKTtcbiAgICByZXR1cm4gY2ggPT0gbnVsbCA/IG51bGwgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBkaXIgPCAwID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mTGluZSh2aXN1YWxseSwgY20sIGxpbmVPYmosIGxpbmVObywgZGlyKSB7XG4gICAgaWYgKHZpc3VhbGx5KSB7XG4gICAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7IGRpciA9IC1kaXI7IH1cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gZGlyIDwgMCA/IGxzdChvcmRlcikgOiBvcmRlclswXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKTtcbiAgICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAgIHZhciBjaDtcbiAgICAgICAgLy8gV2l0aCBhIHdyYXBwZWQgcnRsIGNodW5rIChwb3NzaWJseSBzcGFubmluZyBtdWx0aXBsZSBiaWRpIHBhcnRzKSxcbiAgICAgICAgLy8gaXQgY291bGQgYmUgdGhhdCB0aGUgbGFzdCBiaWRpIHBhcnQgaXMgbm90IG9uIHRoZSBsYXN0IHZpc3VhbCBsaW5lLFxuICAgICAgICAvLyBzaW5jZSB2aXN1YWwgbGluZXMgY29udGFpbiBjb250ZW50IG9yZGVyLWNvbnNlY3V0aXZlIGNodW5rcy5cbiAgICAgICAgLy8gVGh1cywgaW4gcnRsLCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIGZpcnN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXJcbiAgICAgICAgLy8gaW4gdGhlIHJ0bCBjaHVuayB0aGF0IGlzIG9uIHRoZSBsYXN0IGxpbmUgKHRoYXQgaXMsIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgLy8gYXMgdGhlIGxhc3QgKGNvbnRlbnQtb3JkZXIpIGNoYXJhY3RlcikuXG4gICAgICAgIGlmIChwYXJ0LmxldmVsID4gMCB8fCBjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIpIHtcbiAgICAgICAgICB2YXIgcHJlcCA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHZhciB0YXJnZXRUb3AgPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwLCBjaCkudG9wO1xuICAgICAgICAgIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcCA9PSB0YXJnZXRUb3A7IH0sIChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKSA/IHBhcnQuZnJvbSA6IHBhcnQudG8gLSAxLCBjaCk7XG4gICAgICAgICAgaWYgKHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZU9iaiwgY2gsIDEpOyB9XG4gICAgICAgIH0gZWxzZSB7IGNoID0gZGlyIDwgMCA/IHBhcnQudG8gOiBwYXJ0LmZyb207IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGRpciA8IDAgPyBsaW5lT2JqLnRleHQubGVuZ3RoIDogMCwgZGlyIDwgMCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlVmlzdWFsbHkoY20sIGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIGlmICghYmlkaSkgeyByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB9XG4gICAgaWYgKHN0YXJ0LmNoID49IGxpbmUudGV4dC5sZW5ndGgpIHtcbiAgICAgIHN0YXJ0LmNoID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0YXJ0LnN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChzdGFydC5jaCA8PSAwKSB7XG4gICAgICBzdGFydC5jaCA9IDA7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydC5jaCwgc3RhcnQuc3RpY2t5KSwgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIiAmJiBwYXJ0LmxldmVsICUgMiA9PSAwICYmIChkaXIgPiAwID8gcGFydC50byA+IHN0YXJ0LmNoIDogcGFydC5mcm9tIDwgc3RhcnQuY2gpKSB7XG4gICAgICAvLyBDYXNlIDE6IFdlIG1vdmUgd2l0aGluIGFuIGx0ciBwYXJ0IGluIGFuIGx0ciBlZGl0b3IuIEV2ZW4gd2l0aCB3cmFwcGVkIGxpbmVzLFxuICAgICAgLy8gbm90aGluZyBpbnRlcmVzdGluZyBoYXBwZW5zLlxuICAgICAgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcilcbiAgICB9XG5cbiAgICB2YXIgbXYgPSBmdW5jdGlvbiAocG9zLCBkaXIpIHsgcmV0dXJuIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHBvcyBpbnN0YW5jZW9mIFBvcyA/IHBvcy5jaCA6IHBvcywgZGlyKTsgfTtcbiAgICB2YXIgcHJlcDtcbiAgICB2YXIgZ2V0V3JhcHBlZExpbmVFeHRlbnQgPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgcmV0dXJuIHtiZWdpbjogMCwgZW5kOiBsaW5lLnRleHQubGVuZ3RofSB9XG4gICAgICBwcmVwID0gcHJlcCB8fCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpO1xuICAgICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZSwgcHJlcCwgY2gpXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZExpbmVFeHRlbnQgPSBnZXRXcmFwcGVkTGluZUV4dGVudChzdGFydC5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IG12KHN0YXJ0LCAtMSkgOiBzdGFydC5jaCk7XG5cbiAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiIHx8IHBhcnQubGV2ZWwgPT0gMSkge1xuICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChwYXJ0LmxldmVsID09IDEpID09IChkaXIgPCAwKTtcbiAgICAgIHZhciBjaCA9IG12KHN0YXJ0LCBtb3ZlSW5TdG9yYWdlT3JkZXIgPyAxIDogLTEpO1xuICAgICAgaWYgKGNoICE9IG51bGwgJiYgKCFtb3ZlSW5TdG9yYWdlT3JkZXIgPyBjaCA+PSBwYXJ0LmZyb20gJiYgY2ggPj0gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBjaCA8PSBwYXJ0LnRvICYmIGNoIDw9IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCkpIHtcbiAgICAgICAgLy8gQ2FzZSAyOiBXZSBtb3ZlIHdpdGhpbiBhbiBydGwgcGFydCBvciBpbiBhbiBydGwgZWRpdG9yIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhc2UgMzogQ291bGQgbm90IG1vdmUgd2l0aGluIHRoaXMgYmlkaSBwYXJ0IGluIHRoaXMgdmlzdWFsIGxpbmUsIHNvIGxlYXZlXG4gICAgLy8gdGhlIGN1cnJlbnQgYmlkaSBwYXJ0XG5cbiAgICB2YXIgc2VhcmNoSW5WaXN1YWxMaW5lID0gZnVuY3Rpb24gKHBhcnRQb3MsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpIHtcbiAgICAgIHZhciBnZXRSZXMgPSBmdW5jdGlvbiAoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgeyByZXR1cm4gbW92ZUluU3RvcmFnZU9yZGVyXG4gICAgICAgID8gbmV3IFBvcyhzdGFydC5saW5lLCBtdihjaCwgMSksIFwiYmVmb3JlXCIpXG4gICAgICAgIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgXCJhZnRlclwiKTsgfTtcblxuICAgICAgZm9yICg7IHBhcnRQb3MgPj0gMCAmJiBwYXJ0UG9zIDwgYmlkaS5sZW5ndGg7IHBhcnRQb3MgKz0gZGlyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gYmlkaVtwYXJ0UG9zXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPiAwKSA9PSAocGFydC5sZXZlbCAhPSAxKTtcbiAgICAgICAgdmFyIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBtdih3cmFwcGVkTGluZUV4dGVudC5lbmQsIC0xKTtcbiAgICAgICAgaWYgKHBhcnQuZnJvbSA8PSBjaCAmJiBjaCA8IHBhcnQudG8pIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICAgIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gcGFydC5mcm9tIDogbXYocGFydC50bywgLTEpO1xuICAgICAgICBpZiAod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gPD0gY2ggJiYgY2ggPCB3cmFwcGVkTGluZUV4dGVudC5lbmQpIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhc2UgM2E6IExvb2sgZm9yIG90aGVyIGJpZGkgcGFydHMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmVcbiAgICB2YXIgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKHBhcnRQb3MgKyBkaXIsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpO1xuICAgIGlmIChyZXMpIHsgcmV0dXJuIHJlcyB9XG5cbiAgICAvLyBDYXNlIDNiOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBuZXh0IHZpc3VhbCBsaW5lXG4gICAgdmFyIG5leHRDaCA9IGRpciA+IDAgPyB3cmFwcGVkTGluZUV4dGVudC5lbmQgOiBtdih3cmFwcGVkTGluZUV4dGVudC5iZWdpbiwgLTEpO1xuICAgIGlmIChuZXh0Q2ggIT0gbnVsbCAmJiAhKGRpciA+IDAgJiYgbmV4dENoID09IGxpbmUudGV4dC5sZW5ndGgpKSB7XG4gICAgICByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUoZGlyID4gMCA/IDAgOiBiaWRpLmxlbmd0aCAtIDEsIGRpciwgZ2V0V3JhcHBlZExpbmVFeHRlbnQobmV4dENoKSk7XG4gICAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuICAgIH1cblxuICAgIC8vIENhc2UgNDogTm93aGVyZSB0byBtb3ZlXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxuICAvLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cbiAgdmFyIGNvbW1hbmRzID0ge1xuICAgIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICAgIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLCBjbS5nZXRDdXJzb3IoXCJoZWFkXCIpLCBzZWxfZG9udFNjcm9sbCk7IH0sXG4gICAga2lsbExpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICB2YXIgbGVuID0gZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChyYW5nZS5oZWFkLmNoID09IGxlbiAmJiByYW5nZS5oZWFkLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSArIDEsIDApfSB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUsIGxlbil9IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cbiAgICAgIH1cbiAgICB9KTsgfSxcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXG4gICAgICB0bzogY2xpcFBvcyhjbS5kb2MsIFBvcyhyYW5nZS50bygpLmxpbmUgKyAxLCAwKSlcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiAoe1xuICAgICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSwgdG86IHJhbmdlLmZyb20oKVxuICAgIH0pOyB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiBsZWZ0UG9zLCB0bzogcmFuZ2UuZnJvbSgpfVxuICAgIH0pOyB9LFxuICAgIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByaWdodFBvcyB9XG4gICAgfSk7IH0sXG4gICAgdW5kbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvKCk7IH0sXG4gICAgcmVkbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvKCk7IH0sXG4gICAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvU2VsZWN0aW9uKCk7IH0sXG4gICAgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvU2VsZWN0aW9uKCk7IH0sXG4gICAgZ29Eb2NTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7IH0sXG4gICAgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7IH0sXG4gICAgZ29MaW5lU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0KGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogLTF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIilcbiAgICB9LCBzZWxfbW92ZSk7IH0sXG4gICAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKSB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcImxpbmVcIik7IH0sXG4gICAgZ29MaW5lRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcImxpbmVcIik7IH0sXG4gICAgZ29QYWdlVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFwicGFnZVwiKTsgfSxcbiAgICBnb1BhZ2VEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFwicGFnZVwiKTsgfSxcbiAgICBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImNoYXJcIik7IH0sXG4gICAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImNvbHVtblwiKTsgfSxcbiAgICBnb1dvcmRMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcIndvcmRcIik7IH0sXG4gICAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJjb2RlcG9pbnRcIik7IH0sXG4gICAgZGVsQ2hhckFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxHcm91cEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGluZGVudEF1dG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic21hcnRcIik7IH0sXG4gICAgaW5kZW50TW9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH0sXG4gICAgaW5kZW50TGVzczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTsgfSxcbiAgICBpbnNlcnRUYWI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKTsgfSxcbiAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uZnJvbSgpO1xuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHNwYWNlcy5wdXNoKHNwYWNlU3RyKHRhYlNpemUgLSBjb2wgJSB0YWJTaXplKSk7XG4gICAgICB9XG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzcGFjZXMpO1xuICAgIH0sXG4gICAgZGVmYXVsdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH1cbiAgICAgIGVsc2UgeyBjbS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKTsgfVxuICAgIH0sXG4gICAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAvLyBNb3ZlIGN1cnNvciBiZWhpbmQgdGhlIHR3byBzd2FwcGVkIGNoYXJhY3RlcnMgYWZ0ZXJ3YXJkcy5cbiAgICAvL1xuICAgIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cbiAgICAvLyBEb2Vzbid0IHNjYW4gbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIHRvIGZpbmQgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBkbyBhbnl0aGluZyBvbiBhbiBlbXB0eSBsaW5lLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3U2VsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5lbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0O1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIGlmIChjdXIuY2ggPT0gbGluZS5sZW5ndGgpIHsgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSk7IH1cbiAgICAgICAgICBpZiAoY3VyLmNoID4gMCkge1xuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFwiK3RyYW5zcG9zZVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5saW5lID4gY20uZG9jLmZpcnN0KSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCAxKTtcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KDApICsgY20uZG9jLmxpbmVTZXBhcmF0b3IoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNoYXJBdChwcmV2Lmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lIC0gMSwgcHJldi5sZW5ndGggLSAxKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpO1xuICAgIH0pOyB9LFxuICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbHMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgZm9yICh2YXIgaSA9IHNlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgY20ucmVwbGFjZVJhbmdlKGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIHNlbHNbaV0uYW5jaG9yLCBzZWxzW2ldLmhlYWQsIFwiK2lucHV0XCIpOyB9XG4gICAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHNlbHMubGVuZ3RoOyBpJDErKylcbiAgICAgICAgeyBjbS5pbmRlbnRMaW5lKHNlbHNbaSQxXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pOyB9LFxuICAgIG9wZW5MaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIiwgXCJzdGFydFwiKTsgfSxcbiAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udG9nZ2xlT3ZlcndyaXRlKCk7IH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7IGxpbmVOID0gbGluZU5vKHZpc3VhbCk7IH1cbiAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCB2aXN1YWwsIGxpbmVOLCAxKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lRW5kKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgbGluZSwgbGluZU4sIC0xKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKTtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcbiAgICAgIHZhciBmaXJzdE5vbldTID0gTWF0aC5tYXgoc3RhcnQuY2gsIGxpbmUudGV4dC5zZWFyY2goL1xcUy8pKTtcbiAgICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2g7XG4gICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIGluV1MgPyAwIDogZmlyc3ROb25XUywgc3RhcnQuc3RpY2t5KVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXG4gIGZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xuICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxuICAgIC8vIGNvbnNpc3RlbnQgdmlldyBvZiB0aGUgZG9jdW1lbnRcbiAgICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgIGlmIChkcm9wU2hpZnQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9XG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb25lXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShuYW1lLCBjbS5zdGF0ZS5rZXlNYXBzW2ldLCBoYW5kbGUsIGNtKTtcbiAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgfVxuICAgIHJldHVybiAoY20ub3B0aW9ucy5leHRyYUtleXMgJiYgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMuZXh0cmFLZXlzLCBoYW5kbGUsIGNtKSlcbiAgICAgIHx8IGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmtleU1hcCwgaGFuZGxlLCBjbSlcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCwgZGVzcGl0ZSB0aGUgbmFtZSwgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgdG8gY2hlY2tcbiAgLy8gZm9yIGJvdW5kIG1vdXNlIGNsaWNrcy5cblxuICB2YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkO1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIGlmIChpc01vZGlmaWVyS2V5KG5hbWUpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG4gICAgICBpZiAoL1xcJyQvLnRlc3QobmFtZSkpXG4gICAgICAgIHsgY20uc3RhdGUua2V5U2VxID0gbnVsbDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcbiAgICAgICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGw7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgfVxuICAgICAgaWYgKGRpc3BhdGNoS2V5SW5uZXIoY20sIHNlcSArIFwiIFwiICsgbmFtZSwgZSwgaGFuZGxlKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpXG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBcIm11bHRpXCIpXG4gICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7IH1cbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiKVxuICAgICAgeyBzaWduYWxMYXRlcihjbSwgXCJrZXlIYW5kbGVkXCIsIGNtLCBuYW1lLCBlKTsgfVxuXG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIiB8fCByZXN1bHQgPT0gXCJtdWx0aVwiKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISFyZXN1bHRcbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlkb3duIGV2ZW50LlxuICBmdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xuICAgIGlmICghbmFtZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlc29sdmUgZnVsbCBuYW1lIChpbmNsdWRpbmcgJ1NoaWZ0LScpLiBGYWlsaW5nXG4gICAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcbiAgICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiU2hpZnQtXCIgKyBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pXG4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYikgfVxuICAgICAgICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXCInXCIgKyBjaCArIFwiJ1wiLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgfVxuXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExICYmIGUua2V5Q29kZSA9PSAyNykgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xuICAgIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSk7XG4gICAgaWYgKHByZXN0bykge1xuICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XG4gICAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXG4gICAgICBpZiAoIWhhbmRsZWQgJiYgY29kZSA9PSA4OCAmJiAhaGFzQ29weUV2ZW50ICYmIChtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkpKVxuICAgICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICB9XG4gICAgaWYgKGdlY2tvICYmICFtYWMgJiYgIWhhbmRsZWQgJiYgY29kZSA9PSA0NiAmJiBlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpXG4gICAgICB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY3V0XCIpOyB9XG5cbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxuICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXG4gICAgICB7IHNob3dDcm9zc0hhaXIoY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XG4gICAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXY7XG4gICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcblxuICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSAxNikgeyB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTsgfVxuICAgIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XG4gICAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm59XG4gICAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XG4gICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUga2V5cHJlc3MgZXZlbnRzIGZvciBiYWNrc3BhY2VcbiAgICBpZiAoY2ggPT0gXCJcXHgwOFwiKSB7IHJldHVybiB9XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHsgcmV0dXJuIH1cbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XG4gIH1cblxuICB2YXIgRE9VQkxFQ0xJQ0tfREVMQVkgPSA0MDA7XG5cbiAgdmFyIFBhc3RDbGljayA9IGZ1bmN0aW9uKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgfTtcblxuICBQYXN0Q2xpY2sucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodGltZSwgcG9zLCBidXR0b24pIHtcbiAgICByZXR1cm4gdGhpcy50aW1lICsgRE9VQkxFQ0xJQ0tfREVMQVkgPiB0aW1lICYmXG4gICAgICBjbXAocG9zLCB0aGlzLnBvcykgPT0gMCAmJiBidXR0b24gPT0gdGhpcy5idXR0b25cbiAgfTtcblxuICB2YXIgbGFzdENsaWNrLCBsYXN0RG91YmxlQ2xpY2s7XG4gIGZ1bmN0aW9uIGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSB7XG4gICAgdmFyIG5vdyA9ICtuZXcgRGF0ZTtcbiAgICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICBsYXN0Q2xpY2sgPSBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwidHJpcGxlXCJcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3RDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJkb3VibGVcIlxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2xpY2sgPSBuZXcgUGFzdENsaWNrKG5vdywgcG9zLCBidXR0b24pO1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInNpbmdsZVwiXG4gICAgfVxuICB9XG5cbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcbiAgLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGRpc3BsYXkuYWN0aXZlVG91Y2ggJiYgZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpIHsgcmV0dXJuIH1cbiAgICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xuXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHtcbiAgICAgIGlmICghd2Via2l0KSB7XG4gICAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXG4gICAgICAgIC8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBidXR0b24gPSBlX2J1dHRvbihlKSwgcmVwZWF0ID0gcG9zID8gY2xpY2tSZXBlYXQocG9zLCBidXR0b24pIDogXCJzaW5nbGVcIjtcbiAgICB3aW5kb3cuZm9jdXMoKTtcblxuICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxuICAgIGlmIChidXR0b24gPT0gMSAmJiBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KVxuICAgICAgeyBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KGUpOyB9XG5cbiAgICBpZiAocG9zICYmIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGlmIChidXR0b24gPT0gMSkge1xuICAgICAgaWYgKHBvcykgeyBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGUpOyB9XG4gICAgICBlbHNlIGlmIChlX3RhcmdldChlKSA9PSBkaXNwbGF5LnNjcm9sbGVyKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PSAyKSB7XG4gICAgICBpZiAocG9zKSB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHBvcyk7IH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMykge1xuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7IGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTsgfVxuICAgICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFwiQ2xpY2tcIjtcbiAgICBpZiAocmVwZWF0ID09IFwiZG91YmxlXCIpIHsgbmFtZSA9IFwiRG91YmxlXCIgKyBuYW1lOyB9XG4gICAgZWxzZSBpZiAocmVwZWF0ID09IFwidHJpcGxlXCIpIHsgbmFtZSA9IFwiVHJpcGxlXCIgKyBuYW1lOyB9XG4gICAgbmFtZSA9IChidXR0b24gPT0gMSA/IFwiTGVmdFwiIDogYnV0dG9uID09IDIgPyBcIk1pZGRsZVwiIDogXCJSaWdodFwiKSArIG5hbWU7XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sICBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50KSwgZXZlbnQsIGZ1bmN0aW9uIChib3VuZCkge1xuICAgICAgaWYgKHR5cGVvZiBib3VuZCA9PSBcInN0cmluZ1wiKSB7IGJvdW5kID0gY29tbWFuZHNbYm91bmRdOyB9XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgeyBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gdHJ1ZTsgfVxuICAgICAgICBkb25lID0gYm91bmQoY20sIHBvcykgIT0gUGFzcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbiA9IGNtLmdldE9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIpO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbiA/IG9wdGlvbihjbSwgcmVwZWF0LCBldmVudCkgOiB7fTtcbiAgICBpZiAodmFsdWUudW5pdCA9PSBudWxsKSB7XG4gICAgICB2YXIgcmVjdCA9IGNocm9tZU9TID8gZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQubWV0YUtleSA6IGV2ZW50LmFsdEtleTtcbiAgICAgIHZhbHVlLnVuaXQgPSByZWN0ID8gXCJyZWN0YW5nbGVcIiA6IHJlcGVhdCA9PSBcInNpbmdsZVwiID8gXCJjaGFyXCIgOiByZXBlYXQgPT0gXCJkb3VibGVcIiA/IFwid29yZFwiIDogXCJsaW5lXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5leHRlbmQgPT0gbnVsbCB8fCBjbS5kb2MuZXh0ZW5kKSB7IHZhbHVlLmV4dGVuZCA9IGNtLmRvYy5leHRlbmQgfHwgZXZlbnQuc2hpZnRLZXk7IH1cbiAgICBpZiAodmFsdWUuYWRkTmV3ID09IG51bGwpIHsgdmFsdWUuYWRkTmV3ID0gbWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7IH1cbiAgICBpZiAodmFsdWUubW92ZU9uRHJhZyA9PSBudWxsKSB7IHZhbHVlLm1vdmVPbkRyYWcgPSAhKG1hYyA/IGV2ZW50LmFsdEtleSA6IGV2ZW50LmN0cmxLZXkpOyB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgaWYgKGllKSB7IHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTsgfVxuICAgIGVsc2UgeyBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpOyB9XG5cbiAgICB2YXIgYmVoYXZpb3IgPSBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCk7XG5cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgY29udGFpbmVkO1xuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFjbS5pc1JlYWRPbmx5KCkgJiZcbiAgICAgICAgcmVwZWF0ID09IFwic2luZ2xlXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhwb3MpKSA+IC0xICYmXG4gICAgICAgIChjbXAoKGNvbnRhaW5lZCA9IHNlbC5yYW5nZXNbY29udGFpbmVkXSkuZnJvbSgpLCBwb3MpIDwgMCB8fCBwb3MueFJlbCA+IDApICYmXG4gICAgICAgIChjbXAoY29udGFpbmVkLnRvKCksIHBvcykgPiAwIHx8IHBvcy54UmVsIDwgMCkpXG4gICAgICB7IGxlZnRCdXR0b25TdGFydERyYWcoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpOyB9XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcikge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbW92ZWQgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTsgfVxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpXG4gICAgICAgICAgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MsIG51bGwsIG51bGwsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxuICAgICAgICBpZiAoKHdlYmtpdCAmJiAhc2FmYXJpKSB8fCBpZSAmJiBpZV92ZXJzaW9uID09IDkpXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBtb3ZlZCA9IG1vdmVkIHx8IE1hdGguYWJzKGV2ZW50LmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBlMi5jbGllbnRZKSA+PSAxMDtcbiAgICB9O1xuICAgIHZhciBkcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlZCA9IHRydWU7IH07XG4gICAgLy8gTGV0IHRoZSBkcmFnIGhhbmRsZXIgaGFuZGxlIHRoaXMuXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgIGRyYWdFbmQuY29weSA9ICFiZWhhdmlvci5tb3ZlT25EcmFnO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG5cbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxuICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIikgeyByZXR1cm4gbmV3IFJhbmdlKHBvcywgcG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJ3b3JkXCIpIHsgcmV0dXJuIGNtLmZpbmRXb3JkQXQocG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XG4gICAgdmFyIHJlc3VsdCA9IHVuaXQoY20sIHBvcyk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHQuZnJvbSwgcmVzdWx0LnRvKVxuICB9XG5cbiAgLy8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgc3RhcnQsIGJlaGF2aW9yKSB7XG4gICAgaWYgKGllKSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGVfcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XG4gICAgaWYgKGJlaGF2aW9yLmFkZE5ldyAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpO1xuICAgICAgaWYgKG91ckluZGV4ID4gLTEpXG4gICAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZXNbb3VySW5kZXhdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKSB7XG4gICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOyB9XG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgb3VySW5kZXggPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBzdGFydCwgYmVoYXZpb3IudW5pdCk7XG4gICAgICBpZiAoYmVoYXZpb3IuZXh0ZW5kKVxuICAgICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2Uob3VyUmFuZ2UsIHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgYmVoYXZpb3IuZXh0ZW5kKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2U7IH1cbiAgICB9XG5cbiAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgb3VySW5kZXggPSAwO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XG4gICAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgYmVoYXZpb3IudW5pdCA9PSBcImNoYXJcIiAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgeyByZXR1cm4gfVxuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBwb3NDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQsIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbCk7XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XG4gICAgICAgICAgICAgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0TGluZShkb2MsIGxpbmUpLnRleHQsIGxlZnRQb3MgPSBmaW5kQ29sdW1uKHRleHQsIGxlZnQsIHRhYlNpemUpO1xuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxuICAgICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTsgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFwiKm1vdXNlXCIsIHNjcm9sbDogZmFsc2V9KTtcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZUZvclVuaXQoY20sIHBvcywgYmVoYXZpb3IudW5pdCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQ7XG4gICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcbiAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyQxID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBiaWRpU2ltcGxpZnkoY20sIG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCkpO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcyQxLCBvdXJJbmRleCksIHNlbF9tb3VzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcbiAgICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XG4gICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCBiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpO1xuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICAgIGV4dGVuZFRvKGN1cik7XG4gICAgICAgIHZhciB2aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYyk7XG4gICAgICAgIGlmIChjdXIubGluZSA+PSB2aXNpYmxlLnRvIHx8IGN1ci5saW5lIDwgdmlzaWJsZS5mcm9tKVxuICAgICAgICAgIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgeyBleHRlbmQoZSk7IH19KSwgMTUwKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwO1xuICAgICAgICBpZiAob3V0c2lkZSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSB7IHJldHVybiB9XG4gICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcbiAgICAgICAgICBleHRlbmQoZSk7XG4gICAgICAgIH0pLCA1MCk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKGUpIHtcbiAgICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZTtcbiAgICAgIGNvdW50ZXIgPSBJbmZpbml0eTtcbiAgICAgIC8vIElmIGUgaXMgbnVsbCBvciB1bmRlZmluZWQgd2UgaW50ZXJwcmV0IHRoaXMgYXMgc29tZW9uZSB0cnlpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0bHkgY2FuY2VsIHRoZSBzZWxlY3Rpb24gcmF0aGVyIHRoYW4gdGhlIHVzZXJcbiAgICAgIC8vIGxldHRpbmcgZ28gb2YgdGhlIG1vdXNlIGJ1dHRvbi5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gICAgICBkb2MuaGlzdG9yeS5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbW92ZSA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDAgfHwgIWVfYnV0dG9uKGUpKSB7IGRvbmUoZSk7IH1cbiAgICAgIGVsc2UgeyBleHRlbmQoZSk7IH1cbiAgICB9KTtcbiAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xuICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSB1cDtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gbW91c2Utc2VsZWN0aW5nIHRvIGFkanVzdCB0aGUgYW5jaG9yIHRvIHRoZSBwcm9wZXIgc2lkZVxuICAvLyBvZiBhIGJpZGkganVtcCBkZXBlbmRpbmcgb24gdGhlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgaGVhZC5cbiAgZnVuY3Rpb24gYmlkaVNpbXBsaWZ5KGNtLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgdmFyIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgIHZhciBhbmNob3JMaW5lID0gZ2V0TGluZShjbS5kb2MsIGFuY2hvci5saW5lKTtcbiAgICBpZiAoY21wKGFuY2hvciwgaGVhZCkgPT0gMCAmJiBhbmNob3Iuc3RpY2t5ID09IGhlYWQuc3RpY2t5KSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIoYW5jaG9yTGluZSk7XG4gICAgaWYgKCFvcmRlcikgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBpbmRleCA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGFuY2hvci5jaCwgYW5jaG9yLnN0aWNreSksIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgaWYgKHBhcnQuZnJvbSAhPSBhbmNob3IuY2ggJiYgcGFydC50byAhPSBhbmNob3IuY2gpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgYm91bmRhcnkgPSBpbmRleCArICgocGFydC5mcm9tID09IGFuY2hvci5jaCkgPT0gKHBhcnQubGV2ZWwgIT0gMSkgPyAwIDogMSk7XG4gICAgaWYgKGJvdW5kYXJ5ID09IDAgfHwgYm91bmRhcnkgPT0gb3JkZXIubGVuZ3RoKSB7IHJldHVybiByYW5nZSB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSByZWxhdGl2ZSB2aXN1YWwgcG9zaXRpb24gb2YgdGhlIGhlYWQgY29tcGFyZWQgdG8gdGhlXG4gICAgLy8gYW5jaG9yICg8MCBpcyB0byB0aGUgbGVmdCwgPjAgdG8gdGhlIHJpZ2h0KVxuICAgIHZhciBsZWZ0U2lkZTtcbiAgICBpZiAoaGVhZC5saW5lICE9IGFuY2hvci5saW5lKSB7XG4gICAgICBsZWZ0U2lkZSA9IChoZWFkLmxpbmUgLSBhbmNob3IubGluZSkgKiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiID8gMSA6IC0xKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZWFkSW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBoZWFkLmNoLCBoZWFkLnN0aWNreSk7XG4gICAgICB2YXIgZGlyID0gaGVhZEluZGV4IC0gaW5kZXggfHwgKGhlYWQuY2ggLSBhbmNob3IuY2gpICogKHBhcnQubGV2ZWwgPT0gMSA/IC0xIDogMSk7XG4gICAgICBpZiAoaGVhZEluZGV4ID09IGJvdW5kYXJ5IC0gMSB8fCBoZWFkSW5kZXggPT0gYm91bmRhcnkpXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPCAwOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPiAwOyB9XG4gICAgfVxuXG4gICAgdmFyIHVzZVBhcnQgPSBvcmRlcltib3VuZGFyeSArIChsZWZ0U2lkZSA/IC0xIDogMCldO1xuICAgIHZhciBmcm9tID0gbGVmdFNpZGUgPT0gKHVzZVBhcnQubGV2ZWwgPT0gMSk7XG4gICAgdmFyIGNoID0gZnJvbSA/IHVzZVBhcnQuZnJvbSA6IHVzZVBhcnQudG8sIHN0aWNreSA9IGZyb20gPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgIHJldHVybiBhbmNob3IuY2ggPT0gY2ggJiYgYW5jaG9yLnN0aWNreSA9PSBzdGlja3kgPyByYW5nZSA6IG5ldyBSYW5nZShuZXcgUG9zKGFuY2hvci5saW5lLCBjaCwgc3RpY2t5KSwgaGVhZClcbiAgfVxuXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xuICAgIHZhciBtWCwgbVk7XG4gICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgbVggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIG1ZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7IG1YID0gZS5jbGllbnRYOyBtWSA9IGUuY2xpZW50WTsgfVxuICAgICAgY2F0Y2goZSQxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAocHJldmVudCkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHsgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB9XG4gICAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZUF0SGVpZ2h0KGNtLmRvYywgbVkpO1xuICAgICAgICB2YXIgZ3V0dGVyID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXTtcbiAgICAgICAgc2lnbmFsKGNtLCB0eXBlLCBjbSwgbGluZSwgZ3V0dGVyLmNsYXNzTmFtZSwgZSk7XG4gICAgICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGlja0luR3V0dGVyKGNtLCBlKSB7XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNsaWNrXCIsIHRydWUpXG4gIH1cblxuICAvLyBDT05URVhUIE1FTlUgSEFORExJTkdcblxuICAvLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcbiAgLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxuICAvLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlLCBcImNvbnRleHRtZW51XCIpKSB7IHJldHVybiB9XG4gICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcbiAgICBpZiAoIWhhc0hhbmRsZXIoY20sIFwiZ3V0dGVyQ29udGV4dE1lbnVcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ29udGV4dE1lbnVcIiwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcbiAgICBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lID0gY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csIFwiXCIpICtcbiAgICAgIGNtLm9wdGlvbnMudGhlbWUucmVwbGFjZSgvKF58XFxzKVxccyovZywgXCIgY20tcy1cIik7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICB9XG5cbiAgdmFyIEluaXQgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5Jbml0XCJ9fTtcblxuICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0ge307XG5cbiAgZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcbiAgICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcbiAgICAgIGlmIChoYW5kbGUpIHsgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxuICAgICAgICBub3RPbkluaXQgPyBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSB7IGhhbmRsZShjbSwgdmFsLCBvbGQpOyB9fSA6IGhhbmRsZTsgfVxuICAgIH1cblxuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uO1xuXG4gICAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cbiAgICBDb2RlTWlycm9yLkluaXQgPSBJbml0O1xuXG4gICAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxuICAgIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cbiAgICBvcHRpb24oXCJ2YWx1ZVwiLCBcIlwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uc2V0VmFsdWUodmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibW9kZVwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWw7XG4gICAgICBsb2FkTW9kZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJpbmRlbnRVbml0XCIsIDIsIGxvYWRNb2RlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJpbmRlbnRXaXRoVGFic1wiLCBmYWxzZSk7XG4gICAgb3B0aW9uKFwic21hcnRJbmRlbnRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwidGFiU2l6ZVwiLCA0LCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJsaW5lU2VwYXJhdG9yXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kb2MubGluZVNlcCA9IHZhbDtcbiAgICAgIGlmICghdmFsKSB7IHJldHVybiB9XG4gICAgICB2YXIgbmV3QnJlYWtzID0gW10sIGxpbmVObyA9IGNtLmRvYy5maXJzdDtcbiAgICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IDA7Oykge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGxpbmUudGV4dC5pbmRleE9mKHZhbCwgcG9zKTtcbiAgICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHsgYnJlYWsgfVxuICAgICAgICAgIHBvcyA9IGZvdW5kICsgdmFsLmxlbmd0aDtcbiAgICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vLCBmb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVObysrO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gbmV3QnJlYWtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2ldLCBQb3MobmV3QnJlYWtzW2ldLmxpbmUsIG5ld0JyZWFrc1tpXS5jaCArIHZhbC5sZW5ndGgpKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyc1wiLCAvW1xcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXS9nLCBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7XG4gICAgICBjbS5zdGF0ZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKHZhbC5zb3VyY2UgKyAodmFsLnRlc3QoXCJcXHRcIikgPyBcIlwiIDogXCJ8XFx0XCIpLCBcImdcIik7XG4gICAgICBpZiAob2xkICE9IEluaXQpIHsgY20ucmVmcmVzaCgpOyB9XG4gICAgfSk7XG4gICAgb3B0aW9uKFwic3BlY2lhbENoYXJQbGFjZWhvbGRlclwiLCBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlciwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImVsZWN0cmljQ2hhcnNcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiaW5wdXRTdHlsZVwiLCBtb2JpbGUgPyBcImNvbnRlbnRlZGl0YWJsZVwiIDogXCJ0ZXh0YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFN0eWxlIGNhbiBub3QgKHlldCkgYmUgY2hhbmdlZCBpbiBhIHJ1bm5pbmcgZWRpdG9yXCIpIC8vIEZJWE1FXG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic3BlbGxjaGVja1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJhdXRvY29ycmVjdFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5hdXRvY29ycmVjdCA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NhcGl0YWxpemVcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NhcGl0YWxpemUgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCAhd2luZG93cyk7XG4gICAgb3B0aW9uKFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXCIsIHRydWUpO1xuXG4gICAgb3B0aW9uKFwidGhlbWVcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgdGhlbWVDaGFuZ2VkKGNtKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImtleU1hcFwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgdmFyIG5leHQgPSBnZXRLZXlNYXAodmFsKTtcbiAgICAgIHZhciBwcmV2ID0gb2xkICE9IEluaXQgJiYgZ2V0S2V5TWFwKG9sZCk7XG4gICAgICBpZiAocHJldiAmJiBwcmV2LmRldGFjaCkgeyBwcmV2LmRldGFjaChjbSwgbmV4dCk7IH1cbiAgICAgIGlmIChuZXh0LmF0dGFjaCkgeyBuZXh0LmF0dGFjaChjbSwgcHJldiB8fCBudWxsKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcImV4dHJhS2V5c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJjb25maWd1cmVNb3VzZVwiLCBudWxsKTtcblxuICAgIG9wdGlvbihcImxpbmVXcmFwcGluZ1wiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKTtcbiAgICBvcHRpb24oXCJndXR0ZXJzXCIsIFtdLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnModmFsLCBjbS5vcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpeGVkR3V0dGVyXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IHZhbCA/IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGNtLmRpc3BsYXkpICsgXCJweFwiIDogXCIwXCI7XG4gICAgICBjbS5yZWZyZXNoKCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNjcm9sbGJhclN0eWxlXCIsIFwibmF0aXZlXCIsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgaW5pdFNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSk7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGNtLmRvYy5zY3JvbGxUb3ApO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVOdW1iZXJzXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMoY20ub3B0aW9ucy5ndXR0ZXJzLCB2YWwpO1xuICAgICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZmlyc3RMaW5lTnVtYmVyXCIsIDEsIHVwZGF0ZUd1dHRlcnMsIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVOdW1iZXJGb3JtYXR0ZXJcIiwgZnVuY3Rpb24gKGludGVnZXIpIHsgcmV0dXJuIGludGVnZXI7IH0sIHVwZGF0ZUd1dHRlcnMsIHRydWUpO1xuICAgIG9wdGlvbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XCIsIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVXaXNlQ29weUN1dFwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uXCIsIHRydWUpO1xuICAgIG9wdGlvbihcInNlbGVjdGlvbnNNYXlUb3VjaFwiLCBmYWxzZSk7XG5cbiAgICBvcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gXCJub2N1cnNvclwiKSB7XG4gICAgICAgIG9uQmx1cihjbSk7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQodmFsKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbihcInNjcmVlblJlYWRlckxhYmVsXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICB2YWwgPSAodmFsID09PSAnJykgPyBudWxsIDogdmFsO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQodmFsKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbihcImRpc2FibGVJbnB1dFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7IH19LCB0cnVlKTtcbiAgICBvcHRpb24oXCJkcmFnRHJvcFwiLCB0cnVlLCBkcmFnRHJvcENoYW5nZWQpO1xuICAgIG9wdGlvbihcImFsbG93RHJvcEZpbGVUeXBlc1wiLCBudWxsKTtcblxuICAgIG9wdGlvbihcImN1cnNvckJsaW5rUmF0ZVwiLCA1MzApO1xuICAgIG9wdGlvbihcImN1cnNvclNjcm9sbE1hcmdpblwiLCAwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JIZWlnaHRcIiwgMSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwid29ya1RpbWVcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ3b3JrRGVsYXlcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJmbGF0dGVuU3BhbnNcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcImFkZE1vZGVDbGFzc1wiLCBmYWxzZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcInBvbGxJbnRlcnZhbFwiLCAxMDApO1xuICAgIG9wdGlvbihcInVuZG9EZXB0aFwiLCAyMDAsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kb2MuaGlzdG9yeS51bmRvRGVwdGggPSB2YWw7IH0pO1xuICAgIG9wdGlvbihcImhpc3RvcnlFdmVudERlbGF5XCIsIDEyNTApO1xuICAgIG9wdGlvbihcInZpZXdwb3J0TWFyZ2luXCIsIDEwLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZnJlc2goKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsIDEwMDAwLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgaWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKCk7IH1cbiAgICB9KTtcblxuICAgIG9wdGlvbihcInRhYmluZGV4XCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXCJcIjsgfSk7XG4gICAgb3B0aW9uKFwiYXV0b2ZvY3VzXCIsIG51bGwpO1xuICAgIG9wdGlvbihcImRpcmVjdGlvblwiLCBcImx0clwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLnNldERpcmVjdGlvbih2YWwpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJwaHJhc2VzXCIsIG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ0Ryb3BDaGFuZ2VkKGNtLCB2YWx1ZSwgb2xkKSB7XG4gICAgdmFyIHdhc09uID0gb2xkICYmIG9sZCAhPSBJbml0O1xuICAgIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XG4gICAgICB2YXIgZnVuY3MgPSBjbS5kaXNwbGF5LmRyYWdGdW5jdGlvbnM7XG4gICAgICB2YXIgdG9nZ2xlID0gdmFsdWUgPyBvbiA6IG9mZjtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBmdW5jcy5zdGFydCk7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnZW50ZXJcIiwgZnVuY3MuZW50ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ292ZXJcIiwgZnVuY3Mub3Zlcik7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnbGVhdmVcIiwgZnVuY3MubGVhdmUpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBmdW5jcy5kcm9wKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGluZ0NoYW5nZWQoY20pIHtcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXCJcIjtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgIGZpbmRNYXhMaW5lKGNtKTtcbiAgICB9XG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBjbGVhckNhY2hlcyhjbSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgMTAwKTtcbiAgfVxuXG4gIC8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XG4gIC8vIHRoYXQgdXNlciBjb2RlIGlzIHVzdWFsbHkgZGVhbGluZyB3aXRoLlxuXG4gIGZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSkgeyByZXR1cm4gbmV3IENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxuICAgIGNvcHlPYmooZGVmYXVsdHMsIG9wdGlvbnMsIGZhbHNlKTtcblxuICAgIHZhciBkb2MgPSBvcHRpb25zLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgZG9jID09IFwic3RyaW5nXCIpIHsgZG9jID0gbmV3IERvYyhkb2MsIG9wdGlvbnMubW9kZSwgbnVsbCwgb3B0aW9ucy5saW5lU2VwYXJhdG9yLCBvcHRpb25zLmRpcmVjdGlvbik7IH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm1vZGUpIHsgZG9jLm1vZGVPcHRpb24gPSBvcHRpb25zLm1vZGU7IH1cbiAgICB0aGlzLmRvYyA9IGRvYztcblxuICAgIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yLmlucHV0U3R5bGVzW29wdGlvbnMuaW5wdXRTdHlsZV0odGhpcyk7XG4gICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgZGlzcGxheS53cmFwcGVyLkNvZGVNaXJyb3IgPSB0aGlzO1xuICAgIHRoZW1lQ2hhbmdlZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICB7IHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcIiBDb2RlTWlycm9yLXdyYXBcIjsgfVxuICAgIGluaXRTY3JvbGxiYXJzKHRoaXMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGtleU1hcHM6IFtdLCAgLy8gc3RvcmVzIG1hcHMgYWRkZWQgYnkgYWRkS2V5TWFwXG4gICAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxuICAgICAgbW9kZUdlbjogMCwgICAvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxuICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0VkaXRzOiBmYWxzZSwgLy8gdXNlZCB0byBkaXNhYmxlIGVkaXRpbmcgZHVyaW5nIGtleSBoYW5kbGVycyB3aGVuIGluIHJlYWRPbmx5IG1vZGVcbiAgICAgIHBhc3RlSW5jb21pbmc6IC0xLCBjdXRJbmNvbWluZzogLTEsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXG4gICAgICBzZWxlY3RpbmdUZXh0OiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nVGV4dDogZmFsc2UsXG4gICAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcbiAgICAgIGtleVNlcTogbnVsbCwgIC8vIFVuZmluaXNoZWQga2V5IHNlcXVlbmNlXG4gICAgICBzcGVjaWFsQ2hhcnM6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG5cbiAgICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xuICAgIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IH1cblxuICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKTtcbiAgICBlbnN1cmVHbG9iYWxIYW5kbGVycygpO1xuXG4gICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XG5cbiAgICBpZiAoKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHx8IHRoaXMuaGFzRm9jdXMoKSlcbiAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzJDEuaGFzRm9jdXMoKSAmJiAhdGhpcyQxLnN0YXRlLmZvY3VzZWQpIHsgb25Gb2N1cyh0aGlzJDEpOyB9XG4gICAgICB9LCAyMCk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uQmx1cih0aGlzKTsgfVxuXG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbkhhbmRsZXJzKSB7IGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxuICAgICAgeyBvcHRpb25IYW5kbGVyc1tvcHRdKHRoaXMsIG9wdGlvbnNbb3B0XSwgSW5pdCk7IH0gfVxuICAgIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmZpbmlzaEluaXQpIHsgb3B0aW9ucy5maW5pc2hJbml0KHRoaXMpOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIHsgaW5pdEhvb2tzW2ldKHRoaXMpOyB9XG4gICAgZW5kT3BlcmF0aW9uKHRoaXMpO1xuICAgIC8vIFN1cHByZXNzIG9wdGltaXplbGVnaWJpbGl0eSBpbiBXZWJraXQsIHNpbmNlIGl0IGJyZWFrcyB0ZXh0XG4gICAgLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cbiAgICBpZiAod2Via2l0ICYmIG9wdGlvbnMubGluZVdyYXBwaW5nICYmXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nID09IFwib3B0aW1pemVsZWdpYmlsaXR5XCIpXG4gICAgICB7IGRpc3BsYXkubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXCJhdXRvXCI7IH1cbiAgfVxuXG4gIC8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgQ29kZU1pcnJvci5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAvLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cbiAgQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycyA9IG9wdGlvbkhhbmRsZXJzO1xuXG4gIC8vIEF0dGFjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBlZGl0b3JcbiAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2Vkb3duXCIsIG9wZXJhdGlvbihjbSwgb25Nb3VzZURvd24pKTtcbiAgICAvLyBPbGRlciBJRSdzIHdpbGwgbm90IGZpcmUgYSBzZWNvbmQgbW91c2Vkb3duIGZvciBhIGRvdWJsZSBjbGlja1xuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHZhciB3b3JkID0gY20uZmluZFdvcmRBdChwb3MpO1xuICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcbiAgICAgIH0pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pOyB9XG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGNvbnRleHRtZW51ICphZnRlciogb3BlbmluZyB0aGUgbWVudSwgYXRcbiAgICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXG4gICAgLy8gaGFuZGxlZCBpbiBvbk1vdXNlRG93biBmb3IgdGhlc2UgYnJvd3NlcnMuXG4gICAgb24oZC5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Db250ZXh0TWVudShjbSwgZSk7IH0pO1xuICAgIG9uKGQuaW5wdXQuZ2V0RmllbGQoKSwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFkLnNjcm9sbGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgeyBvbkNvbnRleHRNZW51KGNtLCBlKTsgfVxuICAgIH0pO1xuXG4gICAgLy8gVXNlZCB0byBzdXBwcmVzcyBtb3VzZSBldmVudCBoYW5kbGluZyB3aGVuIGEgdG91Y2ggaGFwcGVuc1xuICAgIHZhciB0b3VjaEZpbmlzaGVkLCBwcmV2VG91Y2ggPSB7ZW5kOiAwfTtcbiAgICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcbiAgICAgIGlmIChkLmFjdGl2ZVRvdWNoKSB7XG4gICAgICAgIHRvdWNoRmluaXNoZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQuYWN0aXZlVG91Y2ggPSBudWxsOyB9LCAxMDAwKTtcbiAgICAgICAgcHJldlRvdWNoID0gZC5hY3RpdmVUb3VjaDtcbiAgICAgICAgcHJldlRvdWNoLmVuZCA9ICtuZXcgRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB0b3VjaC5yYWRpdXNYIDw9IDEgJiYgdG91Y2gucmFkaXVzWSA8PSAxXG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhckF3YXkodG91Y2gsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIubGVmdCA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjBcbiAgICB9XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSAmJiAhaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpICYmICFjbGlja0luR3V0dGVyKGNtLCBlKSkge1xuICAgICAgICBkLmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodG91Y2hGaW5pc2hlZCk7XG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgICAgIGQuYWN0aXZlVG91Y2ggPSB7c3RhcnQ6IG5vdywgbW92ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHByZXY6IG5vdyAtIHByZXZUb3VjaC5lbmQgPD0gMzAwID8gcHJldlRvdWNoIDogbnVsbH07XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoLmxlZnQgPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC50b3AgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkgeyBkLmFjdGl2ZVRvdWNoLm1vdmVkID0gdHJ1ZTsgfVxuICAgIH0pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0b3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmXG4gICAgICAgICAgIXRvdWNoLm1vdmVkICYmIG5ldyBEYXRlIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoZC5hY3RpdmVUb3VjaCwgXCJwYWdlXCIpLCByYW5nZTtcbiAgICAgICAgaWYgKCF0b3VjaC5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYpKSAvLyBTaW5nbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShwb3MsIHBvcyk7IH1cbiAgICAgICAgZWxzZSBpZiAoIXRvdWNoLnByZXYucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2LnByZXYpKSAvLyBEb3VibGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKTsgfVxuICAgICAgICBlbHNlIC8vIFRyaXBsZSB0YXBcbiAgICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpOyB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihyYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQpO1xuICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgfVxuICAgICAgZmluaXNoVG91Y2goKTtcbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoY2FuY2VsXCIsIGZpbmlzaFRvdWNoKTtcblxuICAgIC8vIFN5bmMgc2Nyb2xsaW5nIGJldHdlZW4gZmFrZSBzY3JvbGxiYXJzIGFuZCByZWFsIHNjcm9sbGFibGVcbiAgICAvLyBhcmVhLCBlbnN1cmUgdmlld3BvcnQgaXMgdXBkYXRlZCB3aGVuIHNjcm9sbGluZy5cbiAgICBvbihkLnNjcm9sbGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsVG9wKGNtLCBkLnNjcm9sbGVyLnNjcm9sbFRvcCk7XG4gICAgICAgIHNldFNjcm9sbExlZnQoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdHJ1ZSk7XG4gICAgICAgIHNpZ25hbChjbSwgXCJzY3JvbGxcIiwgY20pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIHRvIHdoZWVsIGV2ZW50cyBpbiBvcmRlciB0byB0cnkgYW5kIHVwZGF0ZSB0aGUgdmlld3BvcnQgb24gdGltZS5cbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNld2hlZWxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIkRPTU1vdXNlU2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG5cbiAgICAvLyBQcmV2ZW50IHdyYXBwZXIgZnJvbSBldmVyIHNjcm9sbGluZ1xuICAgIG9uKGQud3JhcHBlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53cmFwcGVyLnNjcm9sbFRvcCA9IGQud3JhcHBlci5zY3JvbGxMZWZ0ID0gMDsgfSk7XG5cbiAgICBkLmRyYWdGdW5jdGlvbnMgPSB7XG4gICAgICBlbnRlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBlX3N0b3AoZSk7IH19LFxuICAgICAgb3ZlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBvbkRyYWdPdmVyKGNtLCBlKTsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25EcmFnU3RhcnQoY20sIGUpOyB9LFxuICAgICAgZHJvcDogb3BlcmF0aW9uKGNtLCBvbkRyb3ApLFxuICAgICAgbGVhdmU6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgY2xlYXJEcmFnQ3Vyc29yKGNtKTsgfX1cbiAgICB9O1xuXG4gICAgdmFyIGlucCA9IGQuaW5wdXQuZ2V0RmllbGQoKTtcbiAgICBvbihpbnAsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uS2V5VXAuY2FsbChjbSwgZSk7IH0pO1xuICAgIG9uKGlucCwgXCJrZXlkb3duXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSk7XG4gICAgb24oaW5wLCBcImtleXByZXNzXCIsIG9wZXJhdGlvbihjbSwgb25LZXlQcmVzcykpO1xuICAgIG9uKGlucCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Gb2N1cyhjbSwgZSk7IH0pO1xuICAgIG9uKGlucCwgXCJibHVyXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkJsdXIoY20sIGUpOyB9KTtcbiAgfVxuXG4gIHZhciBpbml0SG9va3MgPSBbXTtcbiAgQ29kZU1pcnJvci5kZWZpbmVJbml0SG9vayA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBpbml0SG9va3MucHVzaChmKTsgfTtcblxuICAvLyBJbmRlbnQgdGhlIGdpdmVuIGxpbmUuIFRoZSBob3cgcGFyYW1ldGVyIGNhbiBiZSBcInNtYXJ0XCIsXG4gIC8vIFwiYWRkXCIvbnVsbCwgXCJzdWJ0cmFjdFwiLCBvciBcInByZXZcIi4gV2hlbiBhZ2dyZXNzaXZlIGlzIGZhbHNlXG4gIC8vICh0eXBpY2FsbHkgc2V0IHRvIHRydWUgZm9yIGZvcmNlZCBzaW5nbGUtbGluZSBpbmRlbnRzKSwgZW1wdHlcbiAgLy8gbGluZXMgYXJlIG5vdCBpbmRlbnRlZCwgYW5kIHBsYWNlcyB3aGVyZSB0aGUgbW9kZSByZXR1cm5zIFBhc3NcbiAgLy8gYXJlIGxlZnQgYWxvbmUuXG4gIGZ1bmN0aW9uIGluZGVudExpbmUoY20sIG4sIGhvdywgYWdncmVzc2l2ZSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlO1xuICAgIGlmIChob3cgPT0gbnVsbCkgeyBob3cgPSBcImFkZFwiOyB9XG4gICAgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBcInByZXZcIiB3aGVuIHRoZSBtb2RlIGRvZXNuJ3QgaGF2ZSBhbiBpbmRlbnRhdGlvblxuICAgICAgLy8gbWV0aG9kLlxuICAgICAgaWYgKCFkb2MubW9kZS5pbmRlbnQpIHsgaG93ID0gXCJwcmV2XCI7IH1cbiAgICAgIGVsc2UgeyBzdGF0ZSA9IGdldENvbnRleHRCZWZvcmUoY20sIG4pLnN0YXRlOyB9XG4gICAgfVxuXG4gICAgdmFyIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICB2YXIgY3VyU3BhY2VTdHJpbmcgPSBsaW5lLnRleHQubWF0Y2goL15cXHMqLylbMF0sIGluZGVudGF0aW9uO1xuICAgIGlmICghYWdncmVzc2l2ZSAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQpKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IDA7XG4gICAgICBob3cgPSBcIm5vdFwiO1xuICAgIH0gZWxzZSBpZiAoaG93ID09IFwic21hcnRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBkb2MubW9kZS5pbmRlbnQoc3RhdGUsIGxpbmUudGV4dC5zbGljZShjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBsaW5lLnRleHQpO1xuICAgICAgaWYgKGluZGVudGF0aW9uID09IFBhc3MgfHwgaW5kZW50YXRpb24gPiAxNTApIHtcbiAgICAgICAgaWYgKCFhZ2dyZXNzaXZlKSB7IHJldHVybiB9XG4gICAgICAgIGhvdyA9IFwicHJldlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaG93ID09IFwicHJldlwiKSB7XG4gICAgICBpZiAobiA+IGRvYy5maXJzdCkgeyBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpOyB9XG4gICAgICBlbHNlIHsgaW5kZW50YXRpb24gPSAwOyB9XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJhZGRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInN1YnRyYWN0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBob3c7XG4gICAgfVxuICAgIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xuXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXG4gICAgICB7IGZvciAodmFyIGkgPSBNYXRoLmZsb29yKGluZGVudGF0aW9uIC8gdGFiU2l6ZSk7IGk7IC0taSkge3BvcyArPSB0YWJTaXplOyBpbmRlbnRTdHJpbmcgKz0gXCJcXHRcIjt9IH1cbiAgICBpZiAocG9zIDwgaW5kZW50YXRpb24pIHsgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTsgfVxuXG4gICAgaWYgKGluZGVudFN0cmluZyAhPSBjdXJTcGFjZVN0cmluZykge1xuICAgICAgcmVwbGFjZVJhbmdlKGRvYywgaW5kZW50U3RyaW5nLCBQb3MobiwgMCksIFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBcIitpbnB1dFwiKTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnNvciB3YXMgaW4gdGhlIHdoaXRlc3BhY2UgYXQgdGhlIHN0YXJ0XG4gICAgICAvLyBvZiB0aGUgbGluZSwgaXQgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGF0IHNwYWNlLlxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwb3MkMSA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpJDEsIG5ldyBSYW5nZShwb3MkMSwgcG9zJDEpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGJlIHNldCB0byBhIHtsaW5lV2lzZTogYm9vbCwgdGV4dDogW3N0cmluZ119IG9iamVjdCwgc29cbiAgLy8gdGhhdCwgd2hlbiBwYXN0aW5nLCB3ZSBrbm93IHdoYXQga2luZCBvZiBzZWxlY3Rpb25zIHRoZSBjb3BpZWRcbiAgLy8gdGV4dCB3YXMgbWFkZSBvdXQgb2YuXG4gIHZhciBsYXN0Q29waWVkID0gbnVsbDtcblxuICBmdW5jdGlvbiBzZXRMYXN0Q29waWVkKG5ld0xhc3RDb3BpZWQpIHtcbiAgICBsYXN0Q29waWVkID0gbmV3TGFzdENvcGllZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VGV4dElucHV0KGNtLCBpbnNlcnRlZCwgZGVsZXRlZCwgc2VsLCBvcmlnaW4pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcbiAgICBpZiAoIXNlbCkgeyBzZWwgPSBkb2Muc2VsOyB9XG5cbiAgICB2YXIgcmVjZW50ID0gK25ldyBEYXRlIC0gMjAwO1xuICAgIHZhciBwYXN0ZSA9IG9yaWdpbiA9PSBcInBhc3RlXCIgfHwgY20uc3RhdGUucGFzdGVJbmNvbWluZyA+IHJlY2VudDtcbiAgICB2YXIgdGV4dExpbmVzID0gc3BsaXRMaW5lc0F1dG8oaW5zZXJ0ZWQpLCBtdWx0aVBhc3RlID0gbnVsbDtcbiAgICAvLyBXaGVuIHBhc3RpbmcgTiBsaW5lcyBpbnRvIE4gc2VsZWN0aW9ucywgaW5zZXJ0IG9uZSBsaW5lIHBlciBzZWxlY3Rpb25cbiAgICBpZiAocGFzdGUgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAobGFzdENvcGllZCAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSBpbnNlcnRlZCkge1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggJSBsYXN0Q29waWVkLnRleHQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBtdWx0aVBhc3RlID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0Q29waWVkLnRleHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7IG11bHRpUGFzdGUucHVzaChkb2Muc3BsaXRMaW5lcyhsYXN0Q29waWVkLnRleHRbaV0pKTsgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRleHRMaW5lcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiYgY20ub3B0aW9ucy5wYXN0ZUxpbmVzUGVyU2VsZWN0aW9uKSB7XG4gICAgICAgIG11bHRpUGFzdGUgPSBtYXAodGV4dExpbmVzLCBmdW5jdGlvbiAobCkgeyByZXR1cm4gW2xdOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5wdXQgPSBjbS5jdXJPcC51cGRhdGVJbnB1dDtcbiAgICAvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxuICAgIGZvciAodmFyIGkkMSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2kkMV07XG4gICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgaWYgKGRlbGV0ZWQgJiYgZGVsZXRlZCA+IDApIC8vIEhhbmRsZSBkZWxldGlvblxuICAgICAgICAgIHsgZnJvbSA9IFBvcyhmcm9tLmxpbmUsIGZyb20uY2ggLSBkZWxldGVkKTsgfVxuICAgICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXG4gICAgICAgICAgeyB0byA9IFBvcyh0by5saW5lLCBNYXRoLm1pbihnZXRMaW5lKGRvYywgdG8ubGluZSkudGV4dC5sZW5ndGgsIHRvLmNoICsgbHN0KHRleHRMaW5lcykubGVuZ3RoKSk7IH1cbiAgICAgICAgZWxzZSBpZiAocGFzdGUgJiYgbGFzdENvcGllZCAmJiBsYXN0Q29waWVkLmxpbmVXaXNlICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpID09IHRleHRMaW5lcy5qb2luKFwiXFxuXCIpKVxuICAgICAgICAgIHsgZnJvbSA9IHRvID0gUG9zKGZyb20ubGluZSwgMCk7IH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IG11bHRpUGFzdGUgPyBtdWx0aVBhc3RlW2kkMSAlIG11bHRpUGFzdGUubGVuZ3RoXSA6IHRleHRMaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbiB8fCAocGFzdGUgPyBcInBhc3RlXCIgOiBjbS5zdGF0ZS5jdXRJbmNvbWluZyA+IHJlY2VudCA/IFwiY3V0XCIgOiBcIitpbnB1dFwiKX07XG4gICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlRXZlbnQpO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwiaW5wdXRSZWFkXCIsIGNtLCBjaGFuZ2VFdmVudCk7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpXG4gICAgICB7IHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpOyB9XG5cbiAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICBpZiAoY20uY3VyT3AudXBkYXRlSW5wdXQgPCAyKSB7IGNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gdXBkYXRlSW5wdXQ7IH1cbiAgICBjbS5jdXJPcC50eXBpbmcgPSB0cnVlO1xuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSwgY20pIHtcbiAgICB2YXIgcGFzdGVkID0gZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICBpZiAocGFzdGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpXG4gICAgICAgIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwbHlUZXh0SW5wdXQoY20sIHBhc3RlZCwgMCwgbnVsbCwgXCJwYXN0ZVwiKTsgfSk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkge1xuICAgIC8vIFdoZW4gYW4gJ2VsZWN0cmljJyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGltbWVkaWF0ZWx5IHRyaWdnZXIgYSByZWluZGVudFxuICAgIGlmICghY20ub3B0aW9ucy5lbGVjdHJpY0NoYXJzIHx8ICFjbS5vcHRpb25zLnNtYXJ0SW5kZW50KSB7IHJldHVybiB9XG4gICAgdmFyIHNlbCA9IGNtLmRvYy5zZWw7XG5cbiAgICBmb3IgKHZhciBpID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5oZWFkLmNoID4gMTAwIHx8IChpICYmIHNlbC5yYW5nZXNbaSAtIDFdLmhlYWQubGluZSA9PSByYW5nZS5oZWFkLmxpbmUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBtb2RlID0gY20uZ2V0TW9kZUF0KHJhbmdlLmhlYWQpO1xuICAgICAgdmFyIGluZGVudGVkID0gZmFsc2U7XG4gICAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW9kZS5lbGVjdHJpY0NoYXJzLmxlbmd0aDsgaisrKVxuICAgICAgICAgIHsgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xuICAgICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gfVxuICAgICAgfSBlbHNlIGlmIChtb2RlLmVsZWN0cmljSW5wdXQpIHtcbiAgICAgICAgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dC50ZXN0KGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQuc2xpY2UoMCwgcmFuZ2UuaGVhZC5jaCkpKVxuICAgICAgICAgIHsgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRlbnRlZCkgeyBzaWduYWxMYXRlcihjbSwgXCJlbGVjdHJpY0lucHV0XCIsIGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcbiAgICB2YXIgdGV4dCA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcbiAgICAgIHZhciBsaW5lUmFuZ2UgPSB7YW5jaG9yOiBQb3MobGluZSwgMCksIGhlYWQ6IFBvcyhsaW5lICsgMSwgMCl9O1xuICAgICAgcmFuZ2VzLnB1c2gobGluZVJhbmdlKTtcbiAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHQ6IHRleHQsIHJhbmdlczogcmFuZ2VzfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZUJyb3dzZXJNYWdpYyhmaWVsZCwgc3BlbGxjaGVjaywgYXV0b2NvcnJlY3QsIGF1dG9jYXBpdGFsaXplKSB7XG4gICAgZmllbGQuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgYXV0b2NvcnJlY3QgPyBcIlwiIDogXCJvZmZcIik7XG4gICAgZmllbGQuc2V0QXR0cmlidXRlKFwiYXV0b2NhcGl0YWxpemVcIiwgYXV0b2NhcGl0YWxpemUgPyBcIlwiIDogXCJvZmZcIik7XG4gICAgZmllbGQuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCAhIXNwZWxsY2hlY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZGVuVGV4dGFyZWEoKSB7XG4gICAgdmFyIHRlID0gZWx0KFwidGV4dGFyZWFcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogLTFlbTsgcGFkZGluZzogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxZW07IG1pbi1oZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICB2YXIgZGl2ID0gZWx0KFwiZGl2XCIsIFt0ZV0sIG51bGwsIFwib3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogM3B4OyBoZWlnaHQ6IDBweDtcIik7XG4gICAgLy8gVGhlIHRleHRhcmVhIGlzIGtlcHQgcG9zaXRpb25lZCBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCB0aGVcbiAgICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXG4gICAgLy8gb3VyIGZha2UgY3Vyc29yIG91dCBvZiB2aWV3LiBPbiB3ZWJraXQsIHdoZW4gd3JhcD1vZmYsIHBhc3RlIGlzXG4gICAgLy8gdmVyeSBzbG93LiBTbyBtYWtlIHRoZSBhcmVhIHdpZGUgaW5zdGVhZC5cbiAgICBpZiAod2Via2l0KSB7IHRlLnN0eWxlLndpZHRoID0gXCIxMDAwcHhcIjsgfVxuICAgIGVsc2UgeyB0ZS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsIFwib2ZmXCIpOyB9XG4gICAgLy8gSWYgYm9yZGVyOiAwOyAtLSBpT1MgZmFpbHMgdG8gb3BlbiBrZXlib2FyZCAoaXNzdWUgIzEyODcpXG4gICAgaWYgKGlvcykgeyB0ZS5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCBibGFja1wiOyB9XG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSk7XG4gICAgcmV0dXJuIGRpdlxuICB9XG5cbiAgLy8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcbiAgLy8gJ3dyYXAgZiBpbiBhbiBvcGVyYXRpb24sIHBlcmZvcm1lZCBvbiBpdHMgYHRoaXNgIHBhcmFtZXRlcicuXG5cbiAgLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcbiAgLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXG4gIC8vIENvZGVNaXJyb3IucHJvdG90eXBlLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kXG4gIC8vIGNvbnZlbmllbmNlLlxuXG4gIGZ1bmN0aW9uIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcikge1xuICAgIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XG5cbiAgICB2YXIgaGVscGVycyA9IENvZGVNaXJyb3IuaGVscGVycyA9IHt9O1xuXG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogQ29kZU1pcnJvcixcbiAgICAgIGZvY3VzOiBmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpOyB0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LFxuXG4gICAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIG9sZCA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PSB2YWx1ZSAmJiBvcHRpb24gIT0gXCJtb2RlXCIpIHsgcmV0dXJuIH1cbiAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKVxuICAgICAgICAgIHsgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpOyB9XG4gICAgICAgIHNpZ25hbCh0aGlzLCBcIm9wdGlvbkNoYW5nZVwiLCB0aGlzLCBvcHRpb24pO1xuICAgICAgfSxcblxuICAgICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24pIHtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl19LFxuICAgICAgZ2V0RG9jOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5kb2N9LFxuXG4gICAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uKG1hcCwgYm90dG9tKSB7XG4gICAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXShnZXRLZXlNYXAobWFwKSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICB7IGlmIChtYXBzW2ldID09IG1hcCB8fCBtYXBzW2ldLm5hbWUgPT0gbWFwKSB7XG4gICAgICAgICAgICBtYXBzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSB9XG4gICAgICB9LFxuXG4gICAgICBhZGRPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2RlID0gc3BlYy50b2tlbiA/IHNwZWMgOiBDb2RlTWlycm9yLmdldE1vZGUodGhpcy5vcHRpb25zLCBzcGVjKTtcbiAgICAgICAgaWYgKG1vZGUuc3RhcnRTdGF0ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKSB9XG4gICAgICAgIGluc2VydFNvcnRlZCh0aGlzLnN0YXRlLm92ZXJsYXlzLFxuICAgICAgICAgICAgICAgICAgICAge21vZGU6IG1vZGUsIG1vZGVTcGVjOiBzcGVjLCBvcGFxdWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcGFxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IChvcHRpb25zICYmIG9wdGlvbnMucHJpb3JpdHkpIHx8IDB9LFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG92ZXJsYXkpIHsgcmV0dXJuIG92ZXJsYXkucHJpb3JpdHk7IH0pO1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgfSksXG4gICAgICByZW1vdmVPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuc3RhdGUub3ZlcmxheXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxheXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgY3VyID0gb3ZlcmxheXNbaV0ubW9kZVNwZWM7XG4gICAgICAgICAgaWYgKGN1ciA9PSBzcGVjIHx8IHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgY3VyLm5hbWUgPT0gc3BlYykge1xuICAgICAgICAgICAgb3ZlcmxheXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBpbmRlbnRMaW5lOiBtZXRob2RPcChmdW5jdGlvbihuLCBkaXIsIGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXIgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZGlyICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAoZGlyID09IG51bGwpIHsgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXCJzbWFydFwiIDogXCJwcmV2XCI7IH1cbiAgICAgICAgICBlbHNlIHsgZGlyID0gZGlyID8gXCJhZGRcIiA6IFwic3VidHJhY3RcIjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmUodGhpcy5kb2MsIG4pKSB7IGluZGVudExpbmUodGhpcywgbiwgZGlyLCBhZ2dyZXNzaXZlKTsgfVxuICAgICAgfSksXG4gICAgICBpbmRlbnRTZWxlY3Rpb246IG1ldGhvZE9wKGZ1bmN0aW9uKGhvdykge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KGVuZCwgZnJvbS5saW5lKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDwgZW5kOyArK2opXG4gICAgICAgICAgICAgIHsgaW5kZW50TGluZSh0aGlzLCBqLCBob3cpOyB9XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcztcbiAgICAgICAgICAgIGlmIChmcm9tLmNoID09IDAgJiYgcmFuZ2VzLmxlbmd0aCA9PSBuZXdSYW5nZXMubGVuZ3RoICYmIG5ld1Jhbmdlc1tpXS5mcm9tKCkuY2ggPiAwKVxuICAgICAgICAgICAgICB7IHJlcGxhY2VPbmVTZWxlY3Rpb24odGhpcy5kb2MsIGksIG5ldyBSYW5nZShmcm9tLCBuZXdSYW5nZXNbaV0udG8oKSksIHNlbF9kb250U2Nyb2xsKTsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaGVhZC5saW5lID4gZW5kKSB7XG4gICAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIHJhbmdlLmhlYWQubGluZSwgaG93LCB0cnVlKTtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlLmhlYWQubGluZTtcbiAgICAgICAgICAgIGlmIChpID09IHRoaXMuZG9jLnNlbC5wcmltSW5kZXgpIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXG4gICAgICAvLyB0aGF0IHdhbnQgdG8gaW5zcGVjdCB0aGUgbW9kZSBzdGF0ZSAoc2F5LCBmb3IgY29tcGxldGlvbikuXG4gICAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbihwb3MsIHByZWNpc2UpIHtcbiAgICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBwb3MsIHByZWNpc2UpXG4gICAgICB9LFxuXG4gICAgICBnZXRMaW5lVG9rZW5zOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgUG9zKGxpbmUpLCBwcmVjaXNlLCB0cnVlKVxuICAgICAgfSxcblxuICAgICAgZ2V0VG9rZW5UeXBlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpO1xuICAgICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpO1xuICAgICAgICB2YXIgYmVmb3JlID0gMCwgYWZ0ZXIgPSAoc3R5bGVzLmxlbmd0aCAtIDEpIC8gMiwgY2ggPSBwb3MuY2g7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICBpZiAoY2ggPT0gMCkgeyB0eXBlID0gc3R5bGVzWzJdOyB9XG4gICAgICAgIGVsc2UgeyBmb3IgKDs7KSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChiZWZvcmUgKyBhZnRlcikgPj4gMTtcbiAgICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgeyBhZnRlciA9IG1pZDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0eWxlc1ttaWQgKiAyICsgMV0gPCBjaCkgeyBiZWZvcmUgPSBtaWQgKyAxOyB9XG4gICAgICAgICAgZWxzZSB7IHR5cGUgPSBzdHlsZXNbbWlkICogMiArIDJdOyBicmVhayB9XG4gICAgICAgIH0gfVxuICAgICAgICB2YXIgY3V0ID0gdHlwZSA/IHR5cGUuaW5kZXhPZihcIm92ZXJsYXkgXCIpIDogLTE7XG4gICAgICAgIHJldHVybiBjdXQgPCAwID8gdHlwZSA6IGN1dCA9PSAwID8gbnVsbCA6IHR5cGUuc2xpY2UoMCwgY3V0IC0gMSlcbiAgICAgIH0sXG5cbiAgICAgIGdldE1vZGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZTtcbiAgICAgICAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gbW9kZSB9XG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCB0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZVxuICAgICAgfSxcblxuICAgICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVscGVycyhwb3MsIHR5cGUpWzBdXG4gICAgICB9LFxuXG4gICAgICBnZXRIZWxwZXJzOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gW107XG4gICAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyByZXR1cm4gZm91bmQgfVxuICAgICAgICB2YXIgaGVscCA9IGhlbHBlcnNbdHlwZV0sIG1vZGUgPSB0aGlzLmdldE1vZGVBdChwb3MpO1xuICAgICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSB7IGZvdW5kLnB1c2goaGVscFttb2RlW3R5cGVdXSk7IH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlW3R5cGVdKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlW3R5cGVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXTtcbiAgICAgICAgICAgIGlmICh2YWwpIHsgZm91bmQucHVzaCh2YWwpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUuaGVscGVyVHlwZSAmJiBoZWxwW21vZGUuaGVscGVyVHlwZV0pIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5oZWxwZXJUeXBlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVscFttb2RlLm5hbWVdKSB7XG4gICAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUubmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhlbHAuX2dsb2JhbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IGhlbHAuX2dsb2JhbFtpJDFdO1xuICAgICAgICAgIGlmIChjdXIucHJlZChtb2RlLCB0aGlzKSAmJiBpbmRleE9mKGZvdW5kLCBjdXIudmFsKSA9PSAtMSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChjdXIudmFsKTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZFxuICAgICAgfSxcblxuICAgICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIGxpbmUgPSBjbGlwTGluZShkb2MsIGxpbmUgPT0gbnVsbCA/IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTogbGluZSk7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0QmVmb3JlKHRoaXMsIGxpbmUgKyAxLCBwcmVjaXNlKS5zdGF0ZVxuICAgICAgfSxcblxuICAgICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xuICAgICAgICB2YXIgcG9zLCByYW5nZSA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHBvcyA9IHJhbmdlLmhlYWQ7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFwib2JqZWN0XCIpIHsgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgc3RhcnQpOyB9XG4gICAgICAgIGVsc2UgeyBwb3MgPSBzdGFydCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7IH1cbiAgICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXCJwYWdlXCIpXG4gICAgICB9LFxuXG4gICAgICBjaGFyQ29vcmRzOiBmdW5jdGlvbihwb3MsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcInBhZ2VcIilcbiAgICAgIH0sXG5cbiAgICAgIGNvb3Jkc0NoYXI6IGZ1bmN0aW9uKGNvb3JkcywgbW9kZSkge1xuICAgICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFwicGFnZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApXG4gICAgICB9LFxuXG4gICAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xuICAgICAgICBoZWlnaHQgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywge3RvcDogaGVpZ2h0LCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wO1xuICAgICAgICByZXR1cm4gbGluZUF0SGVpZ2h0KHRoaXMuZG9jLCBoZWlnaHQgKyB0aGlzLmRpc3BsYXkudmlld09mZnNldClcbiAgICAgIH0sXG4gICAgICBoZWlnaHRBdExpbmU6IGZ1bmN0aW9uKGxpbmUsIG1vZGUsIGluY2x1ZGVXaWRnZXRzKSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGluZU9iajtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDE7XG4gICAgICAgICAgaWYgKGxpbmUgPCB0aGlzLmRvYy5maXJzdCkgeyBsaW5lID0gdGhpcy5kb2MuZmlyc3Q7IH1cbiAgICAgICAgICBlbHNlIGlmIChsaW5lID4gbGFzdCkgeyBsaW5lID0gbGFzdDsgZW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lT2JqID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKHRoaXMsIGxpbmVPYmosIHt0b3A6IDAsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiLCBpbmNsdWRlV2lkZ2V0cyB8fCBlbmQpLnRvcCArXG4gICAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApXG4gICAgICB9LFxuXG4gICAgICBkZWZhdWx0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7IHJldHVybiB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkgfSxcbiAgICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSkgfSxcblxuICAgICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge2Zyb206IHRoaXMuZGlzcGxheS52aWV3RnJvbSwgdG86IHRoaXMuZGlzcGxheS52aWV3VG99fSxcblxuICAgICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcbiAgICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXk7XG4gICAgICAgIHBvcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpKTtcbiAgICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICAgIGRpc3BsYXkuc2l6ZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGlmICh2ZXJ0ID09IFwib3ZlclwiKSB7XG4gICAgICAgICAgdG9wID0gcG9zLnRvcDtcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJ0ID09IFwiYWJvdmVcIiB8fCB2ZXJ0ID09IFwibmVhclwiKSB7XG4gICAgICAgICAgdmFyIHZzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHRoaXMuZG9jLmhlaWdodCksXG4gICAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xuICAgICAgICAgIC8vIERlZmF1bHQgdG8gcG9zaXRpb25pbmcgYWJvdmUgKGlmIHNwZWNpZmllZCBhbmQgcG9zc2libGUpOyBvdGhlcndpc2UgZGVmYXVsdCB0byBwb3NpdGlvbmluZyBiZWxvd1xuICAgICAgICAgIGlmICgodmVydCA9PSAnYWJvdmUnIHx8IHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA+IHZzcGFjZSkgJiYgcG9zLnRvcCA+IG5vZGUub2Zmc2V0SGVpZ2h0KVxuICAgICAgICAgICAgeyB0b3AgPSBwb3MudG9wIC0gbm9kZS5vZmZzZXRIZWlnaHQ7IH1cbiAgICAgICAgICBlbHNlIGlmIChwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPD0gdnNwYWNlKVxuICAgICAgICAgICAgeyB0b3AgPSBwb3MuYm90dG9tOyB9XG4gICAgICAgICAgaWYgKGxlZnQgKyBub2RlLm9mZnNldFdpZHRoID4gaHNwYWNlKVxuICAgICAgICAgICAgeyBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aDsgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgaWYgKGhvcml6ID09IFwicmlnaHRcIikge1xuICAgICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaG9yaXogPT0gXCJsZWZ0XCIpIHsgbGVmdCA9IDA7IH1cbiAgICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSB7IGxlZnQgPSAoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGgpIC8gMjsgfVxuICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbClcbiAgICAgICAgICB7IHNjcm9sbEludG9WaWV3KHRoaXMsIHtsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgcmlnaHQ6IGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCBib3R0b206IHRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0fSk7IH1cbiAgICAgIH0sXG5cbiAgICAgIHRyaWdnZXJPbktleURvd246IG1ldGhvZE9wKG9uS2V5RG93biksXG4gICAgICB0cmlnZ2VyT25LZXlQcmVzczogbWV0aG9kT3Aob25LZXlQcmVzcyksXG4gICAgICB0cmlnZ2VyT25LZXlVcDogb25LZXlVcCxcbiAgICAgIHRyaWdnZXJPbk1vdXNlRG93bjogbWV0aG9kT3Aob25Nb3VzZURvd24pLFxuXG4gICAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY21kKSB7XG4gICAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKVxuICAgICAgICAgIHsgcmV0dXJuIGNvbW1hbmRzW2NtZF0uY2FsbChudWxsLCB0aGlzKSB9XG4gICAgICB9LFxuXG4gICAgICB0cmlnZ2VyRWxlY3RyaWM6IG1ldGhvZE9wKGZ1bmN0aW9uKHRleHQpIHsgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpOyB9KSxcblxuICAgICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICAgICAgdmFyIGRpciA9IDE7XG4gICAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xuICAgICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1clxuICAgICAgfSxcblxuICAgICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAodGhpcyQxLmRpc3BsYXkuc2hpZnQgfHwgdGhpcyQxLmRvYy5leHRlbmQgfHwgcmFuZ2UuZW1wdHkoKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIGZpbmRQb3NIKHRoaXMkMS5kb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgdGhpcyQxLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KSB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICB9KSxcblxuICAgICAgZGVsZXRlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciBzZWwgPSB0aGlzLmRvYy5zZWwsIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgICBpZiAoc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkpXG4gICAgICAgICAgeyBkb2MucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcIitkZWxldGVcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGZpbmRQb3NIKGRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn1cbiAgICAgICAgICB9KTsgfVxuICAgICAgfSksXG5cbiAgICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgdmFyIGRpciA9IDEsIHggPSBnb2FsQ29sdW1uO1xuICAgICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxuICAgICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKHRoaXMsIGN1ciwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHggPT0gbnVsbCkgeyB4ID0gY29vcmRzLmxlZnQ7IH1cbiAgICAgICAgICBlbHNlIHsgY29vcmRzLmxlZnQgPSB4OyB9XG4gICAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcywgY29vcmRzLCBkaXIsIHVuaXQpO1xuICAgICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1clxuICAgICAgfSxcblxuICAgICAgbW92ZVY6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW107XG4gICAgICAgIHZhciBjb2xsYXBzZSA9ICF0aGlzLmRpc3BsYXkuc2hpZnQgJiYgIWRvYy5leHRlbmQgJiYgZG9jLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICBkb2MuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgIGlmIChjb2xsYXBzZSlcbiAgICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cbiAgICAgICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3Jkcyh0aGlzJDEsIHJhbmdlLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgICAgIGlmIChyYW5nZS5nb2FsQ29sdW1uICE9IG51bGwpIHsgaGVhZFBvcy5sZWZ0ID0gcmFuZ2UuZ29hbENvbHVtbjsgfVxuICAgICAgICAgIGdvYWxzLnB1c2goaGVhZFBvcy5sZWZ0KTtcbiAgICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YodGhpcyQxLCBoZWFkUG9zLCBkaXIsIHVuaXQpO1xuICAgICAgICAgIGlmICh1bml0ID09IFwicGFnZVwiICYmIHJhbmdlID09IGRvYy5zZWwucHJpbWFyeSgpKVxuICAgICAgICAgICAgeyBhZGRUb1Njcm9sbFRvcCh0aGlzJDEsIGNoYXJDb29yZHModGhpcyQxLCBwb3MsIFwiZGl2XCIpLnRvcCAtIGhlYWRQb3MudG9wKTsgfVxuICAgICAgICAgIHJldHVybiBwb3NcbiAgICAgICAgfSwgc2VsX21vdmUpO1xuICAgICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyBkb2Muc2VsLnJhbmdlc1tpXS5nb2FsQ29sdW1uID0gZ29hbHNbaV07IH0gfVxuICAgICAgfSksXG5cbiAgICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cbiAgICAgIGZpbmRXb3JkQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQ7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcy5jaCwgZW5kID0gcG9zLmNoO1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIHZhciBoZWxwZXIgPSB0aGlzLmdldEhlbHBlcihwb3MsIFwid29yZENoYXJzXCIpO1xuICAgICAgICAgIGlmICgocG9zLnN0aWNreSA9PSBcImJlZm9yZVwiIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIHsgLS1zdGFydDsgfSBlbHNlIHsgKytlbmQ7IH1cbiAgICAgICAgICB2YXIgc3RhcnRDaGFyID0gbGluZS5jaGFyQXQoc3RhcnQpO1xuICAgICAgICAgIHZhciBjaGVjayA9IGlzV29yZENoYXIoc3RhcnRDaGFyLCBoZWxwZXIpXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gaXNXb3JkQ2hhcihjaCwgaGVscGVyKTsgfVxuICAgICAgICAgICAgOiAvXFxzLy50ZXN0KHN0YXJ0Q2hhcikgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIC9cXHMvLnRlc3QoY2gpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gKCEvXFxzLy50ZXN0KGNoKSAmJiAhaXNXb3JkQ2hhcihjaCkpOyB9O1xuICAgICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgY2hlY2sobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkpIHsgLS1zdGFydDsgfVxuICAgICAgICAgIHdoaWxlIChlbmQgPCBsaW5lLmxlbmd0aCAmJiBjaGVjayhsaW5lLmNoYXJBdChlbmQpKSkgeyArK2VuZDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSlcbiAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHsgcmV0dXJuIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKVxuICAgICAgICAgIHsgYWRkQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBybUNsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7IH1cblxuICAgICAgICBzaWduYWwodGhpcywgXCJvdmVyd3JpdGVUb2dnbGVcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xuICAgICAgfSxcbiAgICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpID09IGFjdGl2ZUVsdCgpIH0sXG4gICAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCkgfSxcblxuICAgICAgc2Nyb2xsVG86IG1ldGhvZE9wKGZ1bmN0aW9uICh4LCB5KSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMsIHgsIHkpOyB9KSxcbiAgICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgICAgIHJldHVybiB7bGVmdDogc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdG9wOiBzY3JvbGxlci5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxlci5zY3JvbGxXaWR0aCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IGRpc3BsYXlIZWlnaHQodGhpcyksIGNsaWVudFdpZHRoOiBkaXNwbGF5V2lkdGgodGhpcyl9XG4gICAgICB9LFxuXG4gICAgICBzY3JvbGxJbnRvVmlldzogbWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbikge1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9O1xuICAgICAgICAgIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSB0aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luOyB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiBQb3MocmFuZ2UsIDApLCB0bzogbnVsbH07XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogcmFuZ2UsIHRvOiBudWxsfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlLnRvKSB7IHJhbmdlLnRvID0gcmFuZ2UuZnJvbTsgfVxuICAgICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMDtcblxuICAgICAgICBpZiAocmFuZ2UuZnJvbS5saW5lICE9IG51bGwpIHtcbiAgICAgICAgICBzY3JvbGxUb1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKHRoaXMsIHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS5tYXJnaW4pO1xuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgc2V0U2l6ZTogbWV0aG9kT3AoZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiIHx8IC9eXFxkKyQvLnRlc3QoU3RyaW5nKHZhbCkpID8gdmFsICsgXCJweFwiIDogdmFsOyB9O1xuICAgICAgICBpZiAod2lkdGggIT0gbnVsbCkgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aCA9IGludGVycHJldCh3aWR0aCk7IH1cbiAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpOyB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcyk7IH1cbiAgICAgICAgdmFyIGxpbmVObyA9IHRoaXMuZGlzcGxheS52aWV3RnJvbTtcbiAgICAgICAgdGhpcy5kb2MuaXRlcihsaW5lTm8sIHRoaXMuZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHsgaWYgKGxpbmUud2lkZ2V0c1tpXS5ub0hTY3JvbGwpIHsgcmVnTGluZUNoYW5nZSh0aGlzJDEsIGxpbmVObywgXCJ3aWRnZXRcIik7IGJyZWFrIH0gfSB9XG4gICAgICAgICAgKytsaW5lTm87XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBvcGVyYXRpb246IGZ1bmN0aW9uKGYpe3JldHVybiBydW5Jbk9wKHRoaXMsIGYpfSxcbiAgICAgIHN0YXJ0T3BlcmF0aW9uOiBmdW5jdGlvbigpe3JldHVybiBzdGFydE9wZXJhdGlvbih0aGlzKX0sXG4gICAgICBlbmRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIGVuZE9wZXJhdGlvbih0aGlzKX0sXG5cbiAgICAgIHJlZnJlc2g6IG1ldGhvZE9wKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCB0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApO1xuICAgICAgICB1cGRhdGVHdXR0ZXJTcGFjZSh0aGlzLmRpc3BsYXkpO1xuICAgICAgICBpZiAob2xkSGVpZ2h0ID09IG51bGwgfHwgTWF0aC5hYnMob2xkSGVpZ2h0IC0gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKSA+IC41IHx8IHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgeyBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpOyB9XG4gICAgICAgIHNpZ25hbCh0aGlzLCBcInJlZnJlc2hcIiwgdGhpcyk7XG4gICAgICB9KSxcblxuICAgICAgc3dhcERvYzogbWV0aG9kT3AoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLmRvYztcbiAgICAgICAgb2xkLmNtID0gbnVsbDtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIGlmIGFueSAoIzU4MjEpXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQpIHsgdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KCk7IH1cbiAgICAgICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XG4gICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgc2Nyb2xsVG9Db29yZHModGhpcywgZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgc2lnbmFsTGF0ZXIodGhpcywgXCJzd2FwRG9jXCIsIHRoaXMsIG9sZCk7XG4gICAgICAgIHJldHVybiBvbGRcbiAgICAgIH0pLFxuXG4gICAgICBwaHJhc2U6IGZ1bmN0aW9uKHBocmFzZVRleHQpIHtcbiAgICAgICAgdmFyIHBocmFzZXMgPSB0aGlzLm9wdGlvbnMucGhyYXNlcztcbiAgICAgICAgcmV0dXJuIHBocmFzZXMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBocmFzZXMsIHBocmFzZVRleHQpID8gcGhyYXNlc1twaHJhc2VUZXh0XSA6IHBocmFzZVRleHRcbiAgICAgIH0sXG5cbiAgICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpfSxcbiAgICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcn0sXG4gICAgICBnZXRTY3JvbGxlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlcn0sXG4gICAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyc31cbiAgICB9O1xuICAgIGV2ZW50TWl4aW4oQ29kZU1pcnJvcik7XG5cbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyBoZWxwZXJzW3R5cGVdID0gQ29kZU1pcnJvclt0eXBlXSA9IHtfZ2xvYmFsOiBbXX07IH1cbiAgICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJHbG9iYWxIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBwcmVkaWNhdGUsIHZhbHVlKSB7XG4gICAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGhlbHBlcnNbdHlwZV0uX2dsb2JhbC5wdXNoKHtwcmVkOiBwcmVkaWNhdGUsIHZhbDogdmFsdWV9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3Rpb24uIERpciBpcyAtMSBvciAxIChsZWZ0IG9yXG4gIC8vIHJpZ2h0KSwgdW5pdCBjYW4gYmUgXCJjb2RlcG9pbnRcIiwgXCJjaGFyXCIsIFwiY29sdW1uXCIgKGxpa2UgY2hhciwgYnV0XG4gIC8vIGRvZXNuJ3QgY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXCJ3b3JkXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvclxuICAvLyBcImdyb3VwXCIgKHRvIHRoZSBzdGFydCBvZiBuZXh0IGdyb3VwIG9mIHdvcmQgb3JcbiAgLy8gbm9uLXdvcmQtbm9uLXdoaXRlc3BhY2UgY2hhcnMpLiBUaGUgdmlzdWFsbHkgcGFyYW0gY29udHJvbHNcbiAgLy8gd2hldGhlciwgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHNcbiAgLy8gdGhlIG5leHQgaW5kZXggaW4gdGhlIHN0cmluZywgb3IgdG93YXJkcyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodFxuICAvLyBvZiB0aGUgY3VycmVudCBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYVxuICAvLyBoaXRTaWRlPXRydWUgcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc0goZG9jLCBwb3MsIGRpciwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICB2YXIgb2xkUG9zID0gcG9zO1xuICAgIHZhciBvcmlnRGlyID0gZGlyO1xuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZURpciA9IHZpc3VhbGx5ICYmIGRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IC1kaXIgOiBkaXI7XG4gICAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xuICAgICAgdmFyIGwgPSBwb3MubGluZSArIGxpbmVEaXI7XG4gICAgICBpZiAobCA8IGRvYy5maXJzdCB8fCBsID49IGRvYy5maXJzdCArIGRvYy5zaXplKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwb3MgPSBuZXcgUG9zKGwsIHBvcy5jaCwgcG9zLnN0aWNreSk7XG4gICAgICByZXR1cm4gbGluZU9iaiA9IGdldExpbmUoZG9jLCBsKVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlT25jZShib3VuZFRvTGluZSkge1xuICAgICAgdmFyIG5leHQ7XG4gICAgICBpZiAodW5pdCA9PSBcImNvZGVwb2ludFwiKSB7XG4gICAgICAgIHZhciBjaCA9IGxpbmVPYmoudGV4dC5jaGFyQ29kZUF0KHBvcy5jaCArIChkaXIgPiAwID8gMCA6IC0xKSk7XG4gICAgICAgIGlmIChpc05hTihjaCkpIHtcbiAgICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXN0cmFsID0gZGlyID4gMCA/IGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMCA6IGNoID49IDB4REMwMCAmJiBjaCA8IDB4REZGRjtcbiAgICAgICAgICBuZXh0ID0gbmV3IFBvcyhwb3MubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5taW4obGluZU9iai50ZXh0Lmxlbmd0aCwgcG9zLmNoICsgZGlyICogKGFzdHJhbCA/IDIgOiAxKSkpLCAtZGlyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2aXN1YWxseSkge1xuICAgICAgICBuZXh0ID0gbW92ZVZpc3VhbGx5KGRvYy5jbSwgbGluZU9iaiwgcG9zLCBkaXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCA9IG1vdmVMb2dpY2FsbHkobGluZU9iaiwgcG9zLCBkaXIpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWJvdW5kVG9MaW5lICYmIGZpbmROZXh0TGluZSgpKVxuICAgICAgICAgIHsgcG9zID0gZW5kT2ZMaW5lKHZpc3VhbGx5LCBkb2MuY20sIGxpbmVPYmosIHBvcy5saW5lLCBsaW5lRGlyKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIgfHwgdW5pdCA9PSBcImNvZGVwb2ludFwiKSB7XG4gICAgICBtb3ZlT25jZSgpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcImNvbHVtblwiKSB7XG4gICAgICBtb3ZlT25jZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJ3b3JkXCIgfHwgdW5pdCA9PSBcImdyb3VwXCIpIHtcbiAgICAgIHZhciBzYXdUeXBlID0gbnVsbCwgZ3JvdXAgPSB1bml0ID09IFwiZ3JvdXBcIjtcbiAgICAgIHZhciBoZWxwZXIgPSBkb2MuY20gJiYgZG9jLmNtLmdldEhlbHBlcihwb3MsIFwid29yZENoYXJzXCIpO1xuICAgICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZGlyIDwgMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgeyBicmVhayB9XG4gICAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KHBvcy5jaCkgfHwgXCJcXG5cIjtcbiAgICAgICAgdmFyIHR5cGUgPSBpc1dvcmRDaGFyKGN1ciwgaGVscGVyKSA/IFwid1wiXG4gICAgICAgICAgOiBncm91cCAmJiBjdXIgPT0gXCJcXG5cIiA/IFwiblwiXG4gICAgICAgICAgOiAhZ3JvdXAgfHwgL1xccy8udGVzdChjdXIpID8gbnVsbFxuICAgICAgICAgIDogXCJwXCI7XG4gICAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHsgdHlwZSA9IFwic1wiOyB9XG4gICAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xuICAgICAgICAgIGlmIChkaXIgPCAwKSB7ZGlyID0gMTsgbW92ZU9uY2UoKTsgcG9zLnN0aWNreSA9IFwiYWZ0ZXJcIjt9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlKSB7IHNhd1R5cGUgPSB0eXBlOyB9XG4gICAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBwb3MsIG9sZFBvcywgb3JpZ0RpciwgdHJ1ZSk7XG4gICAgaWYgKGVxdWFsQ3Vyc29yUG9zKG9sZFBvcywgcmVzdWx0KSkgeyByZXN1bHQuaGl0U2lkZSA9IHRydWU7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBGb3IgcmVsYXRpdmUgdmVydGljYWwgbW92ZW1lbnQuIERpciBtYXkgYmUgLTEgb3IgMS4gVW5pdCBjYW4gYmVcbiAgLy8gXCJwYWdlXCIgb3IgXCJsaW5lXCIuIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXG4gIC8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRQb3NWKGNtLCBwb3MsIGRpciwgdW5pdCkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIHggPSBwb3MubGVmdCwgeTtcbiAgICBpZiAodW5pdCA9PSBcInBhZ2VcIikge1xuICAgICAgdmFyIHBhZ2VTaXplID0gTWF0aC5taW4oY20uZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgdmFyIG1vdmVBbW91bnQgPSBNYXRoLm1heChwYWdlU2l6ZSAtIC41ICogdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgMyk7XG4gICAgICB5ID0gKGRpciA+IDAgPyBwb3MuYm90dG9tIDogcG9zLnRvcCkgKyBkaXIgKiBtb3ZlQW1vdW50O1xuXG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwibGluZVwiKSB7XG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XG4gICAgfVxuICAgIHZhciB0YXJnZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdGFyZ2V0ID0gY29vcmRzQ2hhcihjbSwgeCwgeSk7XG4gICAgICBpZiAoIXRhcmdldC5vdXRzaWRlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChkaXIgPCAwID8geSA8PSAwIDogeSA+PSBkb2MuaGVpZ2h0KSB7IHRhcmdldC5oaXRTaWRlID0gdHJ1ZTsgYnJlYWsgfVxuICAgICAgeSArPSBkaXIgKiA1O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBDT05URU5URURJVEFCTEUgSU5QVVQgU1RZTEVcblxuICB2YXIgQ29udGVudEVkaXRhYmxlSW5wdXQgPSBmdW5jdGlvbihjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gdGhpcy5sYXN0Rm9jdXNOb2RlID0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcbiAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY207XG4gICAgdmFyIGRpdiA9IGlucHV0LmRpdiA9IGRpc3BsYXkubGluZURpdjtcbiAgICBkaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKGRpdiwgY20ub3B0aW9ucy5zcGVsbGNoZWNrLCBjbS5vcHRpb25zLmF1dG9jb3JyZWN0LCBjbS5vcHRpb25zLmF1dG9jYXBpdGFsaXplKTtcblxuICAgIGZ1bmN0aW9uIGJlbG9uZ3NUb0lucHV0KGUpIHtcbiAgICAgIGZvciAodmFyIHQgPSBlLnRhcmdldDsgdDsgdCA9IHQucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAodCA9PSBkaXYpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgICBpZiAoL1xcYkNvZGVNaXJyb3ItKD86bGluZSk/d2lkZ2V0XFxiLy50ZXN0KHQuY2xhc3NOYW1lKSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBvbihkaXYsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghYmVsb25nc1RvSW5wdXQoZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxuICAgICAgLy8gSUUgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50cywgc28gd2Ugc2NoZWR1bGUgYSByZWFkIGZvciB0aGUgcGFzdGVkIGNvbnRlbnQgaW4gdGhpcyB3YXlcbiAgICAgIGlmIChpZV92ZXJzaW9uIDw9IDExKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEudXBkYXRlRnJvbURPTSgpOyB9KSwgMjApOyB9XG4gICAgfSk7XG5cbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTtcbiAgICB9KTtcbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb251cGRhdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9OyB9XG4gICAgfSk7XG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICBpZiAoZS5kYXRhICE9IHRoaXMkMS5jb21wb3NpbmcuZGF0YSkgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCk7IH1cbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG9uKGRpdiwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmZvcmNlQ29tcG9zaXRpb25FbmQoKTsgfSk7XG5cbiAgICBvbihkaXYsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKTsgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25Db3B5Q3V0KGUpIHtcbiAgICAgIGlmICghYmVsb25nc1RvSW5wdXQoZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHsgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTsgfVxuICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pO1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7XG4gICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgMCwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcbiAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpID09IGNvbnRlbnQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE9sZC1mYXNoaW9uZWQgYnJpZWZseS1mb2N1cy1hLXRleHRhcmVhIGhhY2tcbiAgICAgIHZhciBrbHVkZ2UgPSBoaWRkZW5UZXh0YXJlYSgpLCB0ZSA9IGtsdWRnZS5maXJzdENoaWxkO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGtsdWRnZSwgY20uZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZCk7XG4gICAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgdmFyIGhhZEZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoa2x1ZGdlKTtcbiAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgaWYgKGhhZEZvY3VzID09IGRpdikgeyBpbnB1dC5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uKGRpdiwgXCJjb3B5XCIsIG9uQ29weUN1dCk7XG4gICAgb24oZGl2LCBcImN1dFwiLCBvbkNvcHlDdXQpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAvLyBMYWJlbCBmb3Igc2NyZWVucmVhZGVycywgYWNjZXNzaWJpbGl0eVxuICAgIGlmKGxhYmVsKSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbih0aGlzLmNtLCBmYWxzZSk7XG4gICAgcmVzdWx0LmZvY3VzID0gYWN0aXZlRWx0KCkgPT0gdGhpcy5kaXY7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluZm8sIHRha2VGb2N1cykge1xuICAgIGlmICghaW5mbyB8fCAhdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgaWYgKGluZm8uZm9jdXMgfHwgdGFrZUZvY3VzKSB7IHRoaXMuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKTsgfVxuICAgIHRoaXMuc2hvd011bHRpcGxlU2VsZWN0aW9ucyhpbmZvKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNtLmRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpXG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dQcmltYXJ5U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY20sIHByaW0gPSBjbS5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICB2YXIgZnJvbSA9IHByaW0uZnJvbSgpLCB0byA9IHByaW0udG8oKTtcblxuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdUbyA9PSBjbS5kaXNwbGF5LnZpZXdGcm9tIHx8IGZyb20ubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCB0by5saW5lIDwgY20uZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgdmFyIGN1ckZvY3VzID0gZG9tVG9Qb3MoY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKGN1ckFuY2hvciAmJiAhY3VyQW5jaG9yLmJhZCAmJiBjdXJGb2N1cyAmJiAhY3VyRm9jdXMuYmFkICYmXG4gICAgICAgIGNtcChtaW5Qb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIGZyb20pID09IDAgJiZcbiAgICAgICAgY21wKG1heFBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgdG8pID09IDApXG4gICAgICB7IHJldHVybiB9XG5cbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldztcbiAgICB2YXIgc3RhcnQgPSAoZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgcG9zVG9ET00oY20sIGZyb20pKSB8fFxuICAgICAgICB7bm9kZTogdmlld1swXS5tZWFzdXJlLm1hcFsyXSwgb2Zmc2V0OiAwfTtcbiAgICB2YXIgZW5kID0gdG8ubGluZSA8IGNtLmRpc3BsYXkudmlld1RvICYmIHBvc1RvRE9NKGNtLCB0byk7XG4gICAgaWYgKCFlbmQpIHtcbiAgICAgIHZhciBtZWFzdXJlID0gdmlld1t2aWV3Lmxlbmd0aCAtIDFdLm1lYXN1cmU7XG4gICAgICB2YXIgbWFwID0gbWVhc3VyZS5tYXBzID8gbWVhc3VyZS5tYXBzW21lYXN1cmUubWFwcy5sZW5ndGggLSAxXSA6IG1lYXN1cmUubWFwO1xuICAgICAgZW5kID0ge25vZGU6IG1hcFttYXAubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwW21hcC5sZW5ndGggLSAyXSAtIG1hcFttYXAubGVuZ3RoIC0gM119O1xuICAgIH1cblxuICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIG9sZCA9IHNlbC5yYW5nZUNvdW50ICYmIHNlbC5nZXRSYW5nZUF0KDApLCBybmc7XG4gICAgdHJ5IHsgcm5nID0gcmFuZ2Uoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0LCBlbmQubm9kZSk7IH1cbiAgICBjYXRjaChlKSB7fSAvLyBPdXIgbW9kZWwgb2YgdGhlIERPTSBtaWdodCBiZSBvdXRkYXRlZCwgaW4gd2hpY2ggY2FzZSB0aGUgcmFuZ2Ugd2UgdHJ5IHRvIHNldCBjYW4gYmUgaW1wb3NzaWJsZVxuICAgIGlmIChybmcpIHtcbiAgICAgIGlmICghZ2Vja28gJiYgY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICBzZWwuY29sbGFwc2Uoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbC5hZGRSYW5nZShybmcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShybmcpO1xuICAgICAgfVxuICAgICAgaWYgKG9sZCAmJiBzZWwuYW5jaG9yTm9kZSA9PSBudWxsKSB7IHNlbC5hZGRSYW5nZShvbGQpOyB9XG4gICAgICBlbHNlIGlmIChnZWNrbykgeyB0aGlzLnN0YXJ0R3JhY2VQZXJpb2QoKTsgfVxuICAgIH1cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnN0YXJ0R3JhY2VQZXJpb2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKTtcbiAgICB0aGlzLmdyYWNlUGVyaW9kID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzJDEuc2VsZWN0aW9uQ2hhbmdlZCgpKVxuICAgICAgICB7IHRoaXMkMS5jbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KTsgfVxuICAgIH0sIDIwKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd011bHRpcGxlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LmN1cnNvckRpdiwgaW5mby5jdXJzb3JzKTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuc2VsZWN0aW9uRGl2LCBpbmZvLnNlbGVjdGlvbik7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlbWVtYmVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTsgdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICB0aGlzLmxhc3RGb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlOyB0aGlzLmxhc3RGb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uSW5FZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwucmFuZ2VDb3VudCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBub2RlID0gc2VsLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuZGl2LCBub2RlKVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFwibm9jdXJzb3JcIikge1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy5kaXYpXG4gICAgICAgIHsgdGhpcy5zaG93U2VsZWN0aW9uKHRoaXMucHJlcGFyZVNlbGVjdGlvbigpLCB0cnVlKTsgfVxuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpdi5ibHVyKCk7IH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGl2IH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbnB1dCA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcbiAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEucG9sbFNlbGVjdGlvbigpOyB9LCAyMCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG5cbiAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgaW5wdXQucG9sbFNlbGVjdGlvbigpO1xuICAgICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlICE9IHRoaXMubGFzdEFuY2hvck5vZGUgfHwgc2VsLmFuY2hvck9mZnNldCAhPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgfHxcbiAgICAgIHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldFxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwgfHwgdGhpcy5ncmFjZVBlcmlvZCB8fCAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCkpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtO1xuICAgIC8vIE9uIEFuZHJvaWQgQ2hyb21lICh2ZXJzaW9uIDU2LCBhdCBsZWFzdCksIGJhY2tzcGFjaW5nIGludG8gYW5cbiAgICAvLyB1bmVkaXRhYmxlIGJsb2NrIGVsZW1lbnQgd2lsbCBwdXQgdGhlIGN1cnNvciBpbiB0aGF0IGVsZW1lbnQsXG4gICAgLy8gYW5kIHRoZW4sIGJlY2F1c2UgaXQncyBub3QgZWRpdGFibGUsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQuXG4gICAgLy8gQmVjYXVzZSBBbmRyb2lkIGRvZXNuJ3QgYWxsb3cgdXMgdG8gYWN0dWFsbHkgZGV0ZWN0IGJhY2tzcGFjZVxuICAgIC8vIHByZXNzZXMgaW4gYSBzYW5lIHdheSwgdGhpcyBjb2RlIGNoZWNrcyBmb3Igd2hlbiB0aGF0IGhhcHBlbnNcbiAgICAvLyBhbmQgc2ltdWxhdGVzIGEgYmFja3NwYWNlIHByZXNzIGluIHRoaXMgY2FzZS5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgdGhpcy5jbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aCAmJiBpc0luR3V0dGVyKHNlbC5hbmNob3JOb2RlKSkge1xuICAgICAgdGhpcy5jbS50cmlnZ2VyT25LZXlEb3duKHt0eXBlOiBcImtleWRvd25cIiwga2V5Q29kZTogOCwgcHJldmVudERlZmF1bHQ6IE1hdGguYWJzfSk7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XG4gICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgdmFyIGhlYWQgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgIGlmIChhbmNob3IuYmFkIHx8IGhlYWQuYmFkKSB7IGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9XG4gICAgfSk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNlbCA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKTtcbiAgICBpZiAoZnJvbS5jaCA9PSAwICYmIGZyb20ubGluZSA+IGNtLmZpcnN0TGluZSgpKVxuICAgICAgeyBmcm9tID0gUG9zKGZyb20ubGluZSAtIDEsIGdldExpbmUoY20uZG9jLCBmcm9tLmxpbmUgLSAxKS5sZW5ndGgpOyB9XG4gICAgaWYgKHRvLmNoID09IGdldExpbmUoY20uZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCAmJiB0by5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgIHsgdG8gPSBQb3ModG8ubGluZSArIDEsIDApOyB9XG4gICAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIGZyb21JbmRleCwgZnJvbUxpbmUsIGZyb21Ob2RlO1xuICAgIGlmIChmcm9tLmxpbmUgPT0gZGlzcGxheS52aWV3RnJvbSB8fCAoZnJvbUluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgZnJvbS5saW5lKSkgPT0gMCkge1xuICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpO1xuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbMF0ubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XG4gICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1tmcm9tSW5kZXggLSAxXS5ub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICB2YXIgdG9JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIHRvLmxpbmUpO1xuICAgIHZhciB0b0xpbmUsIHRvTm9kZTtcbiAgICBpZiAodG9JbmRleCA9PSBkaXNwbGF5LnZpZXcubGVuZ3RoIC0gMSkge1xuICAgICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxO1xuICAgICAgdG9Ob2RlID0gZGlzcGxheS5saW5lRGl2Lmxhc3RDaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubGluZSkgLSAxO1xuICAgICAgdG9Ob2RlID0gZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5ub2RlLnByZXZpb3VzU2libGluZztcbiAgICB9XG5cbiAgICBpZiAoIWZyb21Ob2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5ld1RleHQgPSBjbS5kb2Muc3BsaXRMaW5lcyhkb21UZXh0QmV0d2VlbihjbSwgZnJvbU5vZGUsIHRvTm9kZSwgZnJvbUxpbmUsIHRvTGluZSkpO1xuICAgIHZhciBvbGRUZXh0ID0gZ2V0QmV0d2VlbihjbS5kb2MsIFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUsIGdldExpbmUoY20uZG9jLCB0b0xpbmUpLnRleHQubGVuZ3RoKSk7XG4gICAgd2hpbGUgKG5ld1RleHQubGVuZ3RoID4gMSAmJiBvbGRUZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tOyB9XG4gICAgICBlbHNlIGlmIChuZXdUZXh0WzBdID09IG9sZFRleHRbMF0pIHsgbmV3VGV4dC5zaGlmdCgpOyBvbGRUZXh0LnNoaWZ0KCk7IGZyb21MaW5lKys7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgdmFyIGN1dEZyb250ID0gMCwgY3V0RW5kID0gMDtcbiAgICB2YXIgbmV3VG9wID0gbmV3VGV4dFswXSwgb2xkVG9wID0gb2xkVGV4dFswXSwgbWF4Q3V0RnJvbnQgPSBNYXRoLm1pbihuZXdUb3AubGVuZ3RoLCBvbGRUb3AubGVuZ3RoKTtcbiAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxuICAgICAgeyArK2N1dEZyb250OyB9XG4gICAgdmFyIG5ld0JvdCA9IGxzdChuZXdUZXh0KSwgb2xkQm90ID0gbHN0KG9sZFRleHQpO1xuICAgIHZhciBtYXhDdXRFbmQgPSBNYXRoLm1pbihuZXdCb3QubGVuZ3RoIC0gKG5ld1RleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCb3QubGVuZ3RoIC0gKG9sZFRleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApKTtcbiAgICB3aGlsZSAoY3V0RW5kIDwgbWF4Q3V0RW5kICYmXG4gICAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpXG4gICAgICB7ICsrY3V0RW5kOyB9XG4gICAgLy8gVHJ5IHRvIG1vdmUgc3RhcnQgb2YgY2hhbmdlIHRvIHN0YXJ0IG9mIHNlbGVjdGlvbiBpZiBhbWJpZ3VvdXNcbiAgICBpZiAobmV3VGV4dC5sZW5ndGggPT0gMSAmJiBvbGRUZXh0Lmxlbmd0aCA9PSAxICYmIGZyb21MaW5lID09IGZyb20ubGluZSkge1xuICAgICAgd2hpbGUgKGN1dEZyb250ICYmIGN1dEZyb250ID4gZnJvbS5jaCAmJlxuICAgICAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpIHtcbiAgICAgICAgY3V0RnJvbnQtLTtcbiAgICAgICAgY3V0RW5kKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID0gbmV3Qm90LnNsaWNlKDAsIG5ld0JvdC5sZW5ndGggLSBjdXRFbmQpLnJlcGxhY2UoL15cXHUyMDBiKy8sIFwiXCIpO1xuICAgIG5ld1RleHRbMF0gPSBuZXdUZXh0WzBdLnNsaWNlKGN1dEZyb250KS5yZXBsYWNlKC9cXHUyMDBiKyQvLCBcIlwiKTtcblxuICAgIHZhciBjaEZyb20gPSBQb3MoZnJvbUxpbmUsIGN1dEZyb250KTtcbiAgICB2YXIgY2hUbyA9IFBvcyh0b0xpbmUsIG9sZFRleHQubGVuZ3RoID8gbHN0KG9sZFRleHQpLmxlbmd0aCAtIGN1dEVuZCA6IDApO1xuICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA+IDEgfHwgbmV3VGV4dFswXSB8fCBjbXAoY2hGcm9tLCBjaFRvKSkge1xuICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgbmV3VGV4dCwgY2hGcm9tLCBjaFRvLCBcIitpbnB1dFwiKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvcmNlQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVGcm9tRE9NKCk7XG4gICAgdGhpcy5kaXYuYmx1cigpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWFkRnJvbURPTVNvb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcuZG9uZSkgeyB0aGlzJDEuY29tcG9zaW5nID0gbnVsbDsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIH1cbiAgICAgIH1cbiAgICAgIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7XG4gICAgfSwgODApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS51cGRhdGVGcm9tRE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jbS5pc1JlYWRPbmx5KCkgfHwgIXRoaXMucG9sbENvbnRlbnQoKSlcbiAgICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdDaGFuZ2UodGhpcyQxLmNtKTsgfSk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmNoYXJDb2RlID09IDAgfHwgdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLmNtLmlzUmVhZE9ubHkoKSlcbiAgICAgIHsgb3BlcmF0aW9uKHRoaXMuY20sIGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGUgPT0gbnVsbCA/IGUua2V5Q29kZSA6IGUuY2hhckNvZGUpLCAwKTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5kaXYuY29udGVudEVkaXRhYmxlID0gU3RyaW5nKHZhbCAhPSBcIm5vY3Vyc29yXCIpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKCkge307XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge307XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gcG9zVG9ET00oY20sIHBvcykge1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBwb3MubGluZSk7XG4gICAgaWYgKCF2aWV3IHx8IHZpZXcuaGlkZGVuKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgcG9zLmxpbmUpO1xuXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbiksIHNpZGUgPSBcImxlZnRcIjtcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKTtcbiAgICAgIHNpZGUgPSBwYXJ0UG9zICUgMiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChpbmZvLm1hcCwgcG9zLmNoLCBzaWRlKTtcbiAgICByZXN1bHQub2Zmc2V0ID0gcmVzdWx0LmNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlc3VsdC5lbmQgOiByZXN1bHQuc3RhcnQ7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbkd1dHRlcihub2RlKSB7XG4gICAgZm9yICh2YXIgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpXG4gICAgICB7IGlmICgvQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlci8udGVzdChzY2FuLmNsYXNzTmFtZSkpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBiYWRQb3MocG9zLCBiYWQpIHsgaWYgKGJhZCkgeyBwb3MuYmFkID0gdHJ1ZTsgfSByZXR1cm4gcG9zIH1cblxuICBmdW5jdGlvbiBkb21UZXh0QmV0d2VlbihjbSwgZnJvbSwgdG8sIGZyb21MaW5lLCB0b0xpbmUpIHtcbiAgICB2YXIgdGV4dCA9IFwiXCIsIGNsb3NpbmcgPSBmYWxzZSwgbGluZVNlcCA9IGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7IHJldHVybiBmdW5jdGlvbiAobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaWQgPT0gaWQ7IH0gfVxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKGNsb3NpbmcpIHtcbiAgICAgICAgdGV4dCArPSBsaW5lU2VwO1xuICAgICAgICBpZiAoZXh0cmFMaW5lYnJlYWspIHsgdGV4dCArPSBsaW5lU2VwOyB9XG4gICAgICAgIGNsb3NpbmcgPSBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUZXh0KHN0cikge1xuICAgICAgaWYgKHN0cikge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICB0ZXh0ICs9IHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIHZhciBjbVRleHQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLXRleHRcIik7XG4gICAgICAgIGlmIChjbVRleHQpIHtcbiAgICAgICAgICBhZGRUZXh0KGNtVGV4dCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtlcklEID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiksIHJhbmdlO1xuICAgICAgICBpZiAobWFya2VySUQpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBjbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSArIDEsIDApLCByZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSk7XG4gICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCAmJiAocmFuZ2UgPSBmb3VuZFswXS5maW5kKDApKSlcbiAgICAgICAgICAgIHsgYWRkVGV4dChnZXRCZXR3ZWVuKGNtLmRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pLmpvaW4obGluZVNlcCkpOyB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09IFwiZmFsc2VcIikgeyByZXR1cm4gfVxuICAgICAgICB2YXIgaXNCbG9jayA9IC9eKHByZXxkaXZ8cHxsaXx0YWJsZXxicikkL2kudGVzdChub2RlLm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCEvXmJyJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkgJiYgbm9kZS50ZXh0Q29udGVudC5sZW5ndGggPT0gMCkgeyByZXR1cm4gfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrKSB7IGNsb3NlKCk7IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyB3YWxrKG5vZGUuY2hpbGROb2Rlc1tpXSk7IH1cblxuICAgICAgICBpZiAoL14ocHJlfHApJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpIHsgZXh0cmFMaW5lYnJlYWsgPSB0cnVlOyB9XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7IGNsb3NpbmcgPSB0cnVlOyB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICBhZGRUZXh0KG5vZGUubm9kZVZhbHVlLnJlcGxhY2UoL1xcdTIwMGIvZywgXCJcIikucmVwbGFjZSgvXFx1MDBhMC9nLCBcIiBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICB3YWxrKGZyb20pO1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHsgYnJlYWsgfVxuICAgICAgZnJvbSA9IGZyb20ubmV4dFNpYmxpbmc7XG4gICAgICBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZG9tVG9Qb3MoY20sIG5vZGUsIG9mZnNldCkge1xuICAgIHZhciBsaW5lTm9kZTtcbiAgICBpZiAobm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHtcbiAgICAgIGxpbmVOb2RlID0gY20uZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmICghbGluZU5vZGUpIHsgcmV0dXJuIGJhZFBvcyhjbS5jbGlwUG9zKFBvcyhjbS5kaXNwbGF5LnZpZXdUbyAtIDEpKSwgdHJ1ZSkgfVxuICAgICAgbm9kZSA9IG51bGw7IG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGluZU5vZGUgPSBub2RlOzsgbGluZU5vZGUgPSBsaW5lTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudE5vZGUgJiYgbGluZU5vZGUucGFyZW50Tm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gY20uZGlzcGxheS52aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZU5vZGUpXG4gICAgICAgIHsgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlO1xuICAgIGlmICghbm9kZSB8fCAhY29udGFpbnMod3JhcHBlciwgbm9kZSkpIHsgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmVWaWV3LmxpbmUpLCAwKSwgdHJ1ZSkgfVxuICAgIGlmIChub2RlID09IHdyYXBwZXIpIHtcbiAgICAgIGJhZCA9IHRydWU7XG4gICAgICBub2RlID0gd3JhcHBlci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZVZpZXcucmVzdCA/IGxzdChsaW5lVmlldy5yZXN0KSA6IGxpbmVWaWV3LmxpbmU7XG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlIDogbnVsbCwgdG9wTm9kZSA9IG5vZGU7XG4gICAgaWYgKCF0ZXh0Tm9kZSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKG9mZnNldCkgeyBvZmZzZXQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoOyB9XG4gICAgfVxuICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gd3JhcHBlcikgeyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlOyB9XG4gICAgdmFyIG1lYXN1cmUgPSBsaW5lVmlldy5tZWFzdXJlLCBtYXBzID0gbWVhc3VyZS5tYXBzO1xuXG4gICAgZnVuY3Rpb24gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gLTE7IGkgPCAobWFwcyA/IG1hcHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICB2YXIgbWFwID0gaSA8IDAgPyBtZWFzdXJlLm1hcCA6IG1hcHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgICAgdmFyIGN1ck5vZGUgPSBtYXBbaiArIDJdO1xuICAgICAgICAgIGlmIChjdXJOb2RlID09IHRleHROb2RlIHx8IGN1ck5vZGUgPT0gdG9wTm9kZSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lTm8oaSA8IDAgPyBsaW5lVmlldy5saW5lIDogbGluZVZpZXcucmVzdFtpXSk7XG4gICAgICAgICAgICB2YXIgY2ggPSBtYXBbal0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBjdXJOb2RlICE9IHRleHROb2RlKSB7IGNoID0gbWFwW2ogKyAob2Zmc2V0ID8gMSA6IDApXTsgfVxuICAgICAgICAgICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZvdW5kID0gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KTtcbiAgICBpZiAoZm91bmQpIHsgcmV0dXJuIGJhZFBvcyhmb3VuZCwgYmFkKSB9XG5cbiAgICAvLyBGSVhNRSB0aGlzIGlzIGFsbCByZWFsbHkgc2hha3kuIG1pZ2h0IGhhbmRsZSB0aGUgZmV3IGNhc2VzIGl0IG5lZWRzIHRvIGhhbmRsZSwgYnV0IGxpa2VseSB0byBjYXVzZSBwcm9ibGVtc1xuICAgIGZvciAodmFyIGFmdGVyID0gdG9wTm9kZS5uZXh0U2libGluZywgZGlzdCA9IHRleHROb2RlID8gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIG9mZnNldCA6IDA7IGFmdGVyOyBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCkgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGRpc3QgKz0gYWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoOyB9XG4gICAgfVxuICAgIGZvciAodmFyIGJlZm9yZSA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nLCBkaXN0JDEgPSBvZmZzZXQ7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLnByZXZpb3VzU2libGluZykge1xuICAgICAgZm91bmQgPSBmaW5kKGJlZm9yZSwgYmVmb3JlLmZpcnN0Q2hpbGQsIC0xKTtcbiAgICAgIGlmIChmb3VuZClcbiAgICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QkMSksIGJhZCkgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGRpc3QkMSArPSBiZWZvcmUudGV4dENvbnRlbnQubGVuZ3RoOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gVEVYVEFSRUEgSU5QVVQgU1RZTEVcblxuICB2YXIgVGV4dGFyZWFJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIC8vIFNlZSBpbnB1dC5wb2xsIGFuZCBpbnB1dC5yZXNldFxuICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcblxuICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxuICAgIC8vIG5vdyAoYWZ0ZXIgc29tZSBldmVudCBsaWtlICdrZXlwcmVzcycgb3IgJ2lucHV0JykgYW5kIGFyZVxuICAgIC8vIHBvbGxpbmcgaW50ZW5zaXZlbHkuXG4gICAgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlO1xuICAgIC8vIFNlbGYtcmVzZXR0aW5nIHRpbWVvdXQgZm9yIHRoZSBwb2xsZXJcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xuICAgIC8vIFVzZWQgdG8gd29yayBhcm91bmQgSUUgaXNzdWUgd2l0aCBzZWxlY3Rpb24gYmVpbmcgZm9yZ290dGVuIHdoZW4gZm9jdXMgbW92ZXMgYXdheSBmcm9tIHRleHRhcmVhXG4gICAgdGhpcy5oYXNTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gdGhpcy5jbTtcbiAgICB0aGlzLmNyZWF0ZUZpZWxkKGRpc3BsYXkpO1xuICAgIHZhciB0ZSA9IHRoaXMudGV4dGFyZWE7XG5cbiAgICBkaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKHRoaXMud3JhcHBlciwgZGlzcGxheS53cmFwcGVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgLy8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXG4gICAgaWYgKGlvcykgeyB0ZS5zdHlsZS53aWR0aCA9IFwiMHB4XCI7IH1cblxuICAgIG9uKHRlLCBcImlucHV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcyQxLmhhc1NlbGVjdGlvbikgeyB0aGlzJDEuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgICAgaW5wdXQucG9sbCgpO1xuICAgIH0pO1xuXG4gICAgb24odGUsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XG5cbiAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSArbmV3IERhdGU7XG4gICAgICBpbnB1dC5mYXN0UG9sbCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgbnVsbCwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICAgICAgdGUudmFsdWUgPSByYW5nZXMudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7IGNtLnN0YXRlLmN1dEluY29taW5nID0gK25ldyBEYXRlOyB9XG4gICAgfVxuICAgIG9uKHRlLCBcImN1dFwiLCBwcmVwYXJlQ29weUN1dCk7XG4gICAgb24odGUsIFwiY29weVwiLCBwcmVwYXJlQ29weUN1dCk7XG5cbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmICghdGUuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gK25ldyBEYXRlO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyB0aGUgYHBhc3RlYCBldmVudCB0byB0aGUgdGV4dGFyZWEgc28gaXQncyBoYW5kbGVkIGJ5IGl0cyBldmVudCBsaXN0ZW5lci5cbiAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChcInBhc3RlXCIpO1xuICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YTtcbiAgICAgIHRlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgLy8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxuICAgIG9uKGRpc3BsYXkubGluZVNwYWNlLCBcInNlbGVjdHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuICAgIH0pO1xuXG4gICAgb24odGUsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBjbS5nZXRDdXJzb3IoXCJmcm9tXCIpO1xuICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykgeyBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTsgfVxuICAgICAgaW5wdXQuY29tcG9zaW5nID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIHJhbmdlOiBjbS5tYXJrVGV4dChzdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG9uKHRlLCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcbiAgICAgICAgaW5wdXQucG9sbCgpO1xuICAgICAgICBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5jcmVhdGVGaWVsZCA9IGZ1bmN0aW9uIChfZGlzcGxheSkge1xuICAgIC8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxuICAgIHRoaXMud3JhcHBlciA9IGhpZGRlblRleHRhcmVhKCk7XG4gICAgLy8gVGhlIHNlbWloaWRkZW4gdGV4dGFyZWEgdGhhdCBpcyBmb2N1c2VkIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIC8vIGZvY3VzZWQsIGFuZCByZWNlaXZlcyBpbnB1dC5cbiAgICB0aGlzLnRleHRhcmVhID0gdGhpcy53cmFwcGVyLmZpcnN0Q2hpbGQ7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgLy8gTGFiZWwgZm9yIHNjcmVlbnJlYWRlcnMsIGFjY2Vzc2liaWxpdHlcbiAgICBpZihsYWJlbCkge1xuICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dGFyZWEucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVkcmF3IHRoZSBzZWxlY3Rpb24gYW5kL29yIGN1cnNvclxuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24oY20pO1xuXG4gICAgLy8gTW92ZSB0aGUgaGlkZGVuIHRleHRhcmVhIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHNjcm9sbGluZyBhcnRpZmFjdHNcbiAgICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XG4gICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3JkcyhjbSwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgXCJkaXZcIik7XG4gICAgICB2YXIgd3JhcE9mZiA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGluZU9mZiA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlc3VsdC50ZVRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQgLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpO1xuICAgICAgcmVzdWx0LnRlTGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MubGVmdCArIGxpbmVPZmYubGVmdCAtIHdyYXBPZmYubGVmdCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGRyYXduKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuc2VsZWN0aW9uRGl2LCBkcmF3bi5zZWxlY3Rpb24pO1xuICAgIGlmIChkcmF3bi50ZVRvcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcInB4XCI7XG4gICAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGRyYXduLnRlTGVmdCArIFwicHhcIjtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVzZXQgdGhlIGlucHV0IHRvIGNvcnJlc3BvbmQgdG8gdGhlIHNlbGVjdGlvbiAob3IgdG8gYmUgZW1wdHksXG4gIC8vIHdoZW4gbm90IHR5cGluZyBhbmQgbm90aGluZyBpcyBzZWxlY3RlZClcbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodHlwaW5nKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8IHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSBjb250ZW50O1xuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSk7IH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBjb250ZW50OyB9XG4gICAgfSBlbHNlIGlmICghdHlwaW5nKSB7XG4gICAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcIlwiO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHRhcmVhIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy50ZXh0YXJlYSkpIHtcbiAgICAgIHRyeSB7IHRoaXMudGV4dGFyZWEuZm9jdXMoKTsgfVxuICAgICAgY2F0Y2ggKGUpIHt9IC8vIElFOCB3aWxsIHRocm93IGlmIHRoZSB0ZXh0YXJlYSBpcyBkaXNwbGF5OiBub25lIG9yIG5vdCBpbiBET01cbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCk7IH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSAwO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc2xvd1BvbGwoKTsgfTtcblxuICAvLyBQb2xsIGZvciBpbnB1dCBjaGFuZ2VzLCB1c2luZyB0aGUgbm9ybWFsIHJhdGUgb2YgcG9sbGluZy4gVGhpc1xuICAvLyBydW5zIGFzIGxvbmcgYXMgdGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zbG93UG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5wb2xsKCk7XG4gICAgICBpZiAodGhpcyQxLmNtLnN0YXRlLmZvY3VzZWQpIHsgdGhpcyQxLnNsb3dQb2xsKCk7IH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxuICAvLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcbiAgLy8gdGhlIGNoYW5nZSBhcHBlYXJzIG9uIHRoZSBzY3JlZW4gcXVpY2tseS5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZmFzdFBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pc3NlZCA9IGZhbHNlLCBpbnB1dCA9IHRoaXM7XG4gICAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnBvbGwoKTtcbiAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApO31cbiAgICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCk7fVxuICAgIH1cbiAgICBpbnB1dC5wb2xsaW5nLnNldCgyMCwgcCk7XG4gIH07XG5cbiAgLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXG4gIC8vIFdoZW4gc29tZXRoaW5nIGlzIHNlbGVjdGVkLCBpdCBpcyBwcmVzZW50IGluIHRoZSB0ZXh0YXJlYSwgYW5kXG4gIC8vIHNlbGVjdGVkICh1bmxlc3MgaXQgaXMgaHVnZSwgaW4gd2hpY2ggY2FzZSBhIHBsYWNlaG9sZGVyIGlzXG4gIC8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XG4gIC8vIHNlZW4gdGV4dCAoY2FuIGJlIGVtcHR5KSwgd2hpY2ggaXMgc3RvcmVkIGluIHByZXZJbnB1dCAod2UgbXVzdFxuICAvLyBub3QgcmVzZXQgdGhlIHRleHRhcmVhIHdoZW4gdHlwaW5nLCBiZWNhdXNlIHRoYXQgYnJlYWtzIElNRSkuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjbSA9IHRoaXMuY20sIGlucHV0ID0gdGhpcy50ZXh0YXJlYSwgcHJldklucHV0ID0gdGhpcy5wcmV2SW5wdXQ7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBjYWxsZWQgYSAqbG90KiwgdHJ5IHRvIGJhaWwgb3V0IGFzIGNoZWFwbHkgYXNcbiAgICAvLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXG4gICAgLy8gd2lsbCBiZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGEgbG90IG9mIHRleHQgaW4gdGhlIHRleHRhcmVhLFxuICAgIC8vIGluIHdoaWNoIGNhc2UgcmVhZGluZyBpdHMgdmFsdWUgd291bGQgYmUgZXhwZW5zaXZlLlxuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCAhY20uc3RhdGUuZm9jdXNlZCB8fFxuICAgICAgICAoaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0ICYmICF0aGlzLmNvbXBvc2luZykgfHxcbiAgICAgICAgY20uaXNSZWFkT25seSgpIHx8IGNtLm9wdGlvbnMuZGlzYWJsZUlucHV0IHx8IGNtLnN0YXRlLmtleVNlcSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHZhciB0ZXh0ID0gaW5wdXQudmFsdWU7XG4gICAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxuICAgIGlmICh0ZXh0ID09IHByZXZJbnB1dCAmJiAhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNpY2FsIHNlbGVjdGlvbiByZXNldHRpbmcgaW4gSUU5LzEwLCBhbmRcbiAgICAvLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXG4gICAgLy8gc29tZSBrZXkgY29tYm9zIGluIE1hYyAoIzI2ODkpLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcy5oYXNTZWxlY3Rpb24gPT09IHRleHQgfHxcbiAgICAgICAgbWFjICYmIC9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xuICAgICAgdmFyIGZpcnN0ID0gdGV4dC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGZpcnN0ID09IDB4MjAwYiAmJiAhcHJldklucHV0KSB7IHByZXZJbnB1dCA9IFwiXFx1MjAwYlwiOyB9XG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMWRhKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuIHRoaXMuY20uZXhlY0NvbW1hbmQoXCJ1bmRvXCIpIH1cbiAgICB9XG4gICAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgaW5wdXQgdGhhdCBpcyBhY3R1YWxseSBuZXdcbiAgICB2YXIgc2FtZSA9IDAsIGwgPSBNYXRoLm1pbihwcmV2SW5wdXQubGVuZ3RoLCB0ZXh0Lmxlbmd0aCk7XG4gICAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgeyArK3NhbWU7IH1cblxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSxcbiAgICAgICAgICAgICAgICAgICAgIG51bGwsIHRoaXMkMS5jb21wb3NpbmcgPyBcIipjb21wb3NlXCIgOiBudWxsKTtcblxuICAgICAgLy8gRG9uJ3QgbGVhdmUgbG9uZyB0ZXh0IGluIHRoZSB0ZXh0YXJlYSwgc2luY2UgaXQgbWFrZXMgZnVydGhlciBwb2xsaW5nIHNsb3dcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEwMDAgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpID4gLTEpIHsgaW5wdXQudmFsdWUgPSB0aGlzJDEucHJldklucHV0ID0gXCJcIjsgfVxuICAgICAgZWxzZSB7IHRoaXMkMS5wcmV2SW5wdXQgPSB0ZXh0OyB9XG5cbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZSA9IGNtLm1hcmtUZXh0KHRoaXMkMS5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0ICYmIHRoaXMucG9sbCgpKSB7IHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTsgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICB0aGlzLmZhc3RQb2xsKCk7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHRlID0gaW5wdXQudGV4dGFyZWE7XG4gICAgaWYgKGlucHV0LmNvbnRleHRNZW51UGVuZGluZykgeyBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcoKTsgfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICBpZiAoIXBvcyB8fCBwcmVzdG8pIHsgcmV0dXJuIH0gLy8gT3BlcmEgaXMgZGlmZmljdWx0LlxuXG4gICAgLy8gUmVzZXQgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gb25seSBpZiB0aGUgY2xpY2sgaXMgZG9uZSBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb25cbiAgICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXG4gICAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7XG4gICAgaWYgKHJlc2V0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA9PSAtMSlcbiAgICAgIHsgb3BlcmF0aW9uKGNtLCBzZXRTZWxlY3Rpb24pKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcyksIHNlbF9kb250U2Nyb2xsKTsgfVxuXG4gICAgdmFyIG9sZENTUyA9IHRlLnN0eWxlLmNzc1RleHQsIG9sZFdyYXBwZXJDU1MgPSBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQ7XG4gICAgdmFyIHdyYXBwZXJCb3ggPSBpbnB1dC53cmFwcGVyLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBzdGF0aWNcIjtcbiAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7XFxuICAgICAgdG9wOiBcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICsgXCJweDsgbGVmdDogXCIgKyAoZS5jbGllbnRYIC0gd3JhcHBlckJveC5sZWZ0IC0gNSkgKyBcInB4O1xcbiAgICAgIHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFwiICsgKGllID8gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcIiA6IFwidHJhbnNwYXJlbnRcIikgKyBcIjtcXG4gICAgICBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO1xuICAgIHZhciBvbGRTY3JvbGxZO1xuICAgIGlmICh3ZWJraXQpIHsgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZOyB9IC8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSAoIzI3MTIpXG4gICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgIGlmICh3ZWJraXQpIHsgd2luZG93LnNjcm9sbFRvKG51bGwsIG9sZFNjcm9sbFkpOyB9XG4gICAgZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgIC8vIEFkZHMgXCJTZWxlY3QgYWxsXCIgdG8gY29udGV4dCBtZW51IGluIEZGXG4gICAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHRlLnZhbHVlID0gaW5wdXQucHJldklucHV0ID0gXCIgXCI7IH1cbiAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSByZWhpZGU7XG4gICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG4gICAgY2xlYXJUaW1lb3V0KGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsKTtcblxuICAgIC8vIFNlbGVjdC1hbGwgd2lsbCBiZSBncmV5ZWQgb3V0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzZWxlY3QsIHNvXG4gICAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXG4gICAgLy8gaXQgZ290IHNlbGVjdGVkLlxuICAgIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3RBbGxIYWNrKCkge1xuICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgICAgdmFyIGV4dHZhbCA9IFwiXFx1MjAwYlwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgdGUudmFsdWUgPSBcIlxcdTIxZGFcIjsgLy8gVXNlZCB0byBjYXRjaCBjb250ZXh0LW1lbnUgdW5kb1xuICAgICAgICB0ZS52YWx1ZSA9IGV4dHZhbDtcbiAgICAgICAgaW5wdXQucHJldklucHV0ID0gc2VsZWN0ZWQgPyBcIlwiIDogXCJcXHUyMDBiXCI7XG4gICAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aDtcbiAgICAgICAgLy8gUmUtc2V0IHRoaXMsIGluIGNhc2Ugc29tZSBvdGhlciBoYW5kbGVyIHRvdWNoZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWhpZGUoKSB7XG4gICAgICBpZiAoaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nICE9IHJlaGlkZSkgeyByZXR1cm4gfVxuICAgICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gZmFsc2U7XG4gICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBvbGRXcmFwcGVyQ1NTO1xuICAgICAgdGUuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zKTsgfVxuXG4gICAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSB1c2VyIGNob29zaW5nIHNlbGVjdC1hbGxcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpOyB9XG4gICAgICAgIHZhciBpID0gMCwgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9PSBjbS5kb2Muc2VsICYmIHRlLnNlbGVjdGlvblN0YXJ0ID09IDAgJiZcbiAgICAgICAgICAgICAgdGUuc2VsZWN0aW9uRW5kID4gMCAmJiBpbnB1dC5wcmV2SW5wdXQgPT0gXCJcXHUyMDBiXCIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbihjbSwgc2VsZWN0QWxsKShjbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpKysgPCAxMCkge1xuICAgICAgICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDUwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDIwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpOyB9XG4gICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7XG4gICAgICBlX3N0b3AoZSk7XG4gICAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgMjApO1xuICAgICAgfTtcbiAgICAgIG9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApO1xuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHsgdGhpcy5yZXNldCgpOyB9XG4gICAgdGhpcy50ZXh0YXJlYS5kaXNhYmxlZCA9IHZhbCA9PSBcIm5vY3Vyc29yXCI7XG4gICAgdGhpcy50ZXh0YXJlYS5yZWFkT25seSA9ICEhdmFsO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmcm9tVGV4dEFyZWEodGV4dGFyZWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICBvcHRpb25zLnZhbHVlID0gdGV4dGFyZWEudmFsdWU7XG4gICAgaWYgKCFvcHRpb25zLnRhYmluZGV4ICYmIHRleHRhcmVhLnRhYkluZGV4KVxuICAgICAgeyBvcHRpb25zLnRhYmluZGV4ID0gdGV4dGFyZWEudGFiSW5kZXg7IH1cbiAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXIgJiYgdGV4dGFyZWEucGxhY2Vob2xkZXIpXG4gICAgICB7IG9wdGlvbnMucGxhY2Vob2xkZXIgPSB0ZXh0YXJlYS5wbGFjZWhvbGRlcjsgfVxuICAgIC8vIFNldCBhdXRvZm9jdXMgdG8gdHJ1ZSBpZiB0aGlzIHRleHRhcmVhIGlzIGZvY3VzZWQsIG9yIGlmIGl0IGhhc1xuICAgIC8vIGF1dG9mb2N1cyBhbmQgbm8gb3RoZXIgZWxlbWVudCBpcyBmb2N1c2VkLlxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XG4gICAgICB2YXIgaGFzRm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgIG9wdGlvbnMuYXV0b2ZvY3VzID0gaGFzRm9jdXMgPT0gdGV4dGFyZWEgfHxcbiAgICAgICAgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlKCkge3RleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKTt9XG5cbiAgICB2YXIgcmVhbFN1Ym1pdDtcbiAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xuICAgICAgb24odGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAvLyBEZXBsb3JhYmxlIGhhY2sgdG8gbWFrZSB0aGUgc3VibWl0IG1ldGhvZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xuICAgICAgICB2YXIgZm9ybSA9IHRleHRhcmVhLmZvcm07XG4gICAgICAgIHJlYWxTdWJtaXQgPSBmb3JtLnN1Ym1pdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgd3JhcHBlZFN1Ym1pdCA9IGZvcm0uc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gd3JhcHBlZFN1Ym1pdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgICBjbS5zYXZlID0gc2F2ZTtcbiAgICAgIGNtLmdldFRleHRBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dGFyZWE7IH07XG4gICAgICBjbS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS50b1RleHRBcmVhID0gaXNOYU47IC8vIFByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHJhbiB0d2ljZVxuICAgICAgICBzYXZlKCk7XG4gICAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY20uZ2V0V3JhcHBlckVsZW1lbnQoKSk7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xuICAgICAgICAgIG9mZih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSAmJiB0eXBlb2YgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgeyB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7IH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHZhciBjbSA9IENvZGVNaXJyb3IoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTsgfSxcbiAgICAgIG9wdGlvbnMpO1xuICAgIHJldHVybiBjbVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcikge1xuICAgIENvZGVNaXJyb3Iub2ZmID0gb2ZmO1xuICAgIENvZGVNaXJyb3Iub24gPSBvbjtcbiAgICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSB3aGVlbEV2ZW50UGl4ZWxzO1xuICAgIENvZGVNaXJyb3IuRG9jID0gRG9jO1xuICAgIENvZGVNaXJyb3Iuc3BsaXRMaW5lcyA9IHNwbGl0TGluZXNBdXRvO1xuICAgIENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBjb3VudENvbHVtbjtcbiAgICBDb2RlTWlycm9yLmZpbmRDb2x1bW4gPSBmaW5kQ29sdW1uO1xuICAgIENvZGVNaXJyb3IuaXNXb3JkQ2hhciA9IGlzV29yZENoYXJCYXNpYztcbiAgICBDb2RlTWlycm9yLlBhc3MgPSBQYXNzO1xuICAgIENvZGVNaXJyb3Iuc2lnbmFsID0gc2lnbmFsO1xuICAgIENvZGVNaXJyb3IuTGluZSA9IExpbmU7XG4gICAgQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBjaGFuZ2VFbmQ7XG4gICAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbCA9IHNjcm9sbGJhck1vZGVsO1xuICAgIENvZGVNaXJyb3IuUG9zID0gUG9zO1xuICAgIENvZGVNaXJyb3IuY21wUG9zID0gY21wO1xuICAgIENvZGVNaXJyb3IubW9kZXMgPSBtb2RlcztcbiAgICBDb2RlTWlycm9yLm1pbWVNb2RlcyA9IG1pbWVNb2RlcztcbiAgICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gcmVzb2x2ZU1vZGU7XG4gICAgQ29kZU1pcnJvci5nZXRNb2RlID0gZ2V0TW9kZTtcbiAgICBDb2RlTWlycm9yLm1vZGVFeHRlbnNpb25zID0gbW9kZUV4dGVuc2lvbnM7XG4gICAgQ29kZU1pcnJvci5leHRlbmRNb2RlID0gZXh0ZW5kTW9kZTtcbiAgICBDb2RlTWlycm9yLmNvcHlTdGF0ZSA9IGNvcHlTdGF0ZTtcbiAgICBDb2RlTWlycm9yLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gaW5uZXJNb2RlO1xuICAgIENvZGVNaXJyb3IuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICBDb2RlTWlycm9yLmtleU1hcCA9IGtleU1hcDtcbiAgICBDb2RlTWlycm9yLmtleU5hbWUgPSBrZXlOYW1lO1xuICAgIENvZGVNaXJyb3IuaXNNb2RpZmllcktleSA9IGlzTW9kaWZpZXJLZXk7XG4gICAgQ29kZU1pcnJvci5sb29rdXBLZXkgPSBsb29rdXBLZXk7XG4gICAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAgPSBub3JtYWxpemVLZXlNYXA7XG4gICAgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW07XG4gICAgQ29kZU1pcnJvci5TaGFyZWRUZXh0TWFya2VyID0gU2hhcmVkVGV4dE1hcmtlcjtcbiAgICBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBUZXh0TWFya2VyO1xuICAgIENvZGVNaXJyb3IuTGluZVdpZGdldCA9IExpbmVXaWRnZXQ7XG4gICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0ID0gZV9wcmV2ZW50RGVmYXVsdDtcbiAgICBDb2RlTWlycm9yLmVfc3RvcFByb3BhZ2F0aW9uID0gZV9zdG9wUHJvcGFnYXRpb247XG4gICAgQ29kZU1pcnJvci5lX3N0b3AgPSBlX3N0b3A7XG4gICAgQ29kZU1pcnJvci5hZGRDbGFzcyA9IGFkZENsYXNzO1xuICAgIENvZGVNaXJyb3IuY29udGFpbnMgPSBjb250YWlucztcbiAgICBDb2RlTWlycm9yLnJtQ2xhc3MgPSBybUNsYXNzO1xuICAgIENvZGVNaXJyb3Iua2V5TmFtZXMgPSBrZXlOYW1lcztcbiAgfVxuXG4gIC8vIEVESVRPUiBDT05TVFJVQ1RPUlxuXG4gIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcik7XG5cbiAgYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKTtcblxuICAvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cbiAgdmFyIGRvbnREZWxlZ2F0ZSA9IFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpIHsgaWYgKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgaW5kZXhPZihkb250RGVsZWdhdGUsIHByb3ApIDwgMClcbiAgICB7IENvZGVNaXJyb3IucHJvdG90eXBlW3Byb3BdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBtZXRob2QuYXBwbHkodGhpcy5kb2MsIGFyZ3VtZW50cyl9XG4gICAgfSkoRG9jLnByb3RvdHlwZVtwcm9wXSk7IH0gfVxuXG4gIGV2ZW50TWl4aW4oRG9jKTtcbiAgQ29kZU1pcnJvci5pbnB1dFN0eWxlcyA9IHtcInRleHRhcmVhXCI6IFRleHRhcmVhSW5wdXQsIFwiY29udGVudGVkaXRhYmxlXCI6IENvbnRlbnRFZGl0YWJsZUlucHV0fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZS8qLCBtb2RlLCDigKYqLykge1xuICAgIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXCJudWxsXCIpIHsgQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlID0gbmFtZTsgfVxuICAgIGRlZmluZU1vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUgPSBkZWZpbmVNSU1FO1xuXG4gIC8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJudWxsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7dG9rZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsgcmV0dXJuIHN0cmVhbS5za2lwVG9FbmQoKTsgfX0pOyB9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9wbGFpblwiLCBcIm51bGxcIik7XG5cbiAgLy8gRVhURU5TSU9OU1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG4gIENvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICBEb2MucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgfTtcblxuICBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSA9IGZyb21UZXh0QXJlYTtcblxuICBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKTtcblxuICBDb2RlTWlycm9yLnZlcnNpb24gPSBcIjUuNjMuM1wiO1xuXG4gIHJldHVybiBDb2RlTWlycm9yO1xuXG59KSkpO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJqYXZhc2NyaXB0XCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gIHZhciBzdGF0ZW1lbnRJbmRlbnQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50O1xuICB2YXIganNvbmxkTW9kZSA9IHBhcnNlckNvbmZpZy5qc29ubGQ7XG4gIHZhciBqc29uTW9kZSA9IHBhcnNlckNvbmZpZy5qc29uIHx8IGpzb25sZE1vZGU7XG4gIHZhciB0cmFja1Njb3BlID0gcGFyc2VyQ29uZmlnLnRyYWNrU2NvcGUgIT09IGZhbHNlXG4gIHZhciBpc1RTID0gcGFyc2VyQ29uZmlnLnR5cGVzY3JpcHQ7XG4gIHZhciB3b3JkUkUgPSBwYXJzZXJDb25maWcud29yZENoYXJhY3RlcnMgfHwgL1tcXHckXFx4YTEtXFx1ZmZmZl0vO1xuXG4gIC8vIFRva2VuaXplclxuXG4gIHZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uKCl7XG4gICAgZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG4gICAgdmFyIEEgPSBrdyhcImtleXdvcmQgYVwiKSwgQiA9IGt3KFwia2V5d29yZCBiXCIpLCBDID0ga3coXCJrZXl3b3JkIGNcIiksIEQgPSBrdyhcImtleXdvcmQgZFwiKTtcbiAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIFwiaWZcIjoga3coXCJpZlwiKSwgXCJ3aGlsZVwiOiBBLCBcIndpdGhcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQiwgXCJmaW5hbGx5XCI6IEIsXG4gICAgICBcInJldHVyblwiOiBELCBcImJyZWFrXCI6IEQsIFwiY29udGludWVcIjogRCwgXCJuZXdcIjoga3coXCJuZXdcIiksIFwiZGVsZXRlXCI6IEMsIFwidm9pZFwiOiBDLCBcInRocm93XCI6IEMsXG4gICAgICBcImRlYnVnZ2VyXCI6IGt3KFwiZGVidWdnZXJcIiksIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImNvbnN0XCI6IGt3KFwidmFyXCIpLCBcImxldFwiOiBrdyhcInZhclwiKSxcbiAgICAgIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLFxuICAgICAgXCJmb3JcIjoga3coXCJmb3JcIiksIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLCBcImNhc2VcIjoga3coXCJjYXNlXCIpLCBcImRlZmF1bHRcIjoga3coXCJkZWZhdWx0XCIpLFxuICAgICAgXCJpblwiOiBvcGVyYXRvciwgXCJ0eXBlb2ZcIjogb3BlcmF0b3IsIFwiaW5zdGFuY2VvZlwiOiBvcGVyYXRvcixcbiAgICAgIFwidHJ1ZVwiOiBhdG9tLCBcImZhbHNlXCI6IGF0b20sIFwibnVsbFwiOiBhdG9tLCBcInVuZGVmaW5lZFwiOiBhdG9tLCBcIk5hTlwiOiBhdG9tLCBcIkluZmluaXR5XCI6IGF0b20sXG4gICAgICBcInRoaXNcIjoga3coXCJ0aGlzXCIpLCBcImNsYXNzXCI6IGt3KFwiY2xhc3NcIiksIFwic3VwZXJcIjoga3coXCJhdG9tXCIpLFxuICAgICAgXCJ5aWVsZFwiOiBDLCBcImV4cG9ydFwiOiBrdyhcImV4cG9ydFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwiZXh0ZW5kc1wiOiBDLFxuICAgICAgXCJhd2FpdFwiOiBDXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fH5eQF0vO1xuICB2YXIgaXNKc29ubGRLZXl3b3JkID0gL15AKGNvbnRleHR8aWR8dmFsdWV8bGFuZ3VhZ2V8dHlwZXxjb250YWluZXJ8bGlzdHxzZXR8cmV2ZXJzZXxpbmRleHxiYXNlfHZvY2FifGdyYXBoKVwiLztcblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKHN0cmVhbSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGluU2V0ID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChuZXh0ID09IFwiL1wiICYmICFpblNldCkgcmV0dXJuO1xuICAgICAgICBpZiAobmV4dCA9PSBcIltcIikgaW5TZXQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChpblNldCAmJiBuZXh0ID09IFwiXVwiKSBpblNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAvLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbiAgdmFyIHR5cGUsIGNvbnRlbnQ7XG4gIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxkW1xcZF9dKig/OltlRV1bK1xcLV0/W1xcZF9dKyk/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcInNwcmVhZFwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcIj0+XCIsIFwib3BlcmF0b3JcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0ubWF0Y2goL14oPzp4W1xcZEEtRmEtZl9dK3xvWzAtN19dK3xiWzAxX10rKW4/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcZF9dKig/Om58KD86XFwuW1xcZF9dKik/KD86W2VFXVsrXFwtXT9bXFxkX10rKT8pPy8pO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCAxKSkge1xuICAgICAgICByZWFkUmVnZXhwKHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlxcYigoW2dpbXl1c10pKD8hW2dpbXl1c10qXFwyKSkrXFxiLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXQoXCI9XCIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICByZXR1cm4gdG9rZW5RdWFzaShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5wZWVrKCkgPT0gXCIhXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJtZXRhXCIsIFwibWV0YVwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpKSB7XG4gICAgICByZXR1cm4gcmV0KFwidmFyaWFibGVcIiwgXCJwcm9wZXJ0eVwiKVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIgJiYgc3RyZWFtLm1hdGNoKFwiIS0tXCIpIHx8XG4gICAgICAgICAgICAgICAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIikgJiYgIS9cXFMvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0uc3RhcnQpKSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpXG4gICAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoICE9IFwiPlwiIHx8ICFzdGF0ZS5sZXhpY2FsIHx8IHN0YXRlLmxleGljYWwudHlwZSAhPSBcIj5cIikge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gXCIhXCIgfHwgY2ggPT0gXCI9XCIpIHN0cmVhbS5lYXQoXCI9XCIpXG4gICAgICAgIH0gZWxzZSBpZiAoL1s8PiorXFwtfCY/XS8udGVzdChjaCkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0KGNoKVxuICAgICAgICAgIGlmIChjaCA9PSBcIj5cIikgc3RyZWFtLmVhdChjaClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5lYXQoXCIuXCIpKSByZXR1cm4gcmV0KFwiLlwiKVxuICAgICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpXG4gICAgICBpZiAoc3RhdGUubGFzdFR5cGUgIT0gXCIuXCIpIHtcbiAgICAgICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpKSB7XG4gICAgICAgICAgdmFyIGt3ID0ga2V5d29yZHNbd29yZF1cbiAgICAgICAgICByZXR1cm4gcmV0KGt3LnR5cGUsIGt3LnN0eWxlLCB3b3JkKVxuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID09IFwiYXN5bmNcIiAmJiBzdHJlYW0ubWF0Y2goL14oXFxzfFxcL1xcKihbXipdfFxcKig/IVxcLykpKj9cXCpcXC8pKltcXFtcXChcXHddLywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiByZXQoXCJhc3luY1wiLCBcImtleXdvcmRcIiwgd29yZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICAgIGlmIChqc29ubGRNb2RlICYmIHN0cmVhbS5wZWVrKCkgPT0gXCJAXCIgJiYgc3RyZWFtLm1hdGNoKGlzSnNvbmxkS2V5d29yZCkpe1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIHJldChcImpzb25sZC1rZXl3b3JkXCIsIFwibWV0YVwiKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIGJyZWFrO1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmICghZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmICghZXNjYXBlZCAmJiAobmV4dCA9PSBcImBcIiB8fCBuZXh0ID09IFwiJFwiICYmIHN0cmVhbS5lYXQoXCJ7XCIpKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcInF1YXNpXCIsIFwic3RyaW5nLTJcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gIH1cblxuICB2YXIgYnJhY2tldHMgPSBcIihbe31dKVwiO1xuICAvLyBUaGlzIGlzIGEgY3J1ZGUgbG9va2FoZWFkIHRyaWNrIHRvIHRyeSBhbmQgbm90aWNlIHRoYXQgd2UncmVcbiAgLy8gcGFyc2luZyB0aGUgYXJndW1lbnQgcGF0dGVybnMgZm9yIGEgZmF0LWFycm93IGZ1bmN0aW9uIGJlZm9yZSB3ZVxuICAvLyBhY3R1YWxseSBoaXQgdGhlIGFycm93IHRva2VuLiBJdCBvbmx5IHdvcmtzIGlmIHRoZSBhcnJvdyBpcyBvblxuICAvLyB0aGUgc2FtZSBsaW5lIGFzIHRoZSBhcmd1bWVudHMgYW5kIHRoZXJlJ3Mgbm8gc3RyYW5nZSBub2lzZVxuICAvLyAoY29tbWVudHMpIGluIGJldHdlZW4uIEZhbGxiYWNrIGlzIHRvIG9ubHkgbm90aWNlIHdoZW4gd2UgaGl0IHRoZVxuICAvLyBhcnJvdywgYW5kIG5vdCBkZWNsYXJlIHRoZSBhcmd1bWVudHMgYXMgbG9jYWxzIGZvciB0aGUgYXJyb3dcbiAgLy8gYm9keS5cbiAgZnVuY3Rpb24gZmluZEZhdEFycm93KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZmF0QXJyb3dBdCkgc3RhdGUuZmF0QXJyb3dBdCA9IG51bGw7XG4gICAgdmFyIGFycm93ID0gc3RyZWFtLnN0cmluZy5pbmRleE9mKFwiPT5cIiwgc3RyZWFtLnN0YXJ0KTtcbiAgICBpZiAoYXJyb3cgPCAwKSByZXR1cm47XG5cbiAgICBpZiAoaXNUUykgeyAvLyBUcnkgdG8gc2tpcCBUeXBlU2NyaXB0IHJldHVybiB0eXBlIGRlY2xhcmF0aW9ucyBhZnRlciB0aGUgYXJndW1lbnRzXG4gICAgICB2YXIgbSA9IC86XFxzKig/OlxcdysoPzo8W14+XSo+fFxcW1xcXSk/fFxce1tefV0qXFx9KVxccyokLy5leGVjKHN0cmVhbS5zdHJpbmcuc2xpY2Uoc3RyZWFtLnN0YXJ0LCBhcnJvdykpXG4gICAgICBpZiAobSkgYXJyb3cgPSBtLmluZGV4XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gMCwgc2F3U29tZXRoaW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcG9zID0gYXJyb3cgLSAxOyBwb3MgPj0gMDsgLS1wb3MpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICB2YXIgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2YoY2gpO1xuICAgICAgaWYgKGJyYWNrZXQgPj0gMCAmJiBicmFja2V0IDwgMykge1xuICAgICAgICBpZiAoIWRlcHRoKSB7ICsrcG9zOyBicmVhazsgfVxuICAgICAgICBpZiAoLS1kZXB0aCA9PSAwKSB7IGlmIChjaCA9PSBcIihcIikgc2F3U29tZXRoaW5nID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldCA+PSAzICYmIGJyYWNrZXQgPCA2KSB7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IGVsc2UgaWYgKHdvcmRSRS50ZXN0KGNoKSkge1xuICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICgvW1wiJ1xcL2BdLy50ZXN0KGNoKSkge1xuICAgICAgICBmb3IgKDs7IC0tcG9zKSB7XG4gICAgICAgICAgaWYgKHBvcyA9PSAwKSByZXR1cm5cbiAgICAgICAgICB2YXIgbmV4dCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyAtIDEpXG4gICAgICAgICAgaWYgKG5leHQgPT0gY2ggJiYgc3RyZWFtLnN0cmluZy5jaGFyQXQocG9zIC0gMikgIT0gXCJcXFxcXCIpIHsgcG9zLS07IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYXdTb21ldGhpbmcgJiYgIWRlcHRoKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNhd1NvbWV0aGluZyAmJiAhZGVwdGgpIHN0YXRlLmZhdEFycm93QXQgPSBwb3M7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICB2YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgIFwicmVnZXhwXCI6IHRydWUsIFwidGhpc1wiOiB0cnVlLCBcImltcG9ydFwiOiB0cnVlLCBcImpzb25sZC1rZXl3b3JkXCI6IHRydWV9O1xuXG4gIGZ1bmN0aW9uIEpTTGV4aWNhbChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldiwgaW5mbykge1xuICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICBpZiAoYWxpZ24gIT0gbnVsbCkgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5TY29wZShzdGF0ZSwgdmFybmFtZSkge1xuICAgIGlmICghdHJhY2tTY29wZSkgcmV0dXJuIGZhbHNlXG4gICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gICAgZm9yICh2YXIgY3ggPSBzdGF0ZS5jb250ZXh0OyBjeDsgY3ggPSBjeC5wcmV2KSB7XG4gICAgICBmb3IgKHZhciB2ID0gY3gudmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gICAgdmFyIGNjID0gc3RhdGUuY2M7XG4gICAgLy8gQ29tbXVuaWNhdGUgb3VyIGNvbnRleHQgdG8gdGhlIGNvbWJpbmF0b3JzLlxuICAgIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gICAgY3guc3RhdGUgPSBzdGF0ZTsgY3guc3RyZWFtID0gc3RyZWFtOyBjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjOyBjeC5zdHlsZSA9IHN0eWxlO1xuXG4gICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHZhciBjb21iaW5hdG9yID0gY2MubGVuZ3RoID8gY2MucG9wKCkgOiBqc29uTW9kZSA/IGV4cHJlc3Npb24gOiBzdGF0ZW1lbnQ7XG4gICAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgICB3aGlsZShjYy5sZW5ndGggJiYgY2NbY2MubGVuZ3RoIC0gMV0ubGV4KVxuICAgICAgICAgIGNjLnBvcCgpKCk7XG4gICAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvciB1dGlsc1xuXG4gIHZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbiAgZnVuY3Rpb24gcGFzcygpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udCgpIHtcbiAgICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaW5MaXN0KG5hbWUsIGxpc3QpIHtcbiAgICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dCkgaWYgKHYubmFtZSA9PSBuYW1lKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICBpZiAoIXRyYWNrU2NvcGUpIHJldHVyblxuICAgIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC5pbmZvID09IFwidmFyXCIgJiYgc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LmJsb2NrKSB7XG4gICAgICAgIC8vIEZJWE1FIGZ1bmN0aW9uIGRlY2xzIGFyZSBhbHNvIG5vdCBibG9jayBzY29wZWRcbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSByZWdpc3RlclZhclNjb3BlZCh2YXJuYW1lLCBzdGF0ZS5jb250ZXh0KVxuICAgICAgICBpZiAobmV3Q29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ld0NvbnRleHRcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmxvY2FsVmFycykpIHtcbiAgICAgICAgc3RhdGUubG9jYWxWYXJzID0gbmV3IFZhcih2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIHRocm91Z2ggbWVhbnMgdGhpcyBpcyBnbG9iYWxcbiAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgJiYgIWluTGlzdCh2YXJuYW1lLCBzdGF0ZS5nbG9iYWxWYXJzKSlcbiAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSBuZXcgVmFyKHZhcm5hbWUsIHN0YXRlLmdsb2JhbFZhcnMpXG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJWYXJTY29wZWQodmFybmFtZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQuYmxvY2spIHtcbiAgICAgIHZhciBpbm5lciA9IHJlZ2lzdGVyVmFyU2NvcGVkKHZhcm5hbWUsIGNvbnRleHQucHJldilcbiAgICAgIGlmICghaW5uZXIpIHJldHVybiBudWxsXG4gICAgICBpZiAoaW5uZXIgPT0gY29udGV4dC5wcmV2KSByZXR1cm4gY29udGV4dFxuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGlubmVyLCBjb250ZXh0LnZhcnMsIHRydWUpXG4gICAgfSBlbHNlIGlmIChpbkxpc3QodmFybmFtZSwgY29udGV4dC52YXJzKSkge1xuICAgICAgcmV0dXJuIGNvbnRleHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGNvbnRleHQucHJldiwgbmV3IFZhcih2YXJuYW1lLCBjb250ZXh0LnZhcnMpLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc01vZGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PSBcInB1YmxpY1wiIHx8IG5hbWUgPT0gXCJwcml2YXRlXCIgfHwgbmFtZSA9PSBcInByb3RlY3RlZFwiIHx8IG5hbWUgPT0gXCJhYnN0cmFjdFwiIHx8IG5hbWUgPT0gXCJyZWFkb25seVwiXG4gIH1cblxuICAvLyBDb21iaW5hdG9yc1xuXG4gIGZ1bmN0aW9uIENvbnRleHQocHJldiwgdmFycywgYmxvY2spIHsgdGhpcy5wcmV2ID0gcHJldjsgdGhpcy52YXJzID0gdmFyczsgdGhpcy5ibG9jayA9IGJsb2NrIH1cbiAgZnVuY3Rpb24gVmFyKG5hbWUsIG5leHQpIHsgdGhpcy5uYW1lID0gbmFtZTsgdGhpcy5uZXh0ID0gbmV4dCB9XG5cbiAgdmFyIGRlZmF1bHRWYXJzID0gbmV3IFZhcihcInRoaXNcIiwgbmV3IFZhcihcImFyZ3VtZW50c1wiLCBudWxsKSlcbiAgZnVuY3Rpb24gcHVzaGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGN4LnN0YXRlLmNvbnRleHQsIGN4LnN0YXRlLmxvY2FsVmFycywgZmFsc2UpXG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gZGVmYXVsdFZhcnNcbiAgfVxuICBmdW5jdGlvbiBwdXNoYmxvY2tjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5zdGF0ZS5jb250ZXh0LCBjeC5zdGF0ZS5sb2NhbFZhcnMsIHRydWUpXG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gbnVsbFxuICB9XG4gIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzXG4gICAgY3guc3RhdGUuY29udGV4dCA9IGN4LnN0YXRlLmNvbnRleHQucHJldlxuICB9XG4gIHBvcGNvbnRleHQubGV4ID0gdHJ1ZVxuICBmdW5jdGlvbiBwdXNobGV4KHR5cGUsIGluZm8pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZSwgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwic3RhdFwiKSBpbmRlbnQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBmb3IgKHZhciBvdXRlciA9IHN0YXRlLmxleGljYWw7IG91dGVyICYmIG91dGVyLnR5cGUgPT0gXCIpXCIgJiYgb3V0ZXIuYWxpZ247IG91dGVyID0gb3V0ZXIucHJldilcbiAgICAgICAgaW5kZW50ID0gb3V0ZXIuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEpTTGV4aWNhbChpbmRlbnQsIGN4LnN0cmVhbS5jb2x1bW4oKSwgdHlwZSwgbnVsbCwgc3RhdGUubGV4aWNhbCwgaW5mbyk7XG4gICAgfTtcbiAgICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC5wcmV2KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gc3RhdGUubGV4aWNhbC5wcmV2O1xuICAgIH1cbiAgfVxuICBwb3BsZXgubGV4ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gICAgZnVuY3Rpb24gZXhwKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IHdhbnRlZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGVsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIiB8fCB0eXBlID09IFwifVwiIHx8IHR5cGUgPT0gXCIpXCIgfHwgdHlwZSA9PSBcIl1cIikgcmV0dXJuIHBhc3MoKTtcbiAgICAgIGVsc2UgcmV0dXJuIGNvbnQoZXhwKTtcbiAgICB9O1xuICAgIHJldHVybiBleHA7XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIsIHZhbHVlKSwgdmFyZGVmLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBhXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBkXCIpIHJldHVybiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqJC8sIGZhbHNlKSA/IGNvbnQoKSA6IGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImRlYnVnZ2VyXCIpIHJldHVybiBjb250KGV4cGVjdChcIjtcIikpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgcHVzaGJsb2NrY29udGV4dCwgYmxvY2ssIHBvcGxleCwgcG9wY29udGV4dCk7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpZlwiKSB7XG4gICAgICBpZiAoY3guc3RhdGUubGV4aWNhbC5pbmZvID09IFwiZWxzZVwiICYmIGN4LnN0YXRlLmNjW2N4LnN0YXRlLmNjLmxlbmd0aCAtIDFdID09IHBvcGxleClcbiAgICAgICAgY3guc3RhdGUuY2MucG9wKCkoKTtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIHN0YXRlbWVudCwgcG9wbGV4LCBtYXliZWVsc2UpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcImZvclwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGJsb2NrY29udGV4dCwgZm9yc3BlYywgc3RhdGVtZW50LCBwb3Bjb250ZXh0LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiY2xhc3NcIiB8fCAoaXNUUyAmJiB2YWx1ZSA9PSBcImludGVyZmFjZVwiKSkge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIHR5cGUgPT0gXCJjbGFzc1wiID8gdHlwZSA6IHZhbHVlKSwgY2xhc3NOYW1lLCBwb3BsZXgpXG4gICAgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCJkZWNsYXJlXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgICAgcmV0dXJuIGNvbnQoc3RhdGVtZW50KVxuICAgICAgfSBlbHNlIGlmIChpc1RTICYmICh2YWx1ZSA9PSBcIm1vZHVsZVwiIHx8IHZhbHVlID09IFwiZW51bVwiIHx8IHZhbHVlID09IFwidHlwZVwiKSAmJiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqXFx3LywgZmFsc2UpKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImVudW1cIikgcmV0dXJuIGNvbnQoZW51bWRlZik7XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwidHlwZVwiKSByZXR1cm4gY29udCh0eXBlbmFtZSwgZXhwZWN0KFwib3BlcmF0b3JcIiksIHR5cGVleHByLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGF0dGVybiwgZXhwZWN0KFwie1wiKSwgcHVzaGxleChcIn1cIiksIGJsb2NrLCBwb3BsZXgsIHBvcGxleClcbiAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleClcbiAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcImFic3RyYWN0XCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgICAgcmV0dXJuIGNvbnQoc3RhdGVtZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlbGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInN3aXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGFyZW5FeHByLCBleHBlY3QoXCJ7XCIpLCBwdXNobGV4KFwifVwiLCBcInN3aXRjaFwiKSwgcHVzaGJsb2NrY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ssIHBvcGxleCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcImNhc2VcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiOlwiKSk7XG4gICAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiY2F0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHB1c2hjb250ZXh0LCBtYXliZUNhdGNoQmluZGluZywgc3RhdGVtZW50LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwiZXhwb3J0XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBhZnRlckV4cG9ydCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImltcG9ydFwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgYWZ0ZXJJbXBvcnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiKSByZXR1cm4gY29udChzdGF0ZW1lbnQpXG4gICAgaWYgKHZhbHVlID09IFwiQFwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBzdGF0ZW1lbnQpXG4gICAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVDYXRjaEJpbmRpbmcodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChmdW5hcmcsIGV4cGVjdChcIilcIikpXG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbih0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uTm9Db21tYSh0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgdmFsdWUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcmVuRXhwcih0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCIoXCIpIHJldHVybiBwYXNzKClcbiAgICByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgpXG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbklubmVyKHR5cGUsIHZhbHVlLCBub0NvbW1hKSB7XG4gICAgaWYgKGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0KSB7XG4gICAgICB2YXIgYm9keSA9IG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5O1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAoZnVuYXJnLCBcIilcIiksIHBvcGxleCwgZXhwZWN0KFwiPT5cIiksIGJvZHksIHBvcGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKHB1c2hjb250ZXh0LCBwYXR0ZXJuLCBleHBlY3QoXCI9PlwiKSwgYm9keSwgcG9wY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlb3AgPSBub0NvbW1hID8gbWF5YmVvcGVyYXRvck5vQ29tbWEgOiBtYXliZW9wZXJhdG9yQ29tbWE7XG4gICAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmLCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcImNsYXNzXCIgfHwgKGlzVFMgJiYgdmFsdWUgPT0gXCJpbnRlcmZhY2VcIikpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBjbGFzc0V4cHJlc3Npb24sIHBvcGxleCk7IH1cbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgY1wiIHx8IHR5cGUgPT0gXCJhc3luY1wiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGFycmF5TGl0ZXJhbCwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChvYmpwcm9wLCBcIn1cIiwgbnVsbCwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJxdWFzaVwiKSByZXR1cm4gcGFzcyhxdWFzaSwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJuZXdcIikgcmV0dXJuIGNvbnQobWF5YmVUYXJnZXQobm9Db21tYSkpO1xuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvWztcXH1cXClcXF0sXS8pKSByZXR1cm4gcGFzcygpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvckNvbW1hKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZSwgdmFsdWUsIG5vQ29tbWEpIHtcbiAgICB2YXIgbWUgPSBub0NvbW1hID09IGZhbHNlID8gbWF5YmVvcGVyYXRvckNvbW1hIDogbWF5YmVvcGVyYXRvck5vQ29tbWE7XG4gICAgdmFyIGV4cHIgPSBub0NvbW1hID09IGZhbHNlID8gZXhwcmVzc2lvbiA6IGV4cHJlc3Npb25Ob0NvbW1hO1xuICAgIGlmICh0eXBlID09IFwiPT5cIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgIGlmICgvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSB8fCBpc1RTICYmIHZhbHVlID09IFwiIVwiKSByZXR1cm4gY29udChtZSk7XG4gICAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIiAmJiBjeC5zdHJlYW0ubWF0Y2goL14oW148Pl18PFtePD5dKj4pKj5cXHMqXFwoLywgZmFsc2UpKVxuICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZWV4cHIsIFwiPlwiKSwgcG9wbGV4LCBtZSk7XG4gICAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIiksIGV4cHIpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwicXVhc2lcIikgeyByZXR1cm4gcGFzcyhxdWFzaSwgbWUpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnRDb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCIpXCIsIFwiY2FsbFwiLCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KHByb3BlcnR5LCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIHBvcGxleCwgbWUpO1xuICAgIGlmIChpc1RTICYmIHZhbHVlID09IFwiYXNcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQodHlwZWV4cHIsIG1lKSB9XG4gICAgaWYgKHR5cGUgPT0gXCJyZWdleHBcIikge1xuICAgICAgY3guc3RhdGUubGFzdFR5cGUgPSBjeC5tYXJrZWQgPSBcIm9wZXJhdG9yXCJcbiAgICAgIGN4LnN0cmVhbS5iYWNrVXAoY3guc3RyZWFtLnBvcyAtIGN4LnN0cmVhbS5zdGFydCAtIDEpXG4gICAgICByZXR1cm4gY29udChleHByKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBxdWFzaSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlICE9IFwicXVhc2lcIikgcmV0dXJuIHBhc3MoKTtcbiAgICBpZiAodmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gMikgIT0gXCIke1wiKSByZXR1cm4gY29udChxdWFzaSk7XG4gICAgcmV0dXJuIGNvbnQobWF5YmVleHByZXNzaW9uLCBjb250aW51ZVF1YXNpKTtcbiAgfVxuICBmdW5jdGlvbiBjb250aW51ZVF1YXNpKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikge1xuICAgICAgY3gubWFya2VkID0gXCJzdHJpbmctMlwiO1xuICAgICAgY3guc3RhdGUudG9rZW5pemUgPSB0b2tlblF1YXNpO1xuICAgICAgcmV0dXJuIGNvbnQocXVhc2kpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcnJvd0JvZHkodHlwZSkge1xuICAgIGZpbmRGYXRBcnJvdyhjeC5zdHJlYW0sIGN4LnN0YXRlKTtcbiAgICByZXR1cm4gcGFzcyh0eXBlID09IFwie1wiID8gc3RhdGVtZW50IDogZXhwcmVzc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gYXJyb3dCb2R5Tm9Db21tYSh0eXBlKSB7XG4gICAgZmluZEZhdEFycm93KGN4LnN0cmVhbSwgY3guc3RhdGUpO1xuICAgIHJldHVybiBwYXNzKHR5cGUgPT0gXCJ7XCIgPyBzdGF0ZW1lbnQgOiBleHByZXNzaW9uTm9Db21tYSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVUYXJnZXQobm9Db21tYSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIi5cIikgcmV0dXJuIGNvbnQobm9Db21tYSA/IHRhcmdldE5vQ29tbWEgOiB0YXJnZXQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgaXNUUykgcmV0dXJuIGNvbnQobWF5YmVUeXBlQXJncywgbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hKVxuICAgICAgZWxzZSByZXR1cm4gcGFzcyhub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHRhcmdldChfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcInRhcmdldFwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChtYXliZW9wZXJhdG9yQ29tbWEpOyB9XG4gIH1cbiAgZnVuY3Rpb24gdGFyZ2V0Tm9Db21tYShfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcInRhcmdldFwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChtYXliZW9wZXJhdG9yTm9Db21tYSk7IH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZWxhYmVsKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQocG9wbGV4LCBzdGF0ZW1lbnQpO1xuICAgIHJldHVybiBwYXNzKG1heWJlb3BlcmF0b3JDb21tYSwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wZXJ0eSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7Y3gubWFya2VkID0gXCJwcm9wZXJ0eVwiOyByZXR1cm4gY29udCgpO31cbiAgfVxuICBmdW5jdGlvbiBvYmpwcm9wKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICBpZiAodmFsdWUgPT0gXCJnZXRcIiB8fCB2YWx1ZSA9PSBcInNldFwiKSByZXR1cm4gY29udChnZXR0ZXJTZXR0ZXIpO1xuICAgICAgdmFyIG0gLy8gV29yayBhcm91bmQgZmF0LWFycm93LWRldGVjdGlvbiBjb21wbGljYXRpb24gZm9yIGRldGVjdGluZyB0eXBlc2NyaXB0IHR5cGVkIGFycm93IHBhcmFtc1xuICAgICAgaWYgKGlzVFMgJiYgY3guc3RhdGUuZmF0QXJyb3dBdCA9PSBjeC5zdHJlYW0uc3RhcnQgJiYgKG0gPSBjeC5zdHJlYW0ubWF0Y2goL15cXHMqOlxccyovLCBmYWxzZSkpKVxuICAgICAgICBjeC5zdGF0ZS5mYXRBcnJvd0F0ID0gY3guc3RyZWFtLnBvcyArIG1bMF0ubGVuZ3RoXG4gICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY3gubWFya2VkID0ganNvbmxkTW9kZSA/IFwicHJvcGVydHlcIiA6IChjeC5zdHlsZSArIFwiIHByb3BlcnR5XCIpO1xuICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJqc29ubGQta2V5d29yZFwiKSB7XG4gICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAoaXNUUyAmJiBpc01vZGlmaWVyKHZhbHVlKSkge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KG9ianByb3ApXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiW1wiKSB7XG4gICAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBtYXliZXR5cGUsIGV4cGVjdChcIl1cIiksIGFmdGVycHJvcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHtcbiAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb25Ob0NvbW1hLCBhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgcmV0dXJuIGNvbnQob2JqcHJvcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiOlwiKSB7XG4gICAgICByZXR1cm4gcGFzcyhhZnRlcnByb3ApXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldHRlclNldHRlcih0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gcGFzcyhhZnRlcnByb3ApO1xuICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJwcm9wKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcGFzcyhmdW5jdGlvbmRlZik7XG4gIH1cbiAgZnVuY3Rpb24gY29tbWFzZXAod2hhdCwgZW5kLCBzZXApIHtcbiAgICBmdW5jdGlvbiBwcm9jZWVkKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAoc2VwID8gc2VwLmluZGV4T2YodHlwZSkgPiAtMSA6IHR5cGUgPT0gXCIsXCIpIHtcbiAgICAgICAgdmFyIGxleCA9IGN4LnN0YXRlLmxleGljYWw7XG4gICAgICAgIGlmIChsZXguaW5mbyA9PSBcImNhbGxcIikgbGV4LnBvcyA9IChsZXgucG9zIHx8IDApICsgMTtcbiAgICAgICAgcmV0dXJuIGNvbnQoZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKSByZXR1cm4gcGFzcygpXG4gICAgICAgICAgcmV0dXJuIHBhc3Mod2hhdClcbiAgICAgICAgfSwgcHJvY2VlZCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgaWYgKHNlcCAmJiBzZXAuaW5kZXhPZihcIjtcIikgPiAtMSkgcmV0dXJuIHBhc3Mod2hhdClcbiAgICAgIHJldHVybiBjb250KGV4cGVjdChlbmQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZSA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIHBhc3Mod2hhdCwgcHJvY2VlZCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb250Q29tbWFzZXAod2hhdCwgZW5kLCBpbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgcmV0dXJuIGNvbnQocHVzaGxleChlbmQsIGluZm8pLCBjb21tYXNlcCh3aGF0LCBlbmQpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGJsb2NrKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZXR5cGUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNUUykge1xuICAgICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgIGlmICh2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQobWF5YmV0eXBlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmV0eXBlT3JJbih0eXBlLCB2YWx1ZSkge1xuICAgIGlmIChpc1RTICYmICh0eXBlID09IFwiOlwiIHx8IHZhbHVlID09IFwiaW5cIikpIHJldHVybiBjb250KHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlcmV0dHlwZSh0eXBlKSB7XG4gICAgaWYgKGlzVFMgJiYgdHlwZSA9PSBcIjpcIikge1xuICAgICAgaWYgKGN4LnN0cmVhbS5tYXRjaCgvXlxccypcXHcrXFxzK2lzXFxiLywgZmFsc2UpKSByZXR1cm4gY29udChleHByZXNzaW9uLCBpc0tXLCB0eXBlZXhwcilcbiAgICAgIGVsc2UgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzS1coXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJpc1wiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIlxuICAgICAgcmV0dXJuIGNvbnQoKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0eXBlZXhwcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImtleW9mXCIgfHwgdmFsdWUgPT0gXCJ0eXBlb2ZcIiB8fCB2YWx1ZSA9PSBcImluZmVyXCIgfHwgdmFsdWUgPT0gXCJyZWFkb25seVwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIlxuICAgICAgcmV0dXJuIGNvbnQodmFsdWUgPT0gXCJ0eXBlb2ZcIiA/IGV4cHJlc3Npb25Ob0NvbW1hIDogdHlwZWV4cHIpXG4gICAgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiB8fCB2YWx1ZSA9PSBcInZvaWRcIikge1xuICAgICAgY3gubWFya2VkID0gXCJ0eXBlXCJcbiAgICAgIHJldHVybiBjb250KGFmdGVyVHlwZSlcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IFwifFwiIHx8IHZhbHVlID09IFwiJlwiKSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiIHx8IHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwiYXRvbVwiKSByZXR1cm4gY29udChhZnRlclR5cGUpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgY29tbWFzZXAodHlwZWV4cHIsIFwiXVwiLCBcIixcIiksIHBvcGxleCwgYWZ0ZXJUeXBlKVxuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgdHlwZXByb3BzLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQoY29tbWFzZXAodHlwZWFyZywgXCIpXCIpLCBtYXliZVJldHVyblR5cGUsIGFmdGVyVHlwZSlcbiAgICBpZiAodHlwZSA9PSBcIjxcIikgcmV0dXJuIGNvbnQoY29tbWFzZXAodHlwZWV4cHIsIFwiPlwiKSwgdHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJxdWFzaVwiKSB7IHJldHVybiBwYXNzKHF1YXNpVHlwZSwgYWZ0ZXJUeXBlKTsgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlUmV0dXJuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI9PlwiKSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiB0eXBlcHJvcHModHlwZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9bXFx9XFwpXFxdXS8pKSByZXR1cm4gY29udCgpXG4gICAgaWYgKHR5cGUgPT0gXCIsXCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQodHlwZXByb3BzKVxuICAgIHJldHVybiBwYXNzKHR5cGVwcm9wLCB0eXBlcHJvcHMpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZXByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIlxuICAgICAgcmV0dXJuIGNvbnQodHlwZXByb3ApXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIj9cIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gY29udCh0eXBlcHJvcClcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwidmFyaWFibGVcIiksIG1heWJldHlwZU9ySW4sIGV4cGVjdChcIl1cIiksIHR5cGVwcm9wKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIihcIikge1xuICAgICAgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWNsLCB0eXBlcHJvcClcbiAgICB9IGVsc2UgaWYgKCF0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHtcbiAgICAgIHJldHVybiBjb250KClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcXVhc2lUeXBlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCJxdWFzaVwiKSByZXR1cm4gcGFzcygpO1xuICAgIGlmICh2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSAyKSAhPSBcIiR7XCIpIHJldHVybiBjb250KHF1YXNpVHlwZSk7XG4gICAgcmV0dXJuIGNvbnQodHlwZWV4cHIsIGNvbnRpbnVlUXVhc2lUeXBlKTtcbiAgfVxuICBmdW5jdGlvbiBjb250aW51ZVF1YXNpVHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwic3RyaW5nLTJcIjtcbiAgICAgIGN4LnN0YXRlLnRva2VuaXplID0gdG9rZW5RdWFzaTtcbiAgICAgIHJldHVybiBjb250KHF1YXNpVHlwZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHR5cGVhcmcodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgY3guc3RyZWFtLm1hdGNoKC9eXFxzKls/Ol0vLCBmYWxzZSkgfHwgdmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KHR5cGVhcmcpXG4gICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KHR5cGVhcmcpXG4gICAgcmV0dXJuIHBhc3ModHlwZWV4cHIpXG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJUeXBlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiPFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZWV4cHIsIFwiPlwiKSwgcG9wbGV4LCBhZnRlclR5cGUpXG4gICAgaWYgKHZhbHVlID09IFwifFwiIHx8IHR5cGUgPT0gXCIuXCIgfHwgdmFsdWUgPT0gXCImXCIpIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udCh0eXBlZXhwciwgZXhwZWN0KFwiXVwiKSwgYWZ0ZXJUeXBlKVxuICAgIGlmICh2YWx1ZSA9PSBcImV4dGVuZHNcIiB8fCB2YWx1ZSA9PSBcImltcGxlbWVudHNcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQodHlwZWV4cHIpIH1cbiAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCI6XCIpLCB0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiBtYXliZVR5cGVBcmdzKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiPFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZWV4cHIsIFwiPlwiKSwgcG9wbGV4LCBhZnRlclR5cGUpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZXBhcmFtKCkge1xuICAgIHJldHVybiBwYXNzKHR5cGVleHByLCBtYXliZVR5cGVEZWZhdWx0KVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlVHlwZURlZmF1bHQoXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI9XCIpIHJldHVybiBjb250KHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIHZhcmRlZihfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImVudW1cIikge2N4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChlbnVtZGVmKX1cbiAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZXR5cGUsIG1heWJlQXNzaWduLCB2YXJkZWZDb250KTtcbiAgfVxuICBmdW5jdGlvbiBwYXR0ZXJuKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KHBhdHRlcm4pIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHsgcmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250Q29tbWFzZXAoZWx0cGF0dGVybiwgXCJdXCIpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udENvbW1hc2VwKHByb3BwYXR0ZXJuLCBcIn1cIik7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgIWN4LnN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKSB7XG4gICAgICByZWdpc3Rlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gY29udChtYXliZUFzc2lnbik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KHBhdHRlcm4pO1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gcGFzcygpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoJ10nKSwgZXhwZWN0KCc6JyksIHByb3BwYXR0ZXJuKTtcbiAgICByZXR1cm4gY29udChleHBlY3QoXCI6XCIpLCBwYXR0ZXJuLCBtYXliZUFzc2lnbik7XG4gIH1cbiAgZnVuY3Rpb24gZWx0cGF0dGVybigpIHtcbiAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZUFzc2lnbilcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFzc2lnbihfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI9XCIpIHJldHVybiBjb250KGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgfVxuICBmdW5jdGlvbiB2YXJkZWZDb250KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQodmFyZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZWVsc2UodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiICYmIHZhbHVlID09IFwiZWxzZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiLCBcImVsc2VcIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiYXdhaXRcIikgcmV0dXJuIGNvbnQoZm9yc3BlYyk7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBmb3JzcGVjMSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjMSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQodmFyZGVmLCBmb3JzcGVjMik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChmb3JzcGVjMik7XG4gICAgcmV0dXJuIHBhc3MoZm9yc3BlYzIpXG4gIH1cbiAgZnVuY3Rpb24gZm9yc3BlYzIodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIilcIikgcmV0dXJuIGNvbnQoKVxuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udChmb3JzcGVjMilcbiAgICBpZiAodmFsdWUgPT0gXCJpblwiIHx8IHZhbHVlID09IFwib2ZcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZm9yc3BlYzIpIH1cbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uLCBmb3JzcGVjMilcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbmRlZih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikge2N4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO31cbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCBtYXliZXJldHR5cGUsIHN0YXRlbWVudCwgcG9wY29udGV4dCk7XG4gICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4LCBmdW5jdGlvbmRlZilcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbmRlY2wodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWNsKTt9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlY2wpO31cbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCBtYXliZXJldHR5cGUsIHBvcGNvbnRleHQpO1xuICAgIGlmIChpc1RTICYmIHZhbHVlID09IFwiPFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleCwgZnVuY3Rpb25kZWNsKVxuICB9XG4gIGZ1bmN0aW9uIHR5cGVuYW1lKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkXCIgfHwgdHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwidHlwZVwiXG4gICAgICByZXR1cm4gY29udCh0eXBlbmFtZSlcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwiPFwiKSB7XG4gICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZnVuYXJnKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiQFwiKSBjb250KGV4cHJlc3Npb24sIGZ1bmFyZylcbiAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChmdW5hcmcpO1xuICAgIGlmIChpc1RTICYmIGlzTW9kaWZpZXIodmFsdWUpKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChmdW5hcmcpOyB9XG4gICAgaWYgKGlzVFMgJiYgdHlwZSA9PSBcInRoaXNcIikgcmV0dXJuIGNvbnQobWF5YmV0eXBlLCBtYXliZUFzc2lnbilcbiAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZXR5cGUsIG1heWJlQXNzaWduKTtcbiAgfVxuICBmdW5jdGlvbiBjbGFzc0V4cHJlc3Npb24odHlwZSwgdmFsdWUpIHtcbiAgICAvLyBDbGFzcyBleHByZXNzaW9ucyBtYXkgaGF2ZSBhbiBvcHRpb25hbCBuYW1lLlxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNsYXNzTmFtZSh0eXBlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNsYXNzTmFtZUFmdGVyKHR5cGUsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBjbGFzc05hbWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGNsYXNzTmFtZUFmdGVyKTt9XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NOYW1lQWZ0ZXIodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4LCBjbGFzc05hbWVBZnRlcilcbiAgICBpZiAodmFsdWUgPT0gXCJleHRlbmRzXCIgfHwgdmFsdWUgPT0gXCJpbXBsZW1lbnRzXCIgfHwgKGlzVFMgJiYgdHlwZSA9PSBcIixcIikpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBcImltcGxlbWVudHNcIikgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gY29udChpc1RTID8gdHlwZWV4cHIgOiBleHByZXNzaW9uLCBjbGFzc05hbWVBZnRlcik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY2xhc3NCb2R5LCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzQm9keSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwiYXN5bmNcIiB8fFxuICAgICAgICAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiZcbiAgICAgICAgICh2YWx1ZSA9PSBcInN0YXRpY1wiIHx8IHZhbHVlID09IFwiZ2V0XCIgfHwgdmFsdWUgPT0gXCJzZXRcIiB8fCAoaXNUUyAmJiBpc01vZGlmaWVyKHZhbHVlKSkpICYmXG4gICAgICAgICBjeC5zdHJlYW0ubWF0Y2goL15cXHMrW1xcdyRcXHhhMS1cXHVmZmZmXS8sIGZhbHNlKSkpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgcmV0dXJuIGNvbnQoY2xhc3NCb2R5KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICByZXR1cm4gY29udChjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoY2xhc3NmaWVsZCwgY2xhc3NCb2R5KTtcbiAgICBpZiAodHlwZSA9PSBcIltcIilcbiAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIG1heWJldHlwZSwgZXhwZWN0KFwiXVwiKSwgY2xhc3NmaWVsZCwgY2xhc3NCb2R5KVxuICAgIGlmICh2YWx1ZSA9PSBcIipcIikge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgIH1cbiAgICBpZiAoaXNUUyAmJiB0eXBlID09IFwiKFwiKSByZXR1cm4gcGFzcyhmdW5jdGlvbmRlY2wsIGNsYXNzQm9keSlcbiAgICBpZiAodHlwZSA9PSBcIjtcIiB8fCB0eXBlID09IFwiLFwiKSByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICAgIGlmICh2YWx1ZSA9PSBcIkBcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY2xhc3NCb2R5KVxuICB9XG4gIGZ1bmN0aW9uIGNsYXNzZmllbGQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIhXCIpIHJldHVybiBjb250KGNsYXNzZmllbGQpXG4gICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChjbGFzc2ZpZWxkKVxuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udCh0eXBlZXhwciwgbWF5YmVBc3NpZ24pXG4gICAgaWYgKHZhbHVlID09IFwiPVwiKSByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSlcbiAgICB2YXIgY29udGV4dCA9IGN4LnN0YXRlLmxleGljYWwucHJldiwgaXNJbnRlcmZhY2UgPSBjb250ZXh0ICYmIGNvbnRleHQuaW5mbyA9PSBcImludGVyZmFjZVwiXG4gICAgcmV0dXJuIHBhc3MoaXNJbnRlcmZhY2UgPyBmdW5jdGlvbmRlY2wgOiBmdW5jdGlvbmRlZilcbiAgfVxuICBmdW5jdGlvbiBhZnRlckV4cG9ydCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQobWF5YmVGcm9tLCBleHBlY3QoXCI7XCIpKTsgfVxuICAgIGlmICh2YWx1ZSA9PSBcImRlZmF1bHRcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSk7IH1cbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQoY29tbWFzZXAoZXhwb3J0RmllbGQsIFwifVwiKSwgbWF5YmVGcm9tLCBleHBlY3QoXCI7XCIpKTtcbiAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGV4cG9ydEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiYXNcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwZWN0KFwidmFyaWFibGVcIikpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gcGFzcyhleHByZXNzaW9uTm9Db21tYSwgZXhwb3J0RmllbGQpO1xuICB9XG4gIGZ1bmN0aW9uIGFmdGVySW1wb3J0KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udCgpO1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcGFzcyhleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIi5cIikgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvckNvbW1hKTtcbiAgICByZXR1cm4gcGFzcyhpbXBvcnRTcGVjLCBtYXliZU1vcmVJbXBvcnRzLCBtYXliZUZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFNwZWModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChpbXBvcnRTcGVjLCBcIn1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZWdpc3Rlcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICByZXR1cm4gY29udChtYXliZUFzKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZU1vcmVJbXBvcnRzKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQoaW1wb3J0U3BlYywgbWF5YmVNb3JlSW1wb3J0cylcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFzKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImFzXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGltcG9ydFNwZWMpOyB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVGcm9tKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImZyb21cIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7IH1cbiAgfVxuICBmdW5jdGlvbiBhcnJheUxpdGVyYWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiXVwiKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBwYXNzKGNvbW1hc2VwKGV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICB9XG4gIGZ1bmN0aW9uIGVudW1kZWYoKSB7XG4gICAgcmV0dXJuIHBhc3MocHVzaGxleChcImZvcm1cIiksIHBhdHRlcm4sIGV4cGVjdChcIntcIiksIHB1c2hsZXgoXCJ9XCIpLCBjb21tYXNlcChlbnVtbWVtYmVyLCBcIn1cIiksIHBvcGxleCwgcG9wbGV4KVxuICB9XG4gIGZ1bmN0aW9uIGVudW1tZW1iZXIoKSB7XG4gICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmVBc3NpZ24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikge1xuICAgIHJldHVybiBzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCIsXCIgfHxcbiAgICAgIGlzT3BlcmF0b3JDaGFyLnRlc3QodGV4dEFmdGVyLmNoYXJBdCgwKSkgfHxcbiAgICAgIC9bLC5dLy50ZXN0KHRleHRBZnRlci5jaGFyQXQoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbkFsbG93ZWQoc3RyZWFtLCBzdGF0ZSwgYmFja1VwKSB7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplID09IHRva2VuQmFzZSAmJlxuICAgICAgL14oPzpvcGVyYXRvcnxzb2Z8a2V5d29yZCBbYmNkXXxjYXNlfG5ld3xleHBvcnR8ZGVmYXVsdHxzcHJlYWR8W1xcW3t9XFwoLDs6XXw9PikkLy50ZXN0KHN0YXRlLmxhc3RUeXBlKSB8fFxuICAgICAgKHN0YXRlLmxhc3RUeXBlID09IFwicXVhc2lcIiAmJiAvXFx7XFxzKiQvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0ucG9zIC0gKGJhY2tVcCB8fCAwKSkpKVxuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgIGxhc3RUeXBlOiBcInNvZlwiLFxuICAgICAgICBjYzogW10sXG4gICAgICAgIGxleGljYWw6IG5ldyBKU0xleGljYWwoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcImJsb2NrXCIsIGZhbHNlKSxcbiAgICAgICAgbG9jYWxWYXJzOiBwYXJzZXJDb25maWcubG9jYWxWYXJzLFxuICAgICAgICBjb250ZXh0OiBwYXJzZXJDb25maWcubG9jYWxWYXJzICYmIG5ldyBDb250ZXh0KG51bGwsIG51bGwsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IGJhc2Vjb2x1bW4gfHwgMFxuICAgICAgfTtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZ2xvYmFsVmFycyAmJiB0eXBlb2YgcGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkNvbW1lbnQgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgc3RhdGUubGFzdFR5cGUgPSB0eXBlID09IFwib3BlcmF0b3JcIiAmJiAoY29udGVudCA9PSBcIisrXCIgfHwgY29udGVudCA9PSBcIi0tXCIpID8gXCJpbmNkZWNcIiA6IHR5cGU7XG4gICAgICByZXR1cm4gcGFyc2VKUyhzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplID09IHRva2VuQ29tbWVudCB8fCBzdGF0ZS50b2tlbml6ZSA9PSB0b2tlblF1YXNpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSkgcmV0dXJuIDA7XG4gICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGxleGljYWwgPSBzdGF0ZS5sZXhpY2FsLCB0b3BcbiAgICAgIC8vIEtsdWRnZSB0byBwcmV2ZW50ICdtYXliZWxzZScgZnJvbSBibG9ja2luZyBsZXhpY2FsIHNjb3BlIHBvcHNcbiAgICAgIGlmICghL15cXHMqZWxzZVxcYi8udGVzdCh0ZXh0QWZ0ZXIpKSBmb3IgKHZhciBpID0gc3RhdGUuY2MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGMgPSBzdGF0ZS5jY1tpXTtcbiAgICAgICAgaWYgKGMgPT0gcG9wbGV4KSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICBlbHNlIGlmIChjICE9IG1heWJlZWxzZSAmJiBjICE9IHBvcGNvbnRleHQpIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgfHwgbGV4aWNhbC50eXBlID09IFwiZm9ybVwiKSAmJlxuICAgICAgICAgICAgIChmaXJzdENoYXIgPT0gXCJ9XCIgfHwgKCh0b3AgPSBzdGF0ZS5jY1tzdGF0ZS5jYy5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvcCA9PSBtYXliZW9wZXJhdG9yQ29tbWEgfHwgdG9wID09IG1heWJlb3BlcmF0b3JOb0NvbW1hKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL15bLFxcLj0rXFwtKjo/W1xcKF0vLnRlc3QodGV4dEFmdGVyKSkpKVxuICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgaWYgKHN0YXRlbWVudEluZGVudCAmJiBsZXhpY2FsLnR5cGUgPT0gXCIpXCIgJiYgbGV4aWNhbC5wcmV2LnR5cGUgPT0gXCJzdGF0XCIpXG4gICAgICAgIGxleGljYWwgPSBsZXhpY2FsLnByZXY7XG4gICAgICB2YXIgdHlwZSA9IGxleGljYWwudHlwZSwgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSB0eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PSBcInZhcmRlZlwiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCIsXCIgPyBsZXhpY2FsLmluZm8ubGVuZ3RoICsgMSA6IDApO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIiAmJiBmaXJzdENoYXIgPT0gXCJ7XCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInN0YXRcIilcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikgPyBzdGF0ZW1lbnRJbmRlbnQgfHwgaW5kZW50VW5pdCA6IDApO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5pbmZvID09IFwic3dpdGNoXCIgJiYgIWNsb3NpbmcgJiYgcGFyc2VyQ29uZmlnLmRvdWJsZUluZGVudFN3aXRjaCAhPSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikgPyBpbmRlbnRVbml0IDogMiAqIGluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5hbGlnbikgcmV0dXJuIGxleGljYWwuY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHt8XFx9KSQvLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBqc29uTW9kZSA/IG51bGwgOiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBqc29uTW9kZSA/IG51bGwgOiBcIiovXCIsXG4gICAgYmxvY2tDb21tZW50Q29udGludWU6IGpzb25Nb2RlID8gbnVsbCA6IFwiICogXCIsXG4gICAgbGluZUNvbW1lbnQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiLy9cIixcbiAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgY2xvc2VCcmFja2V0czogXCIoKVtde30nJ1xcXCJcXFwiYGBcIixcblxuICAgIGhlbHBlclR5cGU6IGpzb25Nb2RlID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIixcbiAgICBqc29ubGRNb2RlOiBqc29ubGRNb2RlLFxuICAgIGpzb25Nb2RlOiBqc29uTW9kZSxcblxuICAgIGV4cHJlc3Npb25BbGxvd2VkOiBleHByZXNzaW9uQWxsb3dlZCxcblxuICAgIHNraXBFeHByZXNzaW9uOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcGFyc2VKUyhzdGF0ZSwgXCJhdG9tXCIsIFwiYXRvbVwiLCBcInRydWVcIiwgbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKFwiXCIsIDIsIG51bGwpKVxuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwid29yZENoYXJzXCIsIFwiamF2YXNjcmlwdFwiLCAvW1xcdyRdLyk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2VjbWFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9qc29uXCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb246IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWpzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZSB9KTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL21hbmlmZXN0K2pzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZSB9KVxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbGQranNvblwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29ubGQ6IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3R5cGVzY3JpcHRcIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwgdHlwZXNjcmlwdDogdHJ1ZSB9KTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3R5cGVzY3JpcHRcIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwgdHlwZXNjcmlwdDogdHJ1ZSB9KTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZClcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIlxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3NcblxuICBmdW5jdGlvbiByZWdleHBGbGFncyhyZWdleHApIHtcbiAgICB2YXIgZmxhZ3MgPSByZWdleHAuZmxhZ3NcbiAgICByZXR1cm4gZmxhZ3MgIT0gbnVsbCA/IGZsYWdzIDogKHJlZ2V4cC5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKVxuICAgICAgKyAocmVnZXhwLmdsb2JhbCA/IFwiZ1wiIDogXCJcIilcbiAgICAgICsgKHJlZ2V4cC5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpXG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVGbGFncyhyZWdleHAsIGZsYWdzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWdleHBGbGFncyhyZWdleHApLCB0YXJnZXQgPSBjdXJyZW50XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykgaWYgKHRhcmdldC5pbmRleE9mKGZsYWdzLmNoYXJBdChpKSkgPT0gLTEpXG4gICAgICB0YXJnZXQgKz0gZmxhZ3MuY2hhckF0KGkpXG4gICAgcmV0dXJuIGN1cnJlbnQgPT0gdGFyZ2V0ID8gcmVnZXhwIDogbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB0YXJnZXQpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZU11bHRpbGluZShyZWdleHApIHtcbiAgICByZXR1cm4gL1xcXFxzfFxcXFxufFxcbnxcXFxcV3xcXFxcRHxcXFtcXF4vLnRlc3QocmVnZXhwLnNvdXJjZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEZvcndhcmQoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdcIilcbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7IGxpbmUrKywgY2ggPSAwKSB7XG4gICAgICByZWdleHAubGFzdEluZGV4ID0gY2hcbiAgICAgIHZhciBzdHJpbmcgPSBkb2MuZ2V0TGluZShsaW5lKSwgbWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpXG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2h9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZShkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpIHJldHVybiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydClcblxuICAgIHJlZ2V4cCA9IGVuc3VyZUZsYWdzKHJlZ2V4cCwgXCJnbVwiKVxuICAgIHZhciBzdHJpbmcsIGNodW5rID0gMVxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7IGxpbmUgPD0gbGFzdDspIHtcbiAgICAgIC8vIFRoaXMgZ3Jvd3MgdGhlIHNlYXJjaCBidWZmZXIgaW4gZXhwb25lbnRpYWxseS1zaXplZCBjaHVua3NcbiAgICAgIC8vIGJldHdlZW4gbWF0Y2hlcywgc28gdGhhdCBuZWFyYnkgbWF0Y2hlcyBhcmUgZmFzdCBhbmQgZG9uJ3RcbiAgICAgIC8vIHJlcXVpcmUgY29uY2F0ZW5hdGluZyB0aGUgd2hvbGUgZG9jdW1lbnQgKGluIGNhc2Ugd2UncmVcbiAgICAgIC8vIHNlYXJjaGluZyBmb3Igc29tZXRoaW5nIHRoYXQgaGFzIHRvbnMgb2YgbWF0Y2hlcyksIGJ1dCBhdCB0aGVcbiAgICAgIC8vIHNhbWUgdGltZSwgdGhlIGFtb3VudCBvZiByZXRyaWVzIGlzIGxpbWl0ZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmUgPiBsYXN0KSBicmVha1xuICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUrKylcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogc3RyaW5nICsgXCJcXG5cIiArIGN1ckxpbmVcbiAgICAgIH1cbiAgICAgIGNodW5rID0gY2h1bmsgKiAyXG4gICAgICByZWdleHAubGFzdEluZGV4ID0gc3RhcnQuY2hcbiAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cmluZylcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gc3RyaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KS5zcGxpdChcIlxcblwiKSwgaW5zaWRlID0gbWF0Y2hbMF0uc3BsaXQoXCJcXG5cIilcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmUgKyBiZWZvcmUubGVuZ3RoIC0gMSwgc3RhcnRDaCA9IGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZS5sZW5ndGggPT0gMSA/IHN0YXJ0Q2ggKyBpbnNpZGVbMF0ubGVuZ3RoIDogaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgZW5kTWFyZ2luKSB7XG4gICAgdmFyIG1hdGNoLCBmcm9tID0gMFxuICAgIHdoaWxlIChmcm9tIDw9IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBmcm9tXG4gICAgICB2YXIgbmV3TWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpXG4gICAgICBpZiAoIW5ld01hdGNoKSBicmVha1xuICAgICAgdmFyIGVuZCA9IG5ld01hdGNoLmluZGV4ICsgbmV3TWF0Y2hbMF0ubGVuZ3RoXG4gICAgICBpZiAoZW5kID4gc3RyaW5nLmxlbmd0aCAtIGVuZE1hcmdpbikgYnJlYWtcbiAgICAgIGlmICghbWF0Y2ggfHwgZW5kID4gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpXG4gICAgICAgIG1hdGNoID0gbmV3TWF0Y2hcbiAgICAgIGZyb20gPSBuZXdNYXRjaC5pbmRleCArIDFcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoXG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ1wiKVxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBjaCA9IHN0YXJ0LmNoLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKTsgbGluZSA+PSBmaXJzdDsgbGluZS0tLCBjaCA9IC0xKSB7XG4gICAgICB2YXIgc3RyaW5nID0gZG9jLmdldExpbmUobGluZSlcbiAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBjaCA8IDAgPyAwIDogc3RyaW5nLmxlbmd0aCAtIGNoKVxuICAgICAgaWYgKG1hdGNoKVxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNofVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lKGRvYywgcmVnZXhwLCBzdGFydCkge1xuICAgIGlmICghbWF5YmVNdWx0aWxpbmUocmVnZXhwKSkgcmV0dXJuIHNlYXJjaFJlZ2V4cEJhY2t3YXJkKGRvYywgcmVnZXhwLCBzdGFydClcbiAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ21cIilcbiAgICB2YXIgc3RyaW5nLCBjaHVua1NpemUgPSAxLCBlbmRNYXJnaW4gPSBkb2MuZ2V0TGluZShzdGFydC5saW5lKS5sZW5ndGggLSBzdGFydC5jaFxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKTsgbGluZSA+PSBmaXJzdDspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtTaXplICYmIGxpbmUgPj0gZmlyc3Q7IGkrKykge1xuICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUtLSlcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogY3VyTGluZSArIFwiXFxuXCIgKyBzdHJpbmdcbiAgICAgIH1cbiAgICAgIGNodW5rU2l6ZSAqPSAyXG5cbiAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIiksIGluc2lkZSA9IG1hdGNoWzBdLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgIHZhciBzdGFydExpbmUgPSBsaW5lICsgYmVmb3JlLmxlbmd0aCwgc3RhcnRDaCA9IGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZS5sZW5ndGggPT0gMSA/IHN0YXJ0Q2ggKyBpbnNpZGVbMF0ubGVuZ3RoIDogaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZG9Gb2xkLCBub0ZvbGRcbiAgaWYgKFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplKSB7XG4gICAgZG9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpLnRvTG93ZXJDYXNlKCkgfVxuICAgIG5vRm9sZCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKSB9XG4gIH0gZWxzZSB7XG4gICAgZG9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIudG9Mb3dlckNhc2UoKSB9XG4gICAgbm9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIgfVxuICB9XG5cbiAgLy8gTWFwcyBhIHBvc2l0aW9uIGluIGEgY2FzZS1mb2xkZWQgbGluZSBiYWNrIHRvIGEgcG9zaXRpb24gaW4gdGhlIG9yaWdpbmFsIGxpbmVcbiAgLy8gKGNvbXBlbnNhdGluZyBmb3IgY29kZXBvaW50cyBpbmNyZWFzaW5nIGluIG51bWJlciBkdXJpbmcgZm9sZGluZylcbiAgZnVuY3Rpb24gYWRqdXN0UG9zKG9yaWcsIGZvbGRlZCwgcG9zLCBmb2xkRnVuYykge1xuICAgIGlmIChvcmlnLmxlbmd0aCA9PSBmb2xkZWQubGVuZ3RoKSByZXR1cm4gcG9zXG4gICAgZm9yICh2YXIgbWluID0gMCwgbWF4ID0gcG9zICsgTWF0aC5tYXgoMCwgb3JpZy5sZW5ndGggLSBmb2xkZWQubGVuZ3RoKTs7KSB7XG4gICAgICBpZiAobWluID09IG1heCkgcmV0dXJuIG1pblxuICAgICAgdmFyIG1pZCA9IChtaW4gKyBtYXgpID4+IDFcbiAgICAgIHZhciBsZW4gPSBmb2xkRnVuYyhvcmlnLnNsaWNlKDAsIG1pZCkpLmxlbmd0aFxuICAgICAgaWYgKGxlbiA9PSBwb3MpIHJldHVybiBtaWRcbiAgICAgIGVsc2UgaWYgKGxlbiA+IHBvcykgbWF4ID0gbWlkXG4gICAgICBlbHNlIG1pbiA9IG1pZCArIDFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hTdHJpbmdGb3J3YXJkKGRvYywgcXVlcnksIHN0YXJ0LCBjYXNlRm9sZCkge1xuICAgIC8vIEVtcHR5IHN0cmluZyB3b3VsZCBtYXRjaCBhbnl0aGluZyBhbmQgbmV2ZXIgcHJvZ3Jlc3MsIHNvIHdlXG4gICAgLy8gZGVmaW5lIGl0IHRvIG1hdGNoIG5vdGhpbmcgaW5zdGVhZC5cbiAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICB2YXIgZm9sZCA9IGNhc2VGb2xkID8gZG9Gb2xkIDogbm9Gb2xkXG4gICAgdmFyIGxpbmVzID0gZm9sZChxdWVyeSkuc3BsaXQoL1xccnxcXG5cXHI/LylcblxuICAgIHNlYXJjaDogZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGxhc3QgPSBkb2MubGFzdExpbmUoKSArIDEgLSBsaW5lcy5sZW5ndGg7IGxpbmUgPD0gbGFzdDsgbGluZSsrLCBjaCA9IDApIHtcbiAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSkuc2xpY2UoY2gpLCBzdHJpbmcgPSBmb2xkKG9yaWcpXG4gICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gc3RyaW5nLmluZGV4T2YobGluZXNbMF0pXG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhciBzdGFydCA9IGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kLCBmb2xkKSArIGNoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kLCBmb2xkKSArIGNoKSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kICsgbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSArIGNoKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXRGcm9tID0gc3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aFxuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGN1dEZyb20pICE9IGxpbmVzWzBdKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgaWYgKGZvbGQoZG9jLmdldExpbmUobGluZSArIGkpKSAhPSBsaW5lc1tpXSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhciBlbmQgPSBkb2MuZ2V0TGluZShsaW5lICsgbGluZXMubGVuZ3RoIC0gMSksIGVuZFN0cmluZyA9IGZvbGQoZW5kKSwgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXVxuICAgICAgICBpZiAoZW5kU3RyaW5nLnNsaWNlKDAsIGxhc3RMaW5lLmxlbmd0aCkgIT0gbGFzdExpbmUpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBjdXRGcm9tLCBmb2xkKSArIGNoKSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUgKyBsaW5lcy5sZW5ndGggLSAxLCBhZGp1c3RQb3MoZW5kLCBlbmRTdHJpbmcsIGxhc3RMaW5lLmxlbmd0aCwgZm9sZCkpfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFN0cmluZ0JhY2t3YXJkKGRvYywgcXVlcnksIHN0YXJ0LCBjYXNlRm9sZCkge1xuICAgIGlmICghcXVlcnkubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgIHZhciBmb2xkID0gY2FzZUZvbGQgPyBkb0ZvbGQgOiBub0ZvbGRcbiAgICB2YXIgbGluZXMgPSBmb2xkKHF1ZXJ5KS5zcGxpdCgvXFxyfFxcblxccj8vKVxuXG4gICAgc2VhcmNoOiBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCkgLSAxICsgbGluZXMubGVuZ3RoOyBsaW5lID49IGZpcnN0OyBsaW5lLS0sIGNoID0gLTEpIHtcbiAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSlcbiAgICAgIGlmIChjaCA+IC0xKSBvcmlnID0gb3JpZy5zbGljZSgwLCBjaClcbiAgICAgIHZhciBzdHJpbmcgPSBmb2xkKG9yaWcpXG4gICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gc3RyaW5nLmxhc3RJbmRleE9mKGxpbmVzWzBdKVxuICAgICAgICBpZiAoZm91bmQgPT0gLTEpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCwgZm9sZCkpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQgKyBsaW5lc1swXS5sZW5ndGgsIGZvbGQpKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXN0TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdXG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoMCwgbGFzdExpbmUubGVuZ3RoKSAhPSBsYXN0TGluZSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBzdGFydCA9IGxpbmUgLSBsaW5lcy5sZW5ndGggKyAxOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKHN0YXJ0ICsgaSkpICE9IGxpbmVzW2ldKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgdmFyIHRvcCA9IGRvYy5nZXRMaW5lKGxpbmUgKyAxIC0gbGluZXMubGVuZ3RoKSwgdG9wU3RyaW5nID0gZm9sZCh0b3ApXG4gICAgICAgIGlmICh0b3BTdHJpbmcuc2xpY2UodG9wU3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCkgIT0gbGluZXNbMF0pIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCwgYWRqdXN0UG9zKHRvcCwgdG9wU3RyaW5nLCB0b3AubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBsYXN0TGluZS5sZW5ndGgsIGZvbGQpKX1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBTZWFyY2hDdXJzb3IoZG9jLCBxdWVyeSwgcG9zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hdE9jY3VycmVuY2UgPSBmYWxzZVxuICAgIHRoaXMuYWZ0ZXJFbXB0eU1hdGNoID0gZmFsc2VcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHBvcyA9IHBvcyA/IGRvYy5jbGlwUG9zKHBvcykgOiBQb3MoMCwgMClcbiAgICB0aGlzLnBvcyA9IHtmcm9tOiBwb3MsIHRvOiBwb3N9XG5cbiAgICB2YXIgY2FzZUZvbGRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIikge1xuICAgICAgY2FzZUZvbGQgPSBvcHRpb25zLmNhc2VGb2xkXG4gICAgfSBlbHNlIHsgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3Igd2hlbiBjYXNlRm9sZCB3YXMgdGhlIDR0aCBhcmd1bWVudFxuICAgICAgY2FzZUZvbGQgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGNhc2VGb2xkID09IG51bGwpIGNhc2VGb2xkID0gZmFsc2VcbiAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hTdHJpbmdCYWNrd2FyZCA6IHNlYXJjaFN0cmluZ0ZvcndhcmQpKGRvYywgcXVlcnksIHBvcywgY2FzZUZvbGQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gZW5zdXJlRmxhZ3MocXVlcnksIFwiZ21cIilcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLm11bHRpbGluZSAhPT0gZmFsc2UpXG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lIDogc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZSkoZG9jLCBxdWVyeSwgcG9zKVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFJlZ2V4cEJhY2t3YXJkIDogc2VhcmNoUmVnZXhwRm9yd2FyZCkoZG9jLCBxdWVyeSwgcG9zKVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZSA9IHtcbiAgICBmaW5kTmV4dDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmluZChmYWxzZSl9LFxuICAgIGZpbmRQcmV2aW91czogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmluZCh0cnVlKX0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbihyZXZlcnNlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuZG9jLmNsaXBQb3MocmV2ZXJzZSA/IHRoaXMucG9zLmZyb20gOiB0aGlzLnBvcy50byk7XG4gICAgICBpZiAodGhpcy5hZnRlckVtcHR5TWF0Y2ggJiYgdGhpcy5hdE9jY3VycmVuY2UpIHtcbiAgICAgICAgLy8gZG8gbm90IHJldHVybiB0aGUgc2FtZSAwIHdpZHRoIG1hdGNoIHR3aWNlXG4gICAgICAgIGhlYWQgPSBQb3MoaGVhZC5saW5lLCBoZWFkLmNoKVxuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgIGhlYWQuY2gtLTtcbiAgICAgICAgICBpZiAoaGVhZC5jaCA8IDApIHtcbiAgICAgICAgICAgIGhlYWQubGluZS0tO1xuICAgICAgICAgICAgaGVhZC5jaCA9ICh0aGlzLmRvYy5nZXRMaW5lKGhlYWQubGluZSkgfHwgXCJcIikubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkLmNoKys7XG4gICAgICAgICAgaWYgKGhlYWQuY2ggPiAodGhpcy5kb2MuZ2V0TGluZShoZWFkLmxpbmUpIHx8IFwiXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgaGVhZC5jaCA9IDA7XG4gICAgICAgICAgICBoZWFkLmxpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGhlYWQsIHRoaXMuZG9jLmNsaXBQb3MoaGVhZCkpICE9IDApIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWF0Y2hlcyhyZXZlcnNlLCBoZWFkKVxuICAgICAgdGhpcy5hZnRlckVtcHR5TWF0Y2ggPSByZXN1bHQgJiYgQ29kZU1pcnJvci5jbXBQb3MocmVzdWx0LmZyb20sIHJlc3VsdC50bykgPT0gMFxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcmVzdWx0XG4gICAgICAgIHRoaXMuYXRPY2N1cnJlbmNlID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MubWF0Y2ggfHwgdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVuZCA9IFBvcyhyZXZlcnNlID8gdGhpcy5kb2MuZmlyc3RMaW5lKCkgOiB0aGlzLmRvYy5sYXN0TGluZSgpICsgMSwgMClcbiAgICAgICAgdGhpcy5wb3MgPSB7ZnJvbTogZW5kLCB0bzogZW5kfVxuICAgICAgICByZXR1cm4gdGhpcy5hdE9jY3VycmVuY2UgPSBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmcm9tOiBmdW5jdGlvbigpIHtpZiAodGhpcy5hdE9jY3VycmVuY2UpIHJldHVybiB0aGlzLnBvcy5mcm9tfSxcbiAgICB0bzogZnVuY3Rpb24oKSB7aWYgKHRoaXMuYXRPY2N1cnJlbmNlKSByZXR1cm4gdGhpcy5wb3MudG99LFxuXG4gICAgcmVwbGFjZTogZnVuY3Rpb24obmV3VGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoIXRoaXMuYXRPY2N1cnJlbmNlKSByZXR1cm5cbiAgICAgIHZhciBsaW5lcyA9IENvZGVNaXJyb3Iuc3BsaXRMaW5lcyhuZXdUZXh0KVxuICAgICAgdGhpcy5kb2MucmVwbGFjZVJhbmdlKGxpbmVzLCB0aGlzLnBvcy5mcm9tLCB0aGlzLnBvcy50bywgb3JpZ2luKVxuICAgICAgdGhpcy5wb3MudG8gPSBQb3ModGhpcy5wb3MuZnJvbS5saW5lICsgbGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIChsaW5lcy5sZW5ndGggPT0gMSA/IHRoaXMucG9zLmZyb20uY2ggOiAwKSlcbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHRoaXMuZG9jLCBxdWVyeSwgcG9zLCBjYXNlRm9sZClcbiAgfSlcbiAgQ29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb24oXCJnZXRTZWFyY2hDdXJzb3JcIiwgZnVuY3Rpb24ocXVlcnksIHBvcywgY2FzZUZvbGQpIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcih0aGlzLCBxdWVyeSwgcG9zLCBjYXNlRm9sZClcbiAgfSlcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcInNlbGVjdE1hdGNoZXNcIiwgZnVuY3Rpb24ocXVlcnksIGNhc2VGb2xkKSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdXG4gICAgdmFyIGN1ciA9IHRoaXMuZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCB0aGlzLmdldEN1cnNvcihcImZyb21cIiksIGNhc2VGb2xkKVxuICAgIHdoaWxlIChjdXIuZmluZE5leHQoKSkge1xuICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGN1ci50bygpLCB0aGlzLmdldEN1cnNvcihcInRvXCIpKSA+IDApIGJyZWFrXG4gICAgICByYW5nZXMucHVzaCh7YW5jaG9yOiBjdXIuZnJvbSgpLCBoZWFkOiBjdXIudG8oKX0pXG4gICAgfVxuICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25zKHJhbmdlcywgMClcbiAgfSlcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgdmFyIGllX2x0OCA9IC9NU0lFIFxcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPT0gbnVsbCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4KTtcblxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG5cbiAgdmFyIG1hdGNoaW5nID0ge1wiKFwiOiBcIik+XCIsIFwiKVwiOiBcIig8XCIsIFwiW1wiOiBcIl0+XCIsIFwiXVwiOiBcIls8XCIsIFwie1wiOiBcIn0+XCIsIFwifVwiOiBcIns8XCIsIFwiPFwiOiBcIj4+XCIsIFwiPlwiOiBcIjw8XCJ9O1xuXG4gIGZ1bmN0aW9uIGJyYWNrZXRSZWdleChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnICYmIGNvbmZpZy5icmFja2V0UmVnZXggfHwgL1soKXt9W1xcXV0vXG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdCcmFja2V0KGNtLCB3aGVyZSwgY29uZmlnKSB7XG4gICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKHdoZXJlLmxpbmUpLCBwb3MgPSB3aGVyZS5jaCAtIDE7XG4gICAgdmFyIGFmdGVyQ3Vyc29yID0gY29uZmlnICYmIGNvbmZpZy5hZnRlckN1cnNvclxuICAgIGlmIChhZnRlckN1cnNvciA9PSBudWxsKVxuICAgICAgYWZ0ZXJDdXJzb3IgPSAvKF58ICljbS1mYXQtY3Vyc29yKCR8ICkvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpXG4gICAgdmFyIHJlID0gYnJhY2tldFJlZ2V4KGNvbmZpZylcblxuICAgIC8vIEEgY3Vyc29yIGlzIGRlZmluZWQgYXMgYmV0d2VlbiB0d28gY2hhcmFjdGVycywgYnV0IGluIGluIHZpbSBjb21tYW5kIG1vZGVcbiAgICAvLyAoaS5lLiBub3QgaW5zZXJ0IG1vZGUpLCB0aGUgY3Vyc29yIGlzIHZpc3VhbGx5IHJlcHJlc2VudGVkIGFzIGFcbiAgICAvLyBoaWdobGlnaHRlZCBib3ggb24gdG9wIG9mIHRoZSAybmQgY2hhcmFjdGVyLiBPdGhlcndpc2UsIHdlIGFsbG93IG1hdGNoZXNcbiAgICAvLyBmcm9tIGJlZm9yZSBvciBhZnRlciB0aGUgY3Vyc29yLlxuICAgIHZhciBtYXRjaCA9ICghYWZ0ZXJDdXJzb3IgJiYgcG9zID49IDAgJiYgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcykpICYmIG1hdGNoaW5nW2xpbmUudGV4dC5jaGFyQXQocG9zKV0pIHx8XG4gICAgICAgIHJlLnRlc3QobGluZS50ZXh0LmNoYXJBdChwb3MgKyAxKSkgJiYgbWF0Y2hpbmdbbGluZS50ZXh0LmNoYXJBdCgrK3BvcyldO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgIHZhciBkaXIgPSBtYXRjaC5jaGFyQXQoMSkgPT0gXCI+XCIgPyAxIDogLTE7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcuc3RyaWN0ICYmIChkaXIgPiAwKSAhPSAocG9zID09IHdoZXJlLmNoKSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHN0eWxlID0gY20uZ2V0VG9rZW5UeXBlQXQoUG9zKHdoZXJlLmxpbmUsIHBvcyArIDEpKTtcblxuICAgIHZhciBmb3VuZCA9IHNjYW5Gb3JCcmFja2V0KGNtLCBQb3Mod2hlcmUubGluZSwgcG9zICsgKGRpciA+IDAgPyAxIDogMCkpLCBkaXIsIHN0eWxlLCBjb25maWcpO1xuICAgIGlmIChmb3VuZCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge2Zyb206IFBvcyh3aGVyZS5saW5lLCBwb3MpLCB0bzogZm91bmQgJiYgZm91bmQucG9zLFxuICAgICAgICAgICAgbWF0Y2g6IGZvdW5kICYmIGZvdW5kLmNoID09IG1hdGNoLmNoYXJBdCgwKSwgZm9yd2FyZDogZGlyID4gMH07XG4gIH1cblxuICAvLyBicmFja2V0UmVnZXggaXMgdXNlZCB0byBzcGVjaWZ5IHdoaWNoIHR5cGUgb2YgYnJhY2tldCB0byBzY2FuXG4gIC8vIHNob3VsZCBiZSBhIHJlZ2V4cCwgZS5nLiAvW1tcXF1dL1xuICAvL1xuICAvLyBOb3RlOiBJZiBcIndoZXJlXCIgaXMgb24gYW4gb3BlbiBicmFja2V0LCB0aGVuIHRoaXMgYnJhY2tldCBpcyBpZ25vcmVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGZhbHNlIHdoZW4gbm8gYnJhY2tldCB3YXMgZm91bmQsIG51bGwgd2hlbiBpdCByZWFjaGVkXG4gIC8vIG1heFNjYW5MaW5lcyBhbmQgZ2F2ZSB1cFxuICBmdW5jdGlvbiBzY2FuRm9yQnJhY2tldChjbSwgd2hlcmUsIGRpciwgc3R5bGUsIGNvbmZpZykge1xuICAgIHZhciBtYXhTY2FuTGVuID0gKGNvbmZpZyAmJiBjb25maWcubWF4U2NhbkxpbmVMZW5ndGgpIHx8IDEwMDAwO1xuICAgIHZhciBtYXhTY2FuTGluZXMgPSAoY29uZmlnICYmIGNvbmZpZy5tYXhTY2FuTGluZXMpIHx8IDEwMDA7XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgcmUgPSBicmFja2V0UmVnZXgoY29uZmlnKVxuICAgIHZhciBsaW5lRW5kID0gZGlyID4gMCA/IE1hdGgubWluKHdoZXJlLmxpbmUgKyBtYXhTY2FuTGluZXMsIGNtLmxhc3RMaW5lKCkgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWF4KGNtLmZpcnN0TGluZSgpIC0gMSwgd2hlcmUubGluZSAtIG1heFNjYW5MaW5lcyk7XG4gICAgZm9yICh2YXIgbGluZU5vID0gd2hlcmUubGluZTsgbGluZU5vICE9IGxpbmVFbmQ7IGxpbmVObyArPSBkaXIpIHtcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsaW5lTm8pO1xuICAgICAgaWYgKCFsaW5lKSBjb250aW51ZTtcbiAgICAgIHZhciBwb3MgPSBkaXIgPiAwID8gMCA6IGxpbmUubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IGxpbmUubGVuZ3RoIDogLTE7XG4gICAgICBpZiAobGluZS5sZW5ndGggPiBtYXhTY2FuTGVuKSBjb250aW51ZTtcbiAgICAgIGlmIChsaW5lTm8gPT0gd2hlcmUubGluZSkgcG9zID0gd2hlcmUuY2ggLSAoZGlyIDwgMCA/IDEgOiAwKTtcbiAgICAgIGZvciAoOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgIHZhciBjaCA9IGxpbmUuY2hhckF0KHBvcyk7XG4gICAgICAgIGlmIChyZS50ZXN0KGNoKSAmJiAoc3R5bGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbS5nZXRUb2tlblR5cGVBdChQb3MobGluZU5vLCBwb3MgKyAxKSkgfHwgXCJcIikgPT0gKHN0eWxlIHx8IFwiXCIpKSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoaW5nW2NoXTtcbiAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoLmNoYXJBdCgxKSA9PSBcIj5cIikgPT0gKGRpciA+IDApKSBzdGFjay5wdXNoKGNoKTtcbiAgICAgICAgICBlbHNlIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm4ge3BvczogUG9zKGxpbmVObywgcG9zKSwgY2g6IGNofTtcbiAgICAgICAgICBlbHNlIHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lTm8gLSBkaXIgPT0gKGRpciA+IDAgPyBjbS5sYXN0TGluZSgpIDogY20uZmlyc3RMaW5lKCkpID8gZmFsc2UgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hCcmFja2V0cyhjbSwgYXV0b2NsZWFyLCBjb25maWcpIHtcbiAgICAvLyBEaXNhYmxlIGJyYWNlIG1hdGNoaW5nIGluIGxvbmcgbGluZXMsIHNpbmNlIGl0J2xsIGNhdXNlIGh1Z2VseSBzbG93IHVwZGF0ZXNcbiAgICB2YXIgbWF4SGlnaGxpZ2h0TGVuID0gY20uc3RhdGUubWF0Y2hCcmFja2V0cy5tYXhIaWdobGlnaHRMaW5lTGVuZ3RoIHx8IDEwMDAsXG4gICAgICBoaWdobGlnaHROb25NYXRjaGluZyA9IGNvbmZpZyAmJiBjb25maWcuaGlnaGxpZ2h0Tm9uTWF0Y2hpbmc7XG4gICAgdmFyIG1hcmtzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXRjaCA9IHJhbmdlc1tpXS5lbXB0eSgpICYmIGZpbmRNYXRjaGluZ0JyYWNrZXQoY20sIHJhbmdlc1tpXS5oZWFkLCBjb25maWcpO1xuICAgICAgaWYgKG1hdGNoICYmIChtYXRjaC5tYXRjaCB8fCBoaWdobGlnaHROb25NYXRjaGluZyAhPT0gZmFsc2UpICYmIGNtLmdldExpbmUobWF0Y2guZnJvbS5saW5lKS5sZW5ndGggPD0gbWF4SGlnaGxpZ2h0TGVuKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IG1hdGNoLm1hdGNoID8gXCJDb2RlTWlycm9yLW1hdGNoaW5nYnJhY2tldFwiIDogXCJDb2RlTWlycm9yLW5vbm1hdGNoaW5nYnJhY2tldFwiO1xuICAgICAgICBtYXJrcy5wdXNoKGNtLm1hcmtUZXh0KG1hdGNoLmZyb20sIFBvcyhtYXRjaC5mcm9tLmxpbmUsIG1hdGNoLmZyb20uY2ggKyAxKSwge2NsYXNzTmFtZTogc3R5bGV9KSk7XG4gICAgICAgIGlmIChtYXRjaC50byAmJiBjbS5nZXRMaW5lKG1hdGNoLnRvLmxpbmUpLmxlbmd0aCA8PSBtYXhIaWdobGlnaHRMZW4pXG4gICAgICAgICAgbWFya3MucHVzaChjbS5tYXJrVGV4dChtYXRjaC50bywgUG9zKG1hdGNoLnRvLmxpbmUsIG1hdGNoLnRvLmNoICsgMSksIHtjbGFzc05hbWU6IHN0eWxlfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICAgIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCB0aGUgSUUgYnVnIGZyb20gaXNzdWUgIzExOTMsIHdoZXJlIHRleHRcbiAgICAgIC8vIGlucHV0IHN0b3BzIGdvaW5nIHRvIHRoZSB0ZXh0YXJlYSB3aGVuZXZlciB0aGlzIGZpcmVzLlxuICAgICAgaWYgKGllX2x0OCAmJiBjbS5zdGF0ZS5mb2N1c2VkKSBjbS5mb2N1cygpO1xuXG4gICAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIG1hcmtzW2ldLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChhdXRvY2xlYXIpIHNldFRpbWVvdXQoY2xlYXIsIDgwMCk7XG4gICAgICBlbHNlIHJldHVybiBjbGVhcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb01hdGNoQnJhY2tldHMoY20pIHtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCkge1xuICAgICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKCk7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCA9IG1hdGNoQnJhY2tldHMoY20sIGZhbHNlLCBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFySGlnaGxpZ2h0ZWQoY20pIHtcbiAgICBpZiAoY20uc3RhdGUubWF0Y2hCcmFja2V0cyAmJiBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKSB7XG4gICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKCk7XG4gICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcIm1hdGNoQnJhY2tldHNcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xuICAgIGlmIChvbGQgJiYgb2xkICE9IENvZGVNaXJyb3IuSW5pdCkge1xuICAgICAgY20ub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgIGNtLm9mZihcImZvY3VzXCIsIGRvTWF0Y2hCcmFja2V0cylcbiAgICAgIGNtLm9mZihcImJsdXJcIiwgY2xlYXJIaWdobGlnaHRlZClcbiAgICAgIGNsZWFySGlnaGxpZ2h0ZWQoY20pO1xuICAgIH1cbiAgICBpZiAodmFsKSB7XG4gICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzID0gdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiID8gdmFsIDoge307XG4gICAgICBjbS5vbihcImN1cnNvckFjdGl2aXR5XCIsIGRvTWF0Y2hCcmFja2V0cyk7XG4gICAgICBjbS5vbihcImZvY3VzXCIsIGRvTWF0Y2hCcmFja2V0cylcbiAgICAgIGNtLm9uKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKVxuICAgIH1cbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJtYXRjaEJyYWNrZXRzXCIsIGZ1bmN0aW9uKCkge21hdGNoQnJhY2tldHModGhpcywgdHJ1ZSk7fSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiZmluZE1hdGNoaW5nQnJhY2tldFwiLCBmdW5jdGlvbihwb3MsIGNvbmZpZywgb2xkQ29uZmlnKXtcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBrbHVkZ2VcbiAgICBpZiAob2xkQ29uZmlnIHx8IHR5cGVvZiBjb25maWcgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmICghb2xkQ29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyA/IHtzdHJpY3Q6IHRydWV9IDogbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkQ29uZmlnLnN0cmljdCA9IGNvbmZpZ1xuICAgICAgICBjb25maWcgPSBvbGRDb25maWdcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmRNYXRjaGluZ0JyYWNrZXQodGhpcywgcG9zLCBjb25maWcpXG4gIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcInNjYW5Gb3JCcmFja2V0XCIsIGZ1bmN0aW9uKHBvcywgZGlyLCBzdHlsZSwgY29uZmlnKXtcbiAgICByZXR1cm4gc2NhbkZvckJyYWNrZXQodGhpcywgcG9zLCBkaXIsIHN0eWxlLCBjb25maWcpO1xuICB9KTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gQSByb3VnaCBhcHByb3hpbWF0aW9uIG9mIFN1YmxpbWUgVGV4dCdzIGtleWJpbmRpbmdzXG4vLyBEZXBlbmRzIG9uIGFkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMgYW5kIG9wdGlvbmFsbHkgYWRkb24vZGlhbG9nL2RpYWxvZ3MuanNcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3JcIiksIHJlcXVpcmUoXCIuLi9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHNcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9hZGRvbi9zZWFyY2gvc2VhcmNoY3Vyc29yXCIsIFwiLi4vYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY21kcyA9IENvZGVNaXJyb3IuY29tbWFuZHM7XG4gIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcblxuICAvLyBUaGlzIGlzIG5vdCBleGFjdGx5IFN1YmxpbWUncyBhbGdvcml0aG0uIEkgY291bGRuJ3QgbWFrZSBoZWFkcyBvciB0YWlscyBvZiB0aGF0LlxuICBmdW5jdGlvbiBmaW5kUG9zU3Vid29yZChkb2MsIHN0YXJ0LCBkaXIpIHtcbiAgICBpZiAoZGlyIDwgMCAmJiBzdGFydC5jaCA9PSAwKSByZXR1cm4gZG9jLmNsaXBQb3MoUG9zKHN0YXJ0LmxpbmUgLSAxKSk7XG4gICAgdmFyIGxpbmUgPSBkb2MuZ2V0TGluZShzdGFydC5saW5lKTtcbiAgICBpZiAoZGlyID4gMCAmJiBzdGFydC5jaCA+PSBsaW5lLmxlbmd0aCkgcmV0dXJuIGRvYy5jbGlwUG9zKFBvcyhzdGFydC5saW5lICsgMSwgMCkpO1xuICAgIHZhciBzdGF0ZSA9IFwic3RhcnRcIiwgdHlwZSwgc3RhcnRQb3MgPSBzdGFydC5jaDtcbiAgICBmb3IgKHZhciBwb3MgPSBzdGFydFBvcywgZSA9IGRpciA8IDAgPyAwIDogbGluZS5sZW5ndGgsIGkgPSAwOyBwb3MgIT0gZTsgcG9zICs9IGRpciwgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGxpbmUuY2hhckF0KGRpciA8IDAgPyBwb3MgLSAxIDogcG9zKTtcbiAgICAgIHZhciBjYXQgPSBuZXh0ICE9IFwiX1wiICYmIENvZGVNaXJyb3IuaXNXb3JkQ2hhcihuZXh0KSA/IFwid1wiIDogXCJvXCI7XG4gICAgICBpZiAoY2F0ID09IFwid1wiICYmIG5leHQudG9VcHBlckNhc2UoKSA9PSBuZXh0KSBjYXQgPSBcIldcIjtcbiAgICAgIGlmIChzdGF0ZSA9PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgaWYgKGNhdCAhPSBcIm9cIikgeyBzdGF0ZSA9IFwiaW5cIjsgdHlwZSA9IGNhdDsgfVxuICAgICAgICBlbHNlIHN0YXJ0UG9zID0gcG9zICsgZGlyXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwiaW5cIikge1xuICAgICAgICBpZiAodHlwZSAhPSBjYXQpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PSBcIndcIiAmJiBjYXQgPT0gXCJXXCIgJiYgZGlyIDwgMCkgcG9zLS07XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJXXCIgJiYgY2F0ID09IFwid1wiICYmIGRpciA+IDApIHsgLy8gRnJvbSB1cHBlcmNhc2UgdG8gbG93ZXJjYXNlXG4gICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0UG9zICsgMSkgeyB0eXBlID0gXCJ3XCI7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBlbHNlIHBvcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIHBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlU3Vid29yZChjbSwgZGlyKSB7XG4gICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBjbS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXG4gICAgICAgIHJldHVybiBmaW5kUG9zU3Vid29yZChjbS5kb2MsIHJhbmdlLmhlYWQsIGRpcik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNtZHMuZ29TdWJ3b3JkTGVmdCA9IGZ1bmN0aW9uKGNtKSB7IG1vdmVTdWJ3b3JkKGNtLCAtMSk7IH07XG4gIGNtZHMuZ29TdWJ3b3JkUmlnaHQgPSBmdW5jdGlvbihjbSkgeyBtb3ZlU3Vid29yZChjbSwgMSk7IH07XG5cbiAgY21kcy5zY3JvbGxMaW5lVXAgPSBmdW5jdGlvbihjbSkge1xuICAgIHZhciBpbmZvID0gY20uZ2V0U2Nyb2xsSW5mbygpO1xuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgdmFyIHZpc2libGVCb3R0b21MaW5lID0gY20ubGluZUF0SGVpZ2h0KGluZm8udG9wICsgaW5mby5jbGllbnRIZWlnaHQsIFwibG9jYWxcIik7XG4gICAgICBpZiAoY20uZ2V0Q3Vyc29yKCkubGluZSA+PSB2aXNpYmxlQm90dG9tTGluZSlcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoXCJnb0xpbmVVcFwiKTtcbiAgICB9XG4gICAgY20uc2Nyb2xsVG8obnVsbCwgaW5mby50b3AgLSBjbS5kZWZhdWx0VGV4dEhlaWdodCgpKTtcbiAgfTtcbiAgY21kcy5zY3JvbGxMaW5lRG93biA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIGluZm8gPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICB2YXIgdmlzaWJsZVRvcExpbmUgPSBjbS5saW5lQXRIZWlnaHQoaW5mby50b3AsIFwibG9jYWxcIikrMTtcbiAgICAgIGlmIChjbS5nZXRDdXJzb3IoKS5saW5lIDw9IHZpc2libGVUb3BMaW5lKVxuICAgICAgICBjbS5leGVjQ29tbWFuZChcImdvTGluZURvd25cIik7XG4gICAgfVxuICAgIGNtLnNjcm9sbFRvKG51bGwsIGluZm8udG9wICsgY20uZGVmYXVsdFRleHRIZWlnaHQoKSk7XG4gIH07XG5cbiAgY21kcy5zcGxpdFNlbGVjdGlvbkJ5TGluZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIGxpbmVSYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbaV0uZnJvbSgpLCB0byA9IHJhbmdlc1tpXS50bygpO1xuICAgICAgZm9yICh2YXIgbGluZSA9IGZyb20ubGluZTsgbGluZSA8PSB0by5saW5lOyArK2xpbmUpXG4gICAgICAgIGlmICghKHRvLmxpbmUgPiBmcm9tLmxpbmUgJiYgbGluZSA9PSB0by5saW5lICYmIHRvLmNoID09IDApKVxuICAgICAgICAgIGxpbmVSYW5nZXMucHVzaCh7YW5jaG9yOiBsaW5lID09IGZyb20ubGluZSA/IGZyb20gOiBQb3MobGluZSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkOiBsaW5lID09IHRvLmxpbmUgPyB0byA6IFBvcyhsaW5lKX0pO1xuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb25zKGxpbmVSYW5nZXMsIDApO1xuICB9O1xuXG4gIGNtZHMuc2luZ2xlU2VsZWN0aW9uVG9wID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5saXN0U2VsZWN0aW9ucygpWzBdO1xuICAgIGNtLnNldFNlbGVjdGlvbihyYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQsIHtzY3JvbGw6IGZhbHNlfSk7XG4gIH07XG5cbiAgY21kcy5zZWxlY3RMaW5lID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgZXh0ZW5kZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgZXh0ZW5kZWQucHVzaCh7YW5jaG9yOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLFxuICAgICAgICAgICAgICAgICAgICAgaGVhZDogUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApfSk7XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbnMoZXh0ZW5kZWQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluc2VydExpbmUoY20sIGFib3ZlKSB7XG4gICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzc1xuICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4gPSBjbS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aCwgbmV3U2VsZWN0aW9uID0gW10sIGxhc3QgPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhlYWQgPSBjbS5saXN0U2VsZWN0aW9ucygpW2ldLmhlYWQ7XG4gICAgICAgIGlmIChoZWFkLmxpbmUgPD0gbGFzdCkgY29udGludWU7XG4gICAgICAgIHZhciBhdCA9IFBvcyhoZWFkLmxpbmUgKyAoYWJvdmUgPyAwIDogMSksIDApO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcXG5cIiwgYXQsIG51bGwsIFwiK2luc2VydExpbmVcIik7XG4gICAgICAgIGNtLmluZGVudExpbmUoYXQubGluZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIG5ld1NlbGVjdGlvbi5wdXNoKHtoZWFkOiBhdCwgYW5jaG9yOiBhdH0pO1xuICAgICAgICBsYXN0ID0gaGVhZC5saW5lICsgMTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2VsZWN0aW9uKTtcbiAgICB9KTtcbiAgICBjbS5leGVjQ29tbWFuZChcImluZGVudEF1dG9cIik7XG4gIH1cblxuICBjbWRzLmluc2VydExpbmVBZnRlciA9IGZ1bmN0aW9uKGNtKSB7IHJldHVybiBpbnNlcnRMaW5lKGNtLCBmYWxzZSk7IH07XG5cbiAgY21kcy5pbnNlcnRMaW5lQmVmb3JlID0gZnVuY3Rpb24oY20pIHsgcmV0dXJuIGluc2VydExpbmUoY20sIHRydWUpOyB9O1xuXG4gIGZ1bmN0aW9uIHdvcmRBdChjbSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBzdGFydCwgbGluZSA9IGNtLmdldExpbmUocG9zLmxpbmUpO1xuICAgIHdoaWxlIChzdGFydCAmJiBDb2RlTWlycm9yLmlzV29yZENoYXIobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkpIC0tc3RhcnQ7XG4gICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIENvZGVNaXJyb3IuaXNXb3JkQ2hhcihsaW5lLmNoYXJBdChlbmQpKSkgKytlbmQ7XG4gICAgcmV0dXJuIHtmcm9tOiBQb3MocG9zLmxpbmUsIHN0YXJ0KSwgdG86IFBvcyhwb3MubGluZSwgZW5kKSwgd29yZDogbGluZS5zbGljZShzdGFydCwgZW5kKX07XG4gIH1cblxuICBjbWRzLnNlbGVjdE5leHRPY2N1cnJlbmNlID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgZnJvbSA9IGNtLmdldEN1cnNvcihcImZyb21cIiksIHRvID0gY20uZ2V0Q3Vyc29yKFwidG9cIik7XG4gICAgdmFyIGZ1bGxXb3JkID0gY20uc3RhdGUuc3VibGltZUZpbmRGdWxsV29yZCA9PSBjbS5kb2Muc2VsO1xuICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhmcm9tLCB0bykgPT0gMCkge1xuICAgICAgdmFyIHdvcmQgPSB3b3JkQXQoY20sIGZyb20pO1xuICAgICAgaWYgKCF3b3JkLndvcmQpIHJldHVybjtcbiAgICAgIGNtLnNldFNlbGVjdGlvbih3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgZnVsbFdvcmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKGZyb20sIHRvKTtcbiAgICAgIHZhciBxdWVyeSA9IGZ1bGxXb3JkID8gbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyB0ZXh0ICsgXCJcXFxcYlwiKSA6IHRleHQ7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBjdXIuZmluZE5leHQoKTtcbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgY3VyID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCBQb3MoY20uZmlyc3RMaW5lKCksIDApKTtcbiAgICAgICAgZm91bmQgPSBjdXIuZmluZE5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQgfHwgaXNTZWxlY3RlZFJhbmdlKGNtLmxpc3RTZWxlY3Rpb25zKCksIGN1ci5mcm9tKCksIGN1ci50bygpKSkgcmV0dXJuXG4gICAgICBjbS5hZGRTZWxlY3Rpb24oY3VyLmZyb20oKSwgY3VyLnRvKCkpO1xuICAgIH1cbiAgICBpZiAoZnVsbFdvcmQpXG4gICAgICBjbS5zdGF0ZS5zdWJsaW1lRmluZEZ1bGxXb3JkID0gY20uZG9jLnNlbDtcbiAgfTtcblxuICBjbWRzLnNraXBBbmRTZWxlY3ROZXh0T2NjdXJyZW5jZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIHByZXZBbmNob3IgPSBjbS5nZXRDdXJzb3IoXCJhbmNob3JcIiksIHByZXZIZWFkID0gY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKTtcbiAgICBjbWRzLnNlbGVjdE5leHRPY2N1cnJlbmNlKGNtKTtcbiAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3MocHJldkFuY2hvciwgcHJldkhlYWQpICE9IDApIHtcbiAgICAgIGNtLmRvYy5zZXRTZWxlY3Rpb25zKGNtLmRvYy5saXN0U2VsZWN0aW9ucygpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsLmFuY2hvciAhPSBwcmV2QW5jaG9yIHx8IHNlbC5oZWFkICE9IHByZXZIZWFkO1xuICAgICAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDdXJzb3JUb1NlbGVjdGlvbihjbSwgZGlyKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1JhbmdlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICB2YXIgbmV3QW5jaG9yID0gY20uZmluZFBvc1YoXG4gICAgICAgICAgcmFuZ2UuYW5jaG9yLCBkaXIsIFwibGluZVwiLCByYW5nZS5hbmNob3IuZ29hbENvbHVtbik7XG4gICAgICB2YXIgbmV3SGVhZCA9IGNtLmZpbmRQb3NWKFxuICAgICAgICAgIHJhbmdlLmhlYWQsIGRpciwgXCJsaW5lXCIsIHJhbmdlLmhlYWQuZ29hbENvbHVtbik7XG4gICAgICBuZXdBbmNob3IuZ29hbENvbHVtbiA9IHJhbmdlLmFuY2hvci5nb2FsQ29sdW1uICE9IG51bGwgP1xuICAgICAgICAgIHJhbmdlLmFuY2hvci5nb2FsQ29sdW1uIDogY20uY3Vyc29yQ29vcmRzKHJhbmdlLmFuY2hvciwgXCJkaXZcIikubGVmdDtcbiAgICAgIG5ld0hlYWQuZ29hbENvbHVtbiA9IHJhbmdlLmhlYWQuZ29hbENvbHVtbiAhPSBudWxsID9cbiAgICAgICAgICByYW5nZS5oZWFkLmdvYWxDb2x1bW4gOiBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikubGVmdDtcbiAgICAgIHZhciBuZXdSYW5nZSA9IHthbmNob3I6IG5ld0FuY2hvciwgaGVhZDogbmV3SGVhZH07XG4gICAgICBuZXdSYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICBuZXdSYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbnMobmV3UmFuZ2VzKTtcbiAgfVxuICBjbWRzLmFkZEN1cnNvclRvUHJldkxpbmUgPSBmdW5jdGlvbihjbSkgeyBhZGRDdXJzb3JUb1NlbGVjdGlvbihjbSwgLTEpOyB9O1xuICBjbWRzLmFkZEN1cnNvclRvTmV4dExpbmUgPSBmdW5jdGlvbihjbSkgeyBhZGRDdXJzb3JUb1NlbGVjdGlvbihjbSwgMSk7IH07XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RlZFJhbmdlKHJhbmdlcywgZnJvbSwgdG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhyYW5nZXNbaV0uZnJvbSgpLCBmcm9tKSA9PSAwICYmXG4gICAgICAgICAgQ29kZU1pcnJvci5jbXBQb3MocmFuZ2VzW2ldLnRvKCksIHRvKSA9PSAwKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pcnJvciA9IFwiKCl7fVtdXCI7XG4gIGZ1bmN0aW9uIHNlbGVjdEJldHdlZW5CcmFja2V0cyhjbSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBuZXdSYW5nZXMgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIHBvcyA9IHJhbmdlLmhlYWQsIG9wZW5pbmcgPSBjbS5zY2FuRm9yQnJhY2tldChwb3MsIC0xKTtcbiAgICAgIGlmICghb3BlbmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgY2xvc2luZyA9IGNtLnNjYW5Gb3JCcmFja2V0KHBvcywgMSk7XG4gICAgICAgIGlmICghY2xvc2luZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY2xvc2luZy5jaCA9PSBtaXJyb3IuY2hhckF0KG1pcnJvci5pbmRleE9mKG9wZW5pbmcuY2gpICsgMSkpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBQb3Mob3BlbmluZy5wb3MubGluZSwgb3BlbmluZy5wb3MuY2ggKyAxKTtcbiAgICAgICAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3Moc3RhcnRQb3MsIHJhbmdlLmZyb20oKSkgPT0gMCAmJlxuICAgICAgICAgICAgICBDb2RlTWlycm9yLmNtcFBvcyhjbG9zaW5nLnBvcywgcmFuZ2UudG8oKSkgPT0gMCkge1xuICAgICAgICAgICAgb3BlbmluZyA9IGNtLnNjYW5Gb3JCcmFja2V0KG9wZW5pbmcucG9zLCAtMSk7XG4gICAgICAgICAgICBpZiAoIW9wZW5pbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2goe2FuY2hvcjogc3RhcnRQb3MsIGhlYWQ6IGNsb3NpbmcucG9zfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gUG9zKGNsb3NpbmcucG9zLmxpbmUsIGNsb3NpbmcucG9zLmNoICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbnMobmV3UmFuZ2VzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNtZHMuc2VsZWN0U2NvcGUgPSBmdW5jdGlvbihjbSkge1xuICAgIHNlbGVjdEJldHdlZW5CcmFja2V0cyhjbSkgfHwgY20uZXhlY0NvbW1hbmQoXCJzZWxlY3RBbGxcIik7XG4gIH07XG4gIGNtZHMuc2VsZWN0QmV0d2VlbkJyYWNrZXRzID0gZnVuY3Rpb24oY20pIHtcbiAgICBpZiAoIXNlbGVjdEJldHdlZW5CcmFja2V0cyhjbSkpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVuY1R5cGUodHlwZSkge1xuICAgIHJldHVybiAhdHlwZSA/IG51bGwgOiAvXFxicHVuY3R1YXRpb25cXGIvLnRlc3QodHlwZSkgPyB0eXBlIDogdW5kZWZpbmVkXG4gIH1cblxuICBjbWRzLmdvVG9CcmFja2V0ID0gZnVuY3Rpb24oY20pIHtcbiAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgIHZhciBuZXh0ID0gY20uc2NhbkZvckJyYWNrZXQocmFuZ2UuaGVhZCwgMSwgcHVuY1R5cGUoY20uZ2V0VG9rZW5UeXBlQXQocmFuZ2UuaGVhZCkpKTtcbiAgICAgIGlmIChuZXh0ICYmIENvZGVNaXJyb3IuY21wUG9zKG5leHQucG9zLCByYW5nZS5oZWFkKSAhPSAwKSByZXR1cm4gbmV4dC5wb3M7XG4gICAgICB2YXIgcHJldiA9IGNtLnNjYW5Gb3JCcmFja2V0KHJhbmdlLmhlYWQsIC0xLCBwdW5jVHlwZShjbS5nZXRUb2tlblR5cGVBdChQb3MocmFuZ2UuaGVhZC5saW5lLCByYW5nZS5oZWFkLmNoICsgMSkpKSk7XG4gICAgICByZXR1cm4gcHJldiAmJiBQb3MocHJldi5wb3MubGluZSwgcHJldi5wb3MuY2ggKyAxKSB8fCByYW5nZS5oZWFkO1xuICAgIH0pO1xuICB9O1xuXG4gIGNtZHMuc3dhcExpbmVVcCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzc1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBsaW5lc1RvTW92ZSA9IFtdLCBhdCA9IGNtLmZpcnN0TGluZSgpIC0gMSwgbmV3U2VscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIGZyb20gPSByYW5nZS5mcm9tKCkubGluZSAtIDEsIHRvID0gcmFuZ2UudG8oKS5saW5lO1xuICAgICAgbmV3U2Vscy5wdXNoKHthbmNob3I6IFBvcyhyYW5nZS5hbmNob3IubGluZSAtIDEsIHJhbmdlLmFuY2hvci5jaCksXG4gICAgICAgICAgICAgICAgICAgIGhlYWQ6IFBvcyhyYW5nZS5oZWFkLmxpbmUgLSAxLCByYW5nZS5oZWFkLmNoKX0pO1xuICAgICAgaWYgKHJhbmdlLnRvKCkuY2ggPT0gMCAmJiAhcmFuZ2UuZW1wdHkoKSkgLS10bztcbiAgICAgIGlmIChmcm9tID4gYXQpIGxpbmVzVG9Nb3ZlLnB1c2goZnJvbSwgdG8pO1xuICAgICAgZWxzZSBpZiAobGluZXNUb01vdmUubGVuZ3RoKSBsaW5lc1RvTW92ZVtsaW5lc1RvTW92ZS5sZW5ndGggLSAxXSA9IHRvO1xuICAgICAgYXQgPSB0bztcbiAgICB9XG4gICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc1RvTW92ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgZnJvbSA9IGxpbmVzVG9Nb3ZlW2ldLCB0byA9IGxpbmVzVG9Nb3ZlW2kgKyAxXTtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGZyb20pO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGZyb20sIDApLCBQb3MoZnJvbSArIDEsIDApLCBcIitzd2FwTGluZVwiKTtcbiAgICAgICAgaWYgKHRvID4gY20ubGFzdExpbmUoKSlcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcXG5cIiArIGxpbmUsIFBvcyhjbS5sYXN0TGluZSgpKSwgbnVsbCwgXCIrc3dhcExpbmVcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZSArIFwiXFxuXCIsIFBvcyh0bywgMCksIG51bGwsIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWxzKTtcbiAgICAgIGNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgY21kcy5zd2FwTGluZURvd24gPSBmdW5jdGlvbihjbSkge1xuICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHJldHVybiBDb2RlTWlycm9yLlBhc3NcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbGluZXNUb01vdmUgPSBbXSwgYXQgPSBjbS5sYXN0TGluZSgpICsgMTtcbiAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIGZyb20gPSByYW5nZS50bygpLmxpbmUgKyAxLCB0byA9IHJhbmdlLmZyb20oKS5saW5lO1xuICAgICAgaWYgKHJhbmdlLnRvKCkuY2ggPT0gMCAmJiAhcmFuZ2UuZW1wdHkoKSkgZnJvbS0tO1xuICAgICAgaWYgKGZyb20gPCBhdCkgbGluZXNUb01vdmUucHVzaChmcm9tLCB0byk7XG4gICAgICBlbHNlIGlmIChsaW5lc1RvTW92ZS5sZW5ndGgpIGxpbmVzVG9Nb3ZlW2xpbmVzVG9Nb3ZlLmxlbmd0aCAtIDFdID0gdG87XG4gICAgICBhdCA9IHRvO1xuICAgIH1cbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gbGluZXNUb01vdmUubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgdmFyIGZyb20gPSBsaW5lc1RvTW92ZVtpXSwgdG8gPSBsaW5lc1RvTW92ZVtpICsgMV07XG4gICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShmcm9tKTtcbiAgICAgICAgaWYgKGZyb20gPT0gY20ubGFzdExpbmUoKSlcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGZyb20gLSAxKSwgUG9zKGZyb20pLCBcIitzd2FwTGluZVwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBQb3MoZnJvbSwgMCksIFBvcyhmcm9tICsgMSwgMCksIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZSArIFwiXFxuXCIsIFBvcyh0bywgMCksIG51bGwsIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgfVxuICAgICAgY20uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9KTtcbiAgfTtcblxuICBjbWRzLnRvZ2dsZUNvbW1lbnRJbmRlbnRlZCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgY20udG9nZ2xlQ29tbWVudCh7IGluZGVudDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGNtZHMuam9pbkxpbmVzID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgam9pbmVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXSwgZnJvbSA9IHJhbmdlLmZyb20oKTtcbiAgICAgIHZhciBzdGFydCA9IGZyb20ubGluZSwgZW5kID0gcmFuZ2UudG8oKS5saW5lO1xuICAgICAgd2hpbGUgKGkgPCByYW5nZXMubGVuZ3RoIC0gMSAmJiByYW5nZXNbaSArIDFdLmZyb20oKS5saW5lID09IGVuZClcbiAgICAgICAgZW5kID0gcmFuZ2VzWysraV0udG8oKS5saW5lO1xuICAgICAgam9pbmVkLnB1c2goe3N0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGFuY2hvcjogIXJhbmdlLmVtcHR5KCkgJiYgZnJvbX0pO1xuICAgIH1cbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgcmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpvaW5lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gam9pbmVkW2ldO1xuICAgICAgICB2YXIgYW5jaG9yID0gb2JqLmFuY2hvciAmJiBQb3Mob2JqLmFuY2hvci5saW5lIC0gb2Zmc2V0LCBvYmouYW5jaG9yLmNoKSwgaGVhZDtcbiAgICAgICAgZm9yICh2YXIgbGluZSA9IG9iai5zdGFydDsgbGluZSA8PSBvYmouZW5kOyBsaW5lKyspIHtcbiAgICAgICAgICB2YXIgYWN0dWFsID0gbGluZSAtIG9mZnNldDtcbiAgICAgICAgICBpZiAobGluZSA9PSBvYmouZW5kKSBoZWFkID0gUG9zKGFjdHVhbCwgY20uZ2V0TGluZShhY3R1YWwpLmxlbmd0aCArIDEpO1xuICAgICAgICAgIGlmIChhY3R1YWwgPCBjbS5sYXN0TGluZSgpKSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCIgXCIsIFBvcyhhY3R1YWwpLCBQb3MoYWN0dWFsICsgMSwgL15cXHMqLy5leGVjKGNtLmdldExpbmUoYWN0dWFsICsgMSkpWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhbmdlcy5wdXNoKHthbmNob3I6IGFuY2hvciB8fCBoZWFkLCBoZWFkOiBoZWFkfSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcywgMCk7XG4gICAgfSk7XG4gIH07XG5cbiAgY21kcy5kdXBsaWNhdGVMaW5lID0gZnVuY3Rpb24oY20pIHtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2VDb3VudCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gY20ubGlzdFNlbGVjdGlvbnMoKVtpXTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGNtLmdldExpbmUocmFuZ2UuaGVhZC5saW5lKSArIFwiXFxuXCIsIFBvcyhyYW5nZS5oZWFkLmxpbmUsIDApKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShjbS5nZXRSYW5nZShyYW5nZS5mcm9tKCksIHJhbmdlLnRvKCkpLCByYW5nZS5mcm9tKCkpO1xuICAgICAgfVxuICAgICAgY20uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIHNvcnRMaW5lcyhjbSwgY2FzZVNlbnNpdGl2ZSwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzc1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCB0b1NvcnQgPSBbXSwgc2VsZWN0ZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSBjb250aW51ZTtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLmxpbmUsIHRvID0gcmFuZ2UudG8oKS5saW5lO1xuICAgICAgd2hpbGUgKGkgPCByYW5nZXMubGVuZ3RoIC0gMSAmJiByYW5nZXNbaSArIDFdLmZyb20oKS5saW5lID09IHRvKVxuICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvKCkubGluZTtcbiAgICAgIGlmICghcmFuZ2VzW2ldLnRvKCkuY2gpIHRvLS07XG4gICAgICB0b1NvcnQucHVzaChmcm9tLCB0byk7XG4gICAgfVxuICAgIGlmICh0b1NvcnQubGVuZ3RoKSBzZWxlY3RlZCA9IHRydWU7XG4gICAgZWxzZSB0b1NvcnQucHVzaChjbS5maXJzdExpbmUoKSwgY20ubGFzdExpbmUoKSk7XG5cbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvU29ydC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgZnJvbSA9IHRvU29ydFtpXSwgdG8gPSB0b1NvcnRbaSArIDFdO1xuICAgICAgICB2YXIgc3RhcnQgPSBQb3MoZnJvbSwgMCksIGVuZCA9IFBvcyh0byk7XG4gICAgICAgIHZhciBsaW5lcyA9IGNtLmdldFJhbmdlKHN0YXJ0LCBlbmQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhc2VTZW5zaXRpdmUpXG4gICAgICAgICAgbGluZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIDwgYiA/IC1kaXJlY3Rpb24gOiBhID09IGIgPyAwIDogZGlyZWN0aW9uOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpbmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgdmFyIGF1ID0gYS50b1VwcGVyQ2FzZSgpLCBidSA9IGIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhdSAhPSBidSkgeyBhID0gYXU7IGIgPSBidTsgfVxuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLWRpcmVjdGlvbiA6IGEgPT0gYiA/IDAgOiBkaXJlY3Rpb247XG4gICAgICAgICAgfSk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZCkgcmFuZ2VzLnB1c2goe2FuY2hvcjogc3RhcnQsIGhlYWQ6IFBvcyh0byArIDEsIDApfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQpIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNtZHMuc29ydExpbmVzID0gZnVuY3Rpb24oY20pIHsgc29ydExpbmVzKGNtLCB0cnVlLCAxKTsgfTtcbiAgY21kcy5yZXZlcnNlU29ydExpbmVzID0gZnVuY3Rpb24oY20pIHsgc29ydExpbmVzKGNtLCB0cnVlLCAtMSk7IH07XG4gIGNtZHMuc29ydExpbmVzSW5zZW5zaXRpdmUgPSBmdW5jdGlvbihjbSkgeyBzb3J0TGluZXMoY20sIGZhbHNlLCAxKTsgfTtcbiAgY21kcy5yZXZlcnNlU29ydExpbmVzSW5zZW5zaXRpdmUgPSBmdW5jdGlvbihjbSkgeyBzb3J0TGluZXMoY20sIGZhbHNlLCAtMSk7IH07XG5cbiAgY21kcy5uZXh0Qm9va21hcmsgPSBmdW5jdGlvbihjbSkge1xuICAgIHZhciBtYXJrcyA9IGNtLnN0YXRlLnN1YmxpbWVCb29rbWFya3M7XG4gICAgaWYgKG1hcmtzKSB3aGlsZSAobWFya3MubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG1hcmtzLnNoaWZ0KCk7XG4gICAgICB2YXIgZm91bmQgPSBjdXJyZW50LmZpbmQoKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBtYXJrcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY21kcy5wcmV2Qm9va21hcmsgPSBmdW5jdGlvbihjbSkge1xuICAgIHZhciBtYXJrcyA9IGNtLnN0YXRlLnN1YmxpbWVCb29rbWFya3M7XG4gICAgaWYgKG1hcmtzKSB3aGlsZSAobWFya3MubGVuZ3RoKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KG1hcmtzLnBvcCgpKTtcbiAgICAgIHZhciBmb3VuZCA9IG1hcmtzW21hcmtzLmxlbmd0aCAtIDFdLmZpbmQoKTtcbiAgICAgIGlmICghZm91bmQpXG4gICAgICAgIG1hcmtzLnBvcCgpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICB9XG4gIH07XG5cbiAgY21kcy50b2dnbGVCb29rbWFyayA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgdmFyIG1hcmtzID0gY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcyB8fCAoY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcyA9IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbaV0uZnJvbSgpLCB0byA9IHJhbmdlc1tpXS50bygpO1xuICAgICAgdmFyIGZvdW5kID0gcmFuZ2VzW2ldLmVtcHR5KCkgPyBjbS5maW5kTWFya3NBdChmcm9tKSA6IGNtLmZpbmRNYXJrcyhmcm9tLCB0byk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChmb3VuZFtqXS5zdWJsaW1lQm9va21hcmspIHtcbiAgICAgICAgICBmb3VuZFtqXS5jbGVhcigpO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWFya3MubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICBpZiAobWFya3Nba10gPT0gZm91bmRbal0pXG4gICAgICAgICAgICAgIG1hcmtzLnNwbGljZShrLS0sIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiA9PSBmb3VuZC5sZW5ndGgpXG4gICAgICAgIG1hcmtzLnB1c2goY20ubWFya1RleHQoZnJvbSwgdG8sIHtzdWJsaW1lQm9va21hcms6IHRydWUsIGNsZWFyV2hlbkVtcHR5OiBmYWxzZX0pKTtcbiAgICB9XG4gIH07XG5cbiAgY21kcy5jbGVhckJvb2ttYXJrcyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIG1hcmtzID0gY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcztcbiAgICBpZiAobWFya3MpIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIG1hcmtzW2ldLmNsZWFyKCk7XG4gICAgbWFya3MubGVuZ3RoID0gMDtcbiAgfTtcblxuICBjbWRzLnNlbGVjdEJvb2ttYXJrcyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIG1hcmtzID0gY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcywgcmFuZ2VzID0gW107XG4gICAgaWYgKG1hcmtzKSBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm91bmQgPSBtYXJrc1tpXS5maW5kKCk7XG4gICAgICBpZiAoIWZvdW5kKVxuICAgICAgICBtYXJrcy5zcGxpY2UoaS0tLCAwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goe2FuY2hvcjogZm91bmQuZnJvbSwgaGVhZDogZm91bmQudG99KTtcbiAgICB9XG4gICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcywgMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW9kaWZ5V29yZE9yU2VsZWN0aW9uKGNtLCBtb2QpIHtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgaW5kaWNlcyA9IFtdLCByZXBsYWNlbWVudHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHsgaW5kaWNlcy5wdXNoKGkpOyByZXBsYWNlbWVudHMucHVzaChcIlwiKTsgfVxuICAgICAgICBlbHNlIHJlcGxhY2VtZW50cy5wdXNoKG1vZChjbS5nZXRSYW5nZShyYW5nZS5mcm9tKCksIHJhbmdlLnRvKCkpKSk7XG4gICAgICB9XG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudHMsIFwiYXJvdW5kXCIsIFwiY2FzZVwiKTtcbiAgICAgIGZvciAodmFyIGkgPSBpbmRpY2VzLmxlbmd0aCAtIDEsIGF0OyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChhdCAmJiBDb2RlTWlycm9yLmNtcFBvcyhyYW5nZS5oZWFkLCBhdCkgPiAwKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHdvcmQgPSB3b3JkQXQoY20sIHJhbmdlLmhlYWQpO1xuICAgICAgICBhdCA9IHdvcmQuZnJvbTtcbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKG1vZCh3b3JkLndvcmQpLCB3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY21kcy5zbWFydEJhY2tzcGFjZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG5cbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3Vyc29ycyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICB2YXIgaW5kZW50VW5pdCA9IGNtLmdldE9wdGlvbihcImluZGVudFVuaXRcIik7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjdXJzb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBjdXJzb3JzW2ldLmhlYWQ7XG4gICAgICAgIHZhciB0b1N0YXJ0T2ZMaW5lID0gY20uZ2V0UmFuZ2Uoe2xpbmU6IGN1cnNvci5saW5lLCBjaDogMH0sIGN1cnNvcik7XG4gICAgICAgIHZhciBjb2x1bW4gPSBDb2RlTWlycm9yLmNvdW50Q29sdW1uKHRvU3RhcnRPZkxpbmUsIG51bGwsIGNtLmdldE9wdGlvbihcInRhYlNpemVcIikpO1xuXG4gICAgICAgIC8vIERlbGV0ZSBieSBvbmUgY2hhcmFjdGVyIGJ5IGRlZmF1bHRcbiAgICAgICAgdmFyIGRlbGV0ZVBvcyA9IGNtLmZpbmRQb3NIKGN1cnNvciwgLTEsIFwiY2hhclwiLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRvU3RhcnRPZkxpbmUgJiYgIS9cXFMvLnRlc3QodG9TdGFydE9mTGluZSkgJiYgY29sdW1uICUgaW5kZW50VW5pdCA9PSAwKSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRlbnQgPSBuZXcgUG9zKGN1cnNvci5saW5lLFxuICAgICAgICAgICAgQ29kZU1pcnJvci5maW5kQ29sdW1uKHRvU3RhcnRPZkxpbmUsIGNvbHVtbiAtIGluZGVudFVuaXQsIGluZGVudFVuaXQpKTtcblxuICAgICAgICAgIC8vIFNtYXJ0IGRlbGV0ZSBvbmx5IGlmIHdlIGZvdW5kIGEgdmFsaWQgcHJldkluZGVudCBsb2NhdGlvblxuICAgICAgICAgIGlmIChwcmV2SW5kZW50LmNoICE9IGN1cnNvci5jaCkgZGVsZXRlUG9zID0gcHJldkluZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBkZWxldGVQb3MsIGN1cnNvciwgXCIrZGVsZXRlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNtZHMuZGVsTGluZVJpZ2h0ID0gZnVuY3Rpb24oY20pIHtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCByYW5nZXNbaV0uYW5jaG9yLCBQb3MocmFuZ2VzW2ldLnRvKCkubGluZSksIFwiK2RlbGV0ZVwiKTtcbiAgICAgIGNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgY21kcy51cGNhc2VBdEN1cnNvciA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgbW9kaWZ5V29yZE9yU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihzdHIpIHsgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgfTtcbiAgY21kcy5kb3duY2FzZUF0Q3Vyc29yID0gZnVuY3Rpb24oY20pIHtcbiAgICBtb2RpZnlXb3JkT3JTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICB9O1xuXG4gIGNtZHMuc2V0U3VibGltZU1hcmsgPSBmdW5jdGlvbihjbSkge1xuICAgIGlmIChjbS5zdGF0ZS5zdWJsaW1lTWFyaykgY20uc3RhdGUuc3VibGltZU1hcmsuY2xlYXIoKTtcbiAgICBjbS5zdGF0ZS5zdWJsaW1lTWFyayA9IGNtLnNldEJvb2ttYXJrKGNtLmdldEN1cnNvcigpKTtcbiAgfTtcbiAgY21kcy5zZWxlY3RUb1N1YmxpbWVNYXJrID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgZm91bmQgPSBjbS5zdGF0ZS5zdWJsaW1lTWFyayAmJiBjbS5zdGF0ZS5zdWJsaW1lTWFyay5maW5kKCk7XG4gICAgaWYgKGZvdW5kKSBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKCksIGZvdW5kKTtcbiAgfTtcbiAgY21kcy5kZWxldGVUb1N1YmxpbWVNYXJrID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgZm91bmQgPSBjbS5zdGF0ZS5zdWJsaW1lTWFyayAmJiBjbS5zdGF0ZS5zdWJsaW1lTWFyay5maW5kKCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICB2YXIgZnJvbSA9IGNtLmdldEN1cnNvcigpLCB0byA9IGZvdW5kO1xuICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGZyb20sIHRvKSA+IDApIHsgdmFyIHRtcCA9IHRvOyB0byA9IGZyb207IGZyb20gPSB0bXA7IH1cbiAgICAgIGNtLnN0YXRlLnN1YmxpbWVLaWxsZWQgPSBjbS5nZXRSYW5nZShmcm9tLCB0byk7XG4gICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgZnJvbSwgdG8pO1xuICAgIH1cbiAgfTtcbiAgY21kcy5zd2FwV2l0aFN1YmxpbWVNYXJrID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgZm91bmQgPSBjbS5zdGF0ZS5zdWJsaW1lTWFyayAmJiBjbS5zdGF0ZS5zdWJsaW1lTWFyay5maW5kKCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBjbS5zdGF0ZS5zdWJsaW1lTWFyay5jbGVhcigpO1xuICAgICAgY20uc3RhdGUuc3VibGltZU1hcmsgPSBjbS5zZXRCb29rbWFyayhjbS5nZXRDdXJzb3IoKSk7XG4gICAgICBjbS5zZXRDdXJzb3IoZm91bmQpO1xuICAgIH1cbiAgfTtcbiAgY21kcy5zdWJsaW1lWWFuayA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgaWYgKGNtLnN0YXRlLnN1YmxpbWVLaWxsZWQgIT0gbnVsbClcbiAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oY20uc3RhdGUuc3VibGltZUtpbGxlZCwgbnVsbCwgXCJwYXN0ZVwiKTtcbiAgfTtcblxuICBjbWRzLnNob3dJbkNlbnRlciA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIHBvcyA9IGNtLmN1cnNvckNvb3JkcyhudWxsLCBcImxvY2FsXCIpO1xuICAgIGNtLnNjcm9sbFRvKG51bGwsIChwb3MudG9wICsgcG9zLmJvdHRvbSkgLyAyIC0gY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodCAvIDIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRhcmdldChjbSkge1xuICAgIHZhciBmcm9tID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKSwgdG8gPSBjbS5nZXRDdXJzb3IoXCJ0b1wiKTtcbiAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3MoZnJvbSwgdG8pID09IDApIHtcbiAgICAgIHZhciB3b3JkID0gd29yZEF0KGNtLCBmcm9tKTtcbiAgICAgIGlmICghd29yZC53b3JkKSByZXR1cm47XG4gICAgICBmcm9tID0gd29yZC5mcm9tO1xuICAgICAgdG8gPSB3b3JkLnRvO1xuICAgIH1cbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiB0bywgcXVlcnk6IGNtLmdldFJhbmdlKGZyb20sIHRvKSwgd29yZDogd29yZH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQW5kR29UbyhjbSwgZm9yd2FyZCkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoY20pO1xuICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgdmFyIHF1ZXJ5ID0gdGFyZ2V0LnF1ZXJ5O1xuICAgIHZhciBjdXIgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIGZvcndhcmQgPyB0YXJnZXQudG8gOiB0YXJnZXQuZnJvbSk7XG5cbiAgICBpZiAoZm9yd2FyZCA/IGN1ci5maW5kTmV4dCgpIDogY3VyLmZpbmRQcmV2aW91cygpKSB7XG4gICAgICBjbS5zZXRTZWxlY3Rpb24oY3VyLmZyb20oKSwgY3VyLnRvKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXIgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIGZvcndhcmQgPyBQb3MoY20uZmlyc3RMaW5lKCksIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjbS5jbGlwUG9zKFBvcyhjbS5sYXN0TGluZSgpKSkpO1xuICAgICAgaWYgKGZvcndhcmQgPyBjdXIuZmluZE5leHQoKSA6IGN1ci5maW5kUHJldmlvdXMoKSlcbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKGN1ci5mcm9tKCksIGN1ci50bygpKTtcbiAgICAgIGVsc2UgaWYgKHRhcmdldC53b3JkKVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24odGFyZ2V0LmZyb20sIHRhcmdldC50byk7XG4gICAgfVxuICB9O1xuICBjbWRzLmZpbmRVbmRlciA9IGZ1bmN0aW9uKGNtKSB7IGZpbmRBbmRHb1RvKGNtLCB0cnVlKTsgfTtcbiAgY21kcy5maW5kVW5kZXJQcmV2aW91cyA9IGZ1bmN0aW9uKGNtKSB7IGZpbmRBbmRHb1RvKGNtLGZhbHNlKTsgfTtcbiAgY21kcy5maW5kQWxsVW5kZXIgPSBmdW5jdGlvbihjbSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoY20pO1xuICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgdmFyIGN1ciA9IGNtLmdldFNlYXJjaEN1cnNvcih0YXJnZXQucXVlcnkpO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHByaW1hcnlJbmRleCA9IC0xO1xuICAgIHdoaWxlIChjdXIuZmluZE5leHQoKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKHthbmNob3I6IGN1ci5mcm9tKCksIGhlYWQ6IGN1ci50bygpfSk7XG4gICAgICBpZiAoY3VyLmZyb20oKS5saW5lIDw9IHRhcmdldC5mcm9tLmxpbmUgJiYgY3VyLmZyb20oKS5jaCA8PSB0YXJnZXQuZnJvbS5jaClcbiAgICAgICAgcHJpbWFyeUluZGV4Kys7XG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbnMobWF0Y2hlcywgcHJpbWFyeUluZGV4KTtcbiAgfTtcblxuXG4gIHZhciBrZXlNYXAgPSBDb2RlTWlycm9yLmtleU1hcDtcbiAga2V5TWFwLm1hY1N1YmxpbWUgPSB7XG4gICAgXCJDbWQtTGVmdFwiOiBcImdvTGluZVN0YXJ0U21hcnRcIixcbiAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICBcIlNoaWZ0LUN0cmwtS1wiOiBcImRlbGV0ZUxpbmVcIixcbiAgICBcIkFsdC1RXCI6IFwid3JhcExpbmVzXCIsXG4gICAgXCJDdHJsLUxlZnRcIjogXCJnb1N1YndvcmRMZWZ0XCIsXG4gICAgXCJDdHJsLVJpZ2h0XCI6IFwiZ29TdWJ3b3JkUmlnaHRcIixcbiAgICBcIkN0cmwtQWx0LVVwXCI6IFwic2Nyb2xsTGluZVVwXCIsXG4gICAgXCJDdHJsLUFsdC1Eb3duXCI6IFwic2Nyb2xsTGluZURvd25cIixcbiAgICBcIkNtZC1MXCI6IFwic2VsZWN0TGluZVwiLFxuICAgIFwiU2hpZnQtQ21kLUxcIjogXCJzcGxpdFNlbGVjdGlvbkJ5TGluZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uVG9wXCIsXG4gICAgXCJDbWQtRW50ZXJcIjogXCJpbnNlcnRMaW5lQWZ0ZXJcIixcbiAgICBcIlNoaWZ0LUNtZC1FbnRlclwiOiBcImluc2VydExpbmVCZWZvcmVcIixcbiAgICBcIkNtZC1EXCI6IFwic2VsZWN0TmV4dE9jY3VycmVuY2VcIixcbiAgICBcIlNoaWZ0LUNtZC1TcGFjZVwiOiBcInNlbGVjdFNjb3BlXCIsXG4gICAgXCJTaGlmdC1DbWQtTVwiOiBcInNlbGVjdEJldHdlZW5CcmFja2V0c1wiLFxuICAgIFwiQ21kLU1cIjogXCJnb1RvQnJhY2tldFwiLFxuICAgIFwiQ21kLUN0cmwtVXBcIjogXCJzd2FwTGluZVVwXCIsXG4gICAgXCJDbWQtQ3RybC1Eb3duXCI6IFwic3dhcExpbmVEb3duXCIsXG4gICAgXCJDbWQtL1wiOiBcInRvZ2dsZUNvbW1lbnRJbmRlbnRlZFwiLFxuICAgIFwiQ21kLUpcIjogXCJqb2luTGluZXNcIixcbiAgICBcIlNoaWZ0LUNtZC1EXCI6IFwiZHVwbGljYXRlTGluZVwiLFxuICAgIFwiRjVcIjogXCJzb3J0TGluZXNcIixcbiAgICBcIlNoaWZ0LUY1XCI6IFwicmV2ZXJzZVNvcnRMaW5lc1wiLFxuICAgIFwiQ21kLUY1XCI6IFwic29ydExpbmVzSW5zZW5zaXRpdmVcIixcbiAgICBcIlNoaWZ0LUNtZC1GNVwiOiBcInJldmVyc2VTb3J0TGluZXNJbnNlbnNpdGl2ZVwiLFxuICAgIFwiRjJcIjogXCJuZXh0Qm9va21hcmtcIixcbiAgICBcIlNoaWZ0LUYyXCI6IFwicHJldkJvb2ttYXJrXCIsXG4gICAgXCJDbWQtRjJcIjogXCJ0b2dnbGVCb29rbWFya1wiLFxuICAgIFwiU2hpZnQtQ21kLUYyXCI6IFwiY2xlYXJCb29rbWFya3NcIixcbiAgICBcIkFsdC1GMlwiOiBcInNlbGVjdEJvb2ttYXJrc1wiLFxuICAgIFwiQmFja3NwYWNlXCI6IFwic21hcnRCYWNrc3BhY2VcIixcbiAgICBcIkNtZC1LIENtZC1EXCI6IFwic2tpcEFuZFNlbGVjdE5leHRPY2N1cnJlbmNlXCIsXG4gICAgXCJDbWQtSyBDbWQtS1wiOiBcImRlbExpbmVSaWdodFwiLFxuICAgIFwiQ21kLUsgQ21kLVVcIjogXCJ1cGNhc2VBdEN1cnNvclwiLFxuICAgIFwiQ21kLUsgQ21kLUxcIjogXCJkb3duY2FzZUF0Q3Vyc29yXCIsXG4gICAgXCJDbWQtSyBDbWQtU3BhY2VcIjogXCJzZXRTdWJsaW1lTWFya1wiLFxuICAgIFwiQ21kLUsgQ21kLUFcIjogXCJzZWxlY3RUb1N1YmxpbWVNYXJrXCIsXG4gICAgXCJDbWQtSyBDbWQtV1wiOiBcImRlbGV0ZVRvU3VibGltZU1hcmtcIixcbiAgICBcIkNtZC1LIENtZC1YXCI6IFwic3dhcFdpdGhTdWJsaW1lTWFya1wiLFxuICAgIFwiQ21kLUsgQ21kLVlcIjogXCJzdWJsaW1lWWFua1wiLFxuICAgIFwiQ21kLUsgQ21kLUNcIjogXCJzaG93SW5DZW50ZXJcIixcbiAgICBcIkNtZC1LIENtZC1HXCI6IFwiY2xlYXJCb29rbWFya3NcIixcbiAgICBcIkNtZC1LIENtZC1CYWNrc3BhY2VcIjogXCJkZWxMaW5lTGVmdFwiLFxuICAgIFwiQ21kLUsgQ21kLTFcIjogXCJmb2xkQWxsXCIsXG4gICAgXCJDbWQtSyBDbWQtMFwiOiBcInVuZm9sZEFsbFwiLFxuICAgIFwiQ21kLUsgQ21kLUpcIjogXCJ1bmZvbGRBbGxcIixcbiAgICBcIkN0cmwtU2hpZnQtVXBcIjogXCJhZGRDdXJzb3JUb1ByZXZMaW5lXCIsXG4gICAgXCJDdHJsLVNoaWZ0LURvd25cIjogXCJhZGRDdXJzb3JUb05leHRMaW5lXCIsXG4gICAgXCJDbWQtRjNcIjogXCJmaW5kVW5kZXJcIixcbiAgICBcIlNoaWZ0LUNtZC1GM1wiOiBcImZpbmRVbmRlclByZXZpb3VzXCIsXG4gICAgXCJBbHQtRjNcIjogXCJmaW5kQWxsVW5kZXJcIixcbiAgICBcIlNoaWZ0LUNtZC1bXCI6IFwiZm9sZFwiLFxuICAgIFwiU2hpZnQtQ21kLV1cIjogXCJ1bmZvbGRcIixcbiAgICBcIkNtZC1JXCI6IFwiZmluZEluY3JlbWVudGFsXCIsXG4gICAgXCJTaGlmdC1DbWQtSVwiOiBcImZpbmRJbmNyZW1lbnRhbFJldmVyc2VcIixcbiAgICBcIkNtZC1IXCI6IFwicmVwbGFjZVwiLFxuICAgIFwiRjNcIjogXCJmaW5kTmV4dFwiLFxuICAgIFwiU2hpZnQtRjNcIjogXCJmaW5kUHJldlwiLFxuICAgIFwiZmFsbHRocm91Z2hcIjogXCJtYWNEZWZhdWx0XCJcbiAgfTtcbiAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAoa2V5TWFwLm1hY1N1YmxpbWUpO1xuXG4gIGtleU1hcC5wY1N1YmxpbWUgPSB7XG4gICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgXCJTaGlmdC1DdHJsLUtcIjogXCJkZWxldGVMaW5lXCIsXG4gICAgXCJBbHQtUVwiOiBcIndyYXBMaW5lc1wiLFxuICAgIFwiQ3RybC1UXCI6IFwidHJhbnNwb3NlQ2hhcnNcIixcbiAgICBcIkFsdC1MZWZ0XCI6IFwiZ29TdWJ3b3JkTGVmdFwiLFxuICAgIFwiQWx0LVJpZ2h0XCI6IFwiZ29TdWJ3b3JkUmlnaHRcIixcbiAgICBcIkN0cmwtVXBcIjogXCJzY3JvbGxMaW5lVXBcIixcbiAgICBcIkN0cmwtRG93blwiOiBcInNjcm9sbExpbmVEb3duXCIsXG4gICAgXCJDdHJsLUxcIjogXCJzZWxlY3RMaW5lXCIsXG4gICAgXCJTaGlmdC1DdHJsLUxcIjogXCJzcGxpdFNlbGVjdGlvbkJ5TGluZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uVG9wXCIsXG4gICAgXCJDdHJsLUVudGVyXCI6IFwiaW5zZXJ0TGluZUFmdGVyXCIsXG4gICAgXCJTaGlmdC1DdHJsLUVudGVyXCI6IFwiaW5zZXJ0TGluZUJlZm9yZVwiLFxuICAgIFwiQ3RybC1EXCI6IFwic2VsZWN0TmV4dE9jY3VycmVuY2VcIixcbiAgICBcIlNoaWZ0LUN0cmwtU3BhY2VcIjogXCJzZWxlY3RTY29wZVwiLFxuICAgIFwiU2hpZnQtQ3RybC1NXCI6IFwic2VsZWN0QmV0d2VlbkJyYWNrZXRzXCIsXG4gICAgXCJDdHJsLU1cIjogXCJnb1RvQnJhY2tldFwiLFxuICAgIFwiU2hpZnQtQ3RybC1VcFwiOiBcInN3YXBMaW5lVXBcIixcbiAgICBcIlNoaWZ0LUN0cmwtRG93blwiOiBcInN3YXBMaW5lRG93blwiLFxuICAgIFwiQ3RybC0vXCI6IFwidG9nZ2xlQ29tbWVudEluZGVudGVkXCIsXG4gICAgXCJDdHJsLUpcIjogXCJqb2luTGluZXNcIixcbiAgICBcIlNoaWZ0LUN0cmwtRFwiOiBcImR1cGxpY2F0ZUxpbmVcIixcbiAgICBcIkY5XCI6IFwic29ydExpbmVzXCIsXG4gICAgXCJTaGlmdC1GOVwiOiBcInJldmVyc2VTb3J0TGluZXNcIixcbiAgICBcIkN0cmwtRjlcIjogXCJzb3J0TGluZXNJbnNlbnNpdGl2ZVwiLFxuICAgIFwiU2hpZnQtQ3RybC1GOVwiOiBcInJldmVyc2VTb3J0TGluZXNJbnNlbnNpdGl2ZVwiLFxuICAgIFwiRjJcIjogXCJuZXh0Qm9va21hcmtcIixcbiAgICBcIlNoaWZ0LUYyXCI6IFwicHJldkJvb2ttYXJrXCIsXG4gICAgXCJDdHJsLUYyXCI6IFwidG9nZ2xlQm9va21hcmtcIixcbiAgICBcIlNoaWZ0LUN0cmwtRjJcIjogXCJjbGVhckJvb2ttYXJrc1wiLFxuICAgIFwiQWx0LUYyXCI6IFwic2VsZWN0Qm9va21hcmtzXCIsXG4gICAgXCJCYWNrc3BhY2VcIjogXCJzbWFydEJhY2tzcGFjZVwiLFxuICAgIFwiQ3RybC1LIEN0cmwtRFwiOiBcInNraXBBbmRTZWxlY3ROZXh0T2NjdXJyZW5jZVwiLFxuICAgIFwiQ3RybC1LIEN0cmwtS1wiOiBcImRlbExpbmVSaWdodFwiLFxuICAgIFwiQ3RybC1LIEN0cmwtVVwiOiBcInVwY2FzZUF0Q3Vyc29yXCIsXG4gICAgXCJDdHJsLUsgQ3RybC1MXCI6IFwiZG93bmNhc2VBdEN1cnNvclwiLFxuICAgIFwiQ3RybC1LIEN0cmwtU3BhY2VcIjogXCJzZXRTdWJsaW1lTWFya1wiLFxuICAgIFwiQ3RybC1LIEN0cmwtQVwiOiBcInNlbGVjdFRvU3VibGltZU1hcmtcIixcbiAgICBcIkN0cmwtSyBDdHJsLVdcIjogXCJkZWxldGVUb1N1YmxpbWVNYXJrXCIsXG4gICAgXCJDdHJsLUsgQ3RybC1YXCI6IFwic3dhcFdpdGhTdWJsaW1lTWFya1wiLFxuICAgIFwiQ3RybC1LIEN0cmwtWVwiOiBcInN1YmxpbWVZYW5rXCIsXG4gICAgXCJDdHJsLUsgQ3RybC1DXCI6IFwic2hvd0luQ2VudGVyXCIsXG4gICAgXCJDdHJsLUsgQ3RybC1HXCI6IFwiY2xlYXJCb29rbWFya3NcIixcbiAgICBcIkN0cmwtSyBDdHJsLUJhY2tzcGFjZVwiOiBcImRlbExpbmVMZWZ0XCIsXG4gICAgXCJDdHJsLUsgQ3RybC0xXCI6IFwiZm9sZEFsbFwiLFxuICAgIFwiQ3RybC1LIEN0cmwtMFwiOiBcInVuZm9sZEFsbFwiLFxuICAgIFwiQ3RybC1LIEN0cmwtSlwiOiBcInVuZm9sZEFsbFwiLFxuICAgIFwiQ3RybC1BbHQtVXBcIjogXCJhZGRDdXJzb3JUb1ByZXZMaW5lXCIsXG4gICAgXCJDdHJsLUFsdC1Eb3duXCI6IFwiYWRkQ3Vyc29yVG9OZXh0TGluZVwiLFxuICAgIFwiQ3RybC1GM1wiOiBcImZpbmRVbmRlclwiLFxuICAgIFwiU2hpZnQtQ3RybC1GM1wiOiBcImZpbmRVbmRlclByZXZpb3VzXCIsXG4gICAgXCJBbHQtRjNcIjogXCJmaW5kQWxsVW5kZXJcIixcbiAgICBcIlNoaWZ0LUN0cmwtW1wiOiBcImZvbGRcIixcbiAgICBcIlNoaWZ0LUN0cmwtXVwiOiBcInVuZm9sZFwiLFxuICAgIFwiQ3RybC1JXCI6IFwiZmluZEluY3JlbWVudGFsXCIsXG4gICAgXCJTaGlmdC1DdHJsLUlcIjogXCJmaW5kSW5jcmVtZW50YWxSZXZlcnNlXCIsXG4gICAgXCJDdHJsLUhcIjogXCJyZXBsYWNlXCIsXG4gICAgXCJGM1wiOiBcImZpbmROZXh0XCIsXG4gICAgXCJTaGlmdC1GM1wiOiBcImZpbmRQcmV2XCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBcInBjRGVmYXVsdFwiXG4gIH07XG4gIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwKGtleU1hcC5wY1N1YmxpbWUpO1xuXG4gIHZhciBtYWMgPSBrZXlNYXAuZGVmYXVsdCA9PSBrZXlNYXAubWFjRGVmYXVsdDtcbiAga2V5TWFwLnN1YmxpbWUgPSBtYWMgPyBrZXlNYXAubWFjU3VibGltZSA6IGtleU1hcC5wY1N1YmxpbWU7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIE9wZW4gc2ltcGxlIGRpYWxvZ3Mgb24gdG9wIG9mIGFuIGVkaXRvci4gUmVsaWVzIG9uIGRpYWxvZy5jc3MuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIGZ1bmN0aW9uIGRpYWxvZ0RpdihjbSwgdGVtcGxhdGUsIGJvdHRvbSkge1xuICAgIHZhciB3cmFwID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgZGlhbG9nO1xuICAgIGRpYWxvZyA9IHdyYXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgaWYgKGJvdHRvbSlcbiAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItZGlhbG9nIENvZGVNaXJyb3ItZGlhbG9nLWJvdHRvbVwiO1xuICAgIGVsc2VcbiAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItZGlhbG9nIENvZGVNaXJyb3ItZGlhbG9nLXRvcFwiO1xuXG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkaWFsb2cuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgfSBlbHNlIHsgLy8gQXNzdW1pbmcgaXQncyBhIGRldGFjaGVkIERPTSBlbGVtZW50LlxuICAgICAgZGlhbG9nLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgQ29kZU1pcnJvci5hZGRDbGFzcyh3cmFwLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgIHJldHVybiBkaWFsb2c7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZU5vdGlmaWNhdGlvbihjbSwgbmV3VmFsKSB7XG4gICAgaWYgKGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSlcbiAgICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSgpO1xuICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSA9IG5ld1ZhbDtcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwib3BlbkRpYWxvZ1wiLCBmdW5jdGlvbih0ZW1wbGF0ZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIGNsb3NlTm90aWZpY2F0aW9uKHRoaXMsIG51bGwpO1xuXG4gICAgdmFyIGRpYWxvZyA9IGRpYWxvZ0Rpdih0aGlzLCB0ZW1wbGF0ZSwgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgbWUgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGNsb3NlKG5ld1ZhbCkge1xuICAgICAgaWYgKHR5cGVvZiBuZXdWYWwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5wLnZhbHVlID0gbmV3VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBDb2RlTWlycm9yLnJtQ2xhc3MoZGlhbG9nLnBhcmVudE5vZGUsICdkaWFsb2ctb3BlbmVkJyk7XG4gICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgIG1lLmZvY3VzKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub25DbG9zZSkgb3B0aW9ucy5vbkNsb3NlKGRpYWxvZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlucCA9IGRpYWxvZy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLCBidXR0b247XG4gICAgaWYgKGlucCkge1xuICAgICAgaW5wLmZvY3VzKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlucC52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbGVjdFZhbHVlT25PcGVuICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlucC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vbklucHV0KVxuICAgICAgICBDb2RlTWlycm9yLm9uKGlucCwgXCJpbnB1dFwiLCBmdW5jdGlvbihlKSB7IG9wdGlvbnMub25JbnB1dChlLCBpbnAudmFsdWUsIGNsb3NlKTt9KTtcbiAgICAgIGlmIChvcHRpb25zLm9uS2V5VXApXG4gICAgICAgIENvZGVNaXJyb3Iub24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uKGUpIHtvcHRpb25zLm9uS2V5VXAoZSwgaW5wLnZhbHVlLCBjbG9zZSk7fSk7XG5cbiAgICAgIENvZGVNaXJyb3Iub24oaW5wLCBcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9uS2V5RG93biAmJiBvcHRpb25zLm9uS2V5RG93bihlLCBpbnAudmFsdWUsIGNsb3NlKSkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNyB8fCAob3B0aW9ucy5jbG9zZU9uRW50ZXIgIT09IGZhbHNlICYmIGUua2V5Q29kZSA9PSAxMykpIHtcbiAgICAgICAgICBpbnAuYmx1cigpO1xuICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgY2FsbGJhY2soaW5wLnZhbHVlLCBlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5jbG9zZU9uQmx1ciAhPT0gZmFsc2UpIENvZGVNaXJyb3Iub24oZGlhbG9nLCBcImZvY3Vzb3V0XCIsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5yZWxhdGVkVGFyZ2V0ICE9PSBudWxsKSBjbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPSBkaWFsb2cuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJidXR0b25cIilbMF0pIHtcbiAgICAgIENvZGVNaXJyb3Iub24oYnV0dG9uLCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICBtZS5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25CbHVyICE9PSBmYWxzZSkgQ29kZU1pcnJvci5vbihidXR0b24sIFwiYmx1clwiLCBjbG9zZSk7XG5cbiAgICAgIGJ1dHRvbi5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2U7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwib3BlbkNvbmZpcm1cIiwgZnVuY3Rpb24odGVtcGxhdGUsIGNhbGxiYWNrcywgb3B0aW9ucykge1xuICAgIGNsb3NlTm90aWZpY2F0aW9uKHRoaXMsIG51bGwpO1xuICAgIHZhciBkaWFsb2cgPSBkaWFsb2dEaXYodGhpcywgdGVtcGxhdGUsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBidXR0b25zID0gZGlhbG9nLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYnV0dG9uXCIpO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgbWUgPSB0aGlzLCBibHVycmluZyA9IDE7XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgQ29kZU1pcnJvci5ybUNsYXNzKGRpYWxvZy5wYXJlbnROb2RlLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgIG1lLmZvY3VzKCk7XG4gICAgfVxuICAgIGJ1dHRvbnNbMF0uZm9jdXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBiID0gYnV0dG9uc1tpXTtcbiAgICAgIChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBDb2RlTWlycm9yLm9uKGIsIFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKGNhbGxiYWNrc1tpXSk7XG4gICAgICBDb2RlTWlycm9yLm9uKGIsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLS1ibHVycmluZztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgaWYgKGJsdXJyaW5nIDw9IDApIGNsb3NlKCk7IH0sIDIwMCk7XG4gICAgICB9KTtcbiAgICAgIENvZGVNaXJyb3Iub24oYiwgXCJmb2N1c1wiLCBmdW5jdGlvbigpIHsgKytibHVycmluZzsgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKlxuICAgKiBvcGVuTm90aWZpY2F0aW9uXG4gICAqIE9wZW5zIGEgbm90aWZpY2F0aW9uLCB0aGF0IGNhbiBiZSBjbG9zZWQgd2l0aCBhbiBvcHRpb25hbCB0aW1lclxuICAgKiAoZGVmYXVsdCA1MDAwbXMgdGltZXIpIGFuZCBhbHdheXMgY2xvc2VzIG9uIGNsaWNrLlxuICAgKlxuICAgKiBJZiBhIG5vdGlmaWNhdGlvbiBpcyBvcGVuZWQgd2hpbGUgYW5vdGhlciBpcyBvcGVuZWQsIGl0IHdpbGwgY2xvc2UgdGhlXG4gICAqIGN1cnJlbnRseSBvcGVuZWQgb25lIGFuZCBvcGVuIHRoZSBuZXcgb25lIGltbWVkaWF0ZWx5LlxuICAgKi9cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJvcGVuTm90aWZpY2F0aW9uXCIsIGZ1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgY2xvc2VOb3RpZmljYXRpb24odGhpcywgY2xvc2UpO1xuICAgIHZhciBkaWFsb2cgPSBkaWFsb2dEaXYodGhpcywgdGVtcGxhdGUsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgZG9uZVRpbWVyO1xuICAgIHZhciBkdXJhdGlvbiA9IG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZHVyYXRpb24gIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmR1cmF0aW9uIDogNTAwMDtcblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChkb25lVGltZXIpO1xuICAgICAgQ29kZU1pcnJvci5ybUNsYXNzKGRpYWxvZy5wYXJlbnROb2RlLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICB9XG5cbiAgICBDb2RlTWlycm9yLm9uKGRpYWxvZywgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmIChkdXJhdGlvbilcbiAgICAgIGRvbmVUaW1lciA9IHNldFRpbWVvdXQoY2xvc2UsIGR1cmF0aW9uKTtcblxuICAgIHJldHVybiBjbG9zZTtcbiAgfSk7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIERlZmluZSBzZWFyY2ggY29tbWFuZHMuIERlcGVuZHMgb24gZGlhbG9nLmpzIG9yIGFub3RoZXJcbi8vIGltcGxlbWVudGF0aW9uIG9mIHRoZSBvcGVuRGlhbG9nIG1ldGhvZC5cblxuLy8gUmVwbGFjZSB3b3JrcyBhIGxpdHRsZSBvZGRseSAtLSBpdCB3aWxsIGRvIHRoZSByZXBsYWNlIG9uIHRoZSBuZXh0XG4vLyBDdHJsLUcgKG9yIHdoYXRldmVyIGlzIGJvdW5kIHRvIGZpbmROZXh0KSBwcmVzcy4gWW91IHByZXZlbnQgYVxuLy8gcmVwbGFjZSBieSBtYWtpbmcgc3VyZSB0aGUgbWF0Y2ggaXMgbm8gbG9uZ2VyIHNlbGVjdGVkIHdoZW4gaGl0dGluZ1xuLy8gQ3RybC1HLlxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi9zZWFyY2hjdXJzb3JcIiksIHJlcXVpcmUoXCIuLi9kaWFsb2cvZGlhbG9nXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi9zZWFyY2hjdXJzb3JcIiwgXCIuLi9kaWFsb2cvZGlhbG9nXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBkZWZhdWx0IHNlYXJjaCBwYW5lbCBsb2NhdGlvblxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcInNlYXJjaFwiLCB7Ym90dG9tOiBmYWxzZX0pO1xuXG4gIGZ1bmN0aW9uIHNlYXJjaE92ZXJsYXkocXVlcnksIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIilcbiAgICAgIHF1ZXJ5ID0gbmV3IFJlZ0V4cChxdWVyeS5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIiksIGNhc2VJbnNlbnNpdGl2ZSA/IFwiZ2lcIiA6IFwiZ1wiKTtcbiAgICBlbHNlIGlmICghcXVlcnkuZ2xvYmFsKVxuICAgICAgcXVlcnkgPSBuZXcgUmVnRXhwKHF1ZXJ5LnNvdXJjZSwgcXVlcnkuaWdub3JlQ2FzZSA/IFwiZ2lcIiA6IFwiZ1wiKTtcblxuICAgIHJldHVybiB7dG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcXVlcnkubGFzdEluZGV4ID0gc3RyZWFtLnBvcztcbiAgICAgIHZhciBtYXRjaCA9IHF1ZXJ5LmV4ZWMoc3RyZWFtLnN0cmluZyk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT0gc3RyZWFtLnBvcykge1xuICAgICAgICBzdHJlYW0ucG9zICs9IG1hdGNoWzBdLmxlbmd0aCB8fCAxO1xuICAgICAgICByZXR1cm4gXCJzZWFyY2hpbmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICAgICAgc3RyZWFtLnBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgfVxuICAgIH19O1xuICB9XG5cbiAgZnVuY3Rpb24gU2VhcmNoU3RhdGUoKSB7XG4gICAgdGhpcy5wb3NGcm9tID0gdGhpcy5wb3NUbyA9IHRoaXMubGFzdFF1ZXJ5ID0gdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlYXJjaFN0YXRlKGNtKSB7XG4gICAgcmV0dXJuIGNtLnN0YXRlLnNlYXJjaCB8fCAoY20uc3RhdGUuc2VhcmNoID0gbmV3IFNlYXJjaFN0YXRlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVlcnlDYXNlSW5zZW5zaXRpdmUocXVlcnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIgJiYgcXVlcnkgPT0gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlYXJjaEN1cnNvcihjbSwgcXVlcnksIHBvcykge1xuICAgIC8vIEhldXJpc3RpYzogaWYgdGhlIHF1ZXJ5IHN0cmluZyBpcyBhbGwgbG93ZXJjYXNlLCBkbyBhIGNhc2UgaW5zZW5zaXRpdmUgc2VhcmNoLlxuICAgIHJldHVybiBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIHBvcywge2Nhc2VGb2xkOiBxdWVyeUNhc2VJbnNlbnNpdGl2ZShxdWVyeSksIG11bHRpbGluZTogdHJ1ZX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyc2lzdGVudERpYWxvZyhjbSwgdGV4dCwgZGVmbHQsIG9uRW50ZXIsIG9uS2V5RG93bikge1xuICAgIGNtLm9wZW5EaWFsb2codGV4dCwgb25FbnRlciwge1xuICAgICAgdmFsdWU6IGRlZmx0LFxuICAgICAgc2VsZWN0VmFsdWVPbk9wZW46IHRydWUsXG4gICAgICBjbG9zZU9uRW50ZXI6IGZhbHNlLFxuICAgICAgb25DbG9zZTogZnVuY3Rpb24oKSB7IGNsZWFyU2VhcmNoKGNtKTsgfSxcbiAgICAgIG9uS2V5RG93bjogb25LZXlEb3duLFxuICAgICAgYm90dG9tOiBjbS5vcHRpb25zLnNlYXJjaC5ib3R0b21cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpYWxvZyhjbSwgdGV4dCwgc2hvcnRUZXh0LCBkZWZsdCwgZikge1xuICAgIGlmIChjbS5vcGVuRGlhbG9nKSBjbS5vcGVuRGlhbG9nKHRleHQsIGYsIHt2YWx1ZTogZGVmbHQsIHNlbGVjdFZhbHVlT25PcGVuOiB0cnVlLCBib3R0b206IGNtLm9wdGlvbnMuc2VhcmNoLmJvdHRvbX0pO1xuICAgIGVsc2UgZihwcm9tcHQoc2hvcnRUZXh0LCBkZWZsdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybURpYWxvZyhjbSwgdGV4dCwgc2hvcnRUZXh0LCBmcykge1xuICAgIGlmIChjbS5vcGVuQ29uZmlybSkgY20ub3BlbkNvbmZpcm0odGV4dCwgZnMpO1xuICAgIGVsc2UgaWYgKGNvbmZpcm0oc2hvcnRUZXh0KSkgZnNbMF0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxcXChbbnJ0XFxcXF0pL2csIGZ1bmN0aW9uKG1hdGNoLCBjaCkge1xuICAgICAgaWYgKGNoID09IFwiblwiKSByZXR1cm4gXCJcXG5cIlxuICAgICAgaWYgKGNoID09IFwiclwiKSByZXR1cm4gXCJcXHJcIlxuICAgICAgaWYgKGNoID09IFwidFwiKSByZXR1cm4gXCJcXHRcIlxuICAgICAgaWYgKGNoID09IFwiXFxcXFwiKSByZXR1cm4gXCJcXFxcXCJcbiAgICAgIHJldHVybiBtYXRjaFxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgdmFyIGlzUkUgPSBxdWVyeS5tYXRjaCgvXlxcLyguKilcXC8oW2Etel0qKSQvKTtcbiAgICBpZiAoaXNSRSkge1xuICAgICAgdHJ5IHsgcXVlcnkgPSBuZXcgUmVnRXhwKGlzUkVbMV0sIGlzUkVbMl0uaW5kZXhPZihcImlcIikgPT0gLTEgPyBcIlwiIDogXCJpXCIpOyB9XG4gICAgICBjYXRjaChlKSB7fSAvLyBOb3QgYSByZWd1bGFyIGV4cHJlc3Npb24gYWZ0ZXIgYWxsLCBkbyBhIHN0cmluZyBzZWFyY2hcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBwYXJzZVN0cmluZyhxdWVyeSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PSBcInN0cmluZ1wiID8gcXVlcnkgPT0gXCJcIiA6IHF1ZXJ5LnRlc3QoXCJcIikpXG4gICAgICBxdWVyeSA9IC94Xi87XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRTZWFyY2goY20sIHN0YXRlLCBxdWVyeSkge1xuICAgIHN0YXRlLnF1ZXJ5VGV4dCA9IHF1ZXJ5O1xuICAgIHN0YXRlLnF1ZXJ5ID0gcGFyc2VRdWVyeShxdWVyeSk7XG4gICAgY20ucmVtb3ZlT3ZlcmxheShzdGF0ZS5vdmVybGF5LCBxdWVyeUNhc2VJbnNlbnNpdGl2ZShzdGF0ZS5xdWVyeSkpO1xuICAgIHN0YXRlLm92ZXJsYXkgPSBzZWFyY2hPdmVybGF5KHN0YXRlLnF1ZXJ5LCBxdWVyeUNhc2VJbnNlbnNpdGl2ZShzdGF0ZS5xdWVyeSkpO1xuICAgIGNtLmFkZE92ZXJsYXkoc3RhdGUub3ZlcmxheSk7XG4gICAgaWYgKGNtLnNob3dNYXRjaGVzT25TY3JvbGxiYXIpIHtcbiAgICAgIGlmIChzdGF0ZS5hbm5vdGF0ZSkgeyBzdGF0ZS5hbm5vdGF0ZS5jbGVhcigpOyBzdGF0ZS5hbm5vdGF0ZSA9IG51bGw7IH1cbiAgICAgIHN0YXRlLmFubm90YXRlID0gY20uc2hvd01hdGNoZXNPblNjcm9sbGJhcihzdGF0ZS5xdWVyeSwgcXVlcnlDYXNlSW5zZW5zaXRpdmUoc3RhdGUucXVlcnkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb1NlYXJjaChjbSwgcmV2LCBwZXJzaXN0ZW50LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgaWYgKHN0YXRlLnF1ZXJ5KSByZXR1cm4gZmluZE5leHQoY20sIHJldik7XG4gICAgdmFyIHEgPSBjbS5nZXRTZWxlY3Rpb24oKSB8fCBzdGF0ZS5sYXN0UXVlcnk7XG4gICAgaWYgKHEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcS5zb3VyY2UgPT0gXCJ4XlwiKSBxID0gbnVsbFxuICAgIGlmIChwZXJzaXN0ZW50ICYmIGNtLm9wZW5EaWFsb2cpIHtcbiAgICAgIHZhciBoaWRpbmcgPSBudWxsXG4gICAgICB2YXIgc2VhcmNoTmV4dCA9IGZ1bmN0aW9uKHF1ZXJ5LCBldmVudCkge1xuICAgICAgICBDb2RlTWlycm9yLmVfc3RvcChldmVudCk7XG4gICAgICAgIGlmICghcXVlcnkpIHJldHVybjtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9IHN0YXRlLnF1ZXJ5VGV4dCkge1xuICAgICAgICAgIHN0YXJ0U2VhcmNoKGNtLCBzdGF0ZSwgcXVlcnkpO1xuICAgICAgICAgIHN0YXRlLnBvc0Zyb20gPSBzdGF0ZS5wb3NUbyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWRpbmcpIGhpZGluZy5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgICBmaW5kTmV4dChjbSwgZXZlbnQuc2hpZnRLZXksIGZ1bmN0aW9uKF8sIHRvKSB7XG4gICAgICAgICAgdmFyIGRpYWxvZ1xuICAgICAgICAgIGlmICh0by5saW5lIDwgMyAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICYmXG4gICAgICAgICAgICAgIChkaWFsb2cgPSBjbS5kaXNwbGF5LndyYXBwZXIucXVlcnlTZWxlY3RvcihcIi5Db2RlTWlycm9yLWRpYWxvZ1wiKSkgJiZcbiAgICAgICAgICAgICAgZGlhbG9nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIDQgPiBjbS5jdXJzb3JDb29yZHModG8sIFwid2luZG93XCIpLnRvcClcbiAgICAgICAgICAgIChoaWRpbmcgPSBkaWFsb2cpLnN0eWxlLm9wYWNpdHkgPSAuNFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHBlcnNpc3RlbnREaWFsb2coY20sIGdldFF1ZXJ5RGlhbG9nKGNtKSwgcSwgc2VhcmNoTmV4dCwgZnVuY3Rpb24oZXZlbnQsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGV2ZW50KVxuICAgICAgICB2YXIgZXh0cmEgPSBjbS5nZXRPcHRpb24oJ2V4dHJhS2V5cycpLCBjbWQgPSAoZXh0cmEgJiYgZXh0cmFba2V5TmFtZV0pIHx8IENvZGVNaXJyb3Iua2V5TWFwW2NtLmdldE9wdGlvbihcImtleU1hcFwiKV1ba2V5TmFtZV1cbiAgICAgICAgaWYgKGNtZCA9PSBcImZpbmROZXh0XCIgfHwgY21kID09IFwiZmluZFByZXZcIiB8fFxuICAgICAgICAgIGNtZCA9PSBcImZpbmRQZXJzaXN0ZW50TmV4dFwiIHx8IGNtZCA9PSBcImZpbmRQZXJzaXN0ZW50UHJldlwiKSB7XG4gICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZXZlbnQpO1xuICAgICAgICAgIHN0YXJ0U2VhcmNoKGNtLCBnZXRTZWFyY2hTdGF0ZShjbSksIHF1ZXJ5KTtcbiAgICAgICAgICBjbS5leGVjQ29tbWFuZChjbWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PSBcImZpbmRcIiB8fCBjbWQgPT0gXCJmaW5kUGVyc2lzdGVudFwiKSB7XG4gICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZXZlbnQpO1xuICAgICAgICAgIHNlYXJjaE5leHQocXVlcnksIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaW1tZWRpYXRlICYmIHEpIHtcbiAgICAgICAgc3RhcnRTZWFyY2goY20sIHN0YXRlLCBxKTtcbiAgICAgICAgZmluZE5leHQoY20sIHJldik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpYWxvZyhjbSwgZ2V0UXVlcnlEaWFsb2coY20pLCBcIlNlYXJjaCBmb3I6XCIsIHEsIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeSAmJiAhc3RhdGUucXVlcnkpIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdGFydFNlYXJjaChjbSwgc3RhdGUsIHF1ZXJ5KTtcbiAgICAgICAgICBzdGF0ZS5wb3NGcm9tID0gc3RhdGUucG9zVG8gPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgICBmaW5kTmV4dChjbSwgcmV2KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTmV4dChjbSwgcmV2LCBjYWxsYmFjaykge2NtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgdmFyIGN1cnNvciA9IGdldFNlYXJjaEN1cnNvcihjbSwgc3RhdGUucXVlcnksIHJldiA/IHN0YXRlLnBvc0Zyb20gOiBzdGF0ZS5wb3NUbyk7XG4gICAgaWYgKCFjdXJzb3IuZmluZChyZXYpKSB7XG4gICAgICBjdXJzb3IgPSBnZXRTZWFyY2hDdXJzb3IoY20sIHN0YXRlLnF1ZXJ5LCByZXYgPyBDb2RlTWlycm9yLlBvcyhjbS5sYXN0TGluZSgpKSA6IENvZGVNaXJyb3IuUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7XG4gICAgICBpZiAoIWN1cnNvci5maW5kKHJldikpIHJldHVybjtcbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9uKGN1cnNvci5mcm9tKCksIGN1cnNvci50bygpKTtcbiAgICBjbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY3Vyc29yLmZyb20oKSwgdG86IGN1cnNvci50bygpfSwgMjApO1xuICAgIHN0YXRlLnBvc0Zyb20gPSBjdXJzb3IuZnJvbSgpOyBzdGF0ZS5wb3NUbyA9IGN1cnNvci50bygpO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soY3Vyc29yLmZyb20oKSwgY3Vyc29yLnRvKCkpXG4gIH0pO31cblxuICBmdW5jdGlvbiBjbGVhclNlYXJjaChjbSkge2NtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgc3RhdGUubGFzdFF1ZXJ5ID0gc3RhdGUucXVlcnk7XG4gICAgaWYgKCFzdGF0ZS5xdWVyeSkgcmV0dXJuO1xuICAgIHN0YXRlLnF1ZXJ5ID0gc3RhdGUucXVlcnlUZXh0ID0gbnVsbDtcbiAgICBjbS5yZW1vdmVPdmVybGF5KHN0YXRlLm92ZXJsYXkpO1xuICAgIGlmIChzdGF0ZS5hbm5vdGF0ZSkgeyBzdGF0ZS5hbm5vdGF0ZS5jbGVhcigpOyBzdGF0ZS5hbm5vdGF0ZSA9IG51bGw7IH1cbiAgfSk7fVxuXG4gIGZ1bmN0aW9uIGVsKHRhZywgYXR0cnMpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRhZyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSA6IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGVsZW1lbnRba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBhcmd1bWVudHNbaV1cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodHlwZW9mIGNoaWxkID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UXVlcnlEaWFsb2coY20pICB7XG4gICAgcmV0dXJuIGVsKFwiXCIsIG51bGwsXG4gICAgICAgICAgICAgIGVsKFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3Itc2VhcmNoLWxhYmVsXCJ9LCBjbS5waHJhc2UoXCJTZWFyY2g6XCIpKSwgXCIgXCIsXG4gICAgICAgICAgICAgIGVsKFwiaW5wdXRcIiwge3R5cGU6IFwidGV4dFwiLCBcInN0eWxlXCI6IFwid2lkdGg6IDEwZW1cIiwgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3Itc2VhcmNoLWZpZWxkXCJ9KSwgXCIgXCIsXG4gICAgICAgICAgICAgIGVsKFwic3BhblwiLCB7c3R5bGU6IFwiY29sb3I6ICM4ODhcIiwgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3Itc2VhcmNoLWhpbnRcIn0sXG4gICAgICAgICAgICAgICAgIGNtLnBocmFzZShcIihVc2UgL3JlLyBzeW50YXggZm9yIHJlZ2V4cCBzZWFyY2gpXCIpKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVF1ZXJ5RGlhbG9nKGNtKSB7XG4gICAgcmV0dXJuIGVsKFwiXCIsIG51bGwsIFwiIFwiLFxuICAgICAgICAgICAgICBlbChcImlucHV0XCIsIHt0eXBlOiBcInRleHRcIiwgXCJzdHlsZVwiOiBcIndpZHRoOiAxMGVtXCIsIGNsYXNzTmFtZTogXCJDb2RlTWlycm9yLXNlYXJjaC1maWVsZFwifSksIFwiIFwiLFxuICAgICAgICAgICAgICBlbChcInNwYW5cIiwge3N0eWxlOiBcImNvbG9yOiAjODg4XCIsIGNsYXNzTmFtZTogXCJDb2RlTWlycm9yLXNlYXJjaC1oaW50XCJ9LFxuICAgICAgICAgICAgICAgICBjbS5waHJhc2UoXCIoVXNlIC9yZS8gc3ludGF4IGZvciByZWdleHAgc2VhcmNoKVwiKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VtZW50UXVlcnlEaWFsb2coY20pIHtcbiAgICByZXR1cm4gZWwoXCJcIiwgbnVsbCxcbiAgICAgICAgICAgICAgZWwoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1zZWFyY2gtbGFiZWxcIn0sIGNtLnBocmFzZShcIldpdGg6XCIpKSwgXCIgXCIsXG4gICAgICAgICAgICAgIGVsKFwiaW5wdXRcIiwge3R5cGU6IFwidGV4dFwiLCBcInN0eWxlXCI6IFwid2lkdGg6IDEwZW1cIiwgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3Itc2VhcmNoLWZpZWxkXCJ9KSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RG9SZXBsYWNlQ29uZmlybShjbSkge1xuICAgIHJldHVybiBlbChcIlwiLCBudWxsLFxuICAgICAgICAgICAgICBlbChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLXNlYXJjaC1sYWJlbFwifSwgY20ucGhyYXNlKFwiUmVwbGFjZT9cIikpLCBcIiBcIixcbiAgICAgICAgICAgICAgZWwoXCJidXR0b25cIiwge30sIGNtLnBocmFzZShcIlllc1wiKSksIFwiIFwiLFxuICAgICAgICAgICAgICBlbChcImJ1dHRvblwiLCB7fSwgY20ucGhyYXNlKFwiTm9cIikpLCBcIiBcIixcbiAgICAgICAgICAgICAgZWwoXCJidXR0b25cIiwge30sIGNtLnBocmFzZShcIkFsbFwiKSksIFwiIFwiLFxuICAgICAgICAgICAgICBlbChcImJ1dHRvblwiLCB7fSwgY20ucGhyYXNlKFwiU3RvcFwiKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUFsbChjbSwgcXVlcnksIHRleHQpIHtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBjdXJzb3IgPSBnZXRTZWFyY2hDdXJzb3IoY20sIHF1ZXJ5KTsgY3Vyc29yLmZpbmROZXh0KCk7KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGNtLmdldFJhbmdlKGN1cnNvci5mcm9tKCksIGN1cnNvci50bygpKS5tYXRjaChxdWVyeSk7XG4gICAgICAgICAgY3Vyc29yLnJlcGxhY2UodGV4dC5yZXBsYWNlKC9cXCQoXFxkKS9nLCBmdW5jdGlvbihfLCBpKSB7cmV0dXJuIG1hdGNoW2ldO30pKTtcbiAgICAgICAgfSBlbHNlIGN1cnNvci5yZXBsYWNlKHRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShjbSwgYWxsKSB7XG4gICAgaWYgKGNtLmdldE9wdGlvbihcInJlYWRPbmx5XCIpKSByZXR1cm47XG4gICAgdmFyIHF1ZXJ5ID0gY20uZ2V0U2VsZWN0aW9uKCkgfHwgZ2V0U2VhcmNoU3RhdGUoY20pLmxhc3RRdWVyeTtcbiAgICB2YXIgZGlhbG9nVGV4dCA9IGFsbCA/IGNtLnBocmFzZShcIlJlcGxhY2UgYWxsOlwiKSA6IGNtLnBocmFzZShcIlJlcGxhY2U6XCIpXG4gICAgdmFyIGZyYWdtZW50ID0gZWwoXCJcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBlbChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLXNlYXJjaC1sYWJlbFwifSwgZGlhbG9nVGV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0UmVwbGFjZVF1ZXJ5RGlhbG9nKGNtKSlcbiAgICBkaWFsb2coY20sIGZyYWdtZW50LCBkaWFsb2dUZXh0LCBxdWVyeSwgZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgIGlmICghcXVlcnkpIHJldHVybjtcbiAgICAgIHF1ZXJ5ID0gcGFyc2VRdWVyeShxdWVyeSk7XG4gICAgICBkaWFsb2coY20sIGdldFJlcGxhY2VtZW50UXVlcnlEaWFsb2coY20pLCBjbS5waHJhc2UoXCJSZXBsYWNlIHdpdGg6XCIpLCBcIlwiLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHRleHQgPSBwYXJzZVN0cmluZyh0ZXh0KVxuICAgICAgICBpZiAoYWxsKSB7XG4gICAgICAgICAgcmVwbGFjZUFsbChjbSwgcXVlcnksIHRleHQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJTZWFyY2goY20pO1xuICAgICAgICAgIHZhciBjdXJzb3IgPSBnZXRTZWFyY2hDdXJzb3IoY20sIHF1ZXJ5LCBjbS5nZXRDdXJzb3IoXCJmcm9tXCIpKTtcbiAgICAgICAgICB2YXIgYWR2YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY3Vyc29yLmZyb20oKSwgbWF0Y2g7XG4gICAgICAgICAgICBpZiAoIShtYXRjaCA9IGN1cnNvci5maW5kTmV4dCgpKSkge1xuICAgICAgICAgICAgICBjdXJzb3IgPSBnZXRTZWFyY2hDdXJzb3IoY20sIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgaWYgKCEobWF0Y2ggPSBjdXJzb3IuZmluZE5leHQoKSkgfHxcbiAgICAgICAgICAgICAgICAgIChzdGFydCAmJiBjdXJzb3IuZnJvbSgpLmxpbmUgPT0gc3RhcnQubGluZSAmJiBjdXJzb3IuZnJvbSgpLmNoID09IHN0YXJ0LmNoKSkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9uKGN1cnNvci5mcm9tKCksIGN1cnNvci50bygpKTtcbiAgICAgICAgICAgIGNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjdXJzb3IuZnJvbSgpLCB0bzogY3Vyc29yLnRvKCl9KTtcbiAgICAgICAgICAgIGNvbmZpcm1EaWFsb2coY20sIGdldERvUmVwbGFjZUNvbmZpcm0oY20pLCBjbS5waHJhc2UoXCJSZXBsYWNlP1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2Z1bmN0aW9uKCkge2RvUmVwbGFjZShtYXRjaCk7fSwgYWR2YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge3JlcGxhY2VBbGwoY20sIHF1ZXJ5LCB0ZXh0KX1dKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBkb1JlcGxhY2UgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgY3Vyc29yLnJlcGxhY2UodHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIgPyB0ZXh0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucmVwbGFjZSgvXFwkKFxcZCkvZywgZnVuY3Rpb24oXywgaSkge3JldHVybiBtYXRjaFtpXTt9KSk7XG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgQ29kZU1pcnJvci5jb21tYW5kcy5maW5kID0gZnVuY3Rpb24oY20pIHtjbGVhclNlYXJjaChjbSk7IGRvU2VhcmNoKGNtKTt9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLmZpbmRQZXJzaXN0ZW50ID0gZnVuY3Rpb24oY20pIHtjbGVhclNlYXJjaChjbSk7IGRvU2VhcmNoKGNtLCBmYWxzZSwgdHJ1ZSk7fTtcbiAgQ29kZU1pcnJvci5jb21tYW5kcy5maW5kUGVyc2lzdGVudE5leHQgPSBmdW5jdGlvbihjbSkge2RvU2VhcmNoKGNtLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7fTtcbiAgQ29kZU1pcnJvci5jb21tYW5kcy5maW5kUGVyc2lzdGVudFByZXYgPSBmdW5jdGlvbihjbSkge2RvU2VhcmNoKGNtLCB0cnVlLCB0cnVlLCB0cnVlKTt9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLmZpbmROZXh0ID0gZG9TZWFyY2g7XG4gIENvZGVNaXJyb3IuY29tbWFuZHMuZmluZFByZXYgPSBmdW5jdGlvbihjbSkge2RvU2VhcmNoKGNtLCB0cnVlKTt9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLmNsZWFyU2VhcmNoID0gY2xlYXJTZWFyY2g7XG4gIENvZGVNaXJyb3IuY29tbWFuZHMucmVwbGFjZSA9IHJlcGxhY2U7XG4gIENvZGVNaXJyb3IuY29tbWFuZHMucmVwbGFjZUFsbCA9IGZ1bmN0aW9uKGNtKSB7cmVwbGFjZShjbSwgdHJ1ZSk7fTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gRGVmaW5lcyBqdW1wVG9MaW5lIGNvbW1hbmQuIFVzZXMgZGlhbG9nLmpzIGlmIHByZXNlbnQuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9kaWFsb2cvZGlhbG9nXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vZGlhbG9nL2RpYWxvZ1wiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gZGVmYXVsdCBzZWFyY2ggcGFuZWwgbG9jYXRpb25cbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJzZWFyY2hcIiwge2JvdHRvbTogZmFsc2V9KTtcblxuICBmdW5jdGlvbiBkaWFsb2coY20sIHRleHQsIHNob3J0VGV4dCwgZGVmbHQsIGYpIHtcbiAgICBpZiAoY20ub3BlbkRpYWxvZykgY20ub3BlbkRpYWxvZyh0ZXh0LCBmLCB7dmFsdWU6IGRlZmx0LCBzZWxlY3RWYWx1ZU9uT3BlbjogdHJ1ZSwgYm90dG9tOiBjbS5vcHRpb25zLnNlYXJjaC5ib3R0b219KTtcbiAgICBlbHNlIGYocHJvbXB0KHNob3J0VGV4dCwgZGVmbHQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEp1bXBEaWFsb2coY20pIHtcbiAgICByZXR1cm4gY20ucGhyYXNlKFwiSnVtcCB0byBsaW5lOlwiKSArICcgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJ3aWR0aDogMTBlbVwiIGNsYXNzPVwiQ29kZU1pcnJvci1zZWFyY2gtZmllbGRcIi8+IDxzcGFuIHN0eWxlPVwiY29sb3I6ICM4ODhcIiBjbGFzcz1cIkNvZGVNaXJyb3Itc2VhcmNoLWhpbnRcIj4nICsgY20ucGhyYXNlKFwiKFVzZSBsaW5lOmNvbHVtbiBvciBzY3JvbGwlIHN5bnRheClcIikgKyAnPC9zcGFuPic7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnByZXRMaW5lKGNtLCBzdHJpbmcpIHtcbiAgICB2YXIgbnVtID0gTnVtYmVyKHN0cmluZylcbiAgICBpZiAoL15bLStdLy50ZXN0KHN0cmluZykpIHJldHVybiBjbS5nZXRDdXJzb3IoKS5saW5lICsgbnVtXG4gICAgZWxzZSByZXR1cm4gbnVtIC0gMVxuICB9XG5cbiAgQ29kZU1pcnJvci5jb21tYW5kcy5qdW1wVG9MaW5lID0gZnVuY3Rpb24oY20pIHtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgZGlhbG9nKGNtLCBnZXRKdW1wRGlhbG9nKGNtKSwgY20ucGhyYXNlKFwiSnVtcCB0byBsaW5lOlwiKSwgKGN1ci5saW5lICsgMSkgKyBcIjpcIiArIGN1ci5jaCwgZnVuY3Rpb24ocG9zU3RyKSB7XG4gICAgICBpZiAoIXBvc1N0cikgcmV0dXJuO1xuXG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICBpZiAobWF0Y2ggPSAvXlxccyooW1xcK1xcLV0/XFxkKylcXHMqXFw6XFxzKihcXGQrKVxccyokLy5leGVjKHBvc1N0cikpIHtcbiAgICAgICAgY20uc2V0Q3Vyc29yKGludGVycHJldExpbmUoY20sIG1hdGNoWzFdKSwgTnVtYmVyKG1hdGNoWzJdKSlcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSAvXlxccyooW1xcK1xcLV0/XFxkKyhcXC5cXGQrKT8pXFwlXFxzKi8uZXhlYyhwb3NTdHIpKSB7XG4gICAgICAgIHZhciBsaW5lID0gTWF0aC5yb3VuZChjbS5saW5lQ291bnQoKSAqIE51bWJlcihtYXRjaFsxXSkgLyAxMDApO1xuICAgICAgICBpZiAoL15bLStdLy50ZXN0KG1hdGNoWzFdKSkgbGluZSA9IGN1ci5saW5lICsgbGluZSArIDE7XG4gICAgICAgIGNtLnNldEN1cnNvcihsaW5lIC0gMSwgY3VyLmNoKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSAvXlxccypcXDo/XFxzKihbXFwrXFwtXT9cXGQrKVxccyovLmV4ZWMocG9zU3RyKSkge1xuICAgICAgICBjbS5zZXRDdXJzb3IoaW50ZXJwcmV0TGluZShjbSwgbWF0Y2hbMV0pLCBjdXIuY2gpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIENvZGVNaXJyb3Iua2V5TWFwW1wiZGVmYXVsdFwiXVtcIkFsdC1HXCJdID0gXCJqdW1wVG9MaW5lXCI7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBub09wdGlvbnMgPSB7fTtcbiAgdmFyIG5vbldTID0gL1teXFxzXFx1MDBhMF0vO1xuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3MsIGNtcCA9IENvZGVNaXJyb3IuY21wUG9zO1xuXG4gIGZ1bmN0aW9uIGZpcnN0Tm9uV1Moc3RyKSB7XG4gICAgdmFyIGZvdW5kID0gc3RyLnNlYXJjaChub25XUyk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gMCA6IGZvdW5kO1xuICB9XG5cbiAgQ29kZU1pcnJvci5jb21tYW5kcy50b2dnbGVDb21tZW50ID0gZnVuY3Rpb24oY20pIHtcbiAgICBjbS50b2dnbGVDb21tZW50KCk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJ0b2dnbGVDb21tZW50XCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSBub09wdGlvbnM7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICB2YXIgbWluTGluZSA9IEluZmluaXR5LCByYW5nZXMgPSB0aGlzLmxpc3RTZWxlY3Rpb25zKCksIG1vZGUgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2VzW2ldLmZyb20oKSwgdG8gPSByYW5nZXNbaV0udG8oKTtcbiAgICAgIGlmIChmcm9tLmxpbmUgPj0gbWluTGluZSkgY29udGludWU7XG4gICAgICBpZiAodG8ubGluZSA+PSBtaW5MaW5lKSB0byA9IFBvcyhtaW5MaW5lLCAwKTtcbiAgICAgIG1pbkxpbmUgPSBmcm9tLmxpbmU7XG4gICAgICBpZiAobW9kZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChjbS51bmNvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpKSBtb2RlID0gXCJ1blwiO1xuICAgICAgICBlbHNlIHsgY20ubGluZUNvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpOyBtb2RlID0gXCJsaW5lXCI7IH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBcInVuXCIpIHtcbiAgICAgICAgY20udW5jb21tZW50KGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLmxpbmVDb21tZW50KGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJvdWdoIGhldXJpc3RpYyB0byB0cnkgYW5kIGRldGVjdCBsaW5lcyB0aGF0IGFyZSBwYXJ0IG9mIG11bHRpLWxpbmUgc3RyaW5nXG4gIGZ1bmN0aW9uIHByb2JhYmx5SW5zaWRlU3RyaW5nKGNtLCBwb3MsIGxpbmUpIHtcbiAgICByZXR1cm4gL1xcYnN0cmluZ1xcYi8udGVzdChjbS5nZXRUb2tlblR5cGVBdChQb3MocG9zLmxpbmUsIDApKSkgJiYgIS9eW1xcJ1xcXCJcXGBdLy50ZXN0KGxpbmUpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRNb2RlKGNtLCBwb3MpIHtcbiAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGUoKVxuICAgIHJldHVybiBtb2RlLnVzZUlubmVyQ29tbWVudHMgPT09IGZhbHNlIHx8ICFtb2RlLmlubmVyTW9kZSA/IG1vZGUgOiBjbS5nZXRNb2RlQXQocG9zKVxuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJsaW5lQ29tbWVudFwiLCBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IG5vT3B0aW9ucztcbiAgICB2YXIgc2VsZiA9IHRoaXMsIG1vZGUgPSBnZXRNb2RlKHNlbGYsIGZyb20pO1xuICAgIHZhciBmaXJzdExpbmUgPSBzZWxmLmdldExpbmUoZnJvbS5saW5lKTtcbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwgfHwgcHJvYmFibHlJbnNpZGVTdHJpbmcoc2VsZiwgZnJvbSwgZmlyc3RMaW5lKSkgcmV0dXJuO1xuXG4gICAgdmFyIGNvbW1lbnRTdHJpbmcgPSBvcHRpb25zLmxpbmVDb21tZW50IHx8IG1vZGUubGluZUNvbW1lbnQ7XG4gICAgaWYgKCFjb21tZW50U3RyaW5nKSB7XG4gICAgICBpZiAob3B0aW9ucy5ibG9ja0NvbW1lbnRTdGFydCB8fCBtb2RlLmJsb2NrQ29tbWVudFN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuZnVsbExpbmVzID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5ibG9ja0NvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0by5jaCAhPSAwIHx8IHRvLmxpbmUgPT0gZnJvbS5saW5lID8gdG8ubGluZSArIDEgOiB0by5saW5lLCBzZWxmLmxhc3RMaW5lKCkgKyAxKTtcbiAgICB2YXIgcGFkID0gb3B0aW9ucy5wYWRkaW5nID09IG51bGwgPyBcIiBcIiA6IG9wdGlvbnMucGFkZGluZztcbiAgICB2YXIgYmxhbmtMaW5lcyA9IG9wdGlvbnMuY29tbWVudEJsYW5rTGluZXMgfHwgZnJvbS5saW5lID09IHRvLmxpbmU7XG5cbiAgICBzZWxmLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICB2YXIgYmFzZVN0cmluZyA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgIHZhciBsaW5lID0gc2VsZi5nZXRMaW5lKGkpO1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gbGluZS5zbGljZSgwLCBmaXJzdE5vbldTKGxpbmUpKTtcbiAgICAgICAgICBpZiAoYmFzZVN0cmluZyA9PSBudWxsIHx8IGJhc2VTdHJpbmcubGVuZ3RoID4gd2hpdGVzcGFjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJhc2VTdHJpbmcgPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IHNlbGYuZ2V0TGluZShpKSwgY3V0ID0gYmFzZVN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFibGFua0xpbmVzICYmICFub25XUy50ZXN0KGxpbmUpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAobGluZS5zbGljZSgwLCBjdXQpICE9IGJhc2VTdHJpbmcpIGN1dCA9IGZpcnN0Tm9uV1MobGluZSk7XG4gICAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoYmFzZVN0cmluZyArIGNvbW1lbnRTdHJpbmcgKyBwYWQsIFBvcyhpLCAwKSwgUG9zKGksIGN1dCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICBpZiAoYmxhbmtMaW5lcyB8fCBub25XUy50ZXN0KHNlbGYuZ2V0TGluZShpKSkpXG4gICAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShjb21tZW50U3RyaW5nICsgcGFkLCBQb3MoaSwgMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiYmxvY2tDb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0gbm9PcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZSA9IGdldE1vZGUoc2VsZiwgZnJvbSk7XG4gICAgdmFyIHN0YXJ0U3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRTdGFydCB8fCBtb2RlLmJsb2NrQ29tbWVudFN0YXJ0O1xuICAgIHZhciBlbmRTdHJpbmcgPSBvcHRpb25zLmJsb2NrQ29tbWVudEVuZCB8fCBtb2RlLmJsb2NrQ29tbWVudEVuZDtcbiAgICBpZiAoIXN0YXJ0U3RyaW5nIHx8ICFlbmRTdHJpbmcpIHtcbiAgICAgIGlmICgob3B0aW9ucy5saW5lQ29tbWVudCB8fCBtb2RlLmxpbmVDb21tZW50KSAmJiBvcHRpb25zLmZ1bGxMaW5lcyAhPSBmYWxzZSlcbiAgICAgICAgc2VsZi5saW5lQ29tbWVudChmcm9tLCB0bywgb3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgvXFxiY29tbWVudFxcYi8udGVzdChzZWxmLmdldFRva2VuVHlwZUF0KFBvcyhmcm9tLmxpbmUsIDApKSkpIHJldHVyblxuXG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvLmxpbmUsIHNlbGYubGFzdExpbmUoKSk7XG4gICAgaWYgKGVuZCAhPSBmcm9tLmxpbmUgJiYgdG8uY2ggPT0gMCAmJiBub25XUy50ZXN0KHNlbGYuZ2V0TGluZShlbmQpKSkgLS1lbmQ7XG5cbiAgICB2YXIgcGFkID0gb3B0aW9ucy5wYWRkaW5nID09IG51bGwgPyBcIiBcIiA6IG9wdGlvbnMucGFkZGluZztcbiAgICBpZiAoZnJvbS5saW5lID4gZW5kKSByZXR1cm47XG5cbiAgICBzZWxmLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmZ1bGxMaW5lcyAhPSBmYWxzZSkge1xuICAgICAgICB2YXIgbGFzdExpbmVIYXNUZXh0ID0gbm9uV1MudGVzdChzZWxmLmdldExpbmUoZW5kKSk7XG4gICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKHBhZCArIGVuZFN0cmluZywgUG9zKGVuZCkpO1xuICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShzdGFydFN0cmluZyArIHBhZCwgUG9zKGZyb20ubGluZSwgMCkpO1xuICAgICAgICB2YXIgbGVhZCA9IG9wdGlvbnMuYmxvY2tDb21tZW50TGVhZCB8fCBtb2RlLmJsb2NrQ29tbWVudExlYWQ7XG4gICAgICAgIGlmIChsZWFkICE9IG51bGwpIGZvciAodmFyIGkgPSBmcm9tLmxpbmUgKyAxOyBpIDw9IGVuZDsgKytpKVxuICAgICAgICAgIGlmIChpICE9IGVuZCB8fCBsYXN0TGluZUhhc1RleHQpXG4gICAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShsZWFkICsgcGFkLCBQb3MoaSwgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0Q3Vyc29yID0gY21wKHNlbGYuZ2V0Q3Vyc29yKFwidG9cIiksIHRvKSA9PSAwLCBlbXB0eSA9ICFzZWxmLnNvbWV0aGluZ1NlbGVjdGVkKClcbiAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoZW5kU3RyaW5nLCB0byk7XG4gICAgICAgIGlmIChhdEN1cnNvcikgc2VsZi5zZXRTZWxlY3Rpb24oZW1wdHkgPyB0byA6IHNlbGYuZ2V0Q3Vyc29yKFwiZnJvbVwiKSwgdG8pXG4gICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKHN0YXJ0U3RyaW5nLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJ1bmNvbW1lbnRcIiwgZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSBub09wdGlvbnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBtb2RlID0gZ2V0TW9kZShzZWxmLCBmcm9tKTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG8uY2ggIT0gMCB8fCB0by5saW5lID09IGZyb20ubGluZSA/IHRvLmxpbmUgOiB0by5saW5lIC0gMSwgc2VsZi5sYXN0TGluZSgpKSwgc3RhcnQgPSBNYXRoLm1pbihmcm9tLmxpbmUsIGVuZCk7XG5cbiAgICAvLyBUcnkgZmluZGluZyBsaW5lIGNvbW1lbnRzXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBvcHRpb25zLmxpbmVDb21tZW50IHx8IG1vZGUubGluZUNvbW1lbnQsIGxpbmVzID0gW107XG4gICAgdmFyIHBhZCA9IG9wdGlvbnMucGFkZGluZyA9PSBudWxsID8gXCIgXCIgOiBvcHRpb25zLnBhZGRpbmcsIGRpZFNvbWV0aGluZztcbiAgICBsaW5lQ29tbWVudDoge1xuICAgICAgaWYgKCFsaW5lU3RyaW5nKSBicmVhayBsaW5lQ29tbWVudDtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHNlbGYuZ2V0TGluZShpKTtcbiAgICAgICAgdmFyIGZvdW5kID0gbGluZS5pbmRleE9mKGxpbmVTdHJpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAhL2NvbW1lbnQvLnRlc3Qoc2VsZi5nZXRUb2tlblR5cGVBdChQb3MoaSwgZm91bmQgKyAxKSkpKSBmb3VuZCA9IC0xO1xuICAgICAgICBpZiAoZm91bmQgPT0gLTEgJiYgbm9uV1MudGVzdChsaW5lKSkgYnJlYWsgbGluZUNvbW1lbnQ7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xICYmIG5vbldTLnRlc3QobGluZS5zbGljZSgwLCBmb3VuZCkpKSBicmVhayBsaW5lQ29tbWVudDtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICAgIHNlbGYub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2kgLSBzdGFydF07XG4gICAgICAgICAgdmFyIHBvcyA9IGxpbmUuaW5kZXhPZihsaW5lU3RyaW5nKSwgZW5kUG9zID0gcG9zICsgbGluZVN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHBvcyA8IDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChsaW5lLnNsaWNlKGVuZFBvcywgZW5kUG9zICsgcGFkLmxlbmd0aCkgPT0gcGFkKSBlbmRQb3MgKz0gcGFkLmxlbmd0aDtcbiAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhpLCBwb3MpLCBQb3MoaSwgZW5kUG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZFNvbWV0aGluZykgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGJsb2NrIGNvbW1lbnRzXG4gICAgdmFyIHN0YXJ0U3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRTdGFydCB8fCBtb2RlLmJsb2NrQ29tbWVudFN0YXJ0O1xuICAgIHZhciBlbmRTdHJpbmcgPSBvcHRpb25zLmJsb2NrQ29tbWVudEVuZCB8fCBtb2RlLmJsb2NrQ29tbWVudEVuZDtcbiAgICBpZiAoIXN0YXJ0U3RyaW5nIHx8ICFlbmRTdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbGVhZCA9IG9wdGlvbnMuYmxvY2tDb21tZW50TGVhZCB8fCBtb2RlLmJsb2NrQ29tbWVudExlYWQ7XG4gICAgdmFyIHN0YXJ0TGluZSA9IHNlbGYuZ2V0TGluZShzdGFydCksIG9wZW4gPSBzdGFydExpbmUuaW5kZXhPZihzdGFydFN0cmluZylcbiAgICBpZiAob3BlbiA9PSAtMSkgcmV0dXJuIGZhbHNlXG4gICAgdmFyIGVuZExpbmUgPSBlbmQgPT0gc3RhcnQgPyBzdGFydExpbmUgOiBzZWxmLmdldExpbmUoZW5kKVxuICAgIHZhciBjbG9zZSA9IGVuZExpbmUuaW5kZXhPZihlbmRTdHJpbmcsIGVuZCA9PSBzdGFydCA/IG9wZW4gKyBzdGFydFN0cmluZy5sZW5ndGggOiAwKTtcbiAgICB2YXIgaW5zaWRlU3RhcnQgPSBQb3Moc3RhcnQsIG9wZW4gKyAxKSwgaW5zaWRlRW5kID0gUG9zKGVuZCwgY2xvc2UgKyAxKVxuICAgIGlmIChjbG9zZSA9PSAtMSB8fFxuICAgICAgICAhL2NvbW1lbnQvLnRlc3Qoc2VsZi5nZXRUb2tlblR5cGVBdChpbnNpZGVTdGFydCkpIHx8XG4gICAgICAgICEvY29tbWVudC8udGVzdChzZWxmLmdldFRva2VuVHlwZUF0KGluc2lkZUVuZCkpIHx8XG4gICAgICAgIHNlbGYuZ2V0UmFuZ2UoaW5zaWRlU3RhcnQsIGluc2lkZUVuZCwgXCJcXG5cIikuaW5kZXhPZihlbmRTdHJpbmcpID4gLTEpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBBdm9pZCBraWxsaW5nIGJsb2NrIGNvbW1lbnRzIGNvbXBsZXRlbHkgb3V0c2lkZSB0aGUgc2VsZWN0aW9uLlxuICAgIC8vIFBvc2l0aW9ucyBvZiB0aGUgbGFzdCBzdGFydFN0cmluZyBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24sIGFuZCB0aGUgZmlyc3QgZW5kU3RyaW5nIGFmdGVyIGl0LlxuICAgIHZhciBsYXN0U3RhcnQgPSBzdGFydExpbmUubGFzdEluZGV4T2Yoc3RhcnRTdHJpbmcsIGZyb20uY2gpO1xuICAgIHZhciBmaXJzdEVuZCA9IGxhc3RTdGFydCA9PSAtMSA/IC0xIDogc3RhcnRMaW5lLnNsaWNlKDAsIGZyb20uY2gpLmluZGV4T2YoZW5kU3RyaW5nLCBsYXN0U3RhcnQgKyBzdGFydFN0cmluZy5sZW5ndGgpO1xuICAgIGlmIChsYXN0U3RhcnQgIT0gLTEgJiYgZmlyc3RFbmQgIT0gLTEgJiYgZmlyc3RFbmQgKyBlbmRTdHJpbmcubGVuZ3RoICE9IGZyb20uY2gpIHJldHVybiBmYWxzZTtcbiAgICAvLyBQb3NpdGlvbnMgb2YgdGhlIGZpcnN0IGVuZFN0cmluZyBhZnRlciB0aGUgZW5kIG9mIHRoZSBzZWxlY3Rpb24sIGFuZCB0aGUgbGFzdCBzdGFydFN0cmluZyBiZWZvcmUgaXQuXG4gICAgZmlyc3RFbmQgPSBlbmRMaW5lLmluZGV4T2YoZW5kU3RyaW5nLCB0by5jaCk7XG4gICAgdmFyIGFsbW9zdExhc3RTdGFydCA9IGVuZExpbmUuc2xpY2UodG8uY2gpLmxhc3RJbmRleE9mKHN0YXJ0U3RyaW5nLCBmaXJzdEVuZCAtIHRvLmNoKTtcbiAgICBsYXN0U3RhcnQgPSAoZmlyc3RFbmQgPT0gLTEgfHwgYWxtb3N0TGFzdFN0YXJ0ID09IC0xKSA/IC0xIDogdG8uY2ggKyBhbG1vc3RMYXN0U3RhcnQ7XG4gICAgaWYgKGZpcnN0RW5kICE9IC0xICYmIGxhc3RTdGFydCAhPSAtMSAmJiBsYXN0U3RhcnQgIT0gdG8uY2gpIHJldHVybiBmYWxzZTtcblxuICAgIHNlbGYub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGVuZCwgY2xvc2UgLSAocGFkICYmIGVuZExpbmUuc2xpY2UoY2xvc2UgLSBwYWQubGVuZ3RoLCBjbG9zZSkgPT0gcGFkID8gcGFkLmxlbmd0aCA6IDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhlbmQsIGNsb3NlICsgZW5kU3RyaW5nLmxlbmd0aCkpO1xuICAgICAgdmFyIG9wZW5FbmQgPSBvcGVuICsgc3RhcnRTdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKHBhZCAmJiBzdGFydExpbmUuc2xpY2Uob3BlbkVuZCwgb3BlbkVuZCArIHBhZC5sZW5ndGgpID09IHBhZCkgb3BlbkVuZCArPSBwYWQubGVuZ3RoO1xuICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKHN0YXJ0LCBvcGVuKSwgUG9zKHN0YXJ0LCBvcGVuRW5kKSk7XG4gICAgICBpZiAobGVhZCkgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHNlbGYuZ2V0TGluZShpKSwgZm91bmQgPSBsaW5lLmluZGV4T2YobGVhZCk7XG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSB8fCBub25XUy50ZXN0KGxpbmUuc2xpY2UoMCwgZm91bmQpKSkgY29udGludWU7XG4gICAgICAgIHZhciBmb3VuZEVuZCA9IGZvdW5kICsgbGVhZC5sZW5ndGg7XG4gICAgICAgIGlmIChwYWQgJiYgbGluZS5zbGljZShmb3VuZEVuZCwgZm91bmRFbmQgKyBwYWQubGVuZ3RoKSA9PSBwYWQpIGZvdW5kRW5kICs9IHBhZC5sZW5ndGg7XG4gICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhpLCBmb3VuZCksIFBvcyhpLCBmb3VuZEVuZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn0pO1xuIiwiXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdsaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjc3NgXG4vKiBCQVNJQ1MgKi9cblxuLkNvZGVNaXJyb3Ige1xuICAvKiBTZXQgaGVpZ2h0LCB3aWR0aCwgYm9yZGVycywgYW5kIGdsb2JhbCBmb250IHByb3BlcnRpZXMgaGVyZSAqL1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICBoZWlnaHQ6IDMwMHB4O1xuICBjb2xvcjogYmxhY2s7XG4gIGRpcmVjdGlvbjogbHRyO1xufVxuXG4vKiBQQURESU5HICovXG5cbi5Db2RlTWlycm9yLWxpbmVzIHtcbiAgcGFkZGluZzogNHB4IDA7IC8qIFZlcnRpY2FsIHBhZGRpbmcgYXJvdW5kIGNvbnRlbnQgKi9cbn1cbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUsXG4uQ29kZU1pcnJvciBwcmUuQ29kZU1pcnJvci1saW5lLWxpa2Uge1xuICBwYWRkaW5nOiAwIDRweDsgLyogSG9yaXpvbnRhbCBwYWRkaW5nIG9mIGNvbnRlbnQgKi9cbn1cblxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciwgLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyAvKiBUaGUgbGl0dGxlIHNxdWFyZSBiZXR3ZWVuIEggYW5kIFYgc2Nyb2xsYmFycyAqL1xufVxuXG4vKiBHVVRURVIgKi9cblxuLkNvZGVNaXJyb3ItZ3V0dGVycyB7XG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjc7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG59XG4uQ29kZU1pcnJvci1saW5lbnVtYmVycyB7fVxuLkNvZGVNaXJyb3ItbGluZW51bWJlciB7XG4gIHBhZGRpbmc6IDAgM3B4IDAgNXB4O1xuICBtaW4td2lkdGg6IDIwcHg7XG4gIHRleHQtYWxpZ246IHJpZ2h0O1xuICBjb2xvcjogIzk5OTtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbn1cblxuLkNvZGVNaXJyb3ItZ3V0dGVybWFya2VyIHsgY29sb3I6IGJsYWNrOyB9XG4uQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXItc3VidGxlIHsgY29sb3I6ICM5OTk7IH1cblxuLyogQ1VSU09SICovXG5cbi5Db2RlTWlycm9yLWN1cnNvciB7XG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgYmxhY2s7XG4gIGJvcmRlci1yaWdodDogbm9uZTtcbiAgd2lkdGg6IDA7XG59XG4vKiBTaG93biB3aGVuIG1vdmluZyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0ICovXG4uQ29kZU1pcnJvciBkaXYuQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3Ige1xuICBib3JkZXItbGVmdDogMXB4IHNvbGlkIHNpbHZlcjtcbn1cbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWN1cnNvciB7XG4gIHdpZHRoOiBhdXRvO1xuICBib3JkZXI6IDAgIWltcG9ydGFudDtcbiAgYmFja2dyb3VuZDogIzdlNztcbn1cbi5jbS1mYXQtY3Vyc29yIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xuICB6LWluZGV4OiAxO1xufVxuLmNtLWZhdC1jdXJzb3ItbWFyayB7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjAsIDI1NSwgMjAsIDAuNSk7XG4gIC13ZWJraXQtYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcbiAgLW1vei1hbmltYXRpb246IGJsaW5rIDEuMDZzIHN0ZXBzKDEpIGluZmluaXRlO1xuICBhbmltYXRpb246IGJsaW5rIDEuMDZzIHN0ZXBzKDEpIGluZmluaXRlO1xufVxuLmNtLWFuaW1hdGUtZmF0LWN1cnNvciB7XG4gIHdpZHRoOiBhdXRvO1xuICAtd2Via2l0LWFuaW1hdGlvbjogYmxpbmsgMS4wNnMgc3RlcHMoMSkgaW5maW5pdGU7XG4gIC1tb3otYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcbiAgYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzdlNztcbn1cbkAtbW96LWtleWZyYW1lcyBibGluayB7XG4gIDAlIHt9XG4gIDUwJSB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XG4gIDEwMCUge31cbn1cbkAtd2Via2l0LWtleWZyYW1lcyBibGluayB7XG4gIDAlIHt9XG4gIDUwJSB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XG4gIDEwMCUge31cbn1cbkBrZXlmcmFtZXMgYmxpbmsge1xuICAwJSB7fVxuICA1MCUgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxuICAxMDAlIHt9XG59XG5cbi8qIENhbiBzdHlsZSBjdXJzb3IgZGlmZmVyZW50IGluIG92ZXJ3cml0ZSAobm9uLWluc2VydCkgbW9kZSAqL1xuLkNvZGVNaXJyb3Itb3ZlcndyaXRlIC5Db2RlTWlycm9yLWN1cnNvciB7fVxuXG4uY20tdGFiIHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7IH1cblxuLkNvZGVNaXJyb3ItcnVsZXJzIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAtNTBweDsgYm90dG9tOiAwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLkNvZGVNaXJyb3ItcnVsZXIge1xuICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNjY2M7XG4gIHRvcDogMDsgYm90dG9tOiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG5cbi8qIERFRkFVTFQgVEhFTUUgKi9cblxuLmNtLXMtZGVmYXVsdCAuY20taGVhZGVyIHtjb2xvcjogYmx1ZTt9XG4uY20tcy1kZWZhdWx0IC5jbS1xdW90ZSB7Y29sb3I6ICMwOTA7fVxuLmNtLW5lZ2F0aXZlIHtjb2xvcjogI2Q0NDt9XG4uY20tcG9zaXRpdmUge2NvbG9yOiAjMjkyO31cbi5jbS1oZWFkZXIsIC5jbS1zdHJvbmcge2ZvbnQtd2VpZ2h0OiBib2xkO31cbi5jbS1lbSB7Zm9udC1zdHlsZTogaXRhbGljO31cbi5jbS1saW5rIHt0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTt9XG4uY20tc3RyaWtldGhyb3VnaCB7dGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7fVxuXG4uY20tcy1kZWZhdWx0IC5jbS1rZXl3b3JkIHtjb2xvcjogIzcwODt9XG4uY20tcy1kZWZhdWx0IC5jbS1hdG9tIHtjb2xvcjogIzIxOTt9XG4uY20tcy1kZWZhdWx0IC5jbS1udW1iZXIge2NvbG9yOiAjMTY0O31cbi5jbS1zLWRlZmF1bHQgLmNtLWRlZiB7Y29sb3I6ICMwMGY7fVxuLmNtLXMtZGVmYXVsdCAuY20tdmFyaWFibGUsXG4uY20tcy1kZWZhdWx0IC5jbS1wdW5jdHVhdGlvbixcbi5jbS1zLWRlZmF1bHQgLmNtLXByb3BlcnR5LFxuLmNtLXMtZGVmYXVsdCAuY20tb3BlcmF0b3Ige31cbi5jbS1zLWRlZmF1bHQgLmNtLXZhcmlhYmxlLTIge2NvbG9yOiAjMDVhO31cbi5jbS1zLWRlZmF1bHQgLmNtLXZhcmlhYmxlLTMsIC5jbS1zLWRlZmF1bHQgLmNtLXR5cGUge2NvbG9yOiAjMDg1O31cbi5jbS1zLWRlZmF1bHQgLmNtLWNvbW1lbnQge2NvbG9yOiAjYTUwO31cbi5jbS1zLWRlZmF1bHQgLmNtLXN0cmluZyB7Y29sb3I6ICNhMTE7fVxuLmNtLXMtZGVmYXVsdCAuY20tc3RyaW5nLTIge2NvbG9yOiAjZjUwO31cbi5jbS1zLWRlZmF1bHQgLmNtLW1ldGEge2NvbG9yOiAjNTU1O31cbi5jbS1zLWRlZmF1bHQgLmNtLXF1YWxpZmllciB7Y29sb3I6ICM1NTU7fVxuLmNtLXMtZGVmYXVsdCAuY20tYnVpbHRpbiB7Y29sb3I6ICMzMGE7fVxuLmNtLXMtZGVmYXVsdCAuY20tYnJhY2tldCB7Y29sb3I6ICM5OTc7fVxuLmNtLXMtZGVmYXVsdCAuY20tdGFnIHtjb2xvcjogIzE3MDt9XG4uY20tcy1kZWZhdWx0IC5jbS1hdHRyaWJ1dGUge2NvbG9yOiAjMDBjO31cbi5jbS1zLWRlZmF1bHQgLmNtLWhyIHtjb2xvcjogIzk5OTt9XG4uY20tcy1kZWZhdWx0IC5jbS1saW5rIHtjb2xvcjogIzAwYzt9XG5cbi5jbS1zLWRlZmF1bHQgLmNtLWVycm9yIHtjb2xvcjogI2YwMDt9XG4uY20taW52YWxpZGNoYXIge2NvbG9yOiAjZjAwO31cblxuLkNvZGVNaXJyb3ItY29tcG9zaW5nIHsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkOyB9XG5cbi8qIERlZmF1bHQgc3R5bGVzIGZvciBjb21tb24gYWRkb25zICovXG5cbmRpdi5Db2RlTWlycm9yIHNwYW4uQ29kZU1pcnJvci1tYXRjaGluZ2JyYWNrZXQge2NvbG9yOiAjMGIwO31cbmRpdi5Db2RlTWlycm9yIHNwYW4uQ29kZU1pcnJvci1ub25tYXRjaGluZ2JyYWNrZXQge2NvbG9yOiAjYTIyO31cbi5Db2RlTWlycm9yLW1hdGNoaW5ndGFnIHsgYmFja2dyb3VuZDogcmdiYSgyNTUsIDE1MCwgMCwgLjMpOyB9XG4uQ29kZU1pcnJvci1hY3RpdmVsaW5lLWJhY2tncm91bmQge2JhY2tncm91bmQ6ICNlOGYyZmY7fVxuXG4vKiBTVE9QICovXG5cbi8qIFRoZSByZXN0IG9mIHRoaXMgZmlsZSBjb250YWlucyBzdHlsZXMgcmVsYXRlZCB0byB0aGUgbWVjaGFuaWNzIG9mXG4gICB0aGUgZWRpdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IHRvdWNoIHRoZW0uICovXG5cbi5Db2RlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbn1cblxuLkNvZGVNaXJyb3Itc2Nyb2xsIHtcbiAgb3ZlcmZsb3c6IHNjcm9sbCAhaW1wb3J0YW50OyAvKiBUaGluZ3Mgd2lsbCBicmVhayBpZiB0aGlzIGlzIG92ZXJyaWRkZW4gKi9cbiAgLyogNTBweCBpcyB0aGUgbWFnaWMgbWFyZ2luIHVzZWQgdG8gaGlkZSB0aGUgZWxlbWVudCdzIHJlYWwgc2Nyb2xsYmFycyAqL1xuICAvKiBTZWUgb3ZlcmZsb3c6IGhpZGRlbiBpbiAuQ29kZU1pcnJvciAqL1xuICBtYXJnaW4tYm90dG9tOiAtNTBweDsgbWFyZ2luLXJpZ2h0OiAtNTBweDtcbiAgcGFkZGluZy1ib3R0b206IDUwcHg7XG4gIGhlaWdodDogMTAwJTtcbiAgb3V0bGluZTogbm9uZTsgLyogUHJldmVudCBkcmFnZ2luZyBmcm9tIGhpZ2hsaWdodGluZyB0aGUgZWxlbWVudCAqL1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uQ29kZU1pcnJvci1zaXplciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgYm9yZGVyLXJpZ2h0OiA1MHB4IHNvbGlkIHRyYW5zcGFyZW50O1xufVxuXG4vKiBUaGUgZmFrZSwgdmlzaWJsZSBzY3JvbGxiYXJzLiBVc2VkIHRvIGZvcmNlIHJlZHJhdyBkdXJpbmcgc2Nyb2xsaW5nXG4gICBiZWZvcmUgYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCB0aHVzIHByZXZlbnRpbmcgc2hha2luZyBhbmRcbiAgIGZsaWNrZXJpbmcgYXJ0aWZhY3RzLiAqL1xuLkNvZGVNaXJyb3ItdnNjcm9sbGJhciwgLkNvZGVNaXJyb3ItaHNjcm9sbGJhciwgLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciwgLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogNjtcbiAgZGlzcGxheTogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbn1cbi5Db2RlTWlycm9yLXZzY3JvbGxiYXIge1xuICByaWdodDogMDsgdG9wOiAwO1xuICBvdmVyZmxvdy14OiBoaWRkZW47XG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcbn1cbi5Db2RlTWlycm9yLWhzY3JvbGxiYXIge1xuICBib3R0b206IDA7IGxlZnQ6IDA7XG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xufVxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciB7XG4gIHJpZ2h0OiAwOyBib3R0b206IDA7XG59XG4uQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcbiAgbGVmdDogMDsgYm90dG9tOiAwO1xufVxuXG4uQ29kZU1pcnJvci1ndXR0ZXJzIHtcbiAgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7XG4gIG1pbi1oZWlnaHQ6IDEwMCU7XG4gIHotaW5kZXg6IDM7XG59XG4uQ29kZU1pcnJvci1ndXR0ZXIge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgbWFyZ2luLWJvdHRvbTogLTUwcHg7XG59XG4uQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogNDtcbiAgYmFja2dyb3VuZDogbm9uZSAhaW1wb3J0YW50O1xuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcbn1cbi5Db2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7IGJvdHRvbTogMDtcbiAgei1pbmRleDogNDtcbn1cbi5Db2RlTWlycm9yLWd1dHRlci1lbHQge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGN1cnNvcjogZGVmYXVsdDtcbiAgei1pbmRleDogNDtcbn1cbi5Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyIDo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgfVxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIgOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50IH1cblxuLkNvZGVNaXJyb3ItbGluZXMge1xuICBjdXJzb3I6IHRleHQ7XG4gIG1pbi1oZWlnaHQ6IDFweDsgLyogcHJldmVudHMgY29sbGFwc2luZyBiZWZvcmUgZmlyc3QgZHJhdyAqL1xufVxuLkNvZGVNaXJyb3IgcHJlLkNvZGVNaXJyb3ItbGluZSxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUtbGlrZSB7XG4gIC8qIFJlc2V0IHNvbWUgc3R5bGVzIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIHBhZ2UgbWlnaHQgaGF2ZSBzZXQgKi9cbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwOyAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDA7IGJvcmRlci1yYWRpdXM6IDA7XG4gIGJvcmRlci13aWR0aDogMDtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuICBmb250LXNpemU6IGluaGVyaXQ7XG4gIG1hcmdpbjogMDtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgd29yZC13cmFwOiBub3JtYWw7XG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xuICBjb2xvcjogaW5oZXJpdDtcbiAgei1pbmRleDogMjtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBjb250ZXh0dWFsO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBjb250ZXh0dWFsO1xufVxuLkNvZGVNaXJyb3Itd3JhcCBwcmUuQ29kZU1pcnJvci1saW5lLFxuLkNvZGVNaXJyb3Itd3JhcCBwcmUuQ29kZU1pcnJvci1saW5lLWxpa2Uge1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd29yZC1icmVhazogbm9ybWFsO1xufVxuXG4uQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDsgcmlnaHQ6IDA7IHRvcDogMDsgYm90dG9tOiAwO1xuICB6LWluZGV4OiAwO1xufVxuXG4uQ29kZU1pcnJvci1saW5ld2lkZ2V0IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiAyO1xuICBwYWRkaW5nOiAwLjFweDsgLyogRm9yY2Ugd2lkZ2V0IG1hcmdpbnMgdG8gc3RheSBpbnNpZGUgb2YgdGhlIGNvbnRhaW5lciAqL1xufVxuXG4uQ29kZU1pcnJvci13aWRnZXQge31cblxuLkNvZGVNaXJyb3ItcnRsIHByZSB7IGRpcmVjdGlvbjogcnRsOyB9XG5cbi5Db2RlTWlycm9yLWNvZGUge1xuICBvdXRsaW5lOiBub25lO1xufVxuXG4vKiBGb3JjZSBjb250ZW50LWJveCBzaXppbmcgZm9yIHRoZSBlbGVtZW50cyB3aGVyZSB3ZSBleHBlY3QgaXQgKi9cbi5Db2RlTWlycm9yLXNjcm9sbCxcbi5Db2RlTWlycm9yLXNpemVyLFxuLkNvZGVNaXJyb3ItZ3V0dGVyLFxuLkNvZGVNaXJyb3ItZ3V0dGVycyxcbi5Db2RlTWlycm9yLWxpbmVudW1iZXIge1xuICAtbW96LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbn1cblxuLkNvZGVNaXJyb3ItbWVhc3VyZSB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xufVxuXG4uQ29kZU1pcnJvci1jdXJzb3Ige1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuLkNvZGVNaXJyb3ItbWVhc3VyZSBwcmUgeyBwb3NpdGlvbjogc3RhdGljOyB9XG5cbmRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xuICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgei1pbmRleDogMztcbn1cbmRpdi5Db2RlTWlycm9yLWRyYWdjdXJzb3JzIHtcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbn1cblxuLkNvZGVNaXJyb3ItZm9jdXNlZCBkaXYuQ29kZU1pcnJvci1jdXJzb3JzIHtcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbn1cblxuLkNvZGVNaXJyb3Itc2VsZWN0ZWQgeyBiYWNrZ3JvdW5kOiAjZDlkOWQ5OyB9XG4uQ29kZU1pcnJvci1mb2N1c2VkIC5Db2RlTWlycm9yLXNlbGVjdGVkIHsgYmFja2dyb3VuZDogI2Q3ZDRmMDsgfVxuLkNvZGVNaXJyb3ItY3Jvc3NoYWlyIHsgY3Vyc29yOiBjcm9zc2hhaXI7IH1cbi5Db2RlTWlycm9yLWxpbmU6OnNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46OnNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjpzZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiAjZDdkNGYwOyB9XG4uQ29kZU1pcnJvci1saW5lOjotbW96LXNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46Oi1tb3otc2VsZWN0aW9uLCAuQ29kZU1pcnJvci1saW5lID4gc3BhbiA+IHNwYW46Oi1tb3otc2VsZWN0aW9uIHsgYmFja2dyb3VuZDogI2Q3ZDRmMDsgfVxuXG4uY20tc2VhcmNoaW5nIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmYTtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMCwgLjQpO1xufVxuXG4vKiBVc2VkIHRvIGZvcmNlIGEgYm9yZGVyIG1vZGVsIGZvciBhIG5vZGUgKi9cbi5jbS1mb3JjZS1ib3JkZXIgeyBwYWRkaW5nLXJpZ2h0OiAuMXB4OyB9XG5cbkBtZWRpYSBwcmludCB7XG4gIC8qIEhpZGUgdGhlIGN1cnNvciB3aGVuIHByaW50aW5nICovXG4gIC5Db2RlTWlycm9yIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4vKiBTZWUgaXNzdWUgIzI5MDEgKi9cbi5jbS10YWItd3JhcC1oYWNrOmFmdGVyIHsgY29udGVudDogJyc7IH1cblxuLyogSGVscCB1c2VycyB1c2UgbWFya3NlbGVjdGlvbiB0byBzYWZlbHkgc3R5bGUgdGV4dCBiYWNrZ3JvdW5kICovXG5zcGFuLkNvZGVNaXJyb3Itc2VsZWN0ZWR0ZXh0IHsgYmFja2dyb3VuZDogbm9uZTsgfVxuXG5gO1xuIiwiXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdsaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjc3NgXG4vKiBCYXNlZCBvbiBTdWJsaW1lIFRleHQncyBNb25va2FpIHRoZW1lICovXG5cbi5jbS1zLW1vbm9rYWkuQ29kZU1pcnJvciB7IGJhY2tncm91bmQ6ICMyNzI4MjI7IGNvbG9yOiAjZjhmOGYyOyB9XG4uY20tcy1tb25va2FpIGRpdi5Db2RlTWlycm9yLXNlbGVjdGVkIHsgYmFja2dyb3VuZDogIzQ5NDgzRTsgfVxuLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1saW5lOjpzZWxlY3Rpb24sIC5jbS1zLW1vbm9rYWkgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46OnNlbGVjdGlvbiwgLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1saW5lID4gc3BhbiA+IHNwYW46OnNlbGVjdGlvbiB7IGJhY2tncm91bmQ6IHJnYmEoNzMsIDcyLCA2MiwgLjk5KTsgfVxuLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1saW5lOjotbW96LXNlbGVjdGlvbiwgLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1saW5lID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24sIC5jbS1zLW1vbm9rYWkgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQ6IHJnYmEoNzMsIDcyLCA2MiwgLjk5KTsgfVxuLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1ndXR0ZXJzIHsgYmFja2dyb3VuZDogIzI3MjgyMjsgYm9yZGVyLXJpZ2h0OiAwcHg7IH1cbi5jbS1zLW1vbm9rYWkgLkNvZGVNaXJyb3ItZ3V0dGVybWFya2VyIHsgY29sb3I6IHdoaXRlOyB9XG4uY20tcy1tb25va2FpIC5Db2RlTWlycm9yLWd1dHRlcm1hcmtlci1zdWJ0bGUgeyBjb2xvcjogI2QwZDBkMDsgfVxuLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1saW5lbnVtYmVyIHsgY29sb3I6ICNkMGQwZDA7IH1cbi5jbS1zLW1vbm9rYWkgLkNvZGVNaXJyb3ItY3Vyc29yIHsgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZjhmOGYwOyB9XG5cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1jb21tZW50IHsgY29sb3I6ICM3NTcxNWU7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1hdG9tIHsgY29sb3I6ICNhZTgxZmY7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1udW1iZXIgeyBjb2xvcjogI2FlODFmZjsgfVxuXG4uY20tcy1tb25va2FpIHNwYW4uY20tY29tbWVudC5jbS1hdHRyaWJ1dGUgeyBjb2xvcjogIzk3Yjc1NzsgfVxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLWNvbW1lbnQuY20tZGVmIHsgY29sb3I6ICNiYzkyNjI7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1jb21tZW50LmNtLXRhZyB7IGNvbG9yOiAjYmM2MjgzOyB9XG4uY20tcy1tb25va2FpIHNwYW4uY20tY29tbWVudC5jbS10eXBlIHsgY29sb3I6ICM1OTk4YTY7IH1cblxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLXByb3BlcnR5LCAuY20tcy1tb25va2FpIHNwYW4uY20tYXR0cmlidXRlIHsgY29sb3I6ICNhNmUyMmU7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1rZXl3b3JkIHsgY29sb3I6ICNmOTI2NzI7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1idWlsdGluIHsgY29sb3I6ICM2NmQ5ZWY7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1zdHJpbmcgeyBjb2xvcjogI2U2ZGI3NDsgfVxuXG4uY20tcy1tb25va2FpIHNwYW4uY20tdmFyaWFibGUgeyBjb2xvcjogI2Y4ZjhmMjsgfVxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLXZhcmlhYmxlLTIgeyBjb2xvcjogIzllZmZmZjsgfVxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLXZhcmlhYmxlLTMsIC5jbS1zLW1vbm9rYWkgc3Bhbi5jbS10eXBlIHsgY29sb3I6ICM2NmQ5ZWY7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1kZWYgeyBjb2xvcjogI2ZkOTcxZjsgfVxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLWJyYWNrZXQgeyBjb2xvcjogI2Y4ZjhmMjsgfVxuLmNtLXMtbW9ub2thaSBzcGFuLmNtLXRhZyB7IGNvbG9yOiAjZjkyNjcyOyB9XG4uY20tcy1tb25va2FpIHNwYW4uY20taGVhZGVyIHsgY29sb3I6ICNhZTgxZmY7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1saW5rIHsgY29sb3I6ICNhZTgxZmY7IH1cbi5jbS1zLW1vbm9rYWkgc3Bhbi5jbS1lcnJvciB7IGJhY2tncm91bmQ6ICNmOTI2NzI7IGNvbG9yOiAjZjhmOGYwOyB9XG5cbi5jbS1zLW1vbm9rYWkgLkNvZGVNaXJyb3ItYWN0aXZlbGluZS1iYWNrZ3JvdW5kIHsgYmFja2dyb3VuZDogIzM3MzgzMTsgfVxuLmNtLXMtbW9ub2thaSAuQ29kZU1pcnJvci1tYXRjaGluZ2JyYWNrZXQge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XG59XG5cbmA7XG4iLCJcbmltcG9ydCB7IGNzcyB9IGZyb20gJ2xpdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNzc2Bcbi5Db2RlTWlycm9yLWRpYWxvZyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDsgcmlnaHQ6IDA7XG4gIGJhY2tncm91bmQ6IGluaGVyaXQ7XG4gIHotaW5kZXg6IDE1O1xuICBwYWRkaW5nOiAuMWVtIC44ZW07XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGNvbG9yOiBpbmhlcml0O1xufVxuXG4uQ29kZU1pcnJvci1kaWFsb2ctdG9wIHtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XG4gIHRvcDogMDtcbn1cblxuLkNvZGVNaXJyb3ItZGlhbG9nLWJvdHRvbSB7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xuICBib3R0b206IDA7XG59XG5cbi5Db2RlTWlycm9yLWRpYWxvZyBpbnB1dCB7XG4gIGJvcmRlcjogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIHdpZHRoOiAyMGVtO1xuICBjb2xvcjogaW5oZXJpdDtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbn1cblxuLkNvZGVNaXJyb3ItZGlhbG9nIGJ1dHRvbiB7XG4gIGZvbnQtc2l6ZTogNzAlO1xufVxuXG5gO1xuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCwgY3NzIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IHRoZW1lLCBmb250U2l6ZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcbmltcG9ydCAnLi9zYy1idXR0b24uanMnO1xuXG5pbXBvcnQgQ29kZU1pcnJvciBmcm9tICdjb2RlbWlycm9yJztcbmltcG9ydCAnY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdC5qcyc7XG5pbXBvcnQgJ2NvZGVtaXJyb3Iva2V5bWFwL3N1YmxpbWUuanMnO1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2guanMnO1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMnO1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9qdW1wLXRvLWxpbmUuanMnO1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL2RpYWxvZy9kaWFsb2cuanMnO1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL2NvbW1lbnQvY29tbWVudC5qcyc7XG5cbi8vIGNzc1xuaW1wb3J0IGNtU3R5bGVzIGZyb20gJy4vdmVuZG9ycy9jb2RlbWlycm9yLWNzcy5qcyc7XG5pbXBvcnQgbW9ub2thaVRoZW1lIGZyb20gJy4vdmVuZG9ycy90aGVtZS1tb25va2FpLWNzcy5qcyc7XG5pbXBvcnQgYWRkb25EaWFsb2cgZnJvbSAnLi92ZW5kb3JzL2FkZG9uLWRpYWxvZy1jc3MuanMnO1xuXG5cbi8vIGdsb2JhbFRoaXMuSlNISU5UID0gSlNISU5UO1xuXG5Db2RlTWlycm9yLmNvbW1hbmRzLnNhdmUgPSBmdW5jdGlvbihjbSkge1xuICBjbS5fc2NDb21wb25lbnQudmFsdWUgPSBjbS5nZXRWYWx1ZSgpO1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICBkZXRhaWw6IHsgdmFsdWU6IGNtLl9zY0NvbXBvbmVudC52YWx1ZSB9LFxuICB9KTtcblxuICBjbS5fc2NDb21wb25lbnQuY2xlYW5Eb2MoKTtcbiAgY20uX3NjQ29tcG9uZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblxuY2xhc3MgU2NFZGl0b3IgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBmb250U2l6ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGF0dHJpYnV0ZTogJ2ZvbnQtc2l6ZScsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgLy8gdGhpcyBpcyB2ZXJ5IHVnbHlcbiAgICAvLyBAdG9kbyAtIGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gaW1wb3IgY29kZSBtaXJyb3IncyBjc3MuLi5cbiAgICByZXR1cm4gY3NzYFxuICAgICAgOmhvc3Qge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gZGl2IHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIGJvcmRlci1sZWZ0OiAycHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZm9udC1zaXplOiAke2ZvbnRTaXplfTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiBkaXYuZGlydHkge1xuICAgICAgICBib3JkZXItbGVmdDogMnB4IHNvbGlkICR7dGhlbWVbJy0tY29sb3Itc2Vjb25kYXJ5LTMnXX07XG4gICAgICB9XG5cbiAgICAgIC8qIGhpZ2hsaWdodCBmb2N1c2VkIGVkaXRvciAqL1xuICAgICAgLkNvZGVNaXJyb3IgeyBvcGFjaXR5OiAwLjk7IH1cbiAgICAgIC5Db2RlTWlycm9yLkNvZGVNaXJyb3ItZm9jdXNlZCB7IG9wYWNpdHk6IDE7IH1cblxuICAgICAgJHtjbVN0eWxlc31cbiAgICAgICR7bW9ub2thaVRoZW1lfVxuICAgICAgJHthZGRvbkRpYWxvZ31cblxuICAgICAgc2MtYnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMnB4O1xuICAgICAgICBib3R0b206IDJweDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6ICcnO1xuXG4gICAgaWYgKHRoaXMuY29kZU1pcnJvcikge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5jb2RlTWlycm9yLmdldEN1cnNvcigpO1xuICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRDdXJzb3IocG9zKTtcbiAgICAgIHRoaXMuY2xlYW5Eb2MoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKSwgMSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fZWRpdG9yV2lkdGggPSB0aGlzLl93aWR0aCAtIDM7XG5cbiAgICBpZiAodGhpcy5jb2RlTWlycm9yKSB7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy5fZWRpdG9ySGVpZ2h0ID0gdGhpcy5faGVpZ2h0IC0gMjtcblxuICAgIGlmICh0aGlzLmNvZGVNaXJyb3IpIHtcbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG5cbiAgICB0aGlzLndpZHRoID0gMzAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMjAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMTtcbiAgICB0aGlzLnZhbHVlID0gYGA7XG5cbiAgICAvKiogcHJpdmF0ZSAqL1xuICAgIHRoaXMuJGNvbnRhaW5lciA9IG51bGw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuY29kZU1pcnJvcikge1xuICAgICAgLy8gQG5vdGUgLSBhIGJpdCBoYXJkY29yZSBidXQgbW9yZSBlZmZpY2llbnQgdGhhbiBpbiBzZXR0ZXJzXG4gICAgICAvLyBAdG9kbyAtIGRlYm91bmNlXG4gICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0U2l6ZSh0aGlzLl9lZGl0b3JXaWR0aCwgdGhpcy5fZWRpdG9ySGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXZcbiAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICB3aWR0aDogJHt0aGlzLl93aWR0aH1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5faGVpZ2h0fXB4O1xuICAgICAgICBcIlxuICAgICAgICBAa2V5ZG93bj1cIiR7dGhpcy5vbktleWRvd259XCJcbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzPVwiY29kZW1pcnJvclwiXG4gICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgIHdpZHRoOiAke3RoaXMuX2VkaXRvcldpZHRofXB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuX2VkaXRvckhlaWdodH1weDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogJHt0aGlzLmZvbnRTaXplfXB4O1xuICAgICAgICAgIFwiXG4gICAgICAgID48L2Rpdj5cbiAgICAgICAgPHNjLWJ1dHRvblxuICAgICAgICAgIHRleHQ9XCJzYXZlXCJcbiAgICAgICAgICB3aWR0aD1cIjEyMFwiXG4gICAgICAgICAgQGlucHV0PVwiJHtlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XCJcbiAgICAgICAgICBAcmVsZWFzZT1cIiR7dGhpcy5zYXZlfVwiXG4gICAgICAgID48L3NjLWJ1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBvbktleWRvd24oZSkge1xuICAgIC8vIG1hbnVhbGx5IGRvIGNvbW1lbnQgYmVjYXVzZSBvcGVucyBIZWxwIG1lbnUgb3RoZXJ3aXNlLi4uXG4gICAgaWYgKGUubWV0YUtleSAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChlLmtleSA9PT0gJy8nKSB7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci50b2dnbGVDb21tZW50KCk7XG4gICAgICB9XG4gICAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyBmb3Igem9vbSwgdG9vIGRlZXAgaW4gdGhlIHN5c3RlbVxuICAgIH1cbiAgfVxuXG4gIC8vIG5lZWQgdG8gY29weSBzYW1lIGxvZ2ljIGFzIGZvciBjbWQgKyBzIC8gY3RybCArIHNcbiAgc2F2ZShlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKTtcblxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgdmFsdWU6IHRoaXMuX3ZhbHVlIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmNsZWFuRG9jKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIGZpcnN0VXBkYXRlZCgpIHtcbiAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgdGhpcy4kY29kZUNvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYgLmNvZGVtaXJyb3InKTtcblxuICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IodGhpcy4kY29kZUNvbnRhaW5lciwge1xuICAgICAgdmFsdWU6IHRoaXMuX3ZhbHVlLCAvLyBpbml0IHcvIG1hcmt1cCB2YWx1ZSBpZiBhbnlcbiAgICAgIG1vZGU6ICdqYXZhc2NyaXB0JyxcbiAgICAgIHRoZW1lOiAnbW9ub2thaScsXG4gICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgIHRhYlNpemU6IDIsXG4gICAgICBrZXlNYXA6ICdzdWJsaW1lJyxcbiAgICB9KTtcblxuICAgIC8vIG1vbmtleSBwYXRjaCBjb21wb25lbnQgaW4gY29kZU1pcnJvciB0byBwcm9wYWdhdGUgc2F2ZSBmcm9tIGtleWJvYXJkXG4gICAgdGhpcy5jb2RlTWlycm9yLl9zY0NvbXBvbmVudCA9IHRoaXM7XG5cbiAgICAvLyBzZXQgdGhlIHNpemUgb2YgdGhlIGVkaXRvciB0byBtYXRjaCBjb250YWluZXJcbiAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0U2l6ZSh0aGlzLl9lZGl0b3JXaWR0aCwgdGhpcy5fZWRpdG9ySGVpZ2h0KTtcblxuICAgIC8vIHJlcGxhY2UgdGFicyB3aXRoIDIgc3BhY2VzXG4gICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbignZXh0cmFLZXlzJywge1xuICAgICAgVGFiOiBmdW5jdGlvbihjbSkge1xuICAgICAgICBsZXQgc3BhY2VzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY20uZ2V0T3B0aW9uKCdpbmRlbnRVbml0Jyk7IGkrKykge1xuICAgICAgICAgIHNwYWNlcyArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHNwYWNlcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0cmFjayBpZiBkb2N1bWVudCBpcyBjbGVhblxuICAgIHRoaXMuY29kZU1pcnJvci5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNvZGVNaXJyb3IuZ2V0RG9jKCkuaXNDbGVhbigpKSB7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkaXJ0eScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYW5Eb2MoKSB7XG4gICAgdGhpcy5jb2RlTWlycm9yLmdldERvYygpLm1hcmtDbGVhbigpO1xuICAgIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdkaXJ0eScpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc2MtZWRpdG9yJywgU2NFZGl0b3IpO1xuXG5leHBvcnQgZGVmYXVsdCBTY0VkaXRvcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmNvbnN0IGRpcmVjdGl2ZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBCcmFuZHMgYSBmdW5jdGlvbiBhcyBhIGRpcmVjdGl2ZSBmYWN0b3J5IGZ1bmN0aW9uIHNvIHRoYXQgbGl0LWh0bWwgd2lsbCBjYWxsXG4gKiB0aGUgZnVuY3Rpb24gZHVyaW5nIHRlbXBsYXRlIHJlbmRlcmluZywgcmF0aGVyIHRoYW4gcGFzc2luZyBhcyBhIHZhbHVlLlxuICpcbiAqIEEgX2RpcmVjdGl2ZV8gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgUGFydCBhcyBhbiBhcmd1bWVudC4gSXQgaGFzIHRoZVxuICogc2lnbmF0dXJlOiBgKHBhcnQ6IFBhcnQpID0+IHZvaWRgLlxuICpcbiAqIEEgZGlyZWN0aXZlIF9mYWN0b3J5XyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXJndW1lbnRzIGZvciBkYXRhIGFuZFxuICogY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucyBhIGRpcmVjdGl2ZS4gVXNlcnMgb2YgZGlyZWN0aXZlIHVzdWFsbHkgcmVmZXIgdG9cbiAqIHRoZSBkaXJlY3RpdmUgZmFjdG9yeSBhcyB0aGUgZGlyZWN0aXZlLiBGb3IgZXhhbXBsZSwgXCJUaGUgcmVwZWF0IGRpcmVjdGl2ZVwiLlxuICpcbiAqIFVzdWFsbHkgYSB0ZW1wbGF0ZSBhdXRob3Igd2lsbCBpbnZva2UgYSBkaXJlY3RpdmUgZmFjdG9yeSBpbiB0aGVpciB0ZW1wbGF0ZVxuICogd2l0aCByZWxldmFudCBhcmd1bWVudHMsIHdoaWNoIHdpbGwgdGhlbiByZXR1cm4gYSBkaXJlY3RpdmUgZnVuY3Rpb24uXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgdXNpbmcgdGhlIGByZXBlYXQoKWAgZGlyZWN0aXZlIGZhY3RvcnkgdGhhdCB0YWtlcyBhblxuICogYXJyYXkgYW5kIGEgZnVuY3Rpb24gdG8gcmVuZGVyIGFuIGl0ZW06XG4gKlxuICogYGBganNcbiAqIGh0bWxgPHVsPjwke3JlcGVhdChpdGVtcywgKGl0ZW0pID0+IGh0bWxgPGxpPiR7aXRlbX08L2xpPmApfTwvdWw+YFxuICogYGBgXG4gKlxuICogV2hlbiBgcmVwZWF0YCBpcyBpbnZva2VkLCBpdCByZXR1cm5zIGEgZGlyZWN0aXZlIGZ1bmN0aW9uIHRoYXQgY2xvc2VzIG92ZXJcbiAqIGBpdGVtc2AgYW5kIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi4gV2hlbiB0aGUgb3V0ZXIgdGVtcGxhdGUgaXMgcmVuZGVyZWQsIHRoZVxuICogcmV0dXJuIGRpcmVjdGl2ZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgUGFydCBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKiBgcmVwZWF0YCB0aGVuIHBlcmZvcm1zIGl0J3MgY3VzdG9tIGxvZ2ljIHRvIHJlbmRlciBtdWx0aXBsZSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0gZiBUaGUgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24uIE11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYVxuICogZnVuY3Rpb24gb2YgdGhlIHNpZ25hdHVyZSBgKHBhcnQ6IFBhcnQpID0+IHZvaWRgLiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbFxuICogYmUgY2FsbGVkIHdpdGggdGhlIHBhcnQgb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHtkaXJlY3RpdmUsIGh0bWx9IGZyb20gJ2xpdC1odG1sJztcbiAqXG4gKiBjb25zdCBpbW11dGFibGUgPSBkaXJlY3RpdmUoKHYpID0+IChwYXJ0KSA9PiB7XG4gKiAgIGlmIChwYXJ0LnZhbHVlICE9PSB2KSB7XG4gKiAgICAgcGFydC5zZXRWYWx1ZSh2KVxuICogICB9XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGNvbnN0IGRpcmVjdGl2ZSA9IChmKSA9PiAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBkID0gZiguLi5hcmdzKTtcbiAgICBkaXJlY3RpdmVzLnNldChkLCB0cnVlKTtcbiAgICByZXR1cm4gZDtcbn0pO1xuZXhwb3J0IGNvbnN0IGlzRGlyZWN0aXZlID0gKG8pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbicgJiYgZGlyZWN0aXZlcy5oYXMobyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogVHJ1ZSBpZiB0aGUgY3VzdG9tIGVsZW1lbnRzIHBvbHlmaWxsIGlzIGluIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ0VQb2x5ZmlsbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzICE9IG51bGwgJiZcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayAhPT1cbiAgICAgICAgdW5kZWZpbmVkO1xuLyoqXG4gKiBSZXBhcmVudHMgbm9kZXMsIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCAoaW5jbHVzaXZlKSB0byBgZW5kYCAoZXhjbHVzaXZlKSxcbiAqIGludG8gYW5vdGhlciBjb250YWluZXIgKGNvdWxkIGJlIHRoZSBzYW1lIGNvbnRhaW5lciksIGJlZm9yZSBgYmVmb3JlYC4gSWZcbiAqIGBiZWZvcmVgIGlzIG51bGwsIGl0IGFwcGVuZHMgdGhlIG5vZGVzIHRvIHRoZSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBhcmVudE5vZGVzID0gKGNvbnRhaW5lciwgc3RhcnQsIGVuZCA9IG51bGwsIGJlZm9yZSA9IG51bGwpID0+IHtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBjb25zdCBuID0gc3RhcnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3RhcnQsIGJlZm9yZSk7XG4gICAgICAgIHN0YXJ0ID0gbjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZW1vdmVzIG5vZGVzLCBzdGFydGluZyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGAgKGV4Y2x1c2l2ZSksIGZyb21cbiAqIGBjb250YWluZXJgLlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlTm9kZXMgPSAoY29udGFpbmVyLCBzdGFydCwgZW5kID0gbnVsbCkgPT4ge1xuICAgIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzdGFydC5uZXh0U2libGluZztcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBuO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBBIHNlbnRpbmVsIHZhbHVlIHRoYXQgc2lnbmFscyB0aGF0IGEgdmFsdWUgd2FzIGhhbmRsZWQgYnkgYSBkaXJlY3RpdmUgYW5kXG4gKiBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vQ2hhbmdlID0ge307XG4vKipcbiAqIEEgc2VudGluZWwgdmFsdWUgdGhhdCBzaWduYWxzIGEgTm9kZVBhcnQgdG8gZnVsbHkgY2xlYXIgaXRzIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBub3RoaW5nID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgd2l0aCBlbWJlZGRlZCB1bmlxdWUga2V5IHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoXG4gKiBwb3NzaWJsZSB0ZXh0IGluIHRlbXBsYXRlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtlciA9IGB7e2xpdC0ke1N0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKX19fWA7XG4vKipcbiAqIEFuIGV4cHJlc3Npb24gbWFya2VyIHVzZWQgdGV4dC1wb3NpdGlvbnMsIG11bHRpLWJpbmRpbmcgYXR0cmlidXRlcywgYW5kXG4gKiBhdHRyaWJ1dGVzIHdpdGggbWFya3VwLWxpa2UgdGV4dCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBub2RlTWFya2VyID0gYDwhLS0ke21hcmtlcn0tLT5gO1xuZXhwb3J0IGNvbnN0IG1hcmtlclJlZ2V4ID0gbmV3IFJlZ0V4cChgJHttYXJrZXJ9fCR7bm9kZU1hcmtlcn1gKTtcbi8qKlxuICogU3VmZml4IGFwcGVuZGVkIHRvIGFsbCBib3VuZCBhdHRyaWJ1dGUgbmFtZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCA9ICckbGl0JCc7XG4vKipcbiAqIEFuIHVwZGF0YWJsZSBUZW1wbGF0ZSB0aGF0IHRyYWNrcyB0aGUgbG9jYXRpb24gb2YgZHluYW1pYyBwYXJ0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmUgbnVsbFxuICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQuY29udGVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBsYXN0IGluZGV4IGFzc29jaWF0ZWQgd2l0aCBhIHBhcnQuIFdlIHRyeSB0byBkZWxldGVcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnkgbm9kZXMsIGJ1dCB3ZSBuZXZlciB3YW50IHRvIGFzc29jaWF0ZSB0d28gZGlmZmVyZW50IHBhcnRzXG4gICAgICAgIC8vIHRvIHRoZSBzYW1lIGluZGV4LiBUaGV5IG11c3QgaGF2ZSBhIGNvbnN0YW50IG5vZGUgYmV0d2Vlbi5cbiAgICAgICAgbGV0IGxhc3RQYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgdmFsdWVzOiB7IGxlbmd0aCB9IH0gPSByZXN1bHQ7XG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIHRoZSBjb250ZW50IGluc2lkZSBhIG5lc3RlZCB0ZW1wbGF0ZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugc3RpbGwgaGF2ZSBwYXJ0cyAodGhlIG91dGVyIGZvci1sb29wKSwgd2Uga25vdzpcbiAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgdGVtcGxhdGUgaW4gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgd2Fsa2VyIHdpbGwgZmluZCBhIG5leHROb2RlIG91dHNpZGUgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmFtZWROb2RlTWFwLFxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSByZXR1cm5lZCBpbiBkb2N1bWVudCBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFydGljdWxhciwgRWRnZS9JRSBjYW4gcmV0dXJuIHRoZW0gb3V0IG9mIG9yZGVyLCBzbyB3ZSBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGEgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBwYXJ0IGluZGV4IGFuZCBhdHRyaWJ1dGUgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aChhdHRyaWJ1dGVzW2ldLm5hbWUsIGJvdW5kQXR0cmlidXRlU3VmZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRlbXBsYXRlIGxpdGVyYWwgc2VjdGlvbiBsZWFkaW5nIHVwIHRvIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiBpbiB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nRm9yUGFydCA9IHN0cmluZ3NbcGFydEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHN0cmluZ0ZvclBhcnQpWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBib3VuZCBhdHRyaWJ1dGVzIGhhdmUgaGFkIGEgc3VmZml4IGFkZGVkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZVJlc3VsdCNnZXRIVE1MIHRvIG9wdCBvdXQgb2Ygc3BlY2lhbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsaW5nLiBUbyBsb29rIHVwIHRoZSBhdHRyaWJ1dGUgdmFsdWUgd2UgYWxzbyBuZWVkIHRvIGFkZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN1ZmZpeC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZUxvb2t1cE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkgKyBib3VuZEF0dHJpYnV0ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTG9va3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVMb29rdXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY3MgPSBhdHRyaWJ1dGVWYWx1ZS5zcGxpdChtYXJrZXJSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnYXR0cmlidXRlJywgaW5kZXgsIG5hbWUsIHN0cmluZ3M6IHN0YXRpY3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gc3RhdGljcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMgLyogTm9kZS5URVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmluZGV4T2YobWFya2VyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5ncyA9IGRhdGEuc3BsaXQobWFya2VyUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHRleHQgbm9kZSBmb3IgZWFjaCBsaXRlcmFsIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugbm9kZXMgYXJlIGFsc28gdXNlZCBhcyB0aGUgbWFya2VycyBmb3Igbm9kZSBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gY3JlYXRlTWFya2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgZW5kc1dpdGgobWF0Y2hbMl0sIGJvdW5kQXR0cmlidXRlU3VmZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBtYXRjaFsxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXS5zbGljZSgwLCAtYm91bmRBdHRyaWJ1dGVTdWZmaXgubGVuZ3RoKSArIG1hdGNoWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoaW5zZXJ0LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXg6ICsraW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyB0ZXh0LCB3ZSBtdXN0IGluc2VydCBhIGNvbW1lbnQgdG8gbWFyayBvdXIgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGNhbiB0cnVzdCBpdCB3aWxsIHN0aWNrIGFyb3VuZCBhZnRlciBjbG9uaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nc1tsYXN0SW5kZXhdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSBzdHJpbmdzW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHBhcnQgZm9yIGVhY2ggbWF0Y2ggZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIE5vZGUuQ09NTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gbWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbmV3IG1hcmtlciBub2RlIHRvIGJlIHRoZSBzdGFydE5vZGUgb2YgdGhlIFBhcnQgaWYgYW55IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgICAgIC8vICAqIFdlIGRvbid0IGhhdmUgYSBwcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gICogVGhlIHByZXZpb3VzU2libGluZyBpcyBhbHJlYWR5IHRoZSBzdGFydCBvZiBhIHByZXZpb3VzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09PSBudWxsIHx8IGluZGV4ID09PSBsYXN0UGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbmV4dFNpYmxpbmcsIGtlZXAgdGhpcyBub2RlIHNvIHdlIGhhdmUgYW4gZW5kLlxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBjYW4gcmVtb3ZlIGl0IHRvIHNhdmUgZnV0dXJlIGNvc3RzLlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpID0gbm9kZS5kYXRhLmluZGV4T2YobWFya2VyLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudCBub2RlIGhhcyBhIGJpbmRpbmcgbWFya2VyIGluc2lkZSwgbWFrZSBhbiBpbmFjdGl2ZSBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmluZGluZyB3b24ndCB3b3JrLCBidXQgc3Vic2VxdWVudCBiaW5kaW5ncyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIChqdXN0aW5mYWduYW5pKTogY29uc2lkZXIgd2hldGhlciBpdCdzIGV2ZW4gd29ydGggaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYmluZGluZ3MgaW4gY29tbWVudHMgd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleDogLTEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGV4dCBiaW5kaW5nIG5vZGVzIGFmdGVyIHRoZSB3YWxrIHRvIG5vdCBkaXN0dXJiIHRoZSBUcmVlV2Fsa2VyXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHN1ZmZpeCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGg7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgc3RyLnNsaWNlKGluZGV4KSA9PT0gc3VmZml4O1xufTtcbmV4cG9ydCBjb25zdCBpc1RlbXBsYXRlUGFydEFjdGl2ZSA9IChwYXJ0KSA9PiBwYXJ0LmluZGV4ICE9PSAtMTtcbi8vIEFsbG93cyBgZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJylgIHRvIGJlIHJlbmFtZWQgZm9yIGFcbi8vIHNtYWxsIG1hbnVhbCBzaXplLXNhdmluZ3MuXG5leHBvcnQgY29uc3QgY3JlYXRlTWFya2VyID0gKCkgPT4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4vKipcbiAqIFRoaXMgcmVnZXggZXh0cmFjdHMgdGhlIGF0dHJpYnV0ZSBuYW1lIHByZWNlZGluZyBhbiBhdHRyaWJ1dGUtcG9zaXRpb25cbiAqIGV4cHJlc3Npb24uIEl0IGRvZXMgdGhpcyBieSBtYXRjaGluZyB0aGUgc3ludGF4IGFsbG93ZWQgZm9yIGF0dHJpYnV0ZXNcbiAqIGFnYWluc3QgdGhlIHN0cmluZyBsaXRlcmFsIGRpcmVjdGx5IHByZWNlZGluZyB0aGUgZXhwcmVzc2lvbiwgYXNzdW1pbmcgdGhhdFxuICogdGhlIGV4cHJlc3Npb24gaXMgaW4gYW4gYXR0cmlidXRlLXZhbHVlIHBvc2l0aW9uLlxuICpcbiAqIFNlZSBhdHRyaWJ1dGVzIGluIHRoZSBIVE1MIHNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudHMtYXR0cmlidXRlc1xuICpcbiAqIFwiIFxceDA5XFx4MGFcXHgwY1xceDBkXCIgYXJlIEhUTUwgc3BhY2UgY2hhcmFjdGVyczpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3NwYWNlLWNoYXJhY3RlcnNcbiAqXG4gKiBcIlxcMC1cXHgxRlxceDdGLVxceDlGXCIgYXJlIFVuaWNvZGUgY29udHJvbCBjaGFyYWN0ZXJzLCB3aGljaCBpbmNsdWRlcyBldmVyeVxuICogc3BhY2UgY2hhcmFjdGVyIGV4Y2VwdCBcIiBcIi5cbiAqXG4gKiBTbyBhbiBhdHRyaWJ1dGUgaXM6XG4gKiAgKiBUaGUgbmFtZTogYW55IGNoYXJhY3RlciBleGNlcHQgYSBjb250cm9sIGNoYXJhY3Rlciwgc3BhY2UgY2hhcmFjdGVyLCAoJyksXG4gKiAgICAoXCIpLCBcIj5cIiwgXCI9XCIsIG9yIFwiL1wiXG4gKiAgKiBGb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVyc1xuICogICogRm9sbG93ZWQgYnkgXCI9XCJcbiAqICAqIEZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzXG4gKiAgKiBGb2xsb3dlZCBieTpcbiAqICAgICogQW55IGNoYXJhY3RlciBleGNlcHQgc3BhY2UsICgnKSwgKFwiKSwgXCI8XCIsIFwiPlwiLCBcIj1cIiwgKGApLCBvclxuICogICAgKiAoXCIpIHRoZW4gYW55IG5vbi0oXCIpLCBvclxuICogICAgKiAoJykgdGhlbiBhbnkgbm9uLSgnKVxuICovXG5leHBvcnQgY29uc3QgbGFzdEF0dHJpYnV0ZU5hbWVSZWdleCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbi8oWyBcXHgwOVxceDBhXFx4MGNcXHgwZF0pKFteXFwwLVxceDFGXFx4N0YtXFx4OUYgXCInPj0vXSspKFsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKj1bIFxceDA5XFx4MGFcXHgwY1xceDBkXSooPzpbXiBcXHgwOVxceDBhXFx4MGNcXHgwZFwiJ2A8Pj1dKnxcIlteXCJdKnwnW14nXSopKSQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgaXNDRVBvbHlmaWxsIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgaXNUZW1wbGF0ZVBhcnRBY3RpdmUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgYSBgVGVtcGxhdGVgIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gYW5kIHVwZGF0ZWRcbiAqIHdpdGggbmV3IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBwcm9jZXNzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fX3BhcnRzID0gW107XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fX3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFydC5zZXRWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNvbW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jbG9uZSgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgbnVtYmVyIG9mIHN0ZXBzIGluIHRoZSBsaWZlY3ljbGUgb2YgYSB0ZW1wbGF0ZSBpbnN0YW5jZSdzXG4gICAgICAgIC8vIERPTSBmcmFnbWVudDpcbiAgICAgICAgLy8gIDEuIENsb25lIC0gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcmFnbWVudFxuICAgICAgICAvLyAgMi4gQWRvcHQgLSBhZG9wdCBpbnRvIHRoZSBtYWluIGRvY3VtZW50XG4gICAgICAgIC8vICAzLiBQcm9jZXNzIC0gZmluZCBwYXJ0IG1hcmtlcnMgYW5kIGNyZWF0ZSBwYXJ0c1xuICAgICAgICAvLyAgNC4gVXBncmFkZSAtIHVwZ3JhZGUgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIC8vICA1LiBVcGRhdGUgLSBzZXQgbm9kZSwgYXR0cmlidXRlLCBwcm9wZXJ0eSwgZXRjLiwgdmFsdWVzXG4gICAgICAgIC8vICA2LiBDb25uZWN0IC0gY29ubmVjdCB0byB0aGUgZG9jdW1lbnQuIE9wdGlvbmFsIGFuZCBvdXRzaWRlIG9mIHRoaXNcbiAgICAgICAgLy8gICAgIG1ldGhvZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgaGF2ZSBhIGZldyBjb25zdHJhaW50cyBvbiB0aGUgb3JkZXJpbmcgb2YgdGhlc2Ugc3RlcHM6XG4gICAgICAgIC8vICAqIFdlIG5lZWQgdG8gdXBncmFkZSBiZWZvcmUgdXBkYXRpbmcsIHNvIHRoYXQgcHJvcGVydHkgdmFsdWVzIHdpbGwgcGFzc1xuICAgICAgICAvLyAgICB0aHJvdWdoIGFueSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgICAgICAvLyAgKiBXZSB3b3VsZCBsaWtlIHRvIHByb2Nlc3MgYmVmb3JlIHVwZ3JhZGluZyBzbyB0aGF0IHdlJ3JlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gICAgY2xvbmVkIGZyYWdtZW50IGlzIGluZXJ0IGFuZCBub3QgZGlzdHVyYmVkIGJ5IHNlbGYtbW9kaWZ5aW5nIERPTS5cbiAgICAgICAgLy8gICogV2Ugd2FudCBjdXN0b20gZWxlbWVudHMgdG8gdXBncmFkZSBldmVuIGluIGRpc2Nvbm5lY3RlZCBmcmFnbWVudHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHRoZXNlIGNvbnN0cmFpbnRzLCB3aXRoIGZ1bGwgY3VzdG9tIGVsZW1lbnRzIHN1cHBvcnQgd2Ugd291bGRcbiAgICAgICAgLy8gcHJlZmVyIHRoZSBvcmRlcjogQ2xvbmUsIFByb2Nlc3MsIEFkb3B0LCBVcGdyYWRlLCBVcGRhdGUsIENvbm5lY3RcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQnV0IFNhZmFyaSBkb2VzIG5vdCBpbXBsZW1lbnQgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5I3VwZ3JhZGUsIHNvIHdlXG4gICAgICAgIC8vIGNhbiBub3QgaW1wbGVtZW50IHRoYXQgb3JkZXIgYW5kIHN0aWxsIGhhdmUgdXBncmFkZS1iZWZvcmUtdXBkYXRlIGFuZFxuICAgICAgICAvLyB1cGdyYWRlIGRpc2Nvbm5lY3RlZCBmcmFnbWVudHMuIFNvIHdlIGluc3RlYWQgc2FjcmlmaWNlIHRoZVxuICAgICAgICAvLyBwcm9jZXNzLWJlZm9yZS11cGdyYWRlIGNvbnN0cmFpbnQsIHNpbmNlIGluIEN1c3RvbSBFbGVtZW50cyB2MSBlbGVtZW50c1xuICAgICAgICAvLyBtdXN0IG5vdCBtb2RpZnkgdGhlaXIgbGlnaHQgRE9NIGluIHRoZSBjb25zdHJ1Y3Rvci4gV2Ugc3RpbGwgaGF2ZSBpc3N1ZXNcbiAgICAgICAgLy8gd2hlbiBjby1leGlzdGluZyB3aXRoIENFdjAgZWxlbWVudHMgbGlrZSBQb2x5bWVyIDEsIGFuZCB3aXRoIHBvbHlmaWxsc1xuICAgICAgICAvLyB0aGF0IGRvbid0IHN0cmljdGx5IGFkaGVyZSB0byB0aGUgbm8tbW9kaWZpY2F0aW9uIHJ1bGUgYmVjYXVzZSBzaGFkb3dcbiAgICAgICAgLy8gRE9NLCB3aGljaCBtYXkgYmUgY3JlYXRlZCBpbiB0aGUgY29uc3RydWN0b3IsIGlzIGVtdWxhdGVkIGJ5IGJlaW5nIHBsYWNlZFxuICAgICAgICAvLyBpbiB0aGUgbGlnaHQgRE9NLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcmVzdWx0aW5nIG9yZGVyIGlzIG9uIG5hdGl2ZSBpczogQ2xvbmUsIEFkb3B0LCBVcGdyYWRlLCBQcm9jZXNzLFxuICAgICAgICAvLyBVcGRhdGUsIENvbm5lY3QuIGRvY3VtZW50LmltcG9ydE5vZGUoKSBwZXJmb3JtcyBDbG9uZSwgQWRvcHQsIGFuZCBVcGdyYWRlXG4gICAgICAgIC8vIGluIG9uZSBzdGVwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgQ3VzdG9tIEVsZW1lbnRzIHYxIHBvbHlmaWxsIHN1cHBvcnRzIHVwZ3JhZGUoKSwgc28gdGhlIG9yZGVyIHdoZW5cbiAgICAgICAgLy8gcG9seWZpbGxlZCBpcyB0aGUgbW9yZSBpZGVhbDogQ2xvbmUsIFByb2Nlc3MsIEFkb3B0LCBVcGdyYWRlLCBVcGRhdGUsXG4gICAgICAgIC8vIENvbm5lY3QuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gaXNDRVBvbHlmaWxsID9cbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSA6XG4gICAgICAgICAgICBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnRlbXBsYXRlLnBhcnRzO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihmcmFnbWVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBhcnQ7XG4gICAgICAgIGxldCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIG5vZGVzIGFuZCBwYXJ0cyBvZiBhIHRlbXBsYXRlXG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc1RlbXBsYXRlUGFydEFjdGl2ZShwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9ncmVzcyB0aGUgdHJlZSB3YWxrZXIgdW50aWwgd2UgZmluZCBvdXIgbmV4dCBwYXJ0J3Mgbm9kZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBtdWx0aXBsZSBwYXJ0cyBtYXkgc2hhcmUgdGhlIHNhbWUgbm9kZSAoYXR0cmlidXRlIHBhcnRzXG4gICAgICAgICAgICAvLyBvbiBhIHNpbmdsZSBlbGVtZW50KSwgc28gdGhpcyBsb29wIG1heSBub3QgcnVuIGF0IGFsbC5cbiAgICAgICAgICAgIHdoaWxlIChub2RlSW5kZXggPCBwYXJ0LmluZGV4KSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIHRoZSBjb250ZW50IGluc2lkZSBhIG5lc3RlZCB0ZW1wbGF0ZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHN0aWxsIGhhdmUgcGFydHMgKHRoZSBvdXRlciBmb3ItbG9vcCksIHdlIGtub3c6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB0ZW1wbGF0ZSBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGUgd2Fsa2VyIHdpbGwgZmluZCBhIG5leHROb2RlIG91dHNpZGUgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UndmUgYXJyaXZlZCBhdCBvdXIgcGFydCdzIG5vZGUuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5wcm9jZXNzb3IuaGFuZGxlVGV4dEV4cHJlc3Npb24odGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBwYXJ0Lmluc2VydEFmdGVyTm9kZShub2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaCguLi50aGlzLnByb2Nlc3Nvci5oYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhub2RlLCBwYXJ0Lm5hbWUsIHBhcnQuc3RyaW5ncywgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDRVBvbHlmaWxsKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZG9wdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMudXBncmFkZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWluc3RhbmNlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYm91bmRBdHRyaWJ1dGVTdWZmaXgsIGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXgsIG1hcmtlciwgbm9kZU1hcmtlciB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuLyoqXG4gKiBPdXIgVHJ1c3RlZFR5cGVQb2xpY3kgZm9yIEhUTUwgd2hpY2ggaXMgZGVjbGFyZWQgdXNpbmcgdGhlIGh0bWwgdGVtcGxhdGVcbiAqIHRhZyBmdW5jdGlvbi5cbiAqXG4gKiBUaGF0IEhUTUwgaXMgYSBkZXZlbG9wZXItYXV0aG9yZWQgY29uc3RhbnQsIGFuZCBpcyBwYXJzZWQgd2l0aCBpbm5lckhUTUxcbiAqIGJlZm9yZSBhbnkgdW50cnVzdGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlbiBtaXhlZCBpbi4gVGhlcmVmb3IgaXQgaXNcbiAqIGNvbnNpZGVyZWQgc2FmZSBieSBjb25zdHJ1Y3Rpb24uXG4gKi9cbmNvbnN0IHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMgJiZcbiAgICB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdsaXQtaHRtbCcsIHsgY3JlYXRlSFRNTDogKHMpID0+IHMgfSk7XG5jb25zdCBjb21tZW50TWFya2VyID0gYCAke21hcmtlcn0gYDtcbi8qKlxuICogVGhlIHJldHVybiB0eXBlIG9mIGBodG1sYCwgd2hpY2ggaG9sZHMgYSBUZW1wbGF0ZSBhbmQgdGhlIHZhbHVlcyBmcm9tXG4gKiBpbnRlcnBvbGF0ZWQgZXhwcmVzc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzLCB0eXBlLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIEhUTUwgdXNlZCB0byBjcmVhdGUgYSBgPHRlbXBsYXRlPmAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRIVE1MKCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgIGxldCBpc0NvbW1lbnRCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5zdHJpbmdzW2ldO1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggYmluZGluZyB3ZSB3YW50IHRvIGRldGVybWluZSB0aGUga2luZCBvZiBtYXJrZXIgdG8gaW5zZXJ0XG4gICAgICAgICAgICAvLyBpbnRvIHRoZSB0ZW1wbGF0ZSBzb3VyY2UgYmVmb3JlIGl0J3MgcGFyc2VkIGJ5IHRoZSBicm93c2VyJ3MgSFRNTFxuICAgICAgICAgICAgLy8gcGFyc2VyLiBUaGUgbWFya2VyIHR5cGUgaXMgYmFzZWQgb24gd2hldGhlciB0aGUgZXhwcmVzc2lvbiBpcyBpbiBhblxuICAgICAgICAgICAgLy8gYXR0cmlidXRlLCB0ZXh0LCBvciBjb21tZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgLy8gICAqIEZvciBub2RlLXBvc2l0aW9uIGJpbmRpbmdzIHdlIGluc2VydCBhIGNvbW1lbnQgd2l0aCB0aGUgbWFya2VyXG4gICAgICAgICAgICAvLyAgICAgc2VudGluZWwgYXMgaXRzIHRleHQgY29udGVudCwgbGlrZSA8IS0te3tsaXQtZ3VpZH19LS0+LlxuICAgICAgICAgICAgLy8gICAqIEZvciBhdHRyaWJ1dGUgYmluZGluZ3Mgd2UgaW5zZXJ0IGp1c3QgdGhlIG1hcmtlciBzZW50aW5lbCBmb3IgdGhlXG4gICAgICAgICAgICAvLyAgICAgZmlyc3QgYmluZGluZywgc28gdGhhdCB3ZSBzdXBwb3J0IHVucXVvdGVkIGF0dHJpYnV0ZSBiaW5kaW5ncy5cbiAgICAgICAgICAgIC8vICAgICBTdWJzZXF1ZW50IGJpbmRpbmdzIGNhbiB1c2UgYSBjb21tZW50IG1hcmtlciBiZWNhdXNlIG11bHRpLWJpbmRpbmdcbiAgICAgICAgICAgIC8vICAgICBhdHRyaWJ1dGVzIG11c3QgYmUgcXVvdGVkLlxuICAgICAgICAgICAgLy8gICAqIEZvciBjb21tZW50IGJpbmRpbmdzIHdlIGluc2VydCBqdXN0IHRoZSBtYXJrZXIgc2VudGluZWwgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vICAgICBjbG9zZSB0aGUgY29tbWVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgc2NhbnMgdGhlIHRlbXBsYXRlIHNvdXJjZSwgYnV0IGlzICpub3QqIGFuIEhUTUxcbiAgICAgICAgICAgIC8vIHBhcnNlci4gV2UgZG9uJ3QgbmVlZCB0byB0cmFjayB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIEhUTUwsIG9ubHlcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgYSBiaW5kaW5nIGlzIGluc2lkZSBhIGNvbW1lbnQsIGFuZCBpZiBub3QsIGlmIGl0IGFwcGVhcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaW5kaW5nIGluIGFuIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRPcGVuID0gcy5sYXN0SW5kZXhPZignPCEtLScpO1xuICAgICAgICAgICAgLy8gV2UncmUgaW4gY29tbWVudCBwb3NpdGlvbiBpZiB3ZSBoYXZlIGEgY29tbWVudCBvcGVuIHdpdGggbm8gZm9sbG93aW5nXG4gICAgICAgICAgICAvLyBjb21tZW50IGNsb3NlLiBCZWNhdXNlIDwtLSBjYW4gYXBwZWFyIGluIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGVyZSBjYW5cbiAgICAgICAgICAgIC8vIGJlIGZhbHNlIHBvc2l0aXZlcy5cbiAgICAgICAgICAgIGlzQ29tbWVudEJpbmRpbmcgPSAoY29tbWVudE9wZW4gPiAtMSB8fCBpc0NvbW1lbnRCaW5kaW5nKSAmJlxuICAgICAgICAgICAgICAgIHMuaW5kZXhPZignLS0+JywgY29tbWVudE9wZW4gKyAxKSA9PT0gLTE7XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhbiBhdHRyaWJ1dGUtbGlrZSBzZXF1ZW5jZSBwcmVjZWRpbmcgdGhlXG4gICAgICAgICAgICAvLyBleHByZXNzaW9uLiBUaGlzIGNhbiBtYXRjaCBcIm5hbWU9dmFsdWVcIiBsaWtlIHN0cnVjdHVyZXMgaW4gdGV4dCxcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzLCBhbmQgYXR0cmlidXRlIHZhbHVlcywgc28gdGhlcmUgY2FuIGJlIGZhbHNlLXBvc2l0aXZlcy5cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgb25seSBpbiB0aGlzIGJyYW5jaCBpZiB3ZSBkb24ndCBoYXZlIGEgYXR0cmlidXRlLWxpa2VcbiAgICAgICAgICAgICAgICAvLyBwcmVjZWRpbmcgc2VxdWVuY2UuIEZvciBjb21tZW50cywgdGhpcyBndWFyZHMgYWdhaW5zdCB1bnVzdWFsXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHZhbHVlcyBsaWtlIDxkaXYgZm9vPVwiPCEtLSR7J2Jhcid9XCI+LiBDYXNlcyBsaWtlXG4gICAgICAgICAgICAgICAgLy8gPCEtLSBmb289JHsnYmFyJ30tLT4gYXJlIGhhbmRsZWQgY29ycmVjdGx5IGluIHRoZSBhdHRyaWJ1dGUgYnJhbmNoXG4gICAgICAgICAgICAgICAgLy8gYmVsb3cuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBzICsgKGlzQ29tbWVudEJpbmRpbmcgPyBjb21tZW50TWFya2VyIDogbm9kZU1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYXR0cmlidXRlcyB3ZSB1c2UganVzdCBhIG1hcmtlciBzZW50aW5lbCwgYW5kIGFsc28gYXBwZW5kIGFcbiAgICAgICAgICAgICAgICAvLyAkbGl0JCBzdWZmaXggdG8gdGhlIG5hbWUgdG8gb3B0LW91dCBvZiBhdHRyaWJ1dGUtc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgSUUgYW5kIEVkZ2UgZG8gZm9yIHN0eWxlIGFuZCBjZXJ0YWluIFNWRyBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcy5zdWJzdHIoMCwgYXR0cmlidXRlTWF0Y2guaW5kZXgpICsgYXR0cmlidXRlTWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVNYXRjaFsyXSArIGJvdW5kQXR0cmlidXRlU3VmZml4ICsgYXR0cmlidXRlTWF0Y2hbM10gK1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSB0aGlzLnN0cmluZ3NbbF07XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICBnZXRUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRIVE1MKCk7XG4gICAgICAgIGlmIChwb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBzZWN1cmUgYmVjYXVzZSBgdGhpcy5zdHJpbmdzYCBpcyBhIFRlbXBsYXRlU3RyaW5nc0FycmF5LlxuICAgICAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgdGhpcyB3aGVuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1pcy10ZW1wbGF0ZS1vYmplY3QgaXNcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGVkLlxuICAgICAgICAgICAgdmFsdWUgPSBwb2xpY3kuY3JlYXRlSFRNTCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG59XG4vKipcbiAqIEEgVGVtcGxhdGVSZXN1bHQgZm9yIFNWRyBmcmFnbWVudHMuXG4gKlxuICogVGhpcyBjbGFzcyB3cmFwcyBIVE1MIGluIGFuIGA8c3ZnPmAgdGFnIGluIG9yZGVyIHRvIHBhcnNlIGl0cyBjb250ZW50cyBpbiB0aGVcbiAqIFNWRyBuYW1lc3BhY2UsIHRoZW4gbW9kaWZpZXMgdGhlIHRlbXBsYXRlIHRvIHJlbW92ZSB0aGUgYDxzdmc+YCB0YWcgc28gdGhhdFxuICogY2xvbmVzIG9ubHkgY29udGFpbmVyIHRoZSBvcmlnaW5hbCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNWR1RlbXBsYXRlUmVzdWx0IGV4dGVuZHMgVGVtcGxhdGVSZXN1bHQge1xuICAgIGdldEhUTUwoKSB7XG4gICAgICAgIHJldHVybiBgPHN2Zz4ke3N1cGVyLmdldEhUTUwoKX08L3N2Zz5gO1xuICAgIH1cbiAgICBnZXRUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gc3VwZXIuZ2V0VGVtcGxhdGVFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZW50LnJlbW92ZUNoaWxkKHN2Z0VsZW1lbnQpO1xuICAgICAgICByZXBhcmVudE5vZGVzKGNvbnRlbnQsIHN2Z0VsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1yZXN1bHQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgaXNEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZS5qcyc7XG5pbXBvcnQgeyByZW1vdmVOb2RlcyB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IG5vQ2hhbmdlLCBub3RoaW5nIH0gZnJvbSAnLi9wYXJ0LmpzJztcbmltcG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UgfSBmcm9tICcuL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmltcG9ydCB7IFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi90ZW1wbGF0ZS1yZXN1bHQuanMnO1xuaW1wb3J0IHsgY3JlYXRlTWFya2VyIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG5leHBvcnQgY29uc3QgaXNQcmltaXRpdmUgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICEodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpKTtcbn07XG5leHBvcnQgY29uc3QgaXNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAhISh2YWx1ZSAmJiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKTtcbn07XG4vKipcbiAqIFdyaXRlcyBhdHRyaWJ1dGUgdmFsdWVzIHRvIHRoZSBET00gZm9yIGEgZ3JvdXAgb2YgQXR0cmlidXRlUGFydHMgYm91bmQgdG8gYVxuICogc2luZ2xlIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIGlzIG9ubHkgc2V0IG9uY2UgZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFydHNcbiAqIGZvciBhbiBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVDb21taXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c1tpXSA9IHRoaXMuX2NyZWF0ZVBhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIHBhcnQuIE92ZXJyaWRlIHRoaXMgdG8gY3JlYXRlIGEgZGlmZmVybnQgdHlwZSBvZiBwYXJ0LlxuICAgICAqL1xuICAgIF9jcmVhdGVQYXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVBhcnQodGhpcyk7XG4gICAgfVxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgY29uc3QgbCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzO1xuICAgICAgICAvLyBJZiB3ZSdyZSBhc3NpZ25pbmcgYW4gYXR0cmlidXRlIHZpYSBzeW50YXggbGlrZTpcbiAgICAgICAgLy8gICAgYXR0cj1cIiR7Zm9vfVwiICBvciAgYXR0cj0ke2Zvb31cbiAgICAgICAgLy8gYnV0IG5vdFxuICAgICAgICAvLyAgICBhdHRyPVwiJHtmb299ICR7YmFyfVwiIG9yIGF0dHI9XCIke2Zvb30gYmF6XCJcbiAgICAgICAgLy8gdGhlbiB3ZSBkb24ndCB3YW50IHRvIGNvZXJjZSB0aGUgYXR0cmlidXRlIHZhbHVlIGludG8gb25lIGxvbmdcbiAgICAgICAgLy8gc3RyaW5nLiBJbnN0ZWFkIHdlIHdhbnQgdG8ganVzdCByZXR1cm4gdGhlIHZhbHVlIGl0c2VsZiBkaXJlY3RseSxcbiAgICAgICAgLy8gc28gdGhhdCBzYW5pdGl6ZURPTVZhbHVlIGNhbiBnZXQgdGhlIGFjdHVhbCB2YWx1ZSByYXRoZXIgdGhhblxuICAgICAgICAvLyBTdHJpbmcodmFsdWUpXG4gICAgICAgIC8vIFRoZSBleGNlcHRpb24gaXMgaWYgdiBpcyBhbiBhcnJheSwgaW4gd2hpY2ggY2FzZSB3ZSBkbyB3YW50IHRvIHNtYXNoXG4gICAgICAgIC8vIGl0IHRvZ2V0aGVyIGludG8gYSBzdHJpbmcgd2l0aG91dCBjYWxsaW5nIFN0cmluZygpIG9uIHRoZSBhcnJheS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbHNvIGFsbG93cyB0cnVzdGVkIHZhbHVlcyAod2hlbiB1c2luZyBUcnVzdGVkVHlwZXMpIGJlaW5nXG4gICAgICAgIC8vIGFzc2lnbmVkIHRvIERPTSBzaW5rcyB3aXRob3V0IGJlaW5nIHN0cmluZ2lmaWVkIGluIHRoZSBwcm9jZXNzLlxuICAgICAgICBpZiAobCA9PT0gMSAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJykge1xuICAgICAgICAgICAgY29uc3QgdiA9IHBhcnRzWzBdLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8ICFpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gcGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodikgfHwgIWlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2IDogU3RyaW5nKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIHQgPT09ICdzdHJpbmcnID8gdCA6IFN0cmluZyh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IHN0cmluZ3NbbF07XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgdGhpcy5fZ2V0VmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgUGFydCB0aGF0IGNvbnRyb2xzIGFsbCBvciBwYXJ0IG9mIGFuIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1pdHRlcikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbW1pdHRlciA9IGNvbW1pdHRlcjtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBub0NoYW5nZSAmJiAoIWlzUHJpbWl0aXZlKHZhbHVlKSB8fCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIG5vdCBhIGRpcmVjdGl2ZSwgZGlydHkgdGhlIGNvbW1pdHRlciBzbyB0aGF0IGl0J2xsXG4gICAgICAgICAgICAvLyBjYWxsIHNldEF0dHJpYnV0ZS4gSWYgdGhlIHZhbHVlIGlzIGEgZGlyZWN0aXZlLCBpdCdsbCBkaXJ0eSB0aGVcbiAgICAgICAgICAgIC8vIGNvbW1pdHRlciBpZiBpdCBjYWxscyBzZXRWYWx1ZSgpLlxuICAgICAgICAgICAgaWYgKCFpc0RpcmVjdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdHRlci5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21taXR0ZXIuY29tbWl0KCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFBhcnQgdGhhdCBjb250cm9scyBhIGxvY2F0aW9uIHdpdGhpbiBhIE5vZGUgdHJlZS4gTGlrZSBhIFJhbmdlLCBOb2RlUGFydFxuICogaGFzIHN0YXJ0IGFuZCBlbmQgbG9jYXRpb25zIGFuZCBjYW4gc2V0IGFuZCB1cGRhdGUgdGhlIE5vZGVzIGJldHdlZW4gdGhvc2VcbiAqIGxvY2F0aW9ucy5cbiAqXG4gKiBOb2RlUGFydHMgc3VwcG9ydCBzZXZlcmFsIHZhbHVlIHR5cGVzOiBwcmltaXRpdmVzLCBOb2RlcywgVGVtcGxhdGVSZXN1bHRzLFxuICogYXMgd2VsbCBhcyBhcnJheXMgYW5kIGl0ZXJhYmxlcyBvZiB0aG9zZSB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhpcyBwYXJ0IGludG8gYSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRJbnRvKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVNYXJrZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhpcyBwYXJ0IGFmdGVyIHRoZSBgcmVmYCBub2RlIChiZXR3ZWVuIGByZWZgIGFuZCBgcmVmYCdzIG5leHRcbiAgICAgKiBzaWJsaW5nKS4gQm90aCBgcmVmYCBhbmQgaXRzIG5leHQgc2libGluZyBtdXN0IGJlIHN0YXRpYywgdW5jaGFuZ2luZyBub2Rlc1xuICAgICAqIHN1Y2ggYXMgdGhvc2UgdGhhdCBhcHBlYXIgaW4gYSBsaXRlcmFsIHNlY3Rpb24gb2YgYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGluc2VydEFmdGVyTm9kZShyZWYpIHtcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSByZWY7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IHJlZi5uZXh0U2libGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGlzIHBhcnQgaW50byBhIHBhcmVudCBwYXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgYXBwZW5kSW50b1BhcnQocGFydCkge1xuICAgICAgICBwYXJ0Ll9faW5zZXJ0KHRoaXMuc3RhcnROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICBwYXJ0Ll9faW5zZXJ0KHRoaXMuZW5kTm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGlzIHBhcnQgYWZ0ZXIgdGhlIGByZWZgIHBhcnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlclBhcnQocmVmKSB7XG4gICAgICAgIHJlZi5fX2luc2VydCh0aGlzLnN0YXJ0Tm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gcmVmLmVuZE5vZGU7XG4gICAgICAgIHJlZi5lbmROb2RlID0gdGhpcy5zdGFydE5vZGU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydE5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29tbWl0VGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vdGhpbmc7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjaywgd2lsbCByZW5kZXIgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9faW5zZXJ0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5lbmROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMuZW5kTm9kZSk7XG4gICAgfVxuICAgIF9fY29tbWl0Tm9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX19pbnNlcnQodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9fY29tbWl0VGV4dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIC8vIElmIGB2YWx1ZWAgaXNuJ3QgYWxyZWFkeSBhIHN0cmluZywgd2UgZXhwbGljaXRseSBjb252ZXJ0IGl0IGhlcmUgaW4gY2FzZVxuICAgICAgICAvLyBpdCBjYW4ndCBiZSBpbXBsaWNpdGx5IGNvbnZlcnRlZCAtIGkuZS4gaXQncyBhIHN5bWJvbC5cbiAgICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nICYmXG4gICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBvbmx5IGhhdmUgYSBzaW5nbGUgdGV4dCBub2RlIGJldHdlZW4gdGhlIG1hcmtlcnMsIHdlIGNhbiBqdXN0XG4gICAgICAgICAgICAvLyBzZXQgaXRzIHZhbHVlLCByYXRoZXIgdGhhbiByZXBsYWNpbmcgaXQuXG4gICAgICAgICAgICAvLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBDYW4gd2UganVzdCBjaGVjayBpZiB0aGlzLnZhbHVlIGlzIHByaW1pdGl2ZT9cbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZUFzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlRmFjdG9yeSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS50ZW1wbGF0ZSA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHZhbHVlLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJvcGFnYXRlIHRoZSB0ZW1wbGF0ZSBwcm9jZXNzb3IgZnJvbSB0aGUgVGVtcGxhdGVSZXN1bHRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgdXNlIGl0cyBzeW50YXggZXh0ZW5zaW9uLCBldGMuIFRoZSB0ZW1wbGF0ZSBmYWN0b3J5IGNvbWVzXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSByZW5kZXIgZnVuY3Rpb24gb3B0aW9ucyBzbyB0aGF0IGl0IGNhbiBjb250cm9sIHRlbXBsYXRlXG4gICAgICAgICAgICAvLyBjYWNoaW5nIGFuZCBwcmVwcm9jZXNzaW5nLlxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZSh0ZW1wbGF0ZSwgdmFsdWUucHJvY2Vzc29yLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpbnN0YW5jZS5fY2xvbmUoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9fY29tbWl0SXRlcmFibGUodmFsdWUpIHtcbiAgICAgICAgLy8gRm9yIGFuIEl0ZXJhYmxlLCB3ZSBjcmVhdGUgYSBuZXcgSW5zdGFuY2VQYXJ0IHBlciBpdGVtLCB0aGVuIHNldCBpdHNcbiAgICAgICAgLy8gdmFsdWUgdG8gdGhlIGl0ZW0uIFRoaXMgaXMgYSBsaXR0bGUgYml0IG9mIG92ZXJoZWFkIGZvciBldmVyeSBpdGVtIGluXG4gICAgICAgIC8vIGFuIEl0ZXJhYmxlLCBidXQgaXQgbGV0cyB1cyByZWN1cnNlIGVhc2lseSBhbmQgZWZmaWNpZW50bHkgdXBkYXRlIEFycmF5c1xuICAgICAgICAvLyBvZiBUZW1wbGF0ZVJlc3VsdHMgdGhhdCB3aWxsIGJlIGNvbW1vbmx5IHJldHVybmVkIGZyb20gZXhwcmVzc2lvbnMgbGlrZTpcbiAgICAgICAgLy8gYXJyYXkubWFwKChpKSA9PiBodG1sYCR7aX1gKSwgYnkgcmV1c2luZyBleGlzdGluZyBUZW1wbGF0ZUluc3RhbmNlcy5cbiAgICAgICAgLy8gSWYgX3ZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG9mIGFuXG4gICAgICAgIC8vIGl0ZXJhYmxlIGFuZCBfdmFsdWUgd2lsbCBjb250YWluIHRoZSBOb2RlUGFydHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJZiBfdmFsdWUgaXMgbm90IGFuIGFycmF5LCBjbGVhciB0aGlzIHBhcnQgYW5kIG1ha2UgYSBuZXdcbiAgICAgICAgLy8gYXJyYXkgZm9yIE5vZGVQYXJ0cy5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGl0ZW1zIHdlIHN0YW1wZWQgc28gd2UgY2FuIGNsZWFyIGxlZnRvdmVyXG4gICAgICAgIC8vIGl0ZW1zIGZyb20gYSBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgY29uc3QgaXRlbVBhcnRzID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpdGVtUGFydDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmV1c2UgYW4gZXhpc3RpbmcgcGFydFxuICAgICAgICAgICAgaXRlbVBhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIHBhcnQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgIGlmIChpdGVtUGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnQgPSBuZXcgTm9kZVBhcnQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpdGVtUGFydHMucHVzaChpdGVtUGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtUGFydC5hcHBlbmRJbnRvUGFydCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1QYXJ0Lmluc2VydEFmdGVyUGFydChpdGVtUGFydHNbcGFydEluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1QYXJ0LnNldFZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbVBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEluZGV4IDwgaXRlbVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIHBhcnRzIGFycmF5IHNvIF92YWx1ZSByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgaXRlbVBhcnRzLmxlbmd0aCA9IHBhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoaXRlbVBhcnQgJiYgaXRlbVBhcnQuZW5kTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUpIHtcbiAgICAgICAgcmVtb3ZlTm9kZXModGhpcy5zdGFydE5vZGUucGFyZW50Tm9kZSwgc3RhcnROb2RlLm5leHRTaWJsaW5nLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGJvb2xlYW4gYXR0cmlidXRlLCByb3VnaGx5IGFzIGRlZmluZWQgaW4gdGhlIEhUTUxcbiAqIHNwZWNpZmljYXRpb24uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIHRydXRoeSwgdGhlbiB0aGUgYXR0cmlidXRlIGlzIHByZXNlbnQgd2l0aCBhIHZhbHVlIG9mXG4gKiAnJy4gSWYgdGhlIHZhbHVlIGlzIGZhbHNleSwgdGhlIGF0dHJpYnV0ZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoICE9PSAyIHx8IHN0cmluZ3NbMF0gIT09ICcnIHx8IHN0cmluZ3NbMV0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb2xlYW4gYXR0cmlidXRlcyBjYW4gb25seSBjb250YWluIGEgc2luZ2xlIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1ZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gISF0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGUgdmFsdWVzIGZvciBQcm9wZXJ0eVBhcnRzLCBzbyB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBvbmNlXG4gKiBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0cyBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBJZiBhbiBleHByZXNzaW9uIGNvbnRyb2xzIHRoZSB3aG9sZSBwcm9wZXJ0eSB2YWx1ZSwgdGhlbiB0aGUgdmFsdWUgaXMgc2ltcGx5XG4gKiBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgdW5kZXIgY29udHJvbC4gSWYgdGhlcmUgYXJlIHN0cmluZyBsaXRlcmFscyBvclxuICogbXVsdGlwbGUgZXhwcmVzc2lvbnMsIHRoZW4gdGhlIHN0cmluZ3MgYXJlIGV4cHJlc3Npb25zIGFyZSBpbnRlcnBvbGF0ZWQgaW50b1xuICogYSBzdHJpbmcgZmlyc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUNvbW1pdHRlciBleHRlbmRzIEF0dHJpYnV0ZUNvbW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICBzdXBlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPVxuICAgICAgICAgICAgKHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKTtcbiAgICB9XG4gICAgX2NyZWF0ZVBhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlQYXJ0KHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydHNbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50W3RoaXMubmFtZV0gPSB0aGlzLl9nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5UGFydCBleHRlbmRzIEF0dHJpYnV0ZVBhcnQge1xufVxuLy8gRGV0ZWN0IGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgc3VwcG9ydC4gSWYgdGhlIGBjYXB0dXJlYCBwcm9wZXJ0eSBpcyByZWFkXG4vLyBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlbiBvcHRpb25zIGFyZSBzdXBwb3J0ZWQuIElmIG5vdCwgdGhlbiB0aGUgdGhpcmRcbi8vIGFyZ3VtZW50IHRvIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyIGlzIGludGVycHJldGVkIGFzIHRoZSBib29sZWFuIGNhcHR1cmVcbi8vIHZhbHVlIHNvIHdlIHNob3VsZCBvbmx5IHBhc3MgdGhlIGBjYXB0dXJlYCBwcm9wZXJ0eS5cbmxldCBldmVudE9wdGlvbnNTdXBwb3J0ZWQgPSBmYWxzZTtcbi8vIFdyYXAgaW50byBhbiBJSUZFIGJlY2F1c2UgTVMgRWRnZSA8PSB2NDEgZG9lcyBub3Qgc3VwcG9ydCBoYXZpbmcgdHJ5L2NhdGNoXG4vLyBibG9ja3MgcmlnaHQgaW50byB0aGUgYm9keSBvZiBhIG1vZHVsZVxuKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZ2V0IGNhcHR1cmUoKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRPcHRpb25zU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChfZSkge1xuICAgICAgICAvLyBldmVudCBvcHRpb25zIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG59KSgpO1xuZXhwb3J0IGNsYXNzIEV2ZW50UGFydCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZXZlbnROYW1lLCBldmVudENvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuZXZlbnRDb250ZXh0ID0gZXZlbnRDb250ZXh0O1xuICAgICAgICB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCA9IChlKSA9PiB0aGlzLmhhbmRsZUV2ZW50KGUpO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1ZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xpc3RlbmVyID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgY29uc3Qgb2xkTGlzdGVuZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBzaG91bGRSZW1vdmVMaXN0ZW5lciA9IG5ld0xpc3RlbmVyID09IG51bGwgfHxcbiAgICAgICAgICAgIG9sZExpc3RlbmVyICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAobmV3TGlzdGVuZXIuY2FwdHVyZSAhPT0gb2xkTGlzdGVuZXIuY2FwdHVyZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ZW5lci5vbmNlICE9PSBvbGRMaXN0ZW5lci5vbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpc3RlbmVyLnBhc3NpdmUgIT09IG9sZExpc3RlbmVyLnBhc3NpdmUpO1xuICAgICAgICBjb25zdCBzaG91bGRBZGRMaXN0ZW5lciA9IG5ld0xpc3RlbmVyICE9IG51bGwgJiYgKG9sZExpc3RlbmVyID09IG51bGwgfHwgc2hvdWxkUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCwgdGhpcy5fX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRBZGRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBnZXRPcHRpb25zKG5ld0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCwgdGhpcy5fX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXdMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuY2FsbCh0aGlzLmV2ZW50Q29udGV4dCB8fCB0aGlzLmVsZW1lbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gV2UgY29weSBvcHRpb25zIGJlY2F1c2Ugb2YgdGhlIGluY29uc2lzdGVudCBiZWhhdmlvciBvZiBicm93c2VycyB3aGVuIHJlYWRpbmdcbi8vIHRoZSB0aGlyZCBhcmd1bWVudCBvZiBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lci4gSUUxMSBkb2Vzbid0IHN1cHBvcnQgb3B0aW9uc1xuLy8gYXQgYWxsLiBDaHJvbWUgNDEgb25seSByZWFkcyBgY2FwdHVyZWAgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdC5cbmNvbnN0IGdldE9wdGlvbnMgPSAobykgPT4gbyAmJlxuICAgIChldmVudE9wdGlvbnNTdXBwb3J0ZWQgP1xuICAgICAgICB7IGNhcHR1cmU6IG8uY2FwdHVyZSwgcGFzc2l2ZTogby5wYXNzaXZlLCBvbmNlOiBvLm9uY2UgfSA6XG4gICAgICAgIG8uY2FwdHVyZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0cy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBBdHRyaWJ1dGVDb21taXR0ZXIsIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0LCBFdmVudFBhcnQsIE5vZGVQYXJ0LCBQcm9wZXJ0eUNvbW1pdHRlciB9IGZyb20gJy4vcGFydHMuanMnO1xuLyoqXG4gKiBDcmVhdGVzIFBhcnRzIHdoZW4gYSB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXJ0cyBmb3IgYW4gYXR0cmlidXRlLXBvc2l0aW9uIGJpbmRpbmcsIGdpdmVuIHRoZSBldmVudCwgYXR0cmlidXRlXG4gICAgICogbmFtZSwgYW5kIHN0cmluZyBsaXRlcmFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGJpbmRpbmdcbiAgICAgKiBAcGFyYW0gbmFtZSAgVGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHN0cmluZ3MgVGhlIHN0cmluZyBsaXRlcmFscy4gVGhlcmUgYXJlIGFsd2F5cyBhdCBsZWFzdCB0d28gc3RyaW5ncyxcbiAgICAgKiAgIGV2ZW50IGZvciBmdWxseS1jb250cm9sbGVkIGJpbmRpbmdzIHdpdGggYSBzaW5nbGUgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBoYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhlbGVtZW50LCBuYW1lLCBzdHJpbmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVbMF07XG4gICAgICAgIGlmIChwcmVmaXggPT09ICcuJykge1xuICAgICAgICAgICAgY29uc3QgY29tbWl0dGVyID0gbmV3IFByb3BlcnR5Q29tbWl0dGVyKGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIHN0cmluZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1pdHRlci5wYXJ0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4ID09PSAnQCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEV2ZW50UGFydChlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBvcHRpb25zLmV2ZW50Q29udGV4dCldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPT09ICc/Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgQm9vbGVhbkF0dHJpYnV0ZVBhcnQoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgc3RyaW5ncyldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlciA9IG5ldyBBdHRyaWJ1dGVDb21taXR0ZXIoZWxlbWVudCwgbmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHJldHVybiBjb21taXR0ZXIucGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXJ0cyBmb3IgYSB0ZXh0LXBvc2l0aW9uIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRmFjdG9yeVxuICAgICAqL1xuICAgIGhhbmRsZVRleHRFeHByZXNzaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUGFydChvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yID0gbmV3IERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKlxuICogTWFpbiBsaXQtaHRtbCBtb2R1bGUuXG4gKlxuICogTWFpbiBleHBvcnRzOlxuICpcbiAqIC0gIFtbaHRtbF1dXG4gKiAtICBbW3N2Z11dXG4gKiAtICBbW3JlbmRlcl1dXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbi8qKlxuICogRG8gbm90IHJlbW92ZSB0aGlzIGNvbW1lbnQ7IGl0IGtlZXBzIHR5cGVkb2MgZnJvbSBtaXNwbGFjaW5nIHRoZSBtb2R1bGVcbiAqIGRvY3MuXG4gKi9cbmltcG9ydCB7IGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmltcG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmV4cG9ydCB7IGRpcmVjdGl2ZSwgaXNEaXJlY3RpdmUgfSBmcm9tICcuL2xpYi9kaXJlY3RpdmUuanMnO1xuLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogcmVtb3ZlIGxpbmUgd2hlbiB3ZSBnZXQgTm9kZVBhcnQgbW92aW5nIG1ldGhvZHNcbmV4cG9ydCB7IHJlbW92ZU5vZGVzLCByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9saWIvZG9tLmpzJztcbmV4cG9ydCB7IG5vQ2hhbmdlLCBub3RoaW5nIH0gZnJvbSAnLi9saWIvcGFydC5qcyc7XG5leHBvcnQgeyBBdHRyaWJ1dGVDb21taXR0ZXIsIEF0dHJpYnV0ZVBhcnQsIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0LCBFdmVudFBhcnQsIGlzSXRlcmFibGUsIGlzUHJpbWl0aXZlLCBOb2RlUGFydCwgUHJvcGVydHlDb21taXR0ZXIsIFByb3BlcnR5UGFydCB9IGZyb20gJy4vbGliL3BhcnRzLmpzJztcbmV4cG9ydCB7IHBhcnRzLCByZW5kZXIgfSBmcm9tICcuL2xpYi9yZW5kZXIuanMnO1xuZXhwb3J0IHsgdGVtcGxhdGVDYWNoZXMsIHRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWZhY3RvcnkuanMnO1xuZXhwb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmV4cG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBjcmVhdGVNYXJrZXIsIGlzVGVtcGxhdGVQYXJ0QWN0aXZlLCBUZW1wbGF0ZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLmpzJztcbi8vIElNUE9SVEFOVDogZG8gbm90IGNoYW5nZSB0aGUgcHJvcGVydHkgbmFtZSBvciB0aGUgYXNzaWdubWVudCBleHByZXNzaW9uLlxuLy8gVGhpcyBsaW5lIHdpbGwgYmUgdXNlZCBpbiByZWdleGVzIHRvIHNlYXJjaCBmb3IgbGl0LWh0bWwgdXNhZ2UuXG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBpbmplY3QgdmVyc2lvbiBudW1iZXIgYXQgYnVpbGQgdGltZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gfHwgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gPSBbXSkpLnB1c2goJzEuNC4xJyk7XG59XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIEhUTUwgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdodG1sJywgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gU1ZHIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN2ZyA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBTVkdUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdzdmcnLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWh0bWwuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgQXR0cmlidXRlUGFydCwgZGlyZWN0aXZlLCBQcm9wZXJ0eVBhcnQgfSBmcm9tICcuLi9saXQtaHRtbC5qcyc7XG4vLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBjbGFzc0xpc3Qgb24gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBlbXVsYXRlIGl0IHdpdGggYSBTZXRcbmNsYXNzIENsYXNzTGlzdCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChjbHMpIHtcbiAgICAgICAgdGhpcy5jbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZW1vdmUoY2xzKSB7XG4gICAgICAgIHRoaXMuY2xhc3Nlcy5kZWxldGUoY2xzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IGNsYXNzU3RyaW5nICs9IGNscyArICcgJyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU3RvcmVzIHRoZSBDbGFzc0luZm8gb2JqZWN0IGFwcGxpZWQgdG8gYSBnaXZlbiBBdHRyaWJ1dGVQYXJ0LlxuICogVXNlZCB0byB1bnNldCBleGlzdGluZyB2YWx1ZXMgd2hlbiBhIG5ldyBDbGFzc0luZm8gb2JqZWN0IGlzIGFwcGxpZWQuXG4gKi9cbmNvbnN0IHByZXZpb3VzQ2xhc3Nlc0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhcHBsaWVzIENTUyBjbGFzc2VzLiBUaGlzIG11c3QgYmUgdXNlZCBpbiB0aGUgYGNsYXNzYFxuICogYXR0cmlidXRlIGFuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgdXNlZCBpbiB0aGUgYXR0cmlidXRlLiBJdCB0YWtlcyBlYWNoXG4gKiBwcm9wZXJ0eSBpbiB0aGUgYGNsYXNzSW5mb2AgYXJndW1lbnQgYW5kIGFkZHMgdGhlIHByb3BlcnR5IG5hbWUgdG8gdGhlXG4gKiBlbGVtZW50J3MgYGNsYXNzYCBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXMgdHJ1dGh5OyBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXNcbiAqIGZhbHNleSwgdGhlIHByb3BlcnR5IG5hbWUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50J3MgYGNsYXNzYC4gRm9yIGV4YW1wbGVcbiAqIGB7Zm9vOiBiYXJ9YCBhcHBsaWVzIHRoZSBjbGFzcyBgZm9vYCBpZiB0aGUgdmFsdWUgb2YgYGJhcmAgaXMgdHJ1dGh5LlxuICogQHBhcmFtIGNsYXNzSW5mbyB7Q2xhc3NJbmZvfVxuICovXG5leHBvcnQgY29uc3QgY2xhc3NNYXAgPSBkaXJlY3RpdmUoKGNsYXNzSW5mbykgPT4gKHBhcnQpID0+IHtcbiAgICBpZiAoIShwYXJ0IGluc3RhbmNlb2YgQXR0cmlidXRlUGFydCkgfHwgKHBhcnQgaW5zdGFuY2VvZiBQcm9wZXJ0eVBhcnQpIHx8XG4gICAgICAgIHBhcnQuY29tbWl0dGVyLm5hbWUgIT09ICdjbGFzcycgfHwgcGFydC5jb21taXR0ZXIucGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgY2xhc3NNYXBgIGRpcmVjdGl2ZSBtdXN0IGJlIHVzZWQgaW4gdGhlIGBjbGFzc2AgYXR0cmlidXRlICcgK1xuICAgICAgICAgICAgJ2FuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgaW4gdGhlIGF0dHJpYnV0ZS4nKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb21taXR0ZXIgfSA9IHBhcnQ7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBjb21taXR0ZXI7XG4gICAgbGV0IHByZXZpb3VzQ2xhc3NlcyA9IHByZXZpb3VzQ2xhc3Nlc0NhY2hlLmdldChwYXJ0KTtcbiAgICBpZiAocHJldmlvdXNDbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV3JpdGUgc3RhdGljIGNsYXNzZXMgb25jZVxuICAgICAgICAvLyBVc2Ugc2V0QXR0cmlidXRlKCkgYmVjYXVzZSBjbGFzc05hbWUgaXNuJ3QgYSBzdHJpbmcgb24gU1ZHIGVsZW1lbnRzXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNvbW1pdHRlci5zdHJpbmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIHByZXZpb3VzQ2xhc3Nlc0NhY2hlLnNldChwYXJ0LCBwcmV2aW91c0NsYXNzZXMgPSBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0xpc3QgPSAoZWxlbWVudC5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChlbGVtZW50KSk7XG4gICAgLy8gUmVtb3ZlIG9sZCBjbGFzc2VzIHRoYXQgbm8gbG9uZ2VyIGFwcGx5XG4gICAgLy8gV2UgdXNlIGZvckVhY2goKSBpbnN0ZWFkIG9mIGZvci1vZiBzbyB0aGF0IHJlIGRvbid0IHJlcXVpcmUgZG93bi1sZXZlbFxuICAgIC8vIGl0ZXJhdGlvbi5cbiAgICBwcmV2aW91c0NsYXNzZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBpZiAoIShuYW1lIGluIGNsYXNzSW5mbykpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIG9yIHJlbW92ZSBjbGFzc2VzIGJhc2VkIG9uIHRoZWlyIGNsYXNzTWFwIHZhbHVlXG4gICAgZm9yIChjb25zdCBuYW1lIGluIGNsYXNzSW5mbykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNsYXNzSW5mb1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IHByZXZpb3VzQ2xhc3Nlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgd2FudCBhIGxvb3NlIHRydXRoeSBjaGVjayBvZiBgdmFsdWVgIGJlY2F1c2UgaXQgc2VlbXNcbiAgICAgICAgICAgIC8vIG1vcmUgY29udmVuaWVudCB0aGF0ICcnIGFuZCAwIGFyZSBza2lwcGVkLlxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0LmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjbGFzc0xpc3QuY29tbWl0KCk7XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy1tYXAuanMubWFwIiwiaW1wb3J0IHsgaHRtbCwgY3NzLCBub3RoaW5nIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSAnbGl0LWh0bWwvZGlyZWN0aXZlcy9jbGFzcy1tYXAuanMnO1xuaW1wb3J0IFNjRWxlbWVudCBmcm9tICcuL1NjRWxlbWVudC5qcyc7XG5pbXBvcnQgeyBmb250RmFtaWx5LCBmb250U2l6ZSwgdGhlbWUgfSBmcm9tICcuL3N0eWxlcy5qcyc7XG5cbmNsYXNzIFNjVGV4dCBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgOmhvc3Qge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIH1cblxuICAgICAgdGV4dGFyZWEge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMiddfTtcbiAgICAgICAgYm9yZGVyOiAxcHggZG90dGVkICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS00J119O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xuICAgICAgICBwYWRkaW5nOiA2cHggMnB4IDZweCA2cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgZm9udC1zaXplOiAke2ZvbnRTaXplfTtcbiAgICAgICAgbGluZS1oZWlnaHQ6ICR7MTZ9cHg7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgdGV4dGFyZWE6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktNCddfTtcbiAgICAgIH1cblxuICAgICAgdGV4dGFyZWEuZGlydHkge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXNlY29uZGFyeS0zJ119O1xuICAgICAgfVxuXG4gICAgICB0ZXh0YXJlYVtyZWFkb25seV0sIHRleHRhcmVhW3JlYWRvbmx5XTpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0zJ119O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMyddfTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMud2lkdGggPSAyMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjbGFzc2VzID0geyBkaXJ0eTogdGhpcy5fZGlydHkgfTtcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPHRleHRhcmVhXG4gICAgICAgIGNsYXNzPSR7Y2xhc3NNYXAoY2xhc3Nlcyl9XG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgIFwiXG4gICAgICAgIC52YWx1ZT1cIiR7dGhpcy52YWx1ZX1cIlxuICAgICAgICA/cmVhZG9ubHk9JHt0aGlzLnJlYWRvbmx5fVxuICAgICAgICBAYmx1cj0ke3RoaXMudXBkYXRlVmFsdWV9XG4gICAgICAgIEBrZXlkb3duPSR7dGhpcy5vbktleURvd259XG4gICAgICAgIEBrZXl1cD0ke3RoaXMub25LZXlVcH1cbiAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgID48L3RleHRhcmVhPlxuICAgIGA7XG4gIH1cblxuICBmb2N1cygpIHtcbiAgICBjb25zdCAkdGV4dGFyZWEgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcblxuICAgIGlmICgkdGV4dGFyZWEpIHtcbiAgICAgICR0ZXh0YXJlYS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIG9uS2V5RG93bihlKSB7XG4gICAgLy8gbWFudWFsbHkgZG8gY29tbWVudCBiZWNhdXNlIG9wZW5zIEhlbHAgbWVudSBvdGhlcndpc2UuLi5cbiAgICBpZiAoZS5tZXRhS2V5ICYmIGUua2V5ID09PSAncycpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy51cGRhdGVWYWx1ZShlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBvbktleVVwKGUpIHtcbiAgICBpZiAoZS50YXJnZXQudmFsdWUgIT09IHRoaXMudmFsdWUgJiYgdGhpcy5fZGlydHkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGUudGFyZ2V0LnZhbHVlID09PSB0aGlzLnZhbHVlICYmIHRoaXMuX2RpcnR5ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVmFsdWUoZSwgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuX2RpcnR5IHx8wqBmb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcblxuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy52YWx1ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy10ZXh0JywgU2NUZXh0KTtcblxuZXhwb3J0IGRlZmF1bHQgU2NUZXh0O1xuIiwiaW1wb3J0IHsgaHRtbCwgY3NzLCBzdmcsIG5vdGhpbmcgfSBmcm9tICdsaXQnO1xuaW1wb3J0IFNjRWxlbWVudCBmcm9tICcuL1NjRWxlbWVudC5qcyc7XG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcblxuY2xhc3MgU2NCYW5nIGV4dGVuZHMgU2NFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBhY3RpdmU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIH0sXG4gICAgICB2YWx1ZToge30sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTEnXX07XG4gICAgICAgIGZvbnQtc2l6ZTogMCAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICBzdmcge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMiddfTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBzZXQgYWN0aXZlKHZhbHVlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG5cbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcblxuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgfSwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLndpZHRoID0gMzA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLnZhbHVlID0gdHJ1ZSxcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3RpbWVvdXRJZCA9IG51bGw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgLSAyO1xuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3ZnXG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7dGhpcy5fc2l6ZX1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5fc2l6ZX1weDtcbiAgICAgICAgXCJcbiAgICAgICAgdmlld2JveD1cIjAgMCAxMDAgMTAwXCJcbiAgICAgICAgQG1vdXNlZG93bj1cIiR7dGhpcy5fdHJpZ2dlckV2ZW50fVwiXG4gICAgICAgIEB0b3VjaHN0YXJ0PVwiJHt0aGlzLl90cmlnZ2VyRXZlbnR9XCJcbiAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgID5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGN4PVwiNTBcIlxuICAgICAgICAgIGN5PVwiNTBcIlxuICAgICAgICAgIHI9XCIzNFwiXG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiOFwiXG4gICAgICAgICAgc3Ryb2tlPVwiJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTMnXX1cIlxuICAgICAgICAgIGZpbGw9XCIke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMSddfVwiXG4gICAgICAgID48L2NpcmNsZT5cbiAgICAgICAgJHt0aGlzLl9hY3RpdmVcbiAgICAgICAgICA/IHN2Z2BcbiAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgY3g9XCI1MFwiXG4gICAgICAgICAgICAgIGN5PVwiNTBcIlxuICAgICAgICAgICAgICByPVwiMjBcIlxuICAgICAgICAgICAgICBmaWxsPVwiJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTQnXX1cIlxuICAgICAgICAgICAgPjwvY2lyY2xlPlxuICAgICAgICAgIGBcbiAgICAgICAgICA6IG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgPC9zdmc+XG4gICAgYFxuICB9XG5cbiAgX3RyaWdnZXJFdmVudChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgaW5wdXRFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnaW5wdXQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgdmFsdWU6IHRoaXMudmFsdWUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoaW5wdXRFdmVudCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy1iYW5nJywgU2NCYW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NCYW5nO1xuXG4iLCJpbXBvcnQgeyBodG1sLCBjc3MsIG5vdGhpbmcgfSBmcm9tICdsaXQnO1xuaW1wb3J0IFNjRWxlbWVudCBmcm9tICcuL1NjRWxlbWVudC5qcyc7XG5pbXBvcnQgeyB0aGVtZSwgZm9udEZhbWlseSB9IGZyb20gJy4vc3R5bGVzLmpzJztcblxuY2xhc3MgU2NTaWduYWwgZXh0ZW5kcyBTY0VsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIGR1cmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBtaW46IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgICB9LFxuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgfSxcbiAgICAgIGxpbmVXaWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZTogJ2xpbmUtd2lkdGgnLFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlNaW5NYXg6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgYXR0cmlidXRlOiAnZGlzcGxheS1taW4tbWF4JyxcbiAgICAgICAgcmVmbGVjdDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xuICAgICAgICBvdXRsaW5lOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgY2FudmFzIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgfVxuXG4gICAgICAubWluLCAubWF4IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDE0cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxNHB4O1xuICAgICAgICBmb250LXNpemU6IDEwcHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAycHg7XG4gICAgICAgIGNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMCddfTs7XG4gICAgICB9XG5cbiAgICAgIC5taW4ge1xuICAgICAgICBib3R0b206IDBweDtcbiAgICAgIH1cblxuICAgICAgLm1heCB7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBzZXQgdmFsdWUoZnJhbWUpIHtcbiAgICBmcmFtZS5kYXRhID0gQXJyYXkuaXNBcnJheShmcmFtZS5kYXRhKSA/IGZyYW1lLmRhdGEgOiBbZnJhbWUuZGF0YV07XG4gICAgLy8gbmVlZCB0byBjb3B5IHZhbHVlcyBhdCBzb21lIHBvaW50XG4gICAgdGhpcy5fZnJhbWVTdGFjay5wdXNoKGZyYW1lKTtcblxuICAgIGlmICh0aGlzLmRpc3BsYXlNaW5NYXgpIHtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWUuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZnJhbWUuZGF0YVtpXSA+IHRoaXMuX21heFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSBmcmFtZS5kYXRhW2ldO1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYW1lLmRhdGFbaV0gPCB0aGlzLl9taW5WYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX21pblZhbHVlID0gZnJhbWUuZGF0YVtpXTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICB0aGlzLmhlaWdodCA9IDE1MDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMTtcbiAgICB0aGlzLmNvbG9ycyA9IFsnIzQ2ODJCNCcsICcjZmZhNTAwJywgJyMwMGU2MDAnLCAnI2ZmMDAwMCcsICcjODAwMDgwJywgJyMyMjQxNTMnXTtcbiAgICB0aGlzLmRpc3BsYXlNaW5NYXggPSBmYWxzZTtcblxuICAgIHRoaXMubWluID0gLTE7XG4gICAgdGhpcy5tYXggPSAxO1xuXG4gICAgdGhpcy5fZnJhbWVTdGFjayA9IFtdO1xuICAgIHRoaXMuX3BpeGVsSW5kZXggPSBudWxsO1xuXG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX21heFZhbHVlID0gLUluZmluaXR5O1xuICAgIHRoaXMuX21pblZhbHVlID0gK0luZmluaXR5O1xuXG4gICAgdGhpcy5fcmVuZGVyU2lnbmFsID0gdGhpcy5fcmVuZGVyU2lnbmFsLmJpbmQodGhpcyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8ZGl2XG4gICAgICAgIEBjb250ZXh0bWVudT1cIiR7dGhpcy5fcHJldmVudENvbnRleHRNZW51fVwiXG4gICAgICA+XG4gICAgICAgIDxjYW52YXNcbiAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICBcIlxuICAgICAgICA+PC9jYW52YXM+XG4gICAgICAgICR7dGhpcy5kaXNwbGF5TWluTWF4XG4gICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXhcIj4ke3RoaXMuX21heFZhbHVlLnRvRml4ZWQoMyl9PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtaW5cIj4ke3RoaXMuX21pblZhbHVlLnRvRml4ZWQoMyl9PC9zcGFuPlxuICAgICAgICAgICAgYFxuICAgICAgICAgIDogbm90aGluZ1xuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgZmlyc3RVcGRhdGVkKCkge1xuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICB0aGlzLmNhY2hlZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FjaGVkQ3R4ID0gdGhpcy5jYWNoZWRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGRlYnVnIGNhY2hlZCBjYW52YXNcbiAgICAvLyB0aGlzLmNhY2hlZENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5jYWNoZWRDYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICAvLyB0aGlzLmNhY2hlZENhbnZhcy5zdHlsZS5yaWdodCA9IDA7XG4gICAgLy8gdGhpcy5jYWNoZWRDYW52YXMuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgcmVkJztcbiAgICAvLyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FjaGVkQ2FudmFzKTtcblxuICAgIHN1cGVyLmZpcnN0VXBkYXRlZCgpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZnJhbWVTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3BpeGVsSW5kZXggPSBudWxsO1xuXG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMuckFGSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlclNpZ25hbCk7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgc3VwZXIudXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRklkKTtcblxuICAgIHRoaXMuX2ZyYW1lU3RhY2subGVuZ3RoID0gMDtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fbG9naWNhbFdpZHRoLCB0aGlzLl9sb2dpY2FsSGVpZ2h0KTtcbiAgICB0aGlzLmNhY2hlZEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fbG9naWNhbFdpZHRoLCB0aGlzLl9sb2dpY2FsSGVpZ2h0KTtcblxuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cblxuICBfcmVuZGVyU2lnbmFsKCkge1xuXG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAvLyBAdG9kbyAtIGZpeCB3ZWlyZCBiZWhhdmlvciB3aGVuIHVwZGF0aW5nIGB3aWR0aGBcbiAgICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9sb2dpY2FsV2lkdGggPSB0aGlzLndpZHRoICogc2NhbGU7XG4gICAgICB0aGlzLl9sb2dpY2FsSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBzY2FsZTtcblxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLl9sb2dpY2FsV2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLl9sb2dpY2FsSGVpZ2h0O1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXMud2lkdGggPSB0aGlzLl9sb2dpY2FsV2lkdGg7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhcy5oZWlnaHQgPSB0aGlzLl9sb2dpY2FsSGVpZ2h0O1xuXG4gICAgICAvLyBjcmVhdGUgeSBzY2FsZSAoc2hvdWxkIGJlIGNhbGxlZCBvbiBoZWlnaHQsIG1pbiBvciBtYXggY2hhbmdlKVxuICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2xvZ2ljYWxIZWlnaHQ7XG5cbiAgICAgIGNvbnN0IGEgPSAoMCAtIGhlaWdodCkgLyAobWF4IC0gbWluKTtcbiAgICAgIGNvbnN0IGIgPSBoZWlnaHQgLSAoYSAqIG1pbik7XG5cbiAgICAgIHRoaXMuX2dldFlQb3NpdGlvbiA9ICh4KSA9PiBhICogeCArIGI7XG5cbiAgICAgIHRoaXMuX2ZyYW1lU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3BpeGVsSW5kZXggPSBudWxsO1xuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2xvZ2ljYWxXaWR0aCwgdGhpcy5fbG9naWNhbEhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlZEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fbG9naWNhbFdpZHRoLCB0aGlzLl9sb2dpY2FsSGVpZ2h0KTtcblxuICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFtZVN0YWNrU2l6ZSA9IHRoaXMuX2ZyYW1lU3RhY2subGVuZ3RoO1xuXG4gICAgaWYgKGZyYW1lU3RhY2tTaXplID4gMCkge1xuICAgICAgbGV0IHNoaWZ0Q2FudmFzUGl4ZWxzID0gMDtcbiAgICAgIGxldCBhYm9ydCA9IGZhbHNlO1xuICAgICAgY29uc3QgcGl4ZWxEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5fcGl4ZWxJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9waXhlbEluZGV4ID0gTWF0aC5mbG9vcih0aGlzLl9mcmFtZVN0YWNrWzBdLnRpbWUgLyBwaXhlbER1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hpbGUgd2UgaGF2ZSBzb21lIGZyYW1lcyB0byBkaXNwbGF5LCB3ZSBnbyB0aHJvdWdoIHBpeGVscyBhbmQgZGlzcGxheVxuICAgICAgd2hpbGUgKHRoaXMuX2ZyYW1lU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBzaGlmdENhbnZhc1BpeGVscyArPSAxO1xuXG4gICAgICAgIGNvbnN0IHBpeGVsU3RhcnRUaW1lID0gdGhpcy5fcGl4ZWxJbmRleCAqIHBpeGVsRHVyYXRpb247XG4gICAgICAgIGNvbnN0IHBpeGVsU3RvcFRpbWUgPSAodGhpcy5fcGl4ZWxJbmRleCArIDEpICogcGl4ZWxEdXJhdGlvbjtcbiAgICAgICAgLy8gY29uc29sZS5sb2cocGl4ZWxTdGFydFRpbWUsIHBpeGVsU3RvcFRpbWUsIHRoaXMuX3BpeGVsSW5kZXgpO1xuICAgICAgICBsZXQgY2FuZGlkYXRlSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8vIGZpbmQgY2FuZGlkYXRlcyBmb3IgZGlzcGxheSBpbiBjdXJyZW50IHBpeGVsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZnJhbWVTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fZnJhbWVTdGFja1tpXTtcbiAgICAgICAgICBjb25zdCBmcmFtZVRpbWUgPSBmcmFtZS50aW1lO1xuXG4gICAgICAgICAgLy8gaWdub3JlIG9sZCBwaXhlbFxuICAgICAgICAgIGlmIChmcmFtZVRpbWUgPCBwaXhlbFN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gaWYgbGFzdCBmcmFtZSBpbiBzdGFjaywgYWJvcnQgYW5kIHdhaXQgZm9yIG5ldyBmcmFtZXNcbiAgICAgICAgICAgIGlmIChpICsgMSA9PT0gdGhpcy5fZnJhbWVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ltIHRoZXJlJywgZnJhbWVUaW1lLCBwaXhlbFN0YXJ0VGltZSwgdGhpcy5fZnJhbWVTdGFjay5sZW5ndGgsIGkpO1xuICAgICAgICAgICAgICB0aGlzLl9mcmFtZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0YWtlIHRoZSBsYXN0IGZyYW1lIHdlIGZpbmQgaW4gdGhlIHBpeGVsIHRpbWUgaW50ZXJ2YWxcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lVGltZSA+PSBwaXhlbFN0YXJ0VGltZSAmJiBmcmFtZVRpbWUgPCBwaXhlbFN0b3BUaW1lKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgYWJvcnQgYmVmb3JlIGluY3JlbWVudGluZyB0aGlzLl9waXhlbEluZGV4LFxuICAgICAgICAvLyBhcyB3ZSB3YW50IHRvIHJlY2hlY2sgdGhlIHNhbWUgcGl4ZWwgd2l0aCBuZXcgZGF0YSBsYXRlclxuICAgICAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEBub3RlIC0gdGhlcmUgaXMgcHJvYmFibHkgcm9vbSBmb3Igb3B0aW1pemF0aW9ucyBoZXJlIGFzXG4gICAgICAgIC8vIHdlIHN0b3JlIGFuZCByZXRyaWV2ZSB0aGUgY29tbGV0ZSBjYW52YXMgYXQgZWFjaCBwaXhlbC4gVGhpcyBjb3VsZFxuICAgICAgICAvLyBwcm9iYWJseSBiZSBiYXRjaGVkIGluIHNvbWUgd2F5LlxuICAgICAgICBpZiAoY2FuZGlkYXRlSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2ZyYW1lU3RhY2tbY2FuZGlkYXRlSW5kZXhdO1xuICAgICAgICAgIC8vIGRyYXcgbGluZSBzaW5jZSBsYXN0IGZyYW1lXG4gICAgICAgICAgaWYgKHRoaXMubGFzdEZyYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX2xvZ2ljYWxXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2xvZ2ljYWxIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0RnJhbWVQaXhlbCA9IHdpZHRoIC0gc2hpZnRDYW52YXNQaXhlbHM7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0IGNhbnZhcyBmcm9tIGBzaGlmdENhbnZhc1BpeGVsc2BcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmNhY2hlZENhbnZhcyxcbiAgICAgICAgICAgICAgc2hpZnRDYW52YXNQaXhlbHMsIDAsIGxhc3RGcmFtZVBpeGVsLCBoZWlnaHQsXG4gICAgICAgICAgICAgIDAsIDAsIGxhc3RGcmFtZVBpeGVsLCBoZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWUuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JzW2ldO1xuICAgICAgICAgICAgICAvLyBkcmF3IGxpbmUgYmV0d2VlbiBsYXN0RnJhbWUgKHdpZHRoIC0gc2hpZnRDYW52YXNQaXhlbHMsIHkpXG4gICAgICAgICAgICAgIC8vIGFuZCBjdXJyZW50RnJhbWUgKHdpZHRoLCB5KVxuICAgICAgICAgICAgICBjb25zdCBsYXN0WSA9IHRoaXMuX2dldFlQb3NpdGlvbih0aGlzLmxhc3RGcmFtZS5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFkgPSB0aGlzLl9nZXRZUG9zaXRpb24oZnJhbWUuZGF0YVtpXSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhsYXN0RnJhbWVQaXhlbCwgbGFzdFkpO1xuICAgICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8od2lkdGgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNhdmUgY3VycmVudFN0YXRlIGludG8gY2FjaGVcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQ3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICBzaGlmdENhbnZhc1BpeGVscyA9IDA7XG5cbiAgICAgICAgICAvLyByZW1vdmUgZnJhbWVzIGZyb20gc3RhY2sgaW5jbHVkaW5nIHJlbmRlcmVkIGNhbmRpZGF0ZVxuICAgICAgICAgIHRoaXMuX2ZyYW1lU3RhY2suc3BsaWNlKDAsIGNhbmRpZGF0ZUluZGV4ICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9waXhlbEluZGV4ICs9IDE7XG4gICAgICB9IC8vIGVuZCB3aGlsZVxuICAgIH0gLy8gZW5kIGlmXG5cbiAgICB0aGlzLnJBRklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJTaWduYWwpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc2Mtc2lnbmFsJywgU2NTaWduYWwpO1xuXG5leHBvcnQgZGVmYXVsdCBTY1NpZ25hbDtcbiIsImltcG9ydHtfJExIIGFzIG99ZnJvbVwiLi9saXQtaHRtbC5qc1wiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovY29uc3R7SDppfT1vLHQ9bz0+bnVsbD09PW98fFwib2JqZWN0XCIhPXR5cGVvZiBvJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBvLG49e0hUTUw6MSxTVkc6Mn0sdj0obyxpKT0+e3ZhciB0LG47cmV0dXJuIHZvaWQgMD09PWk/dm9pZCAwIT09KG51bGw9PT0odD1vKXx8dm9pZCAwPT09dD92b2lkIDA6dC5fJGxpdFR5cGUkKToobnVsbD09PShuPW8pfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLl8kbGl0VHlwZSQpPT09aX0sbD1vPT57dmFyIGk7cmV0dXJuIHZvaWQgMCE9PShudWxsPT09KGk9byl8fHZvaWQgMD09PWk/dm9pZCAwOmkuXyRsaXREaXJlY3RpdmUkKX0sZD1vPT57dmFyIGk7cmV0dXJuIG51bGw9PT0oaT1vKXx8dm9pZCAwPT09aT92b2lkIDA6aS5fJGxpdERpcmVjdGl2ZSR9LHI9bz0+dm9pZCAwPT09by5zdHJpbmdzLGU9KCk9PmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIiksdT0obyx0LG4pPT57dmFyIHY7Y29uc3QgbD1vLl8kQUEucGFyZW50Tm9kZSxkPXZvaWQgMD09PXQ/by5fJEFCOnQuXyRBQTtpZih2b2lkIDA9PT1uKXtjb25zdCB0PWwuaW5zZXJ0QmVmb3JlKGUoKSxkKSx2PWwuaW5zZXJ0QmVmb3JlKGUoKSxkKTtuPW5ldyBpKHQsdixvLG8ub3B0aW9ucyl9ZWxzZXtjb25zdCBpPW4uXyRBQi5uZXh0U2libGluZyx0PW4uXyRBTSxyPXQhPT1vO2lmKHIpe2xldCBpO251bGw9PT0odj1uLl8kQVEpfHx2b2lkIDA9PT12fHx2LmNhbGwobixvKSxuLl8kQU09byx2b2lkIDAhPT1uLl8kQVAmJihpPW8uXyRBVSkhPT10Ll8kQVUmJm4uXyRBUChpKX1pZihpIT09ZHx8cil7bGV0IG89bi5fJEFBO2Zvcig7byE9PWk7KXtjb25zdCBpPW8ubmV4dFNpYmxpbmc7bC5pbnNlcnRCZWZvcmUobyxkKSxvPWl9fX1yZXR1cm4gbn0sYz0obyxpLHQ9byk9PihvLl8kQUkoaSx0KSxvKSxmPXt9LHM9KG8saT1mKT0+by5fJEFIPWksYT1vPT5vLl8kQUgsbT1vPT57dmFyIGk7bnVsbD09PShpPW8uXyRBUCl8fHZvaWQgMD09PWl8fGkuY2FsbChvLCExLCEwKTtsZXQgdD1vLl8kQUE7Y29uc3Qgbj1vLl8kQUIubmV4dFNpYmxpbmc7Zm9yKDt0IT09bjspe2NvbnN0IG89dC5uZXh0U2libGluZzt0LnJlbW92ZSgpLHQ9b319LHA9bz0+e28uXyRBUigpfTtleHBvcnR7biBhcyBUZW1wbGF0ZVJlc3VsdFR5cGUscCBhcyBjbGVhclBhcnQsYSBhcyBnZXRDb21taXR0ZWRWYWx1ZSxkIGFzIGdldERpcmVjdGl2ZUNsYXNzLHUgYXMgaW5zZXJ0UGFydCxsIGFzIGlzRGlyZWN0aXZlUmVzdWx0LHQgYXMgaXNQcmltaXRpdmUsciBhcyBpc1NpbmdsZUV4cHJlc3Npb24sdiBhcyBpc1RlbXBsYXRlUmVzdWx0LG0gYXMgcmVtb3ZlUGFydCxjIGFzIHNldENoaWxkUGFydFZhbHVlLHMgYXMgc2V0Q29tbWl0dGVkVmFsdWV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlLWhlbHBlcnMuanMubWFwXG4iLCJpbXBvcnR7bm9DaGFuZ2UgYXMgZX1mcm9tXCIuLi9saXQtaHRtbC5qc1wiO2ltcG9ydHtkaXJlY3RpdmUgYXMgcyxEaXJlY3RpdmUgYXMgdCxQYXJ0VHlwZSBhcyByfWZyb21cIi4uL2RpcmVjdGl2ZS5qc1wiO2ltcG9ydHtnZXRDb21taXR0ZWRWYWx1ZSBhcyBsLHNldENoaWxkUGFydFZhbHVlIGFzIG8saW5zZXJ0UGFydCBhcyBpLHJlbW92ZVBhcnQgYXMgbixzZXRDb21taXR0ZWRWYWx1ZSBhcyBmfWZyb21cIi4uL2RpcmVjdGl2ZS1oZWxwZXJzLmpzXCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmNvbnN0IHU9KGUscyx0KT0+e2NvbnN0IHI9bmV3IE1hcDtmb3IobGV0IGw9cztsPD10O2wrKylyLnNldChlW2xdLGwpO3JldHVybiByfSxjPXMoY2xhc3MgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLGUudHlwZSE9PXIuQ0hJTEQpdGhyb3cgRXJyb3IoXCJyZXBlYXQoKSBjYW4gb25seSBiZSB1c2VkIGluIHRleHQgZXhwcmVzc2lvbnNcIil9ZHQoZSxzLHQpe2xldCByO3ZvaWQgMD09PXQ/dD1zOnZvaWQgMCE9PXMmJihyPXMpO2NvbnN0IGw9W10sbz1bXTtsZXQgaT0wO2Zvcihjb25zdCBzIG9mIGUpbFtpXT1yP3IocyxpKTppLG9baV09dChzLGkpLGkrKztyZXR1cm57dmFsdWVzOm8sa2V5czpsfX1yZW5kZXIoZSxzLHQpe3JldHVybiB0aGlzLmR0KGUscyx0KS52YWx1ZXN9dXBkYXRlKHMsW3QscixjXSl7dmFyIGQ7Y29uc3QgYT1sKHMpLHt2YWx1ZXM6cCxrZXlzOnZ9PXRoaXMuZHQodCxyLGMpO2lmKCFBcnJheS5pc0FycmF5KGEpKXJldHVybiB0aGlzLnV0PXYscDtjb25zdCBoPW51bGwhPT0oZD10aGlzLnV0KSYmdm9pZCAwIT09ZD9kOnRoaXMudXQ9W10sbT1bXTtsZXQgeSx4LGo9MCxrPWEubGVuZ3RoLTEsdz0wLEE9cC5sZW5ndGgtMTtmb3IoO2o8PWsmJnc8PUE7KWlmKG51bGw9PT1hW2pdKWorKztlbHNlIGlmKG51bGw9PT1hW2tdKWstLTtlbHNlIGlmKGhbal09PT12W3ddKW1bd109byhhW2pdLHBbd10pLGorKyx3Kys7ZWxzZSBpZihoW2tdPT09dltBXSltW0FdPW8oYVtrXSxwW0FdKSxrLS0sQS0tO2Vsc2UgaWYoaFtqXT09PXZbQV0pbVtBXT1vKGFbal0scFtBXSksaShzLG1bQSsxXSxhW2pdKSxqKyssQS0tO2Vsc2UgaWYoaFtrXT09PXZbd10pbVt3XT1vKGFba10scFt3XSksaShzLGFbal0sYVtrXSksay0tLHcrKztlbHNlIGlmKHZvaWQgMD09PXkmJih5PXUodix3LEEpLHg9dShoLGosaykpLHkuaGFzKGhbal0pKWlmKHkuaGFzKGhba10pKXtjb25zdCBlPXguZ2V0KHZbd10pLHQ9dm9pZCAwIT09ZT9hW2VdOm51bGw7aWYobnVsbD09PXQpe2NvbnN0IGU9aShzLGFbal0pO28oZSxwW3ddKSxtW3ddPWV9ZWxzZSBtW3ddPW8odCxwW3ddKSxpKHMsYVtqXSx0KSxhW2VdPW51bGw7dysrfWVsc2UgbihhW2tdKSxrLS07ZWxzZSBuKGFbal0pLGorKztmb3IoO3c8PUE7KXtjb25zdCBlPWkocyxtW0ErMV0pO28oZSxwW3ddKSxtW3crK109ZX1mb3IoO2o8PWs7KXtjb25zdCBlPWFbaisrXTtudWxsIT09ZSYmbihlKX1yZXR1cm4gdGhpcy51dD12LGYocyxtKSxlfX0pO2V4cG9ydHtjIGFzIHJlcGVhdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sLCBzdmcsIGNzcyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBpZkRlZmluZWQgfSBmcm9tICdsaXQvZGlyZWN0aXZlcy9pZi1kZWZpbmVkLmpzJztcbmltcG9ydCB7IHJlcGVhdCB9IGZyb20gJ2xpdC9kaXJlY3RpdmVzL3JlcGVhdC5qcyc7XG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcbmltcG9ydCAnLi9zYy1wb3NpdGlvbi1zdXJmYWNlJztcblxuY2xhc3MgU2NEb3RNYXAgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICB4UmFuZ2U6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGF0dHJpYnV0ZTogJ3gtcmFuZ2UnLFxuICAgICAgfSxcbiAgICAgIHlSYW5nZToge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgYXR0cmlidXRlOiAneS1yYW5nZScsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGhhc0NoYW5nZWQobmV3VmFsLCBvbGRWYWwpIHsgcmV0dXJuIHRydWUgfSxcbiAgICAgIH0sXG4gICAgICBtYXhTaXplOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgYXR0cmlidXRlOiAnbWF4LXNpemUnLFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgYXR0cmlidXRlOiAnY29sb3InXG4gICAgICB9LFxuICAgICAgcmFkaXVzOiB7IC8vIGluIHBpeGVscyAocHJlY2VkZW5jZSBvdmVyIHJhZGl1c1JlbClcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBhdHRyaWJ1dGU6ICdyYWRpdXMnXG4gICAgICB9LFxuICAgICAgcmFkaXVzUmVsOiB7IC8vIGFjY29yZGluZyB0byByYW5nZXNcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBhdHRyaWJ1dGU6ICdyYWRpdXMtcmVsJ1xuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBhdHRyaWJ1dGU6ICdvcGFjaXR5J1xuICAgICAgfSxcblxuICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgYXR0cmlidXRlOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZE9wYWNpdHk6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBhdHRyaWJ1dGU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmRJbWFnZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGF0dHJpYnV0ZTogJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgICAgfSxcblxuICAgICAgY2FwdHVyZUV2ZW50czoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBhdHRyaWJ1dGU6ICdjYXB0dXJlLWV2ZW50cycsXG4gICAgICB9LFxuICAgICAgcGVyc2lzdEV2ZW50czoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBhdHRyaWJ1dGU6ICdwZXJzaXN0LWV2ZW50cycsXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gZGl2IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICBzYy1wb3NpdGlvbi1zdXJmYWNlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICB0aGlzLmNvbG9yID0gdGhlbWVbJy0tY29sb3Itc2Vjb25kYXJ5LTInXTtcbiAgICB0aGlzLmRlZmF1bHRSYWRpdXMgPSA1O1xuICAgIHRoaXMucmFkaXVzID0gbnVsbDtcbiAgICB0aGlzLnJhZGl1c1JlbCA9IG51bGw7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcblxuICAgIHRoaXMubWF4U2l6ZSA9ICtJbmZpbml0eTtcblxuICAgIHRoaXMueFJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMueVJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMud2lkdGggPSAzMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDA7XG5cbiAgICB0aGlzLmNhcHR1cmVFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLnBlcnNpc3RFdmVudHMgPSBmYWxzZTtcblxuICAgIC8vIGNhbiBiZSBvdmVycmlkZW4gdG8gJ25vbmUnXG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSB0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTEnXTtcbiAgICB0aGlzLmJhY2tncm91bmRPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9ICcnO1xuXG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgdXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKFxuICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCd3aWR0aCcpICB8fFxuICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdoZWlnaHQnKSB8fFxuICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCd4UmFuZ2UnKSB8fFxuICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCd5UmFuZ2UnKVxuICAgICkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHN1cGVyLnVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICBjb25zdCB4RGVsdGEgPSBNYXRoLmFicyh0aGlzLnhSYW5nZVsxXSAtIHRoaXMueFJhbmdlWzBdKTtcbiAgICAgIGNvbnN0IHlEZWx0YSA9IE1hdGguYWJzKHRoaXMueVJhbmdlWzFdIC0gdGhpcy55UmFuZ2VbMF0pO1xuXG4gICAgICAvLyBkZWZpbmUgd2hpY2ggc2lkZSBpcyB0aCBsaW1pdGluZyBvbmVcbiAgICAgIGNvbnN0IGRlbHRhUmF0aW8gPSB4RGVsdGEgLyB5RGVsdGE7XG4gICAgICBjb25zdCBweFJhdGlvID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuXG4gICAgICBsZXQgbGltaXRpbmdTaXplO1xuICAgICAgbGV0IGxpbWl0aW5nRGVsdGE7XG5cbiAgICAgIGlmIChkZWx0YVJhdGlvID4gcHhSYXRpbykge1xuICAgICAgICBsaW1pdGluZ1NpemUgPSB0aGlzLndpZHRoO1xuICAgICAgICBsaW1pdGluZ0RlbHRhID0geERlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXRpbmdTaXplID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGxpbWl0aW5nRGVsdGEgPSB5RGVsdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmluZSBzdmcgc2l6ZVxuICAgICAgdGhpcy5zdmdXaWR0aCA9IGxpbWl0aW5nU2l6ZSAvIGxpbWl0aW5nRGVsdGEgKiB4RGVsdGE7XG4gICAgICB0aGlzLnN2Z0hlaWdodCA9IGxpbWl0aW5nU2l6ZSAvIGxpbWl0aW5nRGVsdGEgKiB5RGVsdGE7XG5cbiAgICAgIC8vIHgycHggYW5kIHkycHggc2hvdWxkIHNoYXJlIHRoZSBzYW1lIHNsb3BlIChhKSwgb25seSBvZmZzZXQgKGIpIHNob3VsZCBkaWZmZXJcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc3ZnV2lkdGggLyAodGhpcy54UmFuZ2VbMV0gLSB0aGlzLnhSYW5nZVswXSk7XG4gICAgICAgIGNvbnN0IGIgPSAtICh0aGlzLnhSYW5nZVswXSAqIGEpO1xuICAgICAgICB0aGlzLngycHggPSB4ID0+IGEgKiB4ICsgYjtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zdmdIZWlnaHQgLyAodGhpcy55UmFuZ2VbMV0gLSB0aGlzLnlSYW5nZVswXSk7XG4gICAgICAgIGNvbnN0IGIgPSAtICh0aGlzLnlSYW5nZVswXSAqIGEpO1xuICAgICAgICB0aGlzLnkycHggPSB5ID0+IGEgKiB5ICsgYjtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHJhZGl1cyBhcyB3ZSBkb24ndCB3YW50IGFueSBvZmZzZXQsIHdlIGp1c3QgcGljayB0aGUgc2xvcGUgb2Ygb25lIG9mIHRoZSBvdGhlcnNcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYSA9IE1hdGguYWJzKHRoaXMuc3ZnSGVpZ2h0IC8gKHRoaXMueVJhbmdlWzFdIC0gdGhpcy55UmFuZ2VbMF0pKTtcbiAgICAgICAgdGhpcy5yYWRpdXMycHggPSByID0+IGEgKiByO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBkb3RzUmFkaXVzID0gdGhpcy5kZWZhdWx0UmFkaXVzO1xuXG4gICAgaWYgKHRoaXMucmFkaXVzKSB7XG4gICAgICBkb3RzUmFkaXVzID0gdGhpcy5yYWRpdXNcbiAgICB9IGVsc2UgaWYgKHRoaXMucmFkaXVzUmVsKSB7XG4gICAgICBkb3RzUmFkaXVzID0gdGhpcy5yYWRpdXMycHgodGhpcy5yYWRpdXNSZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT1cIndpZHRoOiAke3RoaXMud2lkdGh9cHg7IGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcIj5cbiAgICAgICAgJHt0aGlzLmNhcHR1cmVFdmVudHNcbiAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICA8c2MtcG9zaXRpb24tc3VyZmFjZVxuICAgICAgICAgICAgICB3aWR0aD1cIiR7dGhpcy5zdmdXaWR0aH1cIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIke3RoaXMuc3ZnSGVpZ2h0fVwiXG4gICAgICAgICAgICAgIHgtcmFuZ2U9XCIke0pTT04uc3RyaW5naWZ5KHRoaXMueFJhbmdlKX1cIlxuICAgICAgICAgICAgICB5LXJhbmdlPVwiJHtKU09OLnN0cmluZ2lmeSh0aGlzLnlSYW5nZSl9XCJcbiAgICAgICAgICAgICAgQGlucHV0PVwiJHt0aGlzLnVwZGF0ZVBvc2l0aW9uc31cIlxuICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgIGxlZnQ6ICR7KHRoaXMud2lkdGggLSB0aGlzLnN2Z1dpZHRoKSAvIDJ9cHg7XG4gICAgICAgICAgICAgICAgdG9wOiAkeyh0aGlzLmhlaWdodCAtIHRoaXMuc3ZnSGVpZ2h0KSAvIDJ9cHg7XCJcbiAgICAgICAgICAgID48L3NjLXBvc2l0aW9uLXN1cmZhY2U+XG4gICAgICAgICAgYFxuICAgICAgICAgIDogJydcbiAgICAgICAgfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgIHdpZHRoOiAke3RoaXMuc3ZnV2lkdGh9cHg7XG4gICAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5zdmdIZWlnaHR9cHg7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICBsZWZ0OiAkeyh0aGlzLndpZHRoIC0gdGhpcy5zdmdXaWR0aCkgLyAyfXB4O1xuICAgICAgICAgICAgdG9wOiAkeyh0aGlzLmhlaWdodCAtIHRoaXMuc3ZnSGVpZ2h0KSAvIDJ9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoaXMuYmFja2dyb3VuZENvbG9yfTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6ICR7dGhpcy5iYWNrZ3JvdW5kSW1hZ2UgIT09ICcnID8gYHVybCgke3RoaXMuYmFja2dyb3VuZEltYWdlfSlgOiAnbm9uZSd9O1xuICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgICAgICAgICBvcGFjaXR5OiAke3RoaXMuYmFja2dyb3VuZE9wYWNpdHl9O1xuICAgICAgICAgIFwiXG4gICAgICAgID48L2Rpdj5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgICB3aWR0aDogJHt0aGlzLnN2Z1dpZHRofXB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuc3ZnSGVpZ2h0fXB4O1xuICAgICAgICAgICAgbGVmdDogJHsodGhpcy53aWR0aCAtIHRoaXMuc3ZnV2lkdGgpIC8gMn1weDtcbiAgICAgICAgICAgIHRvcDogJHsodGhpcy5oZWlnaHQgLSB0aGlzLnN2Z0hlaWdodCkgLyAyfXB4O1xuICAgICAgICAgIFwiXG4gICAgICAgICAgdmlld0JveD1cIjAgMCAke3RoaXMuc3ZnV2lkdGh9ICR7dGhpcy5zdmdIZWlnaHR9XCJcbiAgICAgICAgPlxuXG4gICAgICAgICAgPCEtLSBkb3RzIC0tPlxuICAgICAgICAgICR7cmVwZWF0KHRoaXMudmFsdWUsIGQgPT4gYCR7ZC54fS0ke2QueX1gLCBkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdmdgPGNpcmNsZVxuICAgICAgICAgICAgICByPVwiJHtkb3RzUmFkaXVzfVwiXG4gICAgICAgICAgICAgIGZpbGw9XCIke2QuY29sb3IgfHwgdGhpcy5jb2xvcn1cIlxuICAgICAgICAgICAgICBjeD1cIiR7dGhpcy54MnB4KGQueCl9XCJcbiAgICAgICAgICAgICAgY3k9XCIke3RoaXMueTJweChkLnkpfVwiXG4gICAgICAgICAgICAgIHN0eWxlPVwicG9pbnRlci1ldmVudDogbm9uZTsgZmlsbC1vcGFjaXR5OiAke3RoaXMub3BhY2l0eX1cIlxuICAgICAgICAgICAgPjwvY2lyY2xlPmBcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9zdmc+XG5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICB1cGRhdGVQb3NpdGlvbnMoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAvLyBpZ25vcmUgbW91c2V1cCBhbmQgdG91Y2hlbmQgZXZlbnRzXG4gICAgaWYgKHRoaXMucGVyc2lzdEV2ZW50cyAmJiBlLmRldGFpbC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0aGUgcG9pbnRlcklkIGZyb20gb3JpZ2luIGV2ZW50XG4gICAgY29uc3QgdmFsdWUgPSBlLmRldGFpbC52YWx1ZS5tYXAocG9pbnRlciA9PiB7XG4gICAgICAvLyBrZWVwIGluIGJvdW5kYXJpZXNcbiAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbih0aGlzLnhSYW5nZVswXSwgdGhpcy54UmFuZ2VbMV0pO1xuICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KHRoaXMueFJhbmdlWzBdLCB0aGlzLnhSYW5nZVsxXSk7XG4gICAgICBjb25zdCBtaW5ZID0gTWF0aC5taW4odGhpcy55UmFuZ2VbMF0sIHRoaXMueVJhbmdlWzFdKTtcbiAgICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heCh0aGlzLnlSYW5nZVswXSwgdGhpcy55UmFuZ2VbMV0pO1xuICAgICAgY29uc3QgeCA9IE1hdGgubWluKG1heFgsIE1hdGgubWF4KG1pblgsIHBvaW50ZXIueCkpO1xuICAgICAgY29uc3QgeSA9IE1hdGgubWluKG1heFksIE1hdGgubWF4KG1pblksIHBvaW50ZXIueSkpO1xuXG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSk7XG5cbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heFNpemUpIHtcbiAgICAgIHZhbHVlLnNwbGljZSh0aGlzLm1heFNpemUpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdpbnB1dCcsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbDogeyB2YWx1ZTogdGhpcy52YWx1ZSB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjLWRvdC1tYXAnLCBTY0RvdE1hcCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjRG90TWFwO1xuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCwgY3NzIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSAnbGl0L2RpcmVjdGl2ZXMvY2xhc3MtbWFwLmpzJztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuaW1wb3J0IHsgZm9udEZhbWlseSwgZm9udFNpemUsIHRoZW1lIH0gZnJvbSAnLi9zdHlsZXMuanMnO1xuXG5jb25zdCBBdWRpb0NvbnRleHQgPSAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbmNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcblxuLyoqXG4gKiBAdG9kbyAtIGVuYWJsZSBpbnRlZ3JhdGlvbiBpbnNpZGUgYW4gdXBsb2FkIHN5c3RlbVxuICovXG5jbGFzcyBTY0RyYWdORHJvcCBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgICBoZWlnaHQ6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgICBsYWJlbDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICAgIHN0YXR1czogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgIH1cblxuICAgICAgLmRyb3Atem9uZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMSddfTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcbiAgICAgIH1cblxuICAgICAgLmRyb3Atem9uZS5kcmFnIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICB9XG5cbiAgICAgIC5kcm9wLXpvbmUucHJvY2Vzc2luZyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3Itc2Vjb25kYXJ5LTMnXX07XG4gICAgICB9XG4gICAgYFxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMud2lkdGggPSAzMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAyMDA7XG4gICAgdGhpcy5sYWJlbCA9ICdEcmFnIGFuZCBkcm9wIEZpbGVzJztcbiAgICB0aGlzLnN0YXR1cyA9ICdpZGxlJzsgLy8gJ2RyYWcnIHwgJ2RlY29kaW5nJ1xuXG4gICAgdGhpcy5mb3JtYXQgPSAnbG9hZCc7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHtcbiAgICAgICdkcm9wLXpvbmUnOiB0cnVlLFxuICAgICAgJ2RyYWcnOiB0aGlzLnN0YXR1cyA9PT0gJ2RyYWcnLFxuICAgICAgJ3Byb2Nlc3NpbmcnOiB0aGlzLnN0YXR1cyA9PT0gJ3Byb2Nlc3NpbmcnLFxuICAgIH07XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXYgY2xhc3M9XCIke2NsYXNzTWFwKGNsYXNzZXMpfVwiXG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgIFwiXG4gICAgICAgIEBkcmFnb3Zlcj1cIiR7dGhpcy5vbkRyYWdPdmVyfVwiXG4gICAgICAgIEBkcmFnbGVhdmU9XCIke3RoaXMub25EcmFnTGVhdmV9XCJcbiAgICAgICAgQGRyb3A9XCIke3RoaXMub25Ecm9wfVwiXG4gICAgICA+JHt0aGlzLnN0YXR1cyAhPT0gJ3Byb2Nlc3NpbmcnID8gdGhpcy5sYWJlbCA6ICdQcm9jZXNzaW5nLi4uJ308L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgb25EcmFnT3ZlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG5cbiAgICB0aGlzLnN0YXR1cyA9ICdkcmFnJztcbiAgfVxuXG4gIG9uRHJhZ0xlYXZlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLnN0YXR1cyA9ICdpZGxlJztcbiAgfVxuXG4gIG9uRHJvcChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5zdGF0dXMgPSAncHJvY2Vzc2luZyc7XG5cbiAgICBpZiAodGhpcy5mb3JtYXQgPT09ICdsb2FkJykge1xuICAgICAgY29uc3QgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgaWYgKC9eYXVkaW8vLnRlc3QoZmlsZS50eXBlKSkge1xuICAgICAgICAgIHR5cGUgPSAnYXVkaW8nO1xuICAgICAgICB9IGVsc2UgaWYgKC9qc29uJC8udGVzdChmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgdHlwZSA9ICdqc29uJztcbiAgICAgICAgfSBlbHNlIGlmICgvXmltYWdlLy50ZXN0KGZpbGUudHlwZSkpIHtcbiAgICAgICAgICB0eXBlID0gJ2ltYWdlJztcbiAgICAgICAgfSBlbHNlIGlmICgvXnRleHQvLnRlc3QoZmlsZS50eXBlKSkge1xuICAgICAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9ICd1bmtub3duJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ZpbGUubmFtZV0gPSBidWZmZXI7XG4gICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ZpbGUubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnanNvbic6IHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tmaWxlLm5hbWVdID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICAgICAgY29uc3QgJGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAkaW1nLnNyYyA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgIHJlc3VsdHNbZmlsZS5uYW1lXSA9ICRpbWc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tmaWxlLm5hbWVdID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbZmlsZS5uYW1lXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50ZXIgKz0gMTtcblxuICAgICAgICAgIGlmIChjb3VudGVyID09PSBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHRzO1xuXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLnZhbHVlIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ2lkbGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc2MtZHJhZ25kcm9wJywgU2NEcmFnTkRyb3ApO1xuXG5leHBvcnQgZGVmYXVsdCBTY0RyYWdORHJvcDtcbiIsImltcG9ydCB7IGh0bWwsIHN2ZywgY3NzIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSAnLi9zdHlsZXMuanMnO1xuaW1wb3J0IFNjRWxlbWVudCBmcm9tICcuL1NjRWxlbWVudC5qcyc7XG5cbi8qKlxuICogRHNpcGxheSBtYXRyaXgsIHRoZSBkYXRhIHNob3VsZCBmb2xsb3cgYSByb3ctZmlyc3QgY29udmVudGlvbiB3aXRoIHRoZSAwIGluZGV4XG4gKiBkZWluZyBkaXNwbGF5ZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbWF0cml4XG4gKiBgYGBcbiAqIFtcbiAqICAgIFswLCAwLCAwLCAxXSxgXG4gKiAgICBbMCwgMSwgMCwgMF0sYFxuICogICAgLy8gLi4uXG4gKiBdXG4gKi9cbmNsYXNzIFNjTWF0cml4IGV4dGVuZHMgU2NFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogeyB0eXBlOiBOdW1iZXIgfSxcbiAgICAgIGhlaWdodDogeyB0eXBlOiBOdW1iZXIgfSxcbiAgICAgIGNvbHVtbnM6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgICByb3dzOiB7IHR5cGU6IE51bWJlciB9LFxuICAgICAgLy8gQG5vdGUgLSBgY2VsbFZhbHVlc2AgaXMgYmFkIG5hbWUuLi4sIGBlbnRyaWVzYCBiZXR0ZXIgP1xuICAgICAgLy8gQHRvZG8gLSB1cGRhdGVzIHZhbHVlcyB3aGVuIHVwZGF0ZWRcbiAgICAgIGVudHJpZXM6IHsgdHlwZTogQXJyYXkgfSxcbiAgICAgIHZhbHVlOiB7IHR5cGU6IEFycmF5IH0sXG4gICAgICByZXNldDogeyB0eXBlOiBCb29sZWFuIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGZvbnQtc2l6ZTogMCAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICBzdmcge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMSddfTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICB9XG4gICAgYDtcbiAgfVxuXG4gIHNldCByb3dzKHZhbHVlKSB7XG4gICAgdGhpcy5fcm93cyA9IHZhbHVlO1xuICAgIHRoaXMuX3Jlc2l6ZU1hdHJpeCgpO1xuICB9XG5cbiAgZ2V0IHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3M7XG4gIH1cblxuICBzZXQgY29sdW1ucyh2YWx1ZSkge1xuICAgIHRoaXMuX2NvbHVtbnMgPSB2YWx1ZTtcbiAgICB0aGlzLl9yZXNpemVNYXRyaXgoKTtcbiAgfVxuXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIGlmIHdlIHJlcGxhY2UgdGhlIGludGVybmFsIGRhdGEgbWF0cml4IHdpdGggYW4gZXh0ZXJuYWwgb25lLCB3ZSB3YW50XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF0cml4IGRlc2NyaXB0aW9uIGNvbnNpc3RlbnRcbiAgICB0aGlzLl9yb3dzID0gdGhpcy5fdmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl92YWx1ZVswXS5sZW5ndGg7XG4gICAgLy8gYHJlcXVlc3RVcGRhdGVgIGJlY2F1c2UgaW4gbWFueSBjYXNlcyBgdmFsdWVgIG1pZ2h0IGJlIHRoZSBzYW1lIGluc3RhbmNlXG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgc2V0IHJlc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgYWN0dWFsbHkgZG9uJ3QgY2FyZSBvZiB0aGUgdmFsdWVcbiAgICB0aGlzLl92YWx1ZS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3dbaV0gPSB0aGlzLl9lbnRyaWVzWzBdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdENoYW5nZSgpO1xuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHJlc2V0KCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQgZW50cmllcyhlbnRyaWVzKSB7XG4gICAgdGhpcy5fZW50cmllcyA9IGVudHJpZXM7XG5cbiAgICAvLyBjaGVjayBleGlzdGluZyB2YWx1ZXMgYWdhaW5zdCBuZXcgZW50cmllc1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5fdmFsdWUubGVuZ3RoOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMuX3ZhbHVlW3ldO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSByb3dbeF07XG4gICAgICAgIC8vIGZpbmQgY2xvc2VzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5fZW50cmllcy5pbmRleE9mKGN1cnJlbnRWYWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gQG5vdGUgb25gcmVkdWNlYCAtIGJ5IGRlZmF1bHQgYWNjdW11bGF0b3IgKGhlcmUgYGFgKSBpcyB0aGUgZmlyc3RcbiAgICAgICAgICAvLyBlbGVtZW50IG9mIHRoZSBhcnJheVxuICAgICAgICAgIGNvbnN0IGNsb3Nlc3QgPSB0aGlzLmVudHJpZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYiAtIGN1cnJlbnRWYWx1ZSkgPCBNYXRoLmFicyhhIC0gY3VycmVudFZhbHVlKSA/IGIgOiBhO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fdmFsdWVbeV1beF0gPSBjbG9zZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdENoYW5nZSgpO1xuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJpZXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICB0aGlzLmhlaWdodCA9IDE1MDtcbiAgICB0aGlzLl92YWx1ZSA9IFtdO1xuXG4gICAgdGhpcy5fZW50cmllcyA9IFswLCAxXTtcblxuICAgIHRoaXMuY29sdW1ucyA9IDg7XG4gICAgdGhpcy5yb3dzID0gNDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjZWxsV2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy5jb2x1bW5zO1xuICAgIGNvbnN0IGNlbGxIZWlnaHQgPSB0aGlzLmhlaWdodCAvIHRoaXMucm93cztcblxuICAgIGNvbnN0IG1pblZhbHVlID0gdGhpcy5fZW50cmllc1swXTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IHRoaXMuX2VudHJpZXNbdGhpcy5fZW50cmllcy5sZW5ndGggLSAxXTtcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN2Z1xuICAgICAgICBzdHlsZT1cIndpZHRoOiAke3RoaXMud2lkdGh9cHg7IGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcIlxuICAgICAgICBAY29udGV4dG1lbnU9XCIke3RoaXMuX3ByZXZlbnRDb250ZXh0TWVudX1cIlxuICAgICAgPlxuICAgICAgICAke3RoaXMudmFsdWUubWFwKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgeSA9IGNlbGxIZWlnaHQgKiByb3dJbmRleDtcblxuICAgICAgICAgIHJldHVybiByb3cubWFwKCh2YWx1ZSwgY29sdW1uSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBjZWxsV2lkdGggKiBjb2x1bW5JbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdmdgXG4gICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgc3Ryb2tlPVwiIzc4Nzg3OFwiXG4gICAgICAgICAgICAgICAgZmlsbD1cIiNmZmZmZmZcIlxuICAgICAgICAgICAgICAgIGZpbGwtb3BhY2l0eT1cIiR7b3BhY2l0eX1cIlxuICAgICAgICAgICAgICAgIHdpZHRoPVwiJHtjZWxsV2lkdGh9XCJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9XCIke2NlbGxIZWlnaHR9XCJcbiAgICAgICAgICAgICAgICB4PVwiJHt4fVwiXG4gICAgICAgICAgICAgICAgeT1cIiR7eX1cIlxuICAgICAgICAgICAgICAgIGRhdGEtcm93LWluZGV4PVwiJHtyb3dJbmRleH1cIlxuICAgICAgICAgICAgICAgIGRhdGEtY29sdW1uLWluZGV4PVwiJHtjb2x1bW5JbmRleH1cIlxuICAgICAgICAgICAgICAgIEBtb3VzZWRvd249XCIke3RoaXMuX3VwZGF0ZUNlbGx9XCJcbiAgICAgICAgICAgICAgPjwvcmVjdD5cbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zdmc+XG4gICAgYDtcbiAgfVxuXG4gIF9yZXNpemVNYXRyaXgoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gcmVtb3ZlIGFkZGl0aW9ubmFsIHJvd3NcbiAgICBmb3IgKGxldCB5ID0gdmFsdWUubGVuZ3RoIC0gMTsgeSA+PSB0aGlzLnJvd3M7IHktLSkge1xuICAgICAgdmFsdWUuc3BsaWNlKHksIDEpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhZGRpdGlvbm5hbCBjb2x1bW5zXG4gICAgdmFsdWUuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgZm9yIChsZXQgeCA9IHJvdy5sZW5ndGggLSAxOyB4ID49IHRoaXMuY29sdW1uczsgeC0tKSB7XG4gICAgICAgIHJvdy5zcGxpY2UoeCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgbmV3IHJvd3MgYW5kIGNvbHVtbnNcbiAgICBjb25zdCBjdXJyZW50TnVtUm93cyA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5yb3dzOyB5KyspIHtcbiAgICAgIGlmICh5IDwgY3VycmVudE51bVJvd3MpIHtcblxuICAgICAgICAvLyBjaGVjayBfcm93c1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgeCA9IHJvdy5sZW5ndGg7IHggPCB0aGlzLmNvbHVtbnM7IHgrKykge1xuICAgICAgICAgICAgcm93W3hdID0gdGhpcy5fZW50cmllc1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IHJvd1xuICAgICAgICBjb25zdCByb3cgPSBuZXcgQXJyYXkodGhpcy5jb2x1bW5zKS5maWxsKHRoaXMuX2VudHJpZXNbMF0pO1xuICAgICAgICB2YWx1ZVt5XSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIF91cGRhdGVDZWxsKGUpIHtcbiAgICBjb25zdCB7IHJvd0luZGV4LCBjb2x1bW5JbmRleCB9ID0gZS50YXJnZXQuZGF0YXNldDtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9lbnRyaWVzLmluZGV4T2YodGhpcy52YWx1ZVtyb3dJbmRleF1bY29sdW1uSW5kZXhdKTtcbiAgICAvLyBoYW5kbGUgc2l0dWF0aW9ucyB3aGVyZSBfZW50cmllcyBhcyBjaGFuZ2VkIGluIGJldHdlZW4gdHdvIGludGVyYWN0aW9uc1xuICAgIGNvbnN0IG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCA9PT0gLTEgPyAwIDogKGN1cnJlbnRJbmRleCArIDEpICUgdGhpcy5fZW50cmllcy5sZW5ndGg7XG5cbiAgICB0aGlzLnZhbHVlW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPSB0aGlzLl9lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0aGlzLl9lbWl0Q2hhbmdlKCk7XG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICBfZW1pdENoYW5nZSgpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLnZhbHVlIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc2MtbWF0cml4JywgU2NNYXRyaXgpO1xuXG5leHBvcnQgZGVmYXVsdCBTY01hdHJpeDtcbiIsImltcG9ydCB7IGh0bWwsIGNzcywgc3ZnLCBub3RoaW5nIH0gZnJvbSAnbGl0JztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuaW1wb3J0IHsgdGhlbWUsIGZvbnRTaXplIH0gZnJvbSAnLi9zdHlsZXMuanMnO1xuXG5jbGFzcyBTY0NvbnRleHRNZW51IGV4dGVuZHMgU2NFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogeyB0eXBlOiBBcnJheSB9LCAvLyBbeyBhY3Rpb24sIGxhYmVsIH0sIC4uLl1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgZm9udC1zaXplOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIGhlaWdodDogMDtcbiAgICAgICAgd2lkdGg6IDA7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLnNob3cpIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgfVxuXG4gICAgICBuYXYge1xuICAgICAgICB3aWR0aDogMjUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDBweCAxMHB4IDBweCByZ2JhKDAsMCwwLDAuMiksIDBweCAwcHggM3B4IDBweCByZ2JhKDI1NSwyNTUsMjU1LDAuOCkgaW5zZXQ7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIH1cblxuICAgICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDEycHggMTBweDtcbiAgICAgIH1cblxuICAgICAgbGkge1xuICAgICAgICBmb250LXNpemU6ICR7Zm9udFNpemV9O1xuICAgICAgICBwYWRkaW5nOiA0cHggOHB4O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgfVxuXG4gICAgICBsaTpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYig5NywgMTQxLCAyMDEpO1xuICAgICAgfVxuXG4gICAgICBsaTphY3RpdmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoOTcsIDE0MSwgMjAxLCAwLjUpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IFtdO1xuXG4gICAgdGhpcy5fcG9zWCA9IDA7XG4gICAgdGhpcy5fcG9zWSA9IDA7XG5cbiAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxuYXZcbiAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICB0b3A6ICR7dGhpcy5fcG9zWX1weDtcbiAgICAgICAgICBsZWZ0OiAke3RoaXMuX3Bvc1h9cHg7XG4gICAgICAgIFwiXG4gICAgICA+XG4gICAgICAgIDx1bD5cbiAgICAgICAgJHt0aGlzLnZhbHVlLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gaHRtbGBcbiAgICAgICAgICAgIDxsaVxuICAgICAgICAgICAgICBAY2xpY2s9XCIke2UgPT4gdGhpcy50cmlnZ2VyRXZlbnQoZW50cnkuYWN0aW9uKX1cIlxuICAgICAgICAgICAgPiR7ZW50cnkubGFiZWx9PC9saT5cbiAgICAgICAgICBgO1xuICAgICAgICB9KX1cbiAgICAgICAgPHA+XG4gICAgICA8L25hdj5cbiAgICBgXG4gIH1cblxuICBzaG93KGUpIHtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGUpO1xuICAgIHRoaXMuX3Bvc1ggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5fcG9zWSA9IGUuY2xpZW50WTtcblxuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuXG4gICAgLy8gdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICB0cmlnZ2VyRXZlbnQoYWN0aW9uKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2lucHV0Jywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiBhY3Rpb24gfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy1jb250ZXh0LW1lbnUnLCBTY0NvbnRleHRNZW51KTtcblxuZXhwb3J0IGRlZmF1bHQgU2NDb250ZXh0TWVudTtcbiIsImltcG9ydCB7IGh0bWwsIGNzcywgc3ZnLCBub3RoaW5nIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSAnbGl0L2RpcmVjdGl2ZXMvY2xhc3MtbWFwLmpzJztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuaW1wb3J0IHsgdGhlbWUsIGZvbnRTaXplLCBhcnJvd1JpZ2h0LCBhcnJvd0Rvd24gfSBmcm9tICcuL3N0eWxlcy5qcyc7XG5cbmNsYXNzIFNjRmlsZVRyZWUgZXh0ZW5kcyBTY0VsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB7IHR5cGU6IE51bWJlciB9LFxuICAgICAgaGVpZ2h0OiB7IHR5cGU6IE51bWJlciB9LFxuICAgICAgdmFsdWU6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgZm9udC1zaXplOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS00J119O1xuICAgICAgfVxuXG4gICAgICBuYXYge1xuICAgICAgICAvKmJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS00J119OyovXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlYmVkZWY7XG4gICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgIH1cblxuICAgICAgdWwge1xuICAgICAgICBmb250LXNpemU6ICR7Zm9udFNpemV9O1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICB9XG5cbiAgICAgIGxpIHtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDIycHg7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICB9XG5cbiAgICAgIGxpIHNwYW4ge1xuICAgICAgICBoZWlnaHQ6IDIycHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMnB4O1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIGxpIC5ob3ZlciwgbGkgLmhvdmVyLWJnIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGhlaWdodDogMjJweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgICBsaSAuY29udGVudCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgIH1cblxuICAgICAgbGkgLmhvdmVyIHtcbiAgICAgICAgei1pbmRleDogMjtcbiAgICAgIH1cblxuICAgICAgbGkgLmhvdmVyOmhvdmVyICsgLmhvdmVyLWJnIHtcbiAgICAgICAgLypiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lWyctLWNvbG9yLXByaW1hcnktMyddfTsqL1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGJkZGUwO1xuICAgICAgfVxuXG4gICAgICBsaS5hY3RpdmUgPiAuaG92ZXItYmcsIGxpLmFjdGl2ZSAuaG92ZXI6aG92ZXIgKyAuaG92ZXItYmcge1xuICAgICAgICAvKmJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0yJ119OyovXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjNmNiZDI7XG4gICAgICB9XG5cbiAgICAgIGxpLmRpcmVjdG9yeSArIGxpIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgbGkub3BlbiArIGxpIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cblxuICAgICAgLypsaS5vcGVuID4gdWwge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH0qL1xuXG4gICAgICBsaS5kaXJlY3Rvcnk6OmJlZm9yZSB7XG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7YXJyb3dSaWdodH0pO1xuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIDUwJTtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAxNHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAyMnB4O1xuICAgICAgICBoZWlnaHQ6IDIycHg7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIC8qbGVmdDogLTIycHg7Ki9cbiAgICAgIH1cblxuICAgICAgbGkuZGlyZWN0b3J5Lm9wZW46OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgke2Fycm93RG93bn0pO1xuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAyMCUgNzAlO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICB0aGlzLmhlaWdodCA9IDIwMDtcblxuICAgIHRoaXMuX2N1cnJlbnRBY3RpdmUgPSBudWxsO1xuICB9XG5cbiAgX3JlbmRlck5vZGUobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBub3RoaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzZXMgPSB7XG4gICAgICBkaXJlY3Rvcnk6IChub2RlLnR5cGUgPT09ICdkaXJlY3RvcnknKSxcbiAgICAgIG9wZW46IChkZXB0aCA9PT0gMCksXG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8bGlcbiAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICB0ZXh0LWluZGVudDogJHtkZXB0aCAqIDIwfXB4O1xuICAgICAgICBcIlxuICAgICAgICBjbGFzcz1cIiR7Y2xhc3NNYXAoY2xhc3Nlcyl9XCJcbiAgICAgICAgQGNsaWNrPVwiJHtlID0+IHRoaXMuX29uSXRlbUNsaWNrKGUsIG5vZGUpfVwiXG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJob3ZlclwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaG92ZXItYmdcIj48L2Rpdj48IS0tIG11c3QgYmUgYWZ0ZXIgLmhvdmVyIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgIDxzcGFuIHN0eWxlPVwiXG4gICAgICAgICAgICB0ZXh0LWluZGVudDogJHtub2RlLnR5cGUgPT09ICdkaXJlY3RvcnknID8gMjAgOiAwfXB4O1xuICAgICAgICAgIFwiPiR7bm9kZS5uYW1lfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgICAgJHtub2RlLnR5cGUgPT09ICdkaXJlY3RvcnknID9cbiAgICAgICAgaHRtbGBcbiAgICAgICAgICA8bGk+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICR7bm9kZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gdGhpcy5fcmVuZGVyTm9kZShjaGlsZCwgZGVwdGggKyAxKSl9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIGBcbiAgICAgIDogbm90aGluZ31cbiAgICBgXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8bmF2IHN0eWxlPVwiXG4gICAgICAgIHdpZHRoOiAke3RoaXMud2lkdGh9cHg7XG4gICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgIFwiPlxuICAgICAgICA8dWw+XG4gICAgICAgICAgJHt0aGlzLl9yZW5kZXJOb2RlKHRoaXMudmFsdWUsIDApfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9uYXY+XG4gICAgYFxuICB9XG5cbiAgX29uSXRlbUNsaWNrKGUsIG5vZGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgIGUuY3VycmVudFRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBY3RpdmUuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGUuY3VycmVudFRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRBY3RpdmUgPSBlLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJJbnB1dChub2RlKTtcbiAgICB9XG4gIH1cblxuICBfdHJpZ2dlcklucHV0KG5vZGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnaW5wdXQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgdmFsdWU6IG5vZGUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy1maWxlLXRyZWUnLCBTY0ZpbGVUcmVlKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NGaWxlVHJlZTtcbiIsImltcG9ydCB7IGh0bWwsIGNzcywgc3ZnLCBub3RoaW5nIH0gZnJvbSAnbGl0JztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuaW1wb3J0IHsgdGhlbWUgfSBmcm9tICcuL3N0eWxlcy5qcyc7XG5cbmNsYXNzIFNjVHJhbnNwb3J0IGV4dGVuZHMgU2NFbGVtZW50IHtcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIH0sXG4gICAgICBidXR0b25zOiB7fSxcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH0sXG4gICAgICB2YWx1ZToge30sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgZm9udC1zaXplOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgc3ZnIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0yJ119O1xuICAgICAgICBmaWxsOiAgI2ZmZmZmZjtcbiAgICAgIH1cblxuICAgICAgc3ZnLmFjdGl2ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0wJ119O1xuICAgICAgfVxuXG4gICAgICBzdmcucGxheS5hY3RpdmUge1xuICAgICAgICBmaWxsOiAke3RoZW1lWyctLWNvbG9yLXNlY29uZGFyeS00J119O1xuICAgICAgfVxuXG4gICAgICBzdmcucGF1c2UuYWN0aXZlIHtcbiAgICAgICAgZmlsbDogJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMiddfTtcbiAgICAgIH1cblxuICAgICAgc3ZnLnN0b3AuYWN0aXZlIHtcbiAgICAgICAgZmlsbDogJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMyddfTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBzZXQgYnV0dG9ucyh2YWx1ZSkge1xuICAgIGNvbnN0IHJlcGxhY2UgPSB2YWx1ZS5yZXBsYWNlKC9bXFxbXFxdXFxzXS9nLCAnJyk7XG4gICAgdGhpcy5fYnV0dG9ucyA9IHJlcGxhY2Uuc3BsaXQoJywnKTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLndpZHRoID0gMzA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICB0aGlzLmJ1dHRvbnMgPSBcIlwiO1xuICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnJlbmRlckZ1bmN0aW9ucyA9IHtcbiAgICAgIHBsYXk6IHRoaXMucmVuZGVyUGxheS5iaW5kKHRoaXMpLFxuICAgICAgcGF1c2U6IHRoaXMucmVuZGVyUGF1c2UuYmluZCh0aGlzKSxcbiAgICAgIHN0b3A6IHRoaXMucmVuZGVyU3RvcC5iaW5kKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICByZW5kZXJQbGF5KHNpemUpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdmcgXG4gICAgICAgIGNsYXNzPVwicGxheSAke3RoaXMuc3RhdGUgPT09ICdwbGF5JyA/ICdhY3RpdmUnIDogJyd9XCJcbiAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICB3aWR0aDogJHtzaXplfXB4O1xuICAgICAgICAgIGhlaWdodDogJHtzaXplfXB4O1xuICAgICAgICBcIlxuICAgICAgICB2aWV3Ym94PVwiMCAwIDIwIDIwXCJcbiAgICAgICAgQG1vdXNlZG93bj1cIiR7ZSA9PiB0aGlzLl9vbkNoYW5nZShlLCAncGxheScpfVwiXG4gICAgICAgIEB0b3VjaHN0YXJ0PVwiJHtlID0+IHRoaXMuX29uQ2hhbmdlKGUsICdwbGF5Jyl9XCJcbiAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgID5cbiAgICAgICAgPHBvbHlnb24gY2xhc3M9XCJwbGF5LXNoYXBlXCIgcG9pbnRzPVwiNiwgNSwgMTUsIDEwLCA2LCAxNVwiPjwvcG9seWdvbj5cbiAgICAgIDwvc3ZnPlxuICAgIGBcbiAgfVxuXG4gIHJlbmRlclBhdXNlKHNpemUpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdmcgXG4gICAgICAgIGNsYXNzPVwicGF1c2UgJHt0aGlzLnN0YXRlID09PSAncGF1c2UnID8gJ2FjdGl2ZScgOiAnJ31cIlxuICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgIHdpZHRoOiAke3NpemV9cHg7XG4gICAgICAgICAgaGVpZ2h0OiAke3NpemV9cHg7XG4gICAgICAgIFwiXG4gICAgICAgIHZpZXdib3g9XCIwIDAgMjAgMjBcIlxuICAgICAgICBAbW91c2Vkb3duPVwiJHtlID0+IHRoaXMuX29uQ2hhbmdlKGUsICdwYXVzZScpIH1cIlxuICAgICAgICBAdG91Y2hzdGFydD1cIiR7ZSA9PiB0aGlzLl9vbkNoYW5nZShlLCAnc3RvcCcpIH1cIlxuICAgICAgICBAY29udGV4dG1lbnU9XCIke3RoaXMuX3ByZXZlbnRDb250ZXh0TWVudX1cIlxuICAgICAgPlxuICAgICAgICA8cmVjdCBjbGFzcz1cImxlZnRcIiB4PVwiNVwiIHk9XCI1XCIgd2lkdGg9XCIzXCIgaGVpZ2h0PVwiMTBcIj48L3JlY3Q+XG4gICAgICAgIDxyZWN0IGNsYXNzPVwicmlnaHRcIiB4PVwiMTJcIiB5PVwiNVwiIHdpZHRoPVwiM1wiIGhlaWdodD1cIjEwXCI+PC9yZWN0PlxuICAgICAgPC9zdmc+XG4gICAgYFxuICB9XG5cbiAgcmVuZGVyU3RvcChzaXplKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3ZnIFxuICAgICAgICBjbGFzcz1cInN0b3AgJHt0aGlzLnN0YXRlID09PSAnc3RvcCcgPyAnYWN0aXZlJyA6ICcnfVwiXG4gICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgd2lkdGg6ICR7c2l6ZX1weDtcbiAgICAgICAgICBoZWlnaHQ6ICR7c2l6ZX1weDtcbiAgICAgICAgXCJcbiAgICAgICAgdmlld2JveD1cIjAgMCAyMCAyMFwiXG4gICAgICAgIEBtb3VzZWRvd249XCIke2UgPT4gdGhpcy5fb25DaGFuZ2UoZSwgJ3N0b3AnKSB9XCJcbiAgICAgICAgQHRvdWNoc3RhcnQ9XCIke2UgPT4gdGhpcy5fb25DaGFuZ2UoZSwgJ3N0b3AnKSB9XCJcbiAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgID5cbiAgICAgICAgPHJlY3QgY2xhc3M9XCJzdG9wLXNoYXBlXCIgeD1cIjZcIiB5PVwiNlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjhcIj48L3JlY3Q+XG4gICAgICA8L3N2Zz5cbiAgICBgXG4gIH1cblxuICAvLyByZW5kZXJSZWNvcmQoY29udGV4dCkge1xuICAvLyAgIGNvbnN0IHNpemUgPSBjb250ZXh0Ll9zaXplIC0gMjtcblxuICAvLyAgIHJldHVybiBodG1sYFxuICAvLyAgICAgPGRpdj5cbiAgLy8gICAgICAgPHN2ZyBcbiAgLy8gICAgICAgICBzdHlsZT1cIlxuICAvLyAgICAgICAgICAgd2lkdGg6ICR7c2l6ZX1weDtcbiAgLy8gICAgICAgICAgIGhlaWdodDogJHtzaXplfXB4O1xuICAvLyAgICAgICAgIFwiXG4gIC8vICAgICAgICAgdmlld2JveD1cIjAgMCAyMCAyMFwiXG4gIC8vICAgICAgICAgQG1vdXNlZG93bj1cIiR7Y29udGV4dC5fdHJpZ2dlckV2ZW50fVwiXG4gIC8vICAgICAgICAgQHRvdWNoc3RhcnQ9XCIke2NvbnRleHQuX3RyaWdnZXJFdmVudH1cIlxuICAvLyAgICAgICAgIEBjb250ZXh0bWVudT1cIiR7Y29udGV4dC5fcHJldmVudENvbnRleHRNZW51fVwiXG4gIC8vICAgICAgID5cbiAgLy8gICAgICAgICAke2NvbnRleHQuc3RhdGUgPT09ICdwbGF5J1xuICAvLyAgICAgICAgICAgPyBzdmdgXG4gIC8vICAgICAgICAgICAgICAgPGNpcmNsZSBcbiAgLy8gICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogJHt0aGVtZVsnLS1jb2xvci1zZWNvbmRhcnktMyddfVwiXG4gIC8vICAgICAgICAgICAgICAgICBjbGFzcz1cInJlY29yZC1zaGFwZVwiIFxuICAvLyAgICAgICAgICAgICAgICAgY3g9XCIxMFwiIFxuICAvLyAgICAgICAgICAgICAgICAgY3k9XCIxMFwiIFxuICAvLyAgICAgICAgICAgICAgICAgcj1cIjVcIlxuICAvLyAgICAgICAgICAgICAgID48L2NpcmNsZT5cbiAgLy8gICAgICAgICAgICAgYFxuICAvLyAgICAgICAgICAgOiBzdmdgXG4gIC8vICAgICAgICAgICAgICAgPGNpcmNsZSBcbiAgLy8gICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogXG4gIC8vICAgICAgICAgICAgICAgICBjbGFzcz1cInJlY29yZC1zaGFwZVwiIFxuICAvLyAgICAgICAgICAgICAgICAgY3g9XCIxMFwiIFxuICAvLyAgICAgICAgICAgICAgICAgY3k9XCIxMFwiIFxuICAvLyAgICAgICAgICAgICAgICAgcj1cIjVcIlxuICAvLyAgICAgICAgICAgICAgID48L2NpcmNsZT5cbiAgLy8gICAgICAgICAgICAgYFxuICAvLyAgICAgICAgIH1cbiAgICAgICAgICBcbiAgLy8gICAgICAgPC9zdmc+XG4gIC8vICAgICA8L2Rpdj5cbiAgLy8gICBgXG4gIC8vIH1cblxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSAtIDI7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgICR7dGhpcy5fYnV0dG9ucy5tYXAodHlwZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckZ1bmN0aW9uc1t0eXBlXShzaXplKTtcbiAgICAgIH0pfVxuICAgIGBcbiAgfVxuXG4gIF9vbkNoYW5nZShlLCB2YWx1ZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IGNoYW5nZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICBkZXRhaWw6IHsgdmFsdWU6IHRoaXMuc3RhdGUgfSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzYy10cmFuc3BvcnQnLCBTY1RyYW5zcG9ydCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjVHJhbnNwb3J0O1xuXG4iLCJpbXBvcnQgeyBodG1sLCBzdmcsIGNzcyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gJy4vc3R5bGVzLmpzJztcbmltcG9ydCBTY0VsZW1lbnQgZnJvbSAnLi9TY0VsZW1lbnQuanMnO1xuXG5jbGFzcyBTY1JlY29yZCBleHRlbmRzIFNjRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB9LFxuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgZm9udC1zaXplOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgc3ZnIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZVsnLS1jb2xvci1wcmltYXJ5LTInXX07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0yJ119O1xuICAgICAgICBmaWxsOiAgI2ZmZmZmZjtcbiAgICAgIH1cblxuICAgICAgc3ZnLmFjdGl2ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbJy0tY29sb3ItcHJpbWFyeS0wJ119O1xuICAgICAgICBmaWxsOiAke3RoZW1lWyctLWNvbG9yLXNlY29uZGFyeS0zJ119O1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9zaXplID0gdmFsdWU7XG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIC8vIGFsaWFzIGFjdGl2ZSBmb3IgY29uc2lzdGVuY3kgYW5kIGdlbmVyaWNpdHkgd2l0aCBvdGhlciBjb21wb25lbnRzXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gIH1cblxuICBzZXQgdmFsdWUoYWN0aXZlKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy53aWR0aCA9IDMwO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSAtIDI7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXY+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICBjbGFzcz1cIiR7dGhpcy5hY3RpdmUgPyAnYWN0aXZlJyA6ICcnfVwiXG4gICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgIHdpZHRoOiAke3NpemV9cHg7XG4gICAgICAgICAgICBoZWlnaHQ6ICR7c2l6ZX1weDtcbiAgICAgICAgICBcIlxuICAgICAgICAgIHZpZXdib3g9XCIwIDAgMjAgMjBcIlxuICAgICAgICAgIEBtb3VzZWRvd249XCIke3RoaXMuX29uQ2hhbmdlfVwiXG4gICAgICAgICAgQHRvdWNoc3RhcnQ9XCIke3RoaXMuX29uQ2hhbmdlfVwiXG4gICAgICAgICAgQGNvbnRleHRtZW51PVwiJHt0aGlzLl9wcmV2ZW50Q29udGV4dE1lbnV9XCJcbiAgICAgICAgPlxuICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJyZWNvcmQtc2hhcGVcIiBjeD1cIjEwXCIgY3k9XCIxMFwiIHI9XCI1XCI+PC9jaXJjbGU+ICBcbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICBgXG4gIH1cblxuICBfb25DaGFuZ2UoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5hY3RpdmUgPSAhdGhpcy5hY3RpdmU7XG5cbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHZhbHVlOiB0aGlzLmFjdGl2ZSB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjLXJlY29yZCcsIFNjUmVjb3JkKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NSZWNvcmQ7XG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0L2h0bWwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgICAvLyBkaXJ0eSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NXG4gIC8vIHNldEludGVydmFsKCgpID0+IHtcbiAgLy8gICBjb25zdCAkbWF0cml4ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtbWF0cml4Jyk7XG4gIC8vICAgY29uc3QgdmFsdWUgPSAkbWF0cml4LnZhbHVlO1xuXG4gIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gIC8vICAgICBjb25zdCByb3dJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbHVlLmxlbmd0aCk7XG4gIC8vICAgICBjb25zdCBjb2xJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbHVlW3Jvd0luZGV4XS5sZW5ndGgpO1xuICAvLyAgICAgY29uc3QgY2VsbFZhbHVlID0gJG1hdHJpeC5lbnRyaWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICRtYXRyaXguZW50cmllcy5sZW5ndGgpXTtcblxuICAvLyAgICAgdmFsdWVbcm93SW5kZXhdW2NvbEluZGV4XSA9IGNlbGxWYWx1ZTtcbiAgLy8gICAgICRtYXRyaXgudmFsdWUgPSB2YWx1ZTtcbiAgLy8gICB9XG5cbiAgLy8gfSwgNTApO1xuXG4gIHJldHVybiBodG1sYFxuICAgIDxwcmU+PGNvZGU+XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1tYXRyaXguanMnO1xuXG4ke2A8c2MtbWF0cml4Pjwvc2MtbWF0cml4PmB9XG4gICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgPHNjLW1hdHJpeFxuICAgICAgaWQ9XCJ0ZXN0LW1hdHJpeFwiXG4gICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgY29uc3QgJGNoYW5nZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYXRyaXgtY2hhbmdlJyk7XG4gICAgICAgICRjaGFuZ2UudmFsdWUgPSBlLmRldGFpbC52YWx1ZS5tYXAocm93ID0+IHJvdy5qb2luKCcsICcpKS5qb2luKCdcXG4nKTtcbiAgICAgIH19XCJcbiAgICA+XG4gICAgPC9zYy1tYXRyaXg+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGNoYW5nZVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0XG4gICAgICAgIGlkPVwibWF0cml4LWNoYW5nZVwiXG4gICAgICAgIHdpZHRoPVwiNDAwXCJcbiAgICAgICAgaGVpZ2h0PVwiMTUwXCJcbiAgICAgICAgcmVhZG9ubHlcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjYwMFwiXG4gICAgICAgIHZhbHVlPVwiMzAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1tYXRyaXgnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjYwMFwiXG4gICAgICAgIHZhbHVlPVwiMjAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1tYXRyaXgnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmhlaWdodCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbcm93cz00XVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMVwiXG4gICAgICAgIG1heD1cIjEwXCJcbiAgICAgICAgdmFsdWU9XCI0XCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1tYXRyaXgnKTtcbiAgICAgICAgICAkY29tcG9uZW50LnJvd3MgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2NvbHVtbnM9OF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjRcIlxuICAgICAgICBtYXg9XCIxNlwiXG4gICAgICAgIHZhbHVlPVwiOFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtbWF0cml4Jyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5jb2x1bW5zID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltlbnRyaWVzPVswLCAxXV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdGV4dFxuICAgICAgICB2YWx1ZT1cIlswLCAxXVwiXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1tYXRyaXgnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRldGFpbC52YWx1ZSk7XG4gICAgICAgICAgJGNvbXBvbmVudC5lbnRyaWVzID0gSlNPTi5wYXJzZShlLmRldGFpbC52YWx1ZSk7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbcmVzZXRdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLWJhbmdcbiAgICAgICAgdmFsdWU9XCJbMCwgMV1cIlxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1tYXRyaXgnKTtcbiAgICAgICAgICAkY29tcG9uZW50LnJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtYmFuZz5cbiAgICA8L3A+XG4gIGA7XG59XG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0L2h0bWwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWRyYWduZHJvcC5qcyc7XG5cbiR7YDxzYy1kcmFnbmRyb3A+PC9zYy1kcmFnbmRyb3A+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtZHJhZ25kcm9wXG4gICAgICBpZD1cInRlc3QtZHJhZ25kcm9wXCJcbiAgICAgIHdpZHRoPVwiMzAwXCJcbiAgICAgIGhlaWdodD1cIjIwMFwiXG4gICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgY29uc3QgJGNoYW5nZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkcmFnbmRyb3AtY2hhbmdlJyk7XG5cbiAgICAgICAgbGV0IHR4dCA9ICd7JztcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBlLmRldGFpbC52YWx1ZSkge1xuICAgICAgICAgIHR4dCArPSBgXFxuICAke25hbWV9OiBcIiR7ZS5kZXRhaWwudmFsdWVbbmFtZV19XCIsYFxuICAgICAgICB9XG4gICAgICAgIHR4dCArPSAnXFxufSc7XG5cbiAgICAgICAgJGNoYW5nZS52YWx1ZSA9IHR4dDtcbiAgICAgIH19XCJcbiAgICA+XG4gICAgPC9zYy1kcmFnbmRyb3A+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGNoYW5nZVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0XG4gICAgICAgIGlkPVwiZHJhZ25kcm9wLWNoYW5nZVwiXG4gICAgICAgIHdpZHRoPVwiNDAwXCJcbiAgICAgICAgaGVpZ2h0PVwiMjAwXCJcbiAgICAgICAgcmVhZG9ubHlcbiAgICAgICAgdmFsdWU9XCJzZWUgY29uc29sZSB0byBzZWUgdGhlIG5vbi1zdHJpbmdpZmllZCB2ZXJzaW9uXCJcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjYwMFwiXG4gICAgICAgIHZhbHVlPVwiMzAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1kcmFnbmRyb3AnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjYwMFwiXG4gICAgICAgIHZhbHVlPVwiMjAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1kcmFnbmRyb3AnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmhlaWdodCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgd2lkdGg9XCIyNTBcIiByZWFkb25seSB2YWx1ZT1cIltsYWJlbD0nRHJhZyBhbmQgRHJvcCBGaWxlcyddXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHRcbiAgICAgICAgdmFsdWU9XCJEcmFnIGFuZCBEcm9wIEZpbGVzXCJcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRyYWduZHJvcCcpO1xuICAgICAgICAgICRjb21wb25lbnQubGFiZWwgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgYDtcbn1cbiIsImltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWJhbmcuanMnO1xuXG4ke2A8c2MtYmFuZz48L3NjLWJhbmc+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtYmFuZ1xuICAgICAgaWQ9XCJ0ZXN0LWJhbmdcIlxuICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgY29uc3QgJGV2ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2JhbmctaW5wdXQnKTtcbiAgICAgICAgJGV2ZW50LmFjdGl2ZSA9IHRydWU7XG4gICAgICB9fVwiXG4gICAgPjwvc2MtYmFuZz5cblxuICAgIDxoMz5FdmVudHM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAaW5wdXRcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtYmFuZyBpZD1cImJhbmctaW5wdXRcIj48L3NjLWJhbmc+XG4gICAgPC9wPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWJhbmcnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWJhbmcnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmhlaWdodCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbYWN0aXZlPWZhbHNlXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1iYW5nXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWJhbmcnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLWJhbmc+XG4gICAgPC9wPlxuICBgO1xufVxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC9odG1sLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICBsZXQgdGltZW91dElkSW5wdXQ7XG4gIGxldCB0aW1lb3V0SWRQcmVzcztcbiAgbGV0IHRpbWVvdXRJZFJlbGVhc2U7XG5cbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWJ1dHRvbi5qcyc7XG5cbiR7YDxzYy1idXR0b24+PC9zYy1idXR0b24+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtYnV0dG9uXG4gICAgICBpZD1cInRlc3QtYnV0dG9uXCJcbiAgICAgIHZhbHVlPVwibXktdmFsdWVcIlxuICAgICAgdGV4dD1cIm15IGJ1dHRvblwiXG4gICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnV0dG9uLWlucHV0Jyk7XG4gICAgICAgICRldmVudC5hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRJbnB1dCk7XG4gICAgICAgIGNvbnN0ICR2YWx1ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNidXR0b24tdmFsdWUtaW5wdXQnKTtcbiAgICAgICAgJHZhbHVlLnZhbHVlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIHRpbWVvdXRJZElucHV0ID0gc2V0VGltZW91dCgoKSA9PiAkdmFsdWUudmFsdWUgPSAnJywgNTAwKTtcbiAgICAgIH19XCJcbiAgICAgIEBwcmVzcz1cIiR7ZSA9PiB7XG4gICAgICAgIGNvbnN0ICRldmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNidXR0b24tcHJlc3MnKTtcbiAgICAgICAgJGV2ZW50LmFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFByZXNzKTtcbiAgICAgICAgY29uc3QgJHZhbHVlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2J1dHRvbi12YWx1ZS1wcmVzcycpO1xuICAgICAgICAkdmFsdWUudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgdGltZW91dElkUHJlc3MgPSBzZXRUaW1lb3V0KCgpID0+ICR2YWx1ZS52YWx1ZSA9ICcnLCA1MDApO1xuICAgICAgfX1cIlxuICAgICAgQHJlbGVhc2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnV0dG9uLXJlbGVhc2UnKTtcbiAgICAgICAgJGV2ZW50LmFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlbGVhc2UpO1xuICAgICAgICBjb25zdCAkdmFsdWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnV0dG9uLXZhbHVlLXJlbGVhc2UnKTtcbiAgICAgICAgJHZhbHVlLnZhbHVlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIHRpbWVvdXRJZFJlbGVhc2UgPSBzZXRUaW1lb3V0KCgpID0+ICR2YWx1ZS52YWx1ZSA9ICcnLCA1MDApO1xuICAgICAgfX1cIlxuICAgID48L3NjLWJ1dHRvbj5cblxuICAgIDxoMz5FdmVudHM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAaW5wdXQgKGUuZGV0YWlsLnZhbHVlKVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1iYW5nIGlkPVwiYnV0dG9uLWlucHV0XCI+PC9zYy1iYW5nPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgaWQ9XCJidXR0b24tdmFsdWUtaW5wdXRcIj48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAcHJlc3MgKGUuZGV0YWlsLnZhbHVlKVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1iYW5nIGlkPVwiYnV0dG9uLXByZXNzXCI+PC9zYy1iYW5nPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgaWQ9XCJidXR0b24tdmFsdWUtcHJlc3NcIj48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAcmVsZWFzZSAoZS5kZXRhaWwudmFsdWUpXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLWJhbmcgaWQ9XCJidXR0b24tcmVsZWFzZVwiPjwvc2MtYmFuZz5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IGlkPVwiYnV0dG9uLXZhbHVlLXJlbGVhc2VcIj48L3NjLXRleHQ+XG4gICAgPC9wPlxuXG5cbiAgICA8aDM+QXR0cmlidXRlczwvaDM+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlt3aWR0aD0yMDBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMjAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1idXR0b24nKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWJ1dHRvbicpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlt2YWx1ZT1udWxsXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0XG4gICAgICAgIHZhbHVlPVwibXktdmFsdWVcIlxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtYnV0dG9uJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC52YWx1ZSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10ZXh0PlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3RleHQ9dGhpcy52YWx1ZV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdGV4dFxuICAgICAgICB2YWx1ZT1cIm15IGJ1dHRvblwiXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1idXR0b24nKTtcbiAgICAgICAgICAkY29tcG9uZW50LnRleHQgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtdGV4dD5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltzZWxlY3RlZD1mYWxzZV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdG9nZ2xlXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1idXR0b24nKTtcbiAgICAgICAgICAkY29tcG9uZW50LnNlbGVjdGVkID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRvZ2dsZT5cbiAgICA8L3A+XG4gIGA7XG59XG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0L2h0bWwuanMnO1xuXG5mdW5jdGlvbiBqcygpIHt9XG5jb25zdCBleGFtcGxlQ29kZSA9IGBmdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4gYSArIGI7XG59XG5gO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBodG1sYFxuICAgIDxwcmU+PGNvZGU+XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1lZGl0b3IuanMnO1xuXG4ke2A8c2MtZWRpdG9yPjwvc2MtZWRpdG9yPmB9XG4gICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgPHNjLWVkaXRvclxuICAgICAgaWQ9XCJ0ZXN0LWVkaXRvclwiXG4gICAgICB2YWx1ZT1cIiR7ZXhhbXBsZUNvZGV9XCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdG9yLWNoYW5nZScpO1xuICAgICAgICAkZXZlbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICA+PC9zYy1lZGl0b3I+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8ZGl2PlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAY2hhbmdlXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgd2lkdGg9XCIzMDBcIiBoZWlnaHQ9XCIyMDBcIiBpZD1cImVkaXRvci1jaGFuZ2VcIj48L3NjLXRleHQ+XG4gICAgICA8cD48aT5AY2hhbmdlIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiBcImNtZCArIHNcIiBhbmQgd2hlbiBjbGlja2luZyB0aGUgXCJzYXZlXCIgYnV0dG9uPC9pPjwvcD5cbiAgICA8L2Rpdj5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3dpZHRoPTMwMF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjIwMFwiXG4gICAgICAgIG1heD1cIjYwMFwiXG4gICAgICAgIHZhbHVlPVwiMzAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1lZGl0b3InKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MjAwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMTAwXCJcbiAgICAgICAgbWF4PVwiNTAwXCJcbiAgICAgICAgdmFsdWU9XCIyMDBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWVkaXRvcicpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltmb250LXNpemU9MTFdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCI4XCJcbiAgICAgICAgbWF4PVwiMjBcIlxuICAgICAgICB2YWx1ZT1cIjExXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1lZGl0b3InKTtcbiAgICAgICAgICAkY29tcG9uZW50LmZvbnRTaXplID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlt2YWx1ZT0nJ11cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtZWRpdG9yXG4gICAgICAgIHZhbHVlPVwiJHtleGFtcGxlQ29kZX1cIlxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkZWRpdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtZWRpdG9yJyk7XG4gICAgICAgICAgJGVkaXRvci52YWx1ZSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1lZGl0b3I+XG5cbiAgICA8L3A+XG4gIGA7XG59XG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0L2h0bWwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBodG1sYFxuICAgIDxwcmU+PGNvZGU+XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1udW1iZXIuanMnO1xuXG4ke2A8c2MtbnVtYmVyPjwvc2MtbnVtYmVyPmB9XG4gICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgPHNjLW51bWJlclxuICAgICAgaWQ9XCJ0ZXN0LW51bWJlclwiXG4gICAgICB2YWx1ZT1cIjBcIlxuICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgY29uc3QgJGV2ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI251bWJlci1pbnB1dCcpO1xuICAgICAgICAkZXZlbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbnVtYmVyLWNoYW5nZScpO1xuICAgICAgICAkZXZlbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICA+PC9zYy1udW1iZXI+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGlucHV0IChlLmRldGFpbC52YWx1ZSlcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyIGlkPVwibnVtYmVyLWlucHV0XCI+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAY2hhbmdlIChlLmRldGFpbC52YWx1ZSlcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyIGlkPVwibnVtYmVyLWNoYW5nZVwiPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3dpZHRoPTEwMF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjMwXCJcbiAgICAgICAgbWF4PVwiMzAwXCJcbiAgICAgICAgdmFsdWU9XCIxMDBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LW51bWJlcicpO1xuICAgICAgICAgICRjb21wb25lbnQud2lkdGggPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2hlaWdodD0zMF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjMwXCJcbiAgICAgICAgbWF4PVwiMzAwXCJcbiAgICAgICAgdmFsdWU9XCIzMFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtbnVtYmVyJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5oZWlnaHQgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW21pbj0tSW5maW5pdHldXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtYXg9XCIwXCJcbiAgICAgICAgdmFsdWU9XCItOTk5OVwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtbnVtYmVyJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5taW4gPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW21heD0rSW5maW5pdHldXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgdmFsdWU9XCI5OTk5XCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1udW1iZXInKTtcbiAgICAgICAgICAkY29tcG9uZW50Lm1heCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbdmFsdWU9MF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIHZhbHVlPVwiMFwiXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LW51bWJlcicpO1xuICAgICAgICAgICRjb21wb25lbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2ludGVnZXI9ZmFsc2VdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRvZ2dsZVxuICAgICAgICBpZD1cInRlc3QtbnVtYmVyXCJcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LW51bWJlcicpO1xuICAgICAgICAgICRjb21wb25lbnQuaW50ZWdlciA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuICBgO1xufVxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC9odG1sLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBodG1sYFxuICAgIDxwcmU+PGNvZGU+XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1zbGlkZXIuanMnO1xuXG4ke2A8c2Mtc2xpZGVyPjwvc2Mtc2xpZGVyPmB9XG4gICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgPHNjLXNsaWRlclxuICAgICAgaWQ9XCJ0ZXN0LXNsaWRlclwiXG4gICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZGlzcGxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzbGlkZXItaW5wdXQnKTtcbiAgICAgICAgJGRpc3BsYXkudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZGlzcGxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzbGlkZXItY2hhbmdlJyk7XG4gICAgICAgICRkaXNwbGF5LnZhbHVlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICB9fVwiXG4gICAgPjwvc2Mtc2xpZGVyPlxuXG4gICAgPGgzPkV2ZW50czwvaDM+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIkBpbnB1dCA9PiBlLmRldGFpbC52YWx1ZVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXIgaWQ9XCJzbGlkZXItaW5wdXRcIj48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIkBjaGFuZ2UgPT4gZS5kZXRhaWwudmFsdWVcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyIGlkPVwic2xpZGVyLWNoYW5nZVwiPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3ZhbHVlPTAuNV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIHZhbHVlPVwiMC41XCJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2xpZGVyJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC52YWx1ZSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MjAwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMzBcIlxuICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIjIwMFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2xpZGVyJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC53aWR0aCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbaGVpZ2h0PTMwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMzBcIlxuICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIjMwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1zbGlkZXInKTtcbiAgICAgICAgICAkY29tcG9uZW50LmhlaWdodCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbbWluPS0xXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiLTIwMFwiXG4gICAgICAgIG1heD1cIjBcIlxuICAgICAgICB2YWx1ZT1cIjBcIlxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1zbGlkZXInKTtcbiAgICAgICAgICAkY29tcG9uZW50Lm1pbiA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbbWF4PTFdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgbWF4PVwiMjAwXCJcbiAgICAgICAgdmFsdWU9XCIxXCJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2xpZGVyJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5tYXggPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW29yaWVudGF0aW9uPWhvcml6b250YWxdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLWJ1dHRvblxuICAgICAgICB2YWx1ZT1cImhvcml6b250YWxcIlxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1zbGlkZXInKTtcbiAgICAgICAgICAkY29tcG9uZW50Lm9yaWVudGF0aW9uID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLWJ1dHRvbj5cbiAgICAgIDxzYy1idXR0b25cbiAgICAgICAgdmFsdWU9XCJ2ZXJ0aWNhbFwiXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNsaWRlcicpO1xuICAgICAgICAgICRjb21wb25lbnQub3JpZW50YXRpb24gPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtYnV0dG9uPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2Rpc3BsYXktbnVtYmVyPWZhbHNlXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10b2dnbGVcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNsaWRlcicpO1xuICAgICAgICAgICRjb21wb25lbnQuZGlzcGxheU51bWJlciA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbY29sb3I9I2RlZGVkZWZmXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0XG4gICAgICAgIHZhbHVlPVwiI2RlZGVkZWZmXCJcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNsaWRlcicpO1xuICAgICAgICAgICRjb21wb25lbnQuY29sb3IgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtdGV4dD5cbiAgICA8L3A+XG5cbiAgYDtcbn1cbiIsImltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLXRleHQuanMnO1xuXG4ke2A8c2MtdGV4dD48L3NjLXRleHQ+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtdGV4dFxuICAgICAgaWQ9XCJ0ZXN0LXRleHRcIlxuICAgICAgd2lkdGg9XCIzMDBcIlxuICAgICAgaGVpZ2h0PVwiMjAwXCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGV4dC1jaGFuZ2UnKTtcbiAgICAgICAgJGV2ZW50LnZhbHVlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICB9fVwiXG4gICAgICB2YWx1ZT1cIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZFxudGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLFxucXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG9cbmNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2VcbmNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uXG5wcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIlxuICAgID48L3NjLXRleHQ+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8ZGl2PlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJAY2hhbmdlXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgd2lkdGg9XCIzMDBcIiBoZWlnaHQ9XCIyMDBcIiBpZD1cInRleHQtY2hhbmdlXCI+PC9zYy10ZXh0PlxuICAgICAgPHA+PGk+QGNoYW5nZSBldmVudCBpcyB0cmlnZ2VyZWQgb24gYmx1ciBhbmQgb24gXCJjbWQgKyBzXCIgPC9pPjwvcD5cbiAgICA8L2Rpdj5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3dpZHRoPTIwMF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjEwMFwiXG4gICAgICAgIG1heD1cIjUwMFwiXG4gICAgICAgIHZhbHVlPVwiMzAwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10ZXh0Jyk7XG4gICAgICAgICAgJGNvbXBvbmVudC53aWR0aCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbaGVpZ2h0PTMwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMzBcIlxuICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIjIwMFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtdGV4dCcpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlt2YWx1ZT0nJ11cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdGV4dFxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtdGV4dCcpO1xuICAgICAgICAgICRjb21wb25lbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtdGV4dD5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltyZWFkb25seT1mYWxzZV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdG9nZ2xlXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10ZXh0Jyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5yZWFkb25seSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuICBgO1xufVxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC9odG1sLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaHRtbGBcbiAgICA8cHJlPjxjb2RlPlxuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2MtdG9nZ2xlLmpzJztcblxuJHtgPHNjLXRvZ2dsZT48L3NjLXRvZ2dsZT5gfVxuICAgIDwvY29kZT48L3ByZT5cblxuICAgIDxzYy10b2dnbGVcbiAgICAgIGlkPVwidGVzdC10b2dnbGVcIlxuICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgIGNvbnN0ICRldmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0b2dnbGUtY2hhbmdlJyk7XG4gICAgICAgICRldmVudC5hY3RpdmUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICA+PC9zYy10b2dnbGU+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGNoYW5nZVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10b2dnbGUgaWQ9XCJ0b2dnbGUtY2hhbmdlXCI+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXRvZ2dsZScpO1xuICAgICAgICAgICRjb21wb25lbnQud2lkdGggPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2hlaWdodD0zMF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjMwXCJcbiAgICAgICAgbWF4PVwiMzAwXCJcbiAgICAgICAgdmFsdWU9XCIzMFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtdG9nZ2xlJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5oZWlnaHQgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2FjdGl2ZT1mYWxzZV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdG9nZ2xlXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10b2dnbGUnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmFjdGl2ZSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuICBgO1xufVxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC9odG1sLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAvLyBkaXJ0eSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnN0ICRkb3RNYXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1kb3QtbWFwJyk7XG4gICAgY29uc3QgJGRvdE1hcERvdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZG90LW1hcC1kb3RzJyk7XG4gICAgY29uc3QgZG90cyA9IFtdO1xuXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKGRvdHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkb3RzLmxlbmd0aCk7XG4gICAgICAgIGRvdHMuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeFJhbmdlID0gJGRvdE1hcC54UmFuZ2U7XG4gICAgICBjb25zdCB5UmFuZ2UgPSAkZG90TWFwLnlSYW5nZTtcblxuICAgICAgY29uc3QgeCA9IE1hdGgucmFuZG9tKCkgKiAoeFJhbmdlWzFdIC0geFJhbmdlWzBdKSArIHhSYW5nZVswXTtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLnJhbmRvbSgpICogKHlSYW5nZVsxXSAtIHlSYW5nZVswXSkgKyB5UmFuZ2VbMF07XG4gICAgICBkb3RzLnB1c2goeyB4LCB5IH0pO1xuXG4gICAgICAkZG90TWFwLnZhbHVlID0gZG90cztcbiAgICAgICRkb3RNYXBEb3RzLnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoZG90cywgbnVsbCwgMik7XG4gICAgfSwgNTAwKTtcbiAgfSwgMTUwKTtcblxuICByZXR1cm4gaHRtbGBcbiAgICA8cHJlPjxjb2RlPlxuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2MtZG90LW1hcC5qcyc7XG5cbiR7YDxzYy1kb3QtbWFwPjwvc2MtZG90LW1hcD5gfVxuICAgIDwvY29kZT48L3ByZT5cblxuICAgIDxzYy1kb3QtbWFwXG4gICAgICBpZD1cInRlc3QtZG90LW1hcFwiXG4gICAgICBzdHlsZT1cIm91dGxpbmU6IDFweCBzb2xpZCAjNDU0NTQ1XCJcbiAgICA+PC9zYy1kb3QtbWFwPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbd2lkdGg9MzAwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMTUwXCJcbiAgICAgICAgbWF4PVwiNjAwXCJcbiAgICAgICAgdmFsdWU9XCIzMDBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRvdC1tYXAnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzAwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMTUwXCJcbiAgICAgICAgbWF4PVwiNjAwXCJcbiAgICAgICAgdmFsdWU9XCIzMDBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRvdC1tYXAnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmhlaWdodCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbeC1yYW5nZT1bMCwgMV1dIChsIC0+IHIpXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHRcbiAgICAgICAgdmFsdWU9XCJbMCwgMV1cIlxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtZG90LW1hcCcpO1xuICAgICAgICAgICRjb21wb25lbnQueFJhbmdlID0gSlNPTi5wYXJzZShlLmRldGFpbC52YWx1ZSk7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbeS1yYW5nZT1bMCwgMV1dICh0IC0+IGIpXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHRcbiAgICAgICAgdmFsdWU9XCJbMCwgMV1cIlxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtZG90LW1hcCcpO1xuICAgICAgICAgICRjb21wb25lbnQueVJhbmdlID0gSlNPTi5wYXJzZShlLmRldGFpbC52YWx1ZSk7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgaGVpZ2h0PVwiNDJcIiB2YWx1ZT1cIltkb3RzPVtdXSBcXG4oZG90PXsgeCwgeVssIGNvbG9yLCAuLi5dKVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0IGlkPVwiZG90LW1hcC1kb3RzXCIgd2lkdGg9XCIzMDBcIiBoZWlnaHQ9XCIxNTBcIiByZWFkb25seT48L3NjLXRleHQ+XG4gICAgPC9wPlxuXG4gICAgPGg0PkFzIGlucHV0PC9oND5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2NhcHR1cmUtZXZlbnQ9ZmFsc2VdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRvZ2dsZVxuICAgICAgICBhY3RpdmVcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRvdC1tYXAtMicpO1xuICAgICAgICAgICRjb21wb25lbnQuY2FwdHVyZUV2ZW50cyA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgICA8c2MtZG90LW1hcFxuICAgICAgICBpZD1cInRlc3QtZG90LW1hcC0yXCJcbiAgICAgICAgY2FwdHVyZS1ldmVudHNcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RvdC1tYXAtY2hhbmdlJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGUuZGV0YWlsLnZhbHVlLCBudWxsLCAyKTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtZG90LW1hcD5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltwZXJzaXN0LWV2ZW50PWZhbHNlXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10b2dnbGVcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRvdC1tYXAtMicpO1xuICAgICAgICAgICRjb21wb25lbnQucGVyc2lzdEV2ZW50cyA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy10b2dnbGU+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbYmFja2dyb3VuZC1pbWFnZT1udWxsXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10b2dnbGVcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWRvdC1tYXAtMicpO1xuICAgICAgICAgIGlmIChlLmRldGFpbC52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJGNvbXBvbmVudC5iYWNrZ3JvdW5kSW1hZ2UgPSAnaW1hZ2VzL3NlYXRpbmctbWFwLnBuZyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjb21wb25lbnQuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRvZ2dsZT5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIkBjaGFuZ2VcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdGV4dCBpZD1cImRvdC1tYXAtY2hhbmdlXCIgd2lkdGg9XCIzMDBcIiBoZWlnaHQ9XCIxMjBcIiByZWFkb25seT48L3NjLXRleHQ+XG4gICAgPC9wPlxuICBgO1xufVxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC9odG1sLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICBjb25zdCBjb250ZXh0ID0gW1xuICAgIHsgYWN0aW9uOiAnZWRpdCcsIGxhYmVsOiAnRWRpdCcgfSxcbiAgICB7IGFjdGlvbjogJ3NhdmUnLCBsYWJlbDogJ1NhdmUnIH0sXG4gICAgeyBhY3Rpb246ICdkZWxldGUnLCBsYWJlbDogJ0RlbGV0ZScgfSxcbiAgXTtcblxuICByZXR1cm4gaHRtbGBcbiAgICA8c2MtY29udGV4dC1tZW51XG4gICAgICBpZD1cInRlc3QtY29udGV4dC1tZW51XCJcbiAgICAgIHZhbHVlPVwiJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1cIlxuICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRleHQtbWVudS1pbnB1dCcpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb250ZXh0LW1lbnUtdmFsdWUtaW5wdXQnKS52YWx1ZSA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgfX1cIlxuICAgID48L3NjLWNvbnRleHQtbWVudT5cbiAgICA8ZGl2XG4gICAgICBzdHlsZT1cIlxuICAgICAgICB3aWR0aDogNDAwcHg7XG4gICAgICAgIGhlaWdodDogMzAwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDMwMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmVmO1xuICAgICAgXCJcbiAgICAgIEBjb250ZXh0bWVudT1cIiR7ZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWNvbnRleHQtbWVudScpO1xuICAgICAgICAkY29tcG9uZW50LnNob3coZSk7XG4gICAgICB9fVwiXG4gICAgPlxuICAgICAgcmlnaHQtY2xpY2sgdG8gb3BlbiB0aGUgY29udGV4dCBtZW51XG4gICAgPC9kaXY+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGlucHV0IChlLmRldGFpbC52YWx1ZSlcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtYmFuZyBpZD1cImNvbnRleHQtbWVudS1pbnB1dFwiPjwvc2MtYmFuZz5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IGlkPVwiY29udGV4dC1tZW51LXZhbHVlLWlucHV0XCI+PC9zYy10ZXh0PlxuICAgIDwvcD5cblxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJ2YWx1ZT1udWxsXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHRcbiAgICAgICAgd2lkdGg9XCIzMDBcIlxuICAgICAgICBoZWlnaHQ9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIiR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCwgbnVsbCwgMil9XCJcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWNvbnRleHQtbWVudScpO1xuICAgICAgICAgICRjb21wb25lbnQudmFsdWUgPSBKU09OLnBhcnNlKGUuZGV0YWlsLnZhbHVlKTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgYDtcbn1cbiIsImltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgdHJlZSA9IHtcbiAgICBwYXRoOiAnZG9jcycsXG4gICAgbmFtZTogJ2RvY3MnLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICB7XG4gICAgICAgIHBhdGg6ICdpbm5lci9kb2NzJyxcbiAgICAgICAgbmFtZTogJ2lubmVyJyxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXRoOiAnZG9jcy9pbm5lci9uaWFwLm1kJyxcbiAgICAgICAgICAgIG5hbWU6ICduaWFwLm1kJyxcbiAgICAgICAgICAgIHNpemU6IDE1ODQsXG4gICAgICAgICAgICBleHRlbnNpb246ICcubWQnLFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXRoOiAnZG9jcy9pbm5lci90ZXN0Lm1kJyxcbiAgICAgICAgICAgIG5hbWU6ICd0ZXN0Lm1kJyxcbiAgICAgICAgICAgIHNpemU6IDE1ODgsXG4gICAgICAgICAgICBleHRlbnNpb246ICcubWQnLFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzaXplOiAzMTcyLFxuICAgICAgICB0eXBlOiAnZGlyZWN0b3J5J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0aDogJ2RvY3MvbmlhcC5tZCcsXG4gICAgICAgIG5hbWU6ICduaWFwLm1kJyxcbiAgICAgICAgc2l6ZTogMTU4NCxcbiAgICAgICAgZXh0ZW5zaW9uOiAnLm1kJyxcbiAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXRoOiAnZG9jcy90ZXN0Lm1kJyxcbiAgICAgICAgbmFtZTogJ3Rlc3QubWQnLFxuICAgICAgICBzaXplOiAxNTg4LFxuICAgICAgICBleHRlbnNpb246ICcubWQnLFxuICAgICAgICB0eXBlOiAnZmlsZSdcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzaXplOiAzMTcyLFxuICAgIHR5cGU6ICdkaXJlY3RvcnknXG4gIH07XG5cbiAgcmV0dXJuIGh0bWxgXG4gICAgPHNjLWZpbGUtdHJlZVxuICAgICAgaWQ9XCJ0ZXN0LWZpbGUtdHJlZVwiXG4gICAgICB2YWx1ZT1cIiR7SlNPTi5zdHJpbmdpZnkodHJlZSl9XCJcbiAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgIGNvbnN0ICRiYW5nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ZpbGUtdHJlZS1pbnB1dCcpO1xuICAgICAgICAkYmFuZy5hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0ICR0ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ZpbGUtdHJlZS12YWx1ZS1pbnB1dCcpO1xuICAgICAgICAkdGV4dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGUuZGV0YWlsLnZhbHVlLCBudWxsLCAyKTtcbiAgICAgIH19XCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIH19XCJcbiAgICA+PC9zYy1maWxlLXRyZWU+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGlucHV0IChlLmRldGFpbC52YWx1ZSlcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtYmFuZyBpZD1cImZpbGUtdHJlZS1pbnB1dFwiPjwvc2MtYmFuZz5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IGlkPVwiZmlsZS10cmVlLXZhbHVlLWlucHV0XCIgaGVpZ2h0PVwiMTMwXCIgd2lkdGg9XCIzMDBcIj48L3NjLXRleHQ+XG4gICAgPC9wPlxuXG4gICAgPGgzPkF0dHJpYnV0ZXM8L2gzPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJ2YWx1ZT1udWxsXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRleHRcbiAgICAgICAgd2lkdGg9XCIzMDBcIlxuICAgICAgICBoZWlnaHQ9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIiR7SlNPTi5zdHJpbmdpZnkodHJlZSwgbnVsbCwgMil9XCJcbiAgICAgICAgQGNoYW5nZT1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LWZpbGUtdHJlZScpO1xuICAgICAgICAgICRjb21wb25lbnQudmFsdWUgPSBKU09OLnBhcnNlKGUuZGV0YWlsLnZhbHVlKTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgYDtcbn1cbiIsImltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLXRyYW5zcG9ydC5qcyc7XG5cbiR7YDxzYy10cmFuc3BvcnQ+PC9zYy10cmFuc3BvcnQ+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtdHJhbnNwb3J0XG4gICAgICBpZD1cInRlc3QtdHJhbnNwb3J0XCJcbiAgICAgIGJ1dHRvbnM9XCJbcGxheSwgcGF1c2UsIHN0b3BdXCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhbnNwb3J0LWNoYW5nZScpO1xuICAgICAgICAkZXZlbnQudmFsdWUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH19XCJcbiAgICA+PC9zYy10cmFuc3BvcnQ+XG5cbiAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiQGNoYW5nZVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0IGlkPVwidHJhbnNwb3J0LWNoYW5nZVwiIHJlYWRvbmx5IHZhbHVlPVwidW5kZWZpbmVkXCI+PC9zYy10ZXh0PlxuICAgIDwvcD5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3dpZHRoPTMwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMzBcIlxuICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIjMwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10cmFuc3BvcnQnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXRyYW5zcG9ydCcpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltidXR0b25zPVtdXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy10ZXh0XG4gICAgICAgIHZhbHVlPVwiW3BsYXksIHBhdXNlLCBzdG9wXVwiXG4gICAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXRyYW5zcG9ydCcpOyBcbiAgICAgICRjb21wb25lbnQuYnV0dG9ucyA9IGUuZGV0YWlsLnZhbHVlO1xuICAgIH19XCJcbiAgICAgID48L3NjLXRleHQ+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbc3RhdGU9JyddXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLWJ1dHRvblxuICAgICAgICB2YWx1ZT1cInBsYXlcIlxuICAgICAgICB3aWR0aD1cIjEwMFwiXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXRyYW5zcG9ydCcpO1xuICAgICAgICAgICRjb21wb25lbnQuc3RhdGUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtYnV0dG9uPlxuICAgICAgPHNjLWJ1dHRvblxuICAgICAgICB2YWx1ZT1cInBhdXNlXCJcbiAgICAgICAgd2lkdGg9XCIxMDBcIlxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10cmFuc3BvcnQnKTtcbiAgICAgICAgICAkY29tcG9uZW50LnN0YXRlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLWJ1dHRvbj5cbiAgICAgIDxzYy1idXR0b25cbiAgICAgICAgdmFsdWU9XCJzdG9wXCJcbiAgICAgICAgd2lkdGg9XCIxMDBcIlxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC10cmFuc3BvcnQnKTtcbiAgICAgICAgICAkY29tcG9uZW50LnN0YXRlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLWJ1dHRvbj5cbiAgICA8L3A+XG5cbiAgYDtcbn1cbiIsImltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGh0bWxgXG4gICAgPHByZT48Y29kZT5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLXJlY29yZC5qcyc7XG5cbiR7YDxzYy1yZWNvcmQ+PC9zYy1yZWNvcmQ+YH1cbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICA8c2MtcmVjb3JkXG4gICAgICBpZD1cInRlc3QtcmVjb3JkXCJcbiAgICAgIEBjaGFuZ2U9XCIke2UgPT4ge1xuICAgICAgICBjb25zdCAkZXZlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcmVjb3JkLWNoYW5nZScpO1xuICAgICAgICAkZXZlbnQuYWN0aXZlID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICB9fVwiXG4gICAgPjwvc2MtcmVjb3JkPlxuXG4gICAgPGgzPkV2ZW50czwvaDM+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIkBjaGFuZ2VcIj48L3NjLXRleHQ+XG4gICAgICA8c2MtdG9nZ2xlIGlkPVwicmVjb3JkLWNoYW5nZVwiPjwvc2MtdG9nZ2xlPlxuICAgIDwvcD5cblxuICAgIDxoMz5BdHRyaWJ1dGVzPC9oMz5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW3dpZHRoPTMwXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMzBcIlxuICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICB2YWx1ZT1cIjMwXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1yZWNvcmQnKTtcbiAgICAgICAgICAkY29tcG9uZW50LndpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltoZWlnaHQ9MzBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIzMFwiXG4gICAgICAgIG1heD1cIjMwMFwiXG4gICAgICAgIHZhbHVlPVwiMzBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXJlY29yZCcpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlthY3RpdmU9ZmFsc2VdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRvZ2dsZVxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3QtcmVjb3JkJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5hY3RpdmUgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtdG9nZ2xlPlxuICAgIDwvcD5cbiAgYDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNpbmVHZW5lcmF0b3IoZnJlcXVlbmN5LCBzYW1wbGVSYXRlLCBibG9ja1NpemUsIGNhbGxiYWNrLCBuYnJCbG9ja3MgPSBJbmZpbml0eSkge1xuICBjb25zdCBzZWxmID0ge307XG5cbiAgY29uc3QgYmxvY2sgPSBuZXcgRmxvYXQzMkFycmF5KGJsb2NrU2l6ZSk7XG4gIGNvbnN0IHRJbmNyID0gYmxvY2tTaXplIC8gc2FtcGxlUmF0ZTtcbiAgY29uc3QgXzJQSSA9IDIgKiBNYXRoLlBJO1xuXG4gIGxldCBwSW5jciA9IGZyZXF1ZW5jeSAvIHNhbXBsZVJhdGU7XG4gIGxldCBwaGFzZSA9IDA7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBsZXQgdGltZSA9IDA7XG4gIGxldCBjb3VudGVyID0gMDtcblxuICBzZWxmLmZyZXF1ZW5jeSA9IChmcmVxdWVuY3kpID0+IHtcbiAgICAvLyBtdWx0ID0gXzJQSSAqIGZyZXF1ZW5jeTtcbiAgICBwSW5jciA9IGZyZXF1ZW5jeSAvIHNhbXBsZVJhdGU7XG4gIH1cblxuICBzZWxmLnN0YXJ0ID0gKCkgPT4ge1xuICAgIChmdW5jdGlvbiBjcmVhdGVCbG9jaygpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnNpbihwaGFzZSAqIF8yUEkpO1xuICAgICAgICBibG9ja1tpXSA9IHZhbHVlO1xuICAgICAgICBwaGFzZSA9IChwaGFzZSArIHBJbmNyKSAlIDE7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHRpbWUsIGJsb2NrKTtcblxuICAgICAgdGltZSArPSB0SW5jcjtcbiAgICAgIGNvdW50ZXIgKz0gMTtcblxuICAgICAgaWYgKGNvdW50ZXIgPCBuYnJCbG9ja3MpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChjcmVhdGVCbG9jaywgdEluY3IgKiAxMDAwKTtcbiAgICAgIH1cbiAgICB9KCkpO1xuICB9XG5cbiAgc2VsZi5zdG9wID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0L2h0bWwuanMnO1xuaW1wb3J0IHNpbmVHZW5lcmF0b3IgZnJvbSAnLi91dGlscy9zaW5lR2VuZXJhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAvLyBkaXJ0eSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnN0ICRzaWduYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1zaWduYWwnKTtcblxuICAgIGxldCBmcmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc2luZTEgPSBzaW5lR2VuZXJhdG9yKDAuNSwgMjUsIDEsICh0aW1lLCBkYXRhKSA9PiB7XG4gICAgICBmcmFtZSA9IHsgdGltZSwgZGF0YTogQXJyYXkuZnJvbShkYXRhKSB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzaW5lMiA9IHNpbmVHZW5lcmF0b3IoMSwgMjUsIDEsICh0aW1lLCBkYXRhKSA9PiB7XG4gICAgICBmcmFtZS5kYXRhWzFdID0gZGF0YVswXSAqIDAuNTtcbiAgICAgICRzaWduYWwudmFsdWUgPSBmcmFtZTtcbiAgICB9KTtcblxuICAgIHNpbmUxLnN0YXJ0KCk7XG4gICAgc2luZTIuc3RhcnQoKTtcblxuICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vICAgc2luZTEuc3RvcCgpO1xuICAgIC8vICAgc2luZTIuc3RvcCgpO1xuICAgIC8vIH0sIDIwMDApO1xuICB9LCAxNTApO1xuXG4gIHJldHVybiBodG1sYFxuICAgIDxwcmU+PGNvZGU+XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1zaWduYWwuanMnO1xuXG4ke2A8c2Mtc2lnbmFsPjwvc2Mtc2lnbmFsPmB9XG4gICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgPHNjLXNpZ25hbCBpZD1cInRlc3Qtc2lnbmFsXCI+PC9zYy1zaWduYWw+XG5cbiAgICA8aDM+QXR0cmlidXRlczwvaDM+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlt3aWR0aD0zMDBdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIxMDBcIlxuICAgICAgICBtYXg9XCI2MDBcIlxuICAgICAgICB2YWx1ZT1cIjMwMFwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2lnbmFsJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC53aWR0aCA9IGUuZGV0YWlsLnZhbHVlO1xuICAgICAgICB9fVwiXG4gICAgICA+PC9zYy1udW1iZXI+XG4gICAgPC9wPlxuICAgIDxwPlxuICAgICAgPHNjLXRleHQgcmVhZG9ubHkgdmFsdWU9XCJbaGVpZ2h0PTE1MF1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjc1XCJcbiAgICAgICAgbWF4PVwiMzAwXCJcbiAgICAgICAgdmFsdWU9XCIxNTBcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNpZ25hbCcpO1xuICAgICAgICAgICRjb21wb25lbnQuaGVpZ2h0ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlttaW49LTFdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCItMTBcIlxuICAgICAgICBtYXg9XCItMVwiXG4gICAgICAgIHZhbHVlPVwiLTFcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNpZ25hbCcpO1xuICAgICAgICAgICRjb21wb25lbnQubWluID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIlttYXg9MV1cIj48L3NjLXRleHQ+XG4gICAgICA8c2MtbnVtYmVyXG4gICAgICAgIG1pbj1cIjFcIlxuICAgICAgICBtYXg9XCIxMFwiXG4gICAgICAgIHZhbHVlPVwiMVwiXG4gICAgICAgIGludGVnZXJcbiAgICAgICAgQGlucHV0PVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2lnbmFsJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5tYXggPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgICAgfX1cIlxuICAgICAgPjwvc2MtbnVtYmVyPlxuICAgIDwvcD5cbiAgICA8cD5cbiAgICAgIDxzYy10ZXh0IHJlYWRvbmx5IHZhbHVlPVwiW2R1cmF0aW9uPS0xXVwiPjwvc2MtdGV4dD5cbiAgICAgIDxzYy1udW1iZXJcbiAgICAgICAgbWluPVwiMVwiXG4gICAgICAgIG1heD1cIjEwXCJcbiAgICAgICAgdmFsdWU9XCIxXCJcbiAgICAgICAgaW50ZWdlclxuICAgICAgICBAaW5wdXQ9XCIke2UgPT4ge1xuICAgICAgICAgIGNvbnN0ICRjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVzdC1zaWduYWwnKTtcbiAgICAgICAgICAkY29tcG9uZW50LmR1cmF0aW9uID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltsaW5lLXdpZHRoPTFdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLW51bWJlclxuICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgbWF4PVwiMTBcIlxuICAgICAgICB2YWx1ZT1cIjFcIlxuICAgICAgICBpbnRlZ2VyXG4gICAgICAgIEBpbnB1dD1cIiR7ZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0LXNpZ25hbCcpO1xuICAgICAgICAgICRjb21wb25lbnQubGluZVdpZHRoID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLW51bWJlcj5cbiAgICA8L3A+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB2YWx1ZT1cIltkaXNwbGF5LW1pbi1tYXg9ZmFsc2VdXCI+PC9zYy10ZXh0PlxuICAgICAgPHNjLXRvZ2dsZVxuICAgICAgICBAY2hhbmdlPVwiJHtlID0+IHtcbiAgICAgICAgICBjb25zdCAkY29tcG9uZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Rlc3Qtc2lnbmFsJyk7XG4gICAgICAgICAgJGNvbXBvbmVudC5kaXNwbGF5TWluTWF4ID0gZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIH19XCJcbiAgICAgID48L3NjLXRvZ2dsZT5cbiAgICA8L3A+XG5cbiAgICA8aDM+UHJvcGVydGllczwvaDM+XG4gICAgPHA+XG4gICAgICA8c2MtdGV4dCByZWFkb25seSB3aWR0aD1cIjM1MFwiIHZhbHVlPVwidmFsdWU9eyB0aW1lPE51bWJlcj4oc2Vjb25kcyksIGRhdGE8QXJyYXk+IH1cIj48L3NjLXRleHQ+XG4gICAgPHA+XG4gIGA7XG59XG4iLCJpbXBvcnQgJ0BiYWJlbC9wb2x5ZmlsbCc7XG5pbXBvcnQgeyBodG1sLCByZW5kZXIgfSBmcm9tICdsaXQvaHRtbC5qcyc7XG5pbXBvcnQgeyB1bnRpbCB9IGZyb20gJ2xpdC9kaXJlY3RpdmVzL3VudGlsLmpzJztcbmltcG9ydCB7IHVuc2FmZUhUTUwgfSBmcm9tICdsaXQvZGlyZWN0aXZlcy91bnNhZmUtaHRtbC5qcyc7XG5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLXBvc2l0aW9uLXN1cmZhY2UuanMnO1xuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2Mtc3BlZWQtc3VyZmFjZS5qcyc7XG5cbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWJ1dHRvbi5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy10b2dnbGUuanMnO1xuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2Mtc2xpZGVyLmpzJztcbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLW51bWJlci5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1lZGl0b3IuanMnO1xuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2MtdGV4dC5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1iYW5nLmpzJztcbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLXNpZ25hbC5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1kb3QtbWFwLmpzJztcbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWRyYWduZHJvcC5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy1tYXRyaXguanMnO1xuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2MtY29udGV4dC1tZW51LmpzJztcbmltcG9ydCAnQGlyY2FtL3NpbXBsZS1jb21wb25lbnRzL3NjLWZpbGUtdHJlZS5qcyc7XG5pbXBvcnQgJ0BpcmNhbS9zaW1wbGUtY29tcG9uZW50cy9zYy10cmFuc3BvcnQuanMnO1xuaW1wb3J0ICdAaXJjYW0vc2ltcGxlLWNvbXBvbmVudHMvc2MtcmVjb3JkLmpzJztcblxuLy8gY29udHJvbHNcbmltcG9ydCBtYXRyaXggZnJvbSAnLi9zYy1tYXRyaXgtZXhhbXBsZS5qcyc7XG5pbXBvcnQgZHJhZ25kcm9wIGZyb20gJy4vc2MtZHJhZ25kcm9wLWV4YW1wbGUuanMnO1xuaW1wb3J0IGJhbmcgZnJvbSAnLi9zYy1iYW5nLWV4YW1wbGUuanMnO1xuaW1wb3J0IGJ1dHRvbiBmcm9tICcuL3NjLWJ1dHRvbi1leGFtcGxlLmpzJztcbmltcG9ydCBlZGl0b3IgZnJvbSAnLi9zYy1lZGl0b3ItZXhhbXBsZS5qcyc7XG5pbXBvcnQgbnVtYmVyIGZyb20gJy4vc2MtbnVtYmVyLWV4YW1wbGUuanMnO1xuaW1wb3J0IHNsaWRlciBmcm9tICcuL3NjLXNsaWRlci1leGFtcGxlLmpzJztcbmltcG9ydCB0ZXh0IGZyb20gJy4vc2MtdGV4dC1leGFtcGxlLmpzJztcbmltcG9ydCB0b2dnbGUgZnJvbSAnLi9zYy10b2dnbGUtZXhhbXBsZS5qcyc7XG5pbXBvcnQgZG90TWFwIGZyb20gJy4vc2MtZG90LW1hcC1leGFtcGxlLmpzJztcbmltcG9ydCBjb250ZXh0TWVudSBmcm9tICcuL3NjLWNvbnRleHQtbWVudS1leGFtcGxlLmpzJztcbmltcG9ydCBmaWxlVHJlZSBmcm9tICcuL3NjLWZpbGUtdHJlZS1leGFtcGxlLmpzJztcbmltcG9ydCB0cmFuc3BvcnQgZnJvbSAnLi9zYy10cmFuc3BvcnQtZXhhbXBsZS5qcyc7XG5pbXBvcnQgcmVjb3JkIGZyb20gJy4vc2MtcmVjb3JkLWV4YW1wbGUuanMnO1xuXG4vLyBtb25pdG9yaW5nXG5pbXBvcnQgc2lnbmFsIGZyb20gJy4vc2Mtc2lnbmFsLWV4YW1wbGUuanMnO1xuXG5jb25zdCBkb2NzID0ge1xuICAnc2MtYmFuZyc6IGJhbmcsXG4gICdzYy10b2dnbGUnOiB0b2dnbGUsXG4gICdzYy1udW1iZXInOiBudW1iZXIsXG4gICdzYy1zbGlkZXInOiBzbGlkZXIsXG4gICdzYy1idXR0b24nOiBidXR0b24sXG4gICdzYy10ZXh0JzogdGV4dCxcbiAgJ3NjLXRyYW5zcG9ydCc6IHRyYW5zcG9ydCxcbiAgJ3NjLXJlY29yZCc6IHJlY29yZCxcbiAgJ3NjLWVkaXRvcic6IGVkaXRvcixcbiAgJ3NjLW1hdHJpeCc6IG1hdHJpeCxcbiAgJ3NjLWRvdC1tYXAnOiBkb3RNYXAsXG4gICdzYy1kcmFnbmRyb3AnOiBkcmFnbmRyb3AsXG4gICdzYy1jb250ZXh0LW1lbnUnOiBjb250ZXh0TWVudSxcbiAgJ3NjLXNpZ25hbCc6IHNpZ25hbCxcbiAgJ3NjLWZpbGUtdHJlZSc6IGZpbGVUcmVlLFxuICAnc2MtdHJhbnNwb3J0JzogdHJhbnNwb3J0LFxufTtcblxuZnVuY3Rpb24gc2V0VGhlbWUobmFtZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdsaWdodCc6XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbGlnaHQnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RhcmsnOlxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdsaWdodCcpO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdkYXJrJyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5zZXRUaGVtZSgnbGlnaHQnKTtcblxucmVuZGVyKGh0bWxgXG4gIDxzZWN0aW9uIGNsYXNzPVwibWVudVwiPlxuICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vaXJjYW0taXNtbS9zaW1wbGUtY29tcG9uZW50c1wiPlxuICAgICAgPHNjLWJ1dHRvbiB0ZXh0PVwiR2l0aHViXCI+PC9zYy1idXR0b24+XG4gICAgPC9hPlxuICAgIDxzYy1idXR0b24gdGV4dD1cImRhcmsgYmFja2dyb3VuZFwiIEBwcmVzcz1cIiR7ZSA9PiBzZXRUaGVtZSgnZGFyaycpfVwiPjwvc2MtYnV0dG9uPlxuICAgIDxzYy1idXR0b24gdGV4dD1cImxpZ2h0IGJhY2tncm91bmRcIiBAcHJlc3M9XCIke2UgPT4gc2V0VGhlbWUoJ2xpZ2h0Jyl9XCI+PC9zYy1idXR0b24+XG5cbiAgICAke09iamVjdC5rZXlzKGRvY3MpLm1hcChuYW1lID0+IGh0bWxgPGEgaHJlZj1cIiMke25hbWV9XCI+Jmx0OyR7bmFtZX0mZ3Q7PC9hPmApfVxuXG4gIDwvc2VjdGlvbj5cbiAgPHNlY3Rpb24gY2xhc3M9XCJjb250ZW50XCI+XG4gICAgPGgxPnNjLWNvbXBvbmVudHM8L2gxPlxuXG4gICAgPHByZT48Y29kZT5cbm5wbSBpbnN0YWxsIEBpcmNhbS9zaW1wbGUtY29tcG9uZW50cyAtLXNhdmVcbiAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICAke09iamVjdC5rZXlzKGRvY3MpLm1hcChuYW1lID0+IHtcbiAgICAgIHJldHVybiBodG1sYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcG9uZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImRvY1wiPlxuICAgICAgICAgICAgPGgyPjxhIGhyZWY9XCIjJHtuYW1lfVwiIGlkPVwiJHtuYW1lfVwiIG5hbWU9XCIke25hbWV9XCI+IzwvYT4gJHtuYW1lfTwvaDI+XG4gICAgICAgICAgICAke2RvY3NbbmFtZV0oKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgIH0pfVxuXG4gICAgPGRpdiBzdHlsZT1cImhlaWdodDogMzAwcHhcIj4mbmJzcDs8L2Rpdj5cbiAgPC9zZWN0aW9uPlxuYCwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRhaW5lcicpKVxuIl0sIm5hbWVzIjpbImdsb2JhbCIsIm1vZHVsZSIsIndpbmRvdyIsIk1hdGgiLCJzZWxmIiwiRnVuY3Rpb24iLCJfX2ciLCJoYXNPd25Qcm9wZXJ0eSIsIml0Iiwia2V5IiwiY2FsbCIsImV4ZWMiLCJlIiwicmVxdWlyZSQkMCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYSIsImNvcmUiLCJ2ZXJzaW9uIiwiX19lIiwiaXNPYmplY3QiLCJUeXBlRXJyb3IiLCJkb2N1bWVudCIsImlzIiwiY3JlYXRlRWxlbWVudCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiUyIsImZuIiwidmFsIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwiZFAiLCJPIiwiUCIsIkF0dHJpYnV0ZXMiLCJhbk9iamVjdCIsInRvUHJpbWl0aXZlIiwiSUU4X0RPTV9ERUZJTkUiLCJ2YWx1ZSIsImJpdG1hcCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm9iamVjdCIsImYiLCJjcmVhdGVEZXNjIiwiaWQiLCJweCIsInJhbmRvbSIsImNvbmNhdCIsInVuZGVmaW5lZCIsIlNIQVJFRCIsInN0b3JlIiwicHVzaCIsIm1vZGUiLCJjb3B5cmlnaHQiLCJTUkMiLCJUT19TVFJJTkciLCJUUEwiLCIkdG9TdHJpbmciLCJzcGxpdCIsImluc3BlY3RTb3VyY2UiLCJzYWZlIiwiaXNGdW5jdGlvbiIsImhhcyIsImhpZGUiLCJqb2luIiwiU3RyaW5nIiwicHJvdG90eXBlIiwidGhhdCIsImxlbmd0aCIsImFGdW5jdGlvbiIsImIiLCJjIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJQUk9UT1RZUEUiLCIkZXhwb3J0IiwidHlwZSIsIm5hbWUiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiSVNfQklORCIsIkIiLCJ0YXJnZXQiLCJleHBvcnRzIiwiZXhwUHJvdG8iLCJvd24iLCJvdXQiLCJleHAiLCJjdHgiLCJyZWRlZmluZSIsIlUiLCJXIiwiUiIsIk1FVEEiLCJzZXREZXNjIiwiaXNFeHRlbnNpYmxlIiwiRlJFRVpFIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRNZXRhIiwiaSIsInciLCJmYXN0S2V5IiwiY3JlYXRlIiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJLRVkiLCJTeW1ib2wiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJ1aWQiLCJkZWYiLCJUQUciLCJ0YWciLCJzdGF0IiwiJFN5bWJvbCIsIkxJQlJBUlkiLCJjaGFyQXQiLCJ3a3NFeHQiLCJzbGljZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY29mIiwiSU9iamVjdCIsImRlZmluZWQiLCJjZWlsIiwiZmxvb3IiLCJpc05hTiIsIm1pbiIsInRvSW50ZWdlciIsIm1heCIsImluZGV4IiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwidG9JT2JqZWN0IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJzaGFyZWQiLCJhcnJheUluZGV4T2YiLCJJRV9QUk9UTyIsIm5hbWVzIiwicmVzdWx0Iiwia2V5cyIsIiRrZXlzIiwiZW51bUJ1Z0tleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRLZXlzIiwiZ2V0U3ltYm9scyIsImdPUFMiLCJzeW1ib2xzIiwiaXNFbnVtIiwicElFIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJnIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJFbXB0eSIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsImd0IiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwid3JpdGUiLCJjbG9zZSIsImRQcyIsImhpZGRlbktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ09QTiIsIndpbmRvd05hbWVzIiwiZ2V0V2luZG93TmFtZXMiLCJnT1BEIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJEdPUEQiLCIkRFAiLCJnT1BORXh0IiwiJEpTT04iLCJKU09OIiwiX3N0cmluZ2lmeSIsInN0cmluZ2lmeSIsIkhJRERFTiIsIndrcyIsIlRPX1BSSU1JVElWRSIsIlN5bWJvbFJlZ2lzdHJ5IiwiQWxsU3ltYm9scyIsIk9QU3ltYm9scyIsIk9iamVjdFByb3RvIiwiVVNFX05BVElWRSIsIiRHT1BTIiwiUU9iamVjdCIsInNldHRlciIsImZpbmRDaGlsZCIsInNldFN5bWJvbERlc2MiLCJERVNDUklQVE9SUyIsIiRmYWlscyIsIl9jcmVhdGUiLCJEIiwicHJvdG9EZXNjIiwid3JhcCIsInN5bSIsIl9rIiwiaXNTeW1ib2wiLCJpdGVyYXRvciIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bUtleXMiLCJsIiwiJGNyZWF0ZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldE93blByb3BlcnR5TmFtZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiSVNfT1AiLCIkc2V0Iiwic2V0IiwicmVxdWlyZSQkMyIsImVzNlN5bWJvbHMiLCJqIiwid2VsbEtub3duU3ltYm9scyIsImsiLCJ3a3NEZWZpbmUiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJGQUlMU19PTl9QUklNSVRJVkVTIiwidG9PYmplY3QiLCJhcmdzIiwicmVwbGFjZXIiLCIkcmVwbGFjZXIiLCJyZXF1aXJlJCQ0Iiwic2V0VG9TdHJpbmdUYWciLCJmYWlscyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCIkZ2V0UHJvdG90eXBlT2YiLCIkZnJlZXplIiwiZnJlZXplIiwiJHNlYWwiLCJzZWFsIiwiJHByZXZlbnRFeHRlbnNpb25zIiwiJGlzRnJvemVuIiwiaXNGcm96ZW4iLCIkaXNTZWFsZWQiLCJpc1NlYWxlZCIsIiRpc0V4dGVuc2libGUiLCIkYXNzaWduIiwiYXNzaWduIiwiQSIsIksiLCJmb3JFYWNoIiwiVCIsImFMZW4iLCJ4IiwieSIsImNoZWNrIiwicHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsInRlc3QiLCJidWdneSIsIl9fcHJvdG9fXyIsIkFSRyIsInRyeUdldCIsImNhbGxlZSIsImNsYXNzb2YiLCJ1biIsImFycmF5U2xpY2UiLCJmYWN0b3JpZXMiLCJjb25zdHJ1Y3QiLCJsZW4iLCJuIiwiYmluZCIsInBhcnRBcmdzIiwiYm91bmQiLCJpbnZva2UiLCJGUHJvdG8iLCJuYW1lUkUiLCJOQU1FIiwibWF0Y2giLCJIQVNfSU5TVEFOQ0UiLCJGdW5jdGlvblByb3RvIiwic3BhY2UiLCJzcGFjZXMiLCJub24iLCJsdHJpbSIsIlJlZ0V4cCIsInJ0cmltIiwiZXhwb3J0ZXIiLCJBTElBUyIsIkZPUkNFIiwidHJpbSIsInN0cmluZyIsIlRZUEUiLCJyZXBsYWNlIiwiJHBhcnNlSW50IiwicGFyc2VJbnQiLCIkdHJpbSIsImhleCIsIndzIiwic3RyIiwicmFkaXgiLCIkcGFyc2VGbG9hdCIsInBhcnNlRmxvYXQiLCJJbmZpbml0eSIsIkMiLCJOVU1CRVIiLCIkTnVtYmVyIiwiQmFzZSIsIkJST0tFTl9DT0YiLCJUUklNIiwidG9OdW1iZXIiLCJhcmd1bWVudCIsImZpcnN0IiwiY2hhckNvZGVBdCIsInRoaXJkIiwibWF4Q29kZSIsIk5hTiIsImRpZ2l0cyIsImNvZGUiLCJOdW1iZXIiLCJpbmhlcml0SWZSZXF1aXJlZCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwibXNnIiwicmVwZWF0IiwiY291bnQiLCJyZXMiLCJSYW5nZUVycm9yIiwiJHRvRml4ZWQiLCJ0b0ZpeGVkIiwiZGF0YSIsIkVSUk9SIiwiWkVSTyIsIm11bHRpcGx5IiwiYzIiLCJkaXZpZGUiLCJudW1Ub1N0cmluZyIsInMiLCJ0IiwicG93IiwiYWNjIiwibG9nIiwieDIiLCJmcmFjdGlvbkRpZ2l0cyIsImFOdW1iZXJWYWx1ZSIsIm0iLCJ6IiwiJHRvUHJlY2lzaW9uIiwidG9QcmVjaXNpb24iLCJwcmVjaXNpb24iLCJFUFNJTE9OIiwiX2lzRmluaXRlIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJudW1iZXIiLCJhYnMiLCJpc1NhZmVJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJsb2cxcCIsInNxcnQiLCIkYWNvc2giLCJhY29zaCIsIk1BWF9WQUxVRSIsIkxOMiIsIiRhc2luaCIsImFzaW5oIiwiJGF0YW5oIiwiYXRhbmgiLCJzaWduIiwiY2JydCIsImNsejMyIiwiTE9HMkUiLCJjb3NoIiwiJGV4cG0xIiwiZXhwbTEiLCJFUFNJTE9OMzIiLCJNQVgzMiIsIk1JTjMyIiwicm91bmRUaWVzVG9FdmVuIiwiZnJvdW5kIiwiJGFicyIsIiRzaWduIiwiaHlwb3QiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJzdW0iLCJsYXJnIiwiZGl2IiwiJGltdWwiLCJpbXVsIiwiVUlOVDE2IiwieG4iLCJ5biIsInhsIiwieWwiLCJsb2cxMCIsIkxPRzEwRSIsImxvZzIiLCJzaW5oIiwidGFuaCIsInRydW5jIiwiZnJvbUNoYXJDb2RlIiwiJGZyb21Db2RlUG9pbnQiLCJmcm9tQ29kZVBvaW50IiwicmF3IiwiY2FsbFNpdGUiLCJ0cGwiLCJwb3MiLCJJdGVyYXRvclByb3RvdHlwZSIsIkNvbnN0cnVjdG9yIiwibmV4dCIsImRlc2NyaXB0b3IiLCJJVEVSQVRPUiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCIkaXRlckNyZWF0ZSIsImdldE1ldGhvZCIsImtpbmQiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiREVGX1ZBTFVFUyIsIlZBTFVFU19CVUciLCIkbmF0aXZlIiwiJGRlZmF1bHQiLCIkZW50cmllcyIsIiRhbnlOYXRpdmUiLCJtZXRob2RzIiwiSXRlcmF0b3JzIiwiJGF0IiwiaXRlcmF0ZWQiLCJfdCIsIl9pIiwicG9pbnQiLCJkb25lIiwiY29kZVBvaW50QXQiLCJNQVRDSCIsImlzUmVnRXhwIiwic2VhcmNoU3RyaW5nIiwicmUiLCJFTkRTX1dJVEgiLCIkZW5kc1dpdGgiLCJlbmRzV2l0aCIsImNvbnRleHQiLCJlbmRQb3NpdGlvbiIsImVuZCIsInNlYXJjaCIsIklOQ0xVREVTIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwiU1RBUlRTX1dJVEgiLCIkc3RhcnRzV2l0aCIsInN0YXJ0c1dpdGgiLCJxdW90IiwiY3JlYXRlSFRNTCIsImF0dHJpYnV0ZSIsInAxIiwidG9Mb3dlckNhc2UiLCJhbmNob3IiLCJiaWciLCJibGluayIsImJvbGQiLCJmaXhlZCIsImZvbnRjb2xvciIsImNvbG9yIiwiZm9udHNpemUiLCJzaXplIiwiaXRhbGljcyIsImxpbmsiLCJ1cmwiLCJzbWFsbCIsInN0cmlrZSIsInN1YiIsInN1cCIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwidG9KU09OIiwidG9JU09TdHJpbmciLCJwdiIsIiR0b0lTT1N0cmluZyIsImx6IiwibnVtIiwiZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIkRhdGVQcm90byIsIklOVkFMSURfREFURSIsImhpbnQiLCJyZXQiLCJBcnJheVByb3RvIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJTQUZFX0NMT1NJTkciLCJyaXRlciIsImZyb20iLCJza2lwQ2xvc2luZyIsImFyciIsIml0ZXIiLCJhcnJheUxpa2UiLCJtYXBmbiIsIm1hcHBpbmciLCJpdGVyRm4iLCJnZXRJdGVyRm4iLCJzdGVwIiwiaXNBcnJheUl0ZXIiLCJjcmVhdGVQcm9wZXJ0eSIsIm9mIiwibWV0aG9kIiwiYXJyYXlKb2luIiwic2VwYXJhdG9yIiwiaHRtbCIsImJlZ2luIiwia2xhc3MiLCJzdGFydCIsInVwVG8iLCJjbG9uZWQiLCIkc29ydCIsInNvcnQiLCJjb21wYXJlZm4iLCJTUEVDSUVTIiwib3JpZ2luYWwiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCJJU19NQVAiLCJJU19GSUxURVIiLCJJU19TT01FIiwiSVNfRVZFUlkiLCJJU19GSU5EX0lOREVYIiwiTk9fSE9MRVMiLCJhc2MiLCJjYWxsYmFja2ZuIiwiJGZvckVhY2giLCJTVFJJQ1QiLCIkbWFwIiwibWFwIiwiJGZpbHRlciIsImZpbHRlciIsIiRzb21lIiwic29tZSIsIiRldmVyeSIsImV2ZXJ5IiwibWVtbyIsImlzUmlnaHQiLCJyZWR1Y2UiLCIkcmVkdWNlIiwicmVkdWNlUmlnaHQiLCIkaW5kZXhPZiIsIk5FR0FUSVZFX1pFUk8iLCJzZWFyY2hFbGVtZW50IiwibGFzdEluZGV4T2YiLCJjb3B5V2l0aGluIiwidG8iLCJpbmMiLCJVTlNDT1BBQkxFUyIsImZpbGwiLCJlbmRQb3MiLCIkZmluZCIsImZvcmNlZCIsImZpbmQiLCJmaW5kSW5kZXgiLCJBcmd1bWVudHMiLCJhZGRUb1Vuc2NvcGFibGVzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsInVuaWNvZGUiLCJzdGlja3kiLCIkUmVnRXhwIiwicmUxIiwicmUyIiwiQ09SUkVDVF9ORVciLCJwIiwidGlSRSIsInBpUkUiLCJmaVUiLCIkZmxhZ3MiLCJwcm94eSIsIm5hdGl2ZUV4ZWMiLCJuYXRpdmVSZXBsYWNlIiwicGF0Y2hlZEV4ZWMiLCJMQVNUX0lOREVYIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwiTlBDR19JTkNMVURFRCIsIlBBVENIIiwibGFzdEluZGV4IiwicmVDb3B5IiwicmVnZXhwRmxhZ3MiLCJyZWdleHBFeGVjIiwiZmxhZ3MiLCJkZWZpbmUiLCJhdCIsImJ1aWx0aW5FeGVjIiwiUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMiLCJncm91cHMiLCJTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMiLCJvcmlnaW5hbEV4ZWMiLCJTWU1CT0wiLCJERUxFR0FURVNfVE9fU1lNQk9MIiwiREVMRUdBVEVTX1RPX0VYRUMiLCJleGVjQ2FsbGVkIiwibmF0aXZlUmVnRXhwTWV0aG9kIiwiZm5zIiwibWF5YmVDYWxsTmF0aXZlIiwibmF0aXZlTWV0aG9kIiwicmVnZXhwIiwiYXJnMiIsImZvcmNlU3RyaW5nTWV0aG9kIiwic3RyZm4iLCJyeGZuIiwiJG1hdGNoIiwicngiLCJyZWdFeHBFeGVjIiwiZnVsbFVuaWNvZGUiLCJtYXRjaFN0ciIsImFkdmFuY2VTdHJpbmdJbmRleCIsIlNVQlNUSVRVVElPTl9TWU1CT0xTIiwiU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQiLCJtYXliZVRvU3RyaW5nIiwiUkVQTEFDRSIsIiRyZXBsYWNlIiwic2VhcmNoVmFsdWUiLCJyZXBsYWNlVmFsdWUiLCJmdW5jdGlvbmFsUmVwbGFjZSIsInJlc3VsdHMiLCJhY2N1bXVsYXRlZFJlc3VsdCIsIm5leHRTb3VyY2VQb3NpdGlvbiIsIm1hdGNoZWQiLCJwb3NpdGlvbiIsImNhcHR1cmVzIiwibmFtZWRDYXB0dXJlcyIsInJlcGxhY2VyQXJncyIsInJlcGxhY2VtZW50IiwiZ2V0U3Vic3RpdHV0aW9uIiwidGFpbFBvcyIsImNoIiwiY2FwdHVyZSIsIlNFQVJDSCIsIiRzZWFyY2giLCJwcmV2aW91c0xhc3RJbmRleCIsInNhbWVWYWx1ZSIsIiRtaW4iLCIkcHVzaCIsIiRTUExJVCIsIkxFTkdUSCIsIk1BWF9VSU5UMzIiLCJTVVBQT1JUU19ZIiwiU1BMSVQiLCIkc3BsaXQiLCJpbnRlcm5hbFNwbGl0IiwibGltaXQiLCJvdXRwdXQiLCJsYXN0TGFzdEluZGV4Iiwic3BsaXRMaW1pdCIsInNlcGFyYXRvckNvcHkiLCJsYXN0TGVuZ3RoIiwic3BsaXR0ZXIiLCJ1bmljb2RlTWF0Y2hpbmciLCJsaW0iLCJjYWxsUmVnRXhwRXhlYyIsInEiLCJmb3JiaWRkZW5GaWVsZCIsIkJSRUFLIiwiUkVUVVJOIiwiaXRlcmFibGUiLCJwcm9jZXNzIiwic2V0VGFzayIsInNldEltbWVkaWF0ZSIsImNsZWFyVGFzayIsImNsZWFySW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJEaXNwYXRjaCIsImNvdW50ZXIiLCJxdWV1ZSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJydW4iLCJsaXN0ZW5lciIsImV2ZW50IiwibmV4dFRpY2siLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsImNlbCIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsImNsZWFyIiwibWFjcm90YXNrIiwiT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsIlByb21pc2UiLCJpc05vZGUiLCJoZWFkIiwibGFzdCIsIm5vdGlmeSIsImZsdXNoIiwicGFyZW50IiwiZG9tYWluIiwiZXhpdCIsImVudGVyIiwibmF2aWdhdG9yIiwic3RhbmRhbG9uZSIsInRvZ2dsZSIsIm5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicmVzb2x2ZSIsInByb21pc2UiLCJ0aGVuIiwidGFzayIsIlByb21pc2VDYXBhYmlsaXR5IiwicmVqZWN0IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCJ2IiwidXNlckFnZW50IiwicHJvbWlzZUNhcGFiaWxpdHkiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsIm1pY3JvdGFzayIsIlBST01JU0UiLCJ2ZXJzaW9ucyIsInY4IiwiJFByb21pc2UiLCJlbXB0eSIsIkludGVybmFsIiwibmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5IiwiT3duUHJvbWlzZUNhcGFiaWxpdHkiLCJXcmFwcGVyIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJGYWtlUHJvbWlzZSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIl9uIiwiY2hhaW4iLCJfYyIsIl92Iiwib2siLCJfcyIsInJlYWN0aW9uIiwiaGFuZGxlciIsImZhaWwiLCJleGl0ZWQiLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsImNvbnNvbGUiLCJwZXJmb3JtIiwiZW1pdCIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwicmVhc29uIiwiZXJyb3IiLCJfYSIsIm9ucmVqZWN0aW9uaGFuZGxlZCIsIiRyZWplY3QiLCJfZCIsIl93IiwiJHJlc29sdmUiLCJ3cmFwcGVyIiwiZXhlY3V0b3IiLCJhbkluc3RhbmNlIiwiZXJyIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiciIsImNhcGFiaWxpdHkiLCJwcm9taXNlUmVzb2x2ZSIsInJlcXVpcmUkJDciLCJhbGwiLCJyZW1haW5pbmciLCJmb3JPZiIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwiU0laRSIsImdldEVudHJ5IiwiZW50cnkiLCJfZiIsImdldENvbnN0cnVjdG9yIiwiQURERVIiLCJfbCIsInJlZGVmaW5lQWxsIiwidmFsaWRhdGUiLCJwcmV2Iiwic2V0U3Ryb25nIiwiJGl0ZXJEZWZpbmUiLCJzZXRTcGVjaWVzIiwiY29tbW9uIiwiSVNfV0VBSyIsImZpeE1ldGhvZCIsImFkZCIsImluc3RhbmNlIiwiSEFTTlRfQ0hBSU5JTkciLCJUSFJPV1NfT05fUFJJTUlUSVZFUyIsIkFDQ0VQVF9JVEVSQUJMRVMiLCIkaXRlckRldGVjdCIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJNQVAiLCJNYXAiLCJzdHJvbmciLCJTRVQiLCJTZXQiLCJhcnJheUZpbmQiLCJjcmVhdGVBcnJheU1ldGhvZCIsImFycmF5RmluZEluZGV4IiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCJzcGxpY2UiLCIkaGFzIiwidWZzdG9yZSIsImVhY2giLCJOQVRJVkVfV0VBS19NQVAiLCJJU19JRTExIiwiQWN0aXZlWE9iamVjdCIsIldFQUtfTUFQIiwid2VhayIsIkludGVybmFsTWFwIiwiV2Vha01hcCIsIiRXZWFrTWFwIiwiV0VBS19TRVQiLCJXZWFrU2V0IiwiVFlQRUQiLCJWSUVXIiwiQUJWIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsIkNPTlNUUiIsIlR5cGVkIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9ycyIsIkFSUkFZX0JVRkZFUiIsIkRBVEFfVklFVyIsIldST05HX0xFTkdUSCIsIldST05HX0lOREVYIiwiJEFycmF5QnVmZmVyIiwiJERhdGFWaWV3IiwiQmFzZUJ1ZmZlciIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJidWZmZXIiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJ1bnBhY2tJRUVFNzU0IiwibkJpdHMiLCJ1bnBhY2tJMzIiLCJieXRlcyIsInBhY2tJOCIsInBhY2tJMTYiLCJwYWNrSTMyIiwicGFja0Y2NCIsInBhY2tGMzIiLCJhZGRHZXR0ZXIiLCJpbnRlcm5hbCIsInZpZXciLCJpc0xpdHRsZUVuZGlhbiIsIm51bUluZGV4IiwiaW50SW5kZXgiLCJ0b0luZGV4IiwiX2IiLCJwYWNrIiwicmV2ZXJzZSIsImNvbnZlcnNpb24iLCIkdHlwZWQiLCJieXRlTGVuZ3RoIiwiYXJyYXlGaWxsIiwiYnl0ZU9mZnNldCIsImJ1ZmZlckxlbmd0aCIsIm9mZnNldCIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRVaW50OCIsInNldEludDE2Iiwic2V0VWludDE2Iiwic2V0SW50MzIiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIkFycmF5QnVmZmVyUHJvdG8iLCIkc2V0SW50OCIsIiRpc1ZpZXciLCJpc1ZpZXciLCIkc2xpY2UiLCJmaW4iLCJ2aWV3UyIsInZpZXdUIiwiJGJ1ZmZlciIsInJlcXVpcmUkJDgiLCJwcm9wZXJ0eURlc2MiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwicmVxdWlyZSQkMjUiLCJyZXF1aXJlJCQyNiIsInJlcXVpcmUkJDI3IiwicmVxdWlyZSQkMjgiLCJjcmVhdGVBcnJheUluY2x1ZGVzIiwicmVxdWlyZSQkMjkiLCJyZXF1aXJlJCQzMCIsIkFycmF5SXRlcmF0b3JzIiwicmVxdWlyZSQkMzEiLCJyZXF1aXJlJCQzMiIsInJlcXVpcmUkJDMzIiwicmVxdWlyZSQkMzQiLCJyZXF1aXJlJCQzNSIsImFycmF5Q29weVdpdGhpbiIsInJlcXVpcmUkJDM2IiwicmVxdWlyZSQkMzciLCJyZXF1aXJlJCQzOCIsIlVpbnQ4QXJyYXkiLCJTSEFSRURfQlVGRkVSIiwiQllURVNfUEVSX0VMRU1FTlQiLCJhcnJheUZvckVhY2giLCJhcnJheUZpbHRlciIsImFycmF5U29tZSIsImFycmF5RXZlcnkiLCJhcnJheUluY2x1ZGVzIiwiYXJyYXlWYWx1ZXMiLCJhcnJheUtleXMiLCJhcnJheUVudHJpZXMiLCJhcnJheUxhc3RJbmRleE9mIiwiYXJyYXlSZWR1Y2UiLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb3J0IiwiYXJyYXlUb1N0cmluZyIsImFycmF5VG9Mb2NhbGVTdHJpbmciLCJ0b0xvY2FsZVN0cmluZyIsIlRZUEVEX0NPTlNUUlVDVE9SIiwiREVGX0NPTlNUUlVDVE9SIiwiQUxMX0NPTlNUUlVDVE9SUyIsIlRZUEVEX0FSUkFZIiwiYWxsb2NhdGUiLCJMSVRUTEVfRU5ESUFOIiwiVWludDE2QXJyYXkiLCJGT1JDRURfU0VUIiwidG9PZmZzZXQiLCJCWVRFUyIsInNwZWNpZXNGcm9tTGlzdCIsImxpc3QiLCJmcm9tTGlzdCIsIiRmcm9tIiwiJG9mIiwiVE9fTE9DQUxFX0JVRyIsIiR0b0xvY2FsZVN0cmluZyIsInByZWRpY2F0ZSIsIm1pZGRsZSIsInN1YmFycmF5IiwiJGJlZ2luIiwiJGl0ZXJhdG9ycyIsImlzVEFJbmRleCIsIiRnZXREZXNjIiwiJHNldERlc2MiLCJkZXNjIiwiJFR5cGVkQXJyYXlQcm90b3R5cGUkIiwiQ0xBTVBFRCIsIkdFVFRFUiIsIlNFVFRFUiIsIlR5cGVkQXJyYXkiLCJUQUMiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiZ2V0dGVyIiwibyIsInJvdW5kIiwiYWRkRWxlbWVudCIsIiRvZmZzZXQiLCIkbGVuZ3RoIiwiJGxlbiIsIiRuYXRpdmVJdGVyYXRvciIsIkNPUlJFQ1RfSVRFUl9OQU1FIiwiJGl0ZXJhdG9yIiwiaW5pdCIsIkludDhBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsInJBcHBseSIsIlJlZmxlY3QiLCJmQXBwbHkiLCJ0aGlzQXJndW1lbnQiLCJhcmd1bWVudHNMaXN0IiwiTCIsInJDb25zdHJ1Y3QiLCJORVdfVEFSR0VUX0JVRyIsIkFSR1NfQlVHIiwiVGFyZ2V0IiwibmV3VGFyZ2V0IiwiJGFyZ3MiLCJwcm9wZXJ0eUtleSIsImF0dHJpYnV0ZXMiLCJkZWxldGVQcm9wZXJ0eSIsIkVudW1lcmF0ZSIsImVudW1lcmF0ZSIsInJlY2VpdmVyIiwiZ2V0UHJvdG8iLCJvd25LZXlzIiwiViIsIm93bkRlc2MiLCJleGlzdGluZ0Rlc2NyaXB0b3IiLCJzZXRQcm90byIsIiRpbmNsdWRlcyIsIklTX0NPTkNBVF9TUFJFQURBQkxFIiwiZmxhdHRlbkludG9BcnJheSIsInNvdXJjZUxlbiIsImRlcHRoIiwibWFwcGVyIiwidGhpc0FyZyIsInRhcmdldEluZGV4Iiwic291cmNlSW5kZXgiLCJtYXBGbiIsImVsZW1lbnQiLCJzcHJlYWRhYmxlIiwiZmxhdE1hcCIsImFycmF5U3BlY2llc0NyZWF0ZSIsIm1heExlbmd0aCIsImZpbGxTdHJpbmciLCJsZWZ0Iiwic3RyaW5nTGVuZ3RoIiwiZmlsbFN0ciIsImludE1heExlbmd0aCIsImZpbGxMZW4iLCJzdHJpbmdGaWxsZXIiLCJXRUJLSVRfQlVHIiwicGFkU3RhcnQiLCIkcGFkIiwicGFkRW5kIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZ2V0RGVzYyIsImlzRW50cmllcyIsIiR2YWx1ZXMiLCJvbkZpbmFsbHkiLCJNU0lFIiwidGltZSIsImJvdW5kQXJncyIsInNldEludGVydmFsIiwiJHRhc2siLCJUT19TVFJJTkdfVEFHIiwiQXJyYXlWYWx1ZXMiLCJET01JdGVyYWJsZXMiLCJDU1NSdWxlTGlzdCIsIkNTU1N0eWxlRGVjbGFyYXRpb24iLCJDU1NWYWx1ZUxpc3QiLCJDbGllbnRSZWN0TGlzdCIsIkRPTVJlY3RMaXN0IiwiRE9NU3RyaW5nTGlzdCIsIkRPTVRva2VuTGlzdCIsIkRhdGFUcmFuc2Zlckl0ZW1MaXN0IiwiRmlsZUxpc3QiLCJIVE1MQWxsQ29sbGVjdGlvbiIsIkhUTUxDb2xsZWN0aW9uIiwiSFRNTEZvcm1FbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJNZWRpYUxpc3QiLCJNaW1lVHlwZUFycmF5IiwiTmFtZWROb2RlTWFwIiwiTm9kZUxpc3QiLCJQYWludFJlcXVlc3RMaXN0IiwiUGx1Z2luIiwiUGx1Z2luQXJyYXkiLCJTVkdMZW5ndGhMaXN0IiwiU1ZHTnVtYmVyTGlzdCIsIlNWR1BhdGhTZWdMaXN0IiwiU1ZHUG9pbnRMaXN0IiwiU1ZHU3RyaW5nTGlzdCIsIlNWR1RyYW5zZm9ybUxpc3QiLCJTb3VyY2VCdWZmZXJMaXN0IiwiU3R5bGVTaGVldExpc3QiLCJUZXh0VHJhY2tDdWVMaXN0IiwiVGV4dFRyYWNrTGlzdCIsIlRvdWNoTGlzdCIsImNvbGxlY3Rpb25zIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJvYmoiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJzdGF0ZSIsIkVycm9yIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsInBvcCIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiZ2xvYmFsVGhpcyIsIklTX1dSQVAiLCJ2aXJ0dWFsIiwiX2dsb2JhbCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfX2VzTW9kdWxlIiwiX2JhYmVsUG9seWZpbGwiLCJ3YXJuIiwidHJ1c3RlZFR5cGVzIiwicG9saWN5IiwiY3JlYXRlUG9saWN5IiwibWFya2VyIiwibWFya2VyTWF0Y2giLCJub2RlTWFya2VyIiwiY3JlYXRlTWFya2VyIiwiY3JlYXRlQ29tbWVudCIsImlzUHJpbWl0aXZlIiwiaXNJdGVyYWJsZSIsInRleHRFbmRSZWdleCIsImNvbW1lbnRFbmRSZWdleCIsImNvbW1lbnQyRW5kUmVnZXgiLCJ0YWdFbmRSZWdleCIsInNpbmdsZVF1b3RlQXR0ckVuZFJlZ2V4IiwiZG91YmxlUXVvdGVBdHRyRW5kUmVnZXgiLCJyYXdUZXh0RWxlbWVudCIsInN0cmluZ3MiLCJfJGxpdFR5cGUkIiwic3ZnIiwibm9DaGFuZ2UiLCJmb3IiLCJub3RoaW5nIiwidGVtcGxhdGVDYWNoZSIsInJlbmRlciIsImNvbnRhaW5lciIsIm9wdGlvbnMiLCJwYXJ0T3duZXJOb2RlIiwicmVuZGVyQmVmb3JlIiwicGFydCIsIl8kbGl0UGFydCQiLCJlbmROb2RlIiwiQ2hpbGRQYXJ0IiwiaW5zZXJ0QmVmb3JlIiwiXyRzZXRWYWx1ZSIsIndhbGtlciIsImNyZWF0ZVRyZWVXYWxrZXIiLCJnZXRUZW1wbGF0ZUh0bWwiLCJhdHRyTmFtZXMiLCJyYXdUZXh0RW5kUmVnZXgiLCJyZWdleCIsImF0dHJOYW1lIiwiYXR0ck5hbWVFbmRJbmRleCIsImh0bWxSZXN1bHQiLCJUZW1wbGF0ZSIsInRoaXMiLCJwYXJ0cyIsIm5vZGVJbmRleCIsImF0dHJOYW1lSW5kZXgiLCJwYXJ0Q291bnQiLCJjdXJyZW50Tm9kZSIsImNvbnRlbnQiLCJzdmdFbGVtZW50IiwiZmlyc3RDaGlsZCIsInJlbW92ZSIsImFwcGVuZCIsImNoaWxkTm9kZXMiLCJuZXh0Tm9kZSIsIm5vZGVUeXBlIiwiaGFzQXR0cmlidXRlcyIsImF0dHJzVG9SZW1vdmUiLCJnZXRBdHRyaWJ1dGVOYW1lcyIsInJlYWxOYW1lIiwic3RhdGljcyIsImdldEF0dHJpYnV0ZSIsIlByb3BlcnR5UGFydCIsIkJvb2xlYW5BdHRyaWJ1dGVQYXJ0IiwiRXZlbnRQYXJ0IiwiQXR0cmlidXRlUGFydCIsInJlbW92ZUF0dHJpYnV0ZSIsInRhZ05hbWUiLCJ0ZXh0Q29udGVudCIsImVtcHR5U2NyaXB0Iiwic3RhdGljIiwiX29wdGlvbnMiLCJpbm5lckhUTUwiLCJyZXNvbHZlRGlyZWN0aXZlIiwiYXR0cmlidXRlSW5kZXgiLCJjdXJyZW50RGlyZWN0aXZlIiwiX19kaXJlY3RpdmVzIiwiX19kaXJlY3RpdmUiLCJuZXh0RGlyZWN0aXZlQ29uc3RydWN0b3IiLCJfJGxpdERpcmVjdGl2ZSQiLCJfJEFPIiwiXyRpbml0aWFsaXplIiwiXyRyZXNvbHZlIiwiVGVtcGxhdGVJbnN0YW5jZSIsInRlbXBsYXRlIiwiX3BhcnRzIiwiXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuIiwiXyR0ZW1wbGF0ZSIsIl8kcGFyZW50IiwicGFyZW50Tm9kZSIsIl8kaXNDb25uZWN0ZWQiLCJfY2xvbmUiLCJmcmFnbWVudCIsImNyZWF0aW9uU2NvcGUiLCJpbXBvcnROb2RlIiwicGFydEluZGV4IiwidGVtcGxhdGVQYXJ0IiwibmV4dFNpYmxpbmciLCJFbGVtZW50UGFydCIsIl91cGRhdGUiLCJzdGFydE5vZGUiLCJfJGNvbW1pdHRlZFZhbHVlIiwiXyRzdGFydE5vZGUiLCJfJGVuZE5vZGUiLCJfX2lzQ29ubmVjdGVkIiwiaXNDb25uZWN0ZWQiLCJkaXJlY3RpdmVQYXJlbnQiLCJfJGNsZWFyIiwiX2NvbW1pdFRleHQiLCJfY29tbWl0VGVtcGxhdGVSZXN1bHQiLCJfY29tbWl0Tm9kZSIsIl9jb21taXRJdGVyYWJsZSIsIl9pbnNlcnQiLCJyZWYiLCJfJGdldFRlbXBsYXRlIiwiaCIsIml0ZW1QYXJ0cyIsIml0ZW1QYXJ0IiwiaXRlbSIsIl8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQiLCJzZXRDb25uZWN0ZWQiLCJub0NvbW1pdCIsInZhbHVlSW5kZXgiLCJjaGFuZ2UiLCJfY29tbWl0VmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJlbXB0eVN0cmluZ0ZvckJvb2xlYW5BdHRyaWJ1dGUiLCJzdXBlciIsIm5ld0xpc3RlbmVyIiwib2xkTGlzdGVuZXIiLCJzaG91bGRSZW1vdmVMaXN0ZW5lciIsIm9uY2UiLCJwYXNzaXZlIiwic2hvdWxkQWRkTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlRXZlbnQiLCJob3N0IiwicG9seWZpbGxTdXBwb3J0IiwibGl0SHRtbFBvbHlmaWxsU3VwcG9ydCIsImxpdEh0bWxWZXJzaW9ucyIsIlNoYWRvd1Jvb3QiLCJTaGFkeUNTUyIsIm5hdGl2ZVNoYWRvdyIsIkRvY3VtZW50IiwiQ1NTU3R5bGVTaGVldCIsImNvbnN0cnVjdGlvblRva2VuIiwic3R5bGVTaGVldENhY2hlIiwiQ1NTUmVzdWx0IiwiY3NzVGV4dCIsInNhZmVUb2tlbiIsIl8kY3NzUmVzdWx0JCIsInN0eWxlU2hlZXQiLCJzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMiLCJyZXBsYWNlU3luYyIsInVuc2FmZUNTUyIsImNzcyIsImlkeCIsImFkb3B0U3R5bGVzIiwicmVuZGVyUm9vdCIsInN0eWxlcyIsImFkb3B0ZWRTdHlsZVNoZWV0cyIsIm5vbmNlIiwibGl0Tm9uY2UiLCJnZXRDb21wYXRpYmxlU3R5bGUiLCJzaGVldCIsImNzc1J1bGVzIiwicnVsZSIsInJlYWN0aXZlRWxlbWVudFBvbHlmaWxsU3VwcG9ydCIsImRlZmF1bHRDb252ZXJ0ZXIiLCJ0b0F0dHJpYnV0ZSIsIkJvb2xlYW4iLCJmcm9tQXR0cmlidXRlIiwiZnJvbVZhbHVlIiwicGFyc2UiLCJub3RFcXVhbCIsIm9sZCIsImRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uIiwiY29udmVydGVyIiwicmVmbGVjdCIsImhhc0NoYW5nZWQiLCJSZWFjdGl2ZUVsZW1lbnQiLCJpc1VwZGF0ZVBlbmRpbmciLCJoYXNVcGRhdGVkIiwiX19yZWZsZWN0aW5nUHJvcGVydHkiLCJfaW5pdGlhbGl6ZSIsIl9fdXBkYXRlUHJvbWlzZSIsImVuYWJsZVVwZGF0aW5nIiwiXyRjaGFuZ2VkUHJvcGVydGllcyIsIl9fc2F2ZUluc3RhbmNlUHJvcGVydGllcyIsInJlcXVlc3RVcGRhdGUiLCJfaW5pdGlhbGl6ZXJzIiwiYWRkQ29udHJvbGxlciIsImNvbnRyb2xsZXIiLCJfX2NvbnRyb2xsZXJzIiwiaG9zdENvbm5lY3RlZCIsInJlbW92ZUNvbnRyb2xsZXIiLCJlbGVtZW50UHJvcGVydGllcyIsIl9faW5zdGFuY2VQcm9wZXJ0aWVzIiwiY3JlYXRlUmVuZGVyUm9vdCIsInNoYWRvd1Jvb3QiLCJhdHRhY2hTaGFkb3ciLCJzaGFkb3dSb290T3B0aW9ucyIsImVsZW1lbnRTdHlsZXMiLCJjb25uZWN0ZWRDYWxsYmFjayIsIl9yZXF1ZXN0ZWRVcGRhdGUiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImhvc3REaXNjb25uZWN0ZWQiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJfb2xkIiwiXyRhdHRyaWJ1dGVUb1Byb3BlcnR5IiwiX19wcm9wZXJ0eVRvQXR0cmlidXRlIiwiYXR0ciIsIl9fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5IiwiYXR0clZhbHVlIiwicHJvcE5hbWUiLCJfX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAiLCJnZXRQcm9wZXJ0eU9wdGlvbnMiLCJvbGRWYWx1ZSIsInNob3VsZFJlcXVlc3RVcGRhdGUiLCJfX3JlZmxlY3RpbmdQcm9wZXJ0aWVzIiwiX19lbnF1ZXVlVXBkYXRlIiwic2NoZWR1bGVVcGRhdGUiLCJwZXJmb3JtVXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiY2hhbmdlZFByb3BlcnRpZXMiLCJ3aWxsVXBkYXRlIiwiaG9zdFVwZGF0ZSIsInVwZGF0ZSIsIl9fbWFya1VwZGF0ZWQiLCJfJGRpZFVwZGF0ZSIsIl9jaGFuZ2VkUHJvcGVydGllcyIsImhvc3RVcGRhdGVkIiwiZmlyc3RVcGRhdGVkIiwidXBkYXRlZCIsInVwZGF0ZUNvbXBsZXRlIiwiZ2V0VXBkYXRlQ29tcGxldGUiLCJpbml0aWFsaXplciIsIm9ic2VydmVkQXR0cmlidXRlcyIsImZpbmFsaXplIiwibm9BY2Nlc3NvciIsImdldFByb3BlcnR5RGVzY3JpcHRvciIsImZpbmFsaXplZCIsInN1cGVyQ3RvciIsInByb3BzIiwicHJvcGVydGllcyIsInByb3BLZXlzIiwiZmluYWxpemVTdHlsZXMiLCJmbGF0IiwidW5zaGlmdCIsIkhUTUxFbGVtZW50IiwicmVhY3RpdmVFbGVtZW50VmVyc2lvbnMiLCJfYm91bmRBdHRyaWJ1dGVTdWZmaXgiLCJfbWFya2VyIiwiX21hcmtlck1hdGNoIiwiX0hUTUxfUkVTVUxUIiwiX2dldFRlbXBsYXRlSHRtbCIsIl9UZW1wbGF0ZUluc3RhbmNlIiwiX2lzSXRlcmFibGUiLCJfcmVzb2x2ZURpcmVjdGl2ZSIsIl9DaGlsZFBhcnQiLCJfQXR0cmlidXRlUGFydCIsIl9Cb29sZWFuQXR0cmlidXRlUGFydCIsIl9FdmVudFBhcnQiLCJfUHJvcGVydHlQYXJ0IiwiX0VsZW1lbnRQYXJ0IiwiTGl0RWxlbWVudCIsInJlbmRlck9wdGlvbnMiLCJfX2NoaWxkUGFydCIsIl8kbGl0RWxlbWVudCQiLCJsaXRFbGVtZW50SHlkcmF0ZVN1cHBvcnQiLCJsaXRFbGVtZW50UG9seWZpbGxTdXBwb3J0IiwibGl0RWxlbWVudFZlcnNpb25zIiwidXNlclNlbGVjdE5vbmVPbkJvZHlSZWdpc3RlciIsIlNjRWxlbWVudCIsIl9zY0lkIiwicHJldmVudERlZmF1bHQiLCJib2R5IiwidXNlclNlbGVjdCIsImRlbGV0ZSIsIlNjUG9zaXRpb25TdXJmYWNlIiwieFJhbmdlIiwieVJhbmdlIiwiY2xhbXBQb3NpdGlvbnMiLCJhY3RpdmVQb2ludGVycyIsInBvaW50ZXJJZHMiLCJtb3VzZU1vdmUiLCJtb3VzZVVwIiwidG91Y2hTdGFydCIsInRvdWNoTW92ZSIsInRvdWNoRW5kIiwicHJvcGFnYXRlVmFsdWVzIiwicmFmSWQiLCJ4RGVsdGEiLCJ5RGVsdGEiLCJweDJ4Iiwid2lkdGgiLCJweDJ5IiwiaGVpZ2h0IiwibW91c2VEb3duIiwiX3ByZXZlbnRDb250ZXh0TWVudSIsIl9yZXF1ZXN0VXNlclNlbGVjdE5vbmVPbkJvZHkiLCJyZXF1ZXN0UHJvcGFnYXRlVmFsdWVzIiwiX2NhbmNlbFVzZXJTZWxlY3ROb25lT25Cb2R5IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY29tcG9zZWQiLCJkZXRhaWwiLCJwb2ludGVySWQiLCJkaXNwYXRjaEV2ZW50IiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaCIsImlkZW50aWZpZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwic2NhbGVkWCIsImNsaWVudFkiLCJ0b3AiLCJzY2FsZWRZIiwiY2xhbXAiLCJjdXN0b21FbGVtZW50cyIsInBlcmZvcm1hbmNlIiwiU2NTcGVlZFN1cmZhY2UiLCJsYXN0UG9pbnRlciIsImxhc3RUaW1lIiwibGFzdFgiLCJzY3JlZW5YIiwibGFzdFkiLCJzY3JlZW5ZIiwiZHQiLCJkeCIsImR5IiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwidGhlbWUiLCJhcnJvdyIsImFycm93UmlnaHQiLCJhcnJvd0Rvd24iLCJTY0J1dHRvbiIsInRleHQiLCJzZWxlY3RlZCIsIl9wcmVzc2VkIiwib25FdmVudCIsImV2ZW50TmFtZSIsImlucHV0RXZlbnQiLCJTY1RvZ2dsZSIsImFjdGl2ZSIsInVwZGF0ZVZhbHVlIiwiX3NpemUiLCJwYWRkaW5nIiwic3Ryb2tlV2lkdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJjaGFuZ2VFdmVudCIsImdldFNjYWxlIiwicmFuZ2UiLCJzbG9wZSIsImludGVyY2VwdCIsInNjYWxlIiwiaW52ZXJ0IiwiZ2V0Q2xpcHBlciIsImNsaXBwZWRWYWx1ZSIsImZpeGVkVmFsdWUiLCJBVFRSSUJVVEUiLCJDSElMRCIsIlBST1BFUlRZIiwiQk9PTEVBTl9BVFRSSUJVVEUiLCJFVkVOVCIsIkVMRU1FTlQiLCJkaXJlY3RpdmUiLCJEaXJlY3RpdmUiLCJfcGFydEluZm8iLCJfX3BhcnQiLCJfX2F0dHJpYnV0ZUluZGV4IiwiX3BhcnQiLCJjbGFzc01hcCIsInBhcnRJbmZvIiwiUGFydFR5cGUiLCJjbGFzc0luZm8iLCJfcHJldmlvdXNDbGFzc2VzIiwiX3N0YXRpY0NsYXNzZXMiLCJjbGFzc0xpc3QiLCJzdHJpcCIsImRpZ2l0TGVuZ3RoIiwiZVNwbGl0IiwiZmxvYXQyRml4ZWQiLCJkTGVuIiwiY2hlY2tCb3VuZGFyeSIsIl9ib3VuZGFyeUNoZWNraW5nU3RhdGUiLCJpdGVyYXRvck9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsIm51bTEiLCJudW0yIiwib3RoZXJzIiwidGltZXMiLCJudW1zIiwibnVtMUNoYW5nZWQiLCJudW0yQ2hhbmdlZCIsImJhc2VOdW0iLCJsZWZ0VmFsdWUiLCJwbHVzIiwibWludXMiLCJyYXRpbyIsImJhc2UiLCJlbmFibGVCb3VuZGFyeUNoZWNraW5nIiwiZmxhZyIsIlNjTnVtYmVyIiwiaW50ZWdlciIsIl9taW4iLCJfbWF4IiwiX3ZhbHVlIiwiX2Rpc3BsYXlWYWx1ZSIsIl92YWx1ZUNoYW5nZWQiLCJfdXBkYXRlVmFsdWUxIiwidXBkYXRlVmFsdWVGcm9tUG9pbnRlciIsIl91cGRhdGVWYWx1ZTAxIiwiX3VwZGF0ZVZhbHVlMDAxIiwiX3VwZGF0ZVZhbHVlMDAwMSIsIl91cGRhdGVWYWx1ZTAwMDAxIiwiX3VwZGF0ZVZhbHVlMDAwMDAxIiwiX3VwZGF0ZVZhbHVlMDAwMDAwMSIsIl9udW1LZXlQcmVzc2VkIiwib25LZXlEb3duIiwiX2VtaXRDaGFuZ2UiLCJlbXB0eVNwYWNlIiwiY2hhcmFjdGVyV2lkdGgiLCJpc0VkaXRlZCIsImVkaXRlZCIsIm9uRm9jdXMiLCJvbkJsdXIiLCJ0cmlnZ2VyRm9jdXMiLCIkY29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImZvY3VzIiwidXBkYXRlVmFsdWVGcm9tRGlzcGxheVZhbHVlIiwidmFsaWRTeW1ib2xzIiwic3ltYm9sIiwid2hpY2giLCJzdWJzdHJpbmciLCJfZW1pdElucHV0IiwibGFzdFZhbHVlIiwiZXhwb25lbnQiLCJOUCIsImRpc3BsYXlWYWx1ZSIsInZhbHVlUGFydHMiLCJzdGVwRGVjaW1hbHMiLCJTY1NsaWRlciIsIm9yaWVudGF0aW9uIiwiZGlzcGxheU51bWJlciIsIl9tYXJnaW5TbGlkZXJOdW1iZXIiLCJfbnVtYmVyV2lkdGgiLCJfcG9pbnRlcklkIiwiX2RpcnR5IiwiX3NsaWRlcldpZHRoIiwiX3NsaWRlckhlaWdodCIsInRtcCIsImNsaXBwZXIiLCJjaGFuZ2VWYWx1ZSIsInVwZGF0ZVZhbHVlRnJvbU51bWJlciIsImZhY3RvcnkiLCJwbGF0Zm9ybSIsImdlY2tvIiwiaWVfdXB0bzEwIiwiaWVfMTF1cCIsImVkZ2UiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJ3ZWJraXQiLCJxdHdlYmtpdCIsImNocm9tZSIsInByZXN0byIsInNhZmFyaSIsInZlbmRvciIsIm1hY19nZU1vdW50YWluTGlvbiIsInBoYW50b20iLCJpb3MiLCJtYXhUb3VjaFBvaW50cyIsImFuZHJvaWQiLCJtb2JpbGUiLCJtYWMiLCJjaHJvbWVPUyIsIndpbmRvd3MiLCJwcmVzdG9fdmVyc2lvbiIsImZsaXBDdHJsQ21kIiwiY2FwdHVyZVJpZ2h0Q2xpY2siLCJjbGFzc1Rlc3QiLCJjbHMiLCJybUNsYXNzIiwiY3VycmVudCIsImNsYXNzTmFtZSIsImFmdGVyIiwicmVtb3ZlQ2hpbGRyZW4iLCJyZW1vdmVDaGlsZHJlbkFuZEFkZCIsImVsdCIsImVsdFAiLCJjcmVhdGVSYW5nZSIsInNldEVuZCIsInNldFN0YXJ0IiwiY3JlYXRlVGV4dFJhbmdlIiwibW92ZVRvRWxlbWVudFRleHQiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJtb3ZlU3RhcnQiLCJjb250YWlucyIsImNoaWxkIiwiYWN0aXZlRWx0IiwiYWN0aXZlRWxlbWVudCIsImFkZENsYXNzIiwiam9pbkNsYXNzZXMiLCJhcyIsInNlbGVjdElucHV0Iiwic2VsZWN0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJfZSIsImNvcHlPYmoiLCJvdmVyd3JpdGUiLCJwcm9wIiwiY291bnRDb2x1bW4iLCJ0YWJTaXplIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJuZXh0VGFiIiwiRGVsYXllZCIsIm9uVGltZW91dCIsIm1zIiwiY2xlYXJUaW1lb3V0IiwiYXJyYXkiLCJzY3JvbGxlckdhcCIsIlBhc3MiLCJzZWxfZG9udFNjcm9sbCIsInNjcm9sbCIsInNlbF9tb3VzZSIsIm9yaWdpbiIsInNlbF9tb3ZlIiwiZmluZENvbHVtbiIsImdvYWwiLCJjb2wiLCJza2lwcGVkIiwic3BhY2VTdHJzIiwic3BhY2VTdHIiLCJsc3QiLCJpbnNlcnRTb3J0ZWQiLCJzY29yZSIsInByaW9yaXR5IiwiY3JlYXRlT2JqIiwiaW5zdCIsIm5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyIiwiaXNXb3JkQ2hhckJhc2ljIiwidG9VcHBlckNhc2UiLCJpc1dvcmRDaGFyIiwiaGVscGVyIiwiaXNFbXB0eSIsImV4dGVuZGluZ0NoYXJzIiwiaXNFeHRlbmRpbmdDaGFyIiwic2tpcEV4dGVuZGluZ0NoYXJzIiwiZGlyIiwiZmluZEZpcnN0IiwicHJlZCIsIm1pZEYiLCJtaWQiLCJpdGVyYXRlQmlkaVNlY3Rpb25zIiwib3JkZXIiLCJmb3VuZCIsImxldmVsIiwiYmlkaU90aGVyIiwiZ2V0QmlkaVBhcnRBdCIsImN1ciIsImJpZGlPcmRlcmluZyIsImxvd1R5cGVzIiwiYXJhYmljVHlwZXMiLCJjaGFyVHlwZSIsImJpZGlSRSIsImlzTmV1dHJhbCIsImlzU3Ryb25nIiwiY291bnRzQXNMZWZ0IiwiY291bnRzQXNOdW0iLCJCaWRpU3BhbiIsImRpcmVjdGlvbiIsIm91dGVyVHlwZSIsInR5cGVzIiwiaSQxIiwiaSQyIiwidHlwZSQxIiwiaSQzIiwicHJldiQxIiwidHlwZSQyIiwiaSQ0IiwidHlwZSQzIiwiaSQ1IiwiY3VyJDEiLCJ0eXBlJDQiLCJpJDYiLCJlbmQkMSIsImJlZm9yZSIsInJlcGxhY2UkMSIsImokMSIsImkkNyIsImlzUlRMIiwiaiQyIiwibnN0YXJ0IiwiZ2V0T3JkZXIiLCJsaW5lIiwibm9IYW5kbGVycyIsIm9uIiwiZW1pdHRlciIsImF0dGFjaEV2ZW50IiwiX2hhbmRsZXJzIiwiZ2V0SGFuZGxlcnMiLCJvZmYiLCJkZXRhY2hFdmVudCIsInNpZ25hbCIsImhhbmRsZXJzIiwic2lnbmFsRE9NRXZlbnQiLCJjbSIsIm92ZXJyaWRlIiwiZGVmYXVsdFByZXZlbnRlZCIsImVfZGVmYXVsdFByZXZlbnRlZCIsImNvZGVtaXJyb3JJZ25vcmUiLCJzaWduYWxDdXJzb3JBY3Rpdml0eSIsImN1cnNvckFjdGl2aXR5IiwiY3VyT3AiLCJjdXJzb3JBY3Rpdml0eUhhbmRsZXJzIiwiaGFzSGFuZGxlciIsImV2ZW50TWl4aW4iLCJlX3ByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJlX3N0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsImVfc3RvcCIsImVfdGFyZ2V0Iiwic3JjRWxlbWVudCIsImVfYnV0dG9uIiwiYnV0dG9uIiwiY3RybEtleSIsImRyYWdBbmREcm9wIiwiendzcFN1cHBvcnRlZCIsInplcm9XaWR0aEVsZW1lbnQiLCJtZWFzdXJlIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJiYWRCaWRpUmVjdHMiLCJoYXNCYWRCaWRpUmVjdHMiLCJ0eHQiLCJyMCIsInIxIiwicmlnaHQiLCJzcGxpdExpbmVzQXV0byIsIm5sIiwiaGFzU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwidGUiLCJvd25lckRvY3VtZW50Iiwic2VsZWN0aW9uIiwicGFyZW50RWxlbWVudCIsImNvbXBhcmVFbmRQb2ludHMiLCJoYXNDb3B5RXZlbnQiLCJvbmNvcHkiLCJiYWRab29tZWRSZWN0cyIsImhhc0JhZFpvb21lZFJlY3RzIiwibm9ybWFsIiwiZnJvbVJhbmdlIiwibW9kZXMiLCJtaW1lTW9kZXMiLCJkZWZpbmVNb2RlIiwiZGVwZW5kZW5jaWVzIiwiZGVmaW5lTUlNRSIsIm1pbWUiLCJzcGVjIiwicmVzb2x2ZU1vZGUiLCJnZXRNb2RlIiwibWZhY3RvcnkiLCJtb2RlT2JqIiwibW9kZUV4dGVuc2lvbnMiLCJleHRzIiwiaGVscGVyVHlwZSIsIm1vZGVQcm9wcyIsInByb3AkMSIsImV4dGVuZE1vZGUiLCJjb3B5U3RhdGUiLCJuc3RhdGUiLCJpbm5lck1vZGUiLCJzdGFydFN0YXRlIiwiYTEiLCJhMiIsIlN0cmluZ1N0cmVhbSIsImxpbmVPcmFjbGUiLCJsYXN0Q29sdW1uUG9zIiwibGFzdENvbHVtblZhbHVlIiwibGluZVN0YXJ0IiwiZW9sIiwic29sIiwicGVlayIsImVhdCIsImVhdFdoaWxlIiwiZWF0U3BhY2UiLCJza2lwVG9FbmQiLCJza2lwVG8iLCJiYWNrVXAiLCJjb2x1bW4iLCJpbmRlbnRhdGlvbiIsInBhdHRlcm4iLCJjb25zdW1lIiwiY2FzZUluc2Vuc2l0aXZlIiwiY2FzZWQiLCJzdWJzdHIiLCJoaWRlRmlyc3RDaGFycyIsImlubmVyIiwibG9va0FoZWFkIiwib3JhY2xlIiwiYmFzZVRva2VuIiwiZ2V0TGluZSIsImRvYyIsImNodW5rIiwibGluZXMiLCJjaGlsZHJlbiIsInN6IiwiY2h1bmtTaXplIiwiZ2V0QmV0d2VlbiIsImdldExpbmVzIiwidXBkYXRlTGluZUhlaWdodCIsImRpZmYiLCJsaW5lTm8iLCJubyIsImxpbmVBdEhlaWdodCIsIm91dGVyIiwibGgiLCJpc0xpbmUiLCJsaW5lTnVtYmVyRm9yIiwibGluZU51bWJlckZvcm1hdHRlciIsImZpcnN0TGluZU51bWJlciIsIlBvcyIsImNtcCIsImVxdWFsQ3Vyc29yUG9zIiwiY29weVBvcyIsIm1heFBvcyIsIm1pblBvcyIsImNsaXBMaW5lIiwiY2xpcFBvcyIsImNsaXBUb0xlbiIsImxpbmVsZW4iLCJjbGlwUG9zQXJyYXkiLCJTYXZlZENvbnRleHQiLCJtYXhMb29rQWhlYWQiLCJiYXNlVG9rZW5zIiwiYmFzZVRva2VuUG9zIiwibmV4dExpbmUiLCJmcm9tU2F2ZWQiLCJzYXZlZCIsInNhdmUiLCJjb3B5IiwiaGlnaGxpZ2h0TGluZSIsImZvcmNlVG9FbmQiLCJzdCIsIm1vZGVHZW4iLCJsaW5lQ2xhc3NlcyIsInJ1bk1vZGUiLCJsb29wIiwib3ZlcmxheSIsIm92ZXJsYXlzIiwiaV9lbmQiLCJvcGFxdWUiLCJjbGFzc2VzIiwiYmdDbGFzcyIsInRleHRDbGFzcyIsImdldExpbmVTdHlsZXMiLCJ1cGRhdGVGcm9udGllciIsImdldENvbnRleHRCZWZvcmUiLCJyZXNldFN0YXRlIiwibWF4SGlnaGxpZ2h0TGVuZ3RoIiwic3RhdGVBZnRlciIsInN0eWxlQ2xhc3NlcyIsImhpZ2hsaWdodEZyb250aWVyIiwibW9kZUZyb250aWVyIiwicHJlY2lzZSIsImZpbmRTdGFydExpbmUiLCJwcm9jZXNzTGluZSIsInZpZXdGcm9tIiwidmlld1RvIiwic3RhcnRBdCIsInN0cmVhbSIsImNhbGxCbGFua0xpbmUiLCJyZWFkVG9rZW4iLCJibGFua0xpbmUiLCJ0b2tlbiIsIlRva2VuIiwidGFrZVRva2VuIiwiYXNBcnJheSIsInRva2VucyIsImV4dHJhY3RMaW5lQ2xhc3NlcyIsImxpbmVDbGFzcyIsImZsYXR0ZW5TcGFucyIsImN1clN0YXJ0IiwiY3VyU3R5bGUiLCJhZGRNb2RlQ2xhc3MiLCJtTmFtZSIsIm1pbmluZGVudCIsIm1pbmxpbmUiLCJpbmRlbnRlZCIsInJldHJlYXRGcm9udGllciIsInNhd1JlYWRPbmx5U3BhbnMiLCJzYXdDb2xsYXBzZWRTcGFucyIsInNlZVJlYWRPbmx5U3BhbnMiLCJzZWVDb2xsYXBzZWRTcGFucyIsIk1hcmtlZFNwYW4iLCJnZXRNYXJrZWRTcGFuRm9yIiwic3BhbnMiLCJzcGFuIiwicmVtb3ZlTWFya2VkU3BhbiIsImFkZE1hcmtlZFNwYW4iLCJvcCIsImluVGhpc09wIiwibWFya2VkU3BhbnMiLCJhdHRhY2hMaW5lIiwibWFya2VkU3BhbnNCZWZvcmUiLCJzdGFydENoIiwiaXNJbnNlcnQiLCJudyIsInN0YXJ0c0JlZm9yZSIsImluY2x1c2l2ZUxlZnQiLCJpbnNlcnRMZWZ0IiwiZW5kc0FmdGVyIiwiaW5jbHVzaXZlUmlnaHQiLCJtYXJrZWRTcGFuc0FmdGVyIiwiZW5kQ2giLCJzdHJldGNoU3BhbnNPdmVyQ2hhbmdlIiwiZnVsbCIsIm9sZEZpcnN0Iiwib2xkTGFzdCIsInNhbWVMaW5lIiwic3BhbiQxIiwiZm91bmQkMSIsImNsZWFyRW1wdHlTcGFucyIsIm5ld01hcmtlcnMiLCJnYXAiLCJnYXBNYXJrZXJzIiwiY2xlYXJXaGVuRW1wdHkiLCJyZW1vdmVSZWFkT25seVJhbmdlcyIsIm1hcmtlcnMiLCJyZWFkT25seSIsIm1rIiwibmV3UGFydHMiLCJkZnJvbSIsImR0byIsImRldGFjaE1hcmtlZFNwYW5zIiwiZGV0YWNoTGluZSIsImF0dGFjaE1hcmtlZFNwYW5zIiwiZXh0cmFMZWZ0IiwiZXh0cmFSaWdodCIsImNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzIiwibGVuRGlmZiIsImFQb3MiLCJiUG9zIiwiZnJvbUNtcCIsInRvQ21wIiwiY29sbGFwc2VkU3BhbkF0U2lkZSIsInNwcyIsInNwIiwiY29sbGFwc2VkIiwiY29sbGFwc2VkU3BhbkF0U3RhcnQiLCJjb2xsYXBzZWRTcGFuQXRFbmQiLCJjb2xsYXBzZWRTcGFuQXJvdW5kIiwiY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZSIsInZpc3VhbExpbmUiLCJtZXJnZWQiLCJ2aXN1YWxMaW5lRW5kIiwidmlzdWFsTGluZUNvbnRpbnVlZCIsInZpc3VhbExpbmVObyIsImxpbmVOIiwidmlzIiwidmlzdWFsTGluZUVuZE5vIiwibGFzdExpbmUiLCJsaW5lSXNIaWRkZW4iLCJ3aWRnZXROb2RlIiwibGluZUlzSGlkZGVuSW5uZXIiLCJoZWlnaHRBdExpbmUiLCJsaW5lT2JqIiwibGluZUxlbmd0aCIsImZpbmRNYXhMaW5lIiwibWF4TGluZSIsIm1heExpbmVMZW5ndGgiLCJtYXhMaW5lQ2hhbmdlZCIsIkxpbmUiLCJlc3RpbWF0ZUhlaWdodCIsInVwZGF0ZUxpbmUiLCJlc3RIZWlnaHQiLCJjbGVhblVwTGluZSIsInN0eWxlVG9DbGFzc0NhY2hlIiwic3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSIsImludGVycHJldFRva2VuU3R5bGUiLCJjYWNoZSIsImJ1aWxkTGluZUNvbnRlbnQiLCJsaW5lVmlldyIsImJ1aWxkZXIiLCJwcmUiLCJ0cmFpbGluZ1NwYWNlIiwic3BsaXRTcGFjZXMiLCJnZXRPcHRpb24iLCJyZXN0IiwiYWRkVG9rZW4iLCJidWlsZFRva2VuIiwiYnVpbGRUb2tlbkJhZEJpZGkiLCJhbGxvd0Zyb250aWVyVXBkYXRlIiwiZXh0ZXJuYWxNZWFzdXJlZCIsImluc2VydExpbmVDb250ZW50IiwibWFwcyIsImNhY2hlcyIsImxhc3RDaGlsZCIsImRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyIiwidGl0bGUiLCJzdGFydFN0eWxlIiwiZW5kU3R5bGUiLCJkaXNwbGF5VGV4dCIsInNwZWNpYWwiLCJzcGVjaWFsQ2hhcnMiLCJtdXN0V3JhcCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJ0eHQkMSIsInRhYldpZHRoIiwic3BlY2lhbENoYXJQbGFjZWhvbGRlciIsImZ1bGxTdHlsZSIsInRyYWlsaW5nQmVmb3JlIiwic3BhY2VCZWZvcmUiLCJidWlsZENvbGxhcHNlZFNwYW4iLCJpZ25vcmVXaWRnZXQiLCJ3aWRnZXQiLCJpbnB1dCIsIm5lZWRzQ29udGVudEF0dHJpYnV0ZSIsInNldFVuZWRpdGFibGUiLCJhbGxUZXh0IiwibmV4dENoYW5nZSIsInNwYW5TdHlsZSIsInNwYW5FbmRTdHlsZSIsInNwYW5TdGFydFN0eWxlIiwiZm91bmRCb29rbWFya3MiLCJlbmRTdHlsZXMiLCJ1cHRvIiwidG9rZW5UZXh0IiwiTGluZVZpZXciLCJoaWRkZW4iLCJidWlsZFZpZXdBcnJheSIsIm5leHRQb3MiLCJvcGVyYXRpb25Hcm91cCIsInB1c2hPcGVyYXRpb24iLCJvcHMiLCJvd25zR3JvdXAiLCJkZWxheWVkQ2FsbGJhY2tzIiwiZmlyZUNhbGxiYWNrc0Zvck9wcyIsImdyb3VwIiwiY2FsbGJhY2tzIiwiY3Vyc29yQWN0aXZpdHlDYWxsZWQiLCJmaW5pc2hPcGVyYXRpb24iLCJlbmRDYiIsIm9ycGhhbkRlbGF5ZWRDYWxsYmFja3MiLCJzaWduYWxMYXRlciIsImZpcmVPcnBoYW5EZWxheWVkIiwiZGVsYXllZCIsInVwZGF0ZUxpbmVGb3JDaGFuZ2VzIiwiZGltcyIsImNoYW5nZXMiLCJ1cGRhdGVMaW5lVGV4dCIsInVwZGF0ZUxpbmVHdXR0ZXIiLCJ1cGRhdGVMaW5lQ2xhc3NlcyIsInVwZGF0ZUxpbmVXaWRnZXRzIiwiZW5zdXJlTGluZVdyYXBwZWQiLCJyZXBsYWNlQ2hpbGQiLCJ6SW5kZXgiLCJ1cGRhdGVMaW5lQmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJnZXRMaW5lQ29udGVudCIsImV4dCIsImJ1aWx0Iiwid3JhcENsYXNzIiwiZ3V0dGVyIiwiZ3V0dGVyQmFja2dyb3VuZCIsImd1dHRlckNsYXNzIiwiZml4ZWRHdXR0ZXIiLCJmaXhlZFBvcyIsImd1dHRlclRvdGFsV2lkdGgiLCJndXR0ZXJNYXJrZXJzIiwibGluZU51bWJlcnMiLCJ3cmFwJDEiLCJndXR0ZXJXcmFwIiwibGluZU51bWJlciIsImd1dHRlckxlZnQiLCJsaW5lTnVtSW5uZXJXaWR0aCIsImd1dHRlclNwZWNzIiwiZ3V0dGVyV2lkdGgiLCJhbGlnbmFibGUiLCJpc1dpZGdldCIsImluc2VydExpbmVXaWRnZXRzIiwiYnVpbGRMaW5lRWxlbWVudCIsImluc2VydExpbmVXaWRnZXRzRm9yIiwiYWxsb3dBYm92ZSIsIndpZGdldHMiLCJoYW5kbGVNb3VzZUV2ZW50cyIsInBvc2l0aW9uTGluZVdpZGdldCIsImFib3ZlIiwibm9IU2Nyb2xsIiwid3JhcHBlcldpZHRoIiwiY292ZXJHdXR0ZXIiLCJwYWRkaW5nTGVmdCIsIm1hcmdpbkxlZnQiLCJ3aWRnZXRIZWlnaHQiLCJwYXJlbnRTdHlsZSIsImd1dHRlcnMiLCJjbGllbnRXaWR0aCIsImV2ZW50SW5XaWRnZXQiLCJzaXplciIsIm1vdmVyIiwicGFkZGluZ1RvcCIsImxpbmVTcGFjZSIsIm9mZnNldFRvcCIsInBhZGRpbmdWZXJ0IiwicGFkZGluZ0giLCJjYWNoZWRQYWRkaW5nSCIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJwYWRkaW5nUmlnaHQiLCJzY3JvbGxHYXAiLCJuYXRpdmVCYXJXaWR0aCIsImRpc3BsYXlXaWR0aCIsInNjcm9sbGVyIiwiYmFyV2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiYmFySGVpZ2h0IiwiZW5zdXJlTGluZUhlaWdodHMiLCJ3cmFwcGluZyIsImxpbmVXcmFwcGluZyIsImN1cldpZHRoIiwiaGVpZ2h0cyIsInJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJib3R0b20iLCJtYXBGcm9tTGluZVZpZXciLCJ1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50IiwibGluZU1lYXN1cmUiLCJtZWFzdXJlQ2hhciIsImJpYXMiLCJtZWFzdXJlQ2hhclByZXBhcmVkIiwicHJlcGFyZU1lYXN1cmVGb3JMaW5lIiwiZmluZFZpZXdGb3JMaW5lIiwiZmluZFZpZXdJbmRleCIsImdldERpbWVuc2lvbnMiLCJmb3JjZVVwZGF0ZSIsImhhc0hlaWdodHMiLCJwcmVwYXJlZCIsInZhckhlaWdodCIsIm1lYXN1cmVDaGFySW5uZXIiLCJib2d1cyIsInJ0b3AiLCJyYm90dG9tIiwibnVsbFJlY3QiLCJub2RlQW5kT2Zmc2V0SW5MaW5lTWFwIiwibVN0YXJ0IiwibUVuZCIsImNvdmVyU3RhcnQiLCJjb3ZlckVuZCIsImdldFVzZWZ1bFJlY3QiLCJwbGFjZSIsIm1heWJlVXBkYXRlUmVjdEZvclpvb21pbmciLCJyU3BhbiIsImNoYXJXaWR0aCIsInJib3QiLCJib3QiLCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lIiwic2NyZWVuIiwibG9naWNhbFhEUEkiLCJkZXZpY2VYRFBJIiwic2NhbGVYIiwic2NhbGVZIiwibG9naWNhbFlEUEkiLCJkZXZpY2VZRFBJIiwiY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvciIsImNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUiLCJleHRlcm5hbE1lYXN1cmUiLCJjbGVhckNhY2hlcyIsImNhY2hlZENoYXJXaWR0aCIsImNhY2hlZFRleHRIZWlnaHQiLCJsaW5lTnVtQ2hhcnMiLCJwYWdlU2Nyb2xsWCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInBhZ2VTY3JvbGxZIiwibWFyZ2luVG9wIiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJ3aWRnZXRUb3BIZWlnaHQiLCJpbnRvQ29vcmRTeXN0ZW0iLCJpbmNsdWRlV2lkZ2V0cyIsInlPZmYiLCJ2aWV3T2Zmc2V0IiwibE9mZiIsInhPZmYiLCJmcm9tQ29vcmRTeXN0ZW0iLCJjb29yZHMiLCJsb2NhbEJveCIsImxpbmVTcGFjZUJveCIsImNoYXJDb29yZHMiLCJjdXJzb3JDb29yZHMiLCJwcmVwYXJlZE1lYXN1cmUiLCJnZXRCaWRpIiwicGFydFBvcyIsIm90aGVyIiwiZXN0aW1hdGVDb29yZHMiLCJQb3NXaXRoSW5mbyIsIm91dHNpZGUiLCJ4UmVsIiwiY29vcmRzQ2hhciIsImNvb3Jkc0NoYXJJbm5lciIsInJhbmdlRW5kIiwid3JhcHBlZExpbmVFeHRlbnQiLCJ3cmFwcGVkTGluZUV4dGVudENoYXIiLCJ0YXJnZXRUb3AiLCJib3hJc0FmdGVyIiwiYm94IiwibHRyIiwiY29vcmRzQmlkaVBhcnRXcmFwcGVkIiwiY29vcmRzQmlkaVBhcnQiLCJjaEFyb3VuZCIsImJveEFyb3VuZCIsImJhc2VYIiwiYXRMZWZ0IiwiYXRTdGFydCIsIl9saW5lTm8iLCJjbG9zZXN0RGlzdCIsImVuZFgiLCJkaXN0IiwibWVhc3VyZVRleHQiLCJ0ZXh0SGVpZ2h0IiwiY2xpZW50TGVmdCIsIm9mZnNldExlZnQiLCJjb21wZW5zYXRlRm9ySFNjcm9sbCIsInRoIiwicGVyTGluZSIsIndpZGdldHNIZWlnaHQiLCJlc3RpbWF0ZUxpbmVIZWlnaHRzIiwiZXN0IiwicG9zRnJvbU1vdXNlIiwibGliZXJhbCIsImZvclJlY3QiLCJlJDEiLCJjb2xEaWZmIiwicmVnQ2hhbmdlIiwibGVuZGlmZiIsInVwZGF0ZUxpbmVOdW1iZXJzIiwidmlld0NoYW5nZWQiLCJyZXNldFZpZXciLCJjdXQiLCJ2aWV3Q3V0dGluZ1BvaW50IiwiY3V0JDEiLCJjdXRUb3AiLCJjdXRCb3QiLCJyZWdMaW5lQ2hhbmdlIiwib2xkTiIsIm5ld04iLCJhZGp1c3RWaWV3IiwiY291bnREaXJ0eVZpZXciLCJkaXJ0eSIsInVwZGF0ZVNlbGVjdGlvbiIsInNob3dTZWxlY3Rpb24iLCJwcmVwYXJlU2VsZWN0aW9uIiwicHJpbWFyeSIsImN1ckZyYWdtZW50IiwiY3Vyc29ycyIsInNlbEZyYWdtZW50Iiwic2VsIiwicmFuZ2VzIiwicHJpbUluZGV4Iiwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmciLCJkcmF3U2VsZWN0aW9uQ3Vyc29yIiwiZHJhd1NlbGVjdGlvblJhbmdlIiwiY3Vyc29yIiwiY3Vyc29ySGVpZ2h0IiwiZ2V0V3JhcHBlckVsZW1lbnQiLCJjaGFyUG9zIiwib3RoZXJDdXJzb3IiLCJjbXBDb29yZHMiLCJsZWZ0U2lkZSIsInJpZ2h0U2lkZSIsInNpemVyV2lkdGgiLCJkb2NMVFIiLCJkcmF3Rm9yTGluZSIsImZyb21BcmciLCJ0b0FyZyIsImxpbmVMZW4iLCJ3cmFwWCIsInNpZGUiLCJleHRlbnQiLCJmcm9tUG9zIiwidG9Qb3MiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbkxlZnQiLCJvcGVuUmlnaHQiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3RMZWZ0IiwiYm90UmlnaHQiLCJzRnJvbSIsInNUbyIsImZyb21MaW5lIiwidG9MaW5lIiwic2luZ2xlVkxpbmUiLCJsZWZ0RW5kIiwicmlnaHRTdGFydCIsInJlc3RhcnRCbGluayIsImZvY3VzZWQiLCJjbGVhckludGVydmFsIiwiYmxpbmtlciIsImN1cnNvckRpdiIsInZpc2liaWxpdHkiLCJjdXJzb3JCbGlua1JhdGUiLCJoYXNGb2N1cyIsImVuc3VyZUZvY3VzIiwiZGVsYXlCbHVyRXZlbnQiLCJkZWxheWluZ0JsdXJFdmVudCIsImRyYWdnaW5nVGV4dCIsInNlbEZvckNvbnRleHRNZW51IiwicmVjZWl2ZWRGb2N1cyIsInNoaWZ0IiwidXBkYXRlSGVpZ2h0c0luVmlld3BvcnQiLCJwcmV2Qm90dG9tIiwibGluZURpdiIsInZpZXdUb3AiLCJvbGRIZWlnaHQiLCJtdXN0U2Nyb2xsIiwidXBkYXRlV2lkZ2V0SGVpZ2h0IiwiY2hXaWR0aCIsInZpc2libGVMaW5lcyIsInZpZXdwb3J0IiwiZW5zdXJlIiwiZW5zdXJlRnJvbSIsImVuc3VyZVRvIiwibWF5YmVTY3JvbGxXaW5kb3ciLCJkb1Njcm9sbCIsImlubmVySGVpZ2h0Iiwic2Nyb2xsTm9kZSIsInNjcm9sbEludG9WaWV3Iiwic2Nyb2xsUG9zSW50b1ZpZXciLCJtYXJnaW4iLCJjaGFuZ2VkIiwiZW5kQ29vcmRzIiwic2Nyb2xsUG9zIiwiY2FsY3VsYXRlU2Nyb2xsUG9zIiwic3RhcnRUb3AiLCJzdGFydExlZnQiLCJ1cGRhdGVTY3JvbGxUb3AiLCJzZXRTY3JvbGxMZWZ0Iiwic25hcE1hcmdpbiIsInNjcmVlbnRvcCIsImRvY0JvdHRvbSIsImF0VG9wIiwiYXRCb3R0b20iLCJuZXdUb3AiLCJndXR0ZXJTcGFjZSIsInNjcmVlbmxlZnQiLCJzY3JlZW53IiwidG9vV2lkZSIsImFkZFRvU2Nyb2xsVG9wIiwicmVzb2x2ZVNjcm9sbFRvUG9zIiwiZW5zdXJlQ3Vyc29yVmlzaWJsZSIsImdldEN1cnNvciIsInNjcm9sbFRvUG9zIiwiY3Vyc29yU2Nyb2xsTWFyZ2luIiwic2Nyb2xsVG9Db29yZHMiLCJzY3JvbGxUb1JhbmdlIiwic2Nyb2xsVG9Db29yZHNSYW5nZSIsInNQb3MiLCJ1cGRhdGVEaXNwbGF5U2ltcGxlIiwic2V0U2Nyb2xsVG9wIiwic3RhcnRXb3JrZXIiLCJmb3JjZVNjcm9sbCIsInNjcm9sbEhlaWdodCIsInNjcm9sbGJhcnMiLCJpc1Njcm9sbGVyIiwic2Nyb2xsV2lkdGgiLCJhbGlnbkhvcml6b250YWxseSIsIm1lYXN1cmVGb3JTY3JvbGxiYXJzIiwiZ3V0dGVyVyIsImRvY0giLCJ2aWV3SGVpZ2h0Iiwidmlld1dpZHRoIiwiYmFyTGVmdCIsImRvY0hlaWdodCIsIk5hdGl2ZVNjcm9sbGJhcnMiLCJ2ZXJ0IiwiaG9yaXoiLCJ0YWJJbmRleCIsImNoZWNrZWRaZXJvV2lkdGgiLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCIsIm5lZWRzSCIsIm5lZWRzViIsInNXaWR0aCIsInRvdGFsSGVpZ2h0IiwidG90YWxXaWR0aCIsInplcm9XaWR0aEhhY2siLCJkaXNhYmxlSG9yaXoiLCJlbmFibGVaZXJvV2lkdGhCYXIiLCJkaXNhYmxlVmVydCIsInBvaW50ZXJFdmVudHMiLCJiYXIiLCJkZWxheSIsIm1heWJlRGlzYWJsZSIsImVsZW1lbnRGcm9tUG9pbnQiLCJOdWxsU2Nyb2xsYmFycyIsInVwZGF0ZVNjcm9sbGJhcnMiLCJzdGFydFdpZHRoIiwic3RhcnRIZWlnaHQiLCJ1cGRhdGVTY3JvbGxiYXJzSW5uZXIiLCJzaXplcyIsInBhZGRpbmdCb3R0b20iLCJoZWlnaHRGb3JjZXIiLCJib3JkZXJCb3R0b20iLCJzY3JvbGxiYXJGaWxsZXIiLCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciIsImd1dHRlckZpbGxlciIsInNjcm9sbGJhck1vZGVsIiwiaW5pdFNjcm9sbGJhcnMiLCJzY3JvbGxiYXJTdHlsZSIsImF4aXMiLCJuZXh0T3BJZCIsInN0YXJ0T3BlcmF0aW9uIiwidXBkYXRlSW5wdXQiLCJ0eXBpbmciLCJjaGFuZ2VPYmpzIiwic2VsZWN0aW9uQ2hhbmdlZCIsInVwZGF0ZU1heExpbmUiLCJtYXJrQXJyYXlzIiwiZW5kT3BlcmF0aW9uIiwiZW5kT3BlcmF0aW9ucyIsImVuZE9wZXJhdGlvbl9SMSIsImVuZE9wZXJhdGlvbl9XMSIsImVuZE9wZXJhdGlvbl9SMiIsImVuZE9wZXJhdGlvbl9XMiIsImVuZE9wZXJhdGlvbl9maW5pc2giLCJtYXliZUNsaXBTY3JvbGxiYXJzIiwibXVzdFVwZGF0ZSIsIkRpc3BsYXlVcGRhdGUiLCJ1cGRhdGVkRGlzcGxheSIsInVwZGF0ZURpc3BsYXlJZk5lZWRlZCIsImJhck1lYXN1cmUiLCJhZGp1c3RXaWR0aFRvIiwibWF4U2Nyb2xsTGVmdCIsInByZXBhcmVkU2VsZWN0aW9uIiwidGFrZUZvY3VzIiwic2V0RG9jdW1lbnRIZWlnaHQiLCJwb3N0VXBkYXRlRGlzcGxheSIsIndoZWVsU3RhcnRYIiwid2hlZWxTdGFydFkiLCJtYXliZUhpZGRlbk1hcmtlcnMiLCJ1bmhpZGRlbiIsIm1heWJlVW5oaWRkZW5NYXJrZXJzIiwicnVuSW5PcCIsIm1ldGhvZE9wIiwiZG9jTWV0aG9kT3AiLCJoaWdobGlnaHQiLCJoaWdobGlnaHRXb3JrZXIiLCJ3b3JrVGltZSIsImNoYW5nZWRMaW5lcyIsIm9sZFN0eWxlcyIsImhpZ2hsaWdodGVkIiwib2xkQ2xzIiwibmV3Q2xzIiwiaXNjaGFuZ2UiLCJ3b3JrRGVsYXkiLCJmb3JjZSIsInZpc2libGUiLCJlZGl0b3JJc0hpZGRlbiIsIndyYXBwZXJIZWlnaHQiLCJvbGREaXNwbGF5V2lkdGgiLCJldmVudHMiLCJzY3JvbGxiYXJzQ2xpcHBlZCIsIm1hcmdpbkJvdHRvbSIsImJvcmRlclJpZ2h0V2lkdGgiLCJzZWxlY3Rpb25TbmFwc2hvdCIsImFuY2hvck5vZGUiLCJleHRlbmQiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsInJlc3RvcmVTZWxlY3Rpb24iLCJzbmFwc2hvdCIsIm5vZGVOYW1lIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJyZW5kZXJlZFZpZXciLCJtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCIsInZpZXdwb3J0TWFyZ2luIiwiZGlmZmVyZW50IiwibGFzdFdyYXBIZWlnaHQiLCJsYXN0V3JhcFdpZHRoIiwidG9VcGRhdGUiLCJzZWxTbmFwc2hvdCIsInBhdGNoRGlzcGxheSIsInNlbGVjdGlvbkRpdiIsInJlcG9ydGVkVmlld0Zyb20iLCJyZXBvcnRlZFZpZXdUbyIsInVwZGF0ZU51bWJlcnNGcm9tIiwicm0iLCJjdXJyZW50V2hlZWxUYXJnZXQiLCJ1cGRhdGVOdW1iZXIiLCJ1cGRhdGVHdXR0ZXJTcGFjZSIsImFsaWduV2lkZ2V0cyIsImNvbXAiLCJhbGlnbiIsImlubmVyVyIsImxpbmVHdXR0ZXIiLCJsaW5lTnVtV2lkdGgiLCJnZXRHdXR0ZXJzIiwic2F3TGluZU51bWJlcnMiLCJyZW5kZXJHdXR0ZXJzIiwic3BlY3MiLCJnRWx0IiwidXBkYXRlR3V0dGVycyIsIkRpc3BsYXkiLCJkcmFnZ2FibGUiLCJ3aGVlbERYIiwid2hlZWxEWSIsImFjdGl2ZVRvdWNoIiwid2hlZWxTYW1wbGVzIiwid2hlZWxQaXhlbHNQZXJVbml0Iiwid2hlZWxFdmVudERlbHRhIiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsIkhPUklaT05UQUxfQVhJUyIsIlZFUlRJQ0FMX0FYSVMiLCJ3aGVlbERlbHRhIiwid2hlZWxFdmVudFBpeGVscyIsImRlbHRhIiwib25TY3JvbGxXaGVlbCIsInBpeGVsc1BlclVuaXQiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVkiLCJjYW5TY3JvbGxYIiwiY2FuU2Nyb2xsWSIsInBpeGVscyIsIm1vdmVkWCIsIm1vdmVkWSIsInNhbXBsZSIsIlNlbGVjdGlvbiIsImVxdWFscyIsImhlcmUiLCJ0aGVyZSIsImRlZXBDb3B5IiwiUmFuZ2UiLCJzb21ldGhpbmdTZWxlY3RlZCIsIm5vcm1hbGl6ZVNlbGVjdGlvbiIsIm1heVRvdWNoIiwic2VsZWN0aW9uc01heVRvdWNoIiwicHJpbSIsImludiIsInNpbXBsZVNlbGVjdGlvbiIsImNoYW5nZUVuZCIsImFkanVzdEZvckNoYW5nZSIsImNvbXB1dGVTZWxBZnRlckNoYW5nZSIsIm9mZnNldFBvcyIsImNvbXB1dGVSZXBsYWNlZFNlbCIsIm9sZFByZXYiLCJuZXdQcmV2IiwibG9hZE1vZGUiLCJtb2RlT3B0aW9uIiwicmVzZXRNb2RlU3RhdGUiLCJpc1dob2xlTGluZVVwZGF0ZSIsIndob2xlTGluZVVwZGF0ZUJlZm9yZSIsInVwZGF0ZURvYyIsInNwYW5zRm9yIiwibGluZXNGb3IiLCJmaXJzdExpbmUiLCJsYXN0VGV4dCIsImxhc3RTcGFucyIsIm5saW5lcyIsImluc2VydCIsImFkZGVkIiwiYWRkZWQkMSIsImFkZGVkJDIiLCJsaW5rZWREb2NzIiwic2hhcmVkSGlzdE9ubHkiLCJwcm9wYWdhdGUiLCJza2lwIiwic2hhcmVkSGlzdCIsImxpbmtlZCIsInJlbCIsImF0dGFjaERvYyIsInNldERpcmVjdGlvbkNsYXNzIiwiZGlyZWN0aW9uQ2hhbmdlZCIsIkhpc3RvcnkiLCJ1bmRvbmUiLCJ1bmRvRGVwdGgiLCJsYXN0TW9kVGltZSIsImxhc3RTZWxUaW1lIiwibGFzdE9wIiwibGFzdFNlbE9wIiwibGFzdE9yaWdpbiIsImxhc3RTZWxPcmlnaW4iLCJnZW5lcmF0aW9uIiwibWF4R2VuZXJhdGlvbiIsImhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlIiwiaGlzdENoYW5nZSIsImF0dGFjaExvY2FsU3BhbnMiLCJjbGVhclNlbGVjdGlvbkV2ZW50cyIsImxhc3RDaGFuZ2VFdmVudCIsImhpc3QiLCJhZGRDaGFuZ2VUb0hpc3RvcnkiLCJzZWxBZnRlciIsIm9wSWQiLCJoaXN0b3J5IiwiaGlzdG9yeUV2ZW50RGVsYXkiLCJwdXNoU2VsZWN0aW9uVG9IaXN0b3J5Iiwic2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZCIsImFkZFNlbGVjdGlvblRvSGlzdG9yeSIsImNsZWFyUmVkbyIsImRlc3QiLCJleGlzdGluZyIsInJlbW92ZUNsZWFyZWRTcGFucyIsImV4cGxpY2l0bHlDbGVhcmVkIiwiZ2V0T2xkU3BhbnMiLCJtZXJnZU9sZFNwYW5zIiwic3RyZXRjaGVkIiwib2xkQ3VyIiwic3RyZXRjaEN1ciIsImNvcHlIaXN0b3J5QXJyYXkiLCJuZXdHcm91cCIsImluc3RhbnRpYXRlU2VsIiwibmV3Q2hhbmdlcyIsImV4dGVuZFJhbmdlIiwicG9zQmVmb3JlIiwiZXh0ZW5kU2VsZWN0aW9uIiwic2V0U2VsZWN0aW9uIiwiZXh0ZW5kU2VsZWN0aW9ucyIsImhlYWRzIiwibmV3U2VsIiwicmVwbGFjZU9uZVNlbGVjdGlvbiIsInNldFNpbXBsZVNlbGVjdGlvbiIsImZpbHRlclNlbGVjdGlvbkNoYW5nZSIsInNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5Iiwic2V0U2VsZWN0aW9uTm9VbmRvIiwic2V0U2VsZWN0aW9uSW5uZXIiLCJza2lwQXRvbWljSW5TZWxlY3Rpb24iLCJyZUNoZWNrU2VsZWN0aW9uIiwibWF5Q2xlYXIiLCJuZXdBbmNob3IiLCJza2lwQXRvbWljIiwibmV3SGVhZCIsInNraXBBdG9taWNJbm5lciIsIm9sZFBvcyIsInByZXZlbnRDdXJzb3JMZWZ0Iiwic2VsZWN0TGVmdCIsInByZXZlbnRDdXJzb3JSaWdodCIsInNlbGVjdFJpZ2h0IiwiYXRvbWljIiwibmVhciIsIm1vdmVQb3MiLCJmYXIiLCJjYW50RWRpdCIsInNlbGVjdEFsbCIsImZpbHRlckNoYW5nZSIsImNhbmNlbGVkIiwiY2FuY2VsIiwibWFrZUNoYW5nZSIsImlnbm9yZVJlYWRPbmx5Iiwic3VwcHJlc3NFZGl0cyIsIm1ha2VDaGFuZ2VJbm5lciIsIm1ha2VDaGFuZ2VTaW5nbGVEb2MiLCJyZWJhc2VkIiwicmViYXNlSGlzdCIsIm1ha2VDaGFuZ2VGcm9tSGlzdG9yeSIsImFsbG93U2VsZWN0aW9uT25seSIsInN1cHByZXNzIiwiYW50aUNoYW5nZXMiLCJyZXR1cm5lZCIsInNoaWZ0RG9jIiwiZGlzdGFuY2UiLCJyZW1vdmVkIiwibWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yIiwicmVjb21wdXRlTWF4TGVuZ3RoIiwiY2hlY2tXaWR0aFN0YXJ0IiwiY2hhbmdlc0hhbmRsZXIiLCJjaGFuZ2VIYW5kbGVyIiwicmVwbGFjZVJhbmdlIiwic3BsaXRMaW5lcyIsInJlYmFzZUhpc3RTZWxTaW5nbGUiLCJyZWJhc2VIaXN0QXJyYXkiLCJjb3BpZWQiLCJjaGFuZ2VMaW5lIiwiY2hhbmdlVHlwZSIsIkxlYWZDaHVuayIsInJlbW92ZUlubmVyIiwiaW5zZXJ0SW5uZXIiLCJpdGVyTiIsIkJyYW5jaENodW5rIiwibGVhZiIsIm1heWJlU3BpbGwiLCJtZSIsInNwaWxsZWQiLCJzaWJsaW5nIiwibXlJbmRleCIsInVzZWQiLCJMaW5lV2lkZ2V0Iiwib3B0IiwiYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZSIsInRoaXMkMSIsIm9sZEgiLCJhZGRMaW5lV2lkZ2V0IiwiaW5zZXJ0QXQiLCJhYm92ZVZpc2libGUiLCJuZXh0TWFya2VySWQiLCJUZXh0TWFya2VyIiwid2l0aE9wIiwidmlzdWFsIiwiZEhlaWdodCIsIm1hcmtUZXh0IiwibWFya1RleHRTaGFyZWQiLCJyZXBsYWNlZFdpdGgiLCJhZGRUb0hpc3RvcnkiLCJjdXJMaW5lIiwiY2xlYXJPbkVudGVyIiwiY2xlYXJIaXN0b3J5IiwiU2hhcmVkVGV4dE1hcmtlciIsImNsb25lTm9kZSIsImlzUGFyZW50IiwiZmluZFNoYXJlZE1hcmtlcnMiLCJmaW5kTWFya3MiLCJjb3B5U2hhcmVkTWFya2VycyIsIm1Gcm9tIiwibVRvIiwic3ViTWFyayIsImRldGFjaFNoYXJlZE1hcmtlcnMiLCJzdWJNYXJrZXIiLCJuZXh0RG9jSWQiLCJEb2MiLCJsaW5lU2VwIiwiY2xlYW5HZW5lcmF0aW9uIiwiZ2V0VmFsdWUiLCJsaW5lU2VwYXJhdG9yIiwic2V0VmFsdWUiLCJnZXRSYW5nZSIsImdldExpbmVIYW5kbGUiLCJnZXRMaW5lTnVtYmVyIiwiZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0IiwibGluZUNvdW50IiwibGlzdFNlbGVjdGlvbnMiLCJzZXRDdXJzb3IiLCJleHRlbmRTZWxlY3Rpb25zQnkiLCJzZXRTZWxlY3Rpb25zIiwiYWRkU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9ucyIsInJlcGxhY2VTZWxlY3Rpb24iLCJkdXAiLCJyZXBsYWNlU2VsZWN0aW9ucyIsInVuZG8iLCJyZWRvIiwidW5kb1NlbGVjdGlvbiIsInJlZG9TZWxlY3Rpb24iLCJzZXRFeHRlbmRpbmciLCJnZXRFeHRlbmRpbmciLCJoaXN0b3J5U2l6ZSIsIm1hcmtDbGVhbiIsImNoYW5nZUdlbmVyYXRpb24iLCJmb3JjZVNwbGl0IiwiaXNDbGVhbiIsImdlbiIsImdldEhpc3RvcnkiLCJzZXRIaXN0b3J5IiwiaGlzdERhdGEiLCJzZXRHdXR0ZXJNYXJrZXIiLCJndXR0ZXJJRCIsImNsZWFyR3V0dGVyIiwibGluZUluZm8iLCJhZGRMaW5lQ2xhc3MiLCJ3aGVyZSIsInJlbW92ZUxpbmVDbGFzcyIsInJlbW92ZUxpbmVXaWRnZXQiLCJzZXRCb29rbWFyayIsInJlYWxPcHRzIiwiZmluZE1hcmtzQXQiLCJnZXRBbGxNYXJrcyIsInBvc0Zyb21JbmRleCIsInNlcFNpemUiLCJpbmRleEZyb21Qb3MiLCJjb3B5SGlzdG9yeSIsImxpbmtlZERvYyIsInVubGlua0RvYyIsIkNvZGVNaXJyb3IiLCJzcGxpdElkcyIsIml0ZXJMaW5rZWREb2NzIiwiZ2V0RWRpdG9yIiwic2V0RGlyZWN0aW9uIiwiZWFjaExpbmUiLCJsYXN0RHJvcCIsIm9uRHJvcCIsImNsZWFyRHJhZ0N1cnNvciIsImZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiaXNSZWFkT25seSIsIkZpbGVSZWFkZXIiLCJGaWxlIiwicmVhZCIsIm1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkIiwicmVhZFRleHRGcm9tRmlsZSIsImZpbGUiLCJhbGxvd0Ryb3BGaWxlVHlwZXMiLCJyZWFkZXIiLCJvbmVycm9yIiwib25sb2FkIiwicmVhZEFzVGV4dCIsInRleHQkMSIsImdldERhdGEiLCJvbkRyYWdTdGFydCIsInNldERhdGEiLCJlZmZlY3RBbGxvd2VkIiwic2V0RHJhZ0ltYWdlIiwiaW1nIiwiX3RvcCIsIm9uRHJhZ092ZXIiLCJmcmFnIiwiZHJhZ0N1cnNvciIsImZvckVhY2hDb2RlTWlycm9yIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImJ5Q2xhc3MiLCJlZGl0b3JzIiwiZ2xvYmFsc1JlZ2lzdGVyZWQiLCJlbnN1cmVHbG9iYWxIYW5kbGVycyIsInJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMiLCJyZXNpemVUaW1lciIsIm9uUmVzaXplIiwic2V0U2l6ZSIsImtleU5hbWVzIiwia2V5TWFwIiwiYmFzaWMiLCJwY0RlZmF1bHQiLCJlbWFjc3kiLCJtYWNEZWZhdWx0Iiwibm9ybWFsaXplS2V5TmFtZSIsImFsdCIsImN0cmwiLCJjbWQiLCJtb2QiLCJub3JtYWxpemVLZXlNYXAiLCJrZXltYXAiLCJrZXluYW1lIiwibG9va3VwS2V5IiwiZ2V0S2V5TWFwIiwiZmFsbHRocm91Z2giLCJpc01vZGlmaWVyS2V5Iiwia2V5Q29kZSIsImFkZE1vZGlmaWVyTmFtZXMiLCJub1NoaWZ0IiwiYWx0S2V5IiwibWV0YUtleSIsInNoaWZ0S2V5Iiwia2V5TmFtZSIsImFsdEdyYXBoS2V5IiwiZGVsZXRlTmVhclNlbGVjdGlvbiIsImNvbXB1dGUiLCJraWxsIiwidG9LaWxsIiwicmVwbGFjZWQiLCJtb3ZlQ2hhckxvZ2ljYWxseSIsIm1vdmVMb2dpY2FsbHkiLCJlbmRPZkxpbmUiLCJ2aXN1YWxseSIsIm1vdmVJblN0b3JhZ2VPcmRlciIsInByZXAiLCJtb3ZlVmlzdWFsbHkiLCJiaWRpIiwibXYiLCJnZXRXcmFwcGVkTGluZUV4dGVudCIsInNlYXJjaEluVmlzdWFsTGluZSIsImdldFJlcyIsIm5leHRDaCIsImNvbW1hbmRzIiwic2luZ2xlU2VsZWN0aW9uIiwia2lsbExpbmUiLCJkZWxldGVMaW5lIiwiZGVsTGluZUxlZnQiLCJkZWxXcmFwcGVkTGluZUxlZnQiLCJsZWZ0UG9zIiwiZGVsV3JhcHBlZExpbmVSaWdodCIsInJpZ2h0UG9zIiwiZ29Eb2NTdGFydCIsImdvRG9jRW5kIiwiZ29MaW5lU3RhcnQiLCJnb0xpbmVTdGFydFNtYXJ0IiwibGluZVN0YXJ0U21hcnQiLCJnb0xpbmVFbmQiLCJsaW5lRW5kIiwiZ29MaW5lUmlnaHQiLCJnb0xpbmVMZWZ0IiwiZ29MaW5lTGVmdFNtYXJ0IiwiZ29MaW5lVXAiLCJtb3ZlViIsImdvTGluZURvd24iLCJnb1BhZ2VVcCIsImdvUGFnZURvd24iLCJnb0NoYXJMZWZ0IiwibW92ZUgiLCJnb0NoYXJSaWdodCIsImdvQ29sdW1uTGVmdCIsImdvQ29sdW1uUmlnaHQiLCJnb1dvcmRMZWZ0IiwiZ29Hcm91cFJpZ2h0IiwiZ29Hcm91cExlZnQiLCJnb1dvcmRSaWdodCIsImRlbENoYXJCZWZvcmUiLCJkZWxldGVIIiwiZGVsQ2hhckFmdGVyIiwiZGVsV29yZEJlZm9yZSIsImRlbFdvcmRBZnRlciIsImRlbEdyb3VwQmVmb3JlIiwiZGVsR3JvdXBBZnRlciIsImluZGVudEF1dG8iLCJpbmRlbnRTZWxlY3Rpb24iLCJpbmRlbnRNb3JlIiwiaW5kZW50TGVzcyIsImluc2VydFRhYiIsImluc2VydFNvZnRUYWIiLCJkZWZhdWx0VGFiIiwiZXhlY0NvbW1hbmQiLCJ0cmFuc3Bvc2VDaGFycyIsIm5ld2xpbmVBbmRJbmRlbnQiLCJzZWxzIiwiaW5kZW50TGluZSIsIm9wZW5MaW5lIiwidG9nZ2xlT3ZlcndyaXRlIiwiZmlyc3ROb25XUyIsImluV1MiLCJkb0hhbmRsZUJpbmRpbmciLCJkcm9wU2hpZnQiLCJlbnN1cmVQb2xsZWQiLCJwcmV2U2hpZnQiLCJsb29rdXBLZXlGb3JFZGl0b3IiLCJrZXlNYXBzIiwiZXh0cmFLZXlzIiwic3RvcFNlcSIsImRpc3BhdGNoS2V5Iiwic2VxIiwia2V5U2VxIiwiZGlzcGF0Y2hLZXlJbm5lciIsImhhbmRsZUtleUJpbmRpbmciLCJtb3Rpb24iLCJoYW5kbGVDaGFyQmluZGluZyIsImxhc3RTdG9wcGVkS2V5IiwiZ2V0RmllbGQiLCJoYW5kbGVkIiwic2hvd0Nyb3NzSGFpciIsInVwIiwib25LZXlVcCIsIm9uS2V5UHJlc3MiLCJjaGFyQ29kZSIsIkRPVUJMRUNMSUNLX0RFTEFZIiwiUGFzdENsaWNrIiwiY29tcGFyZSIsImxhc3RDbGljayIsImxhc3REb3VibGVDbGljayIsImNsaWNrUmVwZWF0Iiwib25Nb3VzZURvd24iLCJzdXBwb3J0c1RvdWNoIiwiY2xpY2tJbkd1dHRlciIsInNlbGVjdGluZ1RleHQiLCJoYW5kbGVNYXBwZWRCdXR0b24iLCJsZWZ0QnV0dG9uRG93biIsIm9uQ29udGV4dE1lbnUiLCJjb25maWd1cmVNb3VzZSIsIm9wdGlvbiIsInVuaXQiLCJhZGROZXciLCJtb3ZlT25EcmFnIiwiYmVoYXZpb3IiLCJjb250YWluZWQiLCJkcmFnRHJvcCIsImxlZnRCdXR0b25TdGFydERyYWciLCJsZWZ0QnV0dG9uU2VsZWN0IiwibW92ZWQiLCJkcmFnRW5kIiwiZHJhZ1N0YXJ0IiwicHJldmVudFNjcm9sbCIsImUyIiwicmFuZ2VGb3JVbml0IiwiZmluZFdvcmRBdCIsIm91clJhbmdlIiwib3VySW5kZXgiLCJzdGFydFNlbCIsImxhc3RQb3MiLCJleHRlbmRUbyIsInN0YXJ0Q29sIiwicG9zQ29sIiwib2xkUmFuZ2UiLCJyYW5nZXMkMSIsImJpZGlTaW1wbGlmeSIsImVkaXRvclNpemUiLCJjdXJDb3VudCIsIm1vdmUiLCJidXR0b25zIiwiYW5jaG9yTGluZSIsImJvdW5kYXJ5IiwiaGVhZEluZGV4IiwidXNlUGFydCIsImd1dHRlckV2ZW50IiwicHJldmVudCIsIm1YIiwibVkiLCJ0b3VjaGVzIiwibGluZUJveCIsImciLCJjb250ZXh0TWVudUluR3V0dGVyIiwidGhlbWVDaGFuZ2VkIiwiSW5pdCIsImRlZmF1bHRzIiwib3B0aW9uSGFuZGxlcnMiLCJkZWZpbmVPcHRpb25zIiwiZGVmbHQiLCJub3RPbkluaXQiLCJkZWZpbmVPcHRpb24iLCJuZXdCcmVha3MiLCJyZWZyZXNoIiwiZ2V0SW5wdXRGaWVsZCIsInNwZWxsY2hlY2siLCJhdXRvY29ycmVjdCIsImF1dG9jYXBpdGFsaXplIiwiZGV0YWNoIiwiYXR0YWNoIiwid3JhcHBpbmdDaGFuZ2VkIiwiYmx1ciIsInJlYWRPbmx5Q2hhbmdlZCIsInNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCIsImRyYWdEcm9wQ2hhbmdlZCIsInJlc2V0UG9zaXRpb24iLCJ3YXNPbiIsImZ1bmNzIiwiZHJhZ0Z1bmN0aW9ucyIsIm92ZXIiLCJsZWF2ZSIsImRyb3AiLCJpbnB1dFN0eWxlcyIsImlucHV0U3R5bGUiLCJwYXN0ZUluY29taW5nIiwiY3V0SW5jb21pbmciLCJhdXRvZm9jdXMiLCJyZWdpc3RlckV2ZW50SGFuZGxlcnMiLCJmaW5pc2hJbml0IiwiaW5pdEhvb2tzIiwidGV4dFJlbmRlcmluZyIsIndvcmQiLCJ0b3VjaEZpbmlzaGVkIiwicHJldlRvdWNoIiwiZmluaXNoVG91Y2giLCJpc01vdXNlTGlrZVRvdWNoRXZlbnQiLCJyYWRpdXNYIiwicmFkaXVzWSIsImZhckF3YXkiLCJwYWdlWCIsInBhZ2VZIiwiaW5wIiwiZGVmaW5lSW5pdEhvb2siLCJob3ciLCJhZ2dyZXNzaXZlIiwiaW5kZW50IiwiY3VyU3BhY2UiLCJjdXJTcGFjZVN0cmluZyIsImluZGVudFVuaXQiLCJpbmRlbnRTdHJpbmciLCJpbmRlbnRXaXRoVGFicyIsInBvcyQxIiwibGFzdENvcGllZCIsInNldExhc3RDb3BpZWQiLCJuZXdMYXN0Q29waWVkIiwiYXBwbHlUZXh0SW5wdXQiLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJyZWNlbnQiLCJwYXN0ZSIsInRleHRMaW5lcyIsIm11bHRpUGFzdGUiLCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uIiwibGluZVdpc2UiLCJ0cmlnZ2VyRWxlY3RyaWMiLCJoYW5kbGVQYXN0ZSIsInBhc3RlZCIsImNsaXBib2FyZERhdGEiLCJkaXNhYmxlSW5wdXQiLCJlbGVjdHJpY0NoYXJzIiwic21hcnRJbmRlbnQiLCJnZXRNb2RlQXQiLCJlbGVjdHJpY0lucHV0IiwiY29weWFibGVSYW5nZXMiLCJsaW5lUmFuZ2UiLCJkaXNhYmxlQnJvd3Nlck1hZ2ljIiwiZmllbGQiLCJoaWRkZW5UZXh0YXJlYSIsImJvcmRlciIsImFkZEVkaXRvck1ldGhvZHMiLCJoZWxwZXJzIiwic2V0T3B0aW9uIiwiZ2V0RG9jIiwiYWRkS2V5TWFwIiwicmVtb3ZlS2V5TWFwIiwiYWRkT3ZlcmxheSIsIm1vZGVTcGVjIiwicmVtb3ZlT3ZlcmxheSIsIm5ld1JhbmdlcyIsImdldFRva2VuQXQiLCJnZXRMaW5lVG9rZW5zIiwiZ2V0VG9rZW5UeXBlQXQiLCJnZXRIZWxwZXIiLCJnZXRIZWxwZXJzIiwiaGVscCIsImdldFN0YXRlQWZ0ZXIiLCJkZWZhdWx0VGV4dEhlaWdodCIsImRlZmF1bHRDaGFyV2lkdGgiLCJnZXRWaWV3cG9ydCIsImFkZFdpZGdldCIsInZzcGFjZSIsImhzcGFjZSIsInRyaWdnZXJPbktleURvd24iLCJ0cmlnZ2VyT25LZXlQcmVzcyIsInRyaWdnZXJPbktleVVwIiwidHJpZ2dlck9uTW91c2VEb3duIiwiZmluZFBvc0giLCJhbW91bnQiLCJoaXRTaWRlIiwicnRsTW92ZVZpc3VhbGx5IiwiZmluZFBvc1YiLCJnb2FsQ29sdW1uIiwiZ29hbHMiLCJoZWFkUG9zIiwic3RhcnRDaGFyIiwic2Nyb2xsVG8iLCJnZXRTY3JvbGxJbmZvIiwiaW50ZXJwcmV0Iiwic3dhcERvYyIsInBocmFzZSIsInBocmFzZVRleHQiLCJwaHJhc2VzIiwiZ2V0U2Nyb2xsZXJFbGVtZW50IiwiZ2V0R3V0dGVyRWxlbWVudCIsInJlZ2lzdGVySGVscGVyIiwicmVnaXN0ZXJHbG9iYWxIZWxwZXIiLCJvcmlnRGlyIiwibGluZURpciIsImZpbmROZXh0TGluZSIsIm1vdmVPbmNlIiwiYm91bmRUb0xpbmUiLCJhc3RyYWwiLCJzYXdUeXBlIiwicGFnZVNpemUiLCJtb3ZlQW1vdW50IiwiQ29udGVudEVkaXRhYmxlSW5wdXQiLCJsYXN0QW5jaG9yTm9kZSIsImxhc3RBbmNob3JPZmZzZXQiLCJsYXN0Rm9jdXNOb2RlIiwibGFzdEZvY3VzT2Zmc2V0IiwicG9sbGluZyIsImNvbXBvc2luZyIsImdyYWNlUGVyaW9kIiwicmVhZERPTVRpbWVvdXQiLCJjb250ZW50RWRpdGFibGUiLCJiZWxvbmdzVG9JbnB1dCIsInVwZGF0ZUZyb21ET00iLCJyZWFkRnJvbURPTVNvb24iLCJmb3JjZUNvbXBvc2l0aW9uRW5kIiwib25Db3B5Q3V0IiwibGluZVdpc2VDb3B5Q3V0IiwiY2xlYXJEYXRhIiwia2x1ZGdlIiwiaGFkRm9jdXMiLCJzaG93UHJpbWFyeVNlbGVjdGlvbiIsImxhYmVsIiwic2hvd011bHRpcGxlU2VsZWN0aW9ucyIsImN1ckFuY2hvciIsImRvbVRvUG9zIiwiY3VyRm9jdXMiLCJiYWQiLCJwb3NUb0RPTSIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0Iiwicm5nIiwic3RhcnRHcmFjZVBlcmlvZCIsInJlbWVtYmVyU2VsZWN0aW9uIiwic2VsZWN0aW9uSW5FZGl0b3IiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsInBvbGxTZWxlY3Rpb24iLCJwb2xsIiwicG9sbEludGVydmFsIiwiaXNJbkd1dHRlciIsInBvbGxDb250ZW50IiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJwcmV2aW91c1NpYmxpbmciLCJuZXdUZXh0IiwiZG9tVGV4dEJldHdlZW4iLCJvbGRUZXh0IiwiY3V0RnJvbnQiLCJjdXRFbmQiLCJvbGRUb3AiLCJtYXhDdXRGcm9udCIsIm5ld0JvdCIsIm9sZEJvdCIsIm1heEN1dEVuZCIsImNoRnJvbSIsImNoVG8iLCJzY2FuIiwiYmFkUG9zIiwiY2xvc2luZyIsImV4dHJhTGluZWJyZWFrIiwicmVjb2duaXplTWFya2VyIiwiYWRkVGV4dCIsIndhbGsiLCJjbVRleHQiLCJtYXJrZXJJRCIsImlzQmxvY2siLCJub2RlVmFsdWUiLCJsaW5lTm9kZSIsImxvY2F0ZU5vZGVJbkxpbmVWaWV3IiwidGV4dE5vZGUiLCJ0b3BOb2RlIiwiY3VyTm9kZSIsImRpc3QkMSIsIlRleHRhcmVhSW5wdXQiLCJwcmV2SW5wdXQiLCJwb2xsaW5nRmFzdCIsImNyZWF0ZUZpZWxkIiwidGV4dGFyZWEiLCJmYXN0UG9sbCIsInByZXBhcmVDb3B5Q3V0IiwiRXZlbnQiLCJfZGlzcGxheSIsIm1vdmVJbnB1dFdpdGhDdXJzb3IiLCJ3cmFwT2ZmIiwibGluZU9mZiIsInRlVG9wIiwidGVMZWZ0IiwiZHJhd24iLCJjb250ZXh0TWVudVBlbmRpbmciLCJzbG93UG9sbCIsIm1pc3NlZCIsInNhbWUiLCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUiLCJvbGRDU1MiLCJvbGRXcmFwcGVyQ1NTIiwid3JhcHBlckJveCIsIm9mZnNldFBhcmVudCIsIm9sZFNjcm9sbFkiLCJzY3JvbGxZIiwicmVoaWRlIiwiZGV0ZWN0aW5nU2VsZWN0QWxsIiwicHJlcGFyZVNlbGVjdEFsbEhhY2siLCJleHR2YWwiLCJtb3VzZXVwIiwiZGlzYWJsZWQiLCJmcm9tVGV4dEFyZWEiLCJ0YWJpbmRleCIsInBsYWNlaG9sZGVyIiwicmVhbFN1Ym1pdCIsImZvcm0iLCJsZWF2ZVN1Ym1pdE1ldGhvZEFsb25lIiwic3VibWl0Iiwid3JhcHBlZFN1Ym1pdCIsImdldFRleHRBcmVhIiwidG9UZXh0QXJlYSIsImFkZExlZ2FjeVByb3BzIiwiY21wUG9zIiwiZG9udERlbGVnYXRlIiwiZGVmaW5lRXh0ZW5zaW9uIiwiZnVuYyIsImRlZmluZURvY0V4dGVuc2lvbiIsImNvbmZpZyIsInBhcnNlckNvbmZpZyIsInN0YXRlbWVudEluZGVudCIsImpzb25sZE1vZGUiLCJqc29ubGQiLCJqc29uTW9kZSIsImpzb24iLCJ0cmFja1Njb3BlIiwiaXNUUyIsInR5cGVzY3JpcHQiLCJ3b3JkUkUiLCJ3b3JkQ2hhcmFjdGVycyIsImtleXdvcmRzIiwia3ciLCJvcGVyYXRvciIsImF0b20iLCJpc09wZXJhdG9yQ2hhciIsImlzSnNvbmxkS2V5d29yZCIsInJlYWRSZWdleHAiLCJlc2NhcGVkIiwiaW5TZXQiLCJ0cCIsImNvbnQiLCJ0b2tlbkJhc2UiLCJ0b2tlbml6ZSIsInRva2VuU3RyaW5nIiwidG9rZW5Db21tZW50IiwiZXhwcmVzc2lvbkFsbG93ZWQiLCJ0b2tlblF1YXNpIiwibGV4aWNhbCIsImxhc3RUeXBlIiwicXVvdGUiLCJtYXliZUVuZCIsImJyYWNrZXRzIiwiZmluZEZhdEFycm93IiwiZmF0QXJyb3dBdCIsInNhd1NvbWV0aGluZyIsImJyYWNrZXQiLCJhdG9taWNUeXBlcyIsIkpTTGV4aWNhbCIsImluU2NvcGUiLCJ2YXJuYW1lIiwibG9jYWxWYXJzIiwiY3giLCJ2YXJzIiwicGFyc2VKUyIsImNjIiwibWFya2VkIiwiY29tYmluYXRvciIsImV4cHJlc3Npb24iLCJzdGF0ZW1lbnQiLCJsZXgiLCJwYXNzIiwiaW5MaXN0IiwicmVnaXN0ZXIiLCJibG9jayIsIm5ld0NvbnRleHQiLCJyZWdpc3RlclZhclNjb3BlZCIsIlZhciIsImdsb2JhbFZhcnMiLCJpc01vZGlmaWVyIiwiZGVmYXVsdFZhcnMiLCJwdXNoY29udGV4dCIsInB1c2hibG9ja2NvbnRleHQiLCJwb3Bjb250ZXh0IiwicHVzaGxleCIsInBvcGxleCIsImV4cGVjdCIsIndhbnRlZCIsInZhcmRlZiIsInBhcmVuRXhwciIsIm1heWJlZXhwcmVzc2lvbiIsIm1heWJlZWxzZSIsImZ1bmN0aW9uZGVmIiwiZm9yc3BlYyIsImVudW1kZWYiLCJ0eXBlbmFtZSIsInR5cGVleHByIiwibWF5YmVsYWJlbCIsIm1heWJlQ2F0Y2hCaW5kaW5nIiwiYWZ0ZXJFeHBvcnQiLCJhZnRlckltcG9ydCIsImZ1bmFyZyIsImV4cHJlc3Npb25Jbm5lciIsImV4cHJlc3Npb25Ob0NvbW1hIiwibm9Db21tYSIsImFycm93Qm9keU5vQ29tbWEiLCJhcnJvd0JvZHkiLCJjb21tYXNlcCIsIm1heWJlb3AiLCJtYXliZW9wZXJhdG9yTm9Db21tYSIsIm1heWJlb3BlcmF0b3JDb21tYSIsImNsYXNzRXhwcmVzc2lvbiIsImFycmF5TGl0ZXJhbCIsImNvbnRDb21tYXNlcCIsIm9ianByb3AiLCJxdWFzaSIsIm1heWJlVGFyZ2V0IiwiZXhwciIsInByb3BlcnR5IiwiY29udGludWVRdWFzaSIsInRhcmdldE5vQ29tbWEiLCJtYXliZVR5cGVBcmdzIiwiXyIsImdldHRlclNldHRlciIsImFmdGVycHJvcCIsIm1heWJldHlwZSIsIndoYXQiLCJzZXAiLCJwcm9jZWVkIiwibWF5YmV0eXBlT3JJbiIsIm1heWJlcmV0dHlwZSIsImlzS1ciLCJhZnRlclR5cGUiLCJ0eXBlcHJvcHMiLCJ0eXBlYXJnIiwibWF5YmVSZXR1cm5UeXBlIiwicXVhc2lUeXBlIiwidHlwZXByb3AiLCJmdW5jdGlvbmRlY2wiLCJjb250aW51ZVF1YXNpVHlwZSIsInR5cGVwYXJhbSIsIm1heWJlVHlwZURlZmF1bHQiLCJtYXliZUFzc2lnbiIsInZhcmRlZkNvbnQiLCJlbHRwYXR0ZXJuIiwicHJvcHBhdHRlcm4iLCJfdHlwZSIsImZvcnNwZWMxIiwiZm9yc3BlYzIiLCJjbGFzc05hbWVBZnRlciIsImNsYXNzQm9keSIsImNsYXNzZmllbGQiLCJpc0ludGVyZmFjZSIsIm1heWJlRnJvbSIsImV4cG9ydEZpZWxkIiwiaW1wb3J0U3BlYyIsIm1heWJlTW9yZUltcG9ydHMiLCJtYXliZUFzIiwiZW51bW1lbWJlciIsImlzQ29udGludWVkU3RhdGVtZW50IiwidGV4dEFmdGVyIiwiYmFzZWNvbHVtbiIsImZpcnN0Q2hhciIsImRvdWJsZUluZGVudFN3aXRjaCIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwiYmxvY2tDb21tZW50Q29udGludWUiLCJsaW5lQ29tbWVudCIsImZvbGQiLCJjbG9zZUJyYWNrZXRzIiwic2tpcEV4cHJlc3Npb24iLCJlbnN1cmVGbGFncyIsIm1heWJlTXVsdGlsaW5lIiwic2VhcmNoUmVnZXhwRm9yd2FyZCIsInNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUiLCJpbnNpZGUiLCJzdGFydExpbmUiLCJsYXN0TWF0Y2hJbiIsImVuZE1hcmdpbiIsIm5ld01hdGNoIiwic2VhcmNoUmVnZXhwQmFja3dhcmQiLCJzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZSIsImRvRm9sZCIsIm5vRm9sZCIsIm5vcm1hbGl6ZSIsImFkanVzdFBvcyIsIm9yaWciLCJmb2xkZWQiLCJmb2xkRnVuYyIsInNlYXJjaFN0cmluZ0ZvcndhcmQiLCJxdWVyeSIsImNhc2VGb2xkIiwiY3V0RnJvbSIsImVuZFN0cmluZyIsInNlYXJjaFN0cmluZ0JhY2t3YXJkIiwidG9wU3RyaW5nIiwiU2VhcmNoQ3Vyc29yIiwiYXRPY2N1cnJlbmNlIiwiYWZ0ZXJFbXB0eU1hdGNoIiwibWF0Y2hlcyIsImZpbmROZXh0IiwiZmluZFByZXZpb3VzIiwiZ2V0U2VhcmNoQ3Vyc29yIiwiaWVfbHQ4IiwibWF0Y2hpbmciLCJicmFja2V0UmVnZXgiLCJmaW5kTWF0Y2hpbmdCcmFja2V0IiwiYWZ0ZXJDdXJzb3IiLCJzdHJpY3QiLCJzY2FuRm9yQnJhY2tldCIsImZvcndhcmQiLCJtYXhTY2FuTGVuIiwibWF4U2NhbkxpbmVMZW5ndGgiLCJtYXhTY2FuTGluZXMiLCJzdGFjayIsIm1hdGNoQnJhY2tldHMiLCJhdXRvY2xlYXIiLCJtYXhIaWdobGlnaHRMZW4iLCJtYXhIaWdobGlnaHRMaW5lTGVuZ3RoIiwiaGlnaGxpZ2h0Tm9uTWF0Y2hpbmciLCJtYXJrcyIsImRvTWF0Y2hCcmFja2V0cyIsImN1cnJlbnRseUhpZ2hsaWdodGVkIiwiY2xlYXJIaWdobGlnaHRlZCIsIm9sZENvbmZpZyIsImNtZHMiLCJmaW5kUG9zU3Vid29yZCIsInN0YXJ0UG9zIiwiY2F0IiwibW92ZVN1YndvcmQiLCJnb1N1YndvcmRMZWZ0IiwiZ29TdWJ3b3JkUmlnaHQiLCJzY3JvbGxMaW5lVXAiLCJ2aXNpYmxlQm90dG9tTGluZSIsInNjcm9sbExpbmVEb3duIiwidmlzaWJsZVRvcExpbmUiLCJzcGxpdFNlbGVjdGlvbkJ5TGluZSIsImxpbmVSYW5nZXMiLCJzaW5nbGVTZWxlY3Rpb25Ub3AiLCJzZWxlY3RMaW5lIiwiZXh0ZW5kZWQiLCJpbnNlcnRMaW5lIiwibmV3U2VsZWN0aW9uIiwiaW5zZXJ0TGluZUFmdGVyIiwiaW5zZXJ0TGluZUJlZm9yZSIsIndvcmRBdCIsInNlbGVjdE5leHRPY2N1cnJlbmNlIiwiZnVsbFdvcmQiLCJzdWJsaW1lRmluZEZ1bGxXb3JkIiwiaXNTZWxlY3RlZFJhbmdlIiwic2tpcEFuZFNlbGVjdE5leHRPY2N1cnJlbmNlIiwicHJldkFuY2hvciIsInByZXZIZWFkIiwiYWRkQ3Vyc29yVG9TZWxlY3Rpb24iLCJuZXdSYW5nZSIsImFkZEN1cnNvclRvUHJldkxpbmUiLCJhZGRDdXJzb3JUb05leHRMaW5lIiwibWlycm9yIiwic2VsZWN0QmV0d2VlbkJyYWNrZXRzIiwib3BlbmluZyIsInNlbGVjdFNjb3BlIiwicHVuY1R5cGUiLCJnb1RvQnJhY2tldCIsInN3YXBMaW5lVXAiLCJsaW5lc1RvTW92ZSIsIm5ld1NlbHMiLCJzd2FwTGluZURvd24iLCJ0b2dnbGVDb21tZW50SW5kZW50ZWQiLCJ0b2dnbGVDb21tZW50Iiwiam9pbkxpbmVzIiwiam9pbmVkIiwiYWN0dWFsIiwiZHVwbGljYXRlTGluZSIsInNvcnRMaW5lcyIsImNhc2VTZW5zaXRpdmUiLCJ0b1NvcnQiLCJhdSIsImJ1IiwicmV2ZXJzZVNvcnRMaW5lcyIsInNvcnRMaW5lc0luc2Vuc2l0aXZlIiwicmV2ZXJzZVNvcnRMaW5lc0luc2Vuc2l0aXZlIiwibmV4dEJvb2ttYXJrIiwic3VibGltZUJvb2ttYXJrcyIsInByZXZCb29rbWFyayIsInRvZ2dsZUJvb2ttYXJrIiwic3VibGltZUJvb2ttYXJrIiwiY2xlYXJCb29rbWFya3MiLCJzZWxlY3RCb29rbWFya3MiLCJtb2RpZnlXb3JkT3JTZWxlY3Rpb24iLCJpbmRpY2VzIiwicmVwbGFjZW1lbnRzIiwic21hcnRCYWNrc3BhY2UiLCJ0b1N0YXJ0T2ZMaW5lIiwiZGVsZXRlUG9zIiwicHJldkluZGVudCIsImRlbExpbmVSaWdodCIsInVwY2FzZUF0Q3Vyc29yIiwiZG93bmNhc2VBdEN1cnNvciIsInNldFN1YmxpbWVNYXJrIiwic3VibGltZU1hcmsiLCJzZWxlY3RUb1N1YmxpbWVNYXJrIiwiZGVsZXRlVG9TdWJsaW1lTWFyayIsInN1YmxpbWVLaWxsZWQiLCJzd2FwV2l0aFN1YmxpbWVNYXJrIiwic3VibGltZVlhbmsiLCJzaG93SW5DZW50ZXIiLCJnZXRUYXJnZXQiLCJmaW5kQW5kR29UbyIsImZpbmRVbmRlciIsImZpbmRVbmRlclByZXZpb3VzIiwiZmluZEFsbFVuZGVyIiwicHJpbWFyeUluZGV4IiwibWFjU3VibGltZSIsInBjU3VibGltZSIsImRlZmF1bHQiLCJzdWJsaW1lIiwiZGlhbG9nRGl2IiwiZGlhbG9nIiwiY2xvc2VOb3RpZmljYXRpb24iLCJuZXdWYWwiLCJjdXJyZW50Tm90aWZpY2F0aW9uQ2xvc2UiLCJjYWxsYmFjayIsImNsb3NlZCIsIm9uQ2xvc2UiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNlbGVjdFZhbHVlT25PcGVuIiwib25JbnB1dCIsImNsb3NlT25FbnRlciIsImNsb3NlT25CbHVyIiwiZXZ0IiwicmVsYXRlZFRhcmdldCIsImJsdXJyaW5nIiwiZG9uZVRpbWVyIiwiZHVyYXRpb24iLCJzZWFyY2hPdmVybGF5IiwiU2VhcmNoU3RhdGUiLCJwb3NGcm9tIiwicG9zVG8iLCJsYXN0UXVlcnkiLCJnZXRTZWFyY2hTdGF0ZSIsInF1ZXJ5Q2FzZUluc2Vuc2l0aXZlIiwicGVyc2lzdGVudERpYWxvZyIsIm9uRW50ZXIiLCJvcGVuRGlhbG9nIiwiY2xlYXJTZWFyY2giLCJzaG9ydFRleHQiLCJwcm9tcHQiLCJjb25maXJtRGlhbG9nIiwiZnMiLCJvcGVuQ29uZmlybSIsImNvbmZpcm0iLCJwYXJzZVN0cmluZyIsInBhcnNlUXVlcnkiLCJpc1JFIiwic3RhcnRTZWFyY2giLCJxdWVyeVRleHQiLCJzaG93TWF0Y2hlc09uU2Nyb2xsYmFyIiwiYW5ub3RhdGUiLCJkb1NlYXJjaCIsInJldiIsInBlcnNpc3RlbnQiLCJpbW1lZGlhdGUiLCJoaWRpbmciLCJzZWFyY2hOZXh0Iiwib3BhY2l0eSIsImdldFF1ZXJ5RGlhbG9nIiwiZXh0cmEiLCJhdHRycyIsImdldFJlcGxhY2VRdWVyeURpYWxvZyIsImdldFJlcGxhY2VtZW50UXVlcnlEaWFsb2ciLCJnZXREb1JlcGxhY2VDb25maXJtIiwicmVwbGFjZUFsbCIsImRpYWxvZ1RleHQiLCJhZHZhbmNlIiwiZG9SZXBsYWNlIiwiZmluZFBlcnNpc3RlbnQiLCJmaW5kUGVyc2lzdGVudE5leHQiLCJmaW5kUGVyc2lzdGVudFByZXYiLCJmaW5kUHJldiIsImdldEp1bXBEaWFsb2ciLCJpbnRlcnByZXRMaW5lIiwianVtcFRvTGluZSIsInBvc1N0ciIsIm5vT3B0aW9ucyIsIm5vbldTIiwibWluTGluZSIsInVuY29tbWVudCIsInByb2JhYmx5SW5zaWRlU3RyaW5nIiwidXNlSW5uZXJDb21tZW50cyIsImNvbW1lbnRTdHJpbmciLCJmdWxsTGluZXMiLCJibG9ja0NvbW1lbnQiLCJwYWQiLCJibGFua0xpbmVzIiwiY29tbWVudEJsYW5rTGluZXMiLCJiYXNlU3RyaW5nIiwid2hpdGVzcGFjZSIsInN0YXJ0U3RyaW5nIiwibGFzdExpbmVIYXNUZXh0IiwibGVhZCIsImJsb2NrQ29tbWVudExlYWQiLCJhdEN1cnNvciIsImxpbmVTdHJpbmciLCJkaWRTb21ldGhpbmciLCJlbmRMaW5lIiwiaW5zaWRlU3RhcnQiLCJpbnNpZGVFbmQiLCJsYXN0U3RhcnQiLCJmaXJzdEVuZCIsImFsbW9zdExhc3RTdGFydCIsImZvdW5kRW5kIiwiX3NjQ29tcG9uZW50IiwiY2xlYW5Eb2MiLCJTY0VkaXRvciIsImNvZGVNaXJyb3IiLCJfd2lkdGgiLCJfZWRpdG9yV2lkdGgiLCJfaGVpZ2h0IiwiX2VkaXRvckhlaWdodCIsIm9uS2V5ZG93biIsIiRjb2RlQ29udGFpbmVyIiwiVGFiIiwiY21TdHlsZXMiLCJtb25va2FpVGhlbWUiLCJhZGRvbkRpYWxvZyIsImRpcmVjdGl2ZXMiLCJpc0RpcmVjdGl2ZSIsImlzQ0VQb2x5ZmlsbCIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJyZW1vdmVOb2RlcyIsImJvdW5kQXR0cmlidXRlU3VmZml4IiwiaXNUZW1wbGF0ZVBhcnRBY3RpdmUiLCJsYXN0QXR0cmlidXRlTmFtZVJlZ2V4IiwicHJvY2Vzc29yIiwiX19wYXJ0cyIsImNvbW1pdCIsImhhbmRsZVRleHRFeHByZXNzaW9uIiwiaW5zZXJ0QWZ0ZXJOb2RlIiwiaGFuZGxlQXR0cmlidXRlRXhwcmVzc2lvbnMiLCJhZG9wdE5vZGUiLCJ1cGdyYWRlIiwiY29tbWVudE1hcmtlciIsIlRlbXBsYXRlUmVzdWx0IiwiaXNDb21tZW50QmluZGluZyIsImNvbW1lbnRPcGVuIiwiYXR0cmlidXRlTWF0Y2giLCJnZXRIVE1MIiwiQXR0cmlidXRlQ29tbWl0dGVyIiwiX2NyZWF0ZVBhcnQiLCJfZ2V0VmFsdWUiLCJjb21taXR0ZXIiLCJOb2RlUGFydCIsIl9faW5zZXJ0IiwiX19wZW5kaW5nVmFsdWUiLCJfX2NvbW1pdFRleHQiLCJfX2NvbW1pdFRlbXBsYXRlUmVzdWx0IiwiTm9kZSIsIl9fY29tbWl0Tm9kZSIsIl9fY29tbWl0SXRlcmFibGUiLCJ2YWx1ZUFzU3RyaW5nIiwidGVtcGxhdGVGYWN0b3J5IiwiYXBwZW5kSW50b1BhcnQiLCJpbnNlcnRBZnRlclBhcnQiLCJQcm9wZXJ0eUNvbW1pdHRlciIsInNpbmdsZSIsImV2ZW50T3B0aW9uc1N1cHBvcnRlZCIsImV2ZW50Q29udGV4dCIsIl9fYm91bmRIYW5kbGVFdmVudCIsIl9fb3B0aW9ucyIsImdldE9wdGlvbnMiLCJEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IiLCJwcmVmaXgiLCJkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IiLCJDbGFzc0xpc3QiLCJjbGFzc1N0cmluZyIsInByZXZpb3VzQ2xhc3Nlc0NhY2hlIiwicHJldmlvdXNDbGFzc2VzIiwiU2NUZXh0IiwicmVhZG9ubHkiLCIkdGV4dGFyZWEiLCJTY0JhbmciLCJfYWN0aXZlIiwiX3RpbWVvdXRJZCIsIl90cmlnZ2VyRXZlbnQiLCJTY1NpZ25hbCIsImNvbG9ycyIsImRpc3BsYXlNaW5NYXgiLCJfZnJhbWVTdGFjayIsIl9waXhlbEluZGV4IiwiX21heFZhbHVlIiwiX21pblZhbHVlIiwiX3JlbmRlclNpZ25hbCIsImZyYW1lIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImNhY2hlZENhbnZhcyIsImNhY2hlZEN0eCIsInJBRklkIiwiY2xlYXJSZWN0IiwiX2xvZ2ljYWxXaWR0aCIsIl9sb2dpY2FsSGVpZ2h0IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIl9nZXRZUG9zaXRpb24iLCJmcmFtZVN0YWNrU2l6ZSIsInNoaWZ0Q2FudmFzUGl4ZWxzIiwiYWJvcnQiLCJwaXhlbER1cmF0aW9uIiwicGl4ZWxTdGFydFRpbWUiLCJwaXhlbFN0b3BUaW1lIiwiY2FuZGlkYXRlSW5kZXgiLCJmcmFtZVRpbWUiLCJsYXN0RnJhbWUiLCJsYXN0RnJhbWVQaXhlbCIsImRyYXdJbWFnZSIsImxpbmVXaWR0aCIsImxpbmVDYXAiLCJzdHJva2VTdHlsZSIsImN1cnJlbnRZIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiXyRMSCIsImluc2VydFBhcnQiLCJjb250YWluZXJQYXJ0IiwicmVmUGFydCIsInJlZk5vZGUiLCJvbGRQYXJlbnQiLCJwYXJlbnRDaGFuZ2VkIiwibmV3Q29ubmVjdGlvblN0YXRlIiwiXyRyZXBhcmVudERpc2Nvbm5lY3RhYmxlcyIsInNldENoaWxkUGFydFZhbHVlIiwiUkVTRVRfVkFMVUUiLCJzZXRDb21taXR0ZWRWYWx1ZSIsImdldENvbW1pdHRlZFZhbHVlIiwicmVtb3ZlUGFydCIsImdlbmVyYXRlTWFwIiwiX2dldFZhbHVlc0FuZEtleXMiLCJpdGVtcyIsImtleUZuT3JUZW1wbGF0ZSIsImtleUZuIiwib2xkUGFydHMiLCJuZXdWYWx1ZXMiLCJuZXdLZXlzIiwiX2l0ZW1LZXlzIiwib2xkS2V5cyIsIm5ld0tleVRvSW5kZXhNYXAiLCJvbGRLZXlUb0luZGV4TWFwIiwib2xkSGVhZCIsIm9sZFRhaWwiLCJuZXdUYWlsIiwib2xkSW5kZXgiLCJvbGRQYXJ0IiwibmV3UGFydCIsIlNjRG90TWFwIiwiZGVmYXVsdFJhZGl1cyIsInJhZGl1cyIsInJhZGl1c1JlbCIsIm1heFNpemUiLCJjYXB0dXJlRXZlbnRzIiwicGVyc2lzdEV2ZW50cyIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRPcGFjaXR5IiwiYmFja2dyb3VuZEltYWdlIiwiZGVsdGFSYXRpbyIsInB4UmF0aW8iLCJsaW1pdGluZ1NpemUiLCJsaW1pdGluZ0RlbHRhIiwic3ZnV2lkdGgiLCJzdmdIZWlnaHQiLCJ4MnB4IiwieTJweCIsInJhZGl1czJweCIsImRvdHNSYWRpdXMiLCJ1cGRhdGVQb3NpdGlvbnMiLCJwb2ludGVyIiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsIm9sZFZhbCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsImF1ZGlvQ29udGV4dCIsIlNjRHJhZ05Ecm9wIiwic3RhdHVzIiwiZm9ybWF0Iiwib25EcmFnTGVhdmUiLCJkcm9wRWZmZWN0IiwiZGVjb2RlQXVkaW9EYXRhIiwiJGltZyIsIkltYWdlIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJyZWFkQXNEYXRhVVJMIiwiU2NNYXRyaXgiLCJfZW50cmllcyIsImNvbHVtbnMiLCJyb3dzIiwiX3Jvd3MiLCJfcmVzaXplTWF0cml4IiwiX2NvbHVtbnMiLCJyb3ciLCJjdXJyZW50VmFsdWUiLCJjbG9zZXN0IiwiY2VsbFdpZHRoIiwiY2VsbEhlaWdodCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJyb3dJbmRleCIsImNvbHVtbkluZGV4IiwiX3VwZGF0ZUNlbGwiLCJjdXJyZW50TnVtUm93cyIsImRhdGFzZXQiLCJjdXJyZW50SW5kZXgiLCJuZXh0SW5kZXgiLCJTY0NvbnRleHRNZW51IiwiX3Bvc1giLCJfcG9zWSIsInRyaWdnZXJFdmVudCIsImFjdGlvbiIsIlNjRmlsZVRyZWUiLCJfY3VycmVudEFjdGl2ZSIsImRpcmVjdG9yeSIsIl9vbkl0ZW1DbGljayIsIl9yZW5kZXJOb2RlIiwiY3VycmVudFRhcmdldCIsIl90cmlnZ2VySW5wdXQiLCJTY1RyYW5zcG9ydCIsInJlbmRlckZ1bmN0aW9ucyIsInBsYXkiLCJyZW5kZXJQbGF5IiwicGF1c2UiLCJyZW5kZXJQYXVzZSIsInJlbmRlclN0b3AiLCJfYnV0dG9ucyIsIl9vbkNoYW5nZSIsIlNjUmVjb3JkIiwiJGNoYW5nZSIsIiRjb21wb25lbnQiLCIkZXZlbnQiLCJ0aW1lb3V0SWRJbnB1dCIsInRpbWVvdXRJZFByZXNzIiwidGltZW91dElkUmVsZWFzZSIsIiR2YWx1ZSIsImV4YW1wbGVDb2RlIiwiJGVkaXRvciIsIiRkaXNwbGF5IiwiJGRvdE1hcCIsIiRkb3RNYXBEb3RzIiwiZG90cyIsInJlbW92ZUluZGV4Iiwic2hvdyIsInRyZWUiLCJwYXRoIiwiZXh0ZW5zaW9uIiwiJGJhbmciLCIkdGV4dCIsInNpbmVHZW5lcmF0b3IiLCJmcmVxdWVuY3kiLCJzYW1wbGVSYXRlIiwiYmxvY2tTaXplIiwibmJyQmxvY2tzIiwidEluY3IiLCJfMlBJIiwiUEkiLCJwSW5jciIsInBoYXNlIiwidGltZW91dElkIiwiY3JlYXRlQmxvY2siLCJzaW4iLCIkc2lnbmFsIiwic2luZTEiLCJzaW5lMiIsImRvY3MiLCJiYW5nIiwic2xpZGVyIiwidHJhbnNwb3J0IiwiZWRpdG9yIiwibWF0cml4IiwiZG90TWFwIiwiZHJhZ25kcm9wIiwiY29udGV4dE1lbnUiLCJmaWxlVHJlZSIsInNldFRoZW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUNBLElBQUlBLE1BQU0sR0FBR0MsY0FBQSxHQUFpQixPQUFPQyxNQUFQLElBQWlCLFdBQWpCLElBQWdDQSxNQUFNLENBQUNDLElBQVAsSUFBZUEsSUFBL0MsR0FDMUJELE1BRDBCLEdBQ2pCLE9BQU9FLElBQVAsSUFBZSxXQUFmLElBQThCQSxJQUFJLENBQUNELElBQUwsSUFBYUEsSUFBM0MsR0FBa0RDLElBQWxEO01BRVRDLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFISjtJQUlBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxHQUFHLEdBQUdOLE1BQU47OztFQ0w1QixJQUFJTyxjQUFjLEdBQUcsR0FBR0EsY0FBeEI7O0VBQ0EsUUFBYyxHQUFHLGFBQUEsQ0FBVUMsRUFBVixFQUFjQyxHQUFkLEVBQW1CO0lBQ2xDLE9BQU9GLGNBQWMsQ0FBQ0csSUFBZixDQUFvQkYsRUFBcEIsRUFBd0JDLEdBQXhCLENBQVA7RUFDRCxDQUZEOztFQ0RBLFVBQWMsR0FBRyxlQUFBLENBQVVFLElBQVYsRUFBZ0I7SUFDL0IsSUFBSTtNQUNGLE9BQU8sQ0FBQyxDQUFDQSxJQUFJLEVBQWI7S0FERixDQUVFLE9BQU9DLENBQVAsRUFBVTtNQUNWLE9BQU8sSUFBUDs7RUFFSCxDQU5EOztFQ0NBLGdCQUFjLEdBQUcsQ0FBQ0MsTUFBbUIsQ0FBQyxZQUFZO0lBQ2hELE9BQU9DLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQixFQUF0QixFQUEwQixHQUExQixFQUErQjtNQUFFQyxHQUFHLEVBQUUsZUFBWTtRQUFFLE9BQU8sQ0FBUDs7S0FBcEQsRUFBbUVDLENBQW5FLElBQXdFLENBQS9FO0VBQ0QsQ0FGb0MsQ0FBckM7OztJQ0RBLElBQUlDLElBQUksR0FBR2pCLGNBQUEsR0FBaUI7TUFBRWtCLE9BQU8sRUFBRTtLQUF2QztJQUNBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxHQUFHLEdBQUdGLElBQU47OztFQ0Q1QixhQUFjLEdBQUcsa0JBQUEsQ0FBVVYsRUFBVixFQUFjO0lBQzdCLE9BQU8sT0FBT0EsRUFBUCxLQUFjLFFBQWQsR0FBeUJBLEVBQUUsS0FBSyxJQUFoQyxHQUF1QyxPQUFPQSxFQUFQLEtBQWMsVUFBNUQ7RUFDRCxDQUZEOztFQ0NBLGFBQWMsR0FBRyxrQkFBQSxDQUFVQSxFQUFWLEVBQWM7SUFDN0IsSUFBSSxDQUFDYSxTQUFRLENBQUNiLEVBQUQsQ0FBYixFQUFtQixNQUFNYyxTQUFTLENBQUNkLEVBQUUsR0FBRyxvQkFBTixDQUFmO0lBQ25CLE9BQU9BLEVBQVA7RUFDRCxDQUhEOztFQ0FBLElBQUllLFVBQVEsR0FBR1YsT0FBb0IsQ0FBQ1UsUUFBcEM7O0VBRUEsSUFBSUMsRUFBRSxHQUFHSCxTQUFRLENBQUNFLFVBQUQsQ0FBUixJQUFzQkYsU0FBUSxDQUFDRSxVQUFRLENBQUNFLGFBQVYsQ0FBdkM7O0VBQ0EsY0FBYyxHQUFHLG1CQUFBLENBQVVqQixFQUFWLEVBQWM7SUFDN0IsT0FBT2dCLEVBQUUsR0FBR0QsVUFBUSxDQUFDRSxhQUFULENBQXVCakIsRUFBdkIsQ0FBSCxHQUFnQyxFQUF6QztFQUNELENBRkQ7O0VDSkEsaUJBQWMsR0FBRyxDQUFDSyxZQUFELElBQThCLENBQUNhLE1BQW1CLENBQUMsWUFBWTtJQUM5RSxPQUFPWixNQUFNLENBQUNDLGNBQVAsQ0FBc0JZLFVBQXdCLENBQUMsS0FBRCxDQUE5QyxFQUF1RCxHQUF2RCxFQUE0RDtNQUFFWCxHQUFHLEVBQUUsZUFBWTtRQUFFLE9BQU8sQ0FBUDs7S0FBakYsRUFBZ0dDLENBQWhHLElBQXFHLENBQTVHO0VBQ0QsQ0FGa0UsQ0FBbkU7O0VDRUE7RUFDQTs7RUFDQSxnQkFBYyxHQUFHLHFCQUFBLENBQVVULEVBQVYsRUFBY29CLENBQWQsRUFBaUI7SUFDaEMsSUFBSSxDQUFDUCxTQUFRLENBQUNiLEVBQUQsQ0FBYixFQUFtQixPQUFPQSxFQUFQO0lBQ25CLElBQUlxQixFQUFKLEVBQVFDLEdBQVI7SUFDQSxJQUFJRixDQUFDLElBQUksUUFBUUMsRUFBRSxHQUFHckIsRUFBRSxDQUFDdUIsUUFBaEIsS0FBNkIsVUFBbEMsSUFBZ0QsQ0FBQ1YsU0FBUSxDQUFDUyxHQUFHLEdBQUdELEVBQUUsQ0FBQ25CLElBQUgsQ0FBUUYsRUFBUixDQUFQLENBQTdELEVBQWtGLE9BQU9zQixHQUFQO0lBQ2xGLElBQUksUUFBUUQsRUFBRSxHQUFHckIsRUFBRSxDQUFDd0IsT0FBaEIsS0FBNEIsVUFBNUIsSUFBMEMsQ0FBQ1gsU0FBUSxDQUFDUyxHQUFHLEdBQUdELEVBQUUsQ0FBQ25CLElBQUgsQ0FBUUYsRUFBUixDQUFQLENBQXZELEVBQTRFLE9BQU9zQixHQUFQO0lBQzVFLElBQUksQ0FBQ0YsQ0FBRCxJQUFNLFFBQVFDLEVBQUUsR0FBR3JCLEVBQUUsQ0FBQ3VCLFFBQWhCLEtBQTZCLFVBQW5DLElBQWlELENBQUNWLFNBQVEsQ0FBQ1MsR0FBRyxHQUFHRCxFQUFFLENBQUNuQixJQUFILENBQVFGLEVBQVIsQ0FBUCxDQUE5RCxFQUFtRixPQUFPc0IsR0FBUDtJQUNuRixNQUFNUixTQUFTLENBQUMseUNBQUQsQ0FBZjtFQUNELENBUEQ7O0VDREEsSUFBSVcsRUFBRSxHQUFHbkIsTUFBTSxDQUFDQyxjQUFoQjtFQUVBLEtBQVMsR0FBR0YsWUFBeUIsR0FBR0MsTUFBTSxDQUFDQyxjQUFWLEdBQTJCLFNBQVNBLGNBQVQsQ0FBd0JtQixDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEJDLFVBQTlCLEVBQTBDO0lBQ3hHQyxTQUFRLENBQUNILENBQUQsQ0FBUjtJQUNBQyxDQUFDLEdBQUdHLFlBQVcsQ0FBQ0gsQ0FBRCxFQUFJLElBQUosQ0FBZjtJQUNBRSxTQUFRLENBQUNELFVBQUQsQ0FBUjtJQUNBLElBQUlHLGFBQUosRUFBb0IsSUFBSTtNQUN0QixPQUFPTixFQUFFLENBQUNDLENBQUQsRUFBSUMsQ0FBSixFQUFPQyxVQUFQLENBQVQ7S0FEa0IsQ0FFbEIsT0FBT3hCLENBQVAsRUFBVTs7O0lBQ1osSUFBSSxTQUFTd0IsVUFBVCxJQUF1QixTQUFTQSxVQUFwQyxFQUFnRCxNQUFNZCxTQUFTLENBQUMsMEJBQUQsQ0FBZjtJQUNoRCxJQUFJLFdBQVdjLFVBQWYsRUFBMkJGLENBQUMsQ0FBQ0MsQ0FBRCxDQUFELEdBQU9DLFVBQVUsQ0FBQ0ksS0FBbEI7SUFDM0IsT0FBT04sQ0FBUDtFQUNELENBVkQ7Ozs7O0VDTEEsaUJBQWMsR0FBRyxzQkFBQSxDQUFVTyxNQUFWLEVBQWtCRCxLQUFsQixFQUF5QjtJQUN4QyxPQUFPO01BQ0xFLFVBQVUsRUFBRSxFQUFFRCxNQUFNLEdBQUcsQ0FBWCxDQURQO01BRUxFLFlBQVksRUFBRSxFQUFFRixNQUFNLEdBQUcsQ0FBWCxDQUZUO01BR0xHLFFBQVEsRUFBRSxFQUFFSCxNQUFNLEdBQUcsQ0FBWCxDQUhMO01BSUxELEtBQUssRUFBRUE7S0FKVDtFQU1ELENBUEQ7O0VDRUEsU0FBYyxHQUFHM0IsWUFBeUIsR0FBRyxVQUFVZ0MsTUFBVixFQUFrQnBDLEdBQWxCLEVBQXVCK0IsS0FBdkIsRUFBOEI7SUFDekUsT0FBT1AsU0FBRSxDQUFDYSxDQUFILENBQUtELE1BQUwsRUFBYXBDLEdBQWIsRUFBa0JzQyxhQUFVLENBQUMsQ0FBRCxFQUFJUCxLQUFKLENBQTVCLENBQVA7RUFDRCxDQUZ5QyxHQUV0QyxVQUFVSyxNQUFWLEVBQWtCcEMsR0FBbEIsRUFBdUIrQixLQUF2QixFQUE4QjtJQUNoQ0ssTUFBTSxDQUFDcEMsR0FBRCxDQUFOLEdBQWMrQixLQUFkO0lBQ0EsT0FBT0ssTUFBUDtFQUNELENBTEQ7O0VDRkEsSUFBSUcsRUFBRSxHQUFHLENBQVQ7RUFDQSxJQUFJQyxFQUFFLEdBQUc5QyxJQUFJLENBQUMrQyxNQUFMLEVBQVQ7O0VBQ0EsUUFBYyxHQUFHLGFBQUEsQ0FBVXpDLEdBQVYsRUFBZTtJQUM5QixPQUFPLFVBQVUwQyxNQUFWLENBQWlCMUMsR0FBRyxLQUFLMkMsU0FBUixHQUFvQixFQUFwQixHQUF5QjNDLEdBQTFDLEVBQStDLElBQS9DLEVBQXFELENBQUMsRUFBRXVDLEVBQUYsR0FBT0MsRUFBUixFQUFZbEIsUUFBWixDQUFxQixFQUFyQixDQUFyRCxDQUFQO0VBQ0QsQ0FGRDs7RUNGQSxZQUFjLEdBQUcsS0FBakI7OztJQ0VBLElBQUlzQixNQUFNLEdBQUcsb0JBQWI7SUFDQSxJQUFJQyxLQUFLLEdBQUd0RCxPQUFNLENBQUNxRCxNQUFELENBQU4sS0FBbUJyRCxPQUFNLENBQUNxRCxNQUFELENBQU4sR0FBaUIsRUFBcEMsQ0FBWjtJQUVBLENBQUNwRCxjQUFBLEdBQWlCLFVBQVVRLEdBQVYsRUFBZStCLEtBQWYsRUFBc0I7TUFDdEMsT0FBT2MsS0FBSyxDQUFDN0MsR0FBRCxDQUFMLEtBQWU2QyxLQUFLLENBQUM3QyxHQUFELENBQUwsR0FBYStCLEtBQUssS0FBS1ksU0FBVixHQUFzQlosS0FBdEIsR0FBOEIsRUFBMUQsQ0FBUDtLQURGLEVBRUcsVUFGSCxFQUVlLEVBRmYsRUFFbUJlLElBRm5CLENBRXdCO01BQ3RCcEMsT0FBTyxFQUFFRCxLQUFJLENBQUNDLE9BRFE7TUFFdEJxQyxJQUFJLEVBQUUzQyxDQUFpQyxRQUZqQjtNQUd0QjRDLFNBQVMsRUFBRTtLQUxiOzs7RUNMQSxxQkFBYyxHQUFHNUMsT0FBb0IsQ0FBQywyQkFBRCxFQUE4QlIsUUFBUSxDQUFDMEIsUUFBdkMsQ0FBckM7OztJQ0dBLElBQUkyQixHQUFHLEdBQUc3QyxJQUFpQixDQUFDLEtBQUQsQ0FBM0I7SUFFQSxJQUFJOEMsU0FBUyxHQUFHLFVBQWhCO0lBQ0EsSUFBSUMsR0FBRyxHQUFHLENBQUMsS0FBS0MsaUJBQU4sRUFBaUJDLEtBQWpCLENBQXVCSCxTQUF2QixDQUFWOztJQUVBakMsS0FBa0IsQ0FBQ3FDLGFBQW5CLEdBQW1DLFVBQVV2RCxFQUFWLEVBQWM7TUFDL0MsT0FBT3FELGlCQUFTLENBQUNuRCxJQUFWLENBQWVGLEVBQWYsQ0FBUDtLQURGOztJQUlBLENBQUNQLGNBQUEsR0FBaUIsVUFBVWlDLENBQVYsRUFBYXpCLEdBQWIsRUFBa0JxQixHQUFsQixFQUF1QmtDLElBQXZCLEVBQTZCO01BQzdDLElBQUlDLFVBQVUsR0FBRyxPQUFPbkMsR0FBUCxJQUFjLFVBQS9CO01BQ0EsSUFBSW1DLFVBQUosRUFBZ0JDLElBQUcsQ0FBQ3BDLEdBQUQsRUFBTSxNQUFOLENBQUgsSUFBb0JxQyxLQUFJLENBQUNyQyxHQUFELEVBQU0sTUFBTixFQUFjckIsR0FBZCxDQUF4QjtNQUNoQixJQUFJeUIsQ0FBQyxDQUFDekIsR0FBRCxDQUFELEtBQVdxQixHQUFmLEVBQW9CO01BQ3BCLElBQUltQyxVQUFKLEVBQWdCQyxJQUFHLENBQUNwQyxHQUFELEVBQU00QixHQUFOLENBQUgsSUFBaUJTLEtBQUksQ0FBQ3JDLEdBQUQsRUFBTTRCLEdBQU4sRUFBV3hCLENBQUMsQ0FBQ3pCLEdBQUQsQ0FBRCxHQUFTLEtBQUt5QixDQUFDLENBQUN6QixHQUFELENBQWYsR0FBdUJtRCxHQUFHLENBQUNRLElBQUosQ0FBU0MsTUFBTSxDQUFDNUQsR0FBRCxDQUFmLENBQWxDLENBQXJCOztNQUNoQixJQUFJeUIsQ0FBQyxLQUFLbEMsT0FBVixFQUFrQjtRQUNoQmtDLENBQUMsQ0FBQ3pCLEdBQUQsQ0FBRCxHQUFTcUIsR0FBVDtPQURGLE1BRU8sSUFBSSxDQUFDa0MsSUFBTCxFQUFXO1FBQ2hCLE9BQU85QixDQUFDLENBQUN6QixHQUFELENBQVI7UUFDQTBELEtBQUksQ0FBQ2pDLENBQUQsRUFBSXpCLEdBQUosRUFBU3FCLEdBQVQsQ0FBSjtPQUZLLE1BR0EsSUFBSUksQ0FBQyxDQUFDekIsR0FBRCxDQUFMLEVBQVk7UUFDakJ5QixDQUFDLENBQUN6QixHQUFELENBQUQsR0FBU3FCLEdBQVQ7T0FESyxNQUVBO1FBQ0xxQyxLQUFJLENBQUNqQyxDQUFELEVBQUl6QixHQUFKLEVBQVNxQixHQUFULENBQUo7T0FiMkM7O0tBQS9DLEVBZ0JHekIsUUFBUSxDQUFDaUUsU0FoQlosRUFnQnVCWCxTQWhCdkIsRUFnQmtDLFNBQVM1QixRQUFULEdBQW9CO01BQ3BELE9BQU8sT0FBTyxJQUFQLElBQWUsVUFBZixJQUE2QixLQUFLMkIsR0FBTCxDQUE3QixJQUEwQ0csaUJBQVMsQ0FBQ25ELElBQVYsQ0FBZSxJQUFmLENBQWpEO0tBakJGOzs7RUNaQSxjQUFjLEdBQUcsbUJBQUEsQ0FBVUYsRUFBVixFQUFjO0lBQzdCLElBQUksT0FBT0EsRUFBUCxJQUFhLFVBQWpCLEVBQTZCLE1BQU1jLFNBQVMsQ0FBQ2QsRUFBRSxHQUFHLHFCQUFOLENBQWY7SUFDN0IsT0FBT0EsRUFBUDtFQUNELENBSEQ7O0VDRUEsUUFBYyxHQUFHLGFBQUEsQ0FBVXFCLEVBQVYsRUFBYzBDLElBQWQsRUFBb0JDLE1BQXBCLEVBQTRCO0lBQzNDQyxVQUFTLENBQUM1QyxFQUFELENBQVQ7SUFDQSxJQUFJMEMsSUFBSSxLQUFLbkIsU0FBYixFQUF3QixPQUFPdkIsRUFBUDs7SUFDeEIsUUFBUTJDLE1BQVI7TUFDRSxLQUFLLENBQUw7UUFBUSxPQUFPLFVBQVV2RCxDQUFWLEVBQWE7VUFDMUIsT0FBT1ksRUFBRSxDQUFDbkIsSUFBSCxDQUFRNkQsSUFBUixFQUFjdEQsQ0FBZCxDQUFQO1NBRE07O01BR1IsS0FBSyxDQUFMO1FBQVEsT0FBTyxVQUFVQSxDQUFWLEVBQWF5RCxDQUFiLEVBQWdCO1VBQzdCLE9BQU83QyxFQUFFLENBQUNuQixJQUFILENBQVE2RCxJQUFSLEVBQWN0RCxDQUFkLEVBQWlCeUQsQ0FBakIsQ0FBUDtTQURNOztNQUdSLEtBQUssQ0FBTDtRQUFRLE9BQU8sVUFBVXpELENBQVYsRUFBYXlELENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CO1VBQ2hDLE9BQU85QyxFQUFFLENBQUNuQixJQUFILENBQVE2RCxJQUFSLEVBQWN0RCxDQUFkLEVBQWlCeUQsQ0FBakIsRUFBb0JDLENBQXBCLENBQVA7U0FETTs7O0lBSVYsT0FBTzs7T0FBeUI7TUFDOUIsT0FBTzlDLEVBQUUsQ0FBQytDLEtBQUgsQ0FBU0wsSUFBVCxFQUFlTSxTQUFmLENBQVA7S0FERjtFQUdELENBakJEOztFQ0dBLElBQUlDLFNBQVMsR0FBRyxXQUFoQjs7RUFFQSxJQUFJQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVQyxJQUFWLEVBQWdCQyxJQUFoQixFQUFzQkMsTUFBdEIsRUFBOEI7SUFDMUMsSUFBSUMsU0FBUyxHQUFHSCxJQUFJLEdBQUdELE9BQU8sQ0FBQ0ssQ0FBL0I7SUFDQSxJQUFJQyxTQUFTLEdBQUdMLElBQUksR0FBR0QsT0FBTyxDQUFDTyxDQUEvQjtJQUNBLElBQUlDLFNBQVMsR0FBR1AsSUFBSSxHQUFHRCxPQUFPLENBQUNuRCxDQUEvQjtJQUNBLElBQUk0RCxRQUFRLEdBQUdSLElBQUksR0FBR0QsT0FBTyxDQUFDNUMsQ0FBOUI7SUFDQSxJQUFJc0QsT0FBTyxHQUFHVCxJQUFJLEdBQUdELE9BQU8sQ0FBQ1csQ0FBN0I7SUFDQSxJQUFJQyxNQUFNLEdBQUdOLFNBQVMsR0FBR3JGLE9BQUgsR0FBWXVGLFNBQVMsR0FBR3ZGLE9BQU0sQ0FBQ2lGLElBQUQsQ0FBTixLQUFpQmpGLE9BQU0sQ0FBQ2lGLElBQUQsQ0FBTixHQUFlLEVBQWhDLENBQUgsR0FBeUMsQ0FBQ2pGLE9BQU0sQ0FBQ2lGLElBQUQsQ0FBTixJQUFnQixFQUFqQixFQUFxQkgsU0FBckIsQ0FBcEY7SUFDQSxJQUFJYyxPQUFPLEdBQUdQLFNBQVMsR0FBR25FLEtBQUgsR0FBVUEsS0FBSSxDQUFDK0QsSUFBRCxDQUFKLEtBQWUvRCxLQUFJLENBQUMrRCxJQUFELENBQUosR0FBYSxFQUE1QixDQUFqQztJQUNBLElBQUlZLFFBQVEsR0FBR0QsT0FBTyxDQUFDZCxTQUFELENBQVAsS0FBdUJjLE9BQU8sQ0FBQ2QsU0FBRCxDQUFQLEdBQXFCLEVBQTVDLENBQWY7SUFDQSxJQUFJckUsR0FBSixFQUFTcUYsR0FBVCxFQUFjQyxHQUFkLEVBQW1CQyxHQUFuQjtJQUNBLElBQUlYLFNBQUosRUFBZUgsTUFBTSxHQUFHRCxJQUFUOztJQUNmLEtBQUt4RSxHQUFMLElBQVl5RSxNQUFaLEVBQW9COztNQUVsQlksR0FBRyxHQUFHLENBQUNYLFNBQUQsSUFBY1EsTUFBZCxJQUF3QkEsTUFBTSxDQUFDbEYsR0FBRCxDQUFOLEtBQWdCMkMsU0FBOUMsQ0FGa0I7O01BSWxCMkMsR0FBRyxHQUFHLENBQUNELEdBQUcsR0FBR0gsTUFBSCxHQUFZVCxNQUFoQixFQUF3QnpFLEdBQXhCLENBQU4sQ0FKa0I7O01BTWxCdUYsR0FBRyxHQUFHUCxPQUFPLElBQUlLLEdBQVgsR0FBaUJHLElBQUcsQ0FBQ0YsR0FBRCxFQUFNL0YsT0FBTixDQUFwQixHQUFvQ3dGLFFBQVEsSUFBSSxPQUFPTyxHQUFQLElBQWMsVUFBMUIsR0FBdUNFLElBQUcsQ0FBQzVGLFFBQVEsQ0FBQ0ssSUFBVixFQUFnQnFGLEdBQWhCLENBQTFDLEdBQWlFQSxHQUEzRyxDQU5rQjs7TUFRbEIsSUFBSUosTUFBSixFQUFZTyxTQUFRLENBQUNQLE1BQUQsRUFBU2xGLEdBQVQsRUFBY3NGLEdBQWQsRUFBbUJmLElBQUksR0FBR0QsT0FBTyxDQUFDb0IsQ0FBbEMsQ0FBUixDQVJNOztNQVVsQixJQUFJUCxPQUFPLENBQUNuRixHQUFELENBQVAsSUFBZ0JzRixHQUFwQixFQUF5QjVCLEtBQUksQ0FBQ3lCLE9BQUQsRUFBVW5GLEdBQVYsRUFBZXVGLEdBQWYsQ0FBSjtNQUN6QixJQUFJUixRQUFRLElBQUlLLFFBQVEsQ0FBQ3BGLEdBQUQsQ0FBUixJQUFpQnNGLEdBQWpDLEVBQXNDRixRQUFRLENBQUNwRixHQUFELENBQVIsR0FBZ0JzRixHQUFoQjs7RUFFekMsQ0F4QkQ7O0FBeUJBL0YsU0FBTSxDQUFDa0IsSUFBUCxHQUFjQSxLQUFkOztFQUVBNkQsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBWjs7RUFDQUwsT0FBTyxDQUFDTyxDQUFSLEdBQVksQ0FBWjs7RUFDQVAsT0FBTyxDQUFDbkQsQ0FBUixHQUFZLENBQVo7O0VBQ0FtRCxPQUFPLENBQUM1QyxDQUFSLEdBQVksQ0FBWjs7RUFDQTRDLE9BQU8sQ0FBQ1csQ0FBUixHQUFZLEVBQVo7O0VBQ0FYLE9BQU8sQ0FBQ3FCLENBQVIsR0FBWSxFQUFaOztFQUNBckIsT0FBTyxDQUFDb0IsQ0FBUixHQUFZLEVBQVo7O0VBQ0FwQixPQUFPLENBQUNzQixDQUFSLEdBQVksR0FBWjs7RUFDQSxXQUFjLEdBQUd0QixPQUFqQjs7O0lDMUNBLElBQUl1QixJQUFJLEdBQUd6RixJQUFpQixDQUFDLE1BQUQsQ0FBNUI7SUFHQSxJQUFJMEYsT0FBTyxHQUFHN0UsU0FBdUIsQ0FBQ29CLENBQXRDO0lBQ0EsSUFBSUUsRUFBRSxHQUFHLENBQVQ7O0lBQ0EsSUFBSXdELFlBQVksR0FBRzFGLE1BQU0sQ0FBQzBGLFlBQVAsSUFBdUIsWUFBWTtNQUNwRCxPQUFPLElBQVA7S0FERjs7SUFHQSxJQUFJQyxNQUFNLEdBQUcsQ0FBQzlFLE1BQW1CLENBQUMsWUFBWTtNQUM1QyxPQUFPNkUsWUFBWSxDQUFDMUYsTUFBTSxDQUFDNEYsaUJBQVAsQ0FBeUIsRUFBekIsQ0FBRCxDQUFuQjtLQUQrQixDQUFqQzs7SUFHQSxJQUFJQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVbkcsRUFBVixFQUFjO01BQzFCK0YsT0FBTyxDQUFDL0YsRUFBRCxFQUFLOEYsSUFBTCxFQUFXO1FBQUU5RCxLQUFLLEVBQUU7VUFDekJvRSxDQUFDLEVBQUUsTUFBTSxFQUFFNUQsRUFEYzs7VUFFekI2RCxDQUFDLEVBQUUsRUFGc0I7OztPQUFwQixDQUFQO0tBREY7O0lBTUEsSUFBSUMsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVXRHLEVBQVYsRUFBY3VHLE1BQWQsRUFBc0I7O01BRWxDLElBQUksQ0FBQzFGLFNBQVEsQ0FBQ2IsRUFBRCxDQUFiLEVBQW1CLE9BQU8sT0FBT0EsRUFBUCxJQUFhLFFBQWIsR0FBd0JBLEVBQXhCLEdBQTZCLENBQUMsT0FBT0EsRUFBUCxJQUFhLFFBQWIsR0FBd0IsR0FBeEIsR0FBOEIsR0FBL0IsSUFBc0NBLEVBQTFFOztNQUNuQixJQUFJLENBQUMwRCxJQUFHLENBQUMxRCxFQUFELEVBQUs4RixJQUFMLENBQVIsRUFBb0I7O1FBRWxCLElBQUksQ0FBQ0UsWUFBWSxDQUFDaEcsRUFBRCxDQUFqQixFQUF1QixPQUFPLEdBQVAsQ0FGTDs7UUFJbEIsSUFBSSxDQUFDdUcsTUFBTCxFQUFhLE9BQU8sR0FBUCxDQUpLOztRQU1sQkosT0FBTyxDQUFDbkcsRUFBRCxDQUFQLENBTmtCOzs7TUFRbEIsT0FBT0EsRUFBRSxDQUFDOEYsSUFBRCxDQUFGLENBQVNNLENBQWhCO0tBWEo7O0lBYUEsSUFBSUksT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVXhHLEVBQVYsRUFBY3VHLE1BQWQsRUFBc0I7TUFDbEMsSUFBSSxDQUFDN0MsSUFBRyxDQUFDMUQsRUFBRCxFQUFLOEYsSUFBTCxDQUFSLEVBQW9COztRQUVsQixJQUFJLENBQUNFLFlBQVksQ0FBQ2hHLEVBQUQsQ0FBakIsRUFBdUIsT0FBTyxJQUFQLENBRkw7O1FBSWxCLElBQUksQ0FBQ3VHLE1BQUwsRUFBYSxPQUFPLEtBQVAsQ0FKSzs7UUFNbEJKLE9BQU8sQ0FBQ25HLEVBQUQsQ0FBUCxDQU5rQjs7O01BUWxCLE9BQU9BLEVBQUUsQ0FBQzhGLElBQUQsQ0FBRixDQUFTTyxDQUFoQjtLQVRKOzs7SUFZQSxJQUFJSSxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVekcsRUFBVixFQUFjO01BQzNCLElBQUlpRyxNQUFNLElBQUlTLElBQUksQ0FBQ0MsSUFBZixJQUF1QlgsWUFBWSxDQUFDaEcsRUFBRCxDQUFuQyxJQUEyQyxDQUFDMEQsSUFBRyxDQUFDMUQsRUFBRCxFQUFLOEYsSUFBTCxDQUFuRCxFQUErREssT0FBTyxDQUFDbkcsRUFBRCxDQUFQO01BQy9ELE9BQU9BLEVBQVA7S0FGRjs7SUFJQSxJQUFJMEcsSUFBSSxHQUFHakgsY0FBQSxHQUFpQjtNQUMxQm1ILEdBQUcsRUFBRWQsSUFEcUI7TUFFMUJhLElBQUksRUFBRSxLQUZvQjtNQUcxQkwsT0FBTyxFQUFFQSxPQUhpQjtNQUkxQkUsT0FBTyxFQUFFQSxPQUppQjtNQUsxQkMsUUFBUSxFQUFFQTtLQUxaOzs7O0lDOUNBLElBQUkzRCxLQUFLLEdBQUd6QyxPQUFvQixDQUFDLEtBQUQsQ0FBaEM7SUFFQSxJQUFJd0csTUFBTSxHQUFHM0YsT0FBb0IsQ0FBQzJGLE1BQWxDO0lBQ0EsSUFBSUMsVUFBVSxHQUFHLE9BQU9ELE1BQVAsSUFBaUIsVUFBbEM7O0lBRUEsSUFBSUUsUUFBUSxHQUFHdEgsY0FBQSxHQUFpQixVQUFVZ0YsSUFBVixFQUFnQjtNQUM5QyxPQUFPM0IsS0FBSyxDQUFDMkIsSUFBRCxDQUFMLEtBQWdCM0IsS0FBSyxDQUFDMkIsSUFBRCxDQUFMLEdBQ3JCcUMsVUFBVSxJQUFJRCxNQUFNLENBQUNwQyxJQUFELENBQXBCLElBQThCLENBQUNxQyxVQUFVLEdBQUdELE1BQUgsR0FBWUcsSUFBdkIsRUFBNEIsWUFBWXZDLElBQXhDLENBRHpCLENBQVA7S0FERjs7SUFLQXNDLFFBQVEsQ0FBQ2pFLEtBQVQsR0FBaUJBLEtBQWpCOzs7RUNWQSxJQUFJbUUsR0FBRyxHQUFHNUcsU0FBdUIsQ0FBQ2lDLENBQWxDO0VBRUEsSUFBSTRFLEdBQUcsR0FBR2hHLElBQWlCLENBQUMsYUFBRCxDQUEzQjs7RUFFQSxtQkFBYyxHQUFHLHdCQUFBLENBQVVsQixFQUFWLEVBQWNtSCxHQUFkLEVBQW1CQyxJQUFuQixFQUF5QjtJQUN4QyxJQUFJcEgsRUFBRSxJQUFJLENBQUMwRCxJQUFHLENBQUMxRCxFQUFFLEdBQUdvSCxJQUFJLEdBQUdwSCxFQUFILEdBQVFBLEVBQUUsQ0FBQzhELFNBQXJCLEVBQWdDb0QsR0FBaEMsQ0FBZCxFQUFvREQsR0FBRyxDQUFDakgsRUFBRCxFQUFLa0gsR0FBTCxFQUFVO01BQUUvRSxZQUFZLEVBQUUsSUFBaEI7TUFBc0JILEtBQUssRUFBRW1GO0tBQXZDLENBQUg7RUFDckQsQ0FGRDs7RUNKQSxPQUFTLEdBQUc5RyxJQUFaOzs7OztFQ0lBLElBQUlFLGNBQWMsR0FBR0YsU0FBdUIsQ0FBQ2lDLENBQTdDOztFQUNBLGNBQWMsR0FBRyxtQkFBQSxDQUFVbUMsSUFBVixFQUFnQjtJQUMvQixJQUFJNEMsT0FBTyxHQUFHM0csS0FBSSxDQUFDbUcsTUFBTCxLQUFnQm5HLEtBQUksQ0FBQ21HLE1BQUwsR0FBY1MsQ0FBZTlILE9BQU0sQ0FBQ3FILE1BQVAsSUFBaUIsRUFBOUQsQ0FBZDtJQUNBLElBQUlwQyxJQUFJLENBQUM4QyxNQUFMLENBQVksQ0FBWixLQUFrQixHQUFsQixJQUF5QixFQUFFOUMsSUFBSSxJQUFJNEMsT0FBVixDQUE3QixFQUFpRDlHLGNBQWMsQ0FBQzhHLE9BQUQsRUFBVTVDLElBQVYsRUFBZ0I7TUFBRXpDLEtBQUssRUFBRXdGLE9BQU0sQ0FBQ2xGLENBQVAsQ0FBU21DLElBQVQ7S0FBekIsQ0FBZDtFQUNsRCxDQUhEOztFQ0xBLElBQUlsRCxRQUFRLEdBQUcsR0FBR0EsUUFBbEI7O0VBRUEsUUFBYyxHQUFHLGFBQUEsQ0FBVXZCLEVBQVYsRUFBYztJQUM3QixPQUFPdUIsUUFBUSxDQUFDckIsSUFBVCxDQUFjRixFQUFkLEVBQWtCeUgsS0FBbEIsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBQyxDQUE1QixDQUFQO0VBQ0QsQ0FGRDs7RUNBQTs7RUFDQSxZQUFjLEdBQUduSCxNQUFNLENBQUMsR0FBRCxDQUFOLENBQVlvSCxvQkFBWixDQUFpQyxDQUFqQyxJQUFzQ3BILE1BQXRDLEdBQStDLFVBQVVOLEVBQVYsRUFBYztJQUM1RSxPQUFPMkgsSUFBRyxDQUFDM0gsRUFBRCxDQUFILElBQVcsUUFBWCxHQUFzQkEsRUFBRSxDQUFDc0QsS0FBSCxDQUFTLEVBQVQsQ0FBdEIsR0FBcUNoRCxNQUFNLENBQUNOLEVBQUQsQ0FBbEQ7RUFDRCxDQUZEOztFQ0hBO0VBQ0EsWUFBYyxHQUFHLGlCQUFBLENBQVVBLEVBQVYsRUFBYztJQUM3QixJQUFJQSxFQUFFLElBQUk0QyxTQUFWLEVBQXFCLE1BQU05QixTQUFTLENBQUMsMkJBQTJCZCxFQUE1QixDQUFmO0lBQ3JCLE9BQU9BLEVBQVA7RUFDRCxDQUhEOztFQ0VBLGNBQWMsR0FBRyxtQkFBQSxDQUFVQSxFQUFWLEVBQWM7SUFDN0IsT0FBTzRILFFBQU8sQ0FBQ0MsUUFBTyxDQUFDN0gsRUFBRCxDQUFSLENBQWQ7RUFDRCxDQUZEOztFQ0hBO0VBQ0EsSUFBSThILElBQUksR0FBR25JLElBQUksQ0FBQ21JLElBQWhCO0VBQ0EsSUFBSUMsS0FBSyxHQUFHcEksSUFBSSxDQUFDb0ksS0FBakI7O0VBQ0EsY0FBYyxHQUFHLG1CQUFBLENBQVUvSCxFQUFWLEVBQWM7SUFDN0IsT0FBT2dJLEtBQUssQ0FBQ2hJLEVBQUUsR0FBRyxDQUFDQSxFQUFQLENBQUwsR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBQ0EsRUFBRSxHQUFHLENBQUwsR0FBUytILEtBQVQsR0FBaUJELElBQWxCLEVBQXdCOUgsRUFBeEIsQ0FBN0I7RUFDRCxDQUZEOztFQ0RBLElBQUlpSSxHQUFHLEdBQUd0SSxJQUFJLENBQUNzSSxHQUFmOztFQUNBLGFBQWMsR0FBRyxrQkFBQSxDQUFVakksRUFBVixFQUFjO0lBQzdCLE9BQU9BLEVBQUUsR0FBRyxDQUFMLEdBQVNpSSxHQUFHLENBQUNDLFVBQVMsQ0FBQ2xJLEVBQUQsQ0FBVixFQUFnQixnQkFBaEIsQ0FBWixHQUFnRCxDQUF2RCxDQUQ2QjtFQUU5QixDQUZEOztFQ0ZBLElBQUltSSxHQUFHLEdBQUd4SSxJQUFJLENBQUN3SSxHQUFmO0VBQ0EsSUFBSUYsS0FBRyxHQUFHdEksSUFBSSxDQUFDc0ksR0FBZjs7RUFDQSxvQkFBYyxHQUFHLHlCQUFBLENBQVVHLEtBQVYsRUFBaUJwRSxNQUFqQixFQUF5QjtJQUN4Q29FLEtBQUssR0FBR0YsVUFBUyxDQUFDRSxLQUFELENBQWpCO0lBQ0EsT0FBT0EsS0FBSyxHQUFHLENBQVIsR0FBWUQsR0FBRyxDQUFDQyxLQUFLLEdBQUdwRSxNQUFULEVBQWlCLENBQWpCLENBQWYsR0FBcUNpRSxLQUFHLENBQUNHLEtBQUQsRUFBUXBFLE1BQVIsQ0FBL0M7RUFDRCxDQUhEOztFQ0ZBOztFQUlBLGtCQUFjLEdBQUcsdUJBQUEsQ0FBVXFFLFdBQVYsRUFBdUI7SUFDdEMsT0FBTyxVQUFVQyxLQUFWLEVBQWlCQyxFQUFqQixFQUFxQkMsU0FBckIsRUFBZ0M7TUFDckMsSUFBSTlHLENBQUMsR0FBRytHLFVBQVMsQ0FBQ0gsS0FBRCxDQUFqQjtNQUNBLElBQUl0RSxNQUFNLEdBQUcwRSxTQUFRLENBQUNoSCxDQUFDLENBQUNzQyxNQUFILENBQXJCO01BQ0EsSUFBSW9FLEtBQUssR0FBR08sZ0JBQWUsQ0FBQ0gsU0FBRCxFQUFZeEUsTUFBWixDQUEzQjtNQUNBLElBQUloQyxLQUFKLENBSnFDOzs7TUFPckMsSUFBSXFHLFdBQVcsSUFBSUUsRUFBRSxJQUFJQSxFQUF6QixFQUE2QixPQUFPdkUsTUFBTSxHQUFHb0UsS0FBaEIsRUFBdUI7UUFDbERwRyxLQUFLLEdBQUdOLENBQUMsQ0FBQzBHLEtBQUssRUFBTixDQUFULENBRGtEOztRQUdsRCxJQUFJcEcsS0FBSyxJQUFJQSxLQUFiLEVBQW9CLE9BQU8sSUFBUCxDQUg4QjtPQUFwRCxNQUtPLE9BQU1nQyxNQUFNLEdBQUdvRSxLQUFmLEVBQXNCQSxLQUFLLEVBQTNCO1FBQStCLElBQUlDLFdBQVcsSUFBSUQsS0FBSyxJQUFJMUcsQ0FBNUIsRUFBK0I7VUFDbkUsSUFBSUEsQ0FBQyxDQUFDMEcsS0FBRCxDQUFELEtBQWFHLEVBQWpCLEVBQXFCLE9BQU9GLFdBQVcsSUFBSUQsS0FBZixJQUF3QixDQUEvQjs7O01BQ3JCLE9BQU8sQ0FBQ0MsV0FBRCxJQUFnQixDQUFDLENBQXhCO0tBZEo7RUFnQkQsQ0FqQkQ7O0VDTEEsSUFBSU8sTUFBTSxHQUFHdkksT0FBb0IsQ0FBQyxNQUFELENBQWpDOztFQUVBLGNBQWMsR0FBRyxtQkFBQSxDQUFVSixHQUFWLEVBQWU7SUFDOUIsT0FBTzJJLE1BQU0sQ0FBQzNJLEdBQUQsQ0FBTixLQUFnQjJJLE1BQU0sQ0FBQzNJLEdBQUQsQ0FBTixHQUFjK0csSUFBRyxDQUFDL0csR0FBRCxDQUFqQyxDQUFQO0VBQ0QsQ0FGRDs7RUNBQSxJQUFJNEksWUFBWSxHQUFHeEksY0FBNEIsQ0FBQyxLQUFELENBQS9DO0VBQ0EsSUFBSXlJLFFBQVEsR0FBRzVILFVBQXdCLENBQUMsVUFBRCxDQUF2Qzs7RUFFQSx1QkFBYyxHQUFHLDRCQUFBLENBQVVtQixNQUFWLEVBQWtCMEcsS0FBbEIsRUFBeUI7SUFDeEMsSUFBSXJILENBQUMsR0FBRytHLFVBQVMsQ0FBQ3BHLE1BQUQsQ0FBakI7SUFDQSxJQUFJK0QsQ0FBQyxHQUFHLENBQVI7SUFDQSxJQUFJNEMsTUFBTSxHQUFHLEVBQWI7SUFDQSxJQUFJL0ksR0FBSjs7SUFDQSxLQUFLQSxHQUFMLElBQVl5QixDQUFaO01BQWUsSUFBSXpCLEdBQUcsSUFBSTZJLFFBQVgsRUFBcUJwRixJQUFHLENBQUNoQyxDQUFELEVBQUl6QixHQUFKLENBQUgsSUFBZStJLE1BQU0sQ0FBQ2pHLElBQVAsQ0FBWTlDLEdBQVosQ0FBZjtLQUxJOzs7SUFPeEMsT0FBTzhJLEtBQUssQ0FBQy9FLE1BQU4sR0FBZW9DLENBQXRCO01BQXlCLElBQUkxQyxJQUFHLENBQUNoQyxDQUFELEVBQUl6QixHQUFHLEdBQUc4SSxLQUFLLENBQUMzQyxDQUFDLEVBQUYsQ0FBZixDQUFQLEVBQThCO1FBQ3JELENBQUN5QyxZQUFZLENBQUNHLE1BQUQsRUFBUy9JLEdBQVQsQ0FBYixJQUE4QitJLE1BQU0sQ0FBQ2pHLElBQVAsQ0FBWTlDLEdBQVosQ0FBOUI7Ozs7SUFFRixPQUFPK0ksTUFBUDtFQUNELENBWEQ7O0VDTEE7RUFDQSxnQkFBYyxHQUNaLCtGQURlLENBRWYxRixLQUZlLENBRVQsR0FGUyxDQUFqQjs7RUNHQSxlQUFjLEdBQUdoRCxNQUFNLENBQUMySSxJQUFQLElBQWUsU0FBU0EsSUFBVCxDQUFjdkgsQ0FBZCxFQUFpQjtJQUMvQyxPQUFPd0gsbUJBQUssQ0FBQ3hILENBQUQsRUFBSXlILFlBQUosQ0FBWjtFQUNELENBRkQ7O0VDSkEsT0FBUyxHQUFHN0ksTUFBTSxDQUFDOEkscUJBQW5COzs7OztFQ0FBLE9BQVMsR0FBRyxHQUFHMUIsb0JBQWY7Ozs7O0VDSUEsYUFBYyxHQUFHLGtCQUFBLENBQVUxSCxFQUFWLEVBQWM7SUFDN0IsSUFBSWdKLE1BQU0sR0FBR0ssV0FBTyxDQUFDckosRUFBRCxDQUFwQjtJQUNBLElBQUlzSixVQUFVLEdBQUdDLFdBQUksQ0FBQ2pILENBQXRCOztJQUNBLElBQUlnSCxVQUFKLEVBQWdCO01BQ2QsSUFBSUUsT0FBTyxHQUFHRixVQUFVLENBQUN0SixFQUFELENBQXhCO01BQ0EsSUFBSXlKLE1BQU0sR0FBR0MsVUFBRyxDQUFDcEgsQ0FBakI7TUFDQSxJQUFJOEQsQ0FBQyxHQUFHLENBQVI7TUFDQSxJQUFJbkcsR0FBSjs7TUFDQSxPQUFPdUosT0FBTyxDQUFDeEYsTUFBUixHQUFpQm9DLENBQXhCO1FBQTJCLElBQUlxRCxNQUFNLENBQUN2SixJQUFQLENBQVlGLEVBQVosRUFBZ0JDLEdBQUcsR0FBR3VKLE9BQU8sQ0FBQ3BELENBQUMsRUFBRixDQUE3QixDQUFKLEVBQXlDNEMsTUFBTSxDQUFDakcsSUFBUCxDQUFZOUMsR0FBWjs7OztJQUNwRSxPQUFPK0ksTUFBUDtFQUNILENBVkQ7O0VDRkEsWUFBYyxHQUFHVyxLQUFLLENBQUNDLE9BQU4sSUFBaUIsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7SUFDdEQsT0FBT2xDLElBQUcsQ0FBQ2tDLEdBQUQsQ0FBSCxJQUFZLE9BQW5CO0VBQ0QsQ0FGRDs7RUNBQSxhQUFjLEdBQUcsa0JBQUEsQ0FBVTdKLEVBQVYsRUFBYztJQUM3QixPQUFPTSxNQUFNLENBQUN1SCxRQUFPLENBQUM3SCxFQUFELENBQVIsQ0FBYjtFQUNELENBRkQ7O0VDRUEsY0FBYyxHQUFHSyxZQUF5QixHQUFHQyxNQUFNLENBQUN3SixnQkFBVixHQUE2QixTQUFTQSxnQkFBVCxDQUEwQnBJLENBQTFCLEVBQTZCcUksVUFBN0IsRUFBeUM7SUFDOUdsSSxTQUFRLENBQUNILENBQUQsQ0FBUjtJQUNBLElBQUl1SCxJQUFJLEdBQUdJLFdBQU8sQ0FBQ1UsVUFBRCxDQUFsQjtJQUNBLElBQUkvRixNQUFNLEdBQUdpRixJQUFJLENBQUNqRixNQUFsQjtJQUNBLElBQUlvQyxDQUFDLEdBQUcsQ0FBUjtJQUNBLElBQUl6RSxDQUFKOztJQUNBLE9BQU9xQyxNQUFNLEdBQUdvQyxDQUFoQjtNQUFtQjNFLFNBQUUsQ0FBQ2EsQ0FBSCxDQUFLWixDQUFMLEVBQVFDLENBQUMsR0FBR3NILElBQUksQ0FBQzdDLENBQUMsRUFBRixDQUFoQixFQUF1QjJELFVBQVUsQ0FBQ3BJLENBQUQsQ0FBakM7OztJQUNuQixPQUFPRCxDQUFQO0VBQ0QsQ0FSRDs7RUNKQSxJQUFJWCxVQUFRLEdBQUdWLE9BQW9CLENBQUNVLFFBQXBDOztFQUNBLFNBQWMsR0FBR0EsVUFBUSxJQUFJQSxVQUFRLENBQUNpSixlQUF0Qzs7RUNHQSxJQUFJbEIsVUFBUSxHQUFHekksVUFBd0IsQ0FBQyxVQUFELENBQXZDOztFQUNBLElBQUk0SixLQUFLLEdBQUcsU0FBUkEsS0FBUSxHQUFZOztFQUFlLENBQXZDOztFQUNBLElBQUkzRixXQUFTLEdBQUcsV0FBaEI7O0VBR0EsSUFBSTRGLFdBQVUsR0FBRyxzQkFBWTs7SUFFM0IsSUFBSUMsTUFBTSxHQUFHakosVUFBd0IsQ0FBQyxRQUFELENBQXJDO0lBQ0EsSUFBSWtGLENBQUMsR0FBRytDLFlBQVcsQ0FBQ25GLE1BQXBCO0lBQ0EsSUFBSW9HLEVBQUUsR0FBRyxHQUFUO0lBQ0EsSUFBSUMsRUFBRSxHQUFHLEdBQVQ7SUFDQSxJQUFJQyxjQUFKO0lBQ0FILE1BQU0sQ0FBQ0ksS0FBUCxDQUFhQyxPQUFiLEdBQXVCLE1BQXZCO0lBQ0FySixLQUFrQixDQUFDc0osV0FBbkIsQ0FBK0JOLE1BQS9CO0lBQ0FBLE1BQU0sQ0FBQ08sR0FBUCxHQUFhLGFBQWIsQ0FUMkI7Ozs7SUFZM0JKLGNBQWMsR0FBR0gsTUFBTSxDQUFDUSxhQUFQLENBQXFCNUosUUFBdEM7SUFDQXVKLGNBQWMsQ0FBQ00sSUFBZjtJQUNBTixjQUFjLENBQUNPLEtBQWYsQ0FBcUJULEVBQUUsR0FBRyxRQUFMLEdBQWdCQyxFQUFoQixHQUFxQixtQkFBckIsR0FBMkNELEVBQTNDLEdBQWdELFNBQWhELEdBQTREQyxFQUFqRjtJQUNBQyxjQUFjLENBQUNRLEtBQWY7SUFDQVosV0FBVSxHQUFHSSxjQUFjLENBQUMxRixDQUE1Qjs7SUFDQSxPQUFPd0IsQ0FBQyxFQUFSO01BQVksT0FBTzhELFdBQVUsQ0FBQzVGLFdBQUQsQ0FBVixDQUFzQjZFLFlBQVcsQ0FBQy9DLENBQUQsQ0FBakMsQ0FBUDs7O0lBQ1osT0FBTzhELFdBQVUsRUFBakI7RUFDRCxDQW5CRDs7RUFxQkEsaUJBQWMsR0FBRzVKLE1BQU0sQ0FBQ2lHLE1BQVAsSUFBaUIsU0FBU0EsTUFBVCxDQUFnQjdFLENBQWhCLEVBQW1CcUksVUFBbkIsRUFBK0I7SUFDL0QsSUFBSWYsTUFBSjs7SUFDQSxJQUFJdEgsQ0FBQyxLQUFLLElBQVYsRUFBZ0I7TUFDZHVJLEtBQUssQ0FBQzNGLFdBQUQsQ0FBTCxHQUFtQnpDLFNBQVEsQ0FBQ0gsQ0FBRCxDQUEzQjtNQUNBc0gsTUFBTSxHQUFHLElBQUlpQixLQUFKLEVBQVQ7TUFDQUEsS0FBSyxDQUFDM0YsV0FBRCxDQUFMLEdBQW1CLElBQW5CLENBSGM7O01BS2QwRSxNQUFNLENBQUNGLFVBQUQsQ0FBTixHQUFtQnBILENBQW5CO0tBTEYsTUFNT3NILE1BQU0sR0FBR2tCLFdBQVUsRUFBbkI7O0lBQ1AsT0FBT0gsVUFBVSxLQUFLbkgsU0FBZixHQUEyQm9HLE1BQTNCLEdBQW9DK0IsVUFBRyxDQUFDL0IsTUFBRCxFQUFTZSxVQUFULENBQTlDO0VBQ0QsQ0FWRDs7RUM1QkEsSUFBSWlCLFVBQVUsR0FBRzNLLFlBQTJCLENBQUNzQyxNQUE1QixDQUFtQyxRQUFuQyxFQUE2QyxXQUE3QyxDQUFqQjs7RUFFQSxPQUFTLEdBQUdyQyxNQUFNLENBQUMySyxtQkFBUCxJQUE4QixTQUFTQSxtQkFBVCxDQUE2QnZKLENBQTdCLEVBQWdDO0lBQ3hFLE9BQU93SCxtQkFBSyxDQUFDeEgsQ0FBRCxFQUFJc0osVUFBSixDQUFaO0VBQ0QsQ0FGRDs7Ozs7O0VDRkEsSUFBSUUsSUFBSSxHQUFHN0ssV0FBeUIsQ0FBQ2lDLENBQXJDO0VBQ0EsSUFBSWYsVUFBUSxHQUFHLEdBQUdBLFFBQWxCO0VBRUEsSUFBSTRKLFdBQVcsR0FBRyxPQUFPekwsTUFBUCxJQUFpQixRQUFqQixJQUE2QkEsTUFBN0IsSUFBdUNZLE1BQU0sQ0FBQzJLLG1CQUE5QyxHQUNkM0ssTUFBTSxDQUFDMkssbUJBQVAsQ0FBMkJ2TCxNQUEzQixDQURjLEdBQ3VCLEVBRHpDOztFQUdBLElBQUkwTCxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQVVwTCxFQUFWLEVBQWM7SUFDakMsSUFBSTtNQUNGLE9BQU9rTCxJQUFJLENBQUNsTCxFQUFELENBQVg7S0FERixDQUVFLE9BQU9JLENBQVAsRUFBVTtNQUNWLE9BQU8rSyxXQUFXLENBQUMxRCxLQUFaLEVBQVA7O0VBRUgsQ0FORDs7RUFRQSxPQUFnQixHQUFHLFNBQVN3RCxtQkFBVCxDQUE2QmpMLEVBQTdCLEVBQWlDO0lBQ2xELE9BQU9tTCxXQUFXLElBQUk1SixVQUFRLENBQUNyQixJQUFULENBQWNGLEVBQWQsS0FBcUIsaUJBQXBDLEdBQXdEb0wsY0FBYyxDQUFDcEwsRUFBRCxDQUF0RSxHQUE2RWtMLElBQUksQ0FBQ3pDLFVBQVMsQ0FBQ3pJLEVBQUQsQ0FBVixDQUF4RjtFQUNELENBRkQ7Ozs7OztFQ1ZBLElBQUlxTCxJQUFJLEdBQUcvSyxNQUFNLENBQUNnTCx3QkFBbEI7RUFFQSxPQUFTLEdBQUdqTCxZQUF5QixHQUFHZ0wsSUFBSCxHQUFVLFNBQVNDLHdCQUFULENBQWtDNUosQ0FBbEMsRUFBcUNDLENBQXJDLEVBQXdDO0lBQ3JGRCxDQUFDLEdBQUcrRyxVQUFTLENBQUMvRyxDQUFELENBQWI7SUFDQUMsQ0FBQyxHQUFHRyxZQUFXLENBQUNILENBQUQsRUFBSSxJQUFKLENBQWY7SUFDQSxJQUFJSSxhQUFKLEVBQW9CLElBQUk7TUFDdEIsT0FBT3NKLElBQUksQ0FBQzNKLENBQUQsRUFBSUMsQ0FBSixDQUFYO0tBRGtCLENBRWxCLE9BQU92QixDQUFQLEVBQVU7OztJQUNaLElBQUlzRCxJQUFHLENBQUNoQyxDQUFELEVBQUlDLENBQUosQ0FBUCxFQUFlLE9BQU9ZLGFBQVUsQ0FBQyxDQUFDbUgsVUFBRyxDQUFDcEgsQ0FBSixDQUFNcEMsSUFBTixDQUFXd0IsQ0FBWCxFQUFjQyxDQUFkLENBQUYsRUFBb0JELENBQUMsQ0FBQ0MsQ0FBRCxDQUFyQixDQUFqQjtFQUNoQixDQVBEOzs7OztFQ0RBLElBQUltRSxJQUFJLEdBQUd6RixLQUFrQixDQUFDdUcsR0FBOUI7RUFzQkEsSUFBSXlFLE1BQUksR0FBR0UsV0FBSyxDQUFDakosQ0FBakI7RUFDQSxJQUFJYixJQUFFLEdBQUcrSixTQUFHLENBQUNsSixDQUFiO0VBQ0EsSUFBSTRJLE1BQUksR0FBR08sY0FBTyxDQUFDbkosQ0FBbkI7RUFDQSxJQUFJK0UsT0FBTyxHQUFHN0gsT0FBTSxDQUFDcUgsTUFBckI7RUFDQSxJQUFJNkUsS0FBSyxHQUFHbE0sT0FBTSxDQUFDbU0sSUFBbkI7O0VBQ0EsSUFBSUMsVUFBVSxHQUFHRixLQUFLLElBQUlBLEtBQUssQ0FBQ0csU0FBaEM7O0VBQ0EsSUFBSXZILFdBQVMsR0FBRyxXQUFoQjtFQUNBLElBQUl3SCxNQUFNLEdBQUdDLElBQUcsQ0FBQyxTQUFELENBQWhCO0VBQ0EsSUFBSUMsWUFBWSxHQUFHRCxJQUFHLENBQUMsYUFBRCxDQUF0QjtFQUNBLElBQUl0QyxNQUFNLEdBQUcsR0FBRy9CLG9CQUFoQjtFQUNBLElBQUl1RSxjQUFjLEdBQUdyRCxPQUFNLENBQUMsaUJBQUQsQ0FBM0I7RUFDQSxJQUFJc0QsVUFBVSxHQUFHdEQsT0FBTSxDQUFDLFNBQUQsQ0FBdkI7RUFDQSxJQUFJdUQsU0FBUyxHQUFHdkQsT0FBTSxDQUFDLFlBQUQsQ0FBdEI7RUFDQSxJQUFJd0QsV0FBVyxHQUFHOUwsTUFBTSxDQUFDZ0UsV0FBRCxDQUF4QjtFQUNBLElBQUkrSCxVQUFVLEdBQUcsT0FBT2hGLE9BQVAsSUFBa0IsVUFBbEIsSUFBZ0MsQ0FBQyxDQUFDaUYsV0FBSyxDQUFDaEssQ0FBekQ7RUFDQSxJQUFJaUssT0FBTyxHQUFHL00sT0FBTSxDQUFDK00sT0FBckI7O0VBRUEsSUFBSUMsTUFBTSxHQUFHLENBQUNELE9BQUQsSUFBWSxDQUFDQSxPQUFPLENBQUNqSSxXQUFELENBQXBCLElBQW1DLENBQUNpSSxPQUFPLENBQUNqSSxXQUFELENBQVAsQ0FBbUJtSSxTQUFwRTs7RUFHQSxJQUFJQyxhQUFhLEdBQUdDLFlBQVcsSUFBSUMsTUFBTSxDQUFDLFlBQVk7SUFDcEQsT0FBT0MsYUFBTyxDQUFDcEwsSUFBRSxDQUFDLEVBQUQsRUFBSyxHQUFMLEVBQVU7TUFDekJqQixHQUFHLEVBQUUsZUFBWTtRQUFFLE9BQU9pQixJQUFFLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWTtVQUFFTyxLQUFLLEVBQUU7U0FBckIsQ0FBRixDQUE0QnZCLENBQW5DOztLQURKLENBQUgsQ0FBUCxDQUVIQSxDQUZHLElBRUUsQ0FGVDtFQUdELENBSndDLENBQXJCLEdBSWYsVUFBVVQsRUFBVixFQUFjQyxHQUFkLEVBQW1CNk0sQ0FBbkIsRUFBc0I7SUFDekIsSUFBSUMsU0FBUyxHQUFHMUIsTUFBSSxDQUFDZSxXQUFELEVBQWNuTSxHQUFkLENBQXBCO0lBQ0EsSUFBSThNLFNBQUosRUFBZSxPQUFPWCxXQUFXLENBQUNuTSxHQUFELENBQWxCO0lBQ2Z3QixJQUFFLENBQUN6QixFQUFELEVBQUtDLEdBQUwsRUFBVTZNLENBQVYsQ0FBRjtJQUNBLElBQUlDLFNBQVMsSUFBSS9NLEVBQUUsS0FBS29NLFdBQXhCLEVBQXFDM0ssSUFBRSxDQUFDMkssV0FBRCxFQUFjbk0sR0FBZCxFQUFtQjhNLFNBQW5CLENBQUY7RUFDdEMsQ0FUbUIsR0FTaEJ0TCxJQVRKOztFQVdBLElBQUl1TCxJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFVN0YsR0FBVixFQUFlO0lBQ3hCLElBQUk4RixHQUFHLEdBQUdmLFVBQVUsQ0FBQy9FLEdBQUQsQ0FBVixHQUFrQjBGLGFBQU8sQ0FBQ3hGLE9BQU8sQ0FBQy9DLFdBQUQsQ0FBUixDQUFuQzs7SUFDQTJJLEdBQUcsQ0FBQ0MsRUFBSixHQUFTL0YsR0FBVDtJQUNBLE9BQU84RixHQUFQO0VBQ0QsQ0FKRDs7RUFNQSxJQUFJRSxRQUFRLEdBQUdkLFVBQVUsSUFBSSxPQUFPaEYsT0FBTyxDQUFDK0YsUUFBZixJQUEyQixRQUF6QyxHQUFvRCxVQUFVcE4sRUFBVixFQUFjO0lBQy9FLE9BQU8sT0FBT0EsRUFBUCxJQUFhLFFBQXBCO0VBQ0QsQ0FGYyxHQUVYLFVBQVVBLEVBQVYsRUFBYztJQUNoQixPQUFPQSxFQUFFLFlBQVlxSCxPQUFyQjtFQUNELENBSkQ7O0VBTUEsSUFBSWdHLGVBQWUsR0FBRyxTQUFTOU0sY0FBVCxDQUF3QlAsRUFBeEIsRUFBNEJDLEdBQTVCLEVBQWlDNk0sQ0FBakMsRUFBb0M7SUFDeEQsSUFBSTlNLEVBQUUsS0FBS29NLFdBQVgsRUFBd0JpQixlQUFlLENBQUNsQixTQUFELEVBQVlsTSxHQUFaLEVBQWlCNk0sQ0FBakIsQ0FBZjtJQUN4QmpMLFNBQVEsQ0FBQzdCLEVBQUQsQ0FBUjtJQUNBQyxHQUFHLEdBQUc2QixZQUFXLENBQUM3QixHQUFELEVBQU0sSUFBTixDQUFqQjtJQUNBNEIsU0FBUSxDQUFDaUwsQ0FBRCxDQUFSOztJQUNBLElBQUlwSixJQUFHLENBQUN3SSxVQUFELEVBQWFqTSxHQUFiLENBQVAsRUFBMEI7TUFDeEIsSUFBSSxDQUFDNk0sQ0FBQyxDQUFDNUssVUFBUCxFQUFtQjtRQUNqQixJQUFJLENBQUN3QixJQUFHLENBQUMxRCxFQUFELEVBQUs4TCxNQUFMLENBQVIsRUFBc0JySyxJQUFFLENBQUN6QixFQUFELEVBQUs4TCxNQUFMLEVBQWF2SixhQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FBdkIsQ0FBRjtRQUN0QnZDLEVBQUUsQ0FBQzhMLE1BQUQsQ0FBRixDQUFXN0wsR0FBWCxJQUFrQixJQUFsQjtPQUZGLE1BR087UUFDTCxJQUFJeUQsSUFBRyxDQUFDMUQsRUFBRCxFQUFLOEwsTUFBTCxDQUFILElBQW1COUwsRUFBRSxDQUFDOEwsTUFBRCxDQUFGLENBQVc3TCxHQUFYLENBQXZCLEVBQXdDRCxFQUFFLENBQUM4TCxNQUFELENBQUYsQ0FBVzdMLEdBQVgsSUFBa0IsS0FBbEI7UUFDeEM2TSxDQUFDLEdBQUdELGFBQU8sQ0FBQ0MsQ0FBRCxFQUFJO1VBQUU1SyxVQUFVLEVBQUVLLGFBQVUsQ0FBQyxDQUFELEVBQUksS0FBSjtTQUE1QixDQUFYOzs7TUFDQSxPQUFPbUssYUFBYSxDQUFDMU0sRUFBRCxFQUFLQyxHQUFMLEVBQVU2TSxDQUFWLENBQXBCOzs7SUFDRixPQUFPckwsSUFBRSxDQUFDekIsRUFBRCxFQUFLQyxHQUFMLEVBQVU2TSxDQUFWLENBQVQ7RUFDSCxDQWREOztFQWVBLElBQUlRLGlCQUFpQixHQUFHLFNBQVN4RCxnQkFBVCxDQUEwQjlKLEVBQTFCLEVBQThCMkIsQ0FBOUIsRUFBaUM7SUFDdkRFLFNBQVEsQ0FBQzdCLEVBQUQsQ0FBUjtJQUNBLElBQUlpSixJQUFJLEdBQUdzRSxTQUFRLENBQUM1TCxDQUFDLEdBQUc4RyxVQUFTLENBQUM5RyxDQUFELENBQWQsQ0FBbkI7SUFDQSxJQUFJeUUsQ0FBQyxHQUFHLENBQVI7SUFDQSxJQUFJb0gsQ0FBQyxHQUFHdkUsSUFBSSxDQUFDakYsTUFBYjtJQUNBLElBQUkvRCxHQUFKOztJQUNBLE9BQU91TixDQUFDLEdBQUdwSCxDQUFYO01BQWNpSCxlQUFlLENBQUNyTixFQUFELEVBQUtDLEdBQUcsR0FBR2dKLElBQUksQ0FBQzdDLENBQUMsRUFBRixDQUFmLEVBQXNCekUsQ0FBQyxDQUFDMUIsR0FBRCxDQUF2QixDQUFmOzs7SUFDZCxPQUFPRCxFQUFQO0VBQ0QsQ0FSRDs7RUFTQSxJQUFJeU4sT0FBTyxHQUFHLFNBQVNsSCxNQUFULENBQWdCdkcsRUFBaEIsRUFBb0IyQixDQUFwQixFQUF1QjtJQUNuQyxPQUFPQSxDQUFDLEtBQUtpQixTQUFOLEdBQWtCaUssYUFBTyxDQUFDN00sRUFBRCxDQUF6QixHQUFnQ3NOLGlCQUFpQixDQUFDVCxhQUFPLENBQUM3TSxFQUFELENBQVIsRUFBYzJCLENBQWQsQ0FBeEQ7RUFDRCxDQUZEOztFQUdBLElBQUkrTCxxQkFBcUIsR0FBRyxTQUFTaEcsb0JBQVQsQ0FBOEJ6SCxHQUE5QixFQUFtQztJQUM3RCxJQUFJME4sQ0FBQyxHQUFHbEUsTUFBTSxDQUFDdkosSUFBUCxDQUFZLElBQVosRUFBa0JELEdBQUcsR0FBRzZCLFlBQVcsQ0FBQzdCLEdBQUQsRUFBTSxJQUFOLENBQW5DLENBQVI7SUFDQSxJQUFJLFNBQVNtTSxXQUFULElBQXdCMUksSUFBRyxDQUFDd0ksVUFBRCxFQUFhak0sR0FBYixDQUEzQixJQUFnRCxDQUFDeUQsSUFBRyxDQUFDeUksU0FBRCxFQUFZbE0sR0FBWixDQUF4RCxFQUEwRSxPQUFPLEtBQVA7SUFDMUUsT0FBTzBOLENBQUMsSUFBSSxDQUFDakssSUFBRyxDQUFDLElBQUQsRUFBT3pELEdBQVAsQ0FBVCxJQUF3QixDQUFDeUQsSUFBRyxDQUFDd0ksVUFBRCxFQUFhak0sR0FBYixDQUE1QixJQUFpRHlELElBQUcsQ0FBQyxJQUFELEVBQU9vSSxNQUFQLENBQUgsSUFBcUIsS0FBS0EsTUFBTCxFQUFhN0wsR0FBYixDQUF0RSxHQUEwRjBOLENBQTFGLEdBQThGLElBQXJHO0VBQ0QsQ0FKRDs7RUFLQSxJQUFJQyx5QkFBeUIsR0FBRyxTQUFTdEMsd0JBQVQsQ0FBa0N0TCxFQUFsQyxFQUFzQ0MsR0FBdEMsRUFBMkM7SUFDekVELEVBQUUsR0FBR3lJLFVBQVMsQ0FBQ3pJLEVBQUQsQ0FBZDtJQUNBQyxHQUFHLEdBQUc2QixZQUFXLENBQUM3QixHQUFELEVBQU0sSUFBTixDQUFqQjtJQUNBLElBQUlELEVBQUUsS0FBS29NLFdBQVAsSUFBc0IxSSxJQUFHLENBQUN3SSxVQUFELEVBQWFqTSxHQUFiLENBQXpCLElBQThDLENBQUN5RCxJQUFHLENBQUN5SSxTQUFELEVBQVlsTSxHQUFaLENBQXRELEVBQXdFO0lBQ3hFLElBQUk2TSxDQUFDLEdBQUd6QixNQUFJLENBQUNyTCxFQUFELEVBQUtDLEdBQUwsQ0FBWjtJQUNBLElBQUk2TSxDQUFDLElBQUlwSixJQUFHLENBQUN3SSxVQUFELEVBQWFqTSxHQUFiLENBQVIsSUFBNkIsRUFBRXlELElBQUcsQ0FBQzFELEVBQUQsRUFBSzhMLE1BQUwsQ0FBSCxJQUFtQjlMLEVBQUUsQ0FBQzhMLE1BQUQsQ0FBRixDQUFXN0wsR0FBWCxDQUFyQixDQUFqQyxFQUF3RTZNLENBQUMsQ0FBQzVLLFVBQUYsR0FBZSxJQUFmO0lBQ3hFLE9BQU80SyxDQUFQO0VBQ0QsQ0FQRDs7RUFRQSxJQUFJZSxvQkFBb0IsR0FBRyxTQUFTNUMsbUJBQVQsQ0FBNkJqTCxFQUE3QixFQUFpQztJQUMxRCxJQUFJK0ksS0FBSyxHQUFHbUMsTUFBSSxDQUFDekMsVUFBUyxDQUFDekksRUFBRCxDQUFWLENBQWhCO0lBQ0EsSUFBSWdKLE1BQU0sR0FBRyxFQUFiO0lBQ0EsSUFBSTVDLENBQUMsR0FBRyxDQUFSO0lBQ0EsSUFBSW5HLEdBQUo7O0lBQ0EsT0FBTzhJLEtBQUssQ0FBQy9FLE1BQU4sR0FBZW9DLENBQXRCLEVBQXlCO01BQ3ZCLElBQUksQ0FBQzFDLElBQUcsQ0FBQ3dJLFVBQUQsRUFBYWpNLEdBQUcsR0FBRzhJLEtBQUssQ0FBQzNDLENBQUMsRUFBRixDQUF4QixDQUFKLElBQXNDbkcsR0FBRyxJQUFJNkwsTUFBN0MsSUFBdUQ3TCxHQUFHLElBQUk2RixJQUFsRSxFQUF3RWtELE1BQU0sQ0FBQ2pHLElBQVAsQ0FBWTlDLEdBQVo7OztJQUN4RSxPQUFPK0ksTUFBUDtFQUNILENBUkQ7O0VBU0EsSUFBSThFLHNCQUFzQixHQUFHLFNBQVMxRSxxQkFBVCxDQUErQnBKLEVBQS9CLEVBQW1DO0lBQzlELElBQUkrTixLQUFLLEdBQUcvTixFQUFFLEtBQUtvTSxXQUFuQjtJQUNBLElBQUlyRCxLQUFLLEdBQUdtQyxNQUFJLENBQUM2QyxLQUFLLEdBQUc1QixTQUFILEdBQWUxRCxVQUFTLENBQUN6SSxFQUFELENBQTlCLENBQWhCO0lBQ0EsSUFBSWdKLE1BQU0sR0FBRyxFQUFiO0lBQ0EsSUFBSTVDLENBQUMsR0FBRyxDQUFSO0lBQ0EsSUFBSW5HLEdBQUo7O0lBQ0EsT0FBTzhJLEtBQUssQ0FBQy9FLE1BQU4sR0FBZW9DLENBQXRCLEVBQXlCO01BQ3ZCLElBQUkxQyxJQUFHLENBQUN3SSxVQUFELEVBQWFqTSxHQUFHLEdBQUc4SSxLQUFLLENBQUMzQyxDQUFDLEVBQUYsQ0FBeEIsQ0FBSCxLQUFzQzJILEtBQUssR0FBR3JLLElBQUcsQ0FBQzBJLFdBQUQsRUFBY25NLEdBQWQsQ0FBTixHQUEyQixJQUF0RSxDQUFKLEVBQWlGK0ksTUFBTSxDQUFDakcsSUFBUCxDQUFZbUosVUFBVSxDQUFDak0sR0FBRCxDQUF0Qjs7O0lBQ2pGLE9BQU8rSSxNQUFQO0VBQ0gsQ0FURDs7O0VBWUEsSUFBSSxDQUFDcUQsVUFBTCxFQUFpQjtJQUNmaEYsT0FBTyxHQUFHLFNBQVNSLE1BQVQsR0FBa0I7TUFDMUIsSUFBSSxnQkFBZ0JRLE9BQXBCLEVBQTZCLE1BQU12RyxTQUFTLENBQUMsOEJBQUQsQ0FBZjtNQUM3QixJQUFJcUcsR0FBRyxHQUFHSCxJQUFHLENBQUMzQyxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBdkMsQ0FBYjs7TUFDQSxJQUFJb0wsSUFBSSxHQUFHLFNBQVBBLElBQU8sQ0FBVWhNLEtBQVYsRUFBaUI7UUFDMUIsSUFBSSxTQUFTb0ssV0FBYixFQUEwQjRCLElBQUksQ0FBQzlOLElBQUwsQ0FBVWlNLFNBQVYsRUFBcUJuSyxLQUFyQjtRQUMxQixJQUFJMEIsSUFBRyxDQUFDLElBQUQsRUFBT29JLE1BQVAsQ0FBSCxJQUFxQnBJLElBQUcsQ0FBQyxLQUFLb0ksTUFBTCxDQUFELEVBQWUzRSxHQUFmLENBQTVCLEVBQWlELEtBQUsyRSxNQUFMLEVBQWEzRSxHQUFiLElBQW9CLEtBQXBCO1FBQ2pEdUYsYUFBYSxDQUFDLElBQUQsRUFBT3ZGLEdBQVAsRUFBWTVFLGFBQVUsQ0FBQyxDQUFELEVBQUlQLEtBQUosQ0FBdEIsQ0FBYjtPQUhGOztNQUtBLElBQUkySyxZQUFXLElBQUlILE1BQW5CLEVBQTJCRSxhQUFhLENBQUNOLFdBQUQsRUFBY2pGLEdBQWQsRUFBbUI7UUFBRWhGLFlBQVksRUFBRSxJQUFoQjtRQUFzQjhMLEdBQUcsRUFBRUQ7T0FBOUMsQ0FBYjtNQUMzQixPQUFPaEIsSUFBSSxDQUFDN0YsR0FBRCxDQUFYO0tBVEY7O0lBV0F6QixTQUFRLENBQUMyQixPQUFPLENBQUMvQyxXQUFELENBQVIsRUFBcUIsVUFBckIsRUFBaUMsU0FBUy9DLFFBQVQsR0FBb0I7TUFDM0QsT0FBTyxLQUFLMkwsRUFBWjtLQURNLENBQVI7SUFJQTNCLFdBQUssQ0FBQ2pKLENBQU4sR0FBVXNMLHlCQUFWO0lBQ0FwQyxTQUFHLENBQUNsSixDQUFKLEdBQVErSyxlQUFSO0lBQ0FuTSxXQUF5QixDQUFDb0IsQ0FBMUIsR0FBOEJtSixjQUFPLENBQUNuSixDQUFSLEdBQVl1TCxvQkFBMUM7SUFDQTFNLFVBQXdCLENBQUNtQixDQUF6QixHQUE2Qm9MLHFCQUE3QjtJQUNBcEIsV0FBSyxDQUFDaEssQ0FBTixHQUFVd0wsc0JBQVY7O0lBRUEsSUFBSW5CLFlBQVcsSUFBSSxDQUFDdUIsUUFBcEIsRUFBMkM7TUFDekN4SSxTQUFRLENBQUMwRyxXQUFELEVBQWMsc0JBQWQsRUFBc0NzQixxQkFBdEMsRUFBNkQsSUFBN0QsQ0FBUjs7O0lBR0ZsRyxPQUFNLENBQUNsRixDQUFQLEdBQVcsVUFBVW1DLElBQVYsRUFBZ0I7TUFDekIsT0FBT3VJLElBQUksQ0FBQ2pCLElBQUcsQ0FBQ3RILElBQUQsQ0FBSixDQUFYO0tBREY7RUFHRDs7QUFFREYsU0FBTyxDQUFDQSxPQUFPLENBQUNPLENBQVIsR0FBWVAsT0FBTyxDQUFDcUIsQ0FBcEIsR0FBd0JyQixPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDeUgsVUFBdEMsRUFBa0Q7SUFBRXhGLE1BQU0sRUFBRVE7RUFBVixDQUFsRCxDQUFQOztFQUVBLEtBQUssSUFBSThHLFVBQVU7RUFFakIsZ0hBRm9CLENBR3BCN0ssS0FIb0IsQ0FHZCxHQUhjLENBQWpCLEVBR1M4SyxDQUFDLEdBQUcsQ0FIbEIsRUFHcUJELFVBQVUsQ0FBQ25LLE1BQVgsR0FBb0JvSyxDQUh6QztJQUc0Q3JDLElBQUcsQ0FBQ29DLFVBQVUsQ0FBQ0MsQ0FBQyxFQUFGLENBQVgsQ0FBSDtFQUg1Qzs7RUFLQSxLQUFLLElBQUlDLGdCQUFnQixHQUFHbkYsV0FBSyxDQUFDNkMsSUFBRyxDQUFDakosS0FBTCxDQUE1QixFQUF5Q3dMLENBQUMsR0FBRyxDQUFsRCxFQUFxREQsZ0JBQWdCLENBQUNySyxNQUFqQixHQUEwQnNLLENBQS9FO0lBQW1GQyxVQUFTLENBQUNGLGdCQUFnQixDQUFDQyxDQUFDLEVBQUYsQ0FBakIsQ0FBVDtFQUFuRjs7QUFFQS9KLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBQ3lILFVBQTFCLEVBQXNDLFFBQXRDLEVBQWdEOztJQUVyRCxPQUFPLGNBQVVwTSxHQUFWLEVBQWU7TUFDcEIsT0FBT3lELElBQUcsQ0FBQ3VJLGNBQUQsRUFBaUJoTSxHQUFHLElBQUksRUFBeEIsQ0FBSCxHQUNIZ00sY0FBYyxDQUFDaE0sR0FBRCxDQURYLEdBRUhnTSxjQUFjLENBQUNoTSxHQUFELENBQWQsR0FBc0JvSCxPQUFPLENBQUNwSCxHQUFELENBRmpDO0tBSG1EOztJQVFyRHVPLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCdkIsR0FBaEIsRUFBcUI7TUFDM0IsSUFBSSxDQUFDRSxRQUFRLENBQUNGLEdBQUQsQ0FBYixFQUFvQixNQUFNbk0sU0FBUyxDQUFDbU0sR0FBRyxHQUFHLG1CQUFQLENBQWY7O01BQ3BCLEtBQUssSUFBSWhOLEdBQVQsSUFBZ0JnTSxjQUFoQjtRQUFnQyxJQUFJQSxjQUFjLENBQUNoTSxHQUFELENBQWQsS0FBd0JnTixHQUE1QixFQUFpQyxPQUFPaE4sR0FBUDs7S0FWZDtJQVlyRHdPLFNBQVMsRUFBRSxxQkFBWTtNQUFFakMsTUFBTSxHQUFHLElBQVQ7S0FaNEI7SUFhckRrQyxTQUFTLEVBQUUscUJBQVk7TUFBRWxDLE1BQU0sR0FBRyxLQUFUOztFQWI0QixDQUFoRCxDQUFQO0FBZ0JBakksU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDeUgsVUFBMUIsRUFBc0MsUUFBdEMsRUFBZ0Q7O0lBRXJEOUYsTUFBTSxFQUFFa0gsT0FGNkM7O0lBSXJEbE4sY0FBYyxFQUFFOE0sZUFKcUM7O0lBTXJEdkQsZ0JBQWdCLEVBQUV3RCxpQkFObUM7O0lBUXJEaEMsd0JBQXdCLEVBQUVzQyx5QkFSMkI7O0lBVXJEM0MsbUJBQW1CLEVBQUU0QyxvQkFWZ0M7O0lBWXJEekUscUJBQXFCLEVBQUUwRTtFQVo4QixDQUFoRCxDQUFQO0VBZ0JBOztFQUNBLElBQUlhLG1CQUFtQixHQUFHL0IsTUFBTSxDQUFDLFlBQVk7SUFBRU4sV0FBSyxDQUFDaEssQ0FBTixDQUFRLENBQVI7RUFBYSxDQUE1QixDQUFoQztBQUVBaUMsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsR0FBWStKLG1CQUF6QixFQUE4QyxRQUE5QyxFQUF3RDtJQUM3RHZGLHFCQUFxQixFQUFFLFNBQVNBLHFCQUFULENBQStCcEosRUFBL0IsRUFBbUM7TUFDeEQsT0FBT3NNLFdBQUssQ0FBQ2hLLENBQU4sQ0FBUXNNLFNBQVEsQ0FBQzVPLEVBQUQsQ0FBaEIsQ0FBUDs7RUFGMkQsQ0FBeEQsQ0FBUDs7RUFPQTBMLEtBQUssSUFBSW5ILE9BQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLElBQWEsQ0FBQ3lILFVBQUQsSUFBZU8sTUFBTSxDQUFDLFlBQVk7SUFDMUUsSUFBSXhMLENBQUMsR0FBR2lHLE9BQU8sRUFBZixDQUQwRTs7OztJQUsxRSxPQUFPdUUsVUFBVSxDQUFDLENBQUN4SyxDQUFELENBQUQsQ0FBVixJQUFtQixRQUFuQixJQUErQndLLFVBQVUsQ0FBQztNQUFFbkwsQ0FBQyxFQUFFVztLQUFOLENBQVYsSUFBd0IsSUFBdkQsSUFBK0R3SyxVQUFVLENBQUN0TCxNQUFNLENBQUNjLENBQUQsQ0FBUCxDQUFWLElBQXlCLElBQS9GO0VBQ0QsQ0FOOEQsQ0FBbEMsQ0FBYixFQU1YLE1BTlcsRUFNSDtJQUNYeUssU0FBUyxFQUFFLFNBQVNBLFNBQVQsQ0FBbUI3TCxFQUFuQixFQUF1QjtNQUNoQyxJQUFJNk8sSUFBSSxHQUFHLENBQUM3TyxFQUFELENBQVg7TUFDQSxJQUFJb0csQ0FBQyxHQUFHLENBQVI7TUFDQSxJQUFJMEksUUFBSixFQUFjQyxTQUFkOztNQUNBLE9BQU8xSyxTQUFTLENBQUNMLE1BQVYsR0FBbUJvQyxDQUExQjtRQUE2QnlJLElBQUksQ0FBQzlMLElBQUwsQ0FBVXNCLFNBQVMsQ0FBQytCLENBQUMsRUFBRixDQUFuQjs7O01BQzdCMkksU0FBUyxHQUFHRCxRQUFRLEdBQUdELElBQUksQ0FBQyxDQUFELENBQTNCO01BQ0EsSUFBSSxDQUFDaE8sU0FBUSxDQUFDaU8sUUFBRCxDQUFULElBQXVCOU8sRUFBRSxLQUFLNEMsU0FBOUIsSUFBMkN1SyxRQUFRLENBQUNuTixFQUFELENBQXZELEVBQTZELE9BTjdCOztNQU9oQyxJQUFJLENBQUM0SixRQUFPLENBQUNrRixRQUFELENBQVosRUFBd0JBLFFBQVEsR0FBRyxrQkFBVTdPLEdBQVYsRUFBZStCLEtBQWYsRUFBc0I7UUFDdkQsSUFBSSxPQUFPK00sU0FBUCxJQUFvQixVQUF4QixFQUFvQy9NLEtBQUssR0FBRytNLFNBQVMsQ0FBQzdPLElBQVYsQ0FBZSxJQUFmLEVBQXFCRCxHQUFyQixFQUEwQitCLEtBQTFCLENBQVI7UUFDcEMsSUFBSSxDQUFDbUwsUUFBUSxDQUFDbkwsS0FBRCxDQUFiLEVBQXNCLE9BQU9BLEtBQVA7T0FGQTtNQUl4QjZNLElBQUksQ0FBQyxDQUFELENBQUosR0FBVUMsUUFBVjtNQUNBLE9BQU9sRCxVQUFVLENBQUN4SCxLQUFYLENBQWlCc0gsS0FBakIsRUFBd0JtRCxJQUF4QixDQUFQOztFQWJTLENBTkcsQ0FBaEI7O0VBd0JBeEgsT0FBTyxDQUFDL0MsV0FBRCxDQUFQLENBQW1CMEgsWUFBbkIsS0FBb0NnRCxLQUFrQixDQUFDM0gsT0FBTyxDQUFDL0MsV0FBRCxDQUFSLEVBQXFCMEgsWUFBckIsRUFBbUMzRSxPQUFPLENBQUMvQyxXQUFELENBQVAsQ0FBbUI5QyxPQUF0RCxDQUF0RDs7QUFFQXlOLGlCQUFjLENBQUM1SCxPQUFELEVBQVUsUUFBVixDQUFkOztBQUVBNEgsaUJBQWMsQ0FBQ3RQLElBQUQsRUFBTyxNQUFQLEVBQWUsSUFBZixDQUFkOztBQUVBc1AsaUJBQWMsQ0FBQ3pQLE9BQU0sQ0FBQ21NLElBQVIsRUFBYyxNQUFkLEVBQXNCLElBQXRCLENBQWQ7O0FDblBBcEgsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUFFbUYsTUFBTSxFQUFFbEc7RUFBVixDQUF0QixDQUFQOztBQ0FBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDdkUsWUFBMUIsRUFBcUQsUUFBckQsRUFBK0Q7SUFBRUUsY0FBYyxFQUFFVyxTQUF1QixDQUFDb0I7RUFBMUMsQ0FBL0QsQ0FBUDs7QUNBQWlDLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBQ3ZFLFlBQTFCLEVBQXFELFFBQXJELEVBQStEO0lBQUV5SixnQkFBZ0IsRUFBRTVJO0VBQXBCLENBQS9ELENBQVA7O0VDRUEsY0FBYyxHQUFHLG1CQUFBLENBQVUwRixHQUFWLEVBQWV6RyxJQUFmLEVBQXFCO0lBQ3BDLElBQUlrQixFQUFFLEdBQUcsQ0FBQ1gsS0FBSSxDQUFDSixNQUFMLElBQWUsRUFBaEIsRUFBb0JzRyxHQUFwQixLQUE0QnRHLE1BQU0sQ0FBQ3NHLEdBQUQsQ0FBM0M7SUFDQSxJQUFJcEIsR0FBRyxHQUFHLEVBQVY7SUFDQUEsR0FBRyxDQUFDb0IsR0FBRCxDQUFILEdBQVd6RyxJQUFJLENBQUNrQixFQUFELENBQWY7SUFDQWtELE9BQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVlzSyxNQUFLLENBQUMsWUFBWTtNQUFFN04sRUFBRSxDQUFDLENBQUQsQ0FBRjtLQUFmLENBQTlCLEVBQXdELFFBQXhELEVBQWtFbUUsR0FBbEUsQ0FBUDtFQUNELENBTEQ7O0VDRkEsSUFBSW9JLDJCQUF5QixHQUFHdk4sV0FBeUIsQ0FBQ2lDLENBQTFEO0FBRUFwQixZQUF3QixDQUFDLDBCQUFELEVBQTZCLFlBQVk7SUFDL0QsT0FBTyxTQUFTb0ssd0JBQVQsQ0FBa0N0TCxFQUFsQyxFQUFzQ0MsR0FBdEMsRUFBMkM7TUFDaEQsT0FBTzJOLDJCQUF5QixDQUFDbkYsVUFBUyxDQUFDekksRUFBRCxDQUFWLEVBQWdCQyxHQUFoQixDQUFoQztLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0VDREEsSUFBSTZJLFVBQVEsR0FBR3pJLFVBQXdCLENBQUMsVUFBRCxDQUF2QztFQUNBLElBQUkrTCxhQUFXLEdBQUc5TCxNQUFNLENBQUN3RCxTQUF6Qjs7RUFFQSxjQUFjLEdBQUd4RCxNQUFNLENBQUM2TyxjQUFQLElBQXlCLFVBQVV6TixDQUFWLEVBQWE7SUFDckRBLENBQUMsR0FBR2tOLFNBQVEsQ0FBQ2xOLENBQUQsQ0FBWjtJQUNBLElBQUlnQyxJQUFHLENBQUNoQyxDQUFELEVBQUlvSCxVQUFKLENBQVAsRUFBc0IsT0FBT3BILENBQUMsQ0FBQ29ILFVBQUQsQ0FBUjs7SUFDdEIsSUFBSSxPQUFPcEgsQ0FBQyxDQUFDME4sV0FBVCxJQUF3QixVQUF4QixJQUFzQzFOLENBQUMsWUFBWUEsQ0FBQyxDQUFDME4sV0FBekQsRUFBc0U7TUFDcEUsT0FBTzFOLENBQUMsQ0FBQzBOLFdBQUYsQ0FBY3RMLFNBQXJCOzs7SUFDQSxPQUFPcEMsQ0FBQyxZQUFZcEIsTUFBYixHQUFzQjhMLGFBQXRCLEdBQW9DLElBQTNDO0VBQ0gsQ0FORDs7QUNGQS9MLFlBQXdCLENBQUMsZ0JBQUQsRUFBbUIsWUFBWTtJQUNyRCxPQUFPLFNBQVM4TyxjQUFULENBQXdCblAsRUFBeEIsRUFBNEI7TUFDakMsT0FBT3FQLFVBQWUsQ0FBQ1QsU0FBUSxDQUFDNU8sRUFBRCxDQUFULENBQXRCO0tBREY7RUFHRCxDQUp1QixDQUF4Qjs7QUNBQUssWUFBd0IsQ0FBQyxNQUFELEVBQVMsWUFBWTtJQUMzQyxPQUFPLFNBQVM0SSxJQUFULENBQWNqSixFQUFkLEVBQWtCO01BQ3ZCLE9BQU9rSixXQUFLLENBQUMwRixTQUFRLENBQUM1TyxFQUFELENBQVQsQ0FBWjtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0FDSEFLLFlBQXdCLENBQUMscUJBQUQsRUFBd0IsWUFBWTtJQUMxRCxPQUFPYSxjQUE2QixDQUFDb0IsQ0FBckM7RUFDRCxDQUZ1QixDQUF4Qjs7RUNDQSxJQUFJb0UsSUFBSSxHQUFHckcsS0FBa0IsQ0FBQ29HLFFBQTlCO0FBRUF2RixZQUF3QixDQUFDLFFBQUQsRUFBVyxVQUFVb08sT0FBVixFQUFtQjtJQUNwRCxPQUFPLFNBQVNDLE1BQVQsQ0FBZ0J2UCxFQUFoQixFQUFvQjtNQUN6QixPQUFPc1AsT0FBTyxJQUFJek8sU0FBUSxDQUFDYixFQUFELENBQW5CLEdBQTBCc1AsT0FBTyxDQUFDNUksSUFBSSxDQUFDMUcsRUFBRCxDQUFMLENBQWpDLEdBQThDQSxFQUFyRDtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0VDRkEsSUFBSTBHLE1BQUksR0FBR3JHLEtBQWtCLENBQUNvRyxRQUE5QjtBQUVBdkYsWUFBd0IsQ0FBQyxNQUFELEVBQVMsVUFBVXNPLEtBQVYsRUFBaUI7SUFDaEQsT0FBTyxTQUFTQyxJQUFULENBQWN6UCxFQUFkLEVBQWtCO01BQ3ZCLE9BQU93UCxLQUFLLElBQUkzTyxTQUFRLENBQUNiLEVBQUQsQ0FBakIsR0FBd0J3UCxLQUFLLENBQUM5SSxNQUFJLENBQUMxRyxFQUFELENBQUwsQ0FBN0IsR0FBMENBLEVBQWpEO0tBREY7RUFHRCxDQUp1QixDQUF4Qjs7RUNGQSxJQUFJMEcsTUFBSSxHQUFHckcsS0FBa0IsQ0FBQ29HLFFBQTlCO0FBRUF2RixZQUF3QixDQUFDLG1CQUFELEVBQXNCLFVBQVV3TyxrQkFBVixFQUE4QjtJQUMxRSxPQUFPLFNBQVN4SixpQkFBVCxDQUEyQmxHLEVBQTNCLEVBQStCO01BQ3BDLE9BQU8wUCxrQkFBa0IsSUFBSTdPLFNBQVEsQ0FBQ2IsRUFBRCxDQUE5QixHQUFxQzBQLGtCQUFrQixDQUFDaEosTUFBSSxDQUFDMUcsRUFBRCxDQUFMLENBQXZELEdBQW9FQSxFQUEzRTtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0FDREFLLFlBQXdCLENBQUMsVUFBRCxFQUFhLFVBQVVzUCxTQUFWLEVBQXFCO0lBQ3hELE9BQU8sU0FBU0MsUUFBVCxDQUFrQjVQLEVBQWxCLEVBQXNCO01BQzNCLE9BQU9hLFNBQVEsQ0FBQ2IsRUFBRCxDQUFSLEdBQWUyUCxTQUFTLEdBQUdBLFNBQVMsQ0FBQzNQLEVBQUQsQ0FBWixHQUFtQixLQUEzQyxHQUFtRCxJQUExRDtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0FDQUFLLFlBQXdCLENBQUMsVUFBRCxFQUFhLFVBQVV3UCxTQUFWLEVBQXFCO0lBQ3hELE9BQU8sU0FBU0MsUUFBVCxDQUFrQjlQLEVBQWxCLEVBQXNCO01BQzNCLE9BQU9hLFNBQVEsQ0FBQ2IsRUFBRCxDQUFSLEdBQWU2UCxTQUFTLEdBQUdBLFNBQVMsQ0FBQzdQLEVBQUQsQ0FBWixHQUFtQixLQUEzQyxHQUFtRCxJQUExRDtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0FDQUFLLFlBQXdCLENBQUMsY0FBRCxFQUFpQixVQUFVMFAsYUFBVixFQUF5QjtJQUNoRSxPQUFPLFNBQVMvSixZQUFULENBQXNCaEcsRUFBdEIsRUFBMEI7TUFDL0IsT0FBT2EsU0FBUSxDQUFDYixFQUFELENBQVIsR0FBZStQLGFBQWEsR0FBR0EsYUFBYSxDQUFDL1AsRUFBRCxDQUFoQixHQUF1QixJQUFuRCxHQUEwRCxLQUFqRTtLQURGO0VBR0QsQ0FKdUIsQ0FBeEI7O0VDS0EsSUFBSWdRLE9BQU8sR0FBRzFQLE1BQU0sQ0FBQzJQLE1BQXJCOztFQUdBLGlCQUFjLEdBQUcsQ0FBQ0QsT0FBRCxJQUFZM1AsTUFBbUIsQ0FBQyxZQUFZO0lBQzNELElBQUk2UCxDQUFDLEdBQUcsRUFBUjtJQUNBLElBQUloTCxDQUFDLEdBQUcsRUFBUixDQUYyRDs7SUFJM0QsSUFBSTlELENBQUMsR0FBR3lGLE1BQU0sRUFBZDtJQUNBLElBQUlzSixDQUFDLEdBQUcsc0JBQVI7SUFDQUQsQ0FBQyxDQUFDOU8sQ0FBRCxDQUFELEdBQU8sQ0FBUDtJQUNBK08sQ0FBQyxDQUFDN00sS0FBRixDQUFRLEVBQVIsRUFBWThNLE9BQVosQ0FBb0IsVUFBVTlCLENBQVYsRUFBYTtNQUFFcEosQ0FBQyxDQUFDb0osQ0FBRCxDQUFELEdBQU9BLENBQVA7S0FBbkM7SUFDQSxPQUFPMEIsT0FBTyxDQUFDLEVBQUQsRUFBS0UsQ0FBTCxDQUFQLENBQWU5TyxDQUFmLEtBQXFCLENBQXJCLElBQTBCZCxNQUFNLENBQUMySSxJQUFQLENBQVkrRyxPQUFPLENBQUMsRUFBRCxFQUFLOUssQ0FBTCxDQUFuQixFQUE0QnRCLElBQTVCLENBQWlDLEVBQWpDLEtBQXdDdU0sQ0FBekU7RUFDRCxDQVQrQyxDQUEvQixHQVNaLFNBQVNGLE1BQVQsQ0FBZ0I5SyxNQUFoQixFQUF3QlQsTUFBeEIsRUFBZ0M7O0lBQ25DLElBQUkyTCxDQUFDLEdBQUd6QixTQUFRLENBQUN6SixNQUFELENBQWhCO0lBQ0EsSUFBSW1MLElBQUksR0FBR2pNLFNBQVMsQ0FBQ0wsTUFBckI7SUFDQSxJQUFJb0UsS0FBSyxHQUFHLENBQVo7SUFDQSxJQUFJa0IsVUFBVSxHQUFHQyxXQUFJLENBQUNqSCxDQUF0QjtJQUNBLElBQUltSCxNQUFNLEdBQUdDLFVBQUcsQ0FBQ3BILENBQWpCOztJQUNBLE9BQU9nTyxJQUFJLEdBQUdsSSxLQUFkLEVBQXFCO01BQ25CLElBQUloSCxDQUFDLEdBQUd3RyxRQUFPLENBQUN2RCxTQUFTLENBQUMrRCxLQUFLLEVBQU4sQ0FBVixDQUFmO01BQ0EsSUFBSWEsSUFBSSxHQUFHSyxVQUFVLEdBQUdELFdBQU8sQ0FBQ2pJLENBQUQsQ0FBUCxDQUFXdUIsTUFBWCxDQUFrQjJHLFVBQVUsQ0FBQ2xJLENBQUQsQ0FBNUIsQ0FBSCxHQUFzQ2lJLFdBQU8sQ0FBQ2pJLENBQUQsQ0FBbEU7TUFDQSxJQUFJNEMsTUFBTSxHQUFHaUYsSUFBSSxDQUFDakYsTUFBbEI7TUFDQSxJQUFJb0ssQ0FBQyxHQUFHLENBQVI7TUFDQSxJQUFJbk8sR0FBSjs7TUFDQSxPQUFPK0QsTUFBTSxHQUFHb0ssQ0FBaEIsRUFBbUI7UUFDakJuTyxHQUFHLEdBQUdnSixJQUFJLENBQUNtRixDQUFDLEVBQUYsQ0FBVjtRQUNBLElBQUksQ0FBQ3pCLFlBQUQsSUFBZ0JsRCxNQUFNLENBQUN2SixJQUFQLENBQVlrQixDQUFaLEVBQWVuQixHQUFmLENBQXBCLEVBQXlDb1EsQ0FBQyxDQUFDcFEsR0FBRCxDQUFELEdBQVNtQixDQUFDLENBQUNuQixHQUFELENBQVY7Ozs7SUFFM0MsT0FBT29RLENBQVA7RUFDSCxDQTFCZ0IsR0EwQmJMLE9BMUJKOztBQ1JBekwsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQXJCLEVBQXdCLFFBQXhCLEVBQWtDO0lBQUVxTCxNQUFNLEVBQUU1UDtFQUFWLENBQWxDLENBQVA7O0VDSEE7RUFDQSxjQUFjLEdBQUdDLE1BQU0sQ0FBQ1UsRUFBUCxJQUFhLFNBQVNBLEVBQVQsQ0FBWXVQLENBQVosRUFBZUMsQ0FBZixFQUFrQjs7SUFFOUMsT0FBT0QsQ0FBQyxLQUFLQyxDQUFOLEdBQVVELENBQUMsS0FBSyxDQUFOLElBQVcsSUFBSUEsQ0FBSixLQUFVLElBQUlDLENBQW5DLEdBQXVDRCxDQUFDLElBQUlBLENBQUwsSUFBVUMsQ0FBQyxJQUFJQSxDQUE3RDtFQUNELENBSEQ7O0FDQ0FqTSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxRQUFaLEVBQXNCO0lBQUVKLEVBQUUsRUFBRVg7RUFBTixDQUF0QixDQUFQOztFQ0RBOztFQUdBLElBQUlvUSxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFVL08sQ0FBVixFQUFhZ1AsS0FBYixFQUFvQjtJQUM5QjdPLFNBQVEsQ0FBQ0gsQ0FBRCxDQUFSO0lBQ0EsSUFBSSxDQUFDYixTQUFRLENBQUM2UCxLQUFELENBQVQsSUFBb0JBLEtBQUssS0FBSyxJQUFsQyxFQUF3QyxNQUFNNVAsU0FBUyxDQUFDNFAsS0FBSyxHQUFHLDJCQUFULENBQWY7RUFDekMsQ0FIRDs7RUFJQSxhQUFjLEdBQUc7SUFDZnpDLEdBQUcsRUFBRTNOLE1BQU0sQ0FBQ3FRLGNBQVAsS0FBMEIsZUFBZSxFQUFmO0lBQzdCLFVBQVVDLElBQVYsRUFBZ0JDLEtBQWhCLEVBQXVCNUMsR0FBdkIsRUFBNEI7TUFDMUIsSUFBSTtRQUNGQSxHQUFHLEdBQUc1TixJQUFpQixDQUFDUixRQUFRLENBQUNLLElBQVYsRUFBZ0JnQixXQUF5QixDQUFDb0IsQ0FBMUIsQ0FBNEJoQyxNQUFNLENBQUN3RCxTQUFuQyxFQUE4QyxXQUE5QyxFQUEyRG1LLEdBQTNFLEVBQWdGLENBQWhGLENBQXZCO1FBQ0FBLEdBQUcsQ0FBQzJDLElBQUQsRUFBTyxFQUFQLENBQUg7UUFDQUMsS0FBSyxHQUFHLEVBQUVELElBQUksWUFBWWpILEtBQWxCLENBQVI7T0FIRixDQUlFLE9BQU92SixDQUFQLEVBQVU7UUFBRXlRLEtBQUssR0FBRyxJQUFSOzs7TUFDZCxPQUFPLFNBQVNGLGNBQVQsQ0FBd0JqUCxDQUF4QixFQUEyQmdQLEtBQTNCLEVBQWtDO1FBQ3ZDRCxLQUFLLENBQUMvTyxDQUFELEVBQUlnUCxLQUFKLENBQUw7UUFDQSxJQUFJRyxLQUFKLEVBQVduUCxDQUFDLENBQUNvUCxTQUFGLEdBQWNKLEtBQWQsQ0FBWCxLQUNLekMsR0FBRyxDQUFDdk0sQ0FBRCxFQUFJZ1AsS0FBSixDQUFIO1FBQ0wsT0FBT2hQLENBQVA7T0FKRjtLQU5GLENBWUUsRUFaRixFQVlNLEtBWk4sQ0FENkIsR0FhZGtCLFNBYlosQ0FEVTtJQWVmNk4sS0FBSyxFQUFFQTtFQWZRLENBQWpCOztBQ05BbE0sU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUFFdVAsY0FBYyxFQUFFdFEsU0FBdUIsQ0FBQzROO0VBQTFDLENBQXRCLENBQVA7O0VDQUEsSUFBSS9HLEtBQUcsR0FBRzdHLElBQWlCLENBQUMsYUFBRCxDQUEzQjs7RUFFQSxJQUFJMFEsR0FBRyxHQUFHcEosSUFBRyxDQUFDLFlBQVk7SUFBRSxPQUFPdEQsU0FBUDtFQUFtQixDQUFqQyxFQUFELENBQUgsSUFBNEMsV0FBdEQ7O0VBR0EsSUFBSTJNLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVVoUixFQUFWLEVBQWNDLEdBQWQsRUFBbUI7SUFDOUIsSUFBSTtNQUNGLE9BQU9ELEVBQUUsQ0FBQ0MsR0FBRCxDQUFUO0tBREYsQ0FFRSxPQUFPRyxDQUFQLEVBQVU7OztFQUNiLENBSkQ7O0VBTUEsWUFBYyxHQUFHLGlCQUFBLENBQVVKLEVBQVYsRUFBYztJQUM3QixJQUFJMEIsQ0FBSixFQUFPMk8sQ0FBUCxFQUFVbkwsQ0FBVjtJQUNBLE9BQU9sRixFQUFFLEtBQUs0QyxTQUFQLEdBQW1CLFdBQW5CLEdBQWlDNUMsRUFBRSxLQUFLLElBQVAsR0FBYyxNQUFkO01BRXBDLFFBQVFxUSxDQUFDLEdBQUdXLE1BQU0sQ0FBQ3RQLENBQUMsR0FBR3BCLE1BQU0sQ0FBQ04sRUFBRCxDQUFYLEVBQWlCa0gsS0FBakIsQ0FBbEIsS0FBNEMsUUFBNUMsR0FBdURtSixDQUF2RDtNQUVBVSxHQUFHLEdBQUdwSixJQUFHLENBQUNqRyxDQUFELENBQU47TUFFSCxDQUFDd0QsQ0FBQyxHQUFHeUMsSUFBRyxDQUFDakcsQ0FBRCxDQUFSLEtBQWdCLFFBQWhCLElBQTRCLE9BQU9BLENBQUMsQ0FBQ3VQLE1BQVQsSUFBbUIsVUFBL0MsR0FBNEQsV0FBNUQsR0FBMEUvTCxDQU45RTtFQU9ELENBVEQ7O0VDVkEsSUFBSTBMLElBQUksR0FBRyxFQUFYO0VBQ0FBLElBQUksQ0FBQ3ZRLElBQWlCLENBQUMsYUFBRCxDQUFsQixDQUFKLEdBQXlDLEdBQXpDOztFQUNBLElBQUl1USxJQUFJLEdBQUcsRUFBUCxJQUFhLFlBQWpCLEVBQStCO0lBQzdCMVAsU0FBc0IsQ0FBQ1osTUFBTSxDQUFDd0QsU0FBUixFQUFtQixVQUFuQixFQUErQixTQUFTdkMsUUFBVCxHQUFvQjtNQUN2RSxPQUFPLGFBQWEyUCxRQUFPLENBQUMsSUFBRCxDQUFwQixHQUE2QixHQUFwQztLQURvQixFQUVuQixJQUZtQixDQUF0Qjs7O0VDTkY7RUFDQSxXQUFjLEdBQUcsZ0JBQUEsQ0FBVTdQLEVBQVYsRUFBY3dOLElBQWQsRUFBb0I5SyxJQUFwQixFQUEwQjtJQUN6QyxJQUFJb04sRUFBRSxHQUFHcE4sSUFBSSxLQUFLbkIsU0FBbEI7O0lBQ0EsUUFBUWlNLElBQUksQ0FBQzdLLE1BQWI7TUFDRSxLQUFLLENBQUw7UUFBUSxPQUFPbU4sRUFBRSxHQUFHOVAsRUFBRSxFQUFMLEdBQ0dBLEVBQUUsQ0FBQ25CLElBQUgsQ0FBUTZELElBQVIsQ0FEWjs7TUFFUixLQUFLLENBQUw7UUFBUSxPQUFPb04sRUFBRSxHQUFHOVAsRUFBRSxDQUFDd04sSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFMLEdBQ0d4TixFQUFFLENBQUNuQixJQUFILENBQVE2RCxJQUFSLEVBQWM4SyxJQUFJLENBQUMsQ0FBRCxDQUFsQixDQURaOztNQUVSLEtBQUssQ0FBTDtRQUFRLE9BQU9zQyxFQUFFLEdBQUc5UCxFQUFFLENBQUN3TixJQUFJLENBQUMsQ0FBRCxDQUFMLEVBQVVBLElBQUksQ0FBQyxDQUFELENBQWQsQ0FBTCxHQUNHeE4sRUFBRSxDQUFDbkIsSUFBSCxDQUFRNkQsSUFBUixFQUFjOEssSUFBSSxDQUFDLENBQUQsQ0FBbEIsRUFBdUJBLElBQUksQ0FBQyxDQUFELENBQTNCLENBRFo7O01BRVIsS0FBSyxDQUFMO1FBQVEsT0FBT3NDLEVBQUUsR0FBRzlQLEVBQUUsQ0FBQ3dOLElBQUksQ0FBQyxDQUFELENBQUwsRUFBVUEsSUFBSSxDQUFDLENBQUQsQ0FBZCxFQUFtQkEsSUFBSSxDQUFDLENBQUQsQ0FBdkIsQ0FBTCxHQUNHeE4sRUFBRSxDQUFDbkIsSUFBSCxDQUFRNkQsSUFBUixFQUFjOEssSUFBSSxDQUFDLENBQUQsQ0FBbEIsRUFBdUJBLElBQUksQ0FBQyxDQUFELENBQTNCLEVBQWdDQSxJQUFJLENBQUMsQ0FBRCxDQUFwQyxDQURaOztNQUVSLEtBQUssQ0FBTDtRQUFRLE9BQU9zQyxFQUFFLEdBQUc5UCxFQUFFLENBQUN3TixJQUFJLENBQUMsQ0FBRCxDQUFMLEVBQVVBLElBQUksQ0FBQyxDQUFELENBQWQsRUFBbUJBLElBQUksQ0FBQyxDQUFELENBQXZCLEVBQTRCQSxJQUFJLENBQUMsQ0FBRCxDQUFoQyxDQUFMLEdBQ0d4TixFQUFFLENBQUNuQixJQUFILENBQVE2RCxJQUFSLEVBQWM4SyxJQUFJLENBQUMsQ0FBRCxDQUFsQixFQUF1QkEsSUFBSSxDQUFDLENBQUQsQ0FBM0IsRUFBZ0NBLElBQUksQ0FBQyxDQUFELENBQXBDLEVBQXlDQSxJQUFJLENBQUMsQ0FBRCxDQUE3QyxDQURaOzs7SUFFUixPQUFPeE4sRUFBRSxDQUFDK0MsS0FBSCxDQUFTTCxJQUFULEVBQWU4SyxJQUFmLENBQVA7RUFDSCxDQWREOztFQ0dBLElBQUl1QyxVQUFVLEdBQUcsR0FBRzNKLEtBQXBCO0VBQ0EsSUFBSTRKLFNBQVMsR0FBRyxFQUFoQjs7RUFFQSxJQUFJQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVMU0sQ0FBVixFQUFhMk0sR0FBYixFQUFrQjFDLElBQWxCLEVBQXdCO0lBQ3RDLElBQUksRUFBRTBDLEdBQUcsSUFBSUYsU0FBVCxDQUFKLEVBQXlCO01BQ3ZCLEtBQUssSUFBSUcsQ0FBQyxHQUFHLEVBQVIsRUFBWXBMLENBQUMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHbUwsR0FBNUIsRUFBaUNuTCxDQUFDLEVBQWxDO1FBQXNDb0wsQ0FBQyxDQUFDcEwsQ0FBRCxDQUFELEdBQU8sT0FBT0EsQ0FBUCxHQUFXLEdBQWxCO09BRGY7OztNQUd2QmlMLFNBQVMsQ0FBQ0UsR0FBRCxDQUFULEdBQWlCMVIsUUFBUSxDQUFDLEtBQUQsRUFBUSxrQkFBa0IyUixDQUFDLENBQUM1TixJQUFGLENBQU8sR0FBUCxDQUFsQixHQUFnQyxHQUF4QyxDQUF6Qjs7O0lBQ0EsT0FBT3lOLFNBQVMsQ0FBQ0UsR0FBRCxDQUFULENBQWUzTSxDQUFmLEVBQWtCaUssSUFBbEIsQ0FBUDtFQUNILENBTkQ7O0VBUUEsU0FBYyxHQUFHaFAsUUFBUSxDQUFDNFIsSUFBVCxJQUFpQixTQUFTQSxJQUFULENBQWMxTjs7RUFBZCxFQUFvQztJQUNwRSxJQUFJMUMsRUFBRSxHQUFHNEMsVUFBUyxDQUFDLElBQUQsQ0FBbEI7SUFDQSxJQUFJeU4sUUFBUSxHQUFHTixVQUFVLENBQUNsUixJQUFYLENBQWdCbUUsU0FBaEIsRUFBMkIsQ0FBM0IsQ0FBZjs7SUFDQSxJQUFJc04sS0FBSyxHQUFHOztJQUFSQSxLQUFRLEdBQXlCO01BQ25DLElBQUk5QyxJQUFJLEdBQUc2QyxRQUFRLENBQUMvTyxNQUFULENBQWdCeU8sVUFBVSxDQUFDbFIsSUFBWCxDQUFnQm1FLFNBQWhCLENBQWhCLENBQVg7TUFDQSxPQUFPLGdCQUFnQnNOLEtBQWhCLEdBQXdCTCxTQUFTLENBQUNqUSxFQUFELEVBQUt3TixJQUFJLENBQUM3SyxNQUFWLEVBQWtCNkssSUFBbEIsQ0FBakMsR0FBMkQrQyxPQUFNLENBQUN2USxFQUFELEVBQUt3TixJQUFMLEVBQVc5SyxJQUFYLENBQXhFO0tBRkY7O0lBSUEsSUFBSWxELFNBQVEsQ0FBQ1EsRUFBRSxDQUFDeUMsU0FBSixDQUFaLEVBQTRCNk4sS0FBSyxDQUFDN04sU0FBTixHQUFrQnpDLEVBQUUsQ0FBQ3lDLFNBQXJCO0lBQzVCLE9BQU82TixLQUFQO0VBQ0QsQ0FURDs7QUNaQXBOLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBVCxFQUFZLFVBQVosRUFBd0I7SUFBRThQLElBQUksRUFBRXBSO0VBQVIsQ0FBeEIsQ0FBUDs7RUNIQSxJQUFJb0IsSUFBRSxHQUFHcEIsU0FBdUIsQ0FBQ2lDLENBQWpDO0VBQ0EsSUFBSXVQLE1BQU0sR0FBR2hTLFFBQVEsQ0FBQ2lFLFNBQXRCO0VBQ0EsSUFBSWdPLE1BQU0sR0FBRyx1QkFBYjtFQUNBLElBQUlDLElBQUksR0FBRyxNQUFYOztFQUdBQSxJQUFJLElBQUlGLE1BQVIsSUFBa0IzUSxZQUF5QixJQUFJTyxJQUFFLENBQUNvUSxNQUFELEVBQVNFLElBQVQsRUFBZTtJQUM5RDVQLFlBQVksRUFBRSxJQURnRDtJQUU5RDNCLEdBQUcsRUFBRSxlQUFZO01BQ2YsSUFBSTtRQUNGLE9BQU8sQ0FBQyxLQUFLLElBQU4sRUFBWXdSLEtBQVosQ0FBa0JGLE1BQWxCLEVBQTBCLENBQTFCLENBQVA7T0FERixDQUVFLE9BQU8xUixDQUFQLEVBQVU7UUFDVixPQUFPLEVBQVA7OztFQU4wRCxDQUFmLENBQWpEOztFQ0hBLElBQUk2UixZQUFZLEdBQUc1UixJQUFpQixDQUFDLGFBQUQsQ0FBcEM7RUFDQSxJQUFJNlIsYUFBYSxHQUFHclMsUUFBUSxDQUFDaUUsU0FBN0I7O0VBRUEsSUFBSSxFQUFFbU8sWUFBWSxJQUFJQyxhQUFsQixDQUFKLEVBQXNDaFIsU0FBdUIsQ0FBQ29CLENBQXhCLENBQTBCNFAsYUFBMUIsRUFBeUNELFlBQXpDLEVBQXVEO0lBQUVqUSxLQUFLLEVBQUUsZUFBVU4sQ0FBVixFQUFhO01BQ2pILElBQUksT0FBTyxJQUFQLElBQWUsVUFBZixJQUE2QixDQUFDYixTQUFRLENBQUNhLENBQUQsQ0FBMUMsRUFBK0MsT0FBTyxLQUFQO01BQy9DLElBQUksQ0FBQ2IsU0FBUSxDQUFDLEtBQUtpRCxTQUFOLENBQWIsRUFBK0IsT0FBT3BDLENBQUMsWUFBWSxJQUFwQixDQUZrRjs7TUFJakgsT0FBT0EsQ0FBQyxHQUFHeU4sVUFBYyxDQUFDek4sQ0FBRCxDQUF6QjtRQUE4QixJQUFJLEtBQUtvQyxTQUFMLEtBQW1CcEMsQ0FBdkIsRUFBMEIsT0FBTyxJQUFQOzs7TUFDeEQsT0FBTyxLQUFQOztFQUwyRixDQUF2RDs7RUNOdEMsYUFBYyxHQUFHLHFFQUNmLGdGQURGOztFQ0lBLElBQUl5USxLQUFLLEdBQUcsTUFBTUMsU0FBTixHQUFlLEdBQTNCO0VBQ0EsSUFBSUMsR0FBRyxHQUFHLGNBQVY7RUFDQSxJQUFJQyxLQUFLLEdBQUdDLE1BQU0sQ0FBQyxNQUFNSixLQUFOLEdBQWNBLEtBQWQsR0FBc0IsR0FBdkIsQ0FBbEI7RUFDQSxJQUFJSyxLQUFLLEdBQUdELE1BQU0sQ0FBQ0osS0FBSyxHQUFHQSxLQUFSLEdBQWdCLElBQWpCLENBQWxCOztFQUVBLElBQUlNLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVU3TCxHQUFWLEVBQWV6RyxJQUFmLEVBQXFCdVMsS0FBckIsRUFBNEI7SUFDekMsSUFBSWxOLEdBQUcsR0FBRyxFQUFWO0lBQ0EsSUFBSW1OLEtBQUssR0FBR3pELE1BQUssQ0FBQyxZQUFZO01BQzVCLE9BQU8sQ0FBQyxDQUFDa0QsU0FBTSxDQUFDeEwsR0FBRCxDQUFOLEVBQUYsSUFBbUJ5TCxHQUFHLENBQUN6TCxHQUFELENBQUgsTUFBY3lMLEdBQXhDO0tBRGUsQ0FBakI7SUFHQSxJQUFJaFIsRUFBRSxHQUFHbUUsR0FBRyxDQUFDb0IsR0FBRCxDQUFILEdBQVcrTCxLQUFLLEdBQUd4UyxJQUFJLENBQUN5UyxJQUFELENBQVAsR0FBZ0JSLFNBQU0sQ0FBQ3hMLEdBQUQsQ0FBL0M7SUFDQSxJQUFJOEwsS0FBSixFQUFXbE4sR0FBRyxDQUFDa04sS0FBRCxDQUFILEdBQWFyUixFQUFiO0lBQ1hrRCxPQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZK04sS0FBekIsRUFBZ0MsUUFBaEMsRUFBMENuTixHQUExQyxDQUFQO0VBQ0QsQ0FSRDtFQVdBO0VBQ0E7OztFQUNBLElBQUlvTixJQUFJLEdBQUdILFFBQVEsQ0FBQ0csSUFBVCxHQUFnQixVQUFVQyxNQUFWLEVBQWtCQyxJQUFsQixFQUF3QjtJQUNqREQsTUFBTSxHQUFHaFAsTUFBTSxDQUFDZ0UsUUFBTyxDQUFDZ0wsTUFBRCxDQUFSLENBQWY7SUFDQSxJQUFJQyxJQUFJLEdBQUcsQ0FBWCxFQUFjRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlVCxLQUFmLEVBQXNCLEVBQXRCLENBQVQ7SUFDZCxJQUFJUSxJQUFJLEdBQUcsQ0FBWCxFQUFjRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlUCxLQUFmLEVBQXNCLEVBQXRCLENBQVQ7SUFDZCxPQUFPSyxNQUFQO0VBQ0QsQ0FMRDs7RUFPQSxlQUFjLEdBQUdKLFFBQWpCOztFQzdCQSxJQUFJTyxTQUFTLEdBQUczUyxPQUFvQixDQUFDNFMsUUFBckM7RUFDQSxJQUFJQyxLQUFLLEdBQUdoUyxXQUF5QixDQUFDMFIsSUFBdEM7RUFFQSxJQUFJTyxHQUFHLEdBQUcsYUFBVjs7RUFFQSxhQUFjLEdBQUdILFNBQVMsQ0FBQ0ksU0FBRSxHQUFHLElBQU4sQ0FBVCxLQUF5QixDQUF6QixJQUE4QkosU0FBUyxDQUFDSSxTQUFFLEdBQUcsTUFBTixDQUFULEtBQTJCLEVBQXpELEdBQThELFNBQVNILFFBQVQsQ0FBa0JJLEdBQWxCLEVBQXVCQyxLQUF2QixFQUE4QjtJQUMzRyxJQUFJVCxNQUFNLEdBQUdLLEtBQUssQ0FBQ3JQLE1BQU0sQ0FBQ3dQLEdBQUQsQ0FBUCxFQUFjLENBQWQsQ0FBbEI7SUFDQSxPQUFPTCxTQUFTLENBQUNILE1BQUQsRUFBVVMsS0FBSyxLQUFLLENBQVgsS0FBa0JILEdBQUcsQ0FBQ3ZDLElBQUosQ0FBU2lDLE1BQVQsSUFBbUIsRUFBbkIsR0FBd0IsRUFBMUMsQ0FBVCxDQUFoQjtFQUNELENBSGdCLEdBR2JHLFNBSEo7O0FDRkF6TyxTQUFPLENBQUNBLE9BQU8sQ0FBQ08sQ0FBUixHQUFZUCxPQUFPLENBQUNLLENBQVIsSUFBYXFPLFFBQVEsSUFBSUQsU0FBekIsQ0FBYixFQUFrRDtJQUFFQyxRQUFRLEVBQUVEO0VBQVosQ0FBbEQsQ0FBUDs7RUNIQSxJQUFJTyxXQUFXLEdBQUdsVCxPQUFvQixDQUFDbVQsVUFBdkM7RUFDQSxJQUFJTixPQUFLLEdBQUdoUyxXQUF5QixDQUFDMFIsSUFBdEM7O0VBRUEsZUFBYyxHQUFHLElBQUlXLFdBQVcsQ0FBQ3BTLFNBQXVCLEdBQUcsSUFBM0IsQ0FBZixLQUFvRCxDQUFDc1MsUUFBckQsR0FBZ0UsU0FBU0QsVUFBVCxDQUFvQkgsR0FBcEIsRUFBeUI7SUFDeEcsSUFBSVIsTUFBTSxHQUFHSyxPQUFLLENBQUNyUCxNQUFNLENBQUN3UCxHQUFELENBQVAsRUFBYyxDQUFkLENBQWxCO0lBQ0EsSUFBSXJLLE1BQU0sR0FBR3VLLFdBQVcsQ0FBQ1YsTUFBRCxDQUF4QjtJQUNBLE9BQU83SixNQUFNLEtBQUssQ0FBWCxJQUFnQjZKLE1BQU0sQ0FBQ3RMLE1BQVAsQ0FBYyxDQUFkLEtBQW9CLEdBQXBDLEdBQTBDLENBQUMsQ0FBM0MsR0FBK0N5QixNQUF0RDtFQUNELENBSmdCLEdBSWJ1SyxXQUpKOztBQ0FBaFAsU0FBTyxDQUFDQSxPQUFPLENBQUNPLENBQVIsR0FBWVAsT0FBTyxDQUFDSyxDQUFSLElBQWE0TyxVQUFVLElBQUlELFdBQTNCLENBQWIsRUFBc0Q7SUFBRUMsVUFBVSxFQUFFRDtFQUFkLENBQXRELENBQVA7O0VDRkEsSUFBSTVDLGNBQWMsR0FBR3RRLFNBQXVCLENBQUM0TixHQUE3Qzs7RUFDQSxzQkFBYyxHQUFHLDJCQUFBLENBQVVsSyxJQUFWLEVBQWdCb0IsTUFBaEIsRUFBd0J1TyxDQUF4QixFQUEyQjtJQUMxQyxJQUFJdFMsQ0FBQyxHQUFHK0QsTUFBTSxDQUFDaUssV0FBZjtJQUNBLElBQUl6TixDQUFKOztJQUNBLElBQUlQLENBQUMsS0FBS3NTLENBQU4sSUFBVyxPQUFPdFMsQ0FBUCxJQUFZLFVBQXZCLElBQXFDLENBQUNPLENBQUMsR0FBR1AsQ0FBQyxDQUFDMEMsU0FBUCxNQUFzQjRQLENBQUMsQ0FBQzVQLFNBQTdELElBQTBFakQsU0FBUSxDQUFDYyxDQUFELENBQWxGLElBQXlGZ1AsY0FBN0YsRUFBNkc7TUFDM0dBLGNBQWMsQ0FBQzVNLElBQUQsRUFBT3BDLENBQVAsQ0FBZDs7O0lBQ0EsT0FBT29DLElBQVA7RUFDSCxDQU5EOztFQ0tBLElBQUltSCxNQUFJLEdBQUc3SyxXQUF5QixDQUFDaUMsQ0FBckM7RUFDQSxJQUFJK0ksTUFBSSxHQUFHbkssV0FBeUIsQ0FBQ29CLENBQXJDO0VBQ0EsSUFBSWIsSUFBRSxHQUFHTixTQUF1QixDQUFDbUIsQ0FBakM7RUFDQSxJQUFJNFEsT0FBSyxHQUFHaEYsV0FBeUIsQ0FBQzBFLElBQXRDO0VBQ0EsSUFBSWUsTUFBTSxHQUFHLFFBQWI7RUFDQSxJQUFJQyxPQUFPLEdBQUdwVSxPQUFNLENBQUNtVSxNQUFELENBQXBCO0VBQ0EsSUFBSUUsSUFBSSxHQUFHRCxPQUFYO0VBQ0EsSUFBSWxELEtBQUssR0FBR2tELE9BQU8sQ0FBQzlQLFNBQXBCOztFQUVBLElBQUlnUSxVQUFVLEdBQUduTSxJQUFHLENBQUNxSCxhQUEyQixDQUFDMEIsS0FBRCxDQUE1QixDQUFILElBQTJDaUQsTUFBNUQ7RUFDQSxJQUFJSSxJQUFJLElBQUcsVUFBVWxRLE1BQU0sQ0FBQ0MsU0FBcEIsQ0FBUjs7RUFHQSxJQUFJa1EsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBVUMsUUFBVixFQUFvQjtJQUNqQyxJQUFJalUsRUFBRSxHQUFHOEIsWUFBVyxDQUFDbVMsUUFBRCxFQUFXLEtBQVgsQ0FBcEI7O0lBQ0EsSUFBSSxPQUFPalUsRUFBUCxJQUFhLFFBQWIsSUFBeUJBLEVBQUUsQ0FBQ2dFLE1BQUgsR0FBWSxDQUF6QyxFQUE0QztNQUMxQ2hFLEVBQUUsR0FBRytULElBQUksR0FBRy9ULEVBQUUsQ0FBQzRTLElBQUgsRUFBSCxHQUFlTSxPQUFLLENBQUNsVCxFQUFELEVBQUssQ0FBTCxDQUE3QjtNQUNBLElBQUlrVSxLQUFLLEdBQUdsVSxFQUFFLENBQUNtVSxVQUFILENBQWMsQ0FBZCxDQUFaO01BQ0EsSUFBSUMsS0FBSixFQUFXZCxLQUFYLEVBQWtCZSxPQUFsQjs7TUFDQSxJQUFJSCxLQUFLLEtBQUssRUFBVixJQUFnQkEsS0FBSyxLQUFLLEVBQTlCLEVBQWtDO1FBQ2hDRSxLQUFLLEdBQUdwVSxFQUFFLENBQUNtVSxVQUFILENBQWMsQ0FBZCxDQUFSO1FBQ0EsSUFBSUMsS0FBSyxLQUFLLEVBQVYsSUFBZ0JBLEtBQUssS0FBSyxHQUE5QixFQUFtQyxPQUFPRSxHQUFQLENBRkg7T0FBbEMsTUFHTyxJQUFJSixLQUFLLEtBQUssRUFBZCxFQUFrQjtRQUN2QixRQUFRbFUsRUFBRSxDQUFDbVUsVUFBSCxDQUFjLENBQWQsQ0FBUjtVQUNFLEtBQUssRUFBTDtVQUFTLEtBQUssRUFBTDtZQUFTYixLQUFLLEdBQUcsQ0FBUjtZQUFXZSxPQUFPLEdBQUcsRUFBVjtZQUFjOzs7VUFDM0MsS0FBSyxFQUFMO1VBQVMsS0FBSyxHQUFMO1lBQVVmLEtBQUssR0FBRyxDQUFSO1lBQVdlLE9BQU8sR0FBRyxFQUFWO1lBQWM7OztVQUM1QztZQUFTLE9BQU8sQ0FBQ3JVLEVBQVI7OztRQUVYLEtBQUssSUFBSXVVLE1BQU0sR0FBR3ZVLEVBQUUsQ0FBQ3lILEtBQUgsQ0FBUyxDQUFULENBQWIsRUFBMEJyQixDQUFDLEdBQUcsQ0FBOUIsRUFBaUNvSCxDQUFDLEdBQUcrRyxNQUFNLENBQUN2USxNQUE1QyxFQUFvRHdRLElBQXpELEVBQStEcE8sQ0FBQyxHQUFHb0gsQ0FBbkUsRUFBc0VwSCxDQUFDLEVBQXZFLEVBQTJFO1VBQ3pFb08sSUFBSSxHQUFHRCxNQUFNLENBQUNKLFVBQVAsQ0FBa0IvTixDQUFsQixDQUFQLENBRHlFOzs7VUFJekUsSUFBSW9PLElBQUksR0FBRyxFQUFQLElBQWFBLElBQUksR0FBR0gsT0FBeEIsRUFBaUMsT0FBT0MsR0FBUDs7O1FBQ2pDLE9BQU9yQixRQUFRLENBQUNzQixNQUFELEVBQVNqQixLQUFULENBQWY7Ozs7SUFFSixPQUFPLENBQUN0VCxFQUFSO0VBQ0gsQ0F2QkQ7O0VBeUJBLElBQUksQ0FBQzRULE9BQU8sQ0FBQyxNQUFELENBQVIsSUFBb0IsQ0FBQ0EsT0FBTyxDQUFDLEtBQUQsQ0FBNUIsSUFBdUNBLE9BQU8sQ0FBQyxNQUFELENBQWxELEVBQTREO0lBQzFEQSxPQUFPLEdBQUcsU0FBU2EsTUFBVCxDQUFnQnpTLEtBQWhCLEVBQXVCO01BQy9CLElBQUloQyxFQUFFLEdBQUdxRSxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FBdkIsR0FBMkJoQyxLQUFwQztNQUNBLElBQUkrQixJQUFJLEdBQUcsSUFBWDtNQUNBLE9BQU9BLElBQUksWUFBWTZQLE9BQWhCO1VBRURFLFVBQVUsR0FBRzVFLE1BQUssQ0FBQyxZQUFZO1FBQUV3QixLQUFLLENBQUNsUCxPQUFOLENBQWN0QixJQUFkLENBQW1CNkQsSUFBbkI7T0FBZixDQUFSLEdBQXNENEQsSUFBRyxDQUFDNUQsSUFBRCxDQUFILElBQWE0UCxNQUY1RSxJQUdEZSxrQkFBaUIsQ0FBQyxJQUFJYixJQUFKLENBQVNHLFFBQVEsQ0FBQ2hVLEVBQUQsQ0FBakIsQ0FBRCxFQUF5QitELElBQXpCLEVBQStCNlAsT0FBL0IsQ0FIaEIsR0FHMERJLFFBQVEsQ0FBQ2hVLEVBQUQsQ0FIekU7S0FIRjs7SUFRQSxLQUFLLElBQUlpSixJQUFJLEdBQUcwTCxZQUF5QixHQUFHekosTUFBSSxDQUFDMkksSUFBRCxDQUFQLEdBQWdCO0lBRXZEO0lBRUEsa0VBRkEsR0FHQSxnREFMdUQsRUFNdkR2USxLQU51RCxDQU1qRCxHQU5pRCxDQUFwRCxFQU1TOEssR0FBQyxHQUFHLENBTmIsRUFNZ0JuTyxHQU5yQixFQU0wQmdKLElBQUksQ0FBQ2pGLE1BQUwsR0FBY29LLEdBTnhDLEVBTTJDQSxHQUFDLEVBTjVDLEVBTWdEO01BQzlDLElBQUkxSyxJQUFHLENBQUNtUSxJQUFELEVBQU81VCxHQUFHLEdBQUdnSixJQUFJLENBQUNtRixHQUFELENBQWpCLENBQUgsSUFBNEIsQ0FBQzFLLElBQUcsQ0FBQ2tRLE9BQUQsRUFBVTNULEdBQVYsQ0FBcEMsRUFBb0Q7UUFDbER3QixJQUFFLENBQUNtUyxPQUFELEVBQVUzVCxHQUFWLEVBQWVvTCxNQUFJLENBQUN3SSxJQUFELEVBQU81VCxHQUFQLENBQW5CLENBQUY7Ozs7SUFHSjJULE9BQU8sQ0FBQzlQLFNBQVIsR0FBb0I0TSxLQUFwQjtJQUNBQSxLQUFLLENBQUN0QixXQUFOLEdBQW9Cd0UsT0FBcEI7SUFDQWdCLFNBQXNCLENBQUNwVixPQUFELEVBQVNtVSxNQUFULEVBQWlCQyxPQUFqQixDQUF0Qjs7O0VDbEVGLGlCQUFjLEdBQUcsc0JBQUEsQ0FBVTVULEVBQVYsRUFBYzZVLEdBQWQsRUFBbUI7SUFDbEMsSUFBSSxPQUFPN1UsRUFBUCxJQUFhLFFBQWIsSUFBeUIySCxJQUFHLENBQUMzSCxFQUFELENBQUgsSUFBVyxRQUF4QyxFQUFrRCxNQUFNYyxTQUFTLENBQUMrVCxHQUFELENBQWY7SUFDbEQsT0FBTyxDQUFDN1UsRUFBUjtFQUNELENBSEQ7O0VDR0EsaUJBQWMsR0FBRyxTQUFTOFUsTUFBVCxDQUFnQkMsS0FBaEIsRUFBdUI7SUFDdEMsSUFBSTFCLEdBQUcsR0FBR3hQLE1BQU0sQ0FBQ2dFLFFBQU8sQ0FBQyxJQUFELENBQVIsQ0FBaEI7SUFDQSxJQUFJbU4sR0FBRyxHQUFHLEVBQVY7SUFDQSxJQUFJeEQsQ0FBQyxHQUFHdEosVUFBUyxDQUFDNk0sS0FBRCxDQUFqQjtJQUNBLElBQUl2RCxDQUFDLEdBQUcsQ0FBSixJQUFTQSxDQUFDLElBQUlpQyxRQUFsQixFQUE0QixNQUFNd0IsVUFBVSxDQUFDLHlCQUFELENBQWhCOztJQUM1QixPQUFNekQsQ0FBQyxHQUFHLENBQVYsRUFBYSxDQUFDQSxDQUFDLE1BQU0sQ0FBUixNQUFlNkIsR0FBRyxJQUFJQSxHQUF0QixDQUFiO01BQXlDLElBQUk3QixDQUFDLEdBQUcsQ0FBUixFQUFXd0QsR0FBRyxJQUFJM0IsR0FBUDs7O0lBQ3BELE9BQU8yQixHQUFQO0VBQ0QsQ0FQRDs7RUNDQSxJQUFJRSxRQUFRLEdBQUcsSUFBSUMsT0FBbkI7RUFDQSxJQUFJcE4sT0FBSyxHQUFHcEksSUFBSSxDQUFDb0ksS0FBakI7RUFDQSxJQUFJcU4sSUFBSSxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBWDtFQUNBLElBQUlDLEtBQUssR0FBRyx1Q0FBWjtFQUNBLElBQUlDLElBQUksR0FBRyxHQUFYOztFQUVBLElBQUlDLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVUvRCxDQUFWLEVBQWFyTixDQUFiLEVBQWdCO0lBQzdCLElBQUlpQyxDQUFDLEdBQUcsQ0FBQyxDQUFUO0lBQ0EsSUFBSW9QLEVBQUUsR0FBR3JSLENBQVQ7O0lBQ0EsT0FBTyxFQUFFaUMsQ0FBRixHQUFNLENBQWIsRUFBZ0I7TUFDZG9QLEVBQUUsSUFBSWhFLENBQUMsR0FBRzRELElBQUksQ0FBQ2hQLENBQUQsQ0FBZDtNQUNBZ1AsSUFBSSxDQUFDaFAsQ0FBRCxDQUFKLEdBQVVvUCxFQUFFLEdBQUcsR0FBZjtNQUNBQSxFQUFFLEdBQUd6TixPQUFLLENBQUN5TixFQUFFLEdBQUcsR0FBTixDQUFWOztFQUVILENBUkQ7O0VBU0EsSUFBSUMsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVWpFLENBQVYsRUFBYTtJQUN4QixJQUFJcEwsQ0FBQyxHQUFHLENBQVI7SUFDQSxJQUFJakMsQ0FBQyxHQUFHLENBQVI7O0lBQ0EsT0FBTyxFQUFFaUMsQ0FBRixJQUFPLENBQWQsRUFBaUI7TUFDZmpDLENBQUMsSUFBSWlSLElBQUksQ0FBQ2hQLENBQUQsQ0FBVDtNQUNBZ1AsSUFBSSxDQUFDaFAsQ0FBRCxDQUFKLEdBQVUyQixPQUFLLENBQUM1RCxDQUFDLEdBQUdxTixDQUFMLENBQWY7TUFDQXJOLENBQUMsR0FBSUEsQ0FBQyxHQUFHcU4sQ0FBTCxHQUFVLEdBQWQ7O0VBRUgsQ0FSRDs7RUFTQSxJQUFJa0UsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBWTtJQUM1QixJQUFJdFAsQ0FBQyxHQUFHLENBQVI7SUFDQSxJQUFJdVAsQ0FBQyxHQUFHLEVBQVI7O0lBQ0EsT0FBTyxFQUFFdlAsQ0FBRixJQUFPLENBQWQsRUFBaUI7TUFDZixJQUFJdVAsQ0FBQyxLQUFLLEVBQU4sSUFBWXZQLENBQUMsS0FBSyxDQUFsQixJQUF1QmdQLElBQUksQ0FBQ2hQLENBQUQsQ0FBSixLQUFZLENBQXZDLEVBQTBDO1FBQ3hDLElBQUl3UCxDQUFDLEdBQUcvUixNQUFNLENBQUN1UixJQUFJLENBQUNoUCxDQUFELENBQUwsQ0FBZDtRQUNBdVAsQ0FBQyxHQUFHQSxDQUFDLEtBQUssRUFBTixHQUFXQyxDQUFYLEdBQWVELENBQUMsR0FBR2IsYUFBTSxDQUFDNVUsSUFBUCxDQUFZb1YsSUFBWixFQUFrQixJQUFJTSxDQUFDLENBQUM1UixNQUF4QixDQUFKLEdBQXNDNFIsQ0FBekQ7Ozs7SUFFRixPQUFPRCxDQUFQO0VBQ0gsQ0FURDs7RUFVQSxJQUFJRSxHQUFHLEdBQUcsU0FBTkEsR0FBTSxDQUFVdEYsQ0FBVixFQUFhaUIsQ0FBYixFQUFnQnNFLEdBQWhCLEVBQXFCO0lBQzdCLE9BQU90RSxDQUFDLEtBQUssQ0FBTixHQUFVc0UsR0FBVixHQUFnQnRFLENBQUMsR0FBRyxDQUFKLEtBQVUsQ0FBVixHQUFjcUUsR0FBRyxDQUFDdEYsQ0FBRCxFQUFJaUIsQ0FBQyxHQUFHLENBQVIsRUFBV3NFLEdBQUcsR0FBR3ZGLENBQWpCLENBQWpCLEdBQXVDc0YsR0FBRyxDQUFDdEYsQ0FBQyxHQUFHQSxDQUFMLEVBQVFpQixDQUFDLEdBQUcsQ0FBWixFQUFlc0UsR0FBZixDQUFqRTtFQUNELENBRkQ7O0VBR0EsSUFBSUMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBVXhGLENBQVYsRUFBYTtJQUNyQixJQUFJaUIsQ0FBQyxHQUFHLENBQVI7SUFDQSxJQUFJd0UsRUFBRSxHQUFHekYsQ0FBVDs7SUFDQSxPQUFPeUYsRUFBRSxJQUFJLElBQWIsRUFBbUI7TUFDakJ4RSxDQUFDLElBQUksRUFBTDtNQUNBd0UsRUFBRSxJQUFJLElBQU47OztJQUVGLE9BQU9BLEVBQUUsSUFBSSxDQUFiLEVBQWdCO01BQ2R4RSxDQUFDLElBQUksQ0FBTDtNQUNBd0UsRUFBRSxJQUFJLENBQU47OztJQUNBLE9BQU94RSxDQUFQO0VBQ0gsQ0FYRDs7QUFhQWpOLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLElBQWEsQ0FBQyxDQUFDc1EsUUFBRixLQUMvQixRQUFRQyxPQUFSLENBQWdCLENBQWhCLE1BQXVCLE9BQXZCLElBQ0EsSUFBSUEsT0FBSixDQUFZLENBQVosTUFBbUIsR0FEbkIsSUFFQSxNQUFNQSxPQUFOLENBQWMsQ0FBZCxNQUFxQixNQUZyQixJQUdBLHNCQUFzQkEsT0FBdEIsQ0FBOEIsQ0FBOUIsTUFBcUMscUJBSk4sS0FLNUIsQ0FBQzlVLE1BQW1CLENBQUMsWUFBWTs7SUFFcEM2VSxRQUFRLENBQUNoVixJQUFULENBQWMsRUFBZDtFQUNELENBSHdCLENBTEwsQ0FBYixFQVFGLFFBUkUsRUFRUTtJQUNiaVYsT0FBTyxFQUFFLFNBQVNBLE9BQVQsQ0FBaUJjLGNBQWpCLEVBQWlDO01BQ3hDLElBQUkxRixDQUFDLEdBQUcyRixhQUFZLENBQUMsSUFBRCxFQUFPYixLQUFQLENBQXBCO01BQ0EsSUFBSS9TLENBQUMsR0FBRzRGLFVBQVMsQ0FBQytOLGNBQUQsQ0FBakI7TUFDQSxJQUFJTixDQUFDLEdBQUcsRUFBUjtNQUNBLElBQUlRLENBQUMsR0FBR2IsSUFBUjtNQUNBLElBQUlsVixDQUFKLEVBQU9nVyxDQUFQLEVBQVVoSSxDQUFWLEVBQWFFLENBQWI7TUFDQSxJQUFJaE0sQ0FBQyxHQUFHLENBQUosSUFBU0EsQ0FBQyxHQUFHLEVBQWpCLEVBQXFCLE1BQU0yUyxVQUFVLENBQUNJLEtBQUQsQ0FBaEIsQ0FObUI7O01BUXhDLElBQUk5RSxDQUFDLElBQUlBLENBQVQsRUFBWSxPQUFPLEtBQVA7TUFDWixJQUFJQSxDQUFDLElBQUksQ0FBQyxJQUFOLElBQWNBLENBQUMsSUFBSSxJQUF2QixFQUE2QixPQUFPMU0sTUFBTSxDQUFDME0sQ0FBRCxDQUFiOztNQUM3QixJQUFJQSxDQUFDLEdBQUcsQ0FBUixFQUFXO1FBQ1RvRixDQUFDLEdBQUcsR0FBSjtRQUNBcEYsQ0FBQyxHQUFHLENBQUNBLENBQUw7OztNQUVGLElBQUlBLENBQUMsR0FBRyxLQUFSLEVBQWU7UUFDYm5RLENBQUMsR0FBRzJWLEdBQUcsQ0FBQ3hGLENBQUMsR0FBR3NGLEdBQUcsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLENBQVIsQ0FBUixDQUFILEdBQXlCLEVBQTdCO1FBQ0FPLENBQUMsR0FBR2hXLENBQUMsR0FBRyxDQUFKLEdBQVFtUSxDQUFDLEdBQUdzRixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUN6VixDQUFMLEVBQVEsQ0FBUixDQUFmLEdBQTRCbVEsQ0FBQyxHQUFHc0YsR0FBRyxDQUFDLENBQUQsRUFBSXpWLENBQUosRUFBTyxDQUFQLENBQXZDO1FBQ0FnVyxDQUFDLElBQUksZ0JBQUw7UUFDQWhXLENBQUMsR0FBRyxLQUFLQSxDQUFUOztRQUNBLElBQUlBLENBQUMsR0FBRyxDQUFSLEVBQVc7VUFDVG1WLFFBQVEsQ0FBQyxDQUFELEVBQUlhLENBQUosQ0FBUjtVQUNBaEksQ0FBQyxHQUFHOUwsQ0FBSjs7VUFDQSxPQUFPOEwsQ0FBQyxJQUFJLENBQVosRUFBZTtZQUNibUgsUUFBUSxDQUFDLEdBQUQsRUFBTSxDQUFOLENBQVI7WUFDQW5ILENBQUMsSUFBSSxDQUFMOzs7VUFFRm1ILFFBQVEsQ0FBQ00sR0FBRyxDQUFDLEVBQUQsRUFBS3pILENBQUwsRUFBUSxDQUFSLENBQUosRUFBZ0IsQ0FBaEIsQ0FBUjtVQUNBQSxDQUFDLEdBQUdoTyxDQUFDLEdBQUcsQ0FBUjs7VUFDQSxPQUFPZ08sQ0FBQyxJQUFJLEVBQVosRUFBZ0I7WUFDZHFILE1BQU0sQ0FBQyxLQUFLLEVBQU4sQ0FBTjtZQUNBckgsQ0FBQyxJQUFJLEVBQUw7OztVQUVGcUgsTUFBTSxDQUFDLEtBQUtySCxDQUFOLENBQU47VUFDQW1ILFFBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFSO1VBQ0FFLE1BQU0sQ0FBQyxDQUFELENBQU47VUFDQVUsQ0FBQyxHQUFHVCxXQUFXLEVBQWY7U0FoQkYsTUFpQk87VUFDTEgsUUFBUSxDQUFDLENBQUQsRUFBSWEsQ0FBSixDQUFSO1VBQ0FiLFFBQVEsQ0FBQyxLQUFLLENBQUNuVixDQUFQLEVBQVUsQ0FBVixDQUFSO1VBQ0ErVixDQUFDLEdBQUdULFdBQVcsS0FBS1osYUFBTSxDQUFDNVUsSUFBUCxDQUFZb1YsSUFBWixFQUFrQmhULENBQWxCLENBQXBCOzs7O01BR0osSUFBSUEsQ0FBQyxHQUFHLENBQVIsRUFBVztRQUNUZ00sQ0FBQyxHQUFHNkgsQ0FBQyxDQUFDblMsTUFBTjtRQUNBbVMsQ0FBQyxHQUFHUixDQUFDLElBQUlySCxDQUFDLElBQUloTSxDQUFMLEdBQVMsT0FBT3dTLGFBQU0sQ0FBQzVVLElBQVAsQ0FBWW9WLElBQVosRUFBa0JoVCxDQUFDLEdBQUdnTSxDQUF0QixDQUFQLEdBQWtDNkgsQ0FBM0MsR0FBK0NBLENBQUMsQ0FBQzFPLEtBQUYsQ0FBUSxDQUFSLEVBQVc2RyxDQUFDLEdBQUdoTSxDQUFmLElBQW9CLEdBQXBCLEdBQTBCNlQsQ0FBQyxDQUFDMU8sS0FBRixDQUFRNkcsQ0FBQyxHQUFHaE0sQ0FBWixDQUE3RSxDQUFMO09BRkYsTUFHTztRQUNMNlQsQ0FBQyxHQUFHUixDQUFDLEdBQUdRLENBQVI7OztNQUNBLE9BQU9BLENBQVA7O0VBaERTLENBUlIsQ0FBUDs7RUNuREEsSUFBSUUsWUFBWSxHQUFHLElBQUlDLFdBQXZCO0FBRUEvUixTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixJQUFhZ0ksTUFBTSxDQUFDLFlBQVk7O0lBRWxELE9BQU95SixZQUFZLENBQUNuVyxJQUFiLENBQWtCLENBQWxCLEVBQXFCMEMsU0FBckIsTUFBb0MsR0FBM0M7RUFDRCxDQUhzQyxDQUFOLElBRzNCLENBQUNnSyxNQUFNLENBQUMsWUFBWTs7SUFFeEJ5SixZQUFZLENBQUNuVyxJQUFiLENBQWtCLEVBQWxCO0VBQ0QsQ0FIWSxDQUhPLENBQWIsRUFNRixRQU5FLEVBTVE7SUFDYm9XLFdBQVcsRUFBRSxTQUFTQSxXQUFULENBQXFCQyxTQUFyQixFQUFnQztNQUMzQyxJQUFJeFMsSUFBSSxHQUFHbVMsYUFBWSxDQUFDLElBQUQsRUFBTywyQ0FBUCxDQUF2QjtNQUNBLE9BQU9LLFNBQVMsS0FBSzNULFNBQWQsR0FBMEJ5VCxZQUFZLENBQUNuVyxJQUFiLENBQWtCNkQsSUFBbEIsQ0FBMUIsR0FBb0RzUyxZQUFZLENBQUNuVyxJQUFiLENBQWtCNkQsSUFBbEIsRUFBd0J3UyxTQUF4QixDQUEzRDs7RUFIVyxDQU5SLENBQVA7O0FDSEFoUyxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxRQUFaLEVBQXNCO0lBQUVvVixPQUFPLEVBQUU3VyxJQUFJLENBQUNrVyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYjtFQUFYLENBQXRCLENBQVA7O0VDREEsSUFBSVksU0FBUyxHQUFHcFcsT0FBb0IsQ0FBQ3FXLFFBQXJDO0FBRUFuUyxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxRQUFaLEVBQXNCO0lBQzNCc1YsUUFBUSxFQUFFLFNBQVNBLFFBQVQsQ0FBa0IxVyxFQUFsQixFQUFzQjtNQUM5QixPQUFPLE9BQU9BLEVBQVAsSUFBYSxRQUFiLElBQXlCeVcsU0FBUyxDQUFDelcsRUFBRCxDQUF6Qzs7RUFGeUIsQ0FBdEIsQ0FBUDs7RUNGQSxJQUFJK0gsT0FBSyxHQUFHcEksSUFBSSxDQUFDb0ksS0FBakI7O0VBQ0EsY0FBYyxHQUFHLFNBQVM0TyxTQUFULENBQW1CM1csRUFBbkIsRUFBdUI7SUFDdEMsT0FBTyxDQUFDYSxTQUFRLENBQUNiLEVBQUQsQ0FBVCxJQUFpQjBXLFFBQVEsQ0FBQzFXLEVBQUQsQ0FBekIsSUFBaUMrSCxPQUFLLENBQUMvSCxFQUFELENBQUwsS0FBY0EsRUFBdEQ7RUFDRCxDQUZEOztBQ0FBdUUsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUFFdVYsU0FBUyxFQUFFdFc7RUFBYixDQUF0QixDQUFQOztBQ0FBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUMzQjRHLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWU0TyxNQUFmLEVBQXVCOztNQUU1QixPQUFPQSxNQUFNLElBQUlBLE1BQWpCOztFQUh5QixDQUF0QixDQUFQOztFQ0FBLElBQUlDLEdBQUcsR0FBR2xYLElBQUksQ0FBQ2tYLEdBQWY7QUFFQXRTLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFFBQVosRUFBc0I7SUFDM0IwVixhQUFhLEVBQUUsU0FBU0EsYUFBVCxDQUF1QkYsTUFBdkIsRUFBK0I7TUFDNUMsT0FBT0QsVUFBUyxDQUFDQyxNQUFELENBQVQsSUFBcUJDLEdBQUcsQ0FBQ0QsTUFBRCxDQUFILElBQWUsZ0JBQTNDOztFQUZ5QixDQUF0QixDQUFQOztBQ0ZBclMsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUFFMlYsZ0JBQWdCLEVBQUU7RUFBcEIsQ0FBdEIsQ0FBUDs7QUNBQXhTLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFFBQVosRUFBc0I7SUFBRTRWLGdCQUFnQixFQUFFLENBQUM7RUFBckIsQ0FBdEIsQ0FBUDs7QUNBQXpTLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLElBQWE2UCxNQUFNLENBQUNqQixVQUFQLElBQXFCRCxXQUFsQyxDQUFiLEVBQTZELFFBQTdELEVBQXVFO0lBQUVDLFVBQVUsRUFBRUQ7RUFBZCxDQUF2RSxDQUFQOztBQ0FBaFAsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsSUFBYTZQLE1BQU0sQ0FBQ3hCLFFBQVAsSUFBbUJELFNBQWhDLENBQWIsRUFBeUQsUUFBekQsRUFBbUU7SUFBRUMsUUFBUSxFQUFFRDtFQUFaLENBQW5FLENBQVA7O0VDSEE7RUFDQSxjQUFjLEdBQUdyVCxJQUFJLENBQUNzWCxLQUFMLElBQWMsU0FBU0EsS0FBVCxDQUFlMUcsQ0FBZixFQUFrQjtJQUMvQyxPQUFPLENBQUNBLENBQUMsR0FBRyxDQUFDQSxDQUFOLElBQVcsQ0FBQyxJQUFaLElBQW9CQSxDQUFDLEdBQUcsSUFBeEIsR0FBK0JBLENBQUMsR0FBR0EsQ0FBQyxHQUFHQSxDQUFKLEdBQVEsQ0FBM0MsR0FBK0M1USxJQUFJLENBQUNvVyxHQUFMLENBQVMsSUFBSXhGLENBQWIsQ0FBdEQ7RUFDRCxDQUZEOztFQ0VBLElBQUkyRyxJQUFJLEdBQUd2WCxJQUFJLENBQUN1WCxJQUFoQjtFQUNBLElBQUlDLE1BQU0sR0FBR3hYLElBQUksQ0FBQ3lYLEtBQWxCO0FBRUE3UyxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLEVBQUV1UyxNQUFNO0VBQUEsR0FFbkN4WCxJQUFJLENBQUNvSSxLQUFMLENBQVdvUCxNQUFNLENBQUMxQyxNQUFNLENBQUM0QyxTQUFSLENBQWpCLEtBQXdDLEdBRlg7RUFBQSxHQUk3QkYsTUFBTSxDQUFDMUQsUUFBRCxDQUFOLElBQW9CQSxRQUpPLENBQXpCLEVBS0osTUFMSSxFQUtJO0lBQ1QyRCxLQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlN0csQ0FBZixFQUFrQjtNQUN2QixPQUFPLENBQUNBLENBQUMsR0FBRyxDQUFDQSxDQUFOLElBQVcsQ0FBWCxHQUFlK0QsR0FBZixHQUFxQi9ELENBQUMsR0FBRyxpQkFBSixHQUN4QjVRLElBQUksQ0FBQ29XLEdBQUwsQ0FBU3hGLENBQVQsSUFBYzVRLElBQUksQ0FBQzJYLEdBREssR0FFeEJMLFVBQUssQ0FBQzFHLENBQUMsR0FBRyxDQUFKLEdBQVEyRyxJQUFJLENBQUMzRyxDQUFDLEdBQUcsQ0FBTCxDQUFKLEdBQWMyRyxJQUFJLENBQUMzRyxDQUFDLEdBQUcsQ0FBTCxDQUEzQixDQUZUOztFQUZPLENBTEosQ0FBUDs7RUNKQSxJQUFJZ0gsTUFBTSxHQUFHNVgsSUFBSSxDQUFDNlgsS0FBbEI7O0VBRUEsU0FBU0EsS0FBVCxDQUFlakgsQ0FBZixFQUFrQjtJQUNoQixPQUFPLENBQUNtRyxRQUFRLENBQUNuRyxDQUFDLEdBQUcsQ0FBQ0EsQ0FBTixDQUFULElBQXFCQSxDQUFDLElBQUksQ0FBMUIsR0FBOEJBLENBQTlCLEdBQWtDQSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQUNpSCxLQUFLLENBQUMsQ0FBQ2pILENBQUYsQ0FBZCxHQUFxQjVRLElBQUksQ0FBQ29XLEdBQUwsQ0FBU3hGLENBQUMsR0FBRzVRLElBQUksQ0FBQ3VYLElBQUwsQ0FBVTNHLENBQUMsR0FBR0EsQ0FBSixHQUFRLENBQWxCLENBQWIsQ0FBOUQ7RUFDRDs7O0FBR0RoTSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLEVBQUUyUyxNQUFNLElBQUksSUFBSUEsTUFBTSxDQUFDLENBQUQsQ0FBVixHQUFnQixDQUE1QixDQUF6QixFQUF5RCxNQUF6RCxFQUFpRTtJQUFFQyxLQUFLLEVBQUVBO0VBQVQsQ0FBakUsQ0FBUDs7RUNQQSxJQUFJQyxNQUFNLEdBQUc5WCxJQUFJLENBQUMrWCxLQUFsQjs7QUFHQW5ULFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVksRUFBRTZTLE1BQU0sSUFBSSxJQUFJQSxNQUFNLENBQUMsQ0FBQyxDQUFGLENBQVYsR0FBaUIsQ0FBN0IsQ0FBekIsRUFBMEQsTUFBMUQsRUFBa0U7SUFDdkVDLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWVuSCxDQUFmLEVBQWtCO01BQ3ZCLE9BQU8sQ0FBQ0EsQ0FBQyxHQUFHLENBQUNBLENBQU4sS0FBWSxDQUFaLEdBQWdCQSxDQUFoQixHQUFvQjVRLElBQUksQ0FBQ29XLEdBQUwsQ0FBUyxDQUFDLElBQUl4RixDQUFMLEtBQVcsSUFBSUEsQ0FBZixDQUFULElBQThCLENBQXpEOztFQUZxRSxDQUFsRSxDQUFQOztFQ0xBO0VBQ0EsYUFBYyxHQUFHNVEsSUFBSSxDQUFDZ1ksSUFBTCxJQUFhLFNBQVNBLElBQVQsQ0FBY3BILENBQWQsRUFBaUI7O0lBRTdDLE9BQU8sQ0FBQ0EsQ0FBQyxHQUFHLENBQUNBLENBQU4sS0FBWSxDQUFaLElBQWlCQSxDQUFDLElBQUlBLENBQXRCLEdBQTBCQSxDQUExQixHQUE4QkEsQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFDLENBQVQsR0FBYSxDQUFsRDtFQUNELENBSEQ7O0FDR0FoTSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxNQUFaLEVBQW9CO0lBQ3pCd1csSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY3JILENBQWQsRUFBaUI7TUFDckIsT0FBT29ILFNBQUksQ0FBQ3BILENBQUMsR0FBRyxDQUFDQSxDQUFOLENBQUosR0FBZTVRLElBQUksQ0FBQ2tXLEdBQUwsQ0FBU2xXLElBQUksQ0FBQ2tYLEdBQUwsQ0FBU3RHLENBQVQsQ0FBVCxFQUFzQixJQUFJLENBQTFCLENBQXRCOztFQUZ1QixDQUFwQixDQUFQOztBQ0RBaE0sU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksTUFBWixFQUFvQjtJQUN6QnlXLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWV0SCxDQUFmLEVBQWtCO01BQ3ZCLE9BQU8sQ0FBQ0EsQ0FBQyxNQUFNLENBQVIsSUFBYSxLQUFLNVEsSUFBSSxDQUFDb0ksS0FBTCxDQUFXcEksSUFBSSxDQUFDb1csR0FBTCxDQUFTeEYsQ0FBQyxHQUFHLEdBQWIsSUFBb0I1USxJQUFJLENBQUNtWSxLQUFwQyxDQUFsQixHQUErRCxFQUF0RTs7RUFGdUIsQ0FBcEIsQ0FBUDs7RUNEQSxJQUFJdFMsR0FBRyxHQUFHN0YsSUFBSSxDQUFDNkYsR0FBZjtBQUVBakIsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksTUFBWixFQUFvQjtJQUN6QjJXLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWN4SCxDQUFkLEVBQWlCO01BQ3JCLE9BQU8sQ0FBQy9LLEdBQUcsQ0FBQytLLENBQUMsR0FBRyxDQUFDQSxDQUFOLENBQUgsR0FBYy9LLEdBQUcsQ0FBQyxDQUFDK0ssQ0FBRixDQUFsQixJQUEwQixDQUFqQzs7RUFGdUIsQ0FBcEIsQ0FBUDs7RUNKQTtFQUNBLElBQUl5SCxNQUFNLEdBQUdyWSxJQUFJLENBQUNzWSxLQUFsQjs7RUFDQSxjQUFjLEdBQUksQ0FBQ0QsTUFBRDtFQUFBLEdBRWJBLE1BQU0sQ0FBQyxFQUFELENBQU4sR0FBYSxrQkFGQSxJQUVzQkEsTUFBTSxDQUFDLEVBQUQsQ0FBTixHQUFhLHNCQUZuQztFQUFBLEdBSWJBLE1BQU0sQ0FBQyxDQUFDLEtBQUYsQ0FBTixJQUFrQixDQUFDLEtBSlAsR0FLYixTQUFTQyxLQUFULENBQWUxSCxDQUFmLEVBQWtCO0lBQ3BCLE9BQU8sQ0FBQ0EsQ0FBQyxHQUFHLENBQUNBLENBQU4sS0FBWSxDQUFaLEdBQWdCQSxDQUFoQixHQUFvQkEsQ0FBQyxHQUFHLENBQUMsSUFBTCxJQUFhQSxDQUFDLEdBQUcsSUFBakIsR0FBd0JBLENBQUMsR0FBR0EsQ0FBQyxHQUFHQSxDQUFKLEdBQVEsQ0FBcEMsR0FBd0M1USxJQUFJLENBQUM2RixHQUFMLENBQVMrSyxDQUFULElBQWMsQ0FBakY7RUFDRCxDQVBnQixHQU9ieUgsTUFQSjs7QUNFQXpULFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLElBQWFvVCxVQUFNLElBQUlyWSxJQUFJLENBQUNzWSxLQUE1QixDQUFiLEVBQWlELE1BQWpELEVBQXlEO0lBQUVBLEtBQUssRUFBRUQ7RUFBVCxDQUF6RCxDQUFQOztFQ0ZBLElBQUluQyxLQUFHLEdBQUdsVyxJQUFJLENBQUNrVyxHQUFmO0VBQ0EsSUFBSVcsT0FBTyxHQUFHWCxLQUFHLENBQUMsQ0FBRCxFQUFJLENBQUMsRUFBTCxDQUFqQjtFQUNBLElBQUlxQyxTQUFTLEdBQUdyQyxLQUFHLENBQUMsQ0FBRCxFQUFJLENBQUMsRUFBTCxDQUFuQjtFQUNBLElBQUlzQyxLQUFLLEdBQUd0QyxLQUFHLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FBSCxJQUFlLElBQUlxQyxTQUFuQixDQUFaO0VBQ0EsSUFBSUUsS0FBSyxHQUFHdkMsS0FBRyxDQUFDLENBQUQsRUFBSSxDQUFDLEdBQUwsQ0FBZjs7RUFFQSxJQUFJd0MsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFVN0csQ0FBVixFQUFhO0lBQ2pDLE9BQU9BLENBQUMsR0FBRyxJQUFJZ0YsT0FBUixHQUFrQixJQUFJQSxPQUE3QjtFQUNELENBRkQ7O0VBSUEsZUFBYyxHQUFHN1csSUFBSSxDQUFDMlksTUFBTCxJQUFlLFNBQVNBLE1BQVQsQ0FBZ0IvSCxDQUFoQixFQUFtQjtJQUNqRCxJQUFJZ0ksSUFBSSxHQUFHNVksSUFBSSxDQUFDa1gsR0FBTCxDQUFTdEcsQ0FBVCxDQUFYO0lBQ0EsSUFBSWlJLEtBQUssR0FBR2IsU0FBSSxDQUFDcEgsQ0FBRCxDQUFoQjtJQUNBLElBQUk5UCxDQUFKLEVBQU91SSxNQUFQO0lBQ0EsSUFBSXVQLElBQUksR0FBR0gsS0FBWCxFQUFrQixPQUFPSSxLQUFLLEdBQUdILGVBQWUsQ0FBQ0UsSUFBSSxHQUFHSCxLQUFQLEdBQWVGLFNBQWhCLENBQXZCLEdBQW9ERSxLQUFwRCxHQUE0REYsU0FBbkU7SUFDbEJ6WCxDQUFDLEdBQUcsQ0FBQyxJQUFJeVgsU0FBUyxHQUFHMUIsT0FBakIsSUFBNEIrQixJQUFoQztJQUNBdlAsTUFBTSxHQUFHdkksQ0FBQyxJQUFJQSxDQUFDLEdBQUc4WCxJQUFSLENBQVYsQ0FOaUQ7O0lBUWpELElBQUl2UCxNQUFNLEdBQUdtUCxLQUFULElBQWtCblAsTUFBTSxJQUFJQSxNQUFoQyxFQUF3QyxPQUFPd1AsS0FBSyxHQUFHL0UsUUFBZjtJQUN4QyxPQUFPK0UsS0FBSyxHQUFHeFAsTUFBZjtFQUNELENBVkQ7O0FDVEF6RSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxNQUFaLEVBQW9CO0lBQUVrWCxNQUFNLEVBQUVqWTtFQUFWLENBQXBCLENBQVA7O0VDREEsSUFBSXdXLEtBQUcsR0FBR2xYLElBQUksQ0FBQ2tYLEdBQWY7QUFFQXRTLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLE1BQVosRUFBb0I7SUFDekJxWCxLQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlQyxNQUFmLEVBQXVCQyxNQUF2QixFQUErQjs7TUFDcEMsSUFBSUMsR0FBRyxHQUFHLENBQVY7TUFDQSxJQUFJeFMsQ0FBQyxHQUFHLENBQVI7TUFDQSxJQUFJa0ssSUFBSSxHQUFHak0sU0FBUyxDQUFDTCxNQUFyQjtNQUNBLElBQUk2VSxJQUFJLEdBQUcsQ0FBWDtNQUNBLElBQUloUCxHQUFKLEVBQVNpUCxHQUFUOztNQUNBLE9BQU8xUyxDQUFDLEdBQUdrSyxJQUFYLEVBQWlCO1FBQ2Z6RyxHQUFHLEdBQUdnTixLQUFHLENBQUN4UyxTQUFTLENBQUMrQixDQUFDLEVBQUYsQ0FBVixDQUFUOztRQUNBLElBQUl5UyxJQUFJLEdBQUdoUCxHQUFYLEVBQWdCO1VBQ2RpUCxHQUFHLEdBQUdELElBQUksR0FBR2hQLEdBQWI7VUFDQStPLEdBQUcsR0FBR0EsR0FBRyxHQUFHRSxHQUFOLEdBQVlBLEdBQVosR0FBa0IsQ0FBeEI7VUFDQUQsSUFBSSxHQUFHaFAsR0FBUDtTQUhGLE1BSU8sSUFBSUEsR0FBRyxHQUFHLENBQVYsRUFBYTtVQUNsQmlQLEdBQUcsR0FBR2pQLEdBQUcsR0FBR2dQLElBQVo7VUFDQUQsR0FBRyxJQUFJRSxHQUFHLEdBQUdBLEdBQWI7U0FGSyxNQUdBRixHQUFHLElBQUkvTyxHQUFQOzs7TUFFVCxPQUFPZ1AsSUFBSSxLQUFLcEYsUUFBVCxHQUFvQkEsUUFBcEIsR0FBK0JvRixJQUFJLEdBQUdsWixJQUFJLENBQUN1WCxJQUFMLENBQVUwQixHQUFWLENBQTdDOztFQWxCdUIsQ0FBcEIsQ0FBUDs7RUNGQSxJQUFJRyxLQUFLLEdBQUdwWixJQUFJLENBQUNxWixJQUFqQjs7QUFHQXpVLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVl2RSxNQUFtQixDQUFDLFlBQVk7SUFDOUQsT0FBTzBZLEtBQUssQ0FBQyxVQUFELEVBQWEsQ0FBYixDQUFMLElBQXdCLENBQUMsQ0FBekIsSUFBOEJBLEtBQUssQ0FBQy9VLE1BQU4sSUFBZ0IsQ0FBckQ7RUFDRCxDQUZrRCxDQUE1QyxFQUVILE1BRkcsRUFFSztJQUNWZ1YsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY3pJLENBQWQsRUFBaUJDLENBQWpCLEVBQW9CO01BQ3hCLElBQUl5SSxNQUFNLEdBQUcsTUFBYjtNQUNBLElBQUlDLEVBQUUsR0FBRyxDQUFDM0ksQ0FBVjtNQUNBLElBQUk0SSxFQUFFLEdBQUcsQ0FBQzNJLENBQVY7TUFDQSxJQUFJNEksRUFBRSxHQUFHSCxNQUFNLEdBQUdDLEVBQWxCO01BQ0EsSUFBSUcsRUFBRSxHQUFHSixNQUFNLEdBQUdFLEVBQWxCO01BQ0EsT0FBTyxJQUFJQyxFQUFFLEdBQUdDLEVBQUwsSUFBVyxDQUFDSixNQUFNLEdBQUdDLEVBQUUsS0FBSyxFQUFqQixJQUF1QkcsRUFBdkIsR0FBNEJELEVBQUUsSUFBSUgsTUFBTSxHQUFHRSxFQUFFLEtBQUssRUFBcEIsQ0FBOUIsSUFBeUQsRUFBekQsS0FBZ0UsQ0FBM0UsQ0FBWDs7RUFQUSxDQUZMLENBQVA7O0FDRkE1VSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxNQUFaLEVBQW9CO0lBQ3pCa1ksS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZS9JLENBQWYsRUFBa0I7TUFDdkIsT0FBTzVRLElBQUksQ0FBQ29XLEdBQUwsQ0FBU3hGLENBQVQsSUFBYzVRLElBQUksQ0FBQzRaLE1BQTFCOztFQUZ1QixDQUFwQixDQUFQOztBQ0FBaFYsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksTUFBWixFQUFvQjtJQUFFNlYsS0FBSyxFQUFFNVc7RUFBVCxDQUFwQixDQUFQOztBQ0FBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksTUFBWixFQUFvQjtJQUN6Qm9ZLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNqSixDQUFkLEVBQWlCO01BQ3JCLE9BQU81USxJQUFJLENBQUNvVyxHQUFMLENBQVN4RixDQUFULElBQWM1USxJQUFJLENBQUMyWCxHQUExQjs7RUFGdUIsQ0FBcEIsQ0FBUDs7QUNBQS9TLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLE1BQVosRUFBb0I7SUFBRXVXLElBQUksRUFBRXRYO0VBQVIsQ0FBcEIsQ0FBUDs7RUNBQSxJQUFJbUYsS0FBRyxHQUFHN0YsSUFBSSxDQUFDNkYsR0FBZjs7QUFHQWpCLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVl2RSxNQUFtQixDQUFDLFlBQVk7SUFDOUQsT0FBTyxDQUFDVixJQUFJLENBQUM4WixJQUFMLENBQVUsQ0FBQyxLQUFYLENBQUQsSUFBc0IsQ0FBQyxLQUE5QjtFQUNELENBRmtELENBQTVDLEVBRUgsTUFGRyxFQUVLO0lBQ1ZBLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNsSixDQUFkLEVBQWlCO01BQ3JCLE9BQU81USxJQUFJLENBQUNrWCxHQUFMLENBQVN0RyxDQUFDLEdBQUcsQ0FBQ0EsQ0FBZCxJQUFtQixDQUFuQixHQUNILENBQUMwSCxVQUFLLENBQUMxSCxDQUFELENBQUwsR0FBVzBILFVBQUssQ0FBQyxDQUFDMUgsQ0FBRixDQUFqQixJQUF5QixDQUR0QixHQUVILENBQUMvSyxLQUFHLENBQUMrSyxDQUFDLEdBQUcsQ0FBTCxDQUFILEdBQWEvSyxLQUFHLENBQUMsQ0FBQytLLENBQUQsR0FBSyxDQUFOLENBQWpCLEtBQThCNVEsSUFBSSxDQUFDZ08sQ0FBTCxHQUFTLENBQXZDLENBRko7O0VBRlEsQ0FGTCxDQUFQOztFQ0hBLElBQUluSSxLQUFHLEdBQUc3RixJQUFJLENBQUM2RixHQUFmO0FBRUFqQixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxNQUFaLEVBQW9CO0lBQ3pCc1ksSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY25KLENBQWQsRUFBaUI7TUFDckIsSUFBSTlQLENBQUMsR0FBR3dYLFVBQUssQ0FBQzFILENBQUMsR0FBRyxDQUFDQSxDQUFOLENBQWI7TUFDQSxJQUFJck0sQ0FBQyxHQUFHK1QsVUFBSyxDQUFDLENBQUMxSCxDQUFGLENBQWI7TUFDQSxPQUFPOVAsQ0FBQyxJQUFJZ1QsUUFBTCxHQUFnQixDQUFoQixHQUFvQnZQLENBQUMsSUFBSXVQLFFBQUwsR0FBZ0IsQ0FBQyxDQUFqQixHQUFxQixDQUFDaFQsQ0FBQyxHQUFHeUQsQ0FBTCxLQUFXc0IsS0FBRyxDQUFDK0ssQ0FBRCxDQUFILEdBQVMvSyxLQUFHLENBQUMsQ0FBQytLLENBQUYsQ0FBdkIsQ0FBaEQ7O0VBSnVCLENBQXBCLENBQVA7O0FDRkFoTSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxNQUFaLEVBQW9CO0lBQ3pCdVksS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZTNaLEVBQWYsRUFBbUI7TUFDeEIsT0FBTyxDQUFDQSxFQUFFLEdBQUcsQ0FBTCxHQUFTTCxJQUFJLENBQUNvSSxLQUFkLEdBQXNCcEksSUFBSSxDQUFDbUksSUFBNUIsRUFBa0M5SCxFQUFsQyxDQUFQOztFQUZ1QixDQUFwQixDQUFQOztFQ0RBLElBQUk0WixZQUFZLEdBQUcvVixNQUFNLENBQUMrVixZQUExQjtFQUNBLElBQUlDLGNBQWMsR0FBR2hXLE1BQU0sQ0FBQ2lXLGFBQTVCOztBQUdBdlYsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsSUFBYSxDQUFDLENBQUNpVixjQUFGLElBQW9CQSxjQUFjLENBQUM3VixNQUFmLElBQXlCLENBQTFELENBQWIsRUFBMkUsUUFBM0UsRUFBcUY7O0lBRTFGOFYsYUFBYSxFQUFFLFNBQVNBLGFBQVQsQ0FBdUJ2SixDQUF2QixFQUEwQjs7TUFDdkMsSUFBSXlFLEdBQUcsR0FBRyxFQUFWO01BQ0EsSUFBSTFFLElBQUksR0FBR2pNLFNBQVMsQ0FBQ0wsTUFBckI7TUFDQSxJQUFJb0MsQ0FBQyxHQUFHLENBQVI7TUFDQSxJQUFJb08sSUFBSjs7TUFDQSxPQUFPbEUsSUFBSSxHQUFHbEssQ0FBZCxFQUFpQjtRQUNmb08sSUFBSSxHQUFHLENBQUNuUSxTQUFTLENBQUMrQixDQUFDLEVBQUYsQ0FBakI7UUFDQSxJQUFJdUMsZ0JBQWUsQ0FBQzZMLElBQUQsRUFBTyxRQUFQLENBQWYsS0FBb0NBLElBQXhDLEVBQThDLE1BQU1TLFVBQVUsQ0FBQ1QsSUFBSSxHQUFHLDRCQUFSLENBQWhCO1FBQzlDUSxHQUFHLENBQUNqUyxJQUFKLENBQVN5UixJQUFJLEdBQUcsT0FBUCxHQUNMb0YsWUFBWSxDQUFDcEYsSUFBRCxDQURQLEdBRUxvRixZQUFZLENBQUMsQ0FBQyxDQUFDcEYsSUFBSSxJQUFJLE9BQVQsS0FBcUIsRUFBdEIsSUFBNEIsTUFBN0IsRUFBcUNBLElBQUksR0FBRyxLQUFQLEdBQWUsTUFBcEQsQ0FGaEI7OztNQUlBLE9BQU9RLEdBQUcsQ0FBQ3BSLElBQUosQ0FBUyxFQUFULENBQVA7O0VBZHNGLENBQXJGLENBQVA7O0FDRkFXLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFFBQVosRUFBc0I7O0lBRTNCMlksR0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYUMsUUFBYixFQUF1QjtNQUMxQixJQUFJQyxHQUFHLEdBQUd4UixVQUFTLENBQUN1UixRQUFRLENBQUNELEdBQVYsQ0FBbkI7TUFDQSxJQUFJeEksR0FBRyxHQUFHN0ksU0FBUSxDQUFDdVIsR0FBRyxDQUFDalcsTUFBTCxDQUFsQjtNQUNBLElBQUlzTSxJQUFJLEdBQUdqTSxTQUFTLENBQUNMLE1BQXJCO01BQ0EsSUFBSWdSLEdBQUcsR0FBRyxFQUFWO01BQ0EsSUFBSTVPLENBQUMsR0FBRyxDQUFSOztNQUNBLE9BQU9tTCxHQUFHLEdBQUduTCxDQUFiLEVBQWdCO1FBQ2Q0TyxHQUFHLENBQUNqUyxJQUFKLENBQVNjLE1BQU0sQ0FBQ29XLEdBQUcsQ0FBQzdULENBQUMsRUFBRixDQUFKLENBQWY7UUFDQSxJQUFJQSxDQUFDLEdBQUdrSyxJQUFSLEVBQWMwRSxHQUFHLENBQUNqUyxJQUFKLENBQVNjLE1BQU0sQ0FBQ1EsU0FBUyxDQUFDK0IsQ0FBRCxDQUFWLENBQWY7OztNQUNkLE9BQU80TyxHQUFHLENBQUNwUixJQUFKLENBQVMsRUFBVCxDQUFQOztFQVh1QixDQUF0QixDQUFQOztBQ0ZBdkQsYUFBeUIsQ0FBQyxNQUFELEVBQVMsVUFBVTZTLEtBQVYsRUFBaUI7SUFDakQsT0FBTyxTQUFTTixJQUFULEdBQWdCO01BQ3JCLE9BQU9NLEtBQUssQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFaO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7RUNDQTs7RUFDQSxhQUFjLEdBQUcsa0JBQUEsQ0FBVS9QLFNBQVYsRUFBcUI7SUFDcEMsT0FBTyxVQUFVWSxJQUFWLEVBQWdCbVcsR0FBaEIsRUFBcUI7TUFDMUIsSUFBSXZFLENBQUMsR0FBRzlSLE1BQU0sQ0FBQ2dFLFFBQU8sQ0FBQzlELElBQUQsQ0FBUixDQUFkO01BQ0EsSUFBSXFDLENBQUMsR0FBRzhCLFVBQVMsQ0FBQ2dTLEdBQUQsQ0FBakI7TUFDQSxJQUFJMU0sQ0FBQyxHQUFHbUksQ0FBQyxDQUFDM1IsTUFBVjtNQUNBLElBQUl2RCxDQUFKLEVBQU95RCxDQUFQO01BQ0EsSUFBSWtDLENBQUMsR0FBRyxDQUFKLElBQVNBLENBQUMsSUFBSW9ILENBQWxCLEVBQXFCLE9BQU9ySyxTQUFTLEdBQUcsRUFBSCxHQUFRUCxTQUF4QjtNQUNyQm5DLENBQUMsR0FBR2tWLENBQUMsQ0FBQ3hCLFVBQUYsQ0FBYS9OLENBQWIsQ0FBSjtNQUNBLE9BQU8zRixDQUFDLEdBQUcsTUFBSixJQUFjQSxDQUFDLEdBQUcsTUFBbEIsSUFBNEIyRixDQUFDLEdBQUcsQ0FBSixLQUFVb0gsQ0FBdEMsSUFBMkMsQ0FBQ3RKLENBQUMsR0FBR3lSLENBQUMsQ0FBQ3hCLFVBQUYsQ0FBYS9OLENBQUMsR0FBRyxDQUFqQixDQUFMLElBQTRCLE1BQXZFLElBQWlGbEMsQ0FBQyxHQUFHLE1BQXJGLEdBQ0hmLFNBQVMsR0FBR3dTLENBQUMsQ0FBQ3BPLE1BQUYsQ0FBU25CLENBQVQsQ0FBSCxHQUFpQjNGLENBRHZCLEdBRUgwQyxTQUFTLEdBQUd3UyxDQUFDLENBQUNsTyxLQUFGLENBQVFyQixDQUFSLEVBQVdBLENBQUMsR0FBRyxDQUFmLENBQUgsR0FBdUIsQ0FBQzNGLENBQUMsR0FBRyxNQUFKLElBQWMsRUFBZixLQUFzQnlELENBQUMsR0FBRyxNQUExQixJQUFvQyxPQUZ4RTtLQVBGO0VBV0QsQ0FaRDs7RUNKQSxjQUFjLEdBQUcsRUFBakI7O0VDSUEsSUFBSWlXLGlCQUFpQixHQUFHLEVBQXhCOztBQUdBOVosT0FBa0IsQ0FBQzhaLGlCQUFELEVBQW9CalosSUFBaUIsQ0FBQyxVQUFELENBQXJDLEVBQW1ELFlBQVk7SUFBRSxPQUFPLElBQVA7RUFBYyxDQUEvRSxDQUFsQjs7RUFFQSxlQUFjLEdBQUcsb0JBQUEsQ0FBVWtaLFdBQVYsRUFBdUJySSxJQUF2QixFQUE2QnNJLElBQTdCLEVBQW1DO0lBQ2xERCxXQUFXLENBQUN0VyxTQUFaLEdBQXdCeUMsYUFBTSxDQUFDNFQsaUJBQUQsRUFBb0I7TUFBRUUsSUFBSSxFQUFFQyxhQUFVLENBQUMsQ0FBRCxFQUFJRCxJQUFKO0tBQXRDLENBQTlCO0lBQ0FwTCxlQUFjLENBQUNtTCxXQUFELEVBQWNySSxJQUFJLEdBQUcsV0FBckIsQ0FBZDtFQUNELENBSEQ7O0VDQUEsSUFBSXdJLFFBQVEsR0FBR2xhLElBQWlCLENBQUMsVUFBRCxDQUFoQztFQUNBLElBQUltYSxLQUFLLEdBQUcsRUFBRSxHQUFHdlIsSUFBSCxJQUFXLFVBQVUsR0FBR0EsSUFBSCxFQUF2QixDQUFaOztFQUNBLElBQUl3UixXQUFXLEdBQUcsWUFBbEI7RUFDQSxJQUFJQyxJQUFJLEdBQUcsTUFBWDtFQUNBLElBQUlDLE1BQU0sR0FBRyxRQUFiOztFQUVBLElBQUlDLFVBQVUsR0FBRyxTQUFiQSxVQUFhLEdBQVk7SUFBRSxPQUFPLElBQVA7RUFBYyxDQUE3Qzs7RUFFQSxlQUFjLEdBQUcsb0JBQUEsQ0FBVS9HLElBQVYsRUFBZ0I5QixJQUFoQixFQUFzQnFJLFdBQXRCLEVBQW1DQyxJQUFuQyxFQUF5Q1EsT0FBekMsRUFBa0RDLE1BQWxELEVBQTBEQyxNQUExRCxFQUFrRTtJQUNqRkMsV0FBVyxDQUFDWixXQUFELEVBQWNySSxJQUFkLEVBQW9Cc0ksSUFBcEIsQ0FBWDs7SUFDQSxJQUFJWSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVQyxJQUFWLEVBQWdCO01BQzlCLElBQUksQ0FBQ1YsS0FBRCxJQUFVVSxJQUFJLElBQUl4SyxLQUF0QixFQUE2QixPQUFPQSxLQUFLLENBQUN3SyxJQUFELENBQVo7O01BQzdCLFFBQVFBLElBQVI7UUFDRSxLQUFLUixJQUFMO1VBQVcsT0FBTyxTQUFTelIsSUFBVCxHQUFnQjtZQUFFLE9BQU8sSUFBSW1SLFdBQUosQ0FBZ0IsSUFBaEIsRUFBc0JjLElBQXRCLENBQVA7V0FBekI7O1FBQ1gsS0FBS1AsTUFBTDtVQUFhLE9BQU8sU0FBU1EsTUFBVCxHQUFrQjtZQUFFLE9BQU8sSUFBSWYsV0FBSixDQUFnQixJQUFoQixFQUFzQmMsSUFBdEIsQ0FBUDtXQUEzQjs7O01BQ2IsT0FBTyxTQUFTRSxPQUFULEdBQW1CO1FBQUUsT0FBTyxJQUFJaEIsV0FBSixDQUFnQixJQUFoQixFQUFzQmMsSUFBdEIsQ0FBUDtPQUE1QjtLQUxKOztJQU9BLElBQUloVSxHQUFHLEdBQUc2SyxJQUFJLEdBQUcsV0FBakI7SUFDQSxJQUFJc0osVUFBVSxHQUFHUixPQUFPLElBQUlGLE1BQTVCO0lBQ0EsSUFBSVcsVUFBVSxHQUFHLEtBQWpCO0lBQ0EsSUFBSTVLLEtBQUssR0FBR21ELElBQUksQ0FBQy9QLFNBQWpCO0lBQ0EsSUFBSXlYLE9BQU8sR0FBRzdLLEtBQUssQ0FBQzZKLFFBQUQsQ0FBTCxJQUFtQjdKLEtBQUssQ0FBQytKLFdBQUQsQ0FBeEIsSUFBeUNJLE9BQU8sSUFBSW5LLEtBQUssQ0FBQ21LLE9BQUQsQ0FBdkU7SUFDQSxJQUFJVyxRQUFRLEdBQUdELE9BQU8sSUFBSU4sU0FBUyxDQUFDSixPQUFELENBQW5DO0lBQ0EsSUFBSVksUUFBUSxHQUFHWixPQUFPLEdBQUcsQ0FBQ1EsVUFBRCxHQUFjRyxRQUFkLEdBQXlCUCxTQUFTLENBQUMsU0FBRCxDQUFyQyxHQUFtRHJZLFNBQXpFO0lBQ0EsSUFBSThZLFVBQVUsR0FBRzNKLElBQUksSUFBSSxPQUFSLEdBQWtCckIsS0FBSyxDQUFDMEssT0FBTixJQUFpQkcsT0FBbkMsR0FBNkNBLE9BQTlEO0lBQ0EsSUFBSUksT0FBSixFQUFhMWIsR0FBYixFQUFrQmthLGlCQUFsQixDQWpCaUY7O0lBbUJqRixJQUFJdUIsVUFBSixFQUFnQjtNQUNkdkIsaUJBQWlCLEdBQUdoTCxVQUFjLENBQUN1TSxVQUFVLENBQUN4YixJQUFYLENBQWdCLElBQUkyVCxJQUFKLEVBQWhCLENBQUQsQ0FBbEM7O01BQ0EsSUFBSXNHLGlCQUFpQixLQUFLN1osTUFBTSxDQUFDd0QsU0FBN0IsSUFBMENxVyxpQkFBaUIsQ0FBQ0UsSUFBaEUsRUFBc0U7O1FBRXBFcEwsZUFBYyxDQUFDa0wsaUJBQUQsRUFBb0JqVCxHQUFwQixFQUF5QixJQUF6QixDQUFkLENBRm9FOztRQUlwRSxJQUFJLENBQVksT0FBT2lULGlCQUFpQixDQUFDSSxRQUFELENBQXhCLElBQXNDLFVBQXRELEVBQWtFNVcsS0FBSSxDQUFDd1csaUJBQUQsRUFBb0JJLFFBQXBCLEVBQThCSyxVQUE5QixDQUFKOztLQXpCVzs7O0lBNkJqRixJQUFJUyxVQUFVLElBQUlFLE9BQWQsSUFBeUJBLE9BQU8sQ0FBQzlXLElBQVIsS0FBaUJrVyxNQUE5QyxFQUFzRDtNQUNwRFcsVUFBVSxHQUFHLElBQWI7O01BQ0FFLFFBQVEsR0FBRyxTQUFTTCxNQUFULEdBQWtCO1FBQUUsT0FBT0ksT0FBTyxDQUFDcmIsSUFBUixDQUFhLElBQWIsQ0FBUDtPQUEvQjtLQS9CK0U7OztJQWtDakYsSUFBSSxFQUF5QnNhLEtBQUssSUFBSWMsVUFBVCxJQUF1QixDQUFDNUssS0FBSyxDQUFDNkosUUFBRCxDQUF0RCxDQUFKLEVBQXVFO01BQ3JFNVcsS0FBSSxDQUFDK00sS0FBRCxFQUFRNkosUUFBUixFQUFrQmlCLFFBQWxCLENBQUo7S0FuQytFOzs7SUFzQ2pGSSxVQUFTLENBQUM3SixJQUFELENBQVQsR0FBa0J5SixRQUFsQjtJQUNBSSxVQUFTLENBQUMxVSxHQUFELENBQVQsR0FBaUIwVCxVQUFqQjs7SUFDQSxJQUFJQyxPQUFKLEVBQWE7TUFDWGMsT0FBTyxHQUFHO1FBQ1JSLE1BQU0sRUFBRUUsVUFBVSxHQUFHRyxRQUFILEdBQWNQLFNBQVMsQ0FBQ04sTUFBRCxDQURqQztRQUVSMVIsSUFBSSxFQUFFNlIsTUFBTSxHQUFHVSxRQUFILEdBQWNQLFNBQVMsQ0FBQ1AsSUFBRCxDQUYzQjtRQUdSVSxPQUFPLEVBQUVLO09BSFg7TUFLQSxJQUFJVixNQUFKLEVBQVksS0FBSzlhLEdBQUwsSUFBWTBiLE9BQVosRUFBcUI7UUFDL0IsSUFBSSxFQUFFMWIsR0FBRyxJQUFJeVEsS0FBVCxDQUFKLEVBQXFCaEwsU0FBUSxDQUFDZ0wsS0FBRCxFQUFRelEsR0FBUixFQUFhMGIsT0FBTyxDQUFDMWIsR0FBRCxDQUFwQixDQUFSO09BRHZCLE1BRU9zRSxPQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixJQUFhNFYsS0FBSyxJQUFJYyxVQUF0QixDQUFiLEVBQWdEdkosSUFBaEQsRUFBc0Q0SixPQUF0RCxDQUFQOzs7SUFFVCxPQUFPQSxPQUFQO0VBQ0QsQ0FuREQ7O0VDaEJBLElBQUlFLEdBQUcsR0FBR3hiLFNBQXVCLENBQUMsSUFBRCxDQUFqQzs7QUFHQWEsYUFBeUIsQ0FBQzJDLE1BQUQsRUFBUyxRQUFULEVBQW1CLFVBQVVpWSxRQUFWLEVBQW9CO0lBQzlELEtBQUtDLEVBQUwsR0FBVWxZLE1BQU0sQ0FBQ2lZLFFBQUQsQ0FBaEIsQ0FEOEQ7O0lBRTlELEtBQUtFLEVBQUwsR0FBVSxDQUFWLENBRjhEOztFQUkvRCxDQUp3QixFQUl0QixZQUFZO0lBQ2IsSUFBSXRhLENBQUMsR0FBRyxLQUFLcWEsRUFBYjtJQUNBLElBQUkzVCxLQUFLLEdBQUcsS0FBSzRULEVBQWpCO0lBQ0EsSUFBSUMsS0FBSjtJQUNBLElBQUk3VCxLQUFLLElBQUkxRyxDQUFDLENBQUNzQyxNQUFmLEVBQXVCLE9BQU87TUFBRWhDLEtBQUssRUFBRVksU0FBVDtNQUFvQnNaLElBQUksRUFBRTtLQUFqQztJQUN2QkQsS0FBSyxHQUFHSixHQUFHLENBQUNuYSxDQUFELEVBQUkwRyxLQUFKLENBQVg7SUFDQSxLQUFLNFQsRUFBTCxJQUFXQyxLQUFLLENBQUNqWSxNQUFqQjtJQUNBLE9BQU87TUFBRWhDLEtBQUssRUFBRWlhLEtBQVQ7TUFBZ0JDLElBQUksRUFBRTtLQUE3QjtFQUNELENBWndCLENBQXpCOztFQ0ZBLElBQUlMLEtBQUcsR0FBR3hiLFNBQXVCLENBQUMsS0FBRCxDQUFqQztBQUNBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFULEVBQVksUUFBWixFQUFzQjs7SUFFM0J3YSxXQUFXLEVBQUUsU0FBU0EsV0FBVCxDQUFxQmpDLEdBQXJCLEVBQTBCO01BQ3JDLE9BQU8yQixLQUFHLENBQUMsSUFBRCxFQUFPM0IsR0FBUCxDQUFWOztFQUh5QixDQUF0QixDQUFQOztFQ0FBLElBQUlrQyxLQUFLLEdBQUcvYixJQUFpQixDQUFDLE9BQUQsQ0FBN0I7O0VBQ0EsYUFBYyxHQUFHLGtCQUFBLENBQVVMLEVBQVYsRUFBYztJQUM3QixJQUFJcWMsUUFBSjtJQUNBLE9BQU94YixTQUFRLENBQUNiLEVBQUQsQ0FBUixLQUFpQixDQUFDcWMsUUFBUSxHQUFHcmMsRUFBRSxDQUFDb2MsS0FBRCxDQUFkLE1BQTJCeFosU0FBM0IsR0FBdUMsQ0FBQyxDQUFDeVosUUFBekMsR0FBb0QxVSxJQUFHLENBQUMzSCxFQUFELENBQUgsSUFBVyxRQUFoRixDQUFQO0VBQ0QsQ0FIRDs7RUNBQSxrQkFBYyxHQUFHLHVCQUFBLENBQVUrRCxJQUFWLEVBQWdCdVksWUFBaEIsRUFBOEJ2SyxJQUE5QixFQUFvQztJQUNuRCxJQUFJc0ssU0FBUSxDQUFDQyxZQUFELENBQVosRUFBNEIsTUFBTXhiLFNBQVMsQ0FBQyxZQUFZaVIsSUFBWixHQUFtQix3QkFBcEIsQ0FBZjtJQUM1QixPQUFPbE8sTUFBTSxDQUFDZ0UsUUFBTyxDQUFDOUQsSUFBRCxDQUFSLENBQWI7RUFDRCxDQUhEOztFQ0pBLElBQUlxWSxPQUFLLEdBQUcvYixJQUFpQixDQUFDLE9BQUQsQ0FBN0I7O0VBQ0Esa0JBQWMsR0FBRyx1QkFBQSxDQUFVdUcsR0FBVixFQUFlO0lBQzlCLElBQUkyVixFQUFFLEdBQUcsR0FBVDs7SUFDQSxJQUFJO01BQ0YsTUFBTTNWLEdBQU4sRUFBVzJWLEVBQVg7S0FERixDQUVFLE9BQU9uYyxDQUFQLEVBQVU7TUFDVixJQUFJO1FBQ0ZtYyxFQUFFLENBQUNILE9BQUQsQ0FBRixHQUFZLEtBQVo7UUFDQSxPQUFPLENBQUMsTUFBTXhWLEdBQU4sRUFBVzJWLEVBQVgsQ0FBUjtPQUZGLENBR0UsT0FBT2phLENBQVAsRUFBVTs7Ozs7SUFDWixPQUFPLElBQVA7RUFDSCxDQVZEOztFQ0lBLElBQUlrYSxTQUFTLEdBQUcsVUFBaEI7RUFDQSxJQUFJQyxTQUFTLEdBQUcsR0FBR0QsU0FBSCxDQUFoQjtBQUVBalksU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWXZFLGNBQTZCLENBQUNtYyxTQUFELENBQXRELEVBQW1FLFFBQW5FLEVBQTZFO0lBQ2xGRSxRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQko7O01BQTRDO01BQ3RFLElBQUl2WSxJQUFJLEdBQUc0WSxjQUFPLENBQUMsSUFBRCxFQUFPTCxZQUFQLEVBQXFCRSxTQUFyQixDQUFsQjtNQUNBLElBQUlJLFdBQVcsR0FBR3ZZLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUF4RDtNQUNBLElBQUkyTyxHQUFHLEdBQUc3SSxTQUFRLENBQUMzRSxJQUFJLENBQUNDLE1BQU4sQ0FBbEI7TUFDQSxJQUFJNlksR0FBRyxHQUFHRCxXQUFXLEtBQUtoYSxTQUFoQixHQUE0QjJPLEdBQTVCLEdBQWtDNVIsSUFBSSxDQUFDc0ksR0FBTCxDQUFTUyxTQUFRLENBQUNrVSxXQUFELENBQWpCLEVBQWdDckwsR0FBaEMsQ0FBNUM7TUFDQSxJQUFJdUwsTUFBTSxHQUFHalosTUFBTSxDQUFDeVksWUFBRCxDQUFuQjtNQUNBLE9BQU9HLFNBQVMsR0FDWkEsU0FBUyxDQUFDdmMsSUFBVixDQUFlNkQsSUFBZixFQUFxQitZLE1BQXJCLEVBQTZCRCxHQUE3QixDQURZLEdBRVo5WSxJQUFJLENBQUMwRCxLQUFMLENBQVdvVixHQUFHLEdBQUdDLE1BQU0sQ0FBQzlZLE1BQXhCLEVBQWdDNlksR0FBaEMsTUFBeUNDLE1BRjdDOztFQVBnRixDQUE3RSxDQUFQOztFQ0pBLElBQUlDLFFBQVEsR0FBRyxVQUFmO0FBRUF4WSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZdkUsY0FBNkIsQ0FBQzBjLFFBQUQsQ0FBdEQsRUFBa0UsUUFBbEUsRUFBNEU7SUFDakZDLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCVjs7TUFBbUM7TUFDN0QsT0FBTyxDQUFDLENBQUMsQ0FBQ0ssY0FBTyxDQUFDLElBQUQsRUFBT0wsWUFBUCxFQUFxQlMsUUFBckIsQ0FBUCxDQUNQRSxPQURPLENBQ0NYLFlBREQsRUFDZWpZLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQURyRCxDQUFWOztFQUYrRSxDQUE1RSxDQUFQOztBQ0pBMkIsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFULEVBQVksUUFBWixFQUFzQjs7SUFFM0JtVCxNQUFNLEVBQUV6VTtFQUZtQixDQUF0QixDQUFQOztFQ0dBLElBQUk2YyxXQUFXLEdBQUcsWUFBbEI7RUFDQSxJQUFJQyxXQUFXLEdBQUcsR0FBR0QsV0FBSCxDQUFsQjtBQUVBM1ksU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWXZFLGNBQTZCLENBQUM2YyxXQUFELENBQXRELEVBQXFFLFFBQXJFLEVBQStFO0lBQ3BGRSxVQUFVLEVBQUUsU0FBU0EsVUFBVCxDQUFvQmQ7O01BQW1DO01BQ2pFLElBQUl2WSxJQUFJLEdBQUc0WSxjQUFPLENBQUMsSUFBRCxFQUFPTCxZQUFQLEVBQXFCWSxXQUFyQixDQUFsQjtNQUNBLElBQUk5VSxLQUFLLEdBQUdNLFNBQVEsQ0FBQy9JLElBQUksQ0FBQ3NJLEdBQUwsQ0FBUzVELFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUEvQyxFQUEwRG1CLElBQUksQ0FBQ0MsTUFBL0QsQ0FBRCxDQUFwQjtNQUNBLElBQUk4WSxNQUFNLEdBQUdqWixNQUFNLENBQUN5WSxZQUFELENBQW5CO01BQ0EsT0FBT2EsV0FBVyxHQUNkQSxXQUFXLENBQUNqZCxJQUFaLENBQWlCNkQsSUFBakIsRUFBdUIrWSxNQUF2QixFQUErQjFVLEtBQS9CLENBRGMsR0FFZHJFLElBQUksQ0FBQzBELEtBQUwsQ0FBV1csS0FBWCxFQUFrQkEsS0FBSyxHQUFHMFUsTUFBTSxDQUFDOVksTUFBakMsTUFBNkM4WSxNQUZqRDs7RUFMa0YsQ0FBL0UsQ0FBUDs7RUNMQSxJQUFJTyxJQUFJLEdBQUcsSUFBWDs7RUFFQSxJQUFJQyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFVekssTUFBVixFQUFrQjFMLEdBQWxCLEVBQXVCb1csU0FBdkIsRUFBa0N2YixLQUFsQyxFQUF5QztJQUN4RCxJQUFJWixDQUFDLEdBQUd5QyxNQUFNLENBQUNnRSxRQUFPLENBQUNnTCxNQUFELENBQVIsQ0FBZDtJQUNBLElBQUkySyxFQUFFLEdBQUcsTUFBTXJXLEdBQWY7SUFDQSxJQUFJb1csU0FBUyxLQUFLLEVBQWxCLEVBQXNCQyxFQUFFLElBQUksTUFBTUQsU0FBTixHQUFrQixJQUFsQixHQUF5QjFaLE1BQU0sQ0FBQzdCLEtBQUQsQ0FBTixDQUFjK1EsT0FBZCxDQUFzQnNLLElBQXRCLEVBQTRCLFFBQTVCLENBQXpCLEdBQWlFLEdBQXZFO0lBQ3RCLE9BQU9HLEVBQUUsR0FBRyxHQUFMLEdBQVdwYyxDQUFYLEdBQWUsSUFBZixHQUFzQitGLEdBQXRCLEdBQTRCLEdBQW5DO0VBQ0QsQ0FMRDs7RUFNQSxlQUFjLEdBQUcsb0JBQUEsQ0FBVTRLLElBQVYsRUFBZ0I1UixJQUFoQixFQUFzQjtJQUNyQyxJQUFJdUIsQ0FBQyxHQUFHLEVBQVI7SUFDQUEsQ0FBQyxDQUFDcVEsSUFBRCxDQUFELEdBQVU1UixJQUFJLENBQUNtZCxVQUFELENBQWQ7SUFDQS9ZLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLEdBQVlzSyxNQUFLLENBQUMsWUFBWTtNQUNoRCxJQUFJMEIsSUFBSSxHQUFHLEdBQUdtQixJQUFILEVBQVMsR0FBVCxDQUFYO01BQ0EsT0FBT25CLElBQUksS0FBS0EsSUFBSSxDQUFDNk0sV0FBTCxFQUFULElBQStCN00sSUFBSSxDQUFDdE4sS0FBTCxDQUFXLEdBQVgsRUFBZ0JVLE1BQWhCLEdBQXlCLENBQS9EO0tBRm1DLENBQTlCLEVBR0gsUUFIRyxFQUdPdEMsQ0FIUCxDQUFQO0VBSUQsQ0FQRDs7QUNUQXJCLGFBQXlCLENBQUMsUUFBRCxFQUFXLFVBQVVpZCxVQUFWLEVBQXNCO0lBQ3hELE9BQU8sU0FBU0ksTUFBVCxDQUFnQmpaLElBQWhCLEVBQXNCO01BQzNCLE9BQU82WSxVQUFVLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWSxNQUFaLEVBQW9CN1ksSUFBcEIsQ0FBakI7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBcEUsYUFBeUIsQ0FBQyxLQUFELEVBQVEsVUFBVWlkLFVBQVYsRUFBc0I7SUFDckQsT0FBTyxTQUFTSyxHQUFULEdBQWU7TUFDcEIsT0FBT0wsVUFBVSxDQUFDLElBQUQsRUFBTyxLQUFQLEVBQWMsRUFBZCxFQUFrQixFQUFsQixDQUFqQjtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUFqZCxhQUF5QixDQUFDLE9BQUQsRUFBVSxVQUFVaWQsVUFBVixFQUFzQjtJQUN2RCxPQUFPLFNBQVNNLEtBQVQsR0FBaUI7TUFDdEIsT0FBT04sVUFBVSxDQUFDLElBQUQsRUFBTyxPQUFQLEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLENBQWpCO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7QUNBQWpkLGFBQXlCLENBQUMsTUFBRCxFQUFTLFVBQVVpZCxVQUFWLEVBQXNCO0lBQ3RELE9BQU8sU0FBU08sSUFBVCxHQUFnQjtNQUNyQixPQUFPUCxVQUFVLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWSxFQUFaLEVBQWdCLEVBQWhCLENBQWpCO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7QUNBQWpkLGFBQXlCLENBQUMsT0FBRCxFQUFVLFVBQVVpZCxVQUFWLEVBQXNCO0lBQ3ZELE9BQU8sU0FBU1EsS0FBVCxHQUFpQjtNQUN0QixPQUFPUixVQUFVLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLENBQWpCO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7QUNBQWpkLGFBQXlCLENBQUMsV0FBRCxFQUFjLFVBQVVpZCxVQUFWLEVBQXNCO0lBQzNELE9BQU8sU0FBU1MsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI7TUFDL0IsT0FBT1YsVUFBVSxDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsT0FBZixFQUF3QlUsS0FBeEIsQ0FBakI7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM2QsYUFBeUIsQ0FBQyxVQUFELEVBQWEsVUFBVWlkLFVBQVYsRUFBc0I7SUFDMUQsT0FBTyxTQUFTVyxRQUFULENBQWtCQyxJQUFsQixFQUF3QjtNQUM3QixPQUFPWixVQUFVLENBQUMsSUFBRCxFQUFPLE1BQVAsRUFBZSxNQUFmLEVBQXVCWSxJQUF2QixDQUFqQjtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUE3ZCxhQUF5QixDQUFDLFNBQUQsRUFBWSxVQUFVaWQsVUFBVixFQUFzQjtJQUN6RCxPQUFPLFNBQVNhLE9BQVQsR0FBbUI7TUFDeEIsT0FBT2IsVUFBVSxDQUFDLElBQUQsRUFBTyxHQUFQLEVBQVksRUFBWixFQUFnQixFQUFoQixDQUFqQjtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUFqZCxhQUF5QixDQUFDLE1BQUQsRUFBUyxVQUFVaWQsVUFBVixFQUFzQjtJQUN0RCxPQUFPLFNBQVNjLElBQVQsQ0FBY0MsR0FBZCxFQUFtQjtNQUN4QixPQUFPZixVQUFVLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWSxNQUFaLEVBQW9CZSxHQUFwQixDQUFqQjtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUFoZSxhQUF5QixDQUFDLE9BQUQsRUFBVSxVQUFVaWQsVUFBVixFQUFzQjtJQUN2RCxPQUFPLFNBQVNnQixLQUFULEdBQWlCO01BQ3RCLE9BQU9oQixVQUFVLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsQ0FBakI7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBamQsYUFBeUIsQ0FBQyxRQUFELEVBQVcsVUFBVWlkLFVBQVYsRUFBc0I7SUFDeEQsT0FBTyxTQUFTaUIsTUFBVCxHQUFrQjtNQUN2QixPQUFPakIsVUFBVSxDQUFDLElBQUQsRUFBTyxRQUFQLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLENBQWpCO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7QUNBQWpkLGFBQXlCLENBQUMsS0FBRCxFQUFRLFVBQVVpZCxVQUFWLEVBQXNCO0lBQ3JELE9BQU8sU0FBU2tCLEdBQVQsR0FBZTtNQUNwQixPQUFPbEIsVUFBVSxDQUFDLElBQUQsRUFBTyxLQUFQLEVBQWMsRUFBZCxFQUFrQixFQUFsQixDQUFqQjtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUFqZCxhQUF5QixDQUFDLEtBQUQsRUFBUSxVQUFVaWQsVUFBVixFQUFzQjtJQUNyRCxPQUFPLFNBQVNtQixHQUFULEdBQWU7TUFDcEIsT0FBT25CLFVBQVUsQ0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLEVBQWQsRUFBa0IsRUFBbEIsQ0FBakI7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0NBL1ksU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksTUFBWixFQUFvQjtJQUFFc2QsR0FBRyxFQUFFLGVBQVk7TUFBRSxPQUFPLElBQUlDLElBQUosR0FBV0MsT0FBWCxFQUFQOztFQUFyQixDQUFwQixDQUFQOztBQ0VBcmEsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWXZFLE1BQW1CLENBQUMsWUFBWTtJQUM5RCxPQUFPLElBQUlzZSxJQUFKLENBQVNySyxHQUFULEVBQWN1SyxNQUFkLE9BQTJCLElBQTNCLElBQ0ZGLElBQUksQ0FBQzdhLFNBQUwsQ0FBZSthLE1BQWYsQ0FBc0IzZSxJQUF0QixDQUEyQjtNQUFFNGUsV0FBVyxFQUFFLHVCQUFZO1FBQUUsT0FBTyxDQUFQOztLQUF4RCxNQUEyRSxDQURoRjtFQUVELENBSGtELENBQTVDLEVBR0gsTUFIRyxFQUdLOztJQUVWRCxNQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQjVlLEdBQWhCLEVBQXFCO01BQzNCLElBQUl5QixDQUFDLEdBQUdrTixTQUFRLENBQUMsSUFBRCxDQUFoQjtNQUNBLElBQUltUSxFQUFFLEdBQUdqZCxZQUFXLENBQUNKLENBQUQsQ0FBcEI7TUFDQSxPQUFPLE9BQU9xZCxFQUFQLElBQWEsUUFBYixJQUF5QixDQUFDckksUUFBUSxDQUFDcUksRUFBRCxDQUFsQyxHQUF5QyxJQUF6QyxHQUFnRHJkLENBQUMsQ0FBQ29kLFdBQUYsRUFBdkQ7O0VBTFEsQ0FITCxDQUFQOztFQ0ZBLElBQUlGLE9BQU8sR0FBR0QsSUFBSSxDQUFDN2EsU0FBTCxDQUFlOGEsT0FBN0I7RUFDQSxJQUFJSSxZQUFZLEdBQUdMLElBQUksQ0FBQzdhLFNBQUwsQ0FBZWdiLFdBQWxDOztFQUVBLElBQUlHLEVBQUUsR0FBRyxTQUFMQSxFQUFLLENBQVVDLEdBQVYsRUFBZTtJQUN0QixPQUFPQSxHQUFHLEdBQUcsQ0FBTixHQUFVQSxHQUFWLEdBQWdCLE1BQU1BLEdBQTdCO0VBQ0QsQ0FGRDs7O0VBS0Esb0JBQWMsR0FBSWhRLE1BQUssQ0FBQyxZQUFZO0lBQ2xDLE9BQU84UCxZQUFZLENBQUM5ZSxJQUFiLENBQWtCLElBQUl5ZSxJQUFKLENBQVMsQ0FBQyxJQUFELEdBQVEsQ0FBakIsQ0FBbEIsS0FBMEMsMEJBQWpEO0VBQ0QsQ0FGc0IsQ0FBTCxJQUVaLENBQUN6UCxNQUFLLENBQUMsWUFBWTtJQUN2QjhQLFlBQVksQ0FBQzllLElBQWIsQ0FBa0IsSUFBSXllLElBQUosQ0FBU3JLLEdBQVQsQ0FBbEI7RUFDRCxDQUZXLENBRkssR0FJWCxTQUFTd0ssV0FBVCxHQUF1QjtJQUMzQixJQUFJLENBQUNwSSxRQUFRLENBQUNrSSxPQUFPLENBQUMxZSxJQUFSLENBQWEsSUFBYixDQUFELENBQWIsRUFBbUMsTUFBTStVLFVBQVUsQ0FBQyxvQkFBRCxDQUFoQjtJQUNuQyxJQUFJa0ssQ0FBQyxHQUFHLElBQVI7SUFDQSxJQUFJM08sQ0FBQyxHQUFHMk8sQ0FBQyxDQUFDQyxjQUFGLEVBQVI7SUFDQSxJQUFJakosQ0FBQyxHQUFHZ0osQ0FBQyxDQUFDRSxrQkFBRixFQUFSO0lBQ0EsSUFBSTFKLENBQUMsR0FBR25GLENBQUMsR0FBRyxDQUFKLEdBQVEsR0FBUixHQUFjQSxDQUFDLEdBQUcsSUFBSixHQUFXLEdBQVgsR0FBaUIsRUFBdkM7SUFDQSxPQUFPbUYsQ0FBQyxHQUFHLENBQUMsVUFBVWhXLElBQUksQ0FBQ2tYLEdBQUwsQ0FBU3JHLENBQVQsQ0FBWCxFQUF3Qi9JLEtBQXhCLENBQThCa08sQ0FBQyxHQUFHLENBQUMsQ0FBSixHQUFRLENBQUMsQ0FBeEMsQ0FBSixHQUNMLEdBREssR0FDQ3NKLEVBQUUsQ0FBQ0UsQ0FBQyxDQUFDRyxXQUFGLEtBQWtCLENBQW5CLENBREgsR0FDMkIsR0FEM0IsR0FDaUNMLEVBQUUsQ0FBQ0UsQ0FBQyxDQUFDSSxVQUFGLEVBQUQsQ0FEbkMsR0FFTCxHQUZLLEdBRUNOLEVBQUUsQ0FBQ0UsQ0FBQyxDQUFDSyxXQUFGLEVBQUQsQ0FGSCxHQUV1QixHQUZ2QixHQUU2QlAsRUFBRSxDQUFDRSxDQUFDLENBQUNNLGFBQUYsRUFBRCxDQUYvQixHQUdMLEdBSEssR0FHQ1IsRUFBRSxDQUFDRSxDQUFDLENBQUNPLGFBQUYsRUFBRCxDQUhILEdBR3lCLEdBSHpCLElBR2dDdkosQ0FBQyxHQUFHLEVBQUosR0FBU0EsQ0FBVCxHQUFhLE1BQU04SSxFQUFFLENBQUM5SSxDQUFELENBSHJELElBRzRELEdBSG5FO0VBSUQsQ0FkZ0IsR0FjYjZJLFlBZEo7O0VDUEE7O0FBQ0F6YSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixJQUFhK1osSUFBSSxDQUFDN2EsU0FBTCxDQUFlZ2IsV0FBZixLQUErQkEsZ0JBQTVDLENBQWIsRUFBdUUsTUFBdkUsRUFBK0U7SUFDcEZBLFdBQVcsRUFBRUE7RUFEdUUsQ0FBL0UsQ0FBUDs7RUNMQSxJQUFJYSxTQUFTLEdBQUdoQixJQUFJLENBQUM3YSxTQUFyQjtFQUNBLElBQUk4YixZQUFZLEdBQUcsY0FBbkI7RUFDQSxJQUFJemMsU0FBUyxHQUFHLFVBQWhCO0VBQ0EsSUFBSUUsU0FBUyxHQUFHc2MsU0FBUyxDQUFDeGMsU0FBRCxDQUF6QjtFQUNBLElBQUl5YixTQUFPLEdBQUdlLFNBQVMsQ0FBQ2YsT0FBeEI7O0VBQ0EsSUFBSSxJQUFJRCxJQUFKLENBQVNySyxHQUFULElBQWdCLEVBQWhCLElBQXNCc0wsWUFBMUIsRUFBd0M7SUFDdEN2ZixTQUFzQixDQUFDc2YsU0FBRCxFQUFZeGMsU0FBWixFQUF1QixTQUFTNUIsUUFBVCxHQUFvQjtNQUMvRCxJQUFJUyxLQUFLLEdBQUc0YyxTQUFPLENBQUMxZSxJQUFSLENBQWEsSUFBYixDQUFaLENBRCtEOztNQUcvRCxPQUFPOEIsS0FBSyxLQUFLQSxLQUFWLEdBQWtCcUIsU0FBUyxDQUFDbkQsSUFBVixDQUFlLElBQWYsQ0FBbEIsR0FBeUMwZixZQUFoRDtLQUhvQixDQUF0Qjs7O0VDSEYsSUFBSWpNLFFBQU0sR0FBRyxRQUFiOztFQUVBLG9CQUFjLEdBQUcseUJBQUEsQ0FBVWtNLElBQVYsRUFBZ0I7SUFDL0IsSUFBSUEsSUFBSSxLQUFLLFFBQVQsSUFBcUJBLElBQUksS0FBS2xNLFFBQTlCLElBQXdDa00sSUFBSSxLQUFLLFNBQXJELEVBQWdFLE1BQU0vZSxTQUFTLENBQUMsZ0JBQUQsQ0FBZjtJQUNoRSxPQUFPZ0IsWUFBVyxDQUFDRCxTQUFRLENBQUMsSUFBRCxDQUFULEVBQWlCZ2UsSUFBSSxJQUFJbE0sUUFBekIsQ0FBbEI7RUFDRCxDQUhEOztFQ0xBLElBQUkzSCxjQUFZLEdBQUczTCxJQUFpQixDQUFDLGFBQUQsQ0FBcEM7RUFDQSxJQUFJcVEsT0FBSyxHQUFHaU8sSUFBSSxDQUFDN2EsU0FBakI7RUFFQSxJQUFJLEVBQUVrSSxjQUFZLElBQUkwRSxPQUFsQixDQUFKLEVBQThCeFAsS0FBa0IsQ0FBQ3dQLE9BQUQsRUFBUTFFLGNBQVIsRUFBc0I3SyxnQkFBdEIsQ0FBbEI7O0FDQTlCb0QsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksT0FBWixFQUFxQjtJQUFFd0ksT0FBTyxFQUFFdko7RUFBWCxDQUFyQixDQUFQOztFQ0RBLGFBQWMsR0FBRyxrQkFBQSxDQUFVK00sUUFBVixFQUFvQi9MLEVBQXBCLEVBQXdCVyxLQUF4QixFQUErQm9aLE9BQS9CLEVBQXdDO0lBQ3ZELElBQUk7TUFDRixPQUFPQSxPQUFPLEdBQUcvWixFQUFFLENBQUNRLFNBQVEsQ0FBQ0csS0FBRCxDQUFSLENBQWdCLENBQWhCLENBQUQsRUFBcUJBLEtBQUssQ0FBQyxDQUFELENBQTFCLENBQUwsR0FBc0NYLEVBQUUsQ0FBQ1csS0FBRCxDQUF0RCxDQURFO0tBQUosQ0FHRSxPQUFPNUIsQ0FBUCxFQUFVO01BQ1YsSUFBSTBmLEdBQUcsR0FBRzFTLFFBQVEsQ0FBQyxRQUFELENBQWxCO01BQ0EsSUFBSTBTLEdBQUcsS0FBS2xkLFNBQVosRUFBdUJmLFNBQVEsQ0FBQ2llLEdBQUcsQ0FBQzVmLElBQUosQ0FBU2tOLFFBQVQsQ0FBRCxDQUFSO01BQ3ZCLE1BQU1oTixDQUFOOztFQUVILENBVEQ7O0VDQUEsSUFBSW1hLFVBQVEsR0FBR2xhLElBQWlCLENBQUMsVUFBRCxDQUFoQztFQUNBLElBQUkwZixVQUFVLEdBQUdwVyxLQUFLLENBQUM3RixTQUF2Qjs7RUFFQSxnQkFBYyxHQUFHLHFCQUFBLENBQVU5RCxFQUFWLEVBQWM7SUFDN0IsT0FBT0EsRUFBRSxLQUFLNEMsU0FBUCxLQUFxQmdaLFVBQVMsQ0FBQ2pTLEtBQVYsS0FBb0IzSixFQUFwQixJQUEwQitmLFVBQVUsQ0FBQ3hGLFVBQUQsQ0FBVixLQUF5QnZhLEVBQXhFLENBQVA7RUFDRCxDQUZEOztFQ0RBLG1CQUFjLEdBQUcsd0JBQUEsQ0FBVXFDLE1BQVYsRUFBa0IrRixLQUFsQixFQUF5QnBHLEtBQXpCLEVBQWdDO0lBQy9DLElBQUlvRyxLQUFLLElBQUkvRixNQUFiLEVBQXFCZ0wsU0FBZSxDQUFDL0ssQ0FBaEIsQ0FBa0JELE1BQWxCLEVBQTBCK0YsS0FBMUIsRUFBaUM3RixhQUFVLENBQUMsQ0FBRCxFQUFJUCxLQUFKLENBQTNDLEVBQXJCLEtBQ0tLLE1BQU0sQ0FBQytGLEtBQUQsQ0FBTixHQUFnQnBHLEtBQWhCO0VBQ04sQ0FIRDs7RUNIQSxJQUFJdVksVUFBUSxHQUFHbGEsSUFBaUIsQ0FBQyxVQUFELENBQWhDOztFQUVBLDBCQUFjLEdBQUdhLEtBQWtCLENBQUM4ZSxpQkFBbkIsR0FBdUMsVUFBVWhnQixFQUFWLEVBQWM7SUFDcEUsSUFBSUEsRUFBRSxJQUFJNEMsU0FBVixFQUFxQixPQUFPNUMsRUFBRSxDQUFDdWEsVUFBRCxDQUFGLElBQ3ZCdmEsRUFBRSxDQUFDLFlBQUQsQ0FEcUIsSUFFdkI0YixVQUFTLENBQUMxSyxRQUFPLENBQUNsUixFQUFELENBQVIsQ0FGTztFQUd0QixDQUpEOztFQ0hBLElBQUl1YSxVQUFRLEdBQUdsYSxJQUFpQixDQUFDLFVBQUQsQ0FBaEM7RUFDQSxJQUFJNGYsWUFBWSxHQUFHLEtBQW5COztFQUVBLElBQUk7SUFDRixJQUFJQyxLQUFLLEdBQUcsQ0FBQyxDQUFELEVBQUkzRixVQUFKLEdBQVo7O0lBQ0EyRixLQUFLLENBQUMsUUFBRCxDQUFMLEdBQWtCLFlBQVk7TUFBRUQsWUFBWSxHQUFHLElBQWY7S0FBaEMsQ0FGRTs7O0lBSUZ0VyxLQUFLLENBQUN3VyxJQUFOLENBQVdELEtBQVgsRUFBa0IsWUFBWTtNQUFFLE1BQU0sQ0FBTjtLQUFoQztFQUNELENBTEQsQ0FLRSxPQUFPOWYsQ0FBUCxFQUFVOztFQUFlOztFQUUzQixlQUFjLEdBQUcsb0JBQUEsQ0FBVUQsSUFBVixFQUFnQmlnQixXQUFoQixFQUE2QjtJQUM1QyxJQUFJLENBQUNBLFdBQUQsSUFBZ0IsQ0FBQ0gsWUFBckIsRUFBbUMsT0FBTyxLQUFQO0lBQ25DLElBQUl6YyxJQUFJLEdBQUcsS0FBWDs7SUFDQSxJQUFJO01BQ0YsSUFBSTZjLEdBQUcsR0FBRyxDQUFDLENBQUQsQ0FBVjtNQUNBLElBQUlDLElBQUksR0FBR0QsR0FBRyxDQUFDOUYsVUFBRCxDQUFILEVBQVg7O01BQ0ErRixJQUFJLENBQUNqRyxJQUFMLEdBQVksWUFBWTtRQUFFLE9BQU87VUFBRTZCLElBQUksRUFBRTFZLElBQUksR0FBRztTQUF0QjtPQUExQjs7TUFDQTZjLEdBQUcsQ0FBQzlGLFVBQUQsQ0FBSCxHQUFnQixZQUFZO1FBQUUsT0FBTytGLElBQVA7T0FBOUI7O01BQ0FuZ0IsSUFBSSxDQUFDa2dCLEdBQUQsQ0FBSjtLQUxGLENBTUUsT0FBT2pnQixDQUFQLEVBQVU7Ozs7SUFDWixPQUFPb0QsSUFBUDtFQUNELENBWEQ7O0FDQUFlLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBQ3ZFLFdBQXlCLENBQUMsVUFBVWlnQixJQUFWLEVBQWdCO0lBQUUzVyxLQUFLLENBQUN3VyxJQUFOLENBQVdHLElBQVg7RUFBbUIsQ0FBdEMsQ0FBbkQsRUFBNEYsT0FBNUYsRUFBcUc7O0lBRTFHSCxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjSTs7TUFBMEQ7TUFDNUUsSUFBSTdlLENBQUMsR0FBR2tOLFNBQVEsQ0FBQzJSLFNBQUQsQ0FBaEI7TUFDQSxJQUFJN00sQ0FBQyxHQUFHLE9BQU8sSUFBUCxJQUFlLFVBQWYsR0FBNEIsSUFBNUIsR0FBbUMvSixLQUEzQztNQUNBLElBQUkyRyxJQUFJLEdBQUdqTSxTQUFTLENBQUNMLE1BQXJCO01BQ0EsSUFBSXdjLEtBQUssR0FBR2xRLElBQUksR0FBRyxDQUFQLEdBQVdqTSxTQUFTLENBQUMsQ0FBRCxDQUFwQixHQUEwQnpCLFNBQXRDO01BQ0EsSUFBSTZkLE9BQU8sR0FBR0QsS0FBSyxLQUFLNWQsU0FBeEI7TUFDQSxJQUFJd0YsS0FBSyxHQUFHLENBQVo7TUFDQSxJQUFJc1ksTUFBTSxHQUFHQyxzQkFBUyxDQUFDamYsQ0FBRCxDQUF0QjtNQUNBLElBQUlzQyxNQUFKLEVBQVlnRixNQUFaLEVBQW9CNFgsSUFBcEIsRUFBMEJ4VCxRQUExQjtNQUNBLElBQUlxVCxPQUFKLEVBQWFELEtBQUssR0FBRy9hLElBQUcsQ0FBQythLEtBQUQsRUFBUWxRLElBQUksR0FBRyxDQUFQLEdBQVdqTSxTQUFTLENBQUMsQ0FBRCxDQUFwQixHQUEwQnpCLFNBQWxDLEVBQTZDLENBQTdDLENBQVgsQ0FUK0Q7O01BVzVFLElBQUk4ZCxNQUFNLElBQUk5ZCxTQUFWLElBQXVCLEVBQUU4USxDQUFDLElBQUkvSixLQUFMLElBQWNrWCxZQUFXLENBQUNILE1BQUQsQ0FBM0IsQ0FBM0IsRUFBaUU7UUFDL0QsS0FBS3RULFFBQVEsR0FBR3NULE1BQU0sQ0FBQ3hnQixJQUFQLENBQVl3QixDQUFaLENBQVgsRUFBMkJzSCxNQUFNLEdBQUcsSUFBSTBLLENBQUosRUFBekMsRUFBa0QsQ0FBQyxDQUFDa04sSUFBSSxHQUFHeFQsUUFBUSxDQUFDaU4sSUFBVCxFQUFSLEVBQXlCNkIsSUFBNUUsRUFBa0Y5VCxLQUFLLEVBQXZGLEVBQTJGO1VBQ3pGMFksZUFBYyxDQUFDOVgsTUFBRCxFQUFTWixLQUFULEVBQWdCcVksT0FBTyxHQUFHdmdCLFNBQUksQ0FBQ2tOLFFBQUQsRUFBV29ULEtBQVgsRUFBa0IsQ0FBQ0ksSUFBSSxDQUFDNWUsS0FBTixFQUFhb0csS0FBYixDQUFsQixFQUF1QyxJQUF2QyxDQUFQLEdBQXNEd1ksSUFBSSxDQUFDNWUsS0FBbEYsQ0FBZDs7T0FGSixNQUlPO1FBQ0xnQyxNQUFNLEdBQUcwRSxTQUFRLENBQUNoSCxDQUFDLENBQUNzQyxNQUFILENBQWpCOztRQUNBLEtBQUtnRixNQUFNLEdBQUcsSUFBSTBLLENBQUosQ0FBTTFQLE1BQU4sQ0FBZCxFQUE2QkEsTUFBTSxHQUFHb0UsS0FBdEMsRUFBNkNBLEtBQUssRUFBbEQsRUFBc0Q7VUFDcEQwWSxlQUFjLENBQUM5WCxNQUFELEVBQVNaLEtBQVQsRUFBZ0JxWSxPQUFPLEdBQUdELEtBQUssQ0FBQzllLENBQUMsQ0FBQzBHLEtBQUQsQ0FBRixFQUFXQSxLQUFYLENBQVIsR0FBNEIxRyxDQUFDLENBQUMwRyxLQUFELENBQXBELENBQWQ7Ozs7TUFHSlksTUFBTSxDQUFDaEYsTUFBUCxHQUFnQm9FLEtBQWhCO01BQ0EsT0FBT1ksTUFBUDs7RUF4QndHLENBQXJHLENBQVA7O0FDTEF6RSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZdkUsTUFBbUIsQ0FBQyxZQUFZO0lBQzlELFNBQVN1RSxDQUFULEdBQWE7Ozs7SUFDYixPQUFPLEVBQUUrRSxLQUFLLENBQUNvWCxFQUFOLENBQVM3Z0IsSUFBVCxDQUFjMEUsQ0FBZCxhQUE0QkEsQ0FBOUIsQ0FBUDtFQUNELENBSGtELENBQTVDLEVBR0gsT0FIRyxFQUdNOztJQUVYbWMsRUFBRSxFQUFFOztJQUFTQSxFQUFULEdBQTJCO01BQzdCLElBQUkzWSxLQUFLLEdBQUcsQ0FBWjtNQUNBLElBQUlrSSxJQUFJLEdBQUdqTSxTQUFTLENBQUNMLE1BQXJCO01BQ0EsSUFBSWdGLE1BQU0sR0FBRyxLQUFLLE9BQU8sSUFBUCxJQUFlLFVBQWYsR0FBNEIsSUFBNUIsR0FBbUNXLEtBQXhDLEVBQStDMkcsSUFBL0MsQ0FBYjs7TUFDQSxPQUFPQSxJQUFJLEdBQUdsSSxLQUFkO1FBQXFCMFksZUFBYyxDQUFDOVgsTUFBRCxFQUFTWixLQUFULEVBQWdCL0QsU0FBUyxDQUFDK0QsS0FBSyxFQUFOLENBQXpCLENBQWQ7OztNQUNyQlksTUFBTSxDQUFDaEYsTUFBUCxHQUFnQnNNLElBQWhCO01BQ0EsT0FBT3RILE1BQVA7O0VBUlMsQ0FITixDQUFQOztFQ0ZBLGlCQUFjLEdBQUcsc0JBQUEsQ0FBVWdZLE1BQVYsRUFBa0JuWCxHQUFsQixFQUF1QjtJQUN0QyxPQUFPLENBQUMsQ0FBQ21YLE1BQUYsSUFBWTlSLE1BQUssQ0FBQyxZQUFZOztNQUVuQ3JGLEdBQUcsR0FBR21YLE1BQU0sQ0FBQzlnQixJQUFQLENBQVksSUFBWixFQUFrQixZQUFZOztPQUE5QixFQUErQyxDQUEvQyxDQUFILEdBQXVEOGdCLE1BQU0sQ0FBQzlnQixJQUFQLENBQVksSUFBWixDQUExRDtLQUZzQixDQUF4QjtFQUlELENBTEQ7O0VDQ0EsSUFBSStnQixTQUFTLEdBQUcsR0FBR3JkLElBQW5COztBQUdBVyxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixJQUFhdkUsUUFBcUIsSUFBSUMsTUFBekIsSUFBbUMsQ0FBQ1ksYUFBMkIsQ0FBQytmLFNBQUQsQ0FBNUUsQ0FBYixFQUF1RyxPQUF2RyxFQUFnSDtJQUNySHJkLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNzZCxTQUFkLEVBQXlCO01BQzdCLE9BQU9ELFNBQVMsQ0FBQy9nQixJQUFWLENBQWV1SSxVQUFTLENBQUMsSUFBRCxDQUF4QixFQUFnQ3lZLFNBQVMsS0FBS3RlLFNBQWQsR0FBMEIsR0FBMUIsR0FBZ0NzZSxTQUFoRSxDQUFQOztFQUZtSCxDQUFoSCxDQUFQOztFQ0RBLElBQUk5UCxZQUFVLEdBQUcsR0FBRzNKLEtBQXBCOztBQUdBbEQsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWXZFLE1BQW1CLENBQUMsWUFBWTtJQUM5RCxJQUFJOGdCLEtBQUosRUFBVS9QLFlBQVUsQ0FBQ2xSLElBQVgsQ0FBZ0JpaEIsS0FBaEI7RUFDWCxDQUZrRCxDQUE1QyxFQUVILE9BRkcsRUFFTTtJQUNYMVosS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZTJaLEtBQWYsRUFBc0J2RSxHQUF0QixFQUEyQjtNQUNoQyxJQUFJdEwsR0FBRyxHQUFHN0ksU0FBUSxDQUFDLEtBQUsxRSxNQUFOLENBQWxCO01BQ0EsSUFBSXFkLEtBQUssR0FBRzFaLElBQUcsQ0FBQyxJQUFELENBQWY7TUFDQWtWLEdBQUcsR0FBR0EsR0FBRyxLQUFLamEsU0FBUixHQUFvQjJPLEdBQXBCLEdBQTBCc0wsR0FBaEM7TUFDQSxJQUFJd0UsS0FBSyxJQUFJLE9BQWIsRUFBc0IsT0FBT2pRLFlBQVUsQ0FBQ2xSLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0JraEIsS0FBdEIsRUFBNkJ2RSxHQUE3QixDQUFQO01BQ3RCLElBQUl5RSxLQUFLLEdBQUczWSxnQkFBZSxDQUFDeVksS0FBRCxFQUFRN1AsR0FBUixDQUEzQjtNQUNBLElBQUlnUSxJQUFJLEdBQUc1WSxnQkFBZSxDQUFDa1UsR0FBRCxFQUFNdEwsR0FBTixDQUExQjtNQUNBLElBQUkyTSxJQUFJLEdBQUd4VixTQUFRLENBQUM2WSxJQUFJLEdBQUdELEtBQVIsQ0FBbkI7TUFDQSxJQUFJRSxNQUFNLEdBQUcsSUFBSTdYLEtBQUosQ0FBVXVVLElBQVYsQ0FBYjtNQUNBLElBQUk5WCxDQUFDLEdBQUcsQ0FBUjs7TUFDQSxPQUFPQSxDQUFDLEdBQUc4WCxJQUFYLEVBQWlCOVgsQ0FBQyxFQUFsQjtRQUFzQm9iLE1BQU0sQ0FBQ3BiLENBQUQsQ0FBTixHQUFZaWIsS0FBSyxJQUFJLFFBQVQsR0FDOUIsS0FBSzlaLE1BQUwsQ0FBWStaLEtBQUssR0FBR2xiLENBQXBCLENBRDhCLEdBRTlCLEtBQUtrYixLQUFLLEdBQUdsYixDQUFiLENBRmtCOzs7TUFHdEIsT0FBT29iLE1BQVA7O0VBZFMsQ0FGTixDQUFQOztFQ0pBLElBQUlDLEtBQUssR0FBRyxHQUFHQyxJQUFmO0VBQ0EsSUFBSTlRLE1BQUksR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFYO0FBRUFyTSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixJQUFhc0ssTUFBSyxDQUFDLFlBQVk7O0lBRWpEMEIsTUFBSSxDQUFDOFEsSUFBTCxDQUFVOWUsU0FBVjtFQUNELENBSHFDLENBQUwsSUFHM0IsQ0FBQ3NNLE1BQUssQ0FBQyxZQUFZOztJQUV2QjBCLE1BQUksQ0FBQzhRLElBQUwsQ0FBVSxJQUFWLEVBRnVCO0VBSXhCLENBSlcsQ0FIcUIsSUFPM0IsQ0FBQ3JoQixhQUEyQixDQUFDb2hCLEtBQUQsQ0FQZCxDQUFiLEVBT3FDLE9BUHJDLEVBTzhDOztJQUVuREMsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY0MsU0FBZCxFQUF5QjtNQUM3QixPQUFPQSxTQUFTLEtBQUsvZSxTQUFkLEdBQ0g2ZSxLQUFLLENBQUN2aEIsSUFBTixDQUFXME8sU0FBUSxDQUFDLElBQUQsQ0FBbkIsQ0FERyxHQUVINlMsS0FBSyxDQUFDdmhCLElBQU4sQ0FBVzBPLFNBQVEsQ0FBQyxJQUFELENBQW5CLEVBQTJCM0ssVUFBUyxDQUFDMGQsU0FBRCxDQUFwQyxDQUZKOztFQUhpRCxDQVA5QyxDQUFQOztFQ05BLElBQUlDLE9BQU8sR0FBR3ZoQixJQUFpQixDQUFDLFNBQUQsQ0FBL0I7O0VBRUEsNEJBQWMsR0FBRyxpQ0FBQSxDQUFVd2hCLFFBQVYsRUFBb0I7SUFDbkMsSUFBSW5PLENBQUo7O0lBQ0EsSUFBSTlKLFFBQU8sQ0FBQ2lZLFFBQUQsQ0FBWCxFQUF1QjtNQUNyQm5PLENBQUMsR0FBR21PLFFBQVEsQ0FBQ3pTLFdBQWIsQ0FEcUI7O01BR3JCLElBQUksT0FBT3NFLENBQVAsSUFBWSxVQUFaLEtBQTJCQSxDQUFDLEtBQUsvSixLQUFOLElBQWVDLFFBQU8sQ0FBQzhKLENBQUMsQ0FBQzVQLFNBQUgsQ0FBakQsQ0FBSixFQUFxRTRQLENBQUMsR0FBRzlRLFNBQUo7O01BQ3JFLElBQUkvQixTQUFRLENBQUM2UyxDQUFELENBQVosRUFBaUI7UUFDZkEsQ0FBQyxHQUFHQSxDQUFDLENBQUNrTyxPQUFELENBQUw7UUFDQSxJQUFJbE8sQ0FBQyxLQUFLLElBQVYsRUFBZ0JBLENBQUMsR0FBRzlRLFNBQUo7Ozs7SUFFbEIsT0FBTzhRLENBQUMsS0FBSzlRLFNBQU4sR0FBa0IrRyxLQUFsQixHQUEwQitKLENBQWpDO0VBQ0gsQ0FYRDs7RUNEQSx1QkFBYyxHQUFHLDRCQUFBLENBQVVtTyxRQUFWLEVBQW9CN2QsTUFBcEIsRUFBNEI7SUFDM0MsT0FBTyxLQUFLOGQsd0JBQWtCLENBQUNELFFBQUQsQ0FBdkIsRUFBbUM3ZCxNQUFuQyxDQUFQO0VBQ0QsQ0FGRDs7RUNGQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBTUEsaUJBQWMsR0FBRyxzQkFBQSxDQUFVOE8sSUFBVixFQUFnQnJGLE9BQWhCLEVBQXlCO0lBQ3hDLElBQUlzVSxNQUFNLEdBQUdqUCxJQUFJLElBQUksQ0FBckI7SUFDQSxJQUFJa1AsU0FBUyxHQUFHbFAsSUFBSSxJQUFJLENBQXhCO0lBQ0EsSUFBSW1QLE9BQU8sR0FBR25QLElBQUksSUFBSSxDQUF0QjtJQUNBLElBQUlvUCxRQUFRLEdBQUdwUCxJQUFJLElBQUksQ0FBdkI7SUFDQSxJQUFJcVAsYUFBYSxHQUFHclAsSUFBSSxJQUFJLENBQTVCO0lBQ0EsSUFBSXNQLFFBQVEsR0FBR3RQLElBQUksSUFBSSxDQUFSLElBQWFxUCxhQUE1QjtJQUNBLElBQUk1YixNQUFNLEdBQUdrSCxPQUFPLElBQUk0VSxtQkFBeEI7SUFDQSxPQUFPLFVBQVUvWixLQUFWLEVBQWlCZ2EsVUFBakIsRUFBNkJ2ZSxJQUE3QixFQUFtQztNQUN4QyxJQUFJckMsQ0FBQyxHQUFHa04sU0FBUSxDQUFDdEcsS0FBRCxDQUFoQjtNQUNBLElBQUkxSSxJQUFJLEdBQUdnSSxRQUFPLENBQUNsRyxDQUFELENBQWxCO01BQ0EsSUFBSVksQ0FBQyxHQUFHbUQsSUFBRyxDQUFDNmMsVUFBRCxFQUFhdmUsSUFBYixFQUFtQixDQUFuQixDQUFYO01BQ0EsSUFBSUMsTUFBTSxHQUFHMEUsU0FBUSxDQUFDOUksSUFBSSxDQUFDb0UsTUFBTixDQUFyQjtNQUNBLElBQUlvRSxLQUFLLEdBQUcsQ0FBWjtNQUNBLElBQUlZLE1BQU0sR0FBRytZLE1BQU0sR0FBR3hiLE1BQU0sQ0FBQytCLEtBQUQsRUFBUXRFLE1BQVIsQ0FBVCxHQUEyQmdlLFNBQVMsR0FBR3piLE1BQU0sQ0FBQytCLEtBQUQsRUFBUSxDQUFSLENBQVQsR0FBc0IxRixTQUE3RTtNQUNBLElBQUl0QixHQUFKLEVBQVMwVCxHQUFUOztNQUNBLE9BQU1oUixNQUFNLEdBQUdvRSxLQUFmLEVBQXNCQSxLQUFLLEVBQTNCO1FBQStCLElBQUlnYSxRQUFRLElBQUloYSxLQUFLLElBQUl4SSxJQUF6QixFQUErQjtVQUM1RDBCLEdBQUcsR0FBRzFCLElBQUksQ0FBQ3dJLEtBQUQsQ0FBVjtVQUNBNE0sR0FBRyxHQUFHMVMsQ0FBQyxDQUFDaEIsR0FBRCxFQUFNOEcsS0FBTixFQUFhMUcsQ0FBYixDQUFQOztVQUNBLElBQUlvUixJQUFKLEVBQVU7WUFDUixJQUFJaVAsTUFBSixFQUFZL1ksTUFBTSxDQUFDWixLQUFELENBQU4sR0FBZ0I0TSxHQUFoQixDQUFaO2lCQUNLLElBQUlBLEdBQUosRUFBUyxRQUFRbEMsSUFBUjtjQUNaLEtBQUssQ0FBTDtnQkFBUSxPQUFPLElBQVA7OztjQUNSLEtBQUssQ0FBTDtnQkFBUSxPQUFPeFIsR0FBUDs7O2NBQ1IsS0FBSyxDQUFMO2dCQUFRLE9BQU84RyxLQUFQOzs7Y0FDUixLQUFLLENBQUw7Z0JBQVFZLE1BQU0sQ0FBQ2pHLElBQVAsQ0FBWXpCLEdBQVo7O2FBSkwsTUFLRSxJQUFJNGdCLFFBQUosRUFBYyxPQUFPLEtBQVAsQ0FQYjs7Ozs7TUFVWixPQUFPQyxhQUFhLEdBQUcsQ0FBQyxDQUFKLEdBQVFGLE9BQU8sSUFBSUMsUUFBWCxHQUFzQkEsUUFBdEIsR0FBaUNsWixNQUE3RDtLQXJCRjtFQXVCRCxDQS9CRDs7RUNWQSxJQUFJdVosUUFBUSxHQUFHbGlCLGFBQTJCLENBQUMsQ0FBRCxDQUExQztFQUNBLElBQUltaUIsTUFBTSxHQUFHdGhCLGFBQTJCLENBQUMsR0FBR2tQLE9BQUosRUFBYSxJQUFiLENBQXhDO0FBRUE3TCxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUM0ZCxNQUExQixFQUFrQyxPQUFsQyxFQUEyQzs7SUFFaERwUyxPQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFpQmtTOztNQUE0QjtNQUNwRCxPQUFPQyxRQUFRLENBQUMsSUFBRCxFQUFPRCxVQUFQLEVBQW1CamUsU0FBUyxDQUFDLENBQUQsQ0FBNUIsQ0FBZjs7RUFIOEMsQ0FBM0MsQ0FBUDs7RUNIQSxJQUFJb2UsSUFBSSxHQUFHcGlCLGFBQTJCLENBQUMsQ0FBRCxDQUF0QztBQUVBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDMUQsYUFBMkIsQ0FBQyxHQUFHd2hCLEdBQUosRUFBUyxJQUFULENBQXJELEVBQXFFLE9BQXJFLEVBQThFOztJQUVuRkEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYUo7O01BQTRCO01BQzVDLE9BQU9HLElBQUksQ0FBQyxJQUFELEVBQU9ILFVBQVAsRUFBbUJqZSxTQUFTLENBQUMsQ0FBRCxDQUE1QixDQUFYOztFQUhpRixDQUE5RSxDQUFQOztFQ0ZBLElBQUlzZSxPQUFPLEdBQUd0aUIsYUFBMkIsQ0FBQyxDQUFELENBQXpDO0FBRUFrRSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUMxRCxhQUEyQixDQUFDLEdBQUcwaEIsTUFBSixFQUFZLElBQVosQ0FBckQsRUFBd0UsT0FBeEUsRUFBaUY7O0lBRXRGQSxNQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQk47O01BQTRCO01BQ2xELE9BQU9LLE9BQU8sQ0FBQyxJQUFELEVBQU9MLFVBQVAsRUFBbUJqZSxTQUFTLENBQUMsQ0FBRCxDQUE1QixDQUFkOztFQUhvRixDQUFqRixDQUFQOztFQ0ZBLElBQUl3ZSxLQUFLLEdBQUd4aUIsYUFBMkIsQ0FBQyxDQUFELENBQXZDO0FBRUFrRSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUMxRCxhQUEyQixDQUFDLEdBQUc0aEIsSUFBSixFQUFVLElBQVYsQ0FBckQsRUFBc0UsT0FBdEUsRUFBK0U7O0lBRXBGQSxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjUjs7TUFBNEI7TUFDOUMsT0FBT08sS0FBSyxDQUFDLElBQUQsRUFBT1AsVUFBUCxFQUFtQmplLFNBQVMsQ0FBQyxDQUFELENBQTVCLENBQVo7O0VBSGtGLENBQS9FLENBQVA7O0VDRkEsSUFBSTBlLE1BQU0sR0FBRzFpQixhQUEyQixDQUFDLENBQUQsQ0FBeEM7QUFFQWtFLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBQzFELGFBQTJCLENBQUMsR0FBRzhoQixLQUFKLEVBQVcsSUFBWCxDQUFyRCxFQUF1RSxPQUF2RSxFQUFnRjs7SUFFckZBLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWVWOztNQUE0QjtNQUNoRCxPQUFPUyxNQUFNLENBQUMsSUFBRCxFQUFPVCxVQUFQLEVBQW1CamUsU0FBUyxDQUFDLENBQUQsQ0FBNUIsQ0FBYjs7RUFIbUYsQ0FBaEYsQ0FBUDs7RUNDQSxnQkFBYyxHQUFHLHFCQUFBLENBQVVOLElBQVYsRUFBZ0J1ZSxVQUFoQixFQUE0QmhTLElBQTVCLEVBQWtDMlMsSUFBbEMsRUFBd0NDLE9BQXhDLEVBQWlEO0lBQ2hFamYsVUFBUyxDQUFDcWUsVUFBRCxDQUFUO0lBQ0EsSUFBSTVnQixDQUFDLEdBQUdrTixTQUFRLENBQUM3SyxJQUFELENBQWhCO0lBQ0EsSUFBSW5FLElBQUksR0FBR2dJLFFBQU8sQ0FBQ2xHLENBQUQsQ0FBbEI7SUFDQSxJQUFJc0MsTUFBTSxHQUFHMEUsU0FBUSxDQUFDaEgsQ0FBQyxDQUFDc0MsTUFBSCxDQUFyQjtJQUNBLElBQUlvRSxLQUFLLEdBQUc4YSxPQUFPLEdBQUdsZixNQUFNLEdBQUcsQ0FBWixHQUFnQixDQUFuQztJQUNBLElBQUlvQyxDQUFDLEdBQUc4YyxPQUFPLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBdkI7SUFDQSxJQUFJNVMsSUFBSSxHQUFHLENBQVgsRUFBYyxTQUFTO01BQ3JCLElBQUlsSSxLQUFLLElBQUl4SSxJQUFiLEVBQW1CO1FBQ2pCcWpCLElBQUksR0FBR3JqQixJQUFJLENBQUN3SSxLQUFELENBQVg7UUFDQUEsS0FBSyxJQUFJaEMsQ0FBVDtRQUNBOzs7TUFFRmdDLEtBQUssSUFBSWhDLENBQVQ7O01BQ0EsSUFBSThjLE9BQU8sR0FBRzlhLEtBQUssR0FBRyxDQUFYLEdBQWVwRSxNQUFNLElBQUlvRSxLQUFwQyxFQUEyQztRQUN6QyxNQUFNdEgsU0FBUyxDQUFDLDZDQUFELENBQWY7Ozs7SUFHSixPQUFNb2lCLE9BQU8sR0FBRzlhLEtBQUssSUFBSSxDQUFaLEdBQWdCcEUsTUFBTSxHQUFHb0UsS0FBdEMsRUFBNkNBLEtBQUssSUFBSWhDLENBQXREO01BQXlELElBQUlnQyxLQUFLLElBQUl4SSxJQUFiLEVBQW1CO1FBQzFFcWpCLElBQUksR0FBR1gsVUFBVSxDQUFDVyxJQUFELEVBQU9yakIsSUFBSSxDQUFDd0ksS0FBRCxDQUFYLEVBQW9CQSxLQUFwQixFQUEyQjFHLENBQTNCLENBQWpCOzs7O0lBRUYsT0FBT3VoQixJQUFQO0VBQ0QsQ0F0QkQ7O0FDREExZSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUN2RSxhQUEyQixDQUFDLEdBQUc4aUIsTUFBSixFQUFZLElBQVosQ0FBckQsRUFBd0UsT0FBeEUsRUFBaUY7O0lBRXRGQSxNQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQmI7O01BQWlDO01BQ3ZELE9BQU9jLFlBQU8sQ0FBQyxJQUFELEVBQU9kLFVBQVAsRUFBbUJqZSxTQUFTLENBQUNMLE1BQTdCLEVBQXFDSyxTQUFTLENBQUMsQ0FBRCxDQUE5QyxFQUFtRCxLQUFuRCxDQUFkOztFQUhvRixDQUFqRixDQUFQOztBQ0FBRSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUN2RSxhQUEyQixDQUFDLEdBQUdnakIsV0FBSixFQUFpQixJQUFqQixDQUFyRCxFQUE2RSxPQUE3RSxFQUFzRjs7SUFFM0ZBLFdBQVcsRUFBRSxTQUFTQSxXQUFULENBQXFCZjs7TUFBaUM7TUFDakUsT0FBT2MsWUFBTyxDQUFDLElBQUQsRUFBT2QsVUFBUCxFQUFtQmplLFNBQVMsQ0FBQ0wsTUFBN0IsRUFBcUNLLFNBQVMsQ0FBQyxDQUFELENBQTlDLEVBQW1ELElBQW5ELENBQWQ7O0VBSHlGLENBQXRGLENBQVA7O0VDRkEsSUFBSWlmLFFBQVEsR0FBR2pqQixjQUE0QixDQUFDLEtBQUQsQ0FBM0M7RUFDQSxJQUFJa2IsT0FBTyxHQUFHLEdBQUcwQixPQUFqQjtFQUNBLElBQUlzRyxhQUFhLEdBQUcsQ0FBQyxDQUFDaEksT0FBRixJQUFhLElBQUksQ0FBQyxDQUFELEVBQUkwQixPQUFKLENBQVksQ0FBWixFQUFlLENBQUMsQ0FBaEIsQ0FBSixHQUF5QixDQUExRDtBQUVBMVksU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsSUFBYTJlLGFBQWEsSUFBSSxDQUFDcmlCLGFBQTJCLENBQUNxYSxPQUFELENBQTFELENBQWIsRUFBbUYsT0FBbkYsRUFBNEY7O0lBRWpHMEIsT0FBTyxFQUFFLFNBQVNBLE9BQVQsQ0FBaUJ1Rzs7TUFBcUM7TUFDN0QsT0FBT0QsYUFBYTtRQUVoQmhJLE9BQU8sQ0FBQ25YLEtBQVIsQ0FBYyxJQUFkLEVBQW9CQyxTQUFwQixLQUFrQyxDQUZsQixHQUdoQmlmLFFBQVEsQ0FBQyxJQUFELEVBQU9FLGFBQVAsRUFBc0JuZixTQUFTLENBQUMsQ0FBRCxDQUEvQixDQUhaOztFQUgrRixDQUE1RixDQUFQOztFQ0RBLElBQUlrWCxTQUFPLEdBQUcsR0FBR2tJLFdBQWpCO0VBQ0EsSUFBSUYsZUFBYSxHQUFHLENBQUMsQ0FBQ2hJLFNBQUYsSUFBYSxJQUFJLENBQUMsQ0FBRCxFQUFJa0ksV0FBSixDQUFnQixDQUFoQixFQUFtQixDQUFDLENBQXBCLENBQUosR0FBNkIsQ0FBOUQ7QUFFQWxmLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLElBQWEyZSxlQUFhLElBQUksQ0FBQ2xqQixhQUEyQixDQUFDa2IsU0FBRCxDQUExRCxDQUFiLEVBQW1GLE9BQW5GLEVBQTRGOztJQUVqR2tJLFdBQVcsRUFBRSxTQUFTQSxXQUFULENBQXFCRDs7TUFBMEM7O01BRTFFLElBQUlELGVBQUosRUFBbUIsT0FBT2hJLFNBQU8sQ0FBQ25YLEtBQVIsQ0FBYyxJQUFkLEVBQW9CQyxTQUFwQixLQUFrQyxDQUF6QztNQUNuQixJQUFJM0MsQ0FBQyxHQUFHK0csVUFBUyxDQUFDLElBQUQsQ0FBakI7TUFDQSxJQUFJekUsTUFBTSxHQUFHMEUsU0FBUSxDQUFDaEgsQ0FBQyxDQUFDc0MsTUFBSCxDQUFyQjtNQUNBLElBQUlvRSxLQUFLLEdBQUdwRSxNQUFNLEdBQUcsQ0FBckI7TUFDQSxJQUFJSyxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEJvRSxLQUFLLEdBQUd6SSxJQUFJLENBQUNzSSxHQUFMLENBQVNHLEtBQVQsRUFBZ0JGLFVBQVMsQ0FBQzdELFNBQVMsQ0FBQyxDQUFELENBQVYsQ0FBekIsQ0FBUjtNQUMxQixJQUFJK0QsS0FBSyxHQUFHLENBQVosRUFBZUEsS0FBSyxHQUFHcEUsTUFBTSxHQUFHb0UsS0FBakI7O01BQ2YsT0FBTUEsS0FBSyxJQUFJLENBQWYsRUFBa0JBLEtBQUssRUFBdkI7UUFBMkIsSUFBSUEsS0FBSyxJQUFJMUcsQ0FBYixFQUFnQixJQUFJQSxDQUFDLENBQUMwRyxLQUFELENBQUQsS0FBYW9iLGFBQWpCLEVBQWdDLE9BQU9wYixLQUFLLElBQUksQ0FBaEI7OztNQUMzRSxPQUFPLENBQUMsQ0FBUjs7RUFYK0YsQ0FBNUYsQ0FBUDs7RUNGQSxvQkFBYyxHQUFHLEdBQUdzYixVQUFILElBQWlCLFNBQVNBLFVBQVQsQ0FBb0J2ZTs7RUFBcEIsRUFBc0NtYzs7RUFBdEMsRUFBc0U7SUFDdEcsSUFBSTVmLENBQUMsR0FBR2tOLFNBQVEsQ0FBQyxJQUFELENBQWhCO0lBQ0EsSUFBSTJDLEdBQUcsR0FBRzdJLFNBQVEsQ0FBQ2hILENBQUMsQ0FBQ3NDLE1BQUgsQ0FBbEI7SUFDQSxJQUFJMmYsRUFBRSxHQUFHaGIsZ0JBQWUsQ0FBQ3hELE1BQUQsRUFBU29NLEdBQVQsQ0FBeEI7SUFDQSxJQUFJNE8sSUFBSSxHQUFHeFgsZ0JBQWUsQ0FBQzJZLEtBQUQsRUFBUS9QLEdBQVIsQ0FBMUI7SUFDQSxJQUFJc0wsR0FBRyxHQUFHeFksU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQWhEO0lBQ0EsSUFBSW1TLEtBQUssR0FBR3BWLElBQUksQ0FBQ3NJLEdBQUwsQ0FBUyxDQUFDNFUsR0FBRyxLQUFLamEsU0FBUixHQUFvQjJPLEdBQXBCLEdBQTBCNUksZ0JBQWUsQ0FBQ2tVLEdBQUQsRUFBTXRMLEdBQU4sQ0FBMUMsSUFBd0Q0TyxJQUFqRSxFQUF1RTVPLEdBQUcsR0FBR29TLEVBQTdFLENBQVo7SUFDQSxJQUFJQyxHQUFHLEdBQUcsQ0FBVjs7SUFDQSxJQUFJekQsSUFBSSxHQUFHd0QsRUFBUCxJQUFhQSxFQUFFLEdBQUd4RCxJQUFJLEdBQUdwTCxLQUE3QixFQUFvQztNQUNsQzZPLEdBQUcsR0FBRyxDQUFDLENBQVA7TUFDQXpELElBQUksSUFBSXBMLEtBQUssR0FBRyxDQUFoQjtNQUNBNE8sRUFBRSxJQUFJNU8sS0FBSyxHQUFHLENBQWQ7OztJQUVGLE9BQU9BLEtBQUssS0FBSyxDQUFqQixFQUFvQjtNQUNsQixJQUFJb0wsSUFBSSxJQUFJemUsQ0FBWixFQUFlQSxDQUFDLENBQUNpaUIsRUFBRCxDQUFELEdBQVFqaUIsQ0FBQyxDQUFDeWUsSUFBRCxDQUFULENBQWYsS0FDSyxPQUFPemUsQ0FBQyxDQUFDaWlCLEVBQUQsQ0FBUjtNQUNMQSxFQUFFLElBQUlDLEdBQU47TUFDQXpELElBQUksSUFBSXlELEdBQVI7OztJQUNBLE9BQU9saUIsQ0FBUDtFQUNILENBbkJEOztFQ0xBLElBQUltaUIsV0FBVyxHQUFHeGpCLElBQWlCLENBQUMsYUFBRCxDQUFuQztFQUNBLElBQUkwZixZQUFVLEdBQUdwVyxLQUFLLENBQUM3RixTQUF2QjtFQUNBLElBQUlpYyxZQUFVLENBQUM4RCxXQUFELENBQVYsSUFBMkJqaEIsU0FBL0IsRUFBMEMxQixLQUFrQixDQUFDNmUsWUFBRCxFQUFhOEQsV0FBYixFQUEwQixFQUExQixDQUFsQjs7RUFDMUMscUJBQWMsR0FBRywwQkFBQSxDQUFVNWpCLEdBQVYsRUFBZTtJQUM5QjhmLFlBQVUsQ0FBQzhELFdBQUQsQ0FBVixDQUF3QjVqQixHQUF4QixJQUErQixJQUEvQjtFQUNELENBRkQ7O0FDREFzRSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVQsRUFBWSxPQUFaLEVBQXFCO0lBQUUraEIsVUFBVSxFQUFFcmpCO0VBQWQsQ0FBckIsQ0FBUDtBQUVBYSxtQkFBZ0MsQ0FBQyxZQUFELENBQWhDOztFQ0FBLGNBQWMsR0FBRyxTQUFTNGlCLElBQVQsQ0FBYzloQjs7RUFBZCxFQUFzRDtJQUNyRSxJQUFJTixDQUFDLEdBQUdrTixTQUFRLENBQUMsSUFBRCxDQUFoQjtJQUNBLElBQUk1SyxNQUFNLEdBQUcwRSxTQUFRLENBQUNoSCxDQUFDLENBQUNzQyxNQUFILENBQXJCO0lBQ0EsSUFBSXNNLElBQUksR0FBR2pNLFNBQVMsQ0FBQ0wsTUFBckI7SUFDQSxJQUFJb0UsS0FBSyxHQUFHTyxnQkFBZSxDQUFDMkgsSUFBSSxHQUFHLENBQVAsR0FBV2pNLFNBQVMsQ0FBQyxDQUFELENBQXBCLEdBQTBCekIsU0FBM0IsRUFBc0NvQixNQUF0QyxDQUEzQjtJQUNBLElBQUk2WSxHQUFHLEdBQUd2TSxJQUFJLEdBQUcsQ0FBUCxHQUFXak0sU0FBUyxDQUFDLENBQUQsQ0FBcEIsR0FBMEJ6QixTQUFwQztJQUNBLElBQUltaEIsTUFBTSxHQUFHbEgsR0FBRyxLQUFLamEsU0FBUixHQUFvQm9CLE1BQXBCLEdBQTZCMkUsZ0JBQWUsQ0FBQ2tVLEdBQUQsRUFBTTdZLE1BQU4sQ0FBekQ7O0lBQ0EsT0FBTytmLE1BQU0sR0FBRzNiLEtBQWhCO01BQXVCMUcsQ0FBQyxDQUFDMEcsS0FBSyxFQUFOLENBQUQsR0FBYXBHLEtBQWI7OztJQUN2QixPQUFPTixDQUFQO0VBQ0QsQ0FURDs7QUNGQTZDLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBVCxFQUFZLE9BQVosRUFBcUI7SUFBRW1pQixJQUFJLEVBQUV6akI7RUFBUixDQUFyQixDQUFQO0FBRUFhLG1CQUFnQyxDQUFDLE1BQUQsQ0FBaEM7O0VDRkEsSUFBSThpQixLQUFLLEdBQUczakIsYUFBMkIsQ0FBQyxDQUFELENBQXZDO0VBQ0EsSUFBSXVHLEdBQUcsR0FBRyxNQUFWO0VBQ0EsSUFBSXFkLE1BQU0sR0FBRyxJQUFiOztFQUVBLElBQUlyZCxHQUFHLElBQUksRUFBWCxFQUFlK0MsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTL0MsR0FBVCxFQUFjLFlBQVk7SUFBRXFkLE1BQU0sR0FBRyxLQUFUO0VBQWlCLENBQTdDO0FBQ2YxZixTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZcWYsTUFBekIsRUFBaUMsT0FBakMsRUFBMEM7SUFDL0NDLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWM1Qjs7TUFBcUM7TUFDdkQsT0FBTzBCLEtBQUssQ0FBQyxJQUFELEVBQU8xQixVQUFQLEVBQW1CamUsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQXpELENBQVo7O0VBRjZDLENBQTFDLENBQVA7QUFLQTFCLG1CQUFnQyxDQUFDMEYsR0FBRCxDQUFoQzs7RUNWQSxJQUFJb2QsT0FBSyxHQUFHM2pCLGFBQTJCLENBQUMsQ0FBRCxDQUF2QztFQUNBLElBQUl1RyxLQUFHLEdBQUcsV0FBVjtFQUNBLElBQUlxZCxRQUFNLEdBQUcsSUFBYjs7RUFFQSxJQUFJcmQsS0FBRyxJQUFJLEVBQVgsRUFBZStDLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUy9DLEtBQVQsRUFBYyxZQUFZO0lBQUVxZCxRQUFNLEdBQUcsS0FBVDtFQUFpQixDQUE3QztBQUNmMWYsU0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsR0FBWXFmLFFBQXpCLEVBQWlDLE9BQWpDLEVBQTBDO0lBQy9DRSxTQUFTLEVBQUUsU0FBU0EsU0FBVCxDQUFtQjdCOztNQUFxQztNQUNqRSxPQUFPMEIsT0FBSyxDQUFDLElBQUQsRUFBTzFCLFVBQVAsRUFBbUJqZSxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBekQsQ0FBWjs7RUFGNkMsQ0FBMUMsQ0FBUDtBQUtBMUIsbUJBQWdDLENBQUMwRixLQUFELENBQWhDOztFQ1RBLElBQUlnYixTQUFPLEdBQUd2aEIsSUFBaUIsQ0FBQyxTQUFELENBQS9COztFQUVBLGVBQWMsR0FBRyxvQkFBQSxDQUFVdUcsR0FBVixFQUFlO0lBQzlCLElBQUk4TSxDQUFDLEdBQUdsVSxPQUFNLENBQUNvSCxHQUFELENBQWQ7SUFDQSxJQUFJK0YsWUFBVyxJQUFJK0csQ0FBZixJQUFvQixDQUFDQSxDQUFDLENBQUNrTyxTQUFELENBQTFCLEVBQXFDbmdCLFNBQUUsQ0FBQ2EsQ0FBSCxDQUFLb1IsQ0FBTCxFQUFRa08sU0FBUixFQUFpQjtNQUNwRHpmLFlBQVksRUFBRSxJQURzQztNQUVwRDNCLEdBQUcsRUFBRSxlQUFZO1FBQUUsT0FBTyxJQUFQOztLQUZnQjtFQUl0QyxDQU5EOztBQ05BSCxhQUF5QixDQUFDLE9BQUQsQ0FBekI7O0VDQUEsYUFBYyxHQUFHLGtCQUFBLENBQVU2YixJQUFWLEVBQWdCbGEsS0FBaEIsRUFBdUI7SUFDdEMsT0FBTztNQUFFQSxLQUFLLEVBQUVBLEtBQVQ7TUFBZ0JrYSxJQUFJLEVBQUUsQ0FBQyxDQUFDQTtLQUEvQjtFQUNELENBRkQ7O0VDT0E7RUFDQTtFQUNBOzs7RUFDQSxzQkFBYyxHQUFHN2IsV0FBeUIsQ0FBQ3NKLEtBQUQsRUFBUSxPQUFSLEVBQWlCLFVBQVVtUyxRQUFWLEVBQW9CWixJQUFwQixFQUEwQjtJQUNuRixLQUFLYSxFQUFMLEdBQVV0VCxVQUFTLENBQUNxVCxRQUFELENBQW5CLENBRG1GOztJQUVuRixLQUFLRSxFQUFMLEdBQVUsQ0FBVixDQUZtRjs7SUFHbkYsS0FBSzlPLEVBQUwsR0FBVWdPLElBQVYsQ0FIbUY7O0VBS3BGLENBTHlDLEVBS3ZDLFlBQVk7SUFDYixJQUFJeFosQ0FBQyxHQUFHLEtBQUtxYSxFQUFiO0lBQ0EsSUFBSWIsSUFBSSxHQUFHLEtBQUtoTyxFQUFoQjtJQUNBLElBQUk5RSxLQUFLLEdBQUcsS0FBSzRULEVBQUwsRUFBWjs7SUFDQSxJQUFJLENBQUN0YSxDQUFELElBQU0wRyxLQUFLLElBQUkxRyxDQUFDLENBQUNzQyxNQUFyQixFQUE2QjtNQUMzQixLQUFLK1gsRUFBTCxHQUFVblosU0FBVjtNQUNBLE9BQU9nZSxTQUFJLENBQUMsQ0FBRCxDQUFYOzs7SUFFRixJQUFJMUYsSUFBSSxJQUFJLE1BQVosRUFBb0IsT0FBTzBGLFNBQUksQ0FBQyxDQUFELEVBQUl4WSxLQUFKLENBQVg7SUFDcEIsSUFBSThTLElBQUksSUFBSSxRQUFaLEVBQXNCLE9BQU8wRixTQUFJLENBQUMsQ0FBRCxFQUFJbGYsQ0FBQyxDQUFDMEcsS0FBRCxDQUFMLENBQVg7SUFDdEIsT0FBT3dZLFNBQUksQ0FBQyxDQUFELEVBQUksQ0FBQ3hZLEtBQUQsRUFBUTFHLENBQUMsQ0FBQzBHLEtBQUQsQ0FBVCxDQUFKLENBQVg7RUFDRCxDQWhCeUMsRUFnQnZDLFFBaEJ1QyxDQUExQzs7QUFtQkF3VCxZQUFTLENBQUN3SSxTQUFWLEdBQXNCeEksVUFBUyxDQUFDalMsS0FBaEM7QUFFQTBhLG1CQUFnQixDQUFDLE1BQUQsQ0FBaEI7QUFDQUEsbUJBQWdCLENBQUMsUUFBRCxDQUFoQjtBQUNBQSxtQkFBZ0IsQ0FBQyxTQUFELENBQWhCOztFQzlCQSxVQUFjLEdBQUcsZUFBQSxHQUFZO0lBQzNCLElBQUl0Z0IsSUFBSSxHQUFHbEMsU0FBUSxDQUFDLElBQUQsQ0FBbkI7SUFDQSxJQUFJbUgsTUFBTSxHQUFHLEVBQWI7SUFDQSxJQUFJakYsSUFBSSxDQUFDdkUsTUFBVCxFQUFpQndKLE1BQU0sSUFBSSxHQUFWO0lBQ2pCLElBQUlqRixJQUFJLENBQUN1Z0IsVUFBVCxFQUFxQnRiLE1BQU0sSUFBSSxHQUFWO0lBQ3JCLElBQUlqRixJQUFJLENBQUN3Z0IsU0FBVCxFQUFvQnZiLE1BQU0sSUFBSSxHQUFWO0lBQ3BCLElBQUlqRixJQUFJLENBQUN5Z0IsT0FBVCxFQUFrQnhiLE1BQU0sSUFBSSxHQUFWO0lBQ2xCLElBQUlqRixJQUFJLENBQUMwZ0IsTUFBVCxFQUFpQnpiLE1BQU0sSUFBSSxHQUFWO0lBQ2pCLE9BQU9BLE1BQVA7RUFDRCxDQVREOztFQ0RBLElBQUl2SCxJQUFFLEdBQUdwQixTQUF1QixDQUFDaUMsQ0FBakM7RUFDQSxJQUFJNEksTUFBSSxHQUFHaEssV0FBeUIsQ0FBQ29CLENBQXJDO0VBR0EsSUFBSW9pQixPQUFPLEdBQUdsbEIsT0FBTSxDQUFDK1MsTUFBckI7RUFDQSxJQUFJc0IsTUFBSSxHQUFHNlEsT0FBWDtFQUNBLElBQUloVSxPQUFLLEdBQUdnVSxPQUFPLENBQUM1Z0IsU0FBcEI7RUFDQSxJQUFJNmdCLEdBQUcsR0FBRyxJQUFWO0VBQ0EsSUFBSUMsR0FBRyxHQUFHLElBQVY7O0VBRUEsSUFBSUMsV0FBVyxHQUFHLElBQUlILE9BQUosQ0FBWUMsR0FBWixNQUFxQkEsR0FBdkM7O0VBRUEsSUFBSXhqQixZQUF5QixLQUFLLENBQUMwakIsV0FBRCxJQUFnQjNXLE1BQW1CLENBQUMsWUFBWTtJQUNoRjBXLEdBQUcsQ0FBQzVWLElBQWlCLENBQUMsT0FBRCxDQUFsQixDQUFILEdBQWtDLEtBQWxDLENBRGdGOztJQUdoRixPQUFPMFYsT0FBTyxDQUFDQyxHQUFELENBQVAsSUFBZ0JBLEdBQWhCLElBQXVCRCxPQUFPLENBQUNFLEdBQUQsQ0FBUCxJQUFnQkEsR0FBdkMsSUFBOENGLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNLEdBQU4sQ0FBUCxJQUFxQixNQUExRTtFQUNELENBSm9FLENBQXhDLENBQTdCLEVBSUs7SUFDSEQsT0FBTyxHQUFHLFNBQVNuUyxNQUFULENBQWdCdVMsQ0FBaEIsRUFBbUJ4aUIsQ0FBbkIsRUFBc0I7TUFDOUIsSUFBSXlpQixJQUFJLEdBQUcsZ0JBQWdCTCxPQUEzQjtNQUNBLElBQUlNLElBQUksR0FBRzNJLFNBQVEsQ0FBQ3lJLENBQUQsQ0FBbkI7TUFDQSxJQUFJRyxHQUFHLEdBQUczaUIsQ0FBQyxLQUFLTSxTQUFoQjtNQUNBLE9BQU8sQ0FBQ21pQixJQUFELElBQVNDLElBQVQsSUFBaUJGLENBQUMsQ0FBQzFWLFdBQUYsS0FBa0JzVixPQUFuQyxJQUE4Q08sR0FBOUMsR0FBb0RILENBQXBELEdBQ0hwUSxrQkFBaUIsQ0FBQ21RLFdBQVcsR0FDM0IsSUFBSWhSLE1BQUosQ0FBU21SLElBQUksSUFBSSxDQUFDQyxHQUFULEdBQWVILENBQUMsQ0FBQ3BnQixNQUFqQixHQUEwQm9nQixDQUFuQyxFQUFzQ3hpQixDQUF0QyxDQUQyQixHQUUzQnVSLE1BQUksQ0FBQyxDQUFDbVIsSUFBSSxHQUFHRixDQUFDLFlBQVlKLE9BQXJCLElBQWdDSSxDQUFDLENBQUNwZ0IsTUFBbEMsR0FBMkNvZ0IsQ0FBNUMsRUFBK0NFLElBQUksSUFBSUMsR0FBUixHQUFjQyxNQUFNLENBQUNobEIsSUFBUCxDQUFZNGtCLENBQVosQ0FBZCxHQUErQnhpQixDQUE5RSxDQUZXLEVBR2pCeWlCLElBQUksR0FBRyxJQUFILEdBQVVyVSxPQUhHLEVBR0lnVSxPQUhKLENBRHJCO0tBSkY7O0lBVUEsSUFBSVMsS0FBSyxHQUFHLFNBQVJBLEtBQVEsQ0FBVWxsQixHQUFWLEVBQWU7TUFDekJBLEdBQUcsSUFBSXlrQixPQUFQLElBQWtCampCLElBQUUsQ0FBQ2lqQixPQUFELEVBQVV6a0IsR0FBVixFQUFlO1FBQ2pDa0MsWUFBWSxFQUFFLElBRG1CO1FBRWpDM0IsR0FBRyxFQUFFLGVBQVk7VUFBRSxPQUFPcVQsTUFBSSxDQUFDNVQsR0FBRCxDQUFYO1NBRmM7UUFHakNnTyxHQUFHLEVBQUUsYUFBVWpPLEVBQVYsRUFBYztVQUFFNlQsTUFBSSxDQUFDNVQsR0FBRCxDQUFKLEdBQVlELEVBQVo7O09BSEgsQ0FBcEI7S0FERjs7SUFPQSxLQUFLLElBQUlpSixNQUFJLEdBQUdpQyxNQUFJLENBQUMySSxNQUFELENBQWYsRUFBdUJ6TixDQUFDLEdBQUcsQ0FBaEMsRUFBbUM2QyxNQUFJLENBQUNqRixNQUFMLEdBQWNvQyxDQUFqRDtNQUFxRCtlLEtBQUssQ0FBQ2xjLE1BQUksQ0FBQzdDLENBQUMsRUFBRixDQUFMLENBQUw7OztJQUNyRHNLLE9BQUssQ0FBQ3RCLFdBQU4sR0FBb0JzVixPQUFwQjtJQUNBQSxPQUFPLENBQUM1Z0IsU0FBUixHQUFvQjRNLE9BQXBCO0lBQ0FpRSxTQUFzQixDQUFDblYsT0FBRCxFQUFTLFFBQVQsRUFBbUJrbEIsT0FBbkIsQ0FBdEI7RUFDRDs7QUFFRDlQLGFBQXlCLENBQUMsUUFBRCxDQUF6Qjs7RUN0Q0EsSUFBSXdRLFVBQVUsR0FBRzdTLE1BQU0sQ0FBQ3pPLFNBQVAsQ0FBaUIzRCxJQUFsQztFQUVBO0VBQ0E7O0VBQ0EsSUFBSWtsQixhQUFhLEdBQUd4aEIsTUFBTSxDQUFDQyxTQUFQLENBQWlCaVAsT0FBckM7RUFFQSxJQUFJdVMsV0FBVyxHQUFHRixVQUFsQjtFQUVBLElBQUlHLFVBQVUsR0FBRyxXQUFqQjs7RUFFQSxJQUFJQyx3QkFBd0IsR0FBSSxZQUFZO0lBQzFDLElBQUliLEdBQUcsR0FBRyxHQUFWO1FBQ0lDLEdBQUcsR0FBRyxLQURWO0lBRUFRLFVBQVUsQ0FBQ2xsQixJQUFYLENBQWdCeWtCLEdBQWhCLEVBQXFCLEdBQXJCO0lBQ0FTLFVBQVUsQ0FBQ2xsQixJQUFYLENBQWdCMGtCLEdBQWhCLEVBQXFCLEdBQXJCO0lBQ0EsT0FBT0QsR0FBRyxDQUFDWSxVQUFELENBQUgsS0FBb0IsQ0FBcEIsSUFBeUJYLEdBQUcsQ0FBQ1csVUFBRCxDQUFILEtBQW9CLENBQXBEO0VBQ0QsQ0FOOEIsRUFBL0I7OztFQVNBLElBQUlFLGFBQWEsR0FBRyxPQUFPdGxCLElBQVAsQ0FBWSxFQUFaLEVBQWdCLENBQWhCLE1BQXVCeUMsU0FBM0M7RUFFQSxJQUFJOGlCLEtBQUssR0FBR0Ysd0JBQXdCLElBQUlDLGFBQXhDOztFQUVBLElBQUlDLEtBQUosRUFBVztJQUNUSixXQUFXLEdBQUcsU0FBU25sQixJQUFULENBQWNrVCxHQUFkLEVBQW1CO01BQy9CLElBQUlrSixFQUFFLEdBQUcsSUFBVDtNQUNBLElBQUlvSixTQUFKLEVBQWVDLE1BQWYsRUFBdUI1VCxLQUF2QixFQUE4QjVMLENBQTlCOztNQUVBLElBQUlxZixhQUFKLEVBQW1CO1FBQ2pCRyxNQUFNLEdBQUcsSUFBSXJULE1BQUosQ0FBVyxNQUFNZ0ssRUFBRSxDQUFDN1gsTUFBVCxHQUFrQixVQUE3QixFQUF5Q21oQixNQUFXLENBQUMzbEIsSUFBWixDQUFpQnFjLEVBQWpCLENBQXpDLENBQVQ7OztNQUVGLElBQUlpSix3QkFBSixFQUE4QkcsU0FBUyxHQUFHcEosRUFBRSxDQUFDZ0osVUFBRCxDQUFkO01BRTlCdlQsS0FBSyxHQUFHb1QsVUFBVSxDQUFDbGxCLElBQVgsQ0FBZ0JxYyxFQUFoQixFQUFvQmxKLEdBQXBCLENBQVI7O01BRUEsSUFBSW1TLHdCQUF3QixJQUFJeFQsS0FBaEMsRUFBdUM7UUFDckN1SyxFQUFFLENBQUNnSixVQUFELENBQUYsR0FBaUJoSixFQUFFLENBQUMvYyxNQUFILEdBQVl3UyxLQUFLLENBQUM1SixLQUFOLEdBQWM0SixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNoTyxNQUFuQyxHQUE0QzJoQixTQUE3RDs7O01BRUYsSUFBSUYsYUFBYSxJQUFJelQsS0FBakIsSUFBMEJBLEtBQUssQ0FBQ2hPLE1BQU4sR0FBZSxDQUE3QyxFQUFnRDs7OztRQUk5Q3FoQixhQUFhLENBQUNubEIsSUFBZCxDQUFtQjhSLEtBQUssQ0FBQyxDQUFELENBQXhCLEVBQTZCNFQsTUFBN0IsRUFBcUMsWUFBWTtVQUMvQyxLQUFLeGYsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHL0IsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5DLEVBQXNDb0MsQ0FBQyxFQUF2QyxFQUEyQztZQUN6QyxJQUFJL0IsU0FBUyxDQUFDK0IsQ0FBRCxDQUFULEtBQWlCeEQsU0FBckIsRUFBZ0NvUCxLQUFLLENBQUM1TCxDQUFELENBQUwsR0FBV3hELFNBQVg7O1NBRnBDOzs7TUFPRixPQUFPb1AsS0FBUDtLQXpCRjtFQTJCRDs7RUFFRCxlQUFjLEdBQUdzVCxXQUFqQjs7QUN2REFqbEIsU0FBb0IsQ0FBQztJQUNuQjhFLE1BQU0sRUFBRSxRQURXO0lBRW5CdUwsS0FBSyxFQUFFLElBRlk7SUFHbkJ1VCxNQUFNLEVBQUU2QixXQUFVLEtBQUssSUFBSTNsQjtFQUhSLENBQUQsRUFJakI7SUFDREEsSUFBSSxFQUFFMmxCO0VBREwsQ0FKaUIsQ0FBcEI7O0VDREEsSUFBSXpsQixZQUF5QixJQUFJLEtBQUswbEIsS0FBTCxJQUFjLEdBQS9DLEVBQW9EN2tCLFNBQXVCLENBQUNvQixDQUF4QixDQUEwQmlRLE1BQU0sQ0FBQ3pPLFNBQWpDLEVBQTRDLE9BQTVDLEVBQXFEO0lBQ3ZHM0IsWUFBWSxFQUFFLElBRHlGO0lBRXZHM0IsR0FBRyxFQUFFVztFQUZrRyxDQUFyRDs7RUNJcEQsSUFBSWdDLFdBQVMsR0FBRyxVQUFoQjtFQUNBLElBQUlFLFdBQVMsR0FBRyxJQUFJRixXQUFKLENBQWhCOztFQUVBLElBQUk2aUIsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVTNrQixFQUFWLEVBQWM7SUFDekJILFNBQXNCLENBQUNxUixNQUFNLENBQUN6TyxTQUFSLEVBQW1CWCxXQUFuQixFQUE4QjlCLEVBQTlCLEVBQWtDLElBQWxDLENBQXRCO0VBQ0QsQ0FGRDs7O0VBS0EsSUFBSUYsTUFBbUIsQ0FBQyxZQUFZO0lBQUUsT0FBT2tDLFdBQVMsQ0FBQ25ELElBQVYsQ0FBZTtNQUFFd0UsTUFBTSxFQUFFLEdBQVY7TUFBZXFoQixLQUFLLEVBQUU7S0FBckMsS0FBK0MsTUFBdEQ7RUFBK0QsQ0FBOUUsQ0FBdkIsRUFBd0c7SUFDdEdDLE1BQU0sQ0FBQyxTQUFTemtCLFFBQVQsR0FBb0I7TUFDekIsSUFBSXNFLENBQUMsR0FBR2hFLFNBQVEsQ0FBQyxJQUFELENBQWhCO01BQ0EsT0FBTyxJQUFJYyxNQUFKLENBQVdrRCxDQUFDLENBQUNuQixNQUFiLEVBQXFCLEdBQXJCLEVBQ0wsV0FBV21CLENBQVgsR0FBZUEsQ0FBQyxDQUFDa2dCLEtBQWpCLEdBQXlCLENBQUNwWixZQUFELElBQWdCOUcsQ0FBQyxZQUFZME0sTUFBN0IsR0FBc0MyUyxNQUFNLENBQUNobEIsSUFBUCxDQUFZMkYsQ0FBWixDQUF0QyxHQUF1RGpELFNBRDNFLENBQVA7S0FGSSxDQUFOLENBRHNHO0VBT3ZHLENBUEQsTUFPTyxJQUFJUyxXQUFTLENBQUNvQixJQUFWLElBQWtCdEIsV0FBdEIsRUFBaUM7SUFDdEM2aUIsTUFBTSxDQUFDLFNBQVN6a0IsUUFBVCxHQUFvQjtNQUN6QixPQUFPOEIsV0FBUyxDQUFDbkQsSUFBVixDQUFlLElBQWYsQ0FBUDtLQURJLENBQU47OztFQ3BCRixJQUFJK2xCLEVBQUUsR0FBRzVsQixTQUF1QixDQUFDLElBQUQsQ0FBaEM7RUFHQTs7RUFDQSx1QkFBYyxHQUFHLDRCQUFBLENBQVVlLENBQVYsRUFBYWdILEtBQWIsRUFBb0JvYyxPQUFwQixFQUE2QjtJQUM1QyxPQUFPcGMsS0FBSyxJQUFJb2MsT0FBTyxHQUFHeUIsRUFBRSxDQUFDN2tCLENBQUQsRUFBSWdILEtBQUosQ0FBRixDQUFhcEUsTUFBaEIsR0FBeUIsQ0FBcEMsQ0FBWjtFQUNELENBRkQ7O0VDRkEsSUFBSWtpQixXQUFXLEdBQUczVCxNQUFNLENBQUN6TyxTQUFQLENBQWlCM0QsSUFBbkM7RUFHQTs7RUFDQSx1QkFBYyxHQUFHLDRCQUFBLENBQVUwRixDQUFWLEVBQWF6RSxDQUFiLEVBQWdCO0lBQy9CLElBQUlqQixJQUFJLEdBQUcwRixDQUFDLENBQUMxRixJQUFiOztJQUNBLElBQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztNQUM5QixJQUFJNkksTUFBTSxHQUFHN0ksSUFBSSxDQUFDRCxJQUFMLENBQVUyRixDQUFWLEVBQWF6RSxDQUFiLENBQWI7O01BQ0EsSUFBSSxPQUFPNEgsTUFBUCxLQUFrQixRQUF0QixFQUFnQztRQUM5QixNQUFNLElBQUlsSSxTQUFKLENBQWMsb0VBQWQsQ0FBTjs7O01BRUYsT0FBT2tJLE1BQVA7OztJQUVGLElBQUlrSSxRQUFPLENBQUNyTCxDQUFELENBQVAsS0FBZSxRQUFuQixFQUE2QjtNQUMzQixNQUFNLElBQUkvRSxTQUFKLENBQWMsNkNBQWQsQ0FBTjs7O0lBRUYsT0FBT29sQixXQUFXLENBQUNobUIsSUFBWixDQUFpQjJGLENBQWpCLEVBQW9CekUsQ0FBcEIsQ0FBUDtFQUNELENBYkQ7O0VDRUEsSUFBSXdnQixTQUFPLEdBQUc3VixJQUFHLENBQUMsU0FBRCxDQUFqQjtFQUVBLElBQUlvYSw2QkFBNkIsR0FBRyxDQUFDalgsTUFBSyxDQUFDLFlBQVk7Ozs7SUFJckQsSUFBSXFOLEVBQUUsR0FBRyxHQUFUOztJQUNBQSxFQUFFLENBQUNwYyxJQUFILEdBQVUsWUFBWTtNQUNwQixJQUFJNkksTUFBTSxHQUFHLEVBQWI7TUFDQUEsTUFBTSxDQUFDb2QsTUFBUCxHQUFnQjtRQUFFM2xCLENBQUMsRUFBRTtPQUFyQjtNQUNBLE9BQU91SSxNQUFQO0tBSEY7O0lBS0EsT0FBTyxHQUFHK0osT0FBSCxDQUFXd0osRUFBWCxFQUFlLE1BQWYsTUFBMkIsR0FBbEM7RUFDRCxDQVh5QyxDQUExQzs7RUFhQSxJQUFJOEosaUNBQWlDLEdBQUksWUFBWTs7SUFFbkQsSUFBSTlKLEVBQUUsR0FBRyxNQUFUO0lBQ0EsSUFBSStKLFlBQVksR0FBRy9KLEVBQUUsQ0FBQ3BjLElBQXRCOztJQUNBb2MsRUFBRSxDQUFDcGMsSUFBSCxHQUFVLFlBQVk7TUFBRSxPQUFPbW1CLFlBQVksQ0FBQ2xpQixLQUFiLENBQW1CLElBQW5CLEVBQXlCQyxTQUF6QixDQUFQO0tBQXhCOztJQUNBLElBQUkyRSxNQUFNLEdBQUcsS0FBSzFGLEtBQUwsQ0FBV2laLEVBQVgsQ0FBYjtJQUNBLE9BQU92VCxNQUFNLENBQUNoRixNQUFQLEtBQWtCLENBQWxCLElBQXVCZ0YsTUFBTSxDQUFDLENBQUQsQ0FBTixLQUFjLEdBQXJDLElBQTRDQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEtBQWMsR0FBakU7RUFDRCxDQVB1QyxFQUF4Qzs7RUFTQSxhQUFjLEdBQUcsa0JBQUEsQ0FBVXBDLEdBQVYsRUFBZTVDLE1BQWYsRUFBdUI3RCxJQUF2QixFQUE2QjtJQUM1QyxJQUFJb21CLE1BQU0sR0FBR3hhLElBQUcsQ0FBQ25GLEdBQUQsQ0FBaEI7SUFFQSxJQUFJNGYsbUJBQW1CLEdBQUcsQ0FBQ3RYLE1BQUssQ0FBQyxZQUFZOztNQUUzQyxJQUFJeE4sQ0FBQyxHQUFHLEVBQVI7O01BQ0FBLENBQUMsQ0FBQzZrQixNQUFELENBQUQsR0FBWSxZQUFZO1FBQUUsT0FBTyxDQUFQO09BQTFCOztNQUNBLE9BQU8sR0FBRzNmLEdBQUgsRUFBUWxGLENBQVIsS0FBYyxDQUFyQjtLQUo4QixDQUFoQztJQU9BLElBQUkra0IsaUJBQWlCLEdBQUdELG1CQUFtQixHQUFHLENBQUN0WCxNQUFLLENBQUMsWUFBWTs7TUFFL0QsSUFBSXdYLFVBQVUsR0FBRyxLQUFqQjtNQUNBLElBQUluSyxFQUFFLEdBQUcsR0FBVDs7TUFDQUEsRUFBRSxDQUFDcGMsSUFBSCxHQUFVLFlBQVk7UUFBRXVtQixVQUFVLEdBQUcsSUFBYjtRQUFtQixPQUFPLElBQVA7T0FBM0M7O01BQ0EsSUFBSTlmLEdBQUcsS0FBSyxPQUFaLEVBQXFCOzs7UUFHbkIyVixFQUFFLENBQUNuTixXQUFILEdBQWlCLEVBQWpCOztRQUNBbU4sRUFBRSxDQUFDbk4sV0FBSCxDQUFld1MsU0FBZixJQUEwQixZQUFZO1VBQUUsT0FBT3JGLEVBQVA7U0FBeEM7OztNQUVGQSxFQUFFLENBQUNnSyxNQUFELENBQUYsQ0FBVyxFQUFYO01BQ0EsT0FBTyxDQUFDRyxVQUFSO0tBWmtELENBQVQsR0FhdEM5akIsU0FiTDs7SUFlQSxJQUNFLENBQUM0akIsbUJBQUQsSUFDQSxDQUFDQyxpQkFERCxJQUVDN2YsR0FBRyxLQUFLLFNBQVIsSUFBcUIsQ0FBQ3VmLDZCQUZ2QixJQUdDdmYsR0FBRyxLQUFLLE9BQVIsSUFBbUIsQ0FBQ3lmLGlDQUp2QixFQUtFO01BQ0EsSUFBSU0sa0JBQWtCLEdBQUcsSUFBSUosTUFBSixDQUF6QjtNQUNBLElBQUlLLEdBQUcsR0FBR3ptQixJQUFJLENBQ1owSCxRQURZLEVBRVowZSxNQUZZLEVBR1osR0FBRzNmLEdBQUgsQ0FIWSxFQUlaLFNBQVNpZ0IsZUFBVCxDQUF5QkMsWUFBekIsRUFBdUNDLE1BQXZDLEVBQStDMVQsR0FBL0MsRUFBb0QyVCxJQUFwRCxFQUEwREMsaUJBQTFELEVBQTZFO1FBQzNFLElBQUlGLE1BQU0sQ0FBQzVtQixJQUFQLEtBQWdCMmxCLFdBQXBCLEVBQWdDO1VBQzlCLElBQUlVLG1CQUFtQixJQUFJLENBQUNTLGlCQUE1QixFQUErQzs7OztZQUk3QyxPQUFPO2NBQUUvSyxJQUFJLEVBQUUsSUFBUjtjQUFjbGEsS0FBSyxFQUFFMmtCLGtCQUFrQixDQUFDem1CLElBQW5CLENBQXdCNm1CLE1BQXhCLEVBQWdDMVQsR0FBaEMsRUFBcUMyVCxJQUFyQzthQUE1Qjs7O1VBRUYsT0FBTztZQUFFOUssSUFBSSxFQUFFLElBQVI7WUFBY2xhLEtBQUssRUFBRThrQixZQUFZLENBQUM1bUIsSUFBYixDQUFrQm1ULEdBQWxCLEVBQXVCMFQsTUFBdkIsRUFBK0JDLElBQS9CO1dBQTVCOzs7UUFFRixPQUFPO1VBQUU5SyxJQUFJLEVBQUU7U0FBZjtPQWRVLENBQWQ7TUFpQkEsSUFBSWdMLEtBQUssR0FBR04sR0FBRyxDQUFDLENBQUQsQ0FBZjtNQUNBLElBQUlPLElBQUksR0FBR1AsR0FBRyxDQUFDLENBQUQsQ0FBZDtNQUVBbGhCLFNBQVEsQ0FBQzdCLE1BQU0sQ0FBQ0MsU0FBUixFQUFtQjhDLEdBQW5CLEVBQXdCc2dCLEtBQXhCLENBQVI7TUFDQXZqQixLQUFJLENBQUM0TyxNQUFNLENBQUN6TyxTQUFSLEVBQW1CeWlCLE1BQW5CLEVBQTJCdmlCLE1BQU0sSUFBSSxDQUFWOztRQUczQixVQUFVNk8sTUFBVixFQUFrQmhKLEdBQWxCLEVBQXVCO1FBQUUsT0FBT3NkLElBQUksQ0FBQ2puQixJQUFMLENBQVUyUyxNQUFWLEVBQWtCLElBQWxCLEVBQXdCaEosR0FBeEIsQ0FBUDtPQUhFOztRQU0zQixVQUFVZ0osTUFBVixFQUFrQjtRQUFFLE9BQU9zVSxJQUFJLENBQUNqbkIsSUFBTCxDQUFVMlMsTUFBVixFQUFrQixJQUFsQixDQUFQO09BTnBCLENBQUo7O0VBU0gsQ0E5REQ7O0FDekJBeFMsV0FBd0IsQ0FBQyxPQUFELEVBQVUsQ0FBVixFQUFhLFVBQVV3SCxPQUFWLEVBQW1CdVUsS0FBbkIsRUFBMEJnTCxNQUExQixFQUFrQ1AsZUFBbEMsRUFBbUQ7SUFDdEYsT0FBTzs7SUFHTCxTQUFTN1UsS0FBVCxDQUFlK1UsTUFBZixFQUF1QjtNQUNyQixJQUFJcmxCLENBQUMsR0FBR21HLE9BQU8sQ0FBQyxJQUFELENBQWY7TUFDQSxJQUFJeEcsRUFBRSxHQUFHMGxCLE1BQU0sSUFBSW5rQixTQUFWLEdBQXNCQSxTQUF0QixHQUFrQ21rQixNQUFNLENBQUMzSyxLQUFELENBQWpEO01BQ0EsT0FBTy9hLEVBQUUsS0FBS3VCLFNBQVAsR0FBbUJ2QixFQUFFLENBQUNuQixJQUFILENBQVE2bUIsTUFBUixFQUFnQnJsQixDQUFoQixDQUFuQixHQUF3QyxJQUFJNlEsTUFBSixDQUFXd1UsTUFBWCxFQUFtQjNLLEtBQW5CLEVBQTBCdlksTUFBTSxDQUFDbkMsQ0FBRCxDQUFoQyxDQUEvQztLQU5HOztJQVVMLFVBQVVxbEIsTUFBVixFQUFrQjtNQUNoQixJQUFJL1IsR0FBRyxHQUFHNlIsZUFBZSxDQUFDTyxNQUFELEVBQVNMLE1BQVQsRUFBaUIsSUFBakIsQ0FBekI7TUFDQSxJQUFJL1IsR0FBRyxDQUFDa0gsSUFBUixFQUFjLE9BQU9sSCxHQUFHLENBQUNoVCxLQUFYO01BQ2QsSUFBSXFsQixFQUFFLEdBQUd4bEIsU0FBUSxDQUFDa2xCLE1BQUQsQ0FBakI7TUFDQSxJQUFJM2xCLENBQUMsR0FBR3lDLE1BQU0sQ0FBQyxJQUFELENBQWQ7TUFDQSxJQUFJLENBQUN3akIsRUFBRSxDQUFDN25CLE1BQVIsRUFBZ0IsT0FBTzhuQixtQkFBVSxDQUFDRCxFQUFELEVBQUtqbUIsQ0FBTCxDQUFqQjtNQUNoQixJQUFJbW1CLFdBQVcsR0FBR0YsRUFBRSxDQUFDN0MsT0FBckI7TUFDQTZDLEVBQUUsQ0FBQzFCLFNBQUgsR0FBZSxDQUFmO01BQ0EsSUFBSXpWLENBQUMsR0FBRyxFQUFSO01BQ0EsSUFBSXNCLENBQUMsR0FBRyxDQUFSO01BQ0EsSUFBSXhJLE1BQUo7O01BQ0EsT0FBTyxDQUFDQSxNQUFNLEdBQUdzZSxtQkFBVSxDQUFDRCxFQUFELEVBQUtqbUIsQ0FBTCxDQUFwQixNQUFpQyxJQUF4QyxFQUE4QztRQUM1QyxJQUFJb21CLFFBQVEsR0FBRzNqQixNQUFNLENBQUNtRixNQUFNLENBQUMsQ0FBRCxDQUFQLENBQXJCO1FBQ0FrSCxDQUFDLENBQUNzQixDQUFELENBQUQsR0FBT2dXLFFBQVA7UUFDQSxJQUFJQSxRQUFRLEtBQUssRUFBakIsRUFBcUJILEVBQUUsQ0FBQzFCLFNBQUgsR0FBZThCLG1CQUFrQixDQUFDcm1CLENBQUQsRUFBSXNILFNBQVEsQ0FBQzJlLEVBQUUsQ0FBQzFCLFNBQUosQ0FBWixFQUE0QjRCLFdBQTVCLENBQWpDO1FBQ3JCL1YsQ0FBQzs7O01BRUgsT0FBT0EsQ0FBQyxLQUFLLENBQU4sR0FBVSxJQUFWLEdBQWlCdEIsQ0FBeEI7S0EzQkcsQ0FBUDtFQThCRCxDQS9CdUIsQ0FBeEI7O0VDQUEsSUFBSS9ILEtBQUcsR0FBR3hJLElBQUksQ0FBQ3dJLEdBQWY7RUFDQSxJQUFJRixLQUFHLEdBQUd0SSxJQUFJLENBQUNzSSxHQUFmO0VBQ0EsSUFBSUYsT0FBSyxHQUFHcEksSUFBSSxDQUFDb0ksS0FBakI7RUFDQSxJQUFJMmYsb0JBQW9CLEdBQUcsMkJBQTNCO0VBQ0EsSUFBSUMsNkJBQTZCLEdBQUcsbUJBQXBDOztFQUVBLElBQUlDLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBVTVuQixFQUFWLEVBQWM7SUFDaEMsT0FBT0EsRUFBRSxLQUFLNEMsU0FBUCxHQUFtQjVDLEVBQW5CLEdBQXdCNkQsTUFBTSxDQUFDN0QsRUFBRCxDQUFyQztFQUNELENBRkQ7OztBQUtBSyxXQUF3QixDQUFDLFNBQUQsRUFBWSxDQUFaLEVBQWUsVUFBVXdILE9BQVYsRUFBbUJnZ0IsT0FBbkIsRUFBNEJDLFFBQTVCLEVBQXNDakIsZUFBdEMsRUFBdUQ7SUFDNUYsT0FBTzs7SUFHTCxTQUFTOVQsT0FBVCxDQUFpQmdWLFdBQWpCLEVBQThCQyxZQUE5QixFQUE0QztNQUMxQyxJQUFJdG1CLENBQUMsR0FBR21HLE9BQU8sQ0FBQyxJQUFELENBQWY7TUFDQSxJQUFJeEcsRUFBRSxHQUFHMG1CLFdBQVcsSUFBSW5sQixTQUFmLEdBQTJCQSxTQUEzQixHQUF1Q21sQixXQUFXLENBQUNGLE9BQUQsQ0FBM0Q7TUFDQSxPQUFPeG1CLEVBQUUsS0FBS3VCLFNBQVAsR0FDSHZCLEVBQUUsQ0FBQ25CLElBQUgsQ0FBUTZuQixXQUFSLEVBQXFCcm1CLENBQXJCLEVBQXdCc21CLFlBQXhCLENBREcsR0FFSEYsUUFBUSxDQUFDNW5CLElBQVQsQ0FBYzJELE1BQU0sQ0FBQ25DLENBQUQsQ0FBcEIsRUFBeUJxbUIsV0FBekIsRUFBc0NDLFlBQXRDLENBRko7S0FORzs7SUFZTCxVQUFVakIsTUFBVixFQUFrQmlCLFlBQWxCLEVBQWdDO01BQzlCLElBQUloVCxHQUFHLEdBQUc2UixlQUFlLENBQUNpQixRQUFELEVBQVdmLE1BQVgsRUFBbUIsSUFBbkIsRUFBeUJpQixZQUF6QixDQUF6QjtNQUNBLElBQUloVCxHQUFHLENBQUNrSCxJQUFSLEVBQWMsT0FBT2xILEdBQUcsQ0FBQ2hULEtBQVg7TUFFZCxJQUFJcWxCLEVBQUUsR0FBR3hsQixTQUFRLENBQUNrbEIsTUFBRCxDQUFqQjtNQUNBLElBQUkzbEIsQ0FBQyxHQUFHeUMsTUFBTSxDQUFDLElBQUQsQ0FBZDtNQUNBLElBQUlva0IsaUJBQWlCLEdBQUcsT0FBT0QsWUFBUCxLQUF3QixVQUFoRDtNQUNBLElBQUksQ0FBQ0MsaUJBQUwsRUFBd0JELFlBQVksR0FBR25rQixNQUFNLENBQUNta0IsWUFBRCxDQUFyQjtNQUN4QixJQUFJeG9CLE1BQU0sR0FBRzZuQixFQUFFLENBQUM3bkIsTUFBaEI7O01BQ0EsSUFBSUEsTUFBSixFQUFZO1FBQ1YsSUFBSStuQixXQUFXLEdBQUdGLEVBQUUsQ0FBQzdDLE9BQXJCO1FBQ0E2QyxFQUFFLENBQUMxQixTQUFILEdBQWUsQ0FBZjs7O01BRUYsSUFBSXVDLE9BQU8sR0FBRyxFQUFkOztNQUNBLE9BQU8sSUFBUCxFQUFhO1FBQ1gsSUFBSWxmLE1BQU0sR0FBR3NlLG1CQUFVLENBQUNELEVBQUQsRUFBS2ptQixDQUFMLENBQXZCO1FBQ0EsSUFBSTRILE1BQU0sS0FBSyxJQUFmLEVBQXFCO1FBQ3JCa2YsT0FBTyxDQUFDbmxCLElBQVIsQ0FBYWlHLE1BQWI7UUFDQSxJQUFJLENBQUN4SixNQUFMLEVBQWE7UUFDYixJQUFJZ29CLFFBQVEsR0FBRzNqQixNQUFNLENBQUNtRixNQUFNLENBQUMsQ0FBRCxDQUFQLENBQXJCO1FBQ0EsSUFBSXdlLFFBQVEsS0FBSyxFQUFqQixFQUFxQkgsRUFBRSxDQUFDMUIsU0FBSCxHQUFlOEIsbUJBQWtCLENBQUNybUIsQ0FBRCxFQUFJc0gsU0FBUSxDQUFDMmUsRUFBRSxDQUFDMUIsU0FBSixDQUFaLEVBQTRCNEIsV0FBNUIsQ0FBakM7OztNQUV2QixJQUFJWSxpQkFBaUIsR0FBRyxFQUF4QjtNQUNBLElBQUlDLGtCQUFrQixHQUFHLENBQXpCOztNQUNBLEtBQUssSUFBSWhpQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGhCLE9BQU8sQ0FBQ2xrQixNQUE1QixFQUFvQ29DLENBQUMsRUFBckMsRUFBeUM7UUFDdkM0QyxNQUFNLEdBQUdrZixPQUFPLENBQUM5aEIsQ0FBRCxDQUFoQjtRQUNBLElBQUlpaUIsT0FBTyxHQUFHeGtCLE1BQU0sQ0FBQ21GLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FBcEI7UUFDQSxJQUFJc2YsUUFBUSxHQUFHbmdCLEtBQUcsQ0FBQ0YsS0FBRyxDQUFDQyxVQUFTLENBQUNjLE1BQU0sQ0FBQ1osS0FBUixDQUFWLEVBQTBCaEgsQ0FBQyxDQUFDNEMsTUFBNUIsQ0FBSixFQUF5QyxDQUF6QyxDQUFsQjtRQUNBLElBQUl1a0IsUUFBUSxHQUFHLEVBQWYsQ0FKdUM7Ozs7OztRQVV2QyxLQUFLLElBQUluYSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcEYsTUFBTSxDQUFDaEYsTUFBM0IsRUFBbUNvSyxDQUFDLEVBQXBDO1VBQXdDbWEsUUFBUSxDQUFDeGxCLElBQVQsQ0FBYzZrQixhQUFhLENBQUM1ZSxNQUFNLENBQUNvRixDQUFELENBQVAsQ0FBM0I7OztRQUN4QyxJQUFJb2EsYUFBYSxHQUFHeGYsTUFBTSxDQUFDb2QsTUFBM0I7O1FBQ0EsSUFBSTZCLGlCQUFKLEVBQXVCO1VBQ3JCLElBQUlRLFlBQVksR0FBRyxDQUFDSixPQUFELEVBQVUxbEIsTUFBVixDQUFpQjRsQixRQUFqQixFQUEyQkQsUUFBM0IsRUFBcUNsbkIsQ0FBckMsQ0FBbkI7VUFDQSxJQUFJb25CLGFBQWEsS0FBSzVsQixTQUF0QixFQUFpQzZsQixZQUFZLENBQUMxbEIsSUFBYixDQUFrQnlsQixhQUFsQjtVQUNqQyxJQUFJRSxXQUFXLEdBQUc3a0IsTUFBTSxDQUFDbWtCLFlBQVksQ0FBQzVqQixLQUFiLENBQW1CeEIsU0FBbkIsRUFBOEI2bEIsWUFBOUIsQ0FBRCxDQUF4QjtTQUhGLE1BSU87VUFDTEMsV0FBVyxHQUFHQyxlQUFlLENBQUNOLE9BQUQsRUFBVWpuQixDQUFWLEVBQWFrbkIsUUFBYixFQUF1QkMsUUFBdkIsRUFBaUNDLGFBQWpDLEVBQWdEUixZQUFoRCxDQUE3Qjs7O1FBRUYsSUFBSU0sUUFBUSxJQUFJRixrQkFBaEIsRUFBb0M7VUFDbENELGlCQUFpQixJQUFJL21CLENBQUMsQ0FBQ3FHLEtBQUYsQ0FBUTJnQixrQkFBUixFQUE0QkUsUUFBNUIsSUFBd0NJLFdBQTdEO1VBQ0FOLGtCQUFrQixHQUFHRSxRQUFRLEdBQUdELE9BQU8sQ0FBQ3JrQixNQUF4Qzs7OztNQUdKLE9BQU9ta0IsaUJBQWlCLEdBQUcvbUIsQ0FBQyxDQUFDcUcsS0FBRixDQUFRMmdCLGtCQUFSLENBQTNCO0tBNURHLENBQVAsQ0FENEY7O0lBa0U1RixTQUFTTyxlQUFULENBQXlCTixPQUF6QixFQUFrQ2hWLEdBQWxDLEVBQXVDaVYsUUFBdkMsRUFBaURDLFFBQWpELEVBQTJEQyxhQUEzRCxFQUEwRUUsV0FBMUUsRUFBdUY7TUFDckYsSUFBSUUsT0FBTyxHQUFHTixRQUFRLEdBQUdELE9BQU8sQ0FBQ3JrQixNQUFqQztNQUNBLElBQUltUyxDQUFDLEdBQUdvUyxRQUFRLENBQUN2a0IsTUFBakI7TUFDQSxJQUFJd0YsT0FBTyxHQUFHbWUsNkJBQWQ7O01BQ0EsSUFBSWEsYUFBYSxLQUFLNWxCLFNBQXRCLEVBQWlDO1FBQy9CNGxCLGFBQWEsR0FBRzVaLFNBQVEsQ0FBQzRaLGFBQUQsQ0FBeEI7UUFDQWhmLE9BQU8sR0FBR2tlLG9CQUFWOzs7TUFFRixPQUFPSSxRQUFRLENBQUM1bkIsSUFBVCxDQUFjd29CLFdBQWQsRUFBMkJsZixPQUEzQixFQUFvQyxVQUFVd0ksS0FBVixFQUFpQjZXLEVBQWpCLEVBQXFCO1FBQzlELElBQUlDLE9BQUo7O1FBQ0EsUUFBUUQsRUFBRSxDQUFDdGhCLE1BQUgsQ0FBVSxDQUFWLENBQVI7VUFDRSxLQUFLLEdBQUw7WUFBVSxPQUFPLEdBQVA7O1VBQ1YsS0FBSyxHQUFMO1lBQVUsT0FBTzhnQixPQUFQOztVQUNWLEtBQUssR0FBTDtZQUFVLE9BQU9oVixHQUFHLENBQUM1TCxLQUFKLENBQVUsQ0FBVixFQUFhNmdCLFFBQWIsQ0FBUDs7VUFDVixLQUFLLEdBQUw7WUFBVSxPQUFPalYsR0FBRyxDQUFDNUwsS0FBSixDQUFVbWhCLE9BQVYsQ0FBUDs7VUFDVixLQUFLLEdBQUw7WUFDRUUsT0FBTyxHQUFHTixhQUFhLENBQUNLLEVBQUUsQ0FBQ3BoQixLQUFILENBQVMsQ0FBVCxFQUFZLENBQUMsQ0FBYixDQUFELENBQXZCO1lBQ0E7O1VBQ0Y7O1lBQ0UsSUFBSStKLENBQUMsR0FBRyxDQUFDcVgsRUFBVDtZQUNBLElBQUlyWCxDQUFDLEtBQUssQ0FBVixFQUFhLE9BQU9RLEtBQVA7O1lBQ2IsSUFBSVIsQ0FBQyxHQUFHMkUsQ0FBUixFQUFXO2NBQ1QsSUFBSTdULENBQUMsR0FBR3lGLE9BQUssQ0FBQ3lKLENBQUMsR0FBRyxFQUFMLENBQWI7Y0FDQSxJQUFJbFAsQ0FBQyxLQUFLLENBQVYsRUFBYSxPQUFPMFAsS0FBUDtjQUNiLElBQUkxUCxDQUFDLElBQUk2VCxDQUFULEVBQVksT0FBT29TLFFBQVEsQ0FBQ2ptQixDQUFDLEdBQUcsQ0FBTCxDQUFSLEtBQW9CTSxTQUFwQixHQUFnQ2ltQixFQUFFLENBQUN0aEIsTUFBSCxDQUFVLENBQVYsQ0FBaEMsR0FBK0NnaEIsUUFBUSxDQUFDam1CLENBQUMsR0FBRyxDQUFMLENBQVIsR0FBa0J1bUIsRUFBRSxDQUFDdGhCLE1BQUgsQ0FBVSxDQUFWLENBQXhFO2NBQ1osT0FBT3lLLEtBQVA7OztZQUVGOFcsT0FBTyxHQUFHUCxRQUFRLENBQUMvVyxDQUFDLEdBQUcsQ0FBTCxDQUFsQjs7O1FBRUosT0FBT3NYLE9BQU8sS0FBS2xtQixTQUFaLEdBQXdCLEVBQXhCLEdBQTZCa21CLE9BQXBDO09BckJLLENBQVA7O0VBd0JILENBbEd1QixDQUF4Qjs7QUNaQXpvQixXQUF3QixDQUFDLFFBQUQsRUFBVyxDQUFYLEVBQWMsVUFBVXdILE9BQVYsRUFBbUJraEIsTUFBbkIsRUFBMkJDLE9BQTNCLEVBQW9DbkMsZUFBcEMsRUFBcUQ7SUFDekYsT0FBTzs7SUFHTCxTQUFTL0osTUFBVCxDQUFnQmlLLE1BQWhCLEVBQXdCO01BQ3RCLElBQUlybEIsQ0FBQyxHQUFHbUcsT0FBTyxDQUFDLElBQUQsQ0FBZjtNQUNBLElBQUl4RyxFQUFFLEdBQUcwbEIsTUFBTSxJQUFJbmtCLFNBQVYsR0FBc0JBLFNBQXRCLEdBQWtDbWtCLE1BQU0sQ0FBQ2dDLE1BQUQsQ0FBakQ7TUFDQSxPQUFPMW5CLEVBQUUsS0FBS3VCLFNBQVAsR0FBbUJ2QixFQUFFLENBQUNuQixJQUFILENBQVE2bUIsTUFBUixFQUFnQnJsQixDQUFoQixDQUFuQixHQUF3QyxJQUFJNlEsTUFBSixDQUFXd1UsTUFBWCxFQUFtQmdDLE1BQW5CLEVBQTJCbGxCLE1BQU0sQ0FBQ25DLENBQUQsQ0FBakMsQ0FBL0M7S0FORzs7SUFVTCxVQUFVcWxCLE1BQVYsRUFBa0I7TUFDaEIsSUFBSS9SLEdBQUcsR0FBRzZSLGVBQWUsQ0FBQ21DLE9BQUQsRUFBVWpDLE1BQVYsRUFBa0IsSUFBbEIsQ0FBekI7TUFDQSxJQUFJL1IsR0FBRyxDQUFDa0gsSUFBUixFQUFjLE9BQU9sSCxHQUFHLENBQUNoVCxLQUFYO01BQ2QsSUFBSXFsQixFQUFFLEdBQUd4bEIsU0FBUSxDQUFDa2xCLE1BQUQsQ0FBakI7TUFDQSxJQUFJM2xCLENBQUMsR0FBR3lDLE1BQU0sQ0FBQyxJQUFELENBQWQ7TUFDQSxJQUFJb2xCLGlCQUFpQixHQUFHNUIsRUFBRSxDQUFDMUIsU0FBM0I7TUFDQSxJQUFJLENBQUN1RCxVQUFTLENBQUNELGlCQUFELEVBQW9CLENBQXBCLENBQWQsRUFBc0M1QixFQUFFLENBQUMxQixTQUFILEdBQWUsQ0FBZjtNQUN0QyxJQUFJM2MsTUFBTSxHQUFHc2UsbUJBQVUsQ0FBQ0QsRUFBRCxFQUFLam1CLENBQUwsQ0FBdkI7TUFDQSxJQUFJLENBQUM4bkIsVUFBUyxDQUFDN0IsRUFBRSxDQUFDMUIsU0FBSixFQUFlc0QsaUJBQWYsQ0FBZCxFQUFpRDVCLEVBQUUsQ0FBQzFCLFNBQUgsR0FBZXNELGlCQUFmO01BQ2pELE9BQU9qZ0IsTUFBTSxLQUFLLElBQVgsR0FBa0IsQ0FBQyxDQUFuQixHQUF1QkEsTUFBTSxDQUFDWixLQUFyQztLQW5CRyxDQUFQO0VBc0JELENBdkJ1QixDQUF4Qjs7RUNKQSxJQUFJd1osU0FBTyxHQUFHdmhCLElBQWlCLENBQUMsU0FBRCxDQUEvQjs7RUFDQSx1QkFBYyxHQUFHLDRCQUFBLENBQVVxQixDQUFWLEVBQWFvTCxDQUFiLEVBQWdCO0lBQy9CLElBQUk0RyxDQUFDLEdBQUc3UixTQUFRLENBQUNILENBQUQsQ0FBUixDQUFZME4sV0FBcEI7SUFDQSxJQUFJaE8sQ0FBSjtJQUNBLE9BQU9zUyxDQUFDLEtBQUs5USxTQUFOLElBQW1CLENBQUN4QixDQUFDLEdBQUdTLFNBQVEsQ0FBQzZSLENBQUQsQ0FBUixDQUFZa08sU0FBWixDQUFMLEtBQThCaGYsU0FBakQsR0FBNkRrSyxDQUE3RCxHQUFpRTdJLFVBQVMsQ0FBQzdDLENBQUQsQ0FBakY7RUFDRCxDQUpEOztFQ01BLElBQUkrbkIsSUFBSSxHQUFHeHBCLElBQUksQ0FBQ3NJLEdBQWhCO0VBQ0EsSUFBSW1oQixLQUFLLEdBQUcsR0FBR3JtQixJQUFmO0VBQ0EsSUFBSXNtQixNQUFNLEdBQUcsT0FBYjtFQUNBLElBQUlDLE1BQU0sR0FBRyxRQUFiO0VBQ0EsSUFBSS9ELFlBQVUsR0FBRyxXQUFqQjtFQUNBLElBQUlnRSxVQUFVLEdBQUcsVUFBakI7O0VBR0EsSUFBSUMsVUFBVSxHQUFHLENBQUN0YSxNQUFLLENBQUMsWUFBWTtJQUFFcUQsTUFBTSxDQUFDZ1gsVUFBRCxFQUFhLEdBQWIsQ0FBTjtFQUEwQixDQUF6QyxDQUF2Qjs7QUFHQWxwQixXQUF3QixDQUFDLE9BQUQsRUFBVSxDQUFWLEVBQWEsVUFBVXdILE9BQVYsRUFBbUI0aEIsS0FBbkIsRUFBMEJDLE1BQTFCLEVBQWtDN0MsZUFBbEMsRUFBbUQ7SUFDdEYsSUFBSThDLGFBQUo7O0lBQ0EsSUFDRSxPQUFPTixNQUFQLEVBQWUsTUFBZixFQUF1QixDQUF2QixLQUE2QixHQUE3QixJQUNBLE9BQU9BLE1BQVAsRUFBZSxNQUFmLEVBQXVCLENBQUMsQ0FBeEIsRUFBMkJDLE1BQTNCLEtBQXNDLENBRHRDLElBRUEsS0FBS0QsTUFBTCxFQUFhLFNBQWIsRUFBd0JDLE1BQXhCLEtBQW1DLENBRm5DLElBR0EsSUFBSUQsTUFBSixFQUFZLFVBQVosRUFBd0JDLE1BQXhCLEtBQW1DLENBSG5DLElBSUEsSUFBSUQsTUFBSixFQUFZLE1BQVosRUFBb0JDLE1BQXBCLElBQThCLENBSjlCLElBS0EsR0FBR0QsTUFBSCxFQUFXLElBQVgsRUFBaUJDLE1BQWpCLENBTkYsRUFPRTs7TUFFQUssYUFBYSxHQUFHLHVCQUFVekksU0FBVixFQUFxQjBJLEtBQXJCLEVBQTRCO1FBQzFDLElBQUkvVyxNQUFNLEdBQUdoUCxNQUFNLENBQUMsSUFBRCxDQUFuQjtRQUNBLElBQUlxZCxTQUFTLEtBQUt0ZSxTQUFkLElBQTJCZ25CLEtBQUssS0FBSyxDQUF6QyxFQUE0QyxPQUFPLEVBQVAsQ0FGRjs7UUFJMUMsSUFBSSxDQUFDdk4sU0FBUSxDQUFDNkUsU0FBRCxDQUFiLEVBQTBCLE9BQU93SSxNQUFNLENBQUN4cEIsSUFBUCxDQUFZMlMsTUFBWixFQUFvQnFPLFNBQXBCLEVBQStCMEksS0FBL0IsQ0FBUDtRQUMxQixJQUFJQyxNQUFNLEdBQUcsRUFBYjtRQUNBLElBQUk5RCxLQUFLLEdBQUcsQ0FBQzdFLFNBQVMsQ0FBQ29ELFVBQVYsR0FBdUIsR0FBdkIsR0FBNkIsRUFBOUIsS0FDQ3BELFNBQVMsQ0FBQ3FELFNBQVYsR0FBc0IsR0FBdEIsR0FBNEIsRUFEN0IsS0FFQ3JELFNBQVMsQ0FBQ3NELE9BQVYsR0FBb0IsR0FBcEIsR0FBMEIsRUFGM0IsS0FHQ3RELFNBQVMsQ0FBQ3VELE1BQVYsR0FBbUIsR0FBbkIsR0FBeUIsRUFIMUIsQ0FBWjtRQUlBLElBQUlxRixhQUFhLEdBQUcsQ0FBcEI7UUFDQSxJQUFJQyxVQUFVLEdBQUdILEtBQUssS0FBS2huQixTQUFWLEdBQXNCMm1CLFVBQXRCLEdBQW1DSyxLQUFLLEtBQUssQ0FBOUQsQ0FYMEM7O1FBYTFDLElBQUlJLGFBQWEsR0FBRyxJQUFJelgsTUFBSixDQUFXMk8sU0FBUyxDQUFDeGMsTUFBckIsRUFBNkJxaEIsS0FBSyxHQUFHLEdBQXJDLENBQXBCO1FBQ0EsSUFBSS9ULEtBQUosRUFBVzJULFNBQVgsRUFBc0JzRSxVQUF0Qjs7UUFDQSxPQUFPalksS0FBSyxHQUFHOFQsV0FBVSxDQUFDNWxCLElBQVgsQ0FBZ0I4cEIsYUFBaEIsRUFBK0JuWCxNQUEvQixDQUFmLEVBQXVEO1VBQ3JEOFMsU0FBUyxHQUFHcUUsYUFBYSxDQUFDekUsWUFBRCxDQUF6Qjs7VUFDQSxJQUFJSSxTQUFTLEdBQUdtRSxhQUFoQixFQUErQjtZQUM3QkQsTUFBTSxDQUFDOW1CLElBQVAsQ0FBWThQLE1BQU0sQ0FBQ3BMLEtBQVAsQ0FBYXFpQixhQUFiLEVBQTRCOVgsS0FBSyxDQUFDNUosS0FBbEMsQ0FBWjtZQUNBLElBQUk0SixLQUFLLENBQUNzWCxNQUFELENBQUwsR0FBZ0IsQ0FBaEIsSUFBcUJ0WCxLQUFLLENBQUM1SixLQUFOLEdBQWN5SyxNQUFNLENBQUN5VyxNQUFELENBQTdDLEVBQXVERixLQUFLLENBQUNobEIsS0FBTixDQUFZeWxCLE1BQVosRUFBb0I3WCxLQUFLLENBQUN2SyxLQUFOLENBQVksQ0FBWixDQUFwQjtZQUN2RHdpQixVQUFVLEdBQUdqWSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNzWCxNQUFULENBQWI7WUFDQVEsYUFBYSxHQUFHbkUsU0FBaEI7WUFDQSxJQUFJa0UsTUFBTSxDQUFDUCxNQUFELENBQU4sSUFBa0JTLFVBQXRCLEVBQWtDOzs7VUFFcEMsSUFBSUMsYUFBYSxDQUFDekUsWUFBRCxDQUFiLEtBQThCdlQsS0FBSyxDQUFDNUosS0FBeEMsRUFBK0M0aEIsYUFBYSxDQUFDekUsWUFBRCxDQUFiLEdBVE07OztRQVd2RCxJQUFJdUUsYUFBYSxLQUFLalgsTUFBTSxDQUFDeVcsTUFBRCxDQUE1QixFQUFzQztVQUNwQyxJQUFJVyxVQUFVLElBQUksQ0FBQ0QsYUFBYSxDQUFDcFosSUFBZCxDQUFtQixFQUFuQixDQUFuQixFQUEyQ2laLE1BQU0sQ0FBQzltQixJQUFQLENBQVksRUFBWjtTQUQ3QyxNQUVPOG1CLE1BQU0sQ0FBQzltQixJQUFQLENBQVk4UCxNQUFNLENBQUNwTCxLQUFQLENBQWFxaUIsYUFBYixDQUFaOztRQUNQLE9BQU9ELE1BQU0sQ0FBQ1AsTUFBRCxDQUFOLEdBQWlCUyxVQUFqQixHQUE4QkYsTUFBTSxDQUFDcGlCLEtBQVAsQ0FBYSxDQUFiLEVBQWdCc2lCLFVBQWhCLENBQTlCLEdBQTRERixNQUFuRTtPQTdCRixDQUZBOztLQVBGLE1BeUNPLElBQUksSUFBSVIsTUFBSixFQUFZem1CLFNBQVosRUFBdUIsQ0FBdkIsRUFBMEIwbUIsTUFBMUIsQ0FBSixFQUF1QztNQUM1Q0ssYUFBYSxHQUFHLHVCQUFVekksU0FBVixFQUFxQjBJLEtBQXJCLEVBQTRCO1FBQzFDLE9BQU8xSSxTQUFTLEtBQUt0ZSxTQUFkLElBQTJCZ25CLEtBQUssS0FBSyxDQUFyQyxHQUF5QyxFQUF6QyxHQUE4Q0YsTUFBTSxDQUFDeHBCLElBQVAsQ0FBWSxJQUFaLEVBQWtCZ2hCLFNBQWxCLEVBQTZCMEksS0FBN0IsQ0FBckQ7T0FERjtLQURLLE1BSUE7TUFDTEQsYUFBYSxHQUFHRCxNQUFoQjs7O0lBR0YsT0FBTzs7SUFHTCxTQUFTcG1CLEtBQVQsQ0FBZTRkLFNBQWYsRUFBMEIwSSxLQUExQixFQUFpQztNQUMvQixJQUFJbG9CLENBQUMsR0FBR21HLE9BQU8sQ0FBQyxJQUFELENBQWY7TUFDQSxJQUFJcWlCLFFBQVEsR0FBR2hKLFNBQVMsSUFBSXRlLFNBQWIsR0FBeUJBLFNBQXpCLEdBQXFDc2UsU0FBUyxDQUFDdUksS0FBRCxDQUE3RDtNQUNBLE9BQU9TLFFBQVEsS0FBS3RuQixTQUFiLEdBQ0hzbkIsUUFBUSxDQUFDaHFCLElBQVQsQ0FBY2doQixTQUFkLEVBQXlCeGYsQ0FBekIsRUFBNEJrb0IsS0FBNUIsQ0FERyxHQUVIRCxhQUFhLENBQUN6cEIsSUFBZCxDQUFtQjJELE1BQU0sQ0FBQ25DLENBQUQsQ0FBekIsRUFBOEJ3ZixTQUE5QixFQUF5QzBJLEtBQXpDLENBRko7S0FORzs7Ozs7SUFlTCxVQUFVN0MsTUFBVixFQUFrQjZDLEtBQWxCLEVBQXlCO01BQ3ZCLElBQUk1VSxHQUFHLEdBQUc2UixlQUFlLENBQUM4QyxhQUFELEVBQWdCNUMsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI2QyxLQUE5QixFQUFxQ0QsYUFBYSxLQUFLRCxNQUF2RCxDQUF6QjtNQUNBLElBQUkxVSxHQUFHLENBQUNrSCxJQUFSLEVBQWMsT0FBT2xILEdBQUcsQ0FBQ2hULEtBQVg7TUFFZCxJQUFJcWxCLEVBQUUsR0FBR3hsQixTQUFRLENBQUNrbEIsTUFBRCxDQUFqQjtNQUNBLElBQUkzbEIsQ0FBQyxHQUFHeUMsTUFBTSxDQUFDLElBQUQsQ0FBZDtNQUNBLElBQUk2UCxDQUFDLEdBQUdvTyxtQkFBa0IsQ0FBQ3VGLEVBQUQsRUFBSzlVLE1BQUwsQ0FBMUI7TUFFQSxJQUFJNFgsZUFBZSxHQUFHOUMsRUFBRSxDQUFDN0MsT0FBekI7TUFDQSxJQUFJdUIsS0FBSyxHQUFHLENBQUNzQixFQUFFLENBQUMvQyxVQUFILEdBQWdCLEdBQWhCLEdBQXNCLEVBQXZCLEtBQ0MrQyxFQUFFLENBQUM5QyxTQUFILEdBQWUsR0FBZixHQUFxQixFQUR0QixLQUVDOEMsRUFBRSxDQUFDN0MsT0FBSCxHQUFhLEdBQWIsR0FBbUIsRUFGcEIsS0FHQ2dGLFVBQVUsR0FBRyxHQUFILEdBQVMsR0FIcEIsQ0FBWixDQVR1Qjs7O01BZ0J2QixJQUFJVSxRQUFRLEdBQUcsSUFBSXhXLENBQUosQ0FBTThWLFVBQVUsR0FBR25DLEVBQUgsR0FBUSxTQUFTQSxFQUFFLENBQUMzaUIsTUFBWixHQUFxQixHQUE3QyxFQUFrRHFoQixLQUFsRCxDQUFmO01BQ0EsSUFBSXFFLEdBQUcsR0FBR1IsS0FBSyxLQUFLaG5CLFNBQVYsR0FBc0IybUIsVUFBdEIsR0FBbUNLLEtBQUssS0FBSyxDQUF2RDtNQUNBLElBQUlRLEdBQUcsS0FBSyxDQUFaLEVBQWUsT0FBTyxFQUFQO01BQ2YsSUFBSWhwQixDQUFDLENBQUM0QyxNQUFGLEtBQWEsQ0FBakIsRUFBb0IsT0FBT3FtQixtQkFBYyxDQUFDSCxRQUFELEVBQVc5b0IsQ0FBWCxDQUFkLEtBQWdDLElBQWhDLEdBQXVDLENBQUNBLENBQUQsQ0FBdkMsR0FBNkMsRUFBcEQ7TUFDcEIsSUFBSTBqQixDQUFDLEdBQUcsQ0FBUjtNQUNBLElBQUl3RixDQUFDLEdBQUcsQ0FBUjtNQUNBLElBQUlwYSxDQUFDLEdBQUcsRUFBUjs7TUFDQSxPQUFPb2EsQ0FBQyxHQUFHbHBCLENBQUMsQ0FBQzRDLE1BQWIsRUFBcUI7UUFDbkJrbUIsUUFBUSxDQUFDdkUsU0FBVCxHQUFxQjZELFVBQVUsR0FBR2MsQ0FBSCxHQUFPLENBQXRDO1FBQ0EsSUFBSWxVLENBQUMsR0FBR2lVLG1CQUFjLENBQUNILFFBQUQsRUFBV1YsVUFBVSxHQUFHcG9CLENBQUgsR0FBT0EsQ0FBQyxDQUFDcUcsS0FBRixDQUFRNmlCLENBQVIsQ0FBNUIsQ0FBdEI7UUFDQSxJQUFJbHFCLENBQUo7O1FBQ0EsSUFDRWdXLENBQUMsS0FBSyxJQUFOLElBQ0EsQ0FBQ2hXLENBQUMsR0FBRytvQixJQUFJLENBQUN6Z0IsU0FBUSxDQUFDd2hCLFFBQVEsQ0FBQ3ZFLFNBQVQsSUFBc0I2RCxVQUFVLEdBQUcsQ0FBSCxHQUFPYyxDQUF2QyxDQUFELENBQVQsRUFBc0RscEIsQ0FBQyxDQUFDNEMsTUFBeEQsQ0FBVCxNQUE4RThnQixDQUZoRixFQUdFO1VBQ0F3RixDQUFDLEdBQUc3QyxtQkFBa0IsQ0FBQ3JtQixDQUFELEVBQUlrcEIsQ0FBSixFQUFPSCxlQUFQLENBQXRCO1NBSkYsTUFLTztVQUNMamEsQ0FBQyxDQUFDbk4sSUFBRixDQUFPM0IsQ0FBQyxDQUFDcUcsS0FBRixDQUFRcWQsQ0FBUixFQUFXd0YsQ0FBWCxDQUFQO1VBQ0EsSUFBSXBhLENBQUMsQ0FBQ2xNLE1BQUYsS0FBYW9tQixHQUFqQixFQUFzQixPQUFPbGEsQ0FBUDs7VUFDdEIsS0FBSyxJQUFJOUosQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSWdRLENBQUMsQ0FBQ3BTLE1BQUYsR0FBVyxDQUFoQyxFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7WUFDdEM4SixDQUFDLENBQUNuTixJQUFGLENBQU9xVCxDQUFDLENBQUNoUSxDQUFELENBQVI7WUFDQSxJQUFJOEosQ0FBQyxDQUFDbE0sTUFBRixLQUFhb21CLEdBQWpCLEVBQXNCLE9BQU9sYSxDQUFQOzs7VUFFeEJvYSxDQUFDLEdBQUd4RixDQUFDLEdBQUcxa0IsQ0FBUjs7OztNQUdKOFAsQ0FBQyxDQUFDbk4sSUFBRixDQUFPM0IsQ0FBQyxDQUFDcUcsS0FBRixDQUFRcWQsQ0FBUixDQUFQO01BQ0EsT0FBTzVVLENBQVA7S0ExREcsQ0FBUDtFQTZERCxDQWhIdUIsQ0FBeEI7O0VDckJBLGVBQWMsR0FBRyxvQkFBQSxDQUFVbFEsRUFBVixFQUFjb2EsV0FBZCxFQUEyQjNWLElBQTNCLEVBQWlDOGxCLGNBQWpDLEVBQWlEO0lBQ2hFLElBQUksRUFBRXZxQixFQUFFLFlBQVlvYSxXQUFoQixLQUFpQ21RLGNBQWMsS0FBSzNuQixTQUFuQixJQUFnQzJuQixjQUFjLElBQUl2cUIsRUFBdkYsRUFBNEY7TUFDMUYsTUFBTWMsU0FBUyxDQUFDMkQsSUFBSSxHQUFHLHlCQUFSLENBQWY7OztJQUNBLE9BQU96RSxFQUFQO0VBQ0gsQ0FKRDs7O0lDTUEsSUFBSXdxQixLQUFLLEdBQUcsRUFBWjtJQUNBLElBQUlDLE1BQU0sR0FBRyxFQUFiOztJQUNBLElBQUlybEIsT0FBTyxHQUFHM0YsY0FBQSxHQUFpQixVQUFVaXJCLFFBQVYsRUFBb0J0UCxPQUFwQixFQUE2Qi9aLEVBQTdCLEVBQWlDMEMsSUFBakMsRUFBdUN3VyxRQUF2QyxFQUFpRDtNQUM5RSxJQUFJbUcsTUFBTSxHQUFHbkcsUUFBUSxHQUFHLFlBQVk7UUFBRSxPQUFPbVEsUUFBUDtPQUFqQixHQUFzQy9KLHNCQUFTLENBQUMrSixRQUFELENBQXBFO01BQ0EsSUFBSXBvQixDQUFDLEdBQUdtRCxJQUFHLENBQUNwRSxFQUFELEVBQUswQyxJQUFMLEVBQVdxWCxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQXpCLENBQVg7TUFDQSxJQUFJaFQsS0FBSyxHQUFHLENBQVo7TUFDQSxJQUFJcEUsTUFBSixFQUFZNGMsSUFBWixFQUFrQnhULFFBQWxCLEVBQTRCcEUsTUFBNUI7TUFDQSxJQUFJLE9BQU8wWCxNQUFQLElBQWlCLFVBQXJCLEVBQWlDLE1BQU01ZixTQUFTLENBQUM0cEIsUUFBUSxHQUFHLG1CQUFaLENBQWYsQ0FMNkM7O01BTzlFLElBQUk3SixZQUFXLENBQUNILE1BQUQsQ0FBZixFQUF5QixLQUFLMWMsTUFBTSxHQUFHMEUsU0FBUSxDQUFDZ2lCLFFBQVEsQ0FBQzFtQixNQUFWLENBQXRCLEVBQXlDQSxNQUFNLEdBQUdvRSxLQUFsRCxFQUF5REEsS0FBSyxFQUE5RCxFQUFrRTtRQUN6RlksTUFBTSxHQUFHb1MsT0FBTyxHQUFHOVksQ0FBQyxDQUFDVCxTQUFRLENBQUMrZSxJQUFJLEdBQUc4SixRQUFRLENBQUN0aUIsS0FBRCxDQUFoQixDQUFSLENBQWlDLENBQWpDLENBQUQsRUFBc0N3WSxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFKLEdBQXFEdGUsQ0FBQyxDQUFDb29CLFFBQVEsQ0FBQ3RpQixLQUFELENBQVQsQ0FBdEU7UUFDQSxJQUFJWSxNQUFNLEtBQUt3aEIsS0FBWCxJQUFvQnhoQixNQUFNLEtBQUt5aEIsTUFBbkMsRUFBMkMsT0FBT3poQixNQUFQO09BRjdDLE1BR08sS0FBS29FLFFBQVEsR0FBR3NULE1BQU0sQ0FBQ3hnQixJQUFQLENBQVl3cUIsUUFBWixDQUFoQixFQUF1QyxDQUFDLENBQUM5SixJQUFJLEdBQUd4VCxRQUFRLENBQUNpTixJQUFULEVBQVIsRUFBeUI2QixJQUFqRSxHQUF3RTtRQUM3RWxULE1BQU0sR0FBRzlJLFNBQUksQ0FBQ2tOLFFBQUQsRUFBVzlLLENBQVgsRUFBY3NlLElBQUksQ0FBQzVlLEtBQW5CLEVBQTBCb1osT0FBMUIsQ0FBYjtRQUNBLElBQUlwUyxNQUFNLEtBQUt3aEIsS0FBWCxJQUFvQnhoQixNQUFNLEtBQUt5aEIsTUFBbkMsRUFBMkMsT0FBT3poQixNQUFQOztLQVovQzs7SUFlQTVELE9BQU8sQ0FBQ29sQixLQUFSLEdBQWdCQSxLQUFoQjtJQUNBcGxCLE9BQU8sQ0FBQ3FsQixNQUFSLEdBQWlCQSxNQUFqQjs7O0VDbkJBLElBQUlFLE9BQU8sR0FBR25yQixPQUFNLENBQUNtckIsT0FBckI7RUFDQSxJQUFJQyxPQUFPLEdBQUdwckIsT0FBTSxDQUFDcXJCLFlBQXJCO0VBQ0EsSUFBSUMsU0FBUyxHQUFHdHJCLE9BQU0sQ0FBQ3VyQixjQUF2QjtFQUNBLElBQUlDLGNBQWMsR0FBR3hyQixPQUFNLENBQUN3ckIsY0FBNUI7RUFDQSxJQUFJQyxRQUFRLEdBQUd6ckIsT0FBTSxDQUFDeXJCLFFBQXRCO0VBQ0EsSUFBSUMsT0FBTyxHQUFHLENBQWQ7RUFDQSxJQUFJQyxLQUFLLEdBQUcsRUFBWjtFQUNBLElBQUlDLGtCQUFrQixHQUFHLG9CQUF6QjtFQUNBLElBQUlDLEtBQUosRUFBV0MsT0FBWCxFQUFvQkMsSUFBcEI7O0VBQ0EsSUFBSUMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sR0FBWTtJQUNwQixJQUFJaHBCLEVBQUUsR0FBRyxDQUFDLElBQVYsQ0FEb0I7O0lBR3BCLElBQUkyb0IsS0FBSyxDQUFDcHJCLGNBQU4sQ0FBcUJ5QyxFQUFyQixDQUFKLEVBQThCO01BQzVCLElBQUluQixFQUFFLEdBQUc4cEIsS0FBSyxDQUFDM29CLEVBQUQsQ0FBZDtNQUNBLE9BQU8yb0IsS0FBSyxDQUFDM29CLEVBQUQsQ0FBWjtNQUNBbkIsRUFBRTs7RUFFTCxDQVJEOztFQVNBLElBQUlvcUIsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBVUMsS0FBVixFQUFpQjtJQUM5QkYsR0FBRyxDQUFDdHJCLElBQUosQ0FBU3dyQixLQUFLLENBQUN0VyxJQUFmO0VBQ0QsQ0FGRDs7O0VBSUEsSUFBSSxDQUFDd1YsT0FBRCxJQUFZLENBQUNFLFNBQWpCLEVBQTRCO0lBQzFCRixPQUFPLEdBQUcsU0FBU0MsWUFBVCxDQUFzQnhwQixFQUF0QixFQUEwQjtNQUNsQyxJQUFJd04sSUFBSSxHQUFHLEVBQVg7TUFDQSxJQUFJekksQ0FBQyxHQUFHLENBQVI7O01BQ0EsT0FBTy9CLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQm9DLENBQTFCO1FBQTZCeUksSUFBSSxDQUFDOUwsSUFBTCxDQUFVc0IsU0FBUyxDQUFDK0IsQ0FBQyxFQUFGLENBQW5COzs7TUFDN0Ira0IsS0FBSyxDQUFDLEVBQUVELE9BQUgsQ0FBTCxHQUFtQixZQUFZOztRQUU3QnRaLE9BQU0sQ0FBQyxPQUFPdlEsRUFBUCxJQUFhLFVBQWIsR0FBMEJBLEVBQTFCLEdBQStCeEIsUUFBUSxDQUFDd0IsRUFBRCxDQUF4QyxFQUE4Q3dOLElBQTlDLENBQU47T0FGRjs7TUFJQXdjLEtBQUssQ0FBQ0gsT0FBRCxDQUFMO01BQ0EsT0FBT0EsT0FBUDtLQVRGOztJQVdBSixTQUFTLEdBQUcsU0FBU0MsY0FBVCxDQUF3QnZvQixFQUF4QixFQUE0QjtNQUN0QyxPQUFPMm9CLEtBQUssQ0FBQzNvQixFQUFELENBQVo7S0FERixDQVowQjs7O0lBZ0IxQixJQUFJbkMsSUFBaUIsQ0FBQ3NxQixPQUFELENBQWpCLElBQThCLFNBQWxDLEVBQTZDO01BQzNDVSxLQUFLLEdBQUcsZUFBVTdvQixFQUFWLEVBQWM7UUFDcEJtb0IsT0FBTyxDQUFDZ0IsUUFBUixDQUFpQmxtQixJQUFHLENBQUMrbEIsR0FBRCxFQUFNaHBCLEVBQU4sRUFBVSxDQUFWLENBQXBCO09BREYsQ0FEMkM7O0tBQTdDLE1BS08sSUFBSXlvQixRQUFRLElBQUlBLFFBQVEsQ0FBQ3ZNLEdBQXpCLEVBQThCO01BQ25DMk0sS0FBSyxHQUFHLGVBQVU3b0IsRUFBVixFQUFjO1FBQ3BCeW9CLFFBQVEsQ0FBQ3ZNLEdBQVQsQ0FBYWpaLElBQUcsQ0FBQytsQixHQUFELEVBQU1ocEIsRUFBTixFQUFVLENBQVYsQ0FBaEI7T0FERixDQURtQzs7S0FBOUIsTUFLQSxJQUFJd29CLGNBQUosRUFBb0I7TUFDekJNLE9BQU8sR0FBRyxJQUFJTixjQUFKLEVBQVY7TUFDQU8sSUFBSSxHQUFHRCxPQUFPLENBQUNNLEtBQWY7TUFDQU4sT0FBTyxDQUFDTyxLQUFSLENBQWNDLFNBQWQsR0FBMEJMLFFBQTFCO01BQ0FKLEtBQUssR0FBRzVsQixJQUFHLENBQUM4bEIsSUFBSSxDQUFDUSxXQUFOLEVBQW1CUixJQUFuQixFQUF5QixDQUF6QixDQUFYLENBSnlCOztLQUFwQixNQU9BLElBQUkvckIsT0FBTSxDQUFDd3NCLGdCQUFQLElBQTJCLE9BQU9ELFdBQVAsSUFBc0IsVUFBakQsSUFBK0QsQ0FBQ3ZzQixPQUFNLENBQUN5c0IsYUFBM0UsRUFBMEY7TUFDL0ZaLEtBQUssR0FBRyxlQUFVN29CLEVBQVYsRUFBYztRQUNwQmhELE9BQU0sQ0FBQ3VzQixXQUFQLENBQW1CdnBCLEVBQUUsR0FBRyxFQUF4QixFQUE0QixHQUE1QjtPQURGOztNQUdBaEQsT0FBTSxDQUFDd3NCLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DUCxRQUFuQyxFQUE2QyxLQUE3QyxFQUorRjtLQUExRixNQU1BLElBQUlMLGtCQUFrQixJQUFJYyxVQUFHLENBQUMsUUFBRCxDQUE3QixFQUF5QztNQUM5Q2IsS0FBSyxHQUFHLGVBQVU3b0IsRUFBVixFQUFjO1FBQ3BCMmUsS0FBSSxDQUFDMVcsV0FBTCxDQUFpQnloQixVQUFHLENBQUMsUUFBRCxDQUFwQixFQUFnQ2Qsa0JBQWhDLElBQXNELFlBQVk7VUFDaEVqSyxLQUFJLENBQUNnTCxXQUFMLENBQWlCLElBQWpCO1VBQ0FYLEdBQUcsQ0FBQ3RyQixJQUFKLENBQVNzQyxFQUFUO1NBRkY7T0FERixDQUQ4Qzs7S0FBekMsTUFRQTtNQUNMNm9CLEtBQUssR0FBRyxlQUFVN29CLEVBQVYsRUFBYztRQUNwQjRwQixVQUFVLENBQUMzbUIsSUFBRyxDQUFDK2xCLEdBQUQsRUFBTWhwQixFQUFOLEVBQVUsQ0FBVixDQUFKLEVBQWtCLENBQWxCLENBQVY7T0FERjs7RUFJSDs7RUFDRCxTQUFjLEdBQUc7SUFDZnlMLEdBQUcsRUFBRTJjLE9BRFU7SUFFZnlCLEtBQUssRUFBRXZCO0VBRlEsQ0FBakI7O0VDL0VBLElBQUl3QixTQUFTLEdBQUdqc0IsS0FBa0IsQ0FBQzROLEdBQW5DO0VBQ0EsSUFBSXNlLFFBQVEsR0FBRy9zQixPQUFNLENBQUNndEIsZ0JBQVAsSUFBMkJodEIsT0FBTSxDQUFDaXRCLHNCQUFqRDtFQUNBLElBQUk5QixTQUFPLEdBQUduckIsT0FBTSxDQUFDbXJCLE9BQXJCO0VBQ0EsSUFBSStCLFNBQU8sR0FBR2x0QixPQUFNLENBQUNrdEIsT0FBckI7RUFDQSxJQUFJQyxNQUFNLEdBQUd6ckIsSUFBaUIsQ0FBQ3lwQixTQUFELENBQWpCLElBQThCLFNBQTNDOztFQUVBLGNBQWMsR0FBRyxtQkFBQSxHQUFZO0lBQzNCLElBQUlpQyxJQUFKLEVBQVVDLElBQVYsRUFBZ0JDLE1BQWhCOztJQUVBLElBQUlDLEtBQUssR0FBRyxTQUFSQSxLQUFRLEdBQVk7TUFDdEIsSUFBSUMsTUFBSixFQUFZM3JCLEVBQVo7TUFDQSxJQUFJc3JCLE1BQU0sS0FBS0ssTUFBTSxHQUFHckMsU0FBTyxDQUFDc0MsTUFBdEIsQ0FBVixFQUF5Q0QsTUFBTSxDQUFDRSxJQUFQOztNQUN6QyxPQUFPTixJQUFQLEVBQWE7UUFDWHZyQixFQUFFLEdBQUd1ckIsSUFBSSxDQUFDdnJCLEVBQVY7UUFDQXVyQixJQUFJLEdBQUdBLElBQUksQ0FBQ3ZTLElBQVo7O1FBQ0EsSUFBSTtVQUNGaFosRUFBRTtTQURKLENBRUUsT0FBT2pCLENBQVAsRUFBVTtVQUNWLElBQUl3c0IsSUFBSixFQUFVRSxNQUFNLEdBQWhCLEtBQ0tELElBQUksR0FBR2pxQixTQUFQO1VBQ0wsTUFBTXhDLENBQU47Ozs7TUFFRnlzQixJQUFJLEdBQUdqcUIsU0FBUDtNQUNGLElBQUlvcUIsTUFBSixFQUFZQSxNQUFNLENBQUNHLEtBQVA7S0FkZCxDQUgyQjs7O0lBcUIzQixJQUFJUixNQUFKLEVBQVk7TUFDVkcsTUFBTSxHQUFHLGtCQUFZO1FBQ25CbkMsU0FBTyxDQUFDZ0IsUUFBUixDQUFpQm9CLEtBQWpCO09BREYsQ0FEVTs7S0FBWixNQUtPLElBQUlSLFFBQVEsSUFBSSxFQUFFL3NCLE9BQU0sQ0FBQzR0QixTQUFQLElBQW9CNXRCLE9BQU0sQ0FBQzR0QixTQUFQLENBQWlCQyxVQUF2QyxDQUFoQixFQUFvRTtNQUN6RSxJQUFJQyxNQUFNLEdBQUcsSUFBYjtNQUNBLElBQUlDLElBQUksR0FBR3hzQixRQUFRLENBQUN5c0IsY0FBVCxDQUF3QixFQUF4QixDQUFYO01BQ0EsSUFBSWpCLFFBQUosQ0FBYVEsS0FBYixFQUFvQlUsT0FBcEIsQ0FBNEJGLElBQTVCLEVBQWtDO1FBQUVHLGFBQWEsRUFBRTtPQUFuRCxFQUh5RTs7TUFJekVaLE1BQU0sR0FBRyxrQkFBWTtRQUNuQlMsSUFBSSxDQUFDblksSUFBTCxHQUFZa1ksTUFBTSxHQUFHLENBQUNBLE1BQXRCO09BREYsQ0FKeUU7O0tBQXBFLE1BUUEsSUFBSVosU0FBTyxJQUFJQSxTQUFPLENBQUNpQixPQUF2QixFQUFnQzs7TUFFckMsSUFBSUMsT0FBTyxHQUFHbEIsU0FBTyxDQUFDaUIsT0FBUixDQUFnQi9xQixTQUFoQixDQUFkOztNQUNBa3FCLE1BQU0sR0FBRyxrQkFBWTtRQUNuQmMsT0FBTyxDQUFDQyxJQUFSLENBQWFkLEtBQWI7T0FERixDQUhxQzs7Ozs7OztLQUFoQyxNQVlBO01BQ0xELE1BQU0sR0FBRyxrQkFBWTs7UUFFbkJSLFNBQVMsQ0FBQ3BzQixJQUFWLENBQWVWLE9BQWYsRUFBdUJ1dEIsS0FBdkI7T0FGRjs7O0lBTUYsT0FBTyxVQUFVMXJCLEVBQVYsRUFBYztNQUNuQixJQUFJeXNCLElBQUksR0FBRztRQUFFenNCLEVBQUUsRUFBRUEsRUFBTjtRQUFVZ1osSUFBSSxFQUFFelg7T0FBM0I7TUFDQSxJQUFJaXFCLElBQUosRUFBVUEsSUFBSSxDQUFDeFMsSUFBTCxHQUFZeVQsSUFBWjs7TUFDVixJQUFJLENBQUNsQixJQUFMLEVBQVc7UUFDVEEsSUFBSSxHQUFHa0IsSUFBUDtRQUNBaEIsTUFBTTs7O01BQ05ELElBQUksR0FBR2lCLElBQVA7S0FOSjtFQVFELENBN0REOztFQ0hBLFNBQVNDLGlCQUFULENBQTJCcmEsQ0FBM0IsRUFBOEI7SUFDNUIsSUFBSWlhLE9BQUosRUFBYUssTUFBYjtJQUNBLEtBQUtKLE9BQUwsR0FBZSxJQUFJbGEsQ0FBSixDQUFNLFVBQVV1YSxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtNQUNsRCxJQUFJUCxPQUFPLEtBQUsvcUIsU0FBWixJQUF5Qm9yQixNQUFNLEtBQUtwckIsU0FBeEMsRUFBbUQsTUFBTTlCLFNBQVMsQ0FBQyx5QkFBRCxDQUFmO01BQ25ENnNCLE9BQU8sR0FBR00sU0FBVjtNQUNBRCxNQUFNLEdBQUdFLFFBQVQ7S0FIYSxDQUFmO0lBS0EsS0FBS1AsT0FBTCxHQUFlMXBCLFVBQVMsQ0FBQzBwQixPQUFELENBQXhCO0lBQ0EsS0FBS0ssTUFBTCxHQUFjL3BCLFVBQVMsQ0FBQytwQixNQUFELENBQXZCO0VBQ0Q7O0VBRUQsT0FBZ0IsR0FBRyxVQUFBLENBQVV0YSxDQUFWLEVBQWE7SUFDOUIsT0FBTyxJQUFJcWEsaUJBQUosQ0FBc0JyYSxDQUF0QixDQUFQO0VBQ0QsQ0FGRDs7Ozs7O0VDZkEsWUFBYyxHQUFHLGlCQUFBLENBQVV2VCxJQUFWLEVBQWdCO0lBQy9CLElBQUk7TUFDRixPQUFPO1FBQUVDLENBQUMsRUFBRSxLQUFMO1FBQVkrdEIsQ0FBQyxFQUFFaHVCLElBQUk7T0FBMUI7S0FERixDQUVFLE9BQU9DLENBQVAsRUFBVTtNQUNWLE9BQU87UUFBRUEsQ0FBQyxFQUFFLElBQUw7UUFBVyt0QixDQUFDLEVBQUUvdEI7T0FBckI7O0VBRUgsQ0FORDs7RUNDQSxJQUFJZ3RCLFdBQVMsR0FBRzV0QixPQUFNLENBQUM0dEIsU0FBdkI7O0VBRUEsY0FBYyxHQUFHQSxXQUFTLElBQUlBLFdBQVMsQ0FBQ2dCLFNBQXZCLElBQW9DLEVBQXJEOztFQ0NBLG1CQUFjLEdBQUcsd0JBQUEsQ0FBVTFhLENBQVYsRUFBYW5ELENBQWIsRUFBZ0I7SUFDL0IxTyxTQUFRLENBQUM2UixDQUFELENBQVI7SUFDQSxJQUFJN1MsU0FBUSxDQUFDMFAsQ0FBRCxDQUFSLElBQWVBLENBQUMsQ0FBQ25CLFdBQUYsS0FBa0JzRSxDQUFyQyxFQUF3QyxPQUFPbkQsQ0FBUDtJQUN4QyxJQUFJOGQsaUJBQWlCLEdBQUdDLHFCQUFvQixDQUFDaHNCLENBQXJCLENBQXVCb1IsQ0FBdkIsQ0FBeEI7SUFDQSxJQUFJaWEsT0FBTyxHQUFHVSxpQkFBaUIsQ0FBQ1YsT0FBaEM7SUFDQUEsT0FBTyxDQUFDcGQsQ0FBRCxDQUFQO0lBQ0EsT0FBTzhkLGlCQUFpQixDQUFDVCxPQUF6QjtFQUNELENBUEQ7O0VDSEEsZ0JBQWMsR0FBRyxxQkFBQSxDQUFVem9CLE1BQVYsRUFBa0J1RixHQUFsQixFQUF1QmxILElBQXZCLEVBQTZCO0lBQzVDLEtBQUssSUFBSXZELEdBQVQsSUFBZ0J5SyxHQUFoQjtNQUFxQmhGLFNBQVEsQ0FBQ1AsTUFBRCxFQUFTbEYsR0FBVCxFQUFjeUssR0FBRyxDQUFDekssR0FBRCxDQUFqQixFQUF3QnVELElBQXhCLENBQVI7OztJQUNyQixPQUFPMkIsTUFBUDtFQUNELENBSEQ7O0VDVUEsSUFBSTJvQixJQUFJLEdBQUd6dEIsS0FBa0IsQ0FBQzROLEdBQTlCO0VBQ0EsSUFBSXNnQixTQUFTLEdBQUdydEIsVUFBdUIsRUFBdkM7RUFLQSxJQUFJc3RCLE9BQU8sR0FBRyxTQUFkO0VBQ0EsSUFBSTF0QixXQUFTLEdBQUd0QixPQUFNLENBQUNzQixTQUF2QjtFQUNBLElBQUk2cEIsU0FBTyxHQUFHbnJCLE9BQU0sQ0FBQ21yQixPQUFyQjtFQUNBLElBQUk4RCxRQUFRLEdBQUc5RCxTQUFPLElBQUlBLFNBQU8sQ0FBQzhELFFBQWxDO0VBQ0EsSUFBSUMsRUFBRSxHQUFHRCxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsRUFBckIsSUFBMkIsRUFBcEM7RUFDQSxJQUFJQyxRQUFRLEdBQUdudkIsT0FBTSxDQUFDZ3ZCLE9BQUQsQ0FBckI7RUFDQSxJQUFJN0IsUUFBTSxHQUFHemIsUUFBTyxDQUFDeVosU0FBRCxDQUFQLElBQW9CLFNBQWpDOztFQUNBLElBQUlpRSxLQUFLLEdBQUcsU0FBUkEsS0FBUSxHQUFZOztFQUFlLENBQXZDOztFQUNBLElBQUlDLFFBQUosRUFBY0MsMkJBQWQsRUFBMkNDLG9CQUEzQyxFQUFpRUMsT0FBakU7RUFDQSxJQUFJVixvQkFBb0IsR0FBR1EsMkJBQTJCLEdBQUdHLHFCQUEwQixDQUFDM3NCLENBQXBGO0VBRUEsSUFBSStKLFlBQVUsR0FBRyxDQUFDLENBQUMsWUFBWTtJQUM3QixJQUFJOztNQUVGLElBQUl1aEIsT0FBTyxHQUFHZSxRQUFRLENBQUNoQixPQUFULENBQWlCLENBQWpCLENBQWQ7O01BQ0EsSUFBSXVCLFdBQVcsR0FBRyxDQUFDdEIsT0FBTyxDQUFDeGUsV0FBUixHQUFzQixFQUF2QixFQUEyQmpPLElBQWlCLENBQUMsU0FBRCxDQUE1QyxJQUEyRCxVQUFVaEIsSUFBVixFQUFnQjtRQUMzRkEsSUFBSSxDQUFDeXVCLEtBQUQsRUFBUUEsS0FBUixDQUFKO09BREYsQ0FIRTs7O01BT0YsT0FBTyxDQUFDakMsUUFBTSxJQUFJLE9BQU93QyxxQkFBUCxJQUFnQyxVQUEzQyxLQUNGdkIsT0FBTyxDQUFDQyxJQUFSLENBQWFlLEtBQWIsYUFBK0JNLFdBRDdCOzs7U0FLRlIsRUFBRSxDQUFDelIsT0FBSCxDQUFXLEtBQVgsTUFBc0IsQ0FMcEIsSUFNRm1SLFVBQVMsQ0FBQ25SLE9BQVYsQ0FBa0IsV0FBbEIsTUFBbUMsQ0FBQyxDQU56QztLQVBGLENBY0UsT0FBTzdjLENBQVAsRUFBVTs7O0VBQ2IsQ0FoQmtCLEVBQW5COztFQW1CQSxJQUFJZ3ZCLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVVwdkIsRUFBVixFQUFjO0lBQzdCLElBQUk2dEIsSUFBSjtJQUNBLE9BQU9odEIsU0FBUSxDQUFDYixFQUFELENBQVIsSUFBZ0IsUUFBUTZ0QixJQUFJLEdBQUc3dEIsRUFBRSxDQUFDNnRCLElBQWxCLEtBQTJCLFVBQTNDLEdBQXdEQSxJQUF4RCxHQUErRCxLQUF0RTtFQUNELENBSEQ7O0VBSUEsSUFBSWYsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVWMsT0FBVixFQUFtQnlCLFFBQW5CLEVBQTZCO0lBQ3hDLElBQUl6QixPQUFPLENBQUMwQixFQUFaLEVBQWdCO0lBQ2hCMUIsT0FBTyxDQUFDMEIsRUFBUixHQUFhLElBQWI7SUFDQSxJQUFJQyxLQUFLLEdBQUczQixPQUFPLENBQUM0QixFQUFwQjtJQUNBakIsU0FBUyxDQUFDLFlBQVk7TUFDcEIsSUFBSXZzQixLQUFLLEdBQUc0ckIsT0FBTyxDQUFDNkIsRUFBcEI7TUFDQSxJQUFJQyxFQUFFLEdBQUc5QixPQUFPLENBQUMrQixFQUFSLElBQWMsQ0FBdkI7TUFDQSxJQUFJdnBCLENBQUMsR0FBRyxDQUFSOztNQUNBLElBQUlvbEIsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBVW9FLFFBQVYsRUFBb0I7UUFDNUIsSUFBSUMsT0FBTyxHQUFHSCxFQUFFLEdBQUdFLFFBQVEsQ0FBQ0YsRUFBWixHQUFpQkUsUUFBUSxDQUFDRSxJQUExQztRQUNBLElBQUluQyxPQUFPLEdBQUdpQyxRQUFRLENBQUNqQyxPQUF2QjtRQUNBLElBQUlLLE1BQU0sR0FBRzRCLFFBQVEsQ0FBQzVCLE1BQXRCO1FBQ0EsSUFBSWYsTUFBTSxHQUFHMkMsUUFBUSxDQUFDM0MsTUFBdEI7UUFDQSxJQUFJamtCLE1BQUosRUFBWTZrQixJQUFaLEVBQWtCa0MsTUFBbEI7O1FBQ0EsSUFBSTtVQUNGLElBQUlGLE9BQUosRUFBYTtZQUNYLElBQUksQ0FBQ0gsRUFBTCxFQUFTO2NBQ1AsSUFBSTlCLE9BQU8sQ0FBQ29DLEVBQVIsSUFBYyxDQUFsQixFQUFxQkMsaUJBQWlCLENBQUNyQyxPQUFELENBQWpCO2NBQ3JCQSxPQUFPLENBQUNvQyxFQUFSLEdBQWEsQ0FBYjs7O1lBRUYsSUFBSUgsT0FBTyxLQUFLLElBQWhCLEVBQXNCN21CLE1BQU0sR0FBR2hILEtBQVQsQ0FBdEIsS0FDSztjQUNILElBQUlpckIsTUFBSixFQUFZQSxNQUFNLENBQUNFLEtBQVA7Y0FDWm5rQixNQUFNLEdBQUc2bUIsT0FBTyxDQUFDN3RCLEtBQUQsQ0FBaEIsQ0FGRzs7Y0FHSCxJQUFJaXJCLE1BQUosRUFBWTtnQkFDVkEsTUFBTSxDQUFDQyxJQUFQO2dCQUNBNkMsTUFBTSxHQUFHLElBQVQ7Ozs7WUFHSixJQUFJL21CLE1BQU0sS0FBSzRtQixRQUFRLENBQUNoQyxPQUF4QixFQUFpQztjQUMvQkksTUFBTSxDQUFDbHRCLFdBQVMsQ0FBQyxxQkFBRCxDQUFWLENBQU47YUFERixNQUVPLElBQUkrc0IsSUFBSSxHQUFHdUIsVUFBVSxDQUFDcG1CLE1BQUQsQ0FBckIsRUFBK0I7Y0FDcEM2a0IsSUFBSSxDQUFDM3RCLElBQUwsQ0FBVThJLE1BQVYsRUFBa0Iya0IsT0FBbEIsRUFBMkJLLE1BQTNCO2FBREssTUFFQUwsT0FBTyxDQUFDM2tCLE1BQUQsQ0FBUDtXQWxCVCxNQW1CT2dsQixNQUFNLENBQUNoc0IsS0FBRCxDQUFOO1NBcEJULENBcUJFLE9BQU81QixDQUFQLEVBQVU7VUFDVixJQUFJNnNCLE1BQU0sSUFBSSxDQUFDOEMsTUFBZixFQUF1QjlDLE1BQU0sQ0FBQ0MsSUFBUDtVQUN2QmMsTUFBTSxDQUFDNXRCLENBQUQsQ0FBTjs7T0E3Qko7O01BZ0NBLE9BQU9tdkIsS0FBSyxDQUFDdnJCLE1BQU4sR0FBZW9DLENBQXRCO1FBQXlCb2xCLEdBQUcsQ0FBQytELEtBQUssQ0FBQ25wQixDQUFDLEVBQUYsQ0FBTixDQUFIO09BcENMOzs7TUFxQ3BCd25CLE9BQU8sQ0FBQzRCLEVBQVIsR0FBYSxFQUFiO01BQ0E1QixPQUFPLENBQUMwQixFQUFSLEdBQWEsS0FBYjtNQUNBLElBQUlELFFBQVEsSUFBSSxDQUFDekIsT0FBTyxDQUFDb0MsRUFBekIsRUFBNkJFLFdBQVcsQ0FBQ3RDLE9BQUQsQ0FBWDtLQXZDdEIsQ0FBVDtFQXlDRCxDQTdDRDs7RUE4Q0EsSUFBSXNDLFdBQVcsR0FBRyxTQUFkQSxXQUFjLENBQVV0QyxPQUFWLEVBQW1CO0lBQ25DRSxJQUFJLENBQUM1dEIsSUFBTCxDQUFVVixPQUFWLEVBQWtCLFlBQVk7TUFDNUIsSUFBSXdDLEtBQUssR0FBRzRyQixPQUFPLENBQUM2QixFQUFwQjtNQUNBLElBQUlVLFNBQVMsR0FBR0MsV0FBVyxDQUFDeEMsT0FBRCxDQUEzQjtNQUNBLElBQUk1a0IsTUFBSixFQUFZNm1CLE9BQVosRUFBcUJRLE9BQXJCOztNQUNBLElBQUlGLFNBQUosRUFBZTtRQUNibm5CLE1BQU0sR0FBR3NuQixRQUFPLENBQUMsWUFBWTtVQUMzQixJQUFJM0QsUUFBSixFQUFZO1lBQ1ZoQyxTQUFPLENBQUM0RixJQUFSLENBQWEsb0JBQWIsRUFBbUN2dUIsS0FBbkMsRUFBMEM0ckIsT0FBMUM7V0FERixNQUVPLElBQUlpQyxPQUFPLEdBQUdyd0IsT0FBTSxDQUFDZ3hCLG9CQUFyQixFQUEyQztZQUNoRFgsT0FBTyxDQUFDO2NBQUVqQyxPQUFPLEVBQUVBLE9BQVg7Y0FBb0I2QyxNQUFNLEVBQUV6dUI7YUFBN0IsQ0FBUDtXQURLLE1BRUEsSUFBSSxDQUFDcXVCLE9BQU8sR0FBRzd3QixPQUFNLENBQUM2d0IsT0FBbEIsS0FBOEJBLE9BQU8sQ0FBQ0ssS0FBMUMsRUFBaUQ7WUFDdERMLE9BQU8sQ0FBQ0ssS0FBUixDQUFjLDZCQUFkLEVBQTZDMXVCLEtBQTdDOztTQU5ZLENBQWhCLENBRGE7O1FBV2I0ckIsT0FBTyxDQUFDb0MsRUFBUixHQUFhckQsUUFBTSxJQUFJeUQsV0FBVyxDQUFDeEMsT0FBRCxDQUFyQixHQUFpQyxDQUFqQyxHQUFxQyxDQUFsRDs7O01BQ0FBLE9BQU8sQ0FBQytDLEVBQVIsR0FBYS90QixTQUFiO01BQ0YsSUFBSXV0QixTQUFTLElBQUlubkIsTUFBTSxDQUFDNUksQ0FBeEIsRUFBMkIsTUFBTTRJLE1BQU0sQ0FBQ21sQixDQUFiO0tBakI3QjtFQW1CRCxDQXBCRDs7RUFxQkEsSUFBSWlDLFdBQVcsR0FBRyxTQUFkQSxXQUFjLENBQVV4QyxPQUFWLEVBQW1CO0lBQ25DLE9BQU9BLE9BQU8sQ0FBQ29DLEVBQVIsS0FBZSxDQUFmLElBQW9CLENBQUNwQyxPQUFPLENBQUMrQyxFQUFSLElBQWMvQyxPQUFPLENBQUM0QixFQUF2QixFQUEyQnhyQixNQUEzQixLQUFzQyxDQUFqRTtFQUNELENBRkQ7O0VBR0EsSUFBSWlzQixpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQVVyQyxPQUFWLEVBQW1CO0lBQ3pDRSxJQUFJLENBQUM1dEIsSUFBTCxDQUFVVixPQUFWLEVBQWtCLFlBQVk7TUFDNUIsSUFBSXF3QixPQUFKOztNQUNBLElBQUlsRCxRQUFKLEVBQVk7UUFDVmhDLFNBQU8sQ0FBQzRGLElBQVIsQ0FBYSxrQkFBYixFQUFpQzNDLE9BQWpDO09BREYsTUFFTyxJQUFJaUMsT0FBTyxHQUFHcndCLE9BQU0sQ0FBQ294QixrQkFBckIsRUFBeUM7UUFDOUNmLE9BQU8sQ0FBQztVQUFFakMsT0FBTyxFQUFFQSxPQUFYO1VBQW9CNkMsTUFBTSxFQUFFN0MsT0FBTyxDQUFDNkI7U0FBckMsQ0FBUDs7S0FMSjtFQVFELENBVEQ7O0VBVUEsSUFBSW9CLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVU3dUIsS0FBVixFQUFpQjtJQUM3QixJQUFJNHJCLE9BQU8sR0FBRyxJQUFkO0lBQ0EsSUFBSUEsT0FBTyxDQUFDa0QsRUFBWixFQUFnQjtJQUNoQmxELE9BQU8sQ0FBQ2tELEVBQVIsR0FBYSxJQUFiO0lBQ0FsRCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ21ELEVBQVIsSUFBY25ELE9BQXhCLENBSjZCOztJQUs3QkEsT0FBTyxDQUFDNkIsRUFBUixHQUFhenRCLEtBQWI7SUFDQTRyQixPQUFPLENBQUMrQixFQUFSLEdBQWEsQ0FBYjtJQUNBLElBQUksQ0FBQy9CLE9BQU8sQ0FBQytDLEVBQWIsRUFBaUIvQyxPQUFPLENBQUMrQyxFQUFSLEdBQWEvQyxPQUFPLENBQUM0QixFQUFSLENBQVcvbkIsS0FBWCxFQUFiO0lBQ2pCcWxCLE1BQU0sQ0FBQ2MsT0FBRCxFQUFVLElBQVYsQ0FBTjtFQUNELENBVEQ7O0VBVUEsSUFBSW9ELFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVVodkIsS0FBVixFQUFpQjtJQUM5QixJQUFJNHJCLE9BQU8sR0FBRyxJQUFkO0lBQ0EsSUFBSUMsSUFBSjtJQUNBLElBQUlELE9BQU8sQ0FBQ2tELEVBQVosRUFBZ0I7SUFDaEJsRCxPQUFPLENBQUNrRCxFQUFSLEdBQWEsSUFBYjtJQUNBbEQsT0FBTyxHQUFHQSxPQUFPLENBQUNtRCxFQUFSLElBQWNuRCxPQUF4QixDQUw4Qjs7SUFNOUIsSUFBSTtNQUNGLElBQUlBLE9BQU8sS0FBSzVyQixLQUFoQixFQUF1QixNQUFNbEIsV0FBUyxDQUFDLGtDQUFELENBQWY7O01BQ3ZCLElBQUkrc0IsSUFBSSxHQUFHdUIsVUFBVSxDQUFDcHRCLEtBQUQsQ0FBckIsRUFBOEI7UUFDNUJ1c0IsU0FBUyxDQUFDLFlBQVk7VUFDcEIsSUFBSTBDLE9BQU8sR0FBRztZQUFFRixFQUFFLEVBQUVuRCxPQUFOO1lBQWVrRCxFQUFFLEVBQUU7V0FBakMsQ0FEb0I7O1VBRXBCLElBQUk7WUFDRmpELElBQUksQ0FBQzN0QixJQUFMLENBQVU4QixLQUFWLEVBQWlCeUQsSUFBRyxDQUFDdXJCLFFBQUQsRUFBV0MsT0FBWCxFQUFvQixDQUFwQixDQUFwQixFQUE0Q3hyQixJQUFHLENBQUNvckIsT0FBRCxFQUFVSSxPQUFWLEVBQW1CLENBQW5CLENBQS9DO1dBREYsQ0FFRSxPQUFPN3dCLENBQVAsRUFBVTtZQUNWeXdCLE9BQU8sQ0FBQzN3QixJQUFSLENBQWErd0IsT0FBYixFQUFzQjd3QixDQUF0Qjs7U0FMSyxDQUFUO09BREYsTUFTTztRQUNMd3RCLE9BQU8sQ0FBQzZCLEVBQVIsR0FBYXp0QixLQUFiO1FBQ0E0ckIsT0FBTyxDQUFDK0IsRUFBUixHQUFhLENBQWI7UUFDQTdDLE1BQU0sQ0FBQ2MsT0FBRCxFQUFVLEtBQVYsQ0FBTjs7S0FkSixDQWdCRSxPQUFPeHRCLENBQVAsRUFBVTtNQUNWeXdCLE9BQU8sQ0FBQzN3QixJQUFSLENBQWE7UUFBRTZ3QixFQUFFLEVBQUVuRCxPQUFOO1FBQWVrRCxFQUFFLEVBQUU7T0FBaEMsRUFBeUMxd0IsQ0FBekMsRUFEVTs7RUFHYixDQXpCRDs7O0VBNEJBLElBQUksQ0FBQ2lNLFlBQUwsRUFBaUI7O0lBRWZzaUIsUUFBUSxHQUFHLFNBQVNqQyxPQUFULENBQWlCd0UsUUFBakIsRUFBMkI7TUFDcENDLFdBQVUsQ0FBQyxJQUFELEVBQU94QyxRQUFQLEVBQWlCSCxPQUFqQixFQUEwQixJQUExQixDQUFWO01BQ0F2cUIsVUFBUyxDQUFDaXRCLFFBQUQsQ0FBVDtNQUNBckMsUUFBUSxDQUFDM3VCLElBQVQsQ0FBYyxJQUFkOztNQUNBLElBQUk7UUFDRmd4QixRQUFRLENBQUN6ckIsSUFBRyxDQUFDdXJCLFFBQUQsRUFBVyxJQUFYLEVBQWlCLENBQWpCLENBQUosRUFBeUJ2ckIsSUFBRyxDQUFDb3JCLE9BQUQsRUFBVSxJQUFWLEVBQWdCLENBQWhCLENBQTVCLENBQVI7T0FERixDQUVFLE9BQU9PLEdBQVAsRUFBWTtRQUNaUCxPQUFPLENBQUMzd0IsSUFBUixDQUFhLElBQWIsRUFBbUJreEIsR0FBbkI7O0tBUEosQ0FGZTs7O0lBYWZ2QyxRQUFRLEdBQUcsU0FBU25DLE9BQVQsQ0FBaUJ3RSxRQUFqQixFQUEyQjtNQUNwQyxLQUFLMUIsRUFBTCxHQUFVLEVBQVYsQ0FEb0M7O01BRXBDLEtBQUttQixFQUFMLEdBQVUvdEIsU0FBVixDQUZvQzs7TUFHcEMsS0FBSytzQixFQUFMLEdBQVUsQ0FBVixDQUhvQzs7TUFJcEMsS0FBS21CLEVBQUwsR0FBVSxLQUFWLENBSm9DOztNQUtwQyxLQUFLckIsRUFBTCxHQUFVN3NCLFNBQVYsQ0FMb0M7O01BTXBDLEtBQUtvdEIsRUFBTCxHQUFVLENBQVYsQ0FOb0M7O01BT3BDLEtBQUtWLEVBQUwsR0FBVSxLQUFWLENBUG9DO0tBQXRDOztJQVNBVCxRQUFRLENBQUMvcUIsU0FBVCxHQUFxQm9LLFlBQTBCLENBQUN5Z0IsUUFBUSxDQUFDN3FCLFNBQVYsRUFBcUI7O01BRWxFK3BCLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWN3RCxXQUFkLEVBQTJCQyxVQUEzQixFQUF1QztRQUMzQyxJQUFJMUIsUUFBUSxHQUFHdEIsb0JBQW9CLENBQUN4TSxtQkFBa0IsQ0FBQyxJQUFELEVBQU82TSxRQUFQLENBQW5CLENBQW5DO1FBQ0FpQixRQUFRLENBQUNGLEVBQVQsR0FBYyxPQUFPMkIsV0FBUCxJQUFzQixVQUF0QixHQUFtQ0EsV0FBbkMsR0FBaUQsSUFBL0Q7UUFDQXpCLFFBQVEsQ0FBQ0UsSUFBVCxHQUFnQixPQUFPd0IsVUFBUCxJQUFxQixVQUFyQixJQUFtQ0EsVUFBbkQ7UUFDQTFCLFFBQVEsQ0FBQzNDLE1BQVQsR0FBa0JOLFFBQU0sR0FBR2hDLFNBQU8sQ0FBQ3NDLE1BQVgsR0FBb0JycUIsU0FBNUM7O1FBQ0EsS0FBSzRzQixFQUFMLENBQVF6c0IsSUFBUixDQUFhNnNCLFFBQWI7O1FBQ0EsSUFBSSxLQUFLZSxFQUFULEVBQWEsS0FBS0EsRUFBTCxDQUFRNXRCLElBQVIsQ0FBYTZzQixRQUFiO1FBQ2IsSUFBSSxLQUFLRCxFQUFULEVBQWE3QyxNQUFNLENBQUMsSUFBRCxFQUFPLEtBQVAsQ0FBTjtRQUNiLE9BQU84QyxRQUFRLENBQUNoQyxPQUFoQjtPQVZnRTs7TUFhbEUsU0FBUyxnQkFBVTBELFVBQVYsRUFBc0I7UUFDN0IsT0FBTyxLQUFLekQsSUFBTCxDQUFVanJCLFNBQVYsRUFBcUIwdUIsVUFBckIsQ0FBUDs7S0FkMkMsQ0FBL0M7O0lBaUJBdkMsb0JBQW9CLEdBQUcsZ0NBQVk7TUFDakMsSUFBSW5CLE9BQU8sR0FBRyxJQUFJaUIsUUFBSixFQUFkO01BQ0EsS0FBS2pCLE9BQUwsR0FBZUEsT0FBZjtNQUNBLEtBQUtELE9BQUwsR0FBZWxvQixJQUFHLENBQUN1ckIsUUFBRCxFQUFXcEQsT0FBWCxFQUFvQixDQUFwQixDQUFsQjtNQUNBLEtBQUtJLE1BQUwsR0FBY3ZvQixJQUFHLENBQUNvckIsT0FBRCxFQUFVakQsT0FBVixFQUFtQixDQUFuQixDQUFqQjtLQUpGOztJQU1BcUIscUJBQTBCLENBQUMzc0IsQ0FBM0IsR0FBK0Jnc0Isb0JBQW9CLEdBQUcsOEJBQVU1YSxDQUFWLEVBQWE7TUFDakUsT0FBT0EsQ0FBQyxLQUFLaWIsUUFBTixJQUFrQmpiLENBQUMsS0FBS3NiLE9BQXhCLEdBQ0gsSUFBSUQsb0JBQUosQ0FBeUJyYixDQUF6QixDQURHLEdBRUhvYiwyQkFBMkIsQ0FBQ3BiLENBQUQsQ0FGL0I7S0FERjtFQUtEOztBQUVEblAsU0FBTyxDQUFDQSxPQUFPLENBQUNPLENBQVIsR0FBWVAsT0FBTyxDQUFDcUIsQ0FBcEIsR0FBd0JyQixPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDeUgsWUFBdEMsRUFBa0Q7SUFBRXFnQixPQUFPLEVBQUVpQztFQUFYLENBQWxELENBQVA7QUFDQTNmLGlCQUErQixDQUFDMmYsUUFBRCxFQUFXSCxPQUFYLENBQS9CO0FBQ0E3WixhQUF5QixDQUFDNlosT0FBRCxDQUF6QjtFQUNBUSxPQUFPLEdBQUdwYSxLQUFrQixDQUFDNFosT0FBRCxDQUE1Qjs7QUFHQWpxQixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUN5SCxZQUExQixFQUFzQ21pQixPQUF0QyxFQUErQzs7SUFFcERSLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCdUQsQ0FBaEIsRUFBbUI7TUFDekIsSUFBSUMsVUFBVSxHQUFHbEQsb0JBQW9CLENBQUMsSUFBRCxDQUFyQztNQUNBLElBQUlKLFFBQVEsR0FBR3NELFVBQVUsQ0FBQ3hELE1BQTFCO01BQ0FFLFFBQVEsQ0FBQ3FELENBQUQsQ0FBUjtNQUNBLE9BQU9DLFVBQVUsQ0FBQzVELE9BQWxCOztFQU5rRCxDQUEvQyxDQUFQO0FBU0FycEIsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsSUFBYTBDLENBQVcsQ0FBQytFLFlBQXpCLENBQWIsRUFBbURtaUIsT0FBbkQsRUFBNEQ7O0lBRWpFYixPQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFpQnBkLENBQWpCLEVBQW9CO01BQzNCLE9BQU9raEIsZUFBYyxDQUFDbnFCLENBQXlDLElBQTFDLEVBQWdEaUosQ0FBaEQsQ0FBckI7O0VBSCtELENBQTVELENBQVA7QUFNQWhNLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBUixHQUFZbUQsT0FBTyxDQUFDSyxDQUFSLEdBQVksRUFBRXlILFlBQVUsSUFBSXFsQixXQUF5QixDQUFDLFVBQVVwUixJQUFWLEVBQWdCO0lBQ3hGcU8sUUFBUSxDQUFDZ0QsR0FBVCxDQUFhclIsSUFBYixFQUFtQixPQUFuQixFQUE0QnNPLEtBQTVCO0VBQ0QsQ0FGd0UsQ0FBekMsQ0FBekIsRUFFRkosT0FGRSxFQUVPOztJQUVabUQsR0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYWpILFFBQWIsRUFBdUI7TUFDMUIsSUFBSWhYLENBQUMsR0FBRyxJQUFSO01BQ0EsSUFBSThkLFVBQVUsR0FBR2xELG9CQUFvQixDQUFDNWEsQ0FBRCxDQUFyQztNQUNBLElBQUlpYSxPQUFPLEdBQUc2RCxVQUFVLENBQUM3RCxPQUF6QjtNQUNBLElBQUlLLE1BQU0sR0FBR3dELFVBQVUsQ0FBQ3hELE1BQXhCO01BQ0EsSUFBSWhsQixNQUFNLEdBQUdzbkIsUUFBTyxDQUFDLFlBQVk7UUFDL0IsSUFBSW5WLE1BQU0sR0FBRyxFQUFiO1FBQ0EsSUFBSS9TLEtBQUssR0FBRyxDQUFaO1FBQ0EsSUFBSXdwQixTQUFTLEdBQUcsQ0FBaEI7UUFDQUMsTUFBSyxDQUFDbkgsUUFBRCxFQUFXLEtBQVgsRUFBa0IsVUFBVWtELE9BQVYsRUFBbUI7VUFDeEMsSUFBSWtFLE1BQU0sR0FBRzFwQixLQUFLLEVBQWxCO1VBQ0EsSUFBSTJwQixhQUFhLEdBQUcsS0FBcEI7VUFDQTVXLE1BQU0sQ0FBQ3BZLElBQVAsQ0FBWUgsU0FBWjtVQUNBZ3ZCLFNBQVM7VUFDVGxlLENBQUMsQ0FBQ2lhLE9BQUYsQ0FBVUMsT0FBVixFQUFtQkMsSUFBbkIsQ0FBd0IsVUFBVTdyQixLQUFWLEVBQWlCO1lBQ3ZDLElBQUkrdkIsYUFBSixFQUFtQjtZQUNuQkEsYUFBYSxHQUFHLElBQWhCO1lBQ0E1VyxNQUFNLENBQUMyVyxNQUFELENBQU4sR0FBaUI5dkIsS0FBakI7WUFDQSxFQUFFNHZCLFNBQUYsSUFBZWpFLE9BQU8sQ0FBQ3hTLE1BQUQsQ0FBdEI7V0FKRixFQUtHNlMsTUFMSDtTQUxHLENBQUw7UUFZQSxFQUFFNEQsU0FBRixJQUFlakUsT0FBTyxDQUFDeFMsTUFBRCxDQUF0QjtPQWhCa0IsQ0FBcEI7TUFrQkEsSUFBSW5TLE1BQU0sQ0FBQzVJLENBQVgsRUFBYzR0QixNQUFNLENBQUNobEIsTUFBTSxDQUFDbWxCLENBQVIsQ0FBTjtNQUNkLE9BQU9xRCxVQUFVLENBQUM1RCxPQUFsQjtLQTFCVTs7SUE2QlpvRSxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjdEgsUUFBZCxFQUF3QjtNQUM1QixJQUFJaFgsQ0FBQyxHQUFHLElBQVI7TUFDQSxJQUFJOGQsVUFBVSxHQUFHbEQsb0JBQW9CLENBQUM1YSxDQUFELENBQXJDO01BQ0EsSUFBSXNhLE1BQU0sR0FBR3dELFVBQVUsQ0FBQ3hELE1BQXhCO01BQ0EsSUFBSWhsQixNQUFNLEdBQUdzbkIsUUFBTyxDQUFDLFlBQVk7UUFDL0J1QixNQUFLLENBQUNuSCxRQUFELEVBQVcsS0FBWCxFQUFrQixVQUFVa0QsT0FBVixFQUFtQjtVQUN4Q2xhLENBQUMsQ0FBQ2lhLE9BQUYsQ0FBVUMsT0FBVixFQUFtQkMsSUFBbkIsQ0FBd0IyRCxVQUFVLENBQUM3RCxPQUFuQyxFQUE0Q0ssTUFBNUM7U0FERyxDQUFMO09BRGtCLENBQXBCO01BS0EsSUFBSWhsQixNQUFNLENBQUM1SSxDQUFYLEVBQWM0dEIsTUFBTSxDQUFDaGxCLE1BQU0sQ0FBQ21sQixDQUFSLENBQU47TUFDZCxPQUFPcUQsVUFBVSxDQUFDNUQsT0FBbEI7O0VBdkNVLENBRlAsQ0FBUDs7RUNqUEEsdUJBQWMsR0FBRyw0QkFBQSxDQUFVNXRCLEVBQVYsRUFBYzhTLElBQWQsRUFBb0I7SUFDbkMsSUFBSSxDQUFDalMsU0FBUSxDQUFDYixFQUFELENBQVQsSUFBaUJBLEVBQUUsQ0FBQytiLEVBQUgsS0FBVWpKLElBQS9CLEVBQXFDLE1BQU1oUyxTQUFTLENBQUMsNEJBQTRCZ1MsSUFBNUIsR0FBbUMsWUFBcEMsQ0FBZjtJQUNyQyxPQUFPOVMsRUFBUDtFQUNELENBSEQ7O0VDQUEsSUFBSXlCLElBQUUsR0FBR3BCLFNBQXVCLENBQUNpQyxDQUFqQztFQVVBLElBQUlnRSxPQUFPLEdBQUdwRixLQUFrQixDQUFDb0YsT0FBakM7RUFFQSxJQUFJMnJCLElBQUksR0FBR3RsQixZQUFXLEdBQUcsSUFBSCxHQUFVLE1BQWhDOztFQUVBLElBQUl1bEIsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBVW51QixJQUFWLEVBQWdCOUQsR0FBaEIsRUFBcUI7O0lBRWxDLElBQUltSSxLQUFLLEdBQUc5QixPQUFPLENBQUNyRyxHQUFELENBQW5CO0lBQ0EsSUFBSWt5QixLQUFKO0lBQ0EsSUFBSS9wQixLQUFLLEtBQUssR0FBZCxFQUFtQixPQUFPckUsSUFBSSxDQUFDaVksRUFBTCxDQUFRNVQsS0FBUixDQUFQLENBSmU7O0lBTWxDLEtBQUsrcEIsS0FBSyxHQUFHcHVCLElBQUksQ0FBQ3F1QixFQUFsQixFQUFzQkQsS0FBdEIsRUFBNkJBLEtBQUssR0FBR0EsS0FBSyxDQUFDM2dCLENBQTNDLEVBQThDO01BQzVDLElBQUkyZ0IsS0FBSyxDQUFDN2pCLENBQU4sSUFBV3JPLEdBQWYsRUFBb0IsT0FBT2t5QixLQUFQOztFQUV2QixDQVREOztFQVdBLHFCQUFjLEdBQUc7SUFDZkUsY0FBYyxFQUFFLHdCQUFVcEIsT0FBVixFQUFtQmxmLElBQW5CLEVBQXlCZ1EsTUFBekIsRUFBaUN1USxLQUFqQyxFQUF3QztNQUN0RCxJQUFJNWUsQ0FBQyxHQUFHdWQsT0FBTyxDQUFDLFVBQVVsdEIsSUFBVixFQUFnQjJtQixRQUFoQixFQUEwQjtRQUN4Q3lHLFdBQVUsQ0FBQ3B0QixJQUFELEVBQU8yUCxDQUFQLEVBQVUzQixJQUFWLEVBQWdCLElBQWhCLENBQVY7UUFDQWhPLElBQUksQ0FBQ2dZLEVBQUwsR0FBVWhLLElBQVYsQ0FGd0M7O1FBR3hDaE8sSUFBSSxDQUFDaVksRUFBTCxHQUFVelYsYUFBTSxDQUFDLElBQUQsQ0FBaEIsQ0FId0M7O1FBSXhDeEMsSUFBSSxDQUFDcXVCLEVBQUwsR0FBVXh2QixTQUFWLENBSndDOztRQUt4Q21CLElBQUksQ0FBQ3d1QixFQUFMLEdBQVUzdkIsU0FBVixDQUx3Qzs7UUFNeENtQixJQUFJLENBQUNrdUIsSUFBRCxDQUFKLEdBQWEsQ0FBYixDQU53Qzs7UUFPeEMsSUFBSXZILFFBQVEsSUFBSTluQixTQUFoQixFQUEyQml2QixNQUFLLENBQUNuSCxRQUFELEVBQVczSSxNQUFYLEVBQW1CaGUsSUFBSSxDQUFDdXVCLEtBQUQsQ0FBdkIsRUFBZ0N2dUIsSUFBaEMsQ0FBTDtPQVBkLENBQWY7TUFTQXl1QixZQUFXLENBQUM5ZSxDQUFDLENBQUM1UCxTQUFILEVBQWM7OztRQUd2QnVvQixLQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtVQUN0QixLQUFLLElBQUl0b0IsSUFBSSxHQUFHMHVCLG1CQUFRLENBQUMsSUFBRCxFQUFPMWdCLElBQVAsQ0FBbkIsRUFBaUNxRCxJQUFJLEdBQUdyUixJQUFJLENBQUNpWSxFQUE3QyxFQUFpRG1XLEtBQUssR0FBR3B1QixJQUFJLENBQUNxdUIsRUFBbkUsRUFBdUVELEtBQXZFLEVBQThFQSxLQUFLLEdBQUdBLEtBQUssQ0FBQzNnQixDQUE1RixFQUErRjtZQUM3RjJnQixLQUFLLENBQUNaLENBQU4sR0FBVSxJQUFWO1lBQ0EsSUFBSVksS0FBSyxDQUFDck4sQ0FBVixFQUFhcU4sS0FBSyxDQUFDck4sQ0FBTixHQUFVcU4sS0FBSyxDQUFDck4sQ0FBTixDQUFRdFQsQ0FBUixHQUFZNU8sU0FBdEI7WUFDYixPQUFPd1MsSUFBSSxDQUFDK2MsS0FBSyxDQUFDL3JCLENBQVAsQ0FBWDs7O1VBRUZyQyxJQUFJLENBQUNxdUIsRUFBTCxHQUFVcnVCLElBQUksQ0FBQ3d1QixFQUFMLEdBQVUzdkIsU0FBcEI7VUFDQW1CLElBQUksQ0FBQ2t1QixJQUFELENBQUosR0FBYSxDQUFiO1NBVnFCOzs7UUFjdkIsVUFBVSxpQkFBVWh5QixHQUFWLEVBQWU7VUFDdkIsSUFBSThELElBQUksR0FBRzB1QixtQkFBUSxDQUFDLElBQUQsRUFBTzFnQixJQUFQLENBQW5CO1VBQ0EsSUFBSW9nQixLQUFLLEdBQUdELFFBQVEsQ0FBQ251QixJQUFELEVBQU85RCxHQUFQLENBQXBCOztVQUNBLElBQUlreUIsS0FBSixFQUFXO1lBQ1QsSUFBSTlYLElBQUksR0FBRzhYLEtBQUssQ0FBQzNnQixDQUFqQjtZQUNBLElBQUlraEIsSUFBSSxHQUFHUCxLQUFLLENBQUNyTixDQUFqQjtZQUNBLE9BQU8vZ0IsSUFBSSxDQUFDaVksRUFBTCxDQUFRbVcsS0FBSyxDQUFDL3JCLENBQWQsQ0FBUDtZQUNBK3JCLEtBQUssQ0FBQ1osQ0FBTixHQUFVLElBQVY7WUFDQSxJQUFJbUIsSUFBSixFQUFVQSxJQUFJLENBQUNsaEIsQ0FBTCxHQUFTNkksSUFBVDtZQUNWLElBQUlBLElBQUosRUFBVUEsSUFBSSxDQUFDeUssQ0FBTCxHQUFTNE4sSUFBVDtZQUNWLElBQUkzdUIsSUFBSSxDQUFDcXVCLEVBQUwsSUFBV0QsS0FBZixFQUFzQnB1QixJQUFJLENBQUNxdUIsRUFBTCxHQUFVL1gsSUFBVjtZQUN0QixJQUFJdFcsSUFBSSxDQUFDd3VCLEVBQUwsSUFBV0osS0FBZixFQUFzQnB1QixJQUFJLENBQUN3dUIsRUFBTCxHQUFVRyxJQUFWO1lBQ3RCM3VCLElBQUksQ0FBQ2t1QixJQUFELENBQUo7OztVQUNBLE9BQU8sQ0FBQyxDQUFDRSxLQUFUO1NBM0JtQjs7O1FBK0J2Qi9oQixPQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFpQmtTOztVQUFxQztVQUM3RG1RLG1CQUFRLENBQUMsSUFBRCxFQUFPMWdCLElBQVAsQ0FBUjtVQUNBLElBQUl6UCxDQUFDLEdBQUdtRCxJQUFHLENBQUM2YyxVQUFELEVBQWFqZSxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBbkQsRUFBOEQsQ0FBOUQsQ0FBWDtVQUNBLElBQUl1dkIsS0FBSjs7VUFDQSxPQUFPQSxLQUFLLEdBQUdBLEtBQUssR0FBR0EsS0FBSyxDQUFDM2dCLENBQVQsR0FBYSxLQUFLNGdCLEVBQXRDLEVBQTBDO1lBQ3hDOXZCLENBQUMsQ0FBQzZ2QixLQUFLLENBQUNoRSxDQUFQLEVBQVVnRSxLQUFLLENBQUM3akIsQ0FBaEIsRUFBbUIsSUFBbkIsQ0FBRCxDQUR3Qzs7WUFHeEMsT0FBTzZqQixLQUFLLElBQUlBLEtBQUssQ0FBQ1osQ0FBdEI7Y0FBeUJZLEtBQUssR0FBR0EsS0FBSyxDQUFDck4sQ0FBZDs7O1NBdENOOzs7UUEyQ3ZCcGhCLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWF6RCxHQUFiLEVBQWtCO1VBQ3JCLE9BQU8sQ0FBQyxDQUFDaXlCLFFBQVEsQ0FBQ08sbUJBQVEsQ0FBQyxJQUFELEVBQU8xZ0IsSUFBUCxDQUFULEVBQXVCOVIsR0FBdkIsQ0FBakI7O09BNUNPLENBQVg7TUErQ0EsSUFBSTBNLFlBQUosRUFBaUJsTCxJQUFFLENBQUNpUyxDQUFDLENBQUM1UCxTQUFILEVBQWMsTUFBZCxFQUFzQjtRQUN2Q3RELEdBQUcsRUFBRSxlQUFZO1VBQ2YsT0FBT2l5QixtQkFBUSxDQUFDLElBQUQsRUFBTzFnQixJQUFQLENBQVIsQ0FBcUJrZ0IsSUFBckIsQ0FBUDs7T0FGZSxDQUFGO01BS2pCLE9BQU92ZSxDQUFQO0tBL0RhO0lBaUVmek0sR0FBRyxFQUFFLGFBQVVsRCxJQUFWLEVBQWdCOUQsR0FBaEIsRUFBcUIrQixLQUFyQixFQUE0QjtNQUMvQixJQUFJbXdCLEtBQUssR0FBR0QsUUFBUSxDQUFDbnVCLElBQUQsRUFBTzlELEdBQVAsQ0FBcEI7TUFDQSxJQUFJeXlCLElBQUosRUFBVXRxQixLQUFWLENBRitCOztNQUkvQixJQUFJK3BCLEtBQUosRUFBVztRQUNUQSxLQUFLLENBQUNoRSxDQUFOLEdBQVVuc0IsS0FBVixDQURTO09BQVgsTUFHTztRQUNMK0IsSUFBSSxDQUFDd3VCLEVBQUwsR0FBVUosS0FBSyxHQUFHO1VBQ2hCL3JCLENBQUMsRUFBRWdDLEtBQUssR0FBRzlCLE9BQU8sQ0FBQ3JHLEdBQUQsRUFBTSxJQUFOLENBREY7O1VBRWhCcU8sQ0FBQyxFQUFFck8sR0FGYTs7VUFHaEJrdUIsQ0FBQyxFQUFFbnNCLEtBSGE7O1VBSWhCOGlCLENBQUMsRUFBRTROLElBQUksR0FBRzN1QixJQUFJLENBQUN3dUIsRUFKQzs7VUFLaEIvZ0IsQ0FBQyxFQUFFNU8sU0FMYTs7VUFNaEIydUIsQ0FBQyxFQUFFLEtBTmE7O1NBQWxCO1FBUUEsSUFBSSxDQUFDeHRCLElBQUksQ0FBQ3F1QixFQUFWLEVBQWNydUIsSUFBSSxDQUFDcXVCLEVBQUwsR0FBVUQsS0FBVjtRQUNkLElBQUlPLElBQUosRUFBVUEsSUFBSSxDQUFDbGhCLENBQUwsR0FBUzJnQixLQUFUO1FBQ1ZwdUIsSUFBSSxDQUFDa3VCLElBQUQsQ0FBSixHQVhLOztRQWFMLElBQUk3cEIsS0FBSyxLQUFLLEdBQWQsRUFBbUJyRSxJQUFJLENBQUNpWSxFQUFMLENBQVE1VCxLQUFSLElBQWlCK3BCLEtBQWpCOzs7TUFDbkIsT0FBT3B1QixJQUFQO0tBdEZXO0lBd0ZmbXVCLFFBQVEsRUFBRUEsUUF4Rks7SUF5RmZTLFNBQVMsRUFBRSxtQkFBVWpmLENBQVYsRUFBYTNCLElBQWIsRUFBbUJnUSxNQUFuQixFQUEyQjs7O01BR3BDNlEsV0FBVyxDQUFDbGYsQ0FBRCxFQUFJM0IsSUFBSixFQUFVLFVBQVUrSixRQUFWLEVBQW9CWixJQUFwQixFQUEwQjtRQUM3QyxLQUFLYSxFQUFMLEdBQVUwVyxtQkFBUSxDQUFDM1csUUFBRCxFQUFXL0osSUFBWCxDQUFsQixDQUQ2Qzs7UUFFN0MsS0FBSzdFLEVBQUwsR0FBVWdPLElBQVYsQ0FGNkM7O1FBRzdDLEtBQUtxWCxFQUFMLEdBQVUzdkIsU0FBVixDQUg2QztPQUFwQyxFQUlSLFlBQVk7UUFDYixJQUFJbUIsSUFBSSxHQUFHLElBQVg7UUFDQSxJQUFJbVgsSUFBSSxHQUFHblgsSUFBSSxDQUFDbUosRUFBaEI7UUFDQSxJQUFJaWxCLEtBQUssR0FBR3B1QixJQUFJLENBQUN3dUIsRUFBakIsQ0FIYTs7UUFLYixPQUFPSixLQUFLLElBQUlBLEtBQUssQ0FBQ1osQ0FBdEI7VUFBeUJZLEtBQUssR0FBR0EsS0FBSyxDQUFDck4sQ0FBZDtTQUxaOzs7UUFPYixJQUFJLENBQUMvZ0IsSUFBSSxDQUFDZ1ksRUFBTixJQUFZLEVBQUVoWSxJQUFJLENBQUN3dUIsRUFBTCxHQUFVSixLQUFLLEdBQUdBLEtBQUssR0FBR0EsS0FBSyxDQUFDM2dCLENBQVQsR0FBYXpOLElBQUksQ0FBQ2dZLEVBQUwsQ0FBUXFXLEVBQTlDLENBQWhCLEVBQW1FOztVQUVqRXJ1QixJQUFJLENBQUNnWSxFQUFMLEdBQVVuWixTQUFWO1VBQ0EsT0FBT2dlLFNBQUksQ0FBQyxDQUFELENBQVg7U0FWVzs7O1FBYWIsSUFBSTFGLElBQUksSUFBSSxNQUFaLEVBQW9CLE9BQU8wRixTQUFJLENBQUMsQ0FBRCxFQUFJdVIsS0FBSyxDQUFDN2pCLENBQVYsQ0FBWDtRQUNwQixJQUFJNE0sSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBTzBGLFNBQUksQ0FBQyxDQUFELEVBQUl1UixLQUFLLENBQUNoRSxDQUFWLENBQVg7UUFDdEIsT0FBT3ZOLFNBQUksQ0FBQyxDQUFELEVBQUksQ0FBQ3VSLEtBQUssQ0FBQzdqQixDQUFQLEVBQVU2akIsS0FBSyxDQUFDaEUsQ0FBaEIsQ0FBSixDQUFYO09BbkJTLEVBb0JScE0sTUFBTSxHQUFHLFNBQUgsR0FBZSxRQXBCYixFQW9CdUIsQ0FBQ0EsTUFwQnhCLEVBb0JnQyxJQXBCaEMsQ0FBWCxDQUhvQzs7TUEwQnBDOFEsV0FBVSxDQUFDOWdCLElBQUQsQ0FBVjs7RUFuSGEsQ0FBakI7O0VDWkEsZUFBYyxHQUFHLG9CQUFBLENBQVVBLElBQVYsRUFBZ0JrZixPQUFoQixFQUF5QnRWLE9BQXpCLEVBQWtDbVgsTUFBbEMsRUFBMEMvUSxNQUExQyxFQUFrRGdSLE9BQWxELEVBQTJEO0lBQzFFLElBQUlsZixJQUFJLEdBQUdyVSxPQUFNLENBQUN1UyxJQUFELENBQWpCO0lBQ0EsSUFBSTJCLENBQUMsR0FBR0csSUFBUjtJQUNBLElBQUl5ZSxLQUFLLEdBQUd2USxNQUFNLEdBQUcsS0FBSCxHQUFXLEtBQTdCO0lBQ0EsSUFBSXJSLEtBQUssR0FBR2dELENBQUMsSUFBSUEsQ0FBQyxDQUFDNVAsU0FBbkI7SUFDQSxJQUFJcEMsQ0FBQyxHQUFHLEVBQVI7O0lBQ0EsSUFBSXN4QixTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVcHNCLEdBQVYsRUFBZTtNQUM3QixJQUFJdkYsRUFBRSxHQUFHcVAsS0FBSyxDQUFDOUosR0FBRCxDQUFkO01BQ0FsQixTQUFRLENBQUNnTCxLQUFELEVBQVE5SixHQUFSLEVBQ05BLEdBQUcsSUFBSSxRQUFQLEdBQWtCLFVBQVVuRyxDQUFWLEVBQWE7UUFDN0IsT0FBT3N5QixPQUFPLElBQUksQ0FBQ2x5QixTQUFRLENBQUNKLENBQUQsQ0FBcEIsR0FBMEIsS0FBMUIsR0FBa0NZLEVBQUUsQ0FBQ25CLElBQUgsQ0FBUSxJQUFSLEVBQWNPLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QixDQUF6QztPQURGLEdBRUltRyxHQUFHLElBQUksS0FBUCxHQUFlLFNBQVNsRCxHQUFULENBQWFqRCxDQUFiLEVBQWdCO1FBQ2pDLE9BQU9zeUIsT0FBTyxJQUFJLENBQUNseUIsU0FBUSxDQUFDSixDQUFELENBQXBCLEdBQTBCLEtBQTFCLEdBQWtDWSxFQUFFLENBQUNuQixJQUFILENBQVEsSUFBUixFQUFjTyxDQUFDLEtBQUssQ0FBTixHQUFVLENBQVYsR0FBY0EsQ0FBNUIsQ0FBekM7T0FERSxHQUVBbUcsR0FBRyxJQUFJLEtBQVAsR0FBZSxTQUFTcEcsR0FBVCxDQUFhQyxDQUFiLEVBQWdCO1FBQ2pDLE9BQU9zeUIsT0FBTyxJQUFJLENBQUNseUIsU0FBUSxDQUFDSixDQUFELENBQXBCLEdBQTBCbUMsU0FBMUIsR0FBc0N2QixFQUFFLENBQUNuQixJQUFILENBQVEsSUFBUixFQUFjTyxDQUFDLEtBQUssQ0FBTixHQUFVLENBQVYsR0FBY0EsQ0FBNUIsQ0FBN0M7T0FERSxHQUVBbUcsR0FBRyxJQUFJLEtBQVAsR0FBZSxTQUFTcXNCLEdBQVQsQ0FBYXh5QixDQUFiLEVBQWdCO1FBQUVZLEVBQUUsQ0FBQ25CLElBQUgsQ0FBUSxJQUFSLEVBQWNPLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QjtRQUFnQyxPQUFPLElBQVA7T0FBakUsR0FDQSxTQUFTd04sR0FBVCxDQUFheE4sQ0FBYixFQUFnQnlELENBQWhCLEVBQW1CO1FBQUU3QyxFQUFFLENBQUNuQixJQUFILENBQVEsSUFBUixFQUFjTyxDQUFDLEtBQUssQ0FBTixHQUFVLENBQVYsR0FBY0EsQ0FBNUIsRUFBK0J5RCxDQUEvQjtRQUFtQyxPQUFPLElBQVA7T0FSdEQsQ0FBUjtLQUZGOztJQWFBLElBQUksT0FBT3dQLENBQVAsSUFBWSxVQUFaLElBQTBCLEVBQUVxZixPQUFPLElBQUlyaUIsS0FBSyxDQUFDTixPQUFOLElBQWlCLENBQUNsQixNQUFLLENBQUMsWUFBWTtNQUM3RSxJQUFJd0UsQ0FBSixHQUFRMEgsT0FBUixHQUFrQmYsSUFBbEI7S0FEZ0UsQ0FBcEMsQ0FBOUIsRUFFSzs7TUFFSDNHLENBQUMsR0FBR29mLE1BQU0sQ0FBQ1QsY0FBUCxDQUFzQnBCLE9BQXRCLEVBQStCbGYsSUFBL0IsRUFBcUNnUSxNQUFyQyxFQUE2Q3VRLEtBQTdDLENBQUo7TUFDQUUsWUFBVyxDQUFDOWUsQ0FBQyxDQUFDNVAsU0FBSCxFQUFjNlgsT0FBZCxDQUFYO01BQ0FqVixLQUFJLENBQUNDLElBQUwsR0FBWSxJQUFaO0tBTkYsTUFPTztNQUNMLElBQUl1c0IsUUFBUSxHQUFHLElBQUl4ZixDQUFKLEVBQWYsQ0FESzs7TUFHTCxJQUFJeWYsY0FBYyxHQUFHRCxRQUFRLENBQUNaLEtBQUQsQ0FBUixDQUFnQlMsT0FBTyxHQUFHLEVBQUgsR0FBUSxDQUFDLENBQWhDLEVBQW1DLENBQW5DLEtBQXlDRyxRQUE5RCxDQUhLOztNQUtMLElBQUlFLG9CQUFvQixHQUFHbGtCLE1BQUssQ0FBQyxZQUFZO1FBQUVna0IsUUFBUSxDQUFDeHZCLEdBQVQsQ0FBYSxDQUFiO09BQWYsQ0FBaEMsQ0FMSzs7TUFPTCxJQUFJMnZCLGdCQUFnQixHQUFHQyxXQUFXLENBQUMsVUFBVWhULElBQVYsRUFBZ0I7UUFBRSxJQUFJNU0sQ0FBSixDQUFNNE0sSUFBTjtPQUFuQixDQUFsQyxDQVBLOzs7TUFTTCxJQUFJaVQsVUFBVSxHQUFHLENBQUNSLE9BQUQsSUFBWTdqQixNQUFLLENBQUMsWUFBWTs7UUFFN0MsSUFBSXNrQixTQUFTLEdBQUcsSUFBSTlmLENBQUosRUFBaEI7UUFDQSxJQUFJdEwsS0FBSyxHQUFHLENBQVo7O1FBQ0EsT0FBT0EsS0FBSyxFQUFaO1VBQWdCb3JCLFNBQVMsQ0FBQ2xCLEtBQUQsQ0FBVCxDQUFpQmxxQixLQUFqQixFQUF3QkEsS0FBeEI7OztRQUNoQixPQUFPLENBQUNvckIsU0FBUyxDQUFDOXZCLEdBQVYsQ0FBYyxDQUFDLENBQWYsQ0FBUjtPQUxnQyxDQUFsQzs7TUFPQSxJQUFJLENBQUMydkIsZ0JBQUwsRUFBdUI7UUFDckIzZixDQUFDLEdBQUd1ZCxPQUFPLENBQUMsVUFBVTlyQixNQUFWLEVBQWtCdWxCLFFBQWxCLEVBQTRCO1VBQ3RDeUcsV0FBVSxDQUFDaHNCLE1BQUQsRUFBU3VPLENBQVQsRUFBWTNCLElBQVosQ0FBVjtVQUNBLElBQUloTyxJQUFJLEdBQUcyUSxrQkFBaUIsQ0FBQyxJQUFJYixJQUFKLEVBQUQsRUFBYTFPLE1BQWIsRUFBcUJ1TyxDQUFyQixDQUE1QjtVQUNBLElBQUlnWCxRQUFRLElBQUk5bkIsU0FBaEIsRUFBMkJpdkIsTUFBSyxDQUFDbkgsUUFBRCxFQUFXM0ksTUFBWCxFQUFtQmhlLElBQUksQ0FBQ3V1QixLQUFELENBQXZCLEVBQWdDdnVCLElBQWhDLENBQUw7VUFDM0IsT0FBT0EsSUFBUDtTQUpTLENBQVg7UUFNQTJQLENBQUMsQ0FBQzVQLFNBQUYsR0FBYzRNLEtBQWQ7UUFDQUEsS0FBSyxDQUFDdEIsV0FBTixHQUFvQnNFLENBQXBCOzs7TUFFRixJQUFJMGYsb0JBQW9CLElBQUlHLFVBQTVCLEVBQXdDO1FBQ3RDUCxTQUFTLENBQUMsUUFBRCxDQUFUO1FBQ0FBLFNBQVMsQ0FBQyxLQUFELENBQVQ7UUFDQWpSLE1BQU0sSUFBSWlSLFNBQVMsQ0FBQyxLQUFELENBQW5COzs7TUFFRixJQUFJTyxVQUFVLElBQUlKLGNBQWxCLEVBQWtDSCxTQUFTLENBQUNWLEtBQUQsQ0FBVCxDQS9CN0I7O01BaUNMLElBQUlTLE9BQU8sSUFBSXJpQixLQUFLLENBQUMyYixLQUFyQixFQUE0QixPQUFPM2IsS0FBSyxDQUFDMmIsS0FBYjs7O0lBRzlCcGQsZUFBYyxDQUFDeUUsQ0FBRCxFQUFJM0IsSUFBSixDQUFkO0lBRUFyUSxDQUFDLENBQUNxUSxJQUFELENBQUQsR0FBVTJCLENBQVY7SUFDQW5QLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDTyxDQUFSLEdBQVlQLE9BQU8sQ0FBQ3FCLENBQXBCLEdBQXdCckIsT0FBTyxDQUFDSyxDQUFSLElBQWE4TyxDQUFDLElBQUlHLElBQWxCLENBQXpCLEVBQWtEblMsQ0FBbEQsQ0FBUDtJQUVBLElBQUksQ0FBQ3F4QixPQUFMLEVBQWNELE1BQU0sQ0FBQ0gsU0FBUCxDQUFpQmpmLENBQWpCLEVBQW9CM0IsSUFBcEIsRUFBMEJnUSxNQUExQjtJQUVkLE9BQU9yTyxDQUFQO0VBQ0QsQ0F0RUQ7O0VDWEEsSUFBSStmLEdBQUcsR0FBRyxLQUFWOztFQUdBLFdBQWMsR0FBR3B6QixXQUF3QixDQUFDb3pCLEdBQUQsRUFBTSxVQUFVanpCLEdBQVYsRUFBZTtJQUM1RCxPQUFPLFNBQVNrekIsR0FBVCxHQUFlO01BQUUsT0FBT2x6QixHQUFHLENBQUMsSUFBRCxFQUFPNkQsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQTdDLENBQVY7S0FBeEI7RUFDRCxDQUZ3QyxFQUV0Qzs7SUFFRHBDLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWFQLEdBQWIsRUFBa0I7TUFDckIsSUFBSWt5QixLQUFLLEdBQUd3QixpQkFBTSxDQUFDekIsUUFBUCxDQUFnQk8sbUJBQVEsQ0FBQyxJQUFELEVBQU9nQixHQUFQLENBQXhCLEVBQXFDeHpCLEdBQXJDLENBQVo7TUFDQSxPQUFPa3lCLEtBQUssSUFBSUEsS0FBSyxDQUFDaEUsQ0FBdEI7S0FKRDs7SUFPRGxnQixHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhaE8sR0FBYixFQUFrQitCLEtBQWxCLEVBQXlCO01BQzVCLE9BQU8yeEIsaUJBQU0sQ0FBQzFzQixHQUFQLENBQVd3ckIsbUJBQVEsQ0FBQyxJQUFELEVBQU9nQixHQUFQLENBQW5CLEVBQWdDeHpCLEdBQUcsS0FBSyxDQUFSLEdBQVksQ0FBWixHQUFnQkEsR0FBaEQsRUFBcUQrQixLQUFyRCxDQUFQOztFQVJELENBRnNDLEVBWXRDMnhCLGlCQVpzQyxFQVk5QixJQVo4QixDQUF6Qzs7RUNIQSxJQUFJQyxHQUFHLEdBQUcsS0FBVjs7RUFHQSxXQUFjLEdBQUd2ekIsV0FBd0IsQ0FBQ3V6QixHQUFELEVBQU0sVUFBVXB6QixHQUFWLEVBQWU7SUFDNUQsT0FBTyxTQUFTcXpCLEdBQVQsR0FBZTtNQUFFLE9BQU9yekIsR0FBRyxDQUFDLElBQUQsRUFBTzZELFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUE3QyxDQUFWO0tBQXhCO0VBQ0QsQ0FGd0MsRUFFdEM7O0lBRURxd0IsR0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYWp4QixLQUFiLEVBQW9CO01BQ3ZCLE9BQU8yeEIsaUJBQU0sQ0FBQzFzQixHQUFQLENBQVd3ckIsbUJBQVEsQ0FBQyxJQUFELEVBQU9tQixHQUFQLENBQW5CLEVBQWdDNXhCLEtBQUssR0FBR0EsS0FBSyxLQUFLLENBQVYsR0FBYyxDQUFkLEdBQWtCQSxLQUExRCxFQUFpRUEsS0FBakUsQ0FBUDs7RUFIRCxDQUZzQyxFQU90QzJ4QixpQkFQc0MsQ0FBekM7O0VDSkEsSUFBSW50QixPQUFPLEdBQUduRyxLQUFrQixDQUFDbUcsT0FBakM7RUFRQSxJQUFJc3RCLFNBQVMsR0FBR0MsYUFBaUIsQ0FBQyxDQUFELENBQWpDO0VBQ0EsSUFBSUMsY0FBYyxHQUFHRCxhQUFpQixDQUFDLENBQUQsQ0FBdEM7RUFDQSxJQUFJdnhCLElBQUUsR0FBRyxDQUFUOztFQUdBLElBQUl5eEIsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFVbHdCLElBQVYsRUFBZ0I7SUFDeEMsT0FBT0EsSUFBSSxDQUFDd3VCLEVBQUwsS0FBWXh1QixJQUFJLENBQUN3dUIsRUFBTCxHQUFVLElBQUkyQixtQkFBSixFQUF0QixDQUFQO0VBQ0QsQ0FGRDs7RUFHQSxJQUFJQSxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLEdBQVk7SUFDcEMsS0FBS3p6QixDQUFMLEdBQVMsRUFBVDtFQUNELENBRkQ7O0VBR0EsSUFBSTB6QixrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQXFCLENBQVVyeEIsS0FBVixFQUFpQjdDLEdBQWpCLEVBQXNCO0lBQzdDLE9BQU82ekIsU0FBUyxDQUFDaHhCLEtBQUssQ0FBQ3JDLENBQVAsRUFBVSxVQUFVVCxFQUFWLEVBQWM7TUFDdEMsT0FBT0EsRUFBRSxDQUFDLENBQUQsQ0FBRixLQUFVQyxHQUFqQjtLQURjLENBQWhCO0VBR0QsQ0FKRDs7RUFLQWkwQixtQkFBbUIsQ0FBQ3B3QixTQUFwQixHQUFnQztJQUM5QnRELEdBQUcsRUFBRSxhQUFVUCxHQUFWLEVBQWU7TUFDbEIsSUFBSWt5QixLQUFLLEdBQUdnQyxrQkFBa0IsQ0FBQyxJQUFELEVBQU9sMEIsR0FBUCxDQUE5QjtNQUNBLElBQUlreUIsS0FBSixFQUFXLE9BQU9BLEtBQUssQ0FBQyxDQUFELENBQVo7S0FIaUI7SUFLOUJ6dUIsR0FBRyxFQUFFLGFBQVV6RCxHQUFWLEVBQWU7TUFDbEIsT0FBTyxDQUFDLENBQUNrMEIsa0JBQWtCLENBQUMsSUFBRCxFQUFPbDBCLEdBQVAsQ0FBM0I7S0FONEI7SUFROUJnTyxHQUFHLEVBQUUsYUFBVWhPLEdBQVYsRUFBZStCLEtBQWYsRUFBc0I7TUFDekIsSUFBSW13QixLQUFLLEdBQUdnQyxrQkFBa0IsQ0FBQyxJQUFELEVBQU9sMEIsR0FBUCxDQUE5QjtNQUNBLElBQUlreUIsS0FBSixFQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdud0IsS0FBWCxDQUFYLEtBQ0ssS0FBS3ZCLENBQUwsQ0FBT3NDLElBQVAsQ0FBWSxDQUFDOUMsR0FBRCxFQUFNK0IsS0FBTixDQUFaO0tBWHVCO0lBYTlCLFVBQVUsaUJBQVUvQixHQUFWLEVBQWU7TUFDdkIsSUFBSW1JLEtBQUssR0FBRzRyQixjQUFjLENBQUMsS0FBS3Z6QixDQUFOLEVBQVMsVUFBVVQsRUFBVixFQUFjO1FBQy9DLE9BQU9BLEVBQUUsQ0FBQyxDQUFELENBQUYsS0FBVUMsR0FBakI7T0FEd0IsQ0FBMUI7TUFHQSxJQUFJLENBQUNtSSxLQUFMLEVBQVksS0FBSzNILENBQUwsQ0FBTzJ6QixNQUFQLENBQWNoc0IsS0FBZCxFQUFxQixDQUFyQjtNQUNaLE9BQU8sQ0FBQyxDQUFDLENBQUNBLEtBQVY7O0VBbEI0QixDQUFoQztFQXNCQSxtQkFBYyxHQUFHO0lBQ2ZpcUIsY0FBYyxFQUFFLHdCQUFVcEIsT0FBVixFQUFtQmxmLElBQW5CLEVBQXlCZ1EsTUFBekIsRUFBaUN1USxLQUFqQyxFQUF3QztNQUN0RCxJQUFJNWUsQ0FBQyxHQUFHdWQsT0FBTyxDQUFDLFVBQVVsdEIsSUFBVixFQUFnQjJtQixRQUFoQixFQUEwQjtRQUN4Q3lHLFdBQVUsQ0FBQ3B0QixJQUFELEVBQU8yUCxDQUFQLEVBQVUzQixJQUFWLEVBQWdCLElBQWhCLENBQVY7UUFDQWhPLElBQUksQ0FBQ2dZLEVBQUwsR0FBVWhLLElBQVYsQ0FGd0M7O1FBR3hDaE8sSUFBSSxDQUFDaVksRUFBTCxHQUFVeFosSUFBRSxFQUFaLENBSHdDOztRQUl4Q3VCLElBQUksQ0FBQ3d1QixFQUFMLEdBQVUzdkIsU0FBVixDQUp3Qzs7UUFLeEMsSUFBSThuQixRQUFRLElBQUk5bkIsU0FBaEIsRUFBMkJpdkIsTUFBSyxDQUFDbkgsUUFBRCxFQUFXM0ksTUFBWCxFQUFtQmhlLElBQUksQ0FBQ3V1QixLQUFELENBQXZCLEVBQWdDdnVCLElBQWhDLENBQUw7T0FMZCxDQUFmO01BT0F5dUIsWUFBVyxDQUFDOWUsQ0FBQyxDQUFDNVAsU0FBSCxFQUFjOzs7UUFHdkIsVUFBVSxpQkFBVTdELEdBQVYsRUFBZTtVQUN2QixJQUFJLENBQUNZLFNBQVEsQ0FBQ1osR0FBRCxDQUFiLEVBQW9CLE9BQU8sS0FBUDtVQUNwQixJQUFJbVYsSUFBSSxHQUFHNU8sT0FBTyxDQUFDdkcsR0FBRCxDQUFsQjtVQUNBLElBQUltVixJQUFJLEtBQUssSUFBYixFQUFtQixPQUFPNmUsbUJBQW1CLENBQUN4QixtQkFBUSxDQUFDLElBQUQsRUFBTzFnQixJQUFQLENBQVQsQ0FBbkIsQ0FBMEMsUUFBMUMsRUFBb0Q5UixHQUFwRCxDQUFQO1VBQ25CLE9BQU9tVixJQUFJLElBQUlpZixJQUFJLENBQUNqZixJQUFELEVBQU8sS0FBSzRHLEVBQVosQ0FBWixJQUErQixPQUFPNUcsSUFBSSxDQUFDLEtBQUs0RyxFQUFOLENBQWpEO1NBUHFCOzs7UUFXdkJ0WSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhekQsR0FBYixFQUFrQjtVQUNyQixJQUFJLENBQUNZLFNBQVEsQ0FBQ1osR0FBRCxDQUFiLEVBQW9CLE9BQU8sS0FBUDtVQUNwQixJQUFJbVYsSUFBSSxHQUFHNU8sT0FBTyxDQUFDdkcsR0FBRCxDQUFsQjtVQUNBLElBQUltVixJQUFJLEtBQUssSUFBYixFQUFtQixPQUFPNmUsbUJBQW1CLENBQUN4QixtQkFBUSxDQUFDLElBQUQsRUFBTzFnQixJQUFQLENBQVQsQ0FBbkIsQ0FBMENyTyxHQUExQyxDQUE4Q3pELEdBQTlDLENBQVA7VUFDbkIsT0FBT21WLElBQUksSUFBSWlmLElBQUksQ0FBQ2pmLElBQUQsRUFBTyxLQUFLNEcsRUFBWixDQUFuQjs7T0FmTyxDQUFYO01Ba0JBLE9BQU90SSxDQUFQO0tBM0JhO0lBNkJmek0sR0FBRyxFQUFFLGFBQVVsRCxJQUFWLEVBQWdCOUQsR0FBaEIsRUFBcUIrQixLQUFyQixFQUE0QjtNQUMvQixJQUFJb1QsSUFBSSxHQUFHNU8sT0FBTyxDQUFDM0UsU0FBUSxDQUFDNUIsR0FBRCxDQUFULEVBQWdCLElBQWhCLENBQWxCO01BQ0EsSUFBSW1WLElBQUksS0FBSyxJQUFiLEVBQW1CNmUsbUJBQW1CLENBQUNsd0IsSUFBRCxDQUFuQixDQUEwQmtLLEdBQTFCLENBQThCaE8sR0FBOUIsRUFBbUMrQixLQUFuQyxFQUFuQixLQUNLb1QsSUFBSSxDQUFDclIsSUFBSSxDQUFDaVksRUFBTixDQUFKLEdBQWdCaGEsS0FBaEI7TUFDTCxPQUFPK0IsSUFBUDtLQWpDYTtJQW1DZnV3QixPQUFPLEVBQUVMO0VBbkNNLENBQWpCOzs7O0lDOUNBLElBQUlNLElBQUksR0FBR2wwQixhQUEyQixDQUFDLENBQUQsQ0FBdEM7SUFPQSxJQUFJbTBCLGVBQWUsR0FBRy9CLG1CQUF0QjtJQUNBLElBQUlnQyxPQUFPLEdBQUcsQ0FBQ2oxQixPQUFNLENBQUNrMUIsYUFBUixJQUF5QixtQkFBbUJsMUIsT0FBMUQ7SUFDQSxJQUFJbTFCLFFBQVEsR0FBRyxTQUFmO0lBQ0EsSUFBSW51QixPQUFPLEdBQUdFLEtBQUksQ0FBQ0YsT0FBbkI7SUFDQSxJQUFJUixZQUFZLEdBQUcxRixNQUFNLENBQUMwRixZQUExQjtJQUNBLElBQUlpdUIsbUJBQW1CLEdBQUdXLGVBQUksQ0FBQ04sT0FBL0I7SUFDQSxJQUFJTyxXQUFKOztJQUVBLElBQUk1RCxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVendCLEdBQVYsRUFBZTtNQUMzQixPQUFPLFNBQVNzMEIsT0FBVCxHQUFtQjtRQUN4QixPQUFPdDBCLEdBQUcsQ0FBQyxJQUFELEVBQU82RCxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBN0MsQ0FBVjtPQURGO0tBREY7O0lBTUEsSUFBSStZLE9BQU8sR0FBRzs7TUFFWm5iLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWFQLEdBQWIsRUFBa0I7UUFDckIsSUFBSVksU0FBUSxDQUFDWixHQUFELENBQVosRUFBbUI7VUFDakIsSUFBSW1WLElBQUksR0FBRzVPLE9BQU8sQ0FBQ3ZHLEdBQUQsQ0FBbEI7VUFDQSxJQUFJbVYsSUFBSSxLQUFLLElBQWIsRUFBbUIsT0FBTzZlLG1CQUFtQixDQUFDeEIsbUJBQVEsQ0FBQyxJQUFELEVBQU9rQyxRQUFQLENBQVQsQ0FBbkIsQ0FBOENuMEIsR0FBOUMsQ0FBa0RQLEdBQWxELENBQVA7VUFDbkIsT0FBT21WLElBQUksR0FBR0EsSUFBSSxDQUFDLEtBQUs0RyxFQUFOLENBQVAsR0FBbUJwWixTQUE5Qjs7T0FOUTs7TUFVWnFMLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWFoTyxHQUFiLEVBQWtCK0IsS0FBbEIsRUFBeUI7UUFDNUIsT0FBTzR5QixlQUFJLENBQUMzdEIsR0FBTCxDQUFTd3JCLG1CQUFRLENBQUMsSUFBRCxFQUFPa0MsUUFBUCxDQUFqQixFQUFtQzEwQixHQUFuQyxFQUF3QytCLEtBQXhDLENBQVA7O0tBWEo7O0lBZ0JBLElBQUkreUIsUUFBUSxHQUFHdDFCLGNBQUEsR0FBaUJ5QixXQUF3QixDQUFDeXpCLFFBQUQsRUFBVzFELE9BQVgsRUFBb0J0VixPQUFwQixFQUE2QmlaLGVBQTdCLEVBQW1DLElBQW5DLEVBQXlDLElBQXpDLENBQXhEOztJQUdBLElBQUlKLGVBQWUsSUFBSUMsT0FBdkIsRUFBZ0M7TUFDOUJJLFdBQVcsR0FBR0QsZUFBSSxDQUFDdkMsY0FBTCxDQUFvQnBCLE9BQXBCLEVBQTZCMEQsUUFBN0IsQ0FBZDtNQUNBMWtCLGFBQU0sQ0FBQzRrQixXQUFXLENBQUMvd0IsU0FBYixFQUF3QjZYLE9BQXhCLENBQU47TUFDQWpWLEtBQUksQ0FBQ0MsSUFBTCxHQUFZLElBQVo7TUFDQTR0QixJQUFJLENBQUMsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixLQUFsQixFQUF5QixLQUF6QixDQUFELEVBQWtDLFVBQVV0MEIsR0FBVixFQUFlO1FBQ25ELElBQUl5USxLQUFLLEdBQUdxa0IsUUFBUSxDQUFDanhCLFNBQXJCO1FBQ0EsSUFBSWtkLE1BQU0sR0FBR3RRLEtBQUssQ0FBQ3pRLEdBQUQsQ0FBbEI7UUFDQXlGLFNBQVEsQ0FBQ2dMLEtBQUQsRUFBUXpRLEdBQVIsRUFBYSxVQUFVUSxDQUFWLEVBQWF5RCxDQUFiLEVBQWdCOztVQUVuQyxJQUFJckQsU0FBUSxDQUFDSixDQUFELENBQVIsSUFBZSxDQUFDdUYsWUFBWSxDQUFDdkYsQ0FBRCxDQUFoQyxFQUFxQztZQUNuQyxJQUFJLENBQUMsS0FBSzJ4QixFQUFWLEVBQWMsS0FBS0EsRUFBTCxHQUFVLElBQUl5QyxXQUFKLEVBQVY7O1lBQ2QsSUFBSTdyQixNQUFNLEdBQUcsS0FBS29wQixFQUFMLENBQVFueUIsR0FBUixFQUFhUSxDQUFiLEVBQWdCeUQsQ0FBaEIsQ0FBYjs7WUFDQSxPQUFPakUsR0FBRyxJQUFJLEtBQVAsR0FBZSxJQUFmLEdBQXNCK0ksTUFBN0IsQ0FIbUM7OztVQUtuQyxPQUFPZ1ksTUFBTSxDQUFDOWdCLElBQVAsQ0FBWSxJQUFaLEVBQWtCTyxDQUFsQixFQUFxQnlELENBQXJCLENBQVA7U0FQSSxDQUFSO09BSEUsQ0FBSjs7OztFQzNDRixJQUFJOHdCLFFBQVEsR0FBRyxTQUFmOztBQUdBMzBCLGFBQXdCLENBQUMyMEIsUUFBRCxFQUFXLFVBQVV4MEIsR0FBVixFQUFlO0lBQ2hELE9BQU8sU0FBU3kwQixPQUFULEdBQW1CO01BQUUsT0FBT3owQixHQUFHLENBQUMsSUFBRCxFQUFPNkQsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQTdDLENBQVY7S0FBNUI7RUFDRCxDQUZ1QixFQUVyQjs7SUFFRHF3QixHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhanhCLEtBQWIsRUFBb0I7TUFDdkIsT0FBTzR5QixlQUFJLENBQUMzdEIsR0FBTCxDQUFTd3JCLG1CQUFRLENBQUMsSUFBRCxFQUFPdUMsUUFBUCxDQUFqQixFQUFtQ2h6QixLQUFuQyxFQUEwQyxJQUExQyxDQUFQOztFQUhELENBRnFCLEVBT3JCNHlCLGVBUHFCLEVBT2YsS0FQZSxFQU9SLElBUFEsQ0FBeEI7O0VDSEEsSUFBSU0sS0FBSyxHQUFHbHVCLElBQUcsQ0FBQyxhQUFELENBQWY7RUFDQSxJQUFJbXVCLElBQUksR0FBR251QixJQUFHLENBQUMsTUFBRCxDQUFkO0VBQ0EsSUFBSW91QixHQUFHLEdBQUcsQ0FBQyxFQUFFNTFCLE9BQU0sQ0FBQzYxQixXQUFQLElBQXNCNzFCLE9BQU0sQ0FBQzgxQixRQUEvQixDQUFYO0VBQ0EsSUFBSUMsTUFBTSxHQUFHSCxHQUFiO0VBQ0EsSUFBSWh2QixHQUFDLEdBQUcsQ0FBUjtFQUNBLElBQUlvSCxDQUFDLEdBQUcsQ0FBUjtFQUNBLElBQUlnb0IsS0FBSjtFQUVBLElBQUlDLHNCQUFzQixHQUN4QixnSEFEMkIsQ0FFM0JueUIsS0FGMkIsQ0FFckIsR0FGcUIsQ0FBN0I7O0VBSUEsT0FBTzhDLEdBQUMsR0FBR29ILENBQVgsRUFBYztJQUNaLElBQUlnb0IsS0FBSyxHQUFHaDJCLE9BQU0sQ0FBQ2kyQixzQkFBc0IsQ0FBQ3J2QixHQUFDLEVBQUYsQ0FBdkIsQ0FBbEIsRUFBaUQ7TUFDL0N6QyxLQUFJLENBQUM2eEIsS0FBSyxDQUFDMXhCLFNBQVAsRUFBa0JveEIsS0FBbEIsRUFBeUIsSUFBekIsQ0FBSjtNQUNBdnhCLEtBQUksQ0FBQzZ4QixLQUFLLENBQUMxeEIsU0FBUCxFQUFrQnF4QixJQUFsQixFQUF3QixJQUF4QixDQUFKO0tBRkYsTUFHT0ksTUFBTSxHQUFHLEtBQVQ7RUFDUjs7RUFFRCxVQUFjLEdBQUc7SUFDZkgsR0FBRyxFQUFFQSxHQURVO0lBRWZHLE1BQU0sRUFBRUEsTUFGTztJQUdmTCxLQUFLLEVBQUVBLEtBSFE7SUFJZkMsSUFBSSxFQUFFQTtFQUpTLENBQWpCOztFQ25CQSxZQUFjLEdBQUcsaUJBQUEsQ0FBVW4xQixFQUFWLEVBQWM7SUFDN0IsSUFBSUEsRUFBRSxLQUFLNEMsU0FBWCxFQUFzQixPQUFPLENBQVA7SUFDdEIsSUFBSWdVLE1BQU0sR0FBRzFPLFVBQVMsQ0FBQ2xJLEVBQUQsQ0FBdEI7SUFDQSxJQUFJZ0UsTUFBTSxHQUFHMEUsU0FBUSxDQUFDa08sTUFBRCxDQUFyQjtJQUNBLElBQUlBLE1BQU0sS0FBSzVTLE1BQWYsRUFBdUIsTUFBTWlSLFVBQVUsQ0FBQyxlQUFELENBQWhCO0lBQ3ZCLE9BQU9qUixNQUFQO0VBQ0QsQ0FORDs7OztJQ1NBLElBQUlrSCxJQUFJLEdBQUc3SyxXQUF5QixDQUFDaUMsQ0FBckM7SUFDQSxJQUFJYixFQUFFLEdBQUdQLFNBQXVCLENBQUNvQixDQUFqQztJQUdBLElBQUlvekIsWUFBWSxHQUFHLGFBQW5CO0lBQ0EsSUFBSUMsU0FBUyxHQUFHLFVBQWhCO0lBQ0EsSUFBSXJ4QixTQUFTLEdBQUcsV0FBaEI7SUFDQSxJQUFJc3hCLFlBQVksR0FBRyxlQUFuQjtJQUNBLElBQUlDLFdBQVcsR0FBRyxjQUFsQjtJQUNBLElBQUlDLFlBQVksR0FBR3QyQixPQUFNLENBQUNrMkIsWUFBRCxDQUF6QjtJQUNBLElBQUlLLFNBQVMsR0FBR3YyQixPQUFNLENBQUNtMkIsU0FBRCxDQUF0QjtJQUNBLElBQUloMkIsSUFBSSxHQUFHSCxPQUFNLENBQUNHLElBQWxCO0lBQ0EsSUFBSXNWLFVBQVUsR0FBR3pWLE9BQU0sQ0FBQ3lWLFVBQXhCOztJQUVBLElBQUl4QixRQUFRLEdBQUdqVSxPQUFNLENBQUNpVSxRQUF0QjtJQUNBLElBQUl1aUIsVUFBVSxHQUFHRixZQUFqQjtJQUNBLElBQUlqZixHQUFHLEdBQUdsWCxJQUFJLENBQUNrWCxHQUFmO0lBQ0EsSUFBSWhCLEdBQUcsR0FBR2xXLElBQUksQ0FBQ2tXLEdBQWY7SUFDQSxJQUFJOU4sS0FBSyxHQUFHcEksSUFBSSxDQUFDb0ksS0FBakI7SUFDQSxJQUFJZ08sR0FBRyxHQUFHcFcsSUFBSSxDQUFDb1csR0FBZjtJQUNBLElBQUl1QixHQUFHLEdBQUczWCxJQUFJLENBQUMyWCxHQUFmO0lBQ0EsSUFBSTJlLE1BQU0sR0FBRyxRQUFiO0lBQ0EsSUFBSUMsV0FBVyxHQUFHLFlBQWxCO0lBQ0EsSUFBSUMsV0FBVyxHQUFHLFlBQWxCO0lBQ0EsSUFBSUMsT0FBTyxHQUFHenBCLFlBQVcsR0FBRyxJQUFILEdBQVVzcEIsTUFBbkM7SUFDQSxJQUFJSSxPQUFPLEdBQUcxcEIsWUFBVyxHQUFHLElBQUgsR0FBVXVwQixXQUFuQztJQUNBLElBQUlJLE9BQU8sR0FBRzNwQixZQUFXLEdBQUcsSUFBSCxHQUFVd3BCLFdBQW5DOztJQUdBLFNBQVNJLFdBQVQsQ0FBcUJ2MEIsS0FBckIsRUFBNEJ3MEIsSUFBNUIsRUFBa0NDLE1BQWxDLEVBQTBDO01BQ3hDLElBQUlDLE1BQU0sR0FBRyxJQUFJL3NCLEtBQUosQ0FBVThzQixNQUFWLENBQWI7TUFDQSxJQUFJRSxJQUFJLEdBQUdGLE1BQU0sR0FBRyxDQUFULEdBQWFELElBQWIsR0FBb0IsQ0FBL0I7TUFDQSxJQUFJSSxJQUFJLEdBQUcsQ0FBQyxLQUFLRCxJQUFOLElBQWMsQ0FBekI7TUFDQSxJQUFJRSxLQUFLLEdBQUdELElBQUksSUFBSSxDQUFwQjtNQUNBLElBQUlFLEVBQUUsR0FBR04sSUFBSSxLQUFLLEVBQVQsR0FBYzNnQixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUMsRUFBTCxDQUFILEdBQWNBLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBQyxFQUFMLENBQS9CLEdBQTBDLENBQW5EO01BQ0EsSUFBSXpQLENBQUMsR0FBRyxDQUFSO01BQ0EsSUFBSXVQLENBQUMsR0FBRzNULEtBQUssR0FBRyxDQUFSLElBQWFBLEtBQUssS0FBSyxDQUFWLElBQWUsSUFBSUEsS0FBSixHQUFZLENBQXhDLEdBQTRDLENBQTVDLEdBQWdELENBQXhEO01BQ0EsSUFBSTVCLENBQUosRUFBTytWLENBQVAsRUFBVWhTLENBQVY7TUFDQW5DLEtBQUssR0FBRzZVLEdBQUcsQ0FBQzdVLEtBQUQsQ0FBWCxDQVR3Qzs7TUFXeEMsSUFBSUEsS0FBSyxJQUFJQSxLQUFULElBQWtCQSxLQUFLLEtBQUt5UixRQUFoQyxFQUEwQzs7UUFFeEMwQyxDQUFDLEdBQUduVSxLQUFLLElBQUlBLEtBQVQsR0FBaUIsQ0FBakIsR0FBcUIsQ0FBekI7UUFDQTVCLENBQUMsR0FBR3cyQixJQUFKO09BSEYsTUFJTztRQUNMeDJCLENBQUMsR0FBRzJILEtBQUssQ0FBQ2dPLEdBQUcsQ0FBQy9ULEtBQUQsQ0FBSCxHQUFhc1YsR0FBZCxDQUFUOztRQUNBLElBQUl0VixLQUFLLElBQUltQyxDQUFDLEdBQUcwUixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUN6VixDQUFMLENBQVgsQ0FBTCxHQUEyQixDQUEvQixFQUFrQztVQUNoQ0EsQ0FBQztVQUNEK0QsQ0FBQyxJQUFJLENBQUw7OztRQUVGLElBQUkvRCxDQUFDLEdBQUd5MkIsS0FBSixJQUFhLENBQWpCLEVBQW9CO1VBQ2xCNzBCLEtBQUssSUFBSTgwQixFQUFFLEdBQUczeUIsQ0FBZDtTQURGLE1BRU87VUFDTG5DLEtBQUssSUFBSTgwQixFQUFFLEdBQUdqaEIsR0FBRyxDQUFDLENBQUQsRUFBSSxJQUFJZ2hCLEtBQVIsQ0FBakI7OztRQUVGLElBQUk3MEIsS0FBSyxHQUFHbUMsQ0FBUixJQUFhLENBQWpCLEVBQW9CO1VBQ2xCL0QsQ0FBQztVQUNEK0QsQ0FBQyxJQUFJLENBQUw7OztRQUVGLElBQUkvRCxDQUFDLEdBQUd5MkIsS0FBSixJQUFhRCxJQUFqQixFQUF1QjtVQUNyQnpnQixDQUFDLEdBQUcsQ0FBSjtVQUNBL1YsQ0FBQyxHQUFHdzJCLElBQUo7U0FGRixNQUdPLElBQUl4MkIsQ0FBQyxHQUFHeTJCLEtBQUosSUFBYSxDQUFqQixFQUFvQjtVQUN6QjFnQixDQUFDLEdBQUcsQ0FBQ25VLEtBQUssR0FBR21DLENBQVIsR0FBWSxDQUFiLElBQWtCMFIsR0FBRyxDQUFDLENBQUQsRUFBSTJnQixJQUFKLENBQXpCO1VBQ0FwMkIsQ0FBQyxHQUFHQSxDQUFDLEdBQUd5MkIsS0FBUjtTQUZLLE1BR0E7VUFDTDFnQixDQUFDLEdBQUduVSxLQUFLLEdBQUc2VCxHQUFHLENBQUMsQ0FBRCxFQUFJZ2hCLEtBQUssR0FBRyxDQUFaLENBQVgsR0FBNEJoaEIsR0FBRyxDQUFDLENBQUQsRUFBSTJnQixJQUFKLENBQW5DO1VBQ0FwMkIsQ0FBQyxHQUFHLENBQUo7Ozs7TUFHSixPQUFPbzJCLElBQUksSUFBSSxDQUFmLEVBQWtCRSxNQUFNLENBQUN0d0IsQ0FBQyxFQUFGLENBQU4sR0FBYytQLENBQUMsR0FBRyxHQUFsQixFQUF1QkEsQ0FBQyxJQUFJLEdBQTVCLEVBQWlDcWdCLElBQUksSUFBSSxDQUEzRDs7O01BQ0FwMkIsQ0FBQyxHQUFHQSxDQUFDLElBQUlvMkIsSUFBTCxHQUFZcmdCLENBQWhCO01BQ0F3Z0IsSUFBSSxJQUFJSCxJQUFSOztNQUNBLE9BQU9HLElBQUksR0FBRyxDQUFkLEVBQWlCRCxNQUFNLENBQUN0d0IsQ0FBQyxFQUFGLENBQU4sR0FBY2hHLENBQUMsR0FBRyxHQUFsQixFQUF1QkEsQ0FBQyxJQUFJLEdBQTVCLEVBQWlDdTJCLElBQUksSUFBSSxDQUExRDs7O01BQ0FELE1BQU0sQ0FBQyxFQUFFdHdCLENBQUgsQ0FBTixJQUFldVAsQ0FBQyxHQUFHLEdBQW5CO01BQ0EsT0FBTytnQixNQUFQOzs7SUFFRixTQUFTSyxhQUFULENBQXVCTCxNQUF2QixFQUErQkYsSUFBL0IsRUFBcUNDLE1BQXJDLEVBQTZDO01BQzNDLElBQUlFLElBQUksR0FBR0YsTUFBTSxHQUFHLENBQVQsR0FBYUQsSUFBYixHQUFvQixDQUEvQjtNQUNBLElBQUlJLElBQUksR0FBRyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtNQUNBLElBQUlFLEtBQUssR0FBR0QsSUFBSSxJQUFJLENBQXBCO01BQ0EsSUFBSUksS0FBSyxHQUFHTCxJQUFJLEdBQUcsQ0FBbkI7TUFDQSxJQUFJdndCLENBQUMsR0FBR3F3QixNQUFNLEdBQUcsQ0FBakI7TUFDQSxJQUFJOWdCLENBQUMsR0FBRytnQixNQUFNLENBQUN0d0IsQ0FBQyxFQUFGLENBQWQ7TUFDQSxJQUFJaEcsQ0FBQyxHQUFHdVYsQ0FBQyxHQUFHLEdBQVo7TUFDQSxJQUFJUSxDQUFKO01BQ0FSLENBQUMsS0FBSyxDQUFOOztNQUNBLE9BQU9xaEIsS0FBSyxHQUFHLENBQWYsRUFBa0I1MkIsQ0FBQyxHQUFHQSxDQUFDLEdBQUcsR0FBSixHQUFVczJCLE1BQU0sQ0FBQ3R3QixDQUFELENBQXBCLEVBQXlCQSxDQUFDLEVBQTFCLEVBQThCNHdCLEtBQUssSUFBSSxDQUF6RDs7O01BQ0E3Z0IsQ0FBQyxHQUFHL1YsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDNDJCLEtBQVAsSUFBZ0IsQ0FBeEI7TUFDQTUyQixDQUFDLEtBQUssQ0FBQzQyQixLQUFQO01BQ0FBLEtBQUssSUFBSVIsSUFBVDs7TUFDQSxPQUFPUSxLQUFLLEdBQUcsQ0FBZixFQUFrQjdnQixDQUFDLEdBQUdBLENBQUMsR0FBRyxHQUFKLEdBQVV1Z0IsTUFBTSxDQUFDdHdCLENBQUQsQ0FBcEIsRUFBeUJBLENBQUMsRUFBMUIsRUFBOEI0d0IsS0FBSyxJQUFJLENBQXpEOzs7TUFDQSxJQUFJNTJCLENBQUMsS0FBSyxDQUFWLEVBQWE7UUFDWEEsQ0FBQyxHQUFHLElBQUl5MkIsS0FBUjtPQURGLE1BRU8sSUFBSXoyQixDQUFDLEtBQUt3MkIsSUFBVixFQUFnQjtRQUNyQixPQUFPemdCLENBQUMsR0FBRzdCLEdBQUgsR0FBU3FCLENBQUMsR0FBRyxDQUFDbEMsUUFBSixHQUFlQSxRQUFqQztPQURLLE1BRUE7UUFDTDBDLENBQUMsR0FBR0EsQ0FBQyxHQUFHTixHQUFHLENBQUMsQ0FBRCxFQUFJMmdCLElBQUosQ0FBWDtRQUNBcDJCLENBQUMsR0FBR0EsQ0FBQyxHQUFHeTJCLEtBQVI7OztNQUNBLE9BQU8sQ0FBQ2xoQixDQUFDLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBVixJQUFlUSxDQUFmLEdBQW1CTixHQUFHLENBQUMsQ0FBRCxFQUFJelYsQ0FBQyxHQUFHbzJCLElBQVIsQ0FBN0I7OztJQUdKLFNBQVNTLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO01BQ3hCLE9BQU9BLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxFQUFaLEdBQWlCQSxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVksRUFBN0IsR0FBa0NBLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxDQUE5QyxHQUFrREEsS0FBSyxDQUFDLENBQUQsQ0FBOUQ7OztJQUVGLFNBQVNDLE1BQVQsQ0FBZ0JuM0IsRUFBaEIsRUFBb0I7TUFDbEIsT0FBTyxDQUFDQSxFQUFFLEdBQUcsSUFBTixDQUFQOzs7SUFFRixTQUFTbzNCLE9BQVQsQ0FBaUJwM0IsRUFBakIsRUFBcUI7TUFDbkIsT0FBTyxDQUFDQSxFQUFFLEdBQUcsSUFBTixFQUFZQSxFQUFFLElBQUksQ0FBTixHQUFVLElBQXRCLENBQVA7OztJQUVGLFNBQVNxM0IsT0FBVCxDQUFpQnIzQixFQUFqQixFQUFxQjtNQUNuQixPQUFPLENBQUNBLEVBQUUsR0FBRyxJQUFOLEVBQVlBLEVBQUUsSUFBSSxDQUFOLEdBQVUsSUFBdEIsRUFBNEJBLEVBQUUsSUFBSSxFQUFOLEdBQVcsSUFBdkMsRUFBNkNBLEVBQUUsSUFBSSxFQUFOLEdBQVcsSUFBeEQsQ0FBUDs7O0lBRUYsU0FBU3MzQixPQUFULENBQWlCdDNCLEVBQWpCLEVBQXFCO01BQ25CLE9BQU91MkIsV0FBVyxDQUFDdjJCLEVBQUQsRUFBSyxFQUFMLEVBQVMsQ0FBVCxDQUFsQjs7O0lBRUYsU0FBU3UzQixPQUFULENBQWlCdjNCLEVBQWpCLEVBQXFCO01BQ25CLE9BQU91MkIsV0FBVyxDQUFDdjJCLEVBQUQsRUFBSyxFQUFMLEVBQVMsQ0FBVCxDQUFsQjs7O0lBR0YsU0FBU3czQixTQUFULENBQW1COWpCLENBQW5CLEVBQXNCelQsR0FBdEIsRUFBMkJ3M0IsUUFBM0IsRUFBcUM7TUFDbkNoMkIsRUFBRSxDQUFDaVMsQ0FBQyxDQUFDcFAsU0FBRCxDQUFGLEVBQWVyRSxHQUFmLEVBQW9CO1FBQUVPLEdBQUcsRUFBRSxlQUFZO1VBQUUsT0FBTyxLQUFLaTNCLFFBQUwsQ0FBUDs7T0FBekMsQ0FBRjs7O0lBR0YsU0FBU2ozQixHQUFULENBQWFrM0IsSUFBYixFQUFtQlIsS0FBbkIsRUFBMEI5dUIsS0FBMUIsRUFBaUN1dkIsY0FBakMsRUFBaUQ7TUFDL0MsSUFBSUMsUUFBUSxHQUFHLENBQUN4dkIsS0FBaEI7TUFDQSxJQUFJeXZCLFFBQVEsR0FBR0MsUUFBTyxDQUFDRixRQUFELENBQXRCO01BQ0EsSUFBSUMsUUFBUSxHQUFHWCxLQUFYLEdBQW1CUSxJQUFJLENBQUNyQixPQUFELENBQTNCLEVBQXNDLE1BQU1waEIsVUFBVSxDQUFDNGdCLFdBQUQsQ0FBaEI7TUFDdEMsSUFBSS95QixLQUFLLEdBQUc0MEIsSUFBSSxDQUFDdEIsT0FBRCxDQUFKLENBQWMyQixFQUExQjtNQUNBLElBQUl6VyxLQUFLLEdBQUd1VyxRQUFRLEdBQUdILElBQUksQ0FBQ3BCLE9BQUQsQ0FBM0I7TUFDQSxJQUFJMEIsSUFBSSxHQUFHbDFCLEtBQUssQ0FBQzJFLEtBQU4sQ0FBWTZaLEtBQVosRUFBbUJBLEtBQUssR0FBRzRWLEtBQTNCLENBQVg7TUFDQSxPQUFPUyxjQUFjLEdBQUdLLElBQUgsR0FBVUEsSUFBSSxDQUFDQyxPQUFMLEVBQS9COzs7SUFFRixTQUFTaHFCLEdBQVQsQ0FBYXlwQixJQUFiLEVBQW1CUixLQUFuQixFQUEwQjl1QixLQUExQixFQUFpQzh2QixVQUFqQyxFQUE2Q2wyQixLQUE3QyxFQUFvRDIxQixjQUFwRCxFQUFvRTtNQUNsRSxJQUFJQyxRQUFRLEdBQUcsQ0FBQ3h2QixLQUFoQjtNQUNBLElBQUl5dkIsUUFBUSxHQUFHQyxRQUFPLENBQUNGLFFBQUQsQ0FBdEI7TUFDQSxJQUFJQyxRQUFRLEdBQUdYLEtBQVgsR0FBbUJRLElBQUksQ0FBQ3JCLE9BQUQsQ0FBM0IsRUFBc0MsTUFBTXBoQixVQUFVLENBQUM0Z0IsV0FBRCxDQUFoQjtNQUN0QyxJQUFJL3lCLEtBQUssR0FBRzQwQixJQUFJLENBQUN0QixPQUFELENBQUosQ0FBYzJCLEVBQTFCO01BQ0EsSUFBSXpXLEtBQUssR0FBR3VXLFFBQVEsR0FBR0gsSUFBSSxDQUFDcEIsT0FBRCxDQUEzQjtNQUNBLElBQUkwQixJQUFJLEdBQUdFLFVBQVUsQ0FBQyxDQUFDbDJCLEtBQUYsQ0FBckI7O01BQ0EsS0FBSyxJQUFJb0UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzh3QixLQUFwQixFQUEyQjl3QixDQUFDLEVBQTVCO1FBQWdDdEQsS0FBSyxDQUFDd2UsS0FBSyxHQUFHbGIsQ0FBVCxDQUFMLEdBQW1CNHhCLElBQUksQ0FBQ0wsY0FBYyxHQUFHdnhCLENBQUgsR0FBTzh3QixLQUFLLEdBQUc5d0IsQ0FBUixHQUFZLENBQWxDLENBQXZCOzs7O0lBR2xDLElBQUksQ0FBQyt4QixNQUFNLENBQUMvQyxHQUFaLEVBQWlCO01BQ2ZVLFlBQVksR0FBRyxTQUFTVCxXQUFULENBQXFCcnhCLE1BQXJCLEVBQTZCO1FBQzFDbXRCLFdBQVUsQ0FBQyxJQUFELEVBQU8yRSxZQUFQLEVBQXFCSixZQUFyQixDQUFWO1FBQ0EsSUFBSTBDLFVBQVUsR0FBR04sUUFBTyxDQUFDOXpCLE1BQUQsQ0FBeEI7UUFDQSxLQUFLK3pCLEVBQUwsR0FBVU0sVUFBUyxDQUFDbjRCLElBQVYsQ0FBZSxJQUFJeUosS0FBSixDQUFVeXVCLFVBQVYsQ0FBZixFQUFzQyxDQUF0QyxDQUFWO1FBQ0EsS0FBSy9CLE9BQUwsSUFBZ0IrQixVQUFoQjtPQUpGOztNQU9BckMsU0FBUyxHQUFHLFNBQVNULFFBQVQsQ0FBa0JvQixNQUFsQixFQUEwQjRCLFVBQTFCLEVBQXNDRixVQUF0QyxFQUFrRDtRQUM1RGpILFdBQVUsQ0FBQyxJQUFELEVBQU80RSxTQUFQLEVBQWtCSixTQUFsQixDQUFWO1FBQ0F4RSxXQUFVLENBQUN1RixNQUFELEVBQVNaLFlBQVQsRUFBdUJILFNBQXZCLENBQVY7UUFDQSxJQUFJNEMsWUFBWSxHQUFHN0IsTUFBTSxDQUFDTCxPQUFELENBQXpCO1FBQ0EsSUFBSW1DLE1BQU0sR0FBR3R3QixVQUFTLENBQUNvd0IsVUFBRCxDQUF0QjtRQUNBLElBQUlFLE1BQU0sR0FBRyxDQUFULElBQWNBLE1BQU0sR0FBR0QsWUFBM0IsRUFBeUMsTUFBTXRqQixVQUFVLENBQUMsZUFBRCxDQUFoQjtRQUN6Q21qQixVQUFVLEdBQUdBLFVBQVUsS0FBS3gxQixTQUFmLEdBQTJCMjFCLFlBQVksR0FBR0MsTUFBMUMsR0FBbUQ5dkIsU0FBUSxDQUFDMHZCLFVBQUQsQ0FBeEU7UUFDQSxJQUFJSSxNQUFNLEdBQUdKLFVBQVQsR0FBc0JHLFlBQTFCLEVBQXdDLE1BQU10akIsVUFBVSxDQUFDMmdCLFlBQUQsQ0FBaEI7UUFDeEMsS0FBS1EsT0FBTCxJQUFnQk0sTUFBaEI7UUFDQSxLQUFLSixPQUFMLElBQWdCa0MsTUFBaEI7UUFDQSxLQUFLbkMsT0FBTCxJQUFnQitCLFVBQWhCO09BVkY7O01BYUEsSUFBSXpyQixZQUFKLEVBQWlCO1FBQ2Y2cUIsU0FBUyxDQUFDMUIsWUFBRCxFQUFlSSxXQUFmLEVBQTRCLElBQTVCLENBQVQ7UUFDQXNCLFNBQVMsQ0FBQ3pCLFNBQUQsRUFBWUUsTUFBWixFQUFvQixJQUFwQixDQUFUO1FBQ0F1QixTQUFTLENBQUN6QixTQUFELEVBQVlHLFdBQVosRUFBeUIsSUFBekIsQ0FBVDtRQUNBc0IsU0FBUyxDQUFDekIsU0FBRCxFQUFZSSxXQUFaLEVBQXlCLElBQXpCLENBQVQ7OztNQUdGM0QsWUFBVyxDQUFDdUQsU0FBUyxDQUFDenhCLFNBQUQsQ0FBVixFQUF1QjtRQUNoQ20wQixPQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFpQkgsVUFBakIsRUFBNkI7VUFDcEMsT0FBTzkzQixHQUFHLENBQUMsSUFBRCxFQUFPLENBQVAsRUFBVTgzQixVQUFWLENBQUgsQ0FBeUIsQ0FBekIsS0FBK0IsRUFBL0IsSUFBcUMsRUFBNUM7U0FGOEI7UUFJaENJLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCSixVQUFsQixFQUE4QjtVQUN0QyxPQUFPOTNCLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVODNCLFVBQVYsQ0FBSCxDQUF5QixDQUF6QixDQUFQO1NBTDhCO1FBT2hDSyxRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQkw7O1VBQWlDO1VBQzNELElBQUlwQixLQUFLLEdBQUcxMkIsR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVU4M0IsVUFBVixFQUFzQmowQixTQUFTLENBQUMsQ0FBRCxDQUEvQixDQUFmO1VBQ0EsT0FBTyxDQUFDNnlCLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxDQUFaLEdBQWdCQSxLQUFLLENBQUMsQ0FBRCxDQUF0QixLQUE4QixFQUE5QixJQUFvQyxFQUEzQztTQVQ4QjtRQVdoQzBCLFNBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CTjs7VUFBaUM7VUFDN0QsSUFBSXBCLEtBQUssR0FBRzEyQixHQUFHLENBQUMsSUFBRCxFQUFPLENBQVAsRUFBVTgzQixVQUFWLEVBQXNCajBCLFNBQVMsQ0FBQyxDQUFELENBQS9CLENBQWY7VUFDQSxPQUFPNnlCLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxDQUFaLEdBQWdCQSxLQUFLLENBQUMsQ0FBRCxDQUE1QjtTQWI4QjtRQWVoQzJCLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCUDs7VUFBaUM7VUFDM0QsT0FBT3JCLFNBQVMsQ0FBQ3oyQixHQUFHLENBQUMsSUFBRCxFQUFPLENBQVAsRUFBVTgzQixVQUFWLEVBQXNCajBCLFNBQVMsQ0FBQyxDQUFELENBQS9CLENBQUosQ0FBaEI7U0FoQjhCO1FBa0JoQ3kwQixTQUFTLEVBQUUsU0FBU0EsU0FBVCxDQUFtQlI7O1VBQWlDO1VBQzdELE9BQU9yQixTQUFTLENBQUN6MkIsR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVU4M0IsVUFBVixFQUFzQmowQixTQUFTLENBQUMsQ0FBRCxDQUEvQixDQUFKLENBQVQsS0FBc0QsQ0FBN0Q7U0FuQjhCO1FBcUJoQzAwQixVQUFVLEVBQUUsU0FBU0EsVUFBVCxDQUFvQlQ7O1VBQWlDO1VBQy9ELE9BQU92QixhQUFhLENBQUN2MkIsR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVU4M0IsVUFBVixFQUFzQmowQixTQUFTLENBQUMsQ0FBRCxDQUEvQixDQUFKLEVBQXlDLEVBQXpDLEVBQTZDLENBQTdDLENBQXBCO1NBdEI4QjtRQXdCaEMyMEIsVUFBVSxFQUFFLFNBQVNBLFVBQVQsQ0FBb0JWOztVQUFpQztVQUMvRCxPQUFPdkIsYUFBYSxDQUFDdjJCLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVODNCLFVBQVYsRUFBc0JqMEIsU0FBUyxDQUFDLENBQUQsQ0FBL0IsQ0FBSixFQUF5QyxFQUF6QyxFQUE2QyxDQUE3QyxDQUFwQjtTQXpCOEI7UUEyQmhDNDBCLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCWCxVQUFqQixFQUE2QnQyQixLQUE3QixFQUFvQztVQUMzQ2lNLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVcXFCLFVBQVYsRUFBc0JuQixNQUF0QixFQUE4Qm4xQixLQUE5QixDQUFIO1NBNUI4QjtRQThCaENrM0IsUUFBUSxFQUFFLFNBQVNBLFFBQVQsQ0FBa0JaLFVBQWxCLEVBQThCdDJCLEtBQTlCLEVBQXFDO1VBQzdDaU0sR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVVxcUIsVUFBVixFQUFzQm5CLE1BQXRCLEVBQThCbjFCLEtBQTlCLENBQUg7U0EvQjhCO1FBaUNoQ20zQixRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQmIsVUFBbEIsRUFBOEJ0MkI7O1VBQTRCO1VBQ2xFaU0sR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVVxcUIsVUFBVixFQUFzQmxCLE9BQXRCLEVBQStCcDFCLEtBQS9CLEVBQXNDcUMsU0FBUyxDQUFDLENBQUQsQ0FBL0MsQ0FBSDtTQWxDOEI7UUFvQ2hDKzBCLFNBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CZCxVQUFuQixFQUErQnQyQjs7VUFBNEI7VUFDcEVpTSxHQUFHLENBQUMsSUFBRCxFQUFPLENBQVAsRUFBVXFxQixVQUFWLEVBQXNCbEIsT0FBdEIsRUFBK0JwMUIsS0FBL0IsRUFBc0NxQyxTQUFTLENBQUMsQ0FBRCxDQUEvQyxDQUFIO1NBckM4QjtRQXVDaENnMUIsUUFBUSxFQUFFLFNBQVNBLFFBQVQsQ0FBa0JmLFVBQWxCLEVBQThCdDJCOztVQUE0QjtVQUNsRWlNLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVcXFCLFVBQVYsRUFBc0JqQixPQUF0QixFQUErQnIxQixLQUEvQixFQUFzQ3FDLFNBQVMsQ0FBQyxDQUFELENBQS9DLENBQUg7U0F4QzhCO1FBMENoQ2kxQixTQUFTLEVBQUUsU0FBU0EsU0FBVCxDQUFtQmhCLFVBQW5CLEVBQStCdDJCOztVQUE0QjtVQUNwRWlNLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVcXFCLFVBQVYsRUFBc0JqQixPQUF0QixFQUErQnIxQixLQUEvQixFQUFzQ3FDLFNBQVMsQ0FBQyxDQUFELENBQS9DLENBQUg7U0EzQzhCO1FBNkNoQ2sxQixVQUFVLEVBQUUsU0FBU0EsVUFBVCxDQUFvQmpCLFVBQXBCLEVBQWdDdDJCOztVQUE0QjtVQUN0RWlNLEdBQUcsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVcXFCLFVBQVYsRUFBc0JmLE9BQXRCLEVBQStCdjFCLEtBQS9CLEVBQXNDcUMsU0FBUyxDQUFDLENBQUQsQ0FBL0MsQ0FBSDtTQTlDOEI7UUFnRGhDbTFCLFVBQVUsRUFBRSxTQUFTQSxVQUFULENBQW9CbEIsVUFBcEIsRUFBZ0N0MkI7O1VBQTRCO1VBQ3RFaU0sR0FBRyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVVxcUIsVUFBVixFQUFzQmhCLE9BQXRCLEVBQStCdDFCLEtBQS9CLEVBQXNDcUMsU0FBUyxDQUFDLENBQUQsQ0FBL0MsQ0FBSDs7T0FqRE8sQ0FBWDtLQTVCRixNQWdGTztNQUNMLElBQUksQ0FBQzZLLE1BQUssQ0FBQyxZQUFZO1FBQ3JCNG1CLFlBQVksQ0FBQyxDQUFELENBQVo7T0FEUSxDQUFOLElBRUUsQ0FBQzVtQixNQUFLLENBQUMsWUFBWTtRQUN2QixJQUFJNG1CLFlBQUosQ0FBaUIsQ0FBQyxDQUFsQixFQUR1QjtPQUFiLENBRlIsSUFJRTVtQixNQUFLLENBQUMsWUFBWTtRQUN0QixJQUFJNG1CLFlBQUosR0FEc0I7O1FBRXRCLElBQUlBLFlBQUosQ0FBaUIsR0FBakIsRUFGc0I7O1FBR3RCLElBQUlBLFlBQUosQ0FBaUJ4aEIsR0FBakIsRUFIc0I7O1FBSXRCLE9BQU93aEIsWUFBWSxDQUFDcnhCLElBQWIsSUFBcUJpeEIsWUFBNUI7T0FKUyxDQUpYLEVBU0k7UUFDRkksWUFBWSxHQUFHLFNBQVNULFdBQVQsQ0FBcUJyeEIsTUFBckIsRUFBNkI7VUFDMUNtdEIsV0FBVSxDQUFDLElBQUQsRUFBTzJFLFlBQVAsQ0FBVjtVQUNBLE9BQU8sSUFBSUUsVUFBSixDQUFlOEIsUUFBTyxDQUFDOXpCLE1BQUQsQ0FBdEIsQ0FBUDtTQUZGOztRQUlBLElBQUl5MUIsZ0JBQWdCLEdBQUczRCxZQUFZLENBQUN4eEIsU0FBRCxDQUFaLEdBQTBCMHhCLFVBQVUsQ0FBQzF4QixTQUFELENBQTNEOztRQUNBLEtBQUssSUFBSTJFLElBQUksR0FBR2lDLElBQUksQ0FBQzhxQixVQUFELENBQWYsRUFBNkI1bkIsQ0FBQyxHQUFHLENBQWpDLEVBQW9Dbk8sR0FBekMsRUFBOENnSixJQUFJLENBQUNqRixNQUFMLEdBQWNvSyxDQUE1RCxHQUFnRTtVQUM5RCxJQUFJLEVBQUUsQ0FBQ25PLEdBQUcsR0FBR2dKLElBQUksQ0FBQ21GLENBQUMsRUFBRixDQUFYLEtBQXFCMG5CLFlBQXZCLENBQUosRUFBMENueUIsS0FBSSxDQUFDbXlCLFlBQUQsRUFBZTcxQixHQUFmLEVBQW9CKzFCLFVBQVUsQ0FBQy8xQixHQUFELENBQTlCLENBQUo7OztRQUU1QyxBQUFjdzVCLGdCQUFnQixDQUFDcnFCLFdBQWpCLEdBQStCMG1CLFlBQS9CO09BbkJYOzs7TUFzQkwsSUFBSTRCLElBQUksR0FBRyxJQUFJM0IsU0FBSixDQUFjLElBQUlELFlBQUosQ0FBaUIsQ0FBakIsQ0FBZCxDQUFYO01BQ0EsSUFBSTRELFFBQVEsR0FBRzNELFNBQVMsQ0FBQ3p4QixTQUFELENBQVQsQ0FBcUIyMEIsT0FBcEM7TUFDQXZCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYSxDQUFiLEVBQWdCLFVBQWhCO01BQ0F2QixJQUFJLENBQUN1QixPQUFMLENBQWEsQ0FBYixFQUFnQixVQUFoQjtNQUNBLElBQUl2QixJQUFJLENBQUNlLE9BQUwsQ0FBYSxDQUFiLEtBQW1CLENBQUNmLElBQUksQ0FBQ2UsT0FBTCxDQUFhLENBQWIsQ0FBeEIsRUFBeUNqRyxZQUFXLENBQUN1RCxTQUFTLENBQUN6eEIsU0FBRCxDQUFWLEVBQXVCO1FBQ3pFMjBCLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCWCxVQUFqQixFQUE2QnQyQixLQUE3QixFQUFvQztVQUMzQzAzQixRQUFRLENBQUN4NUIsSUFBVCxDQUFjLElBQWQsRUFBb0JvNEIsVUFBcEIsRUFBZ0N0MkIsS0FBSyxJQUFJLEVBQVQsSUFBZSxFQUEvQztTQUZ1RTtRQUl6RWszQixRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQlosVUFBbEIsRUFBOEJ0MkIsS0FBOUIsRUFBcUM7VUFDN0MwM0IsUUFBUSxDQUFDeDVCLElBQVQsQ0FBYyxJQUFkLEVBQW9CbzRCLFVBQXBCLEVBQWdDdDJCLEtBQUssSUFBSSxFQUFULElBQWUsRUFBL0M7O09BTGdELEVBT2pELElBUGlELENBQVg7OztJQVMzQ2lOLGVBQWMsQ0FBQzZtQixZQUFELEVBQWVKLFlBQWYsQ0FBZDtJQUNBem1CLGVBQWMsQ0FBQzhtQixTQUFELEVBQVlKLFNBQVosQ0FBZDtJQUNBaHlCLEtBQUksQ0FBQ295QixTQUFTLENBQUN6eEIsU0FBRCxDQUFWLEVBQXVCNnpCLE1BQU0sQ0FBQ2hELElBQTlCLEVBQW9DLElBQXBDLENBQUo7SUFDQS92QixPQUFPLENBQUNzd0IsWUFBRCxDQUFQLEdBQXdCSSxZQUF4QjtJQUNBMXdCLE9BQU8sQ0FBQ3V3QixTQUFELENBQVAsR0FBcUJJLFNBQXJCOzs7RUMzUUEsSUFBSVYsV0FBVyxHQUFHaDFCLE9BQW9CLENBQUNnMUIsV0FBdkM7RUFFQSxJQUFJUyxZQUFZLEdBQUdZLFlBQU0sQ0FBQ3JCLFdBQTFCO0VBQ0EsSUFBSVUsU0FBUyxHQUFHVyxZQUFNLENBQUNwQixRQUF2QjtFQUNBLElBQUlxRSxPQUFPLEdBQUd4QixNQUFNLENBQUMvQyxHQUFQLElBQWNDLFdBQVcsQ0FBQ3VFLE1BQXhDO0VBQ0EsSUFBSUMsTUFBTSxHQUFHL0QsWUFBWSxDQUFDaHlCLFNBQWIsQ0FBdUIyRCxLQUFwQztFQUNBLElBQUkwdEIsTUFBSSxHQUFHZ0QsTUFBTSxDQUFDaEQsSUFBbEI7RUFDQSxJQUFJTyxZQUFZLEdBQUcsYUFBbkI7QUFFQW54QixTQUFPLENBQUNBLE9BQU8sQ0FBQ08sQ0FBUixHQUFZUCxPQUFPLENBQUNxQixDQUFwQixHQUF3QnJCLE9BQU8sQ0FBQ0ssQ0FBUixJQUFheXdCLFdBQVcsS0FBS1MsWUFBN0IsQ0FBekIsRUFBcUU7SUFBRVQsV0FBVyxFQUFFUztFQUFmLENBQXJFLENBQVA7QUFFQXZ4QixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUN1ekIsTUFBTSxDQUFDNUMsTUFBakMsRUFBeUNHLFlBQXpDLEVBQXVEOztJQUU1RGtFLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCNTVCLEVBQWhCLEVBQW9CO01BQzFCLE9BQU8yNUIsT0FBTyxJQUFJQSxPQUFPLENBQUMzNUIsRUFBRCxDQUFsQixJQUEwQmEsU0FBUSxDQUFDYixFQUFELENBQVIsSUFBZ0JtMUIsTUFBSSxJQUFJbjFCLEVBQXpEOztFQUgwRCxDQUF2RCxDQUFQO0FBT0F1RSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ29CLENBQXBCLEdBQXdCcEIsT0FBTyxDQUFDSyxDQUFSLEdBQVkxRCxNQUFtQixDQUFDLFlBQVk7SUFDMUUsT0FBTyxDQUFDLElBQUk0MEIsWUFBSixDQUFpQixDQUFqQixFQUFvQnJ1QixLQUFwQixDQUEwQixDQUExQixFQUE2QjdFLFNBQTdCLEVBQXdDdzFCLFVBQWhEO0VBQ0QsQ0FGOEQsQ0FBeEQsRUFFSDFDLFlBRkcsRUFFVzs7SUFFaEJqdUIsS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZTZaLEtBQWYsRUFBc0J6RSxHQUF0QixFQUEyQjtNQUNoQyxJQUFJZ2QsTUFBTSxLQUFLajNCLFNBQVgsSUFBd0JpYSxHQUFHLEtBQUtqYSxTQUFwQyxFQUErQyxPQUFPaTNCLE1BQU0sQ0FBQzM1QixJQUFQLENBQVkyQixTQUFRLENBQUMsSUFBRCxDQUFwQixFQUE0QnlmLEtBQTVCLENBQVAsQ0FEZjs7TUFFaEMsSUFBSS9QLEdBQUcsR0FBRzFQLFNBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZXUyQixVQUF6QjtNQUNBLElBQUlsa0IsS0FBSyxHQUFHdkwsZ0JBQWUsQ0FBQzJZLEtBQUQsRUFBUS9QLEdBQVIsQ0FBM0I7TUFDQSxJQUFJdW9CLEdBQUcsR0FBR254QixnQkFBZSxDQUFDa1UsR0FBRyxLQUFLamEsU0FBUixHQUFvQjJPLEdBQXBCLEdBQTBCc0wsR0FBM0IsRUFBZ0N0TCxHQUFoQyxDQUF6QjtNQUNBLElBQUl2SSxNQUFNLEdBQUcsS0FBSzhZLG1CQUFrQixDQUFDLElBQUQsRUFBT2dVLFlBQVAsQ0FBdkIsRUFBNkNwdEIsU0FBUSxDQUFDb3hCLEdBQUcsR0FBRzVsQixLQUFQLENBQXJELENBQWI7TUFDQSxJQUFJNmxCLEtBQUssR0FBRyxJQUFJaEUsU0FBSixDQUFjLElBQWQsQ0FBWjtNQUNBLElBQUlpRSxLQUFLLEdBQUcsSUFBSWpFLFNBQUosQ0FBYy9zQixNQUFkLENBQVo7TUFDQSxJQUFJWixLQUFLLEdBQUcsQ0FBWjs7TUFDQSxPQUFPOEwsS0FBSyxHQUFHNGxCLEdBQWYsRUFBb0I7UUFDbEJFLEtBQUssQ0FBQ2QsUUFBTixDQUFlOXdCLEtBQUssRUFBcEIsRUFBd0IyeEIsS0FBSyxDQUFDckIsUUFBTixDQUFleGtCLEtBQUssRUFBcEIsQ0FBeEI7OztNQUNBLE9BQU9sTCxNQUFQOztFQWJZLENBRlgsQ0FBUDtBQW1CQTdILGFBQXlCLENBQUN1MEIsWUFBRCxDQUF6Qjs7QUM1Q0FueEIsU0FBTyxDQUFDQSxPQUFPLENBQUNPLENBQVIsR0FBWVAsT0FBTyxDQUFDcUIsQ0FBcEIsR0FBd0JyQixPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDdkUsTUFBbUIsQ0FBQyswQixHQUExRCxFQUErRDtJQUNwRUUsUUFBUSxFQUFFcDBCLFlBQTBCLENBQUNvMEI7RUFEK0IsQ0FBL0QsQ0FBUDs7OztJQ0FBLElBQUlqMUIsWUFBSixFQUErQjtNQUM3QixJQUFJaUgsT0FBTyxHQUFHcEcsUUFBZDtNQUNBLElBQUkxQixNQUFNLEdBQUcyQixPQUFiO01BQ0EsSUFBSStOLEtBQUssR0FBR2hCLE1BQVo7TUFDQSxJQUFJM0osT0FBTyxHQUFHeUssT0FBZDtNQUNBLElBQUltcEIsTUFBTSxHQUFHeGpCLE1BQWI7TUFDQSxJQUFJc2xCLE9BQU8sR0FBR3JsQixZQUFkO01BQ0EsSUFBSW5QLEdBQUcsR0FBR2lzQixJQUFWO01BQ0EsSUFBSVAsVUFBVSxHQUFHK0ksV0FBakI7TUFDQSxJQUFJQyxZQUFZLEdBQUdDLGFBQW5CO01BQ0EsSUFBSXoyQixJQUFJLEdBQUcwMkIsS0FBWDtNQUNBLElBQUk3SCxXQUFXLEdBQUc4SCxZQUFsQjtNQUNBLElBQUlweUIsU0FBUyxHQUFHcXlCLFVBQWhCO01BQ0EsSUFBSTd4QixRQUFRLEdBQUc4eEIsU0FBZjtNQUNBLElBQUkxQyxPQUFPLEdBQUcyQyxRQUFkO01BQ0EsSUFBSTl4QixlQUFlLEdBQUcreEIsZ0JBQXRCO01BQ0EsSUFBSTU0QixXQUFXLEdBQUc2NEIsWUFBbEI7TUFDQSxJQUFJajNCLEdBQUcsR0FBR2szQixJQUFWO01BQ0EsSUFBSTFwQixPQUFPLEdBQUcycEIsUUFBZDtNQUNBLElBQUloNkIsUUFBUSxHQUFHaTZCLFNBQWY7TUFDQSxJQUFJbHNCLFFBQVEsR0FBR21zQixTQUFmO01BQ0EsSUFBSWxhLFdBQVcsR0FBR21hLFlBQWxCO01BQ0EsSUFBSXowQixNQUFNLEdBQUcwMEIsYUFBYjtNQUNBLElBQUk5ckIsY0FBYyxHQUFHK3JCLFVBQXJCO01BQ0EsSUFBSWh3QixJQUFJLEdBQUdpd0IsV0FBeUIsQ0FBQzc0QixDQUFyQztNQUNBLElBQUlxZSxTQUFTLEdBQUd5YSxzQkFBaEI7TUFDQSxJQUFJcDBCLEdBQUcsR0FBR3EwQixJQUFWO01BQ0EsSUFBSXR2QixHQUFHLEdBQUd1dkIsSUFBVjtNQUNBLElBQUl2SCxpQkFBaUIsR0FBR3dILGFBQXhCO01BQ0EsSUFBSUMsbUJBQW1CLEdBQUdDLGNBQTFCO01BQ0EsSUFBSTNaLGtCQUFrQixHQUFHNFosbUJBQXpCO01BQ0EsSUFBSUMsY0FBYyxHQUFHQyxrQkFBckI7TUFDQSxJQUFJaGdCLFNBQVMsR0FBR2lnQixVQUFoQjtNQUNBLElBQUl2SSxXQUFXLEdBQUd3SSxXQUFsQjtNQUNBLElBQUlqSixVQUFVLEdBQUdrSixXQUFqQjtNQUNBLElBQUkxRCxTQUFTLEdBQUcyRCxVQUFoQjtNQUNBLElBQUlDLGVBQWUsR0FBR0MsZ0JBQXRCO01BQ0EsSUFBSTF3QixHQUFHLEdBQUcyd0IsU0FBVjtNQUNBLElBQUk1d0IsS0FBSyxHQUFHNndCLFdBQVo7TUFDQSxJQUFJMzZCLEVBQUUsR0FBRytKLEdBQUcsQ0FBQ2xKLENBQWI7TUFDQSxJQUFJK0ksSUFBSSxHQUFHRSxLQUFLLENBQUNqSixDQUFqQjtNQUNBLElBQUkyUyxVQUFVLEdBQUd6VixNQUFNLENBQUN5VixVQUF4QjtNQUNBLElBQUluVSxTQUFTLEdBQUd0QixNQUFNLENBQUNzQixTQUF2QjtNQUNBLElBQUl1N0IsVUFBVSxHQUFHNzhCLE1BQU0sQ0FBQzY4QixVQUF4QjtNQUNBLElBQUkzRyxZQUFZLEdBQUcsYUFBbkI7TUFDQSxJQUFJNEcsYUFBYSxHQUFHLFdBQVc1RyxZQUEvQjtNQUNBLElBQUk2RyxpQkFBaUIsR0FBRyxtQkFBeEI7TUFDQSxJQUFJajRCLFNBQVMsR0FBRyxXQUFoQjtNQUNBLElBQUl5YixVQUFVLEdBQUdwVyxLQUFLLENBQUNyRixTQUFELENBQXRCO01BQ0EsSUFBSXd4QixZQUFZLEdBQUdtRSxPQUFPLENBQUM1RSxXQUEzQjtNQUNBLElBQUlVLFNBQVMsR0FBR2tFLE9BQU8sQ0FBQzNFLFFBQXhCO01BQ0EsSUFBSWtILFlBQVksR0FBR3pJLGlCQUFpQixDQUFDLENBQUQsQ0FBcEM7TUFDQSxJQUFJMEksV0FBVyxHQUFHMUksaUJBQWlCLENBQUMsQ0FBRCxDQUFuQztNQUNBLElBQUkySSxTQUFTLEdBQUczSSxpQkFBaUIsQ0FBQyxDQUFELENBQWpDO01BQ0EsSUFBSTRJLFVBQVUsR0FBRzVJLGlCQUFpQixDQUFDLENBQUQsQ0FBbEM7TUFDQSxJQUFJRCxTQUFTLEdBQUdDLGlCQUFpQixDQUFDLENBQUQsQ0FBakM7TUFDQSxJQUFJQyxjQUFjLEdBQUdELGlCQUFpQixDQUFDLENBQUQsQ0FBdEM7TUFDQSxJQUFJNkksYUFBYSxHQUFHcEIsbUJBQW1CLENBQUMsSUFBRCxDQUF2QztNQUNBLElBQUkzeUIsWUFBWSxHQUFHMnlCLG1CQUFtQixDQUFDLEtBQUQsQ0FBdEM7TUFDQSxJQUFJcUIsV0FBVyxHQUFHbEIsY0FBYyxDQUFDeGdCLE1BQWpDO01BQ0EsSUFBSTJoQixTQUFTLEdBQUduQixjQUFjLENBQUMxeUIsSUFBL0I7TUFDQSxJQUFJOHpCLFlBQVksR0FBR3BCLGNBQWMsQ0FBQ3ZnQixPQUFsQztNQUNBLElBQUk0aEIsZ0JBQWdCLEdBQUdqZCxVQUFVLENBQUMwRCxXQUFsQztNQUNBLElBQUl3WixXQUFXLEdBQUdsZCxVQUFVLENBQUNvRCxNQUE3QjtNQUNBLElBQUkrWixnQkFBZ0IsR0FBR25kLFVBQVUsQ0FBQ3NELFdBQWxDO01BQ0EsSUFBSXBDLFNBQVMsR0FBR2xCLFVBQVUsQ0FBQ25jLElBQTNCO01BQ0EsSUFBSXU1QixTQUFTLEdBQUdwZCxVQUFVLENBQUMyQixJQUEzQjtNQUNBLElBQUl0USxVQUFVLEdBQUcyTyxVQUFVLENBQUN0WSxLQUE1QjtNQUNBLElBQUkyMUIsYUFBYSxHQUFHcmQsVUFBVSxDQUFDeGUsUUFBL0I7TUFDQSxJQUFJODdCLG1CQUFtQixHQUFHdGQsVUFBVSxDQUFDdWQsY0FBckM7TUFDQSxJQUFJL2lCLFFBQVEsR0FBR3hPLEdBQUcsQ0FBQyxVQUFELENBQWxCO01BQ0EsSUFBSTdFLEdBQUcsR0FBRzZFLEdBQUcsQ0FBQyxhQUFELENBQWI7TUFDQSxJQUFJd3hCLGlCQUFpQixHQUFHdjJCLEdBQUcsQ0FBQyxtQkFBRCxDQUEzQjtNQUNBLElBQUl3MkIsZUFBZSxHQUFHeDJCLEdBQUcsQ0FBQyxpQkFBRCxDQUF6QjtNQUNBLElBQUl5MkIsZ0JBQWdCLEdBQUd0RixNQUFNLENBQUM1QyxNQUE5QjtNQUNBLElBQUltSSxXQUFXLEdBQUd2RixNQUFNLENBQUNqRCxLQUF6QjtNQUNBLElBQUlDLElBQUksR0FBR2dELE1BQU0sQ0FBQ2hELElBQWxCO01BQ0EsSUFBSVMsWUFBWSxHQUFHLGVBQW5CO01BRUEsSUFBSW5ULElBQUksR0FBR3NSLGlCQUFpQixDQUFDLENBQUQsRUFBSSxVQUFVcnlCLENBQVYsRUFBYXNDLE1BQWIsRUFBcUI7UUFDbkQsT0FBTzI1QixRQUFRLENBQUM3YixrQkFBa0IsQ0FBQ3BnQixDQUFELEVBQUlBLENBQUMsQ0FBQzg3QixlQUFELENBQUwsQ0FBbkIsRUFBNEN4NUIsTUFBNUMsQ0FBZjtPQUQwQixDQUE1QjtNQUlBLElBQUk0NUIsYUFBYSxHQUFHMXVCLEtBQUssQ0FBQyxZQUFZOztRQUVwQyxPQUFPLElBQUltdEIsVUFBSixDQUFlLElBQUl3QixXQUFKLENBQWdCLENBQUMsQ0FBRCxDQUFoQixFQUFxQm5ILE1BQXBDLEVBQTRDLENBQTVDLE1BQW1ELENBQTFEO09BRnVCLENBQXpCO01BS0EsSUFBSW9ILFVBQVUsR0FBRyxDQUFDLENBQUN6QixVQUFGLElBQWdCLENBQUMsQ0FBQ0EsVUFBVSxDQUFDLzNCLFNBQUQsQ0FBVixDQUFzQjJKLEdBQXhDLElBQStDaUIsS0FBSyxDQUFDLFlBQVk7UUFDaEYsSUFBSW10QixVQUFKLENBQWUsQ0FBZixFQUFrQnB1QixHQUFsQixDQUFzQixFQUF0QjtPQURtRSxDQUFyRTs7TUFJQSxJQUFJOHZCLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVUvOUIsRUFBVixFQUFjZytCLEtBQWQsRUFBcUI7UUFDbEMsSUFBSXhGLE1BQU0sR0FBR3R3QixTQUFTLENBQUNsSSxFQUFELENBQXRCO1FBQ0EsSUFBSXc0QixNQUFNLEdBQUcsQ0FBVCxJQUFjQSxNQUFNLEdBQUd3RixLQUEzQixFQUFrQyxNQUFNL29CLFVBQVUsQ0FBQyxlQUFELENBQWhCO1FBQ2xDLE9BQU91akIsTUFBUDtPQUhGOztNQU1BLElBQUkvRixRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVenlCLEVBQVYsRUFBYztRQUMzQixJQUFJYSxRQUFRLENBQUNiLEVBQUQsQ0FBUixJQUFnQjA5QixXQUFXLElBQUkxOUIsRUFBbkMsRUFBdUMsT0FBT0EsRUFBUDtRQUN2QyxNQUFNYyxTQUFTLENBQUNkLEVBQUUsR0FBRyx3QkFBTixDQUFmO09BRkY7O01BS0EsSUFBSTI5QixRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVanFCLENBQVYsRUFBYTFQLE1BQWIsRUFBcUI7UUFDbEMsSUFBSSxFQUFFbkQsUUFBUSxDQUFDNlMsQ0FBRCxDQUFSLElBQWU2cEIsaUJBQWlCLElBQUk3cEIsQ0FBdEMsQ0FBSixFQUE4QztVQUM1QyxNQUFNNVMsU0FBUyxDQUFDLHNDQUFELENBQWY7OztRQUNBLE9BQU8sSUFBSTRTLENBQUosQ0FBTTFQLE1BQU4sQ0FBUDtPQUhKOztNQU1BLElBQUlpNkIsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFVdjhCLENBQVYsRUFBYXc4QixJQUFiLEVBQW1CO1FBQ3ZDLE9BQU9DLFFBQVEsQ0FBQ3JjLGtCQUFrQixDQUFDcGdCLENBQUQsRUFBSUEsQ0FBQyxDQUFDODdCLGVBQUQsQ0FBTCxDQUFuQixFQUE0Q1UsSUFBNUMsQ0FBZjtPQURGOztNQUlBLElBQUlDLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVV6cUIsQ0FBVixFQUFhd3FCLElBQWIsRUFBbUI7UUFDaEMsSUFBSTkxQixLQUFLLEdBQUcsQ0FBWjtRQUNBLElBQUlwRSxNQUFNLEdBQUdrNkIsSUFBSSxDQUFDbDZCLE1BQWxCO1FBQ0EsSUFBSWdGLE1BQU0sR0FBRzIwQixRQUFRLENBQUNqcUIsQ0FBRCxFQUFJMVAsTUFBSixDQUFyQjs7UUFDQSxPQUFPQSxNQUFNLEdBQUdvRSxLQUFoQjtVQUF1QlksTUFBTSxDQUFDWixLQUFELENBQU4sR0FBZ0I4MUIsSUFBSSxDQUFDOTFCLEtBQUssRUFBTixDQUFwQjs7O1FBQ3ZCLE9BQU9ZLE1BQVA7T0FMRjs7TUFRQSxJQUFJd3VCLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVV4M0IsRUFBVixFQUFjQyxHQUFkLEVBQW1CdzNCLFFBQW5CLEVBQTZCO1FBQzNDaDJCLEVBQUUsQ0FBQ3pCLEVBQUQsRUFBS0MsR0FBTCxFQUFVO1VBQUVPLEdBQUcsRUFBRSxlQUFZO1lBQUUsT0FBTyxLQUFLc3dCLEVBQUwsQ0FBUTJHLFFBQVIsQ0FBUDs7U0FBL0IsQ0FBRjtPQURGOztNQUlBLElBQUkyRyxLQUFLLEdBQUcsU0FBU2plLElBQVQsQ0FBY3piOztRQUErQjtRQUN2RCxJQUFJaEQsQ0FBQyxHQUFHa04sUUFBUSxDQUFDbEssTUFBRCxDQUFoQjtRQUNBLElBQUk0TCxJQUFJLEdBQUdqTSxTQUFTLENBQUNMLE1BQXJCO1FBQ0EsSUFBSXdjLEtBQUssR0FBR2xRLElBQUksR0FBRyxDQUFQLEdBQVdqTSxTQUFTLENBQUMsQ0FBRCxDQUFwQixHQUEwQnpCLFNBQXRDO1FBQ0EsSUFBSTZkLE9BQU8sR0FBR0QsS0FBSyxLQUFLNWQsU0FBeEI7UUFDQSxJQUFJOGQsTUFBTSxHQUFHQyxTQUFTLENBQUNqZixDQUFELENBQXRCO1FBQ0EsSUFBSTBFLENBQUosRUFBT3BDLE1BQVAsRUFBZW1YLE1BQWYsRUFBdUJuUyxNQUF2QixFQUErQjRYLElBQS9CLEVBQXFDeFQsUUFBckM7O1FBQ0EsSUFBSXNULE1BQU0sSUFBSTlkLFNBQVYsSUFBdUIsQ0FBQ2llLFdBQVcsQ0FBQ0gsTUFBRCxDQUF2QyxFQUFpRDtVQUMvQyxLQUFLdFQsUUFBUSxHQUFHc1QsTUFBTSxDQUFDeGdCLElBQVAsQ0FBWXdCLENBQVosQ0FBWCxFQUEyQnlaLE1BQU0sR0FBRyxFQUFwQyxFQUF3Qy9VLENBQUMsR0FBRyxDQUFqRCxFQUFvRCxDQUFDLENBQUN3YSxJQUFJLEdBQUd4VCxRQUFRLENBQUNpTixJQUFULEVBQVIsRUFBeUI2QixJQUE5RSxFQUFvRjlWLENBQUMsRUFBckYsRUFBeUY7WUFDdkYrVSxNQUFNLENBQUNwWSxJQUFQLENBQVk2ZCxJQUFJLENBQUM1ZSxLQUFqQjs7O1VBQ0FOLENBQUMsR0FBR3laLE1BQUo7OztRQUVKLElBQUlzRixPQUFPLElBQUluUSxJQUFJLEdBQUcsQ0FBdEIsRUFBeUJrUSxLQUFLLEdBQUcvYSxHQUFHLENBQUMrYSxLQUFELEVBQVFuYyxTQUFTLENBQUMsQ0FBRCxDQUFqQixFQUFzQixDQUF0QixDQUFYOztRQUN6QixLQUFLK0IsQ0FBQyxHQUFHLENBQUosRUFBT3BDLE1BQU0sR0FBRzBFLFFBQVEsQ0FBQ2hILENBQUMsQ0FBQ3NDLE1BQUgsQ0FBeEIsRUFBb0NnRixNQUFNLEdBQUcyMEIsUUFBUSxDQUFDLElBQUQsRUFBTzM1QixNQUFQLENBQTFELEVBQTBFQSxNQUFNLEdBQUdvQyxDQUFuRixFQUFzRkEsQ0FBQyxFQUF2RixFQUEyRjtVQUN6RjRDLE1BQU0sQ0FBQzVDLENBQUQsQ0FBTixHQUFZcWEsT0FBTyxHQUFHRCxLQUFLLENBQUM5ZSxDQUFDLENBQUMwRSxDQUFELENBQUYsRUFBT0EsQ0FBUCxDQUFSLEdBQW9CMUUsQ0FBQyxDQUFDMEUsQ0FBRCxDQUF4Qzs7O1FBRUYsT0FBTzRDLE1BQVA7T0FoQkY7O01BbUJBLElBQUlxMUIsR0FBRyxHQUFHOztNQUFTdGQsRUFBVCxHQUE0QjtRQUNwQyxJQUFJM1ksS0FBSyxHQUFHLENBQVo7UUFDQSxJQUFJcEUsTUFBTSxHQUFHSyxTQUFTLENBQUNMLE1BQXZCO1FBQ0EsSUFBSWdGLE1BQU0sR0FBRzIwQixRQUFRLENBQUMsSUFBRCxFQUFPMzVCLE1BQVAsQ0FBckI7O1FBQ0EsT0FBT0EsTUFBTSxHQUFHb0UsS0FBaEI7VUFBdUJZLE1BQU0sQ0FBQ1osS0FBRCxDQUFOLEdBQWdCL0QsU0FBUyxDQUFDK0QsS0FBSyxFQUFOLENBQXpCOzs7UUFDdkIsT0FBT1ksTUFBUDtPQUxGLENBaEo2Qjs7O01BeUo3QixJQUFJczFCLGFBQWEsR0FBRyxDQUFDLENBQUNqQyxVQUFGLElBQWdCbnRCLEtBQUssQ0FBQyxZQUFZO1FBQUVtdUIsbUJBQW1CLENBQUNuOUIsSUFBcEIsQ0FBeUIsSUFBSW04QixVQUFKLENBQWUsQ0FBZixDQUF6QjtPQUFmLENBQXpDOztNQUVBLElBQUlrQyxlQUFlLEdBQUcsU0FBU2pCLGNBQVQsR0FBMEI7UUFDOUMsT0FBT0QsbUJBQW1CLENBQUNqNUIsS0FBcEIsQ0FBMEJrNkIsYUFBYSxHQUFHbHRCLFVBQVUsQ0FBQ2xSLElBQVgsQ0FBZ0J1eUIsUUFBUSxDQUFDLElBQUQsQ0FBeEIsQ0FBSCxHQUFxQ0EsUUFBUSxDQUFDLElBQUQsQ0FBcEYsRUFBNEZwdUIsU0FBNUYsQ0FBUDtPQURGOztNQUlBLElBQUlxTSxLQUFLLEdBQUc7UUFDVmdULFVBQVUsRUFBRSxTQUFTQSxVQUFULENBQW9CdmUsTUFBcEIsRUFBNEJtYzs7VUFBbUI7VUFDekQsT0FBTzJhLGVBQWUsQ0FBQy83QixJQUFoQixDQUFxQnV5QixRQUFRLENBQUMsSUFBRCxDQUE3QixFQUFxQ3R0QixNQUFyQyxFQUE2Q21jLEtBQTdDLEVBQW9EamQsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQTFGLENBQVA7U0FGUTtRQUlWb2dCLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWVWOztVQUE0QjtVQUNoRCxPQUFPcWEsVUFBVSxDQUFDbEssUUFBUSxDQUFDLElBQUQsQ0FBVCxFQUFpQm5RLFVBQWpCLEVBQTZCamUsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQW5FLENBQWpCO1NBTFE7UUFPVmtoQixJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjOWhCOztVQUEwQjs7VUFDNUMsT0FBT3EyQixTQUFTLENBQUNqMEIsS0FBVixDQUFnQnF1QixRQUFRLENBQUMsSUFBRCxDQUF4QixFQUFnQ3B1QixTQUFoQyxDQUFQO1NBUlE7UUFVVnVlLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCTjs7VUFBNEI7VUFDbEQsT0FBTzJiLGVBQWUsQ0FBQyxJQUFELEVBQU94QixXQUFXLENBQUNoSyxRQUFRLENBQUMsSUFBRCxDQUFULEVBQWlCblEsVUFBakIsRUFDdENqZSxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FEQSxDQUFsQixDQUF0QjtTQVhRO1FBY1ZzaEIsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY3NhOztVQUEyQjtVQUM3QyxPQUFPMUssU0FBUyxDQUFDckIsUUFBUSxDQUFDLElBQUQsQ0FBVCxFQUFpQitMLFNBQWpCLEVBQTRCbjZCLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUFsRSxDQUFoQjtTQWZRO1FBaUJWdWhCLFNBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CcWE7O1VBQTJCO1VBQ3ZELE9BQU94SyxjQUFjLENBQUN2QixRQUFRLENBQUMsSUFBRCxDQUFULEVBQWlCK0wsU0FBakIsRUFBNEJuNkIsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQWxFLENBQXJCO1NBbEJRO1FBb0JWd04sT0FBTyxFQUFFLFNBQVNBLE9BQVQsQ0FBaUJrUzs7VUFBNEI7VUFDcERrYSxZQUFZLENBQUMvSixRQUFRLENBQUMsSUFBRCxDQUFULEVBQWlCblEsVUFBakIsRUFBNkJqZSxTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBbkUsQ0FBWjtTQXJCUTtRQXVCVnFhLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCdUc7O1VBQWlDO1VBQ3pELE9BQU8zYSxZQUFZLENBQUM0cEIsUUFBUSxDQUFDLElBQUQsQ0FBVCxFQUFpQmpQLGFBQWpCLEVBQWdDbmYsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQXRFLENBQW5CO1NBeEJRO1FBMEJWb2EsUUFBUSxFQUFFLFNBQVNBLFFBQVQsQ0FBa0J3Rzs7VUFBaUM7VUFDM0QsT0FBT29aLGFBQWEsQ0FBQ25LLFFBQVEsQ0FBQyxJQUFELENBQVQsRUFBaUJqUCxhQUFqQixFQUFnQ25mLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUF0RSxDQUFwQjtTQTNCUTtRQTZCVmdCLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNzZCxTQUFkLEVBQXlCOztVQUM3QixPQUFPRCxTQUFTLENBQUM3YyxLQUFWLENBQWdCcXVCLFFBQVEsQ0FBQyxJQUFELENBQXhCLEVBQWdDcHVCLFNBQWhDLENBQVA7U0E5QlE7UUFnQ1ZvZixXQUFXLEVBQUUsU0FBU0EsV0FBVCxDQUFxQkQ7O1VBQWlDOztVQUNqRSxPQUFPd1osZ0JBQWdCLENBQUM1NEIsS0FBakIsQ0FBdUJxdUIsUUFBUSxDQUFDLElBQUQsQ0FBL0IsRUFBdUNwdUIsU0FBdkMsQ0FBUDtTQWpDUTtRQW1DVnFlLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWFsQzs7VUFBdUI7VUFDdkMsT0FBT2lDLElBQUksQ0FBQ2dRLFFBQVEsQ0FBQyxJQUFELENBQVQsRUFBaUJqUyxLQUFqQixFQUF3Qm5jLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUE5RCxDQUFYO1NBcENRO1FBc0NWdWdCLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCYjs7VUFBaUM7O1VBQ3ZELE9BQU8yYSxXQUFXLENBQUM3NEIsS0FBWixDQUFrQnF1QixRQUFRLENBQUMsSUFBRCxDQUExQixFQUFrQ3B1QixTQUFsQyxDQUFQO1NBdkNRO1FBeUNWZ2YsV0FBVyxFQUFFLFNBQVNBLFdBQVQsQ0FBcUJmOztVQUFpQzs7VUFDakUsT0FBTzRhLGdCQUFnQixDQUFDOTRCLEtBQWpCLENBQXVCcXVCLFFBQVEsQ0FBQyxJQUFELENBQS9CLEVBQXVDcHVCLFNBQXZDLENBQVA7U0ExQ1E7UUE0Q1Y0ekIsT0FBTyxFQUFFLFNBQVNBLE9BQVQsR0FBbUI7VUFDMUIsSUFBSWwwQixJQUFJLEdBQUcsSUFBWDtVQUNBLElBQUlDLE1BQU0sR0FBR3l1QixRQUFRLENBQUMxdUIsSUFBRCxDQUFSLENBQWVDLE1BQTVCO1VBQ0EsSUFBSXk2QixNQUFNLEdBQUc5K0IsSUFBSSxDQUFDb0ksS0FBTCxDQUFXL0QsTUFBTSxHQUFHLENBQXBCLENBQWI7VUFDQSxJQUFJb0UsS0FBSyxHQUFHLENBQVo7VUFDQSxJQUFJcEcsS0FBSjs7VUFDQSxPQUFPb0csS0FBSyxHQUFHcTJCLE1BQWYsRUFBdUI7WUFDckJ6OEIsS0FBSyxHQUFHK0IsSUFBSSxDQUFDcUUsS0FBRCxDQUFaO1lBQ0FyRSxJQUFJLENBQUNxRSxLQUFLLEVBQU4sQ0FBSixHQUFnQnJFLElBQUksQ0FBQyxFQUFFQyxNQUFILENBQXBCO1lBQ0FELElBQUksQ0FBQ0MsTUFBRCxDQUFKLEdBQWVoQyxLQUFmOzs7VUFDQSxPQUFPK0IsSUFBUDtTQXRETTtRQXdEVitlLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNSOztVQUE0QjtVQUM5QyxPQUFPb2EsU0FBUyxDQUFDakssUUFBUSxDQUFDLElBQUQsQ0FBVCxFQUFpQm5RLFVBQWpCLEVBQTZCamUsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCSyxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ3pCLFNBQW5FLENBQWhCO1NBekRRO1FBMkRWOGUsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY0MsU0FBZCxFQUF5QjtVQUM3QixPQUFPd2IsU0FBUyxDQUFDajlCLElBQVYsQ0FBZXV5QixRQUFRLENBQUMsSUFBRCxDQUF2QixFQUErQjlRLFNBQS9CLENBQVA7U0E1RFE7UUE4RFYrYyxRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQnRkLEtBQWxCLEVBQXlCdkUsR0FBekIsRUFBOEI7VUFDdEMsSUFBSW5iLENBQUMsR0FBRyt3QixRQUFRLENBQUMsSUFBRCxDQUFoQjtVQUNBLElBQUl6dUIsTUFBTSxHQUFHdEMsQ0FBQyxDQUFDc0MsTUFBZjtVQUNBLElBQUkyNkIsTUFBTSxHQUFHaDJCLGVBQWUsQ0FBQ3lZLEtBQUQsRUFBUXBkLE1BQVIsQ0FBNUI7VUFDQSxPQUFPLEtBQUs4ZCxrQkFBa0IsQ0FBQ3BnQixDQUFELEVBQUlBLENBQUMsQ0FBQzg3QixlQUFELENBQUwsQ0FBdkIsRUFDTDk3QixDQUFDLENBQUNnMUIsTUFERyxFQUVMaDFCLENBQUMsQ0FBQzQyQixVQUFGLEdBQWVxRyxNQUFNLEdBQUdqOUIsQ0FBQyxDQUFDNjZCLGlCQUZyQixFQUdMN3pCLFFBQVEsQ0FBQyxDQUFDbVUsR0FBRyxLQUFLamEsU0FBUixHQUFvQm9CLE1BQXBCLEdBQTZCMkUsZUFBZSxDQUFDa1UsR0FBRCxFQUFNN1ksTUFBTixDQUE3QyxJQUE4RDI2QixNQUEvRCxDQUhILENBQVA7O09BbEVKOztNQTBFQSxJQUFJOUUsTUFBTSxHQUFHLFNBQVNweUIsS0FBVCxDQUFlNlosS0FBZixFQUFzQnpFLEdBQXRCLEVBQTJCO1FBQ3RDLE9BQU9vaEIsZUFBZSxDQUFDLElBQUQsRUFBTzdzQixVQUFVLENBQUNsUixJQUFYLENBQWdCdXlCLFFBQVEsQ0FBQyxJQUFELENBQXhCLEVBQWdDblIsS0FBaEMsRUFBdUN6RSxHQUF2QyxDQUFQLENBQXRCO09BREY7O01BSUEsSUFBSTdPLElBQUksR0FBRyxTQUFTQyxHQUFULENBQWFzUzs7UUFBMEI7UUFDaERrUyxRQUFRLENBQUMsSUFBRCxDQUFSO1FBQ0EsSUFBSStGLE1BQU0sR0FBR3VGLFFBQVEsQ0FBQzE1QixTQUFTLENBQUMsQ0FBRCxDQUFWLEVBQWUsQ0FBZixDQUFyQjtRQUNBLElBQUlMLE1BQU0sR0FBRyxLQUFLQSxNQUFsQjtRQUNBLElBQUkwRyxHQUFHLEdBQUdrRSxRQUFRLENBQUMyUixTQUFELENBQWxCO1FBQ0EsSUFBSWhQLEdBQUcsR0FBRzdJLFFBQVEsQ0FBQ2dDLEdBQUcsQ0FBQzFHLE1BQUwsQ0FBbEI7UUFDQSxJQUFJb0UsS0FBSyxHQUFHLENBQVo7UUFDQSxJQUFJbUosR0FBRyxHQUFHaW5CLE1BQU4sR0FBZXgwQixNQUFuQixFQUEyQixNQUFNaVIsVUFBVSxDQUFDMmdCLFlBQUQsQ0FBaEI7O1FBQzNCLE9BQU94dEIsS0FBSyxHQUFHbUosR0FBZjtVQUFvQixLQUFLaW5CLE1BQU0sR0FBR3B3QixLQUFkLElBQXVCc0MsR0FBRyxDQUFDdEMsS0FBSyxFQUFOLENBQTFCOztPQVJ0Qjs7TUFXQSxJQUFJdzJCLFVBQVUsR0FBRztRQUNmeGpCLE9BQU8sRUFBRSxTQUFTQSxPQUFULEdBQW1CO1VBQzFCLE9BQU8yaEIsWUFBWSxDQUFDNzhCLElBQWIsQ0FBa0J1eUIsUUFBUSxDQUFDLElBQUQsQ0FBMUIsQ0FBUDtTQUZhO1FBSWZ4cEIsSUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7VUFDcEIsT0FBTzZ6QixTQUFTLENBQUM1OEIsSUFBVixDQUFldXlCLFFBQVEsQ0FBQyxJQUFELENBQXZCLENBQVA7U0FMYTtRQU9mdFgsTUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7VUFDeEIsT0FBTzBoQixXQUFXLENBQUMzOEIsSUFBWixDQUFpQnV5QixRQUFRLENBQUMsSUFBRCxDQUF6QixDQUFQOztPQVJKOztNQVlBLElBQUlvTSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVMTVCLE1BQVYsRUFBa0JsRixHQUFsQixFQUF1QjtRQUNyQyxPQUFPWSxRQUFRLENBQUNzRSxNQUFELENBQVIsSUFDRkEsTUFBTSxDQUFDdTRCLFdBQUQsQ0FESixJQUVGLE9BQU96OUIsR0FBUCxJQUFjLFFBRlosSUFHRkEsR0FBRyxJQUFJa0YsTUFITCxJQUlGdEIsTUFBTSxDQUFDLENBQUM1RCxHQUFGLENBQU4sSUFBZ0I0RCxNQUFNLENBQUM1RCxHQUFELENBSjNCO09BREY7O01BT0EsSUFBSTYrQixRQUFRLEdBQUcsU0FBU3h6Qix3QkFBVCxDQUFrQ25HLE1BQWxDLEVBQTBDbEYsR0FBMUMsRUFBK0M7UUFDNUQsT0FBTzQrQixTQUFTLENBQUMxNUIsTUFBRCxFQUFTbEYsR0FBRyxHQUFHNkIsV0FBVyxDQUFDN0IsR0FBRCxFQUFNLElBQU4sQ0FBMUIsQ0FBVCxHQUNIazZCLFlBQVksQ0FBQyxDQUFELEVBQUloMUIsTUFBTSxDQUFDbEYsR0FBRCxDQUFWLENBRFQsR0FFSG9MLElBQUksQ0FBQ2xHLE1BQUQsRUFBU2xGLEdBQVQsQ0FGUjtPQURGOztNQUtBLElBQUk4K0IsUUFBUSxHQUFHLFNBQVN4K0IsY0FBVCxDQUF3QjRFLE1BQXhCLEVBQWdDbEYsR0FBaEMsRUFBcUMrK0IsSUFBckMsRUFBMkM7UUFDeEQsSUFBSUgsU0FBUyxDQUFDMTVCLE1BQUQsRUFBU2xGLEdBQUcsR0FBRzZCLFdBQVcsQ0FBQzdCLEdBQUQsRUFBTSxJQUFOLENBQTFCLENBQVQsSUFDQ1ksUUFBUSxDQUFDbStCLElBQUQsQ0FEVCxJQUVDdDdCLEdBQUcsQ0FBQ3M3QixJQUFELEVBQU8sT0FBUCxDQUZKLElBR0MsQ0FBQ3Q3QixHQUFHLENBQUNzN0IsSUFBRCxFQUFPLEtBQVAsQ0FITCxJQUlDLENBQUN0N0IsR0FBRyxDQUFDczdCLElBQUQsRUFBTyxLQUFQLENBSkw7V0FNQyxDQUFDQSxJQUFJLENBQUM3OEIsWUFOUCxLQU9FLENBQUN1QixHQUFHLENBQUNzN0IsSUFBRCxFQUFPLFVBQVAsQ0FBSixJQUEwQkEsSUFBSSxDQUFDNThCLFFBUGpDLE1BUUUsQ0FBQ3NCLEdBQUcsQ0FBQ3M3QixJQUFELEVBQU8sWUFBUCxDQUFKLElBQTRCQSxJQUFJLENBQUM5OEIsVUFSbkMsQ0FBSixFQVNFO1VBQ0FpRCxNQUFNLENBQUNsRixHQUFELENBQU4sR0FBYysrQixJQUFJLENBQUNoOUIsS0FBbkI7VUFDQSxPQUFPbUQsTUFBUDs7O1FBQ0EsT0FBTzFELEVBQUUsQ0FBQzBELE1BQUQsRUFBU2xGLEdBQVQsRUFBYysrQixJQUFkLENBQVQ7T0FiSjs7TUFnQkEsSUFBSSxDQUFDdkIsZ0JBQUwsRUFBdUI7UUFDckJseUIsS0FBSyxDQUFDakosQ0FBTixHQUFVdzhCLFFBQVY7UUFDQXR6QixHQUFHLENBQUNsSixDQUFKLEdBQVF5OEIsUUFBUjs7O01BR0Z4NkIsT0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsR0FBWSxDQUFDNjRCLGdCQUExQixFQUE0QyxRQUE1QyxFQUFzRDtRQUMzRG55Qix3QkFBd0IsRUFBRXd6QixRQURpQztRQUUzRHYrQixjQUFjLEVBQUV3K0I7T0FGWCxDQUFQOztNQUtBLElBQUk3dkIsS0FBSyxDQUFDLFlBQVk7UUFBRWt1QixhQUFhLENBQUNsOUIsSUFBZCxDQUFtQixFQUFuQjtPQUFmLENBQVQsRUFBb0Q7UUFDbERrOUIsYUFBYSxHQUFHQyxtQkFBbUIsR0FBRyxTQUFTOTdCLFFBQVQsR0FBb0I7VUFDeEQsT0FBTzBmLFNBQVMsQ0FBQy9nQixJQUFWLENBQWUsSUFBZixDQUFQO1NBREY7OztNQUtGLElBQUkrK0IscUJBQXFCLEdBQUd6TSxXQUFXLENBQUMsRUFBRCxFQUFLOWhCLEtBQUwsQ0FBdkM7TUFDQThoQixXQUFXLENBQUN5TSxxQkFBRCxFQUF3QkwsVUFBeEIsQ0FBWDtNQUNBajdCLElBQUksQ0FBQ3M3QixxQkFBRCxFQUF3QjFrQixRQUF4QixFQUFrQ3FrQixVQUFVLENBQUN6akIsTUFBN0MsQ0FBSjtNQUNBcVgsV0FBVyxDQUFDeU0scUJBQUQsRUFBd0I7UUFDakN4M0IsS0FBSyxFQUFFb3lCLE1BRDBCO1FBRWpDNXJCLEdBQUcsRUFBRUQsSUFGNEI7UUFHakNvQixXQUFXLEVBQUUsdUJBQVk7O1NBSFE7UUFJakM3TixRQUFRLEVBQUU2N0IsYUFKdUI7UUFLakNFLGNBQWMsRUFBRWlCO09BTFAsQ0FBWDtNQU9BL0csU0FBUyxDQUFDeUgscUJBQUQsRUFBd0IsUUFBeEIsRUFBa0MsR0FBbEMsQ0FBVDtNQUNBekgsU0FBUyxDQUFDeUgscUJBQUQsRUFBd0IsWUFBeEIsRUFBc0MsR0FBdEMsQ0FBVDtNQUNBekgsU0FBUyxDQUFDeUgscUJBQUQsRUFBd0IsWUFBeEIsRUFBc0MsR0FBdEMsQ0FBVDtNQUNBekgsU0FBUyxDQUFDeUgscUJBQUQsRUFBd0IsUUFBeEIsRUFBa0MsR0FBbEMsQ0FBVDtNQUNBeDlCLEVBQUUsQ0FBQ3c5QixxQkFBRCxFQUF3Qi8zQixHQUF4QixFQUE2QjtRQUM3QjFHLEdBQUcsRUFBRSxlQUFZO1VBQUUsT0FBTyxLQUFLazlCLFdBQUwsQ0FBUDs7T0FEbkIsQ0FBRixDQTlUNkI7O01BbVU3QmorQixjQUFBLEdBQWlCLFVBQVVtSCxHQUFWLEVBQWVvM0IsS0FBZixFQUFzQi9NLE9BQXRCLEVBQStCaU8sT0FBL0IsRUFBd0M7UUFDdkRBLE9BQU8sR0FBRyxDQUFDLENBQUNBLE9BQVo7UUFDQSxJQUFJbnRCLElBQUksR0FBR25MLEdBQUcsSUFBSXM0QixPQUFPLEdBQUcsU0FBSCxHQUFlLEVBQTFCLENBQUgsR0FBbUMsT0FBOUM7UUFDQSxJQUFJQyxNQUFNLEdBQUcsUUFBUXY0QixHQUFyQjtRQUNBLElBQUl3NEIsTUFBTSxHQUFHLFFBQVF4NEIsR0FBckI7UUFDQSxJQUFJeTRCLFVBQVUsR0FBRzcvQixNQUFNLENBQUN1UyxJQUFELENBQXZCO1FBQ0EsSUFBSThCLElBQUksR0FBR3dyQixVQUFVLElBQUksRUFBekI7UUFDQSxJQUFJQyxHQUFHLEdBQUdELFVBQVUsSUFBSWx3QixjQUFjLENBQUNrd0IsVUFBRCxDQUF0QztRQUNBLElBQUl0a0IsTUFBTSxHQUFHLENBQUNza0IsVUFBRCxJQUFlLENBQUNsSCxNQUFNLENBQUMvQyxHQUFwQztRQUNBLElBQUkxekIsQ0FBQyxHQUFHLEVBQVI7UUFDQSxJQUFJNjlCLG1CQUFtQixHQUFHRixVQUFVLElBQUlBLFVBQVUsQ0FBQy82QixTQUFELENBQWxEOztRQUNBLElBQUlrN0IsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVXo3QixJQUFWLEVBQWdCcUUsS0FBaEIsRUFBdUI7VUFDbEMsSUFBSWdOLElBQUksR0FBR3JSLElBQUksQ0FBQytzQixFQUFoQjtVQUNBLE9BQU8xYixJQUFJLENBQUMrWSxDQUFMLENBQU9nUixNQUFQLEVBQWUvMkIsS0FBSyxHQUFHNDFCLEtBQVIsR0FBZ0I1b0IsSUFBSSxDQUFDcXFCLENBQXBDLEVBQXVDN0IsYUFBdkMsQ0FBUDtTQUZGOztRQUlBLElBQUlweEIsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVXpJLElBQVYsRUFBZ0JxRSxLQUFoQixFQUF1QnBHLEtBQXZCLEVBQThCO1VBQ3pDLElBQUlvVCxJQUFJLEdBQUdyUixJQUFJLENBQUMrc0IsRUFBaEI7VUFDQSxJQUFJb08sT0FBSixFQUFhbDlCLEtBQUssR0FBRyxDQUFDQSxLQUFLLEdBQUdyQyxJQUFJLENBQUMrL0IsS0FBTCxDQUFXMTlCLEtBQVgsQ0FBVCxJQUE4QixDQUE5QixHQUFrQyxDQUFsQyxHQUFzQ0EsS0FBSyxHQUFHLElBQVIsR0FBZSxJQUFmLEdBQXNCQSxLQUFLLEdBQUcsSUFBNUU7VUFDYm9ULElBQUksQ0FBQytZLENBQUwsQ0FBT2lSLE1BQVAsRUFBZWgzQixLQUFLLEdBQUc0MUIsS0FBUixHQUFnQjVvQixJQUFJLENBQUNxcUIsQ0FBcEMsRUFBdUN6OUIsS0FBdkMsRUFBOEM0N0IsYUFBOUM7U0FIRjs7UUFLQSxJQUFJK0IsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVTU3QixJQUFWLEVBQWdCcUUsS0FBaEIsRUFBdUI7VUFDdEMzRyxFQUFFLENBQUNzQyxJQUFELEVBQU9xRSxLQUFQLEVBQWM7WUFDZDVILEdBQUcsRUFBRSxlQUFZO2NBQ2YsT0FBT2cvQixNQUFNLENBQUMsSUFBRCxFQUFPcDNCLEtBQVAsQ0FBYjthQUZZO1lBSWQ2RixHQUFHLEVBQUUsYUFBVWpNLEtBQVYsRUFBaUI7Y0FDcEIsT0FBT3dLLE1BQU0sQ0FBQyxJQUFELEVBQU9wRSxLQUFQLEVBQWNwRyxLQUFkLENBQWI7YUFMWTtZQU9kRSxVQUFVLEVBQUU7V0FQWixDQUFGO1NBREY7O1FBV0EsSUFBSTZZLE1BQUosRUFBWTtVQUNWc2tCLFVBQVUsR0FBR3BPLE9BQU8sQ0FBQyxVQUFVbHRCLElBQVYsRUFBZ0JxUixJQUFoQixFQUFzQndxQixPQUF0QixFQUErQkMsT0FBL0IsRUFBd0M7WUFDM0QxTyxVQUFVLENBQUNwdEIsSUFBRCxFQUFPczdCLFVBQVAsRUFBbUJ0dEIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBVjtZQUNBLElBQUkzSixLQUFLLEdBQUcsQ0FBWjtZQUNBLElBQUlvd0IsTUFBTSxHQUFHLENBQWI7WUFDQSxJQUFJOUIsTUFBSixFQUFZMEIsVUFBWixFQUF3QnAwQixNQUF4QixFQUFnQ3FkLEtBQWhDOztZQUNBLElBQUksQ0FBQ3hnQixRQUFRLENBQUN1VSxJQUFELENBQWIsRUFBcUI7Y0FDbkJwUixNQUFNLEdBQUc4ekIsT0FBTyxDQUFDMWlCLElBQUQsQ0FBaEI7Y0FDQWdqQixVQUFVLEdBQUdwMEIsTUFBTSxHQUFHZzZCLEtBQXRCO2NBQ0F0SCxNQUFNLEdBQUcsSUFBSVosWUFBSixDQUFpQnNDLFVBQWpCLENBQVQ7YUFIRixNQUlPLElBQUloakIsSUFBSSxZQUFZMGdCLFlBQWhCLElBQWdDLENBQUN6VSxLQUFLLEdBQUduUSxPQUFPLENBQUNrRSxJQUFELENBQWhCLEtBQTJCc2dCLFlBQTNELElBQTJFclUsS0FBSyxJQUFJaWIsYUFBeEYsRUFBdUc7Y0FDNUc1RixNQUFNLEdBQUd0aEIsSUFBVDtjQUNBb2pCLE1BQU0sR0FBR3VGLFFBQVEsQ0FBQzZCLE9BQUQsRUFBVTVCLEtBQVYsQ0FBakI7Y0FDQSxJQUFJOEIsSUFBSSxHQUFHMXFCLElBQUksQ0FBQ2dqQixVQUFoQjs7Y0FDQSxJQUFJeUgsT0FBTyxLQUFLajlCLFNBQWhCLEVBQTJCO2dCQUN6QixJQUFJazlCLElBQUksR0FBRzlCLEtBQVgsRUFBa0IsTUFBTS9vQixVQUFVLENBQUMyZ0IsWUFBRCxDQUFoQjtnQkFDbEJ3QyxVQUFVLEdBQUcwSCxJQUFJLEdBQUd0SCxNQUFwQjtnQkFDQSxJQUFJSixVQUFVLEdBQUcsQ0FBakIsRUFBb0IsTUFBTW5qQixVQUFVLENBQUMyZ0IsWUFBRCxDQUFoQjtlQUh0QixNQUlPO2dCQUNMd0MsVUFBVSxHQUFHMXZCLFFBQVEsQ0FBQ20zQixPQUFELENBQVIsR0FBb0I3QixLQUFqQztnQkFDQSxJQUFJNUYsVUFBVSxHQUFHSSxNQUFiLEdBQXNCc0gsSUFBMUIsRUFBZ0MsTUFBTTdxQixVQUFVLENBQUMyZ0IsWUFBRCxDQUFoQjs7O2NBRWxDNXhCLE1BQU0sR0FBR28wQixVQUFVLEdBQUc0RixLQUF0QjthQVpLLE1BYUEsSUFBSU4sV0FBVyxJQUFJdG9CLElBQW5CLEVBQXlCO2NBQzlCLE9BQU8rb0IsUUFBUSxDQUFDa0IsVUFBRCxFQUFhanFCLElBQWIsQ0FBZjthQURLLE1BRUE7Y0FDTCxPQUFPZ3BCLEtBQUssQ0FBQ2wrQixJQUFOLENBQVdtL0IsVUFBWCxFQUF1QmpxQixJQUF2QixDQUFQOzs7WUFFRnpSLElBQUksQ0FBQ0ksSUFBRCxFQUFPLElBQVAsRUFBYTtjQUNmRyxDQUFDLEVBQUV3eUIsTUFEWTtjQUVmK0ksQ0FBQyxFQUFFakgsTUFGWTtjQUdmaHJCLENBQUMsRUFBRTRxQixVQUhZO2NBSWZoNEIsQ0FBQyxFQUFFNEQsTUFKWTtjQUtmbXFCLENBQUMsRUFBRSxJQUFJNEgsU0FBSixDQUFjVyxNQUFkO2FBTEQsQ0FBSjs7WUFPQSxPQUFPdHVCLEtBQUssR0FBR3BFLE1BQWY7Y0FBdUIyN0IsVUFBVSxDQUFDNTdCLElBQUQsRUFBT3FFLEtBQUssRUFBWixDQUFWOztXQWxDTCxDQUFwQjtVQW9DQW0zQixtQkFBbUIsR0FBR0YsVUFBVSxDQUFDLzZCLFNBQUQsQ0FBVixHQUF3QmlDLE1BQU0sQ0FBQzA0QixxQkFBRCxDQUFwRDtVQUNBdDdCLElBQUksQ0FBQzQ3QixtQkFBRCxFQUFzQixhQUF0QixFQUFxQ0YsVUFBckMsQ0FBSjtTQXRDRixNQXVDTyxJQUFJLENBQUNud0IsS0FBSyxDQUFDLFlBQVk7VUFDNUJtd0IsVUFBVSxDQUFDLENBQUQsQ0FBVjtTQURlLENBQU4sSUFFTCxDQUFDbndCLEtBQUssQ0FBQyxZQUFZO1VBQ3ZCLElBQUltd0IsVUFBSixDQUFlLENBQUMsQ0FBaEIsRUFEdUI7U0FBYixDQUZELElBSUwsQ0FBQy9MLFdBQVcsQ0FBQyxVQUFVaFQsSUFBVixFQUFnQjtVQUNqQyxJQUFJK2UsVUFBSixHQURpQzs7VUFFakMsSUFBSUEsVUFBSixDQUFlLElBQWYsRUFGaUM7O1VBR2pDLElBQUlBLFVBQUosQ0FBZSxHQUFmLEVBSGlDOztVQUlqQyxJQUFJQSxVQUFKLENBQWUvZSxJQUFmLEVBSmlDO1NBQWpCLEVBS2YsSUFMZSxDQUpYLEVBU0c7VUFDUitlLFVBQVUsR0FBR3BPLE9BQU8sQ0FBQyxVQUFVbHRCLElBQVYsRUFBZ0JxUixJQUFoQixFQUFzQndxQixPQUF0QixFQUErQkMsT0FBL0IsRUFBd0M7WUFDM0QxTyxVQUFVLENBQUNwdEIsSUFBRCxFQUFPczdCLFVBQVAsRUFBbUJ0dEIsSUFBbkIsQ0FBVjtZQUNBLElBQUlzUCxLQUFKLENBRjJEOzs7WUFLM0QsSUFBSSxDQUFDeGdCLFFBQVEsQ0FBQ3VVLElBQUQsQ0FBYixFQUFxQixPQUFPLElBQUl2QixJQUFKLENBQVNpa0IsT0FBTyxDQUFDMWlCLElBQUQsQ0FBaEIsQ0FBUDs7WUFDckIsSUFBSUEsSUFBSSxZQUFZMGdCLFlBQWhCLElBQWdDLENBQUN6VSxLQUFLLEdBQUduUSxPQUFPLENBQUNrRSxJQUFELENBQWhCLEtBQTJCc2dCLFlBQTNELElBQTJFclUsS0FBSyxJQUFJaWIsYUFBeEYsRUFBdUc7Y0FDckcsT0FBT3VELE9BQU8sS0FBS2o5QixTQUFaLEdBQ0gsSUFBSWlSLElBQUosQ0FBU3VCLElBQVQsRUFBZTJvQixRQUFRLENBQUM2QixPQUFELEVBQVU1QixLQUFWLENBQXZCLEVBQXlDNkIsT0FBekMsQ0FERyxHQUVIRCxPQUFPLEtBQUtoOUIsU0FBWixHQUNFLElBQUlpUixJQUFKLENBQVN1QixJQUFULEVBQWUyb0IsUUFBUSxDQUFDNkIsT0FBRCxFQUFVNUIsS0FBVixDQUF2QixDQURGLEdBRUUsSUFBSW5xQixJQUFKLENBQVN1QixJQUFULENBSk47OztZQU1GLElBQUlzb0IsV0FBVyxJQUFJdG9CLElBQW5CLEVBQXlCLE9BQU8rb0IsUUFBUSxDQUFDa0IsVUFBRCxFQUFhanFCLElBQWIsQ0FBZjtZQUN6QixPQUFPZ3BCLEtBQUssQ0FBQ2wrQixJQUFOLENBQVdtL0IsVUFBWCxFQUF1QmpxQixJQUF2QixDQUFQO1dBZGtCLENBQXBCO1VBZ0JBb25CLFlBQVksQ0FBQzhDLEdBQUcsS0FBS3ovQixRQUFRLENBQUNpRSxTQUFqQixHQUE2Qm9ILElBQUksQ0FBQzJJLElBQUQsQ0FBSixDQUFXbFIsTUFBWCxDQUFrQnVJLElBQUksQ0FBQ28wQixHQUFELENBQXRCLENBQTdCLEdBQTREcDBCLElBQUksQ0FBQzJJLElBQUQsQ0FBakUsRUFBeUUsVUFBVTVULEdBQVYsRUFBZTtZQUNsRyxJQUFJLEVBQUVBLEdBQUcsSUFBSW8vQixVQUFULENBQUosRUFBMEIxN0IsSUFBSSxDQUFDMDdCLFVBQUQsRUFBYXAvQixHQUFiLEVBQWtCNFQsSUFBSSxDQUFDNVQsR0FBRCxDQUF0QixDQUFKO1dBRGhCLENBQVo7VUFHQW8vQixVQUFVLENBQUMvNkIsU0FBRCxDQUFWLEdBQXdCaTdCLG1CQUF4QjtVQUNBLElBQUksQ0FBQ2o0QixPQUFMLEVBQWNpNEIsbUJBQW1CLENBQUNud0IsV0FBcEIsR0FBa0Npd0IsVUFBbEM7OztRQUVoQixJQUFJVSxlQUFlLEdBQUdSLG1CQUFtQixDQUFDaGxCLFFBQUQsQ0FBekM7UUFDQSxJQUFJeWxCLGlCQUFpQixHQUFHLENBQUMsQ0FBQ0QsZUFBRixLQUNsQkEsZUFBZSxDQUFDdDdCLElBQWhCLElBQXdCLFFBQXhCLElBQW9DczdCLGVBQWUsQ0FBQ3Q3QixJQUFoQixJQUF3QjdCLFNBRDFDLENBQXhCO1FBRUEsSUFBSXE5QixTQUFTLEdBQUdyQixVQUFVLENBQUN6akIsTUFBM0I7UUFDQXhYLElBQUksQ0FBQzA3QixVQUFELEVBQWE5QixpQkFBYixFQUFnQyxJQUFoQyxDQUFKO1FBQ0E1NUIsSUFBSSxDQUFDNDdCLG1CQUFELEVBQXNCN0IsV0FBdEIsRUFBbUMzckIsSUFBbkMsQ0FBSjtRQUNBcE8sSUFBSSxDQUFDNDdCLG1CQUFELEVBQXNCcEssSUFBdEIsRUFBNEIsSUFBNUIsQ0FBSjtRQUNBeHhCLElBQUksQ0FBQzQ3QixtQkFBRCxFQUFzQi9CLGVBQXRCLEVBQXVDNkIsVUFBdkMsQ0FBSjs7UUFFQSxJQUFJSCxPQUFPLEdBQUcsSUFBSUcsVUFBSixDQUFlLENBQWYsRUFBa0JuNEIsR0FBbEIsS0FBMEI2SyxJQUE3QixHQUFvQyxFQUFFN0ssR0FBRyxJQUFJcTRCLG1CQUFULENBQS9DLEVBQThFO1VBQzVFOTlCLEVBQUUsQ0FBQzg5QixtQkFBRCxFQUFzQnI0QixHQUF0QixFQUEyQjtZQUMzQjFHLEdBQUcsRUFBRSxlQUFZO2NBQUUsT0FBT3VSLElBQVA7O1dBRG5CLENBQUY7OztRQUtGclEsQ0FBQyxDQUFDcVEsSUFBRCxDQUFELEdBQVVzdEIsVUFBVjtRQUVBOTZCLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDTyxDQUFSLEdBQVlQLE9BQU8sQ0FBQ3FCLENBQXBCLEdBQXdCckIsT0FBTyxDQUFDSyxDQUFSLElBQWF5NkIsVUFBVSxJQUFJeHJCLElBQTNCLENBQXpCLEVBQTJEblMsQ0FBM0QsQ0FBUDtRQUVBNkMsT0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVkyUSxJQUFaLEVBQWtCO1VBQ3ZCd3FCLGlCQUFpQixFQUFFeUI7U0FEZCxDQUFQO1FBSUF6NUIsT0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFSLEdBQVltRCxPQUFPLENBQUNLLENBQVIsR0FBWXNLLEtBQUssQ0FBQyxZQUFZO1VBQUUyRSxJQUFJLENBQUNrTixFQUFMLENBQVE3Z0IsSUFBUixDQUFhbS9CLFVBQWIsRUFBeUIsQ0FBekI7U0FBZixDQUE5QixFQUE4RXR0QixJQUE5RSxFQUFvRjtVQUN6Rm9PLElBQUksRUFBRWllLEtBRG1GO1VBRXpGcmQsRUFBRSxFQUFFc2Q7U0FGQyxDQUFQO1FBS0EsSUFBSSxFQUFFOUIsaUJBQWlCLElBQUlnRCxtQkFBdkIsQ0FBSixFQUFpRDU3QixJQUFJLENBQUM0N0IsbUJBQUQsRUFBc0JoRCxpQkFBdEIsRUFBeUN5QixLQUF6QyxDQUFKO1FBRWpEejVCLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBVCxFQUFZb1EsSUFBWixFQUFrQnJCLEtBQWxCLENBQVA7UUFFQW1pQixVQUFVLENBQUM5Z0IsSUFBRCxDQUFWO1FBRUF4TixPQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZazVCLFVBQXpCLEVBQXFDL3JCLElBQXJDLEVBQTJDO1VBQUU5RCxHQUFHLEVBQUVEO1NBQWxELENBQVA7UUFFQXpKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBQ283QixpQkFBMUIsRUFBNkNqdUIsSUFBN0MsRUFBbUQ2c0IsVUFBbkQsQ0FBUDtRQUVBLElBQUksQ0FBQ3QzQixPQUFELElBQVlpNEIsbUJBQW1CLENBQUNoK0IsUUFBcEIsSUFBZ0M2N0IsYUFBaEQsRUFBK0RtQyxtQkFBbUIsQ0FBQ2grQixRQUFwQixHQUErQjY3QixhQUEvQjtRQUUvRDc0QixPQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ0ssQ0FBUixHQUFZc0ssS0FBSyxDQUFDLFlBQVk7VUFDaEQsSUFBSW13QixVQUFKLENBQWUsQ0FBZixFQUFrQjUzQixLQUFsQjtTQURtQyxDQUE5QixFQUVIc0ssSUFGRyxFQUVHO1VBQUV0SyxLQUFLLEVBQUVveUI7U0FGWixDQUFQO1FBSUF0MUIsT0FBTyxDQUFDQSxPQUFPLENBQUM1QyxDQUFSLEdBQVk0QyxPQUFPLENBQUNLLENBQVIsSUFBYXNLLEtBQUssQ0FBQyxZQUFZO1VBQ2pELE9BQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPb3VCLGNBQVAsTUFBMkIsSUFBSStCLFVBQUosQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWYsRUFBdUIvQixjQUF2QixFQUFsQztTQURvQyxDQUFMLElBRTNCLENBQUNwdUIsS0FBSyxDQUFDLFlBQVk7VUFDdkJxd0IsbUJBQW1CLENBQUNqQyxjQUFwQixDQUFtQ3A5QixJQUFuQyxDQUF3QyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQXhDO1NBRFUsQ0FGUSxDQUFiLEVBSUY2UixJQUpFLEVBSUk7VUFBRXVyQixjQUFjLEVBQUVpQjtTQUp0QixDQUFQO1FBTUEzaUIsU0FBUyxDQUFDN0osSUFBRCxDQUFULEdBQWtCaXVCLGlCQUFpQixHQUFHRCxlQUFILEdBQXFCRSxTQUF4RDtRQUNBLElBQUksQ0FBQzM0QixPQUFELElBQVksQ0FBQzA0QixpQkFBakIsRUFBb0NyOEIsSUFBSSxDQUFDNDdCLG1CQUFELEVBQXNCaGxCLFFBQXRCLEVBQWdDMGxCLFNBQWhDLENBQUo7T0F6SnRDO0tBblVGLE1BOGRPeGdDLGNBQUEsR0FBaUIsWUFBWTs7S0FBN0I7OztBQy9kUFksYUFBeUIsQ0FBQyxNQUFELEVBQVMsQ0FBVCxFQUFZLFVBQVU2L0IsSUFBVixFQUFnQjtJQUNuRCxPQUFPLFNBQVNDLFNBQVQsQ0FBbUIvcUIsSUFBbkIsRUFBeUJrakIsVUFBekIsRUFBcUN0MEIsTUFBckMsRUFBNkM7TUFDbEQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM0QsYUFBeUIsQ0FBQyxPQUFELEVBQVUsQ0FBVixFQUFhLFVBQVU2L0IsSUFBVixFQUFnQjtJQUNwRCxPQUFPLFNBQVM3RCxVQUFULENBQW9Cam5CLElBQXBCLEVBQTBCa2pCLFVBQTFCLEVBQXNDdDBCLE1BQXRDLEVBQThDO01BQ25ELE9BQU9rOEIsSUFBSSxDQUFDLElBQUQsRUFBTzlxQixJQUFQLEVBQWFrakIsVUFBYixFQUF5QnQwQixNQUF6QixDQUFYO0tBREY7RUFHRCxDQUp3QixDQUF6Qjs7QUNBQTNELGFBQXlCLENBQUMsT0FBRCxFQUFVLENBQVYsRUFBYSxVQUFVNi9CLElBQVYsRUFBZ0I7SUFDcEQsT0FBTyxTQUFTRSxpQkFBVCxDQUEyQmhyQixJQUEzQixFQUFpQ2tqQixVQUFqQyxFQUE2Q3QwQixNQUE3QyxFQUFxRDtNQUMxRCxPQUFPazhCLElBQUksQ0FBQyxJQUFELEVBQU85cUIsSUFBUCxFQUFha2pCLFVBQWIsRUFBeUJ0MEIsTUFBekIsQ0FBWDtLQURGO0VBR0QsQ0FKd0IsRUFJdEIsSUFKc0IsQ0FBekI7O0FDQUEzRCxhQUF5QixDQUFDLE9BQUQsRUFBVSxDQUFWLEVBQWEsVUFBVTYvQixJQUFWLEVBQWdCO0lBQ3BELE9BQU8sU0FBU0csVUFBVCxDQUFvQmpyQixJQUFwQixFQUEwQmtqQixVQUExQixFQUFzQ3QwQixNQUF0QyxFQUE4QztNQUNuRCxPQUFPazhCLElBQUksQ0FBQyxJQUFELEVBQU85cUIsSUFBUCxFQUFha2pCLFVBQWIsRUFBeUJ0MEIsTUFBekIsQ0FBWDtLQURGO0VBR0QsQ0FKd0IsQ0FBekI7O0FDQUEzRCxhQUF5QixDQUFDLFFBQUQsRUFBVyxDQUFYLEVBQWMsVUFBVTYvQixJQUFWLEVBQWdCO0lBQ3JELE9BQU8sU0FBU3JDLFdBQVQsQ0FBcUJ6b0IsSUFBckIsRUFBMkJrakIsVUFBM0IsRUFBdUN0MEIsTUFBdkMsRUFBK0M7TUFDcEQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM0QsYUFBeUIsQ0FBQyxPQUFELEVBQVUsQ0FBVixFQUFhLFVBQVU2L0IsSUFBVixFQUFnQjtJQUNwRCxPQUFPLFNBQVNJLFVBQVQsQ0FBb0JsckIsSUFBcEIsRUFBMEJrakIsVUFBMUIsRUFBc0N0MEIsTUFBdEMsRUFBOEM7TUFDbkQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM0QsYUFBeUIsQ0FBQyxRQUFELEVBQVcsQ0FBWCxFQUFjLFVBQVU2L0IsSUFBVixFQUFnQjtJQUNyRCxPQUFPLFNBQVNLLFdBQVQsQ0FBcUJuckIsSUFBckIsRUFBMkJrakIsVUFBM0IsRUFBdUN0MEIsTUFBdkMsRUFBK0M7TUFDcEQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM0QsYUFBeUIsQ0FBQyxTQUFELEVBQVksQ0FBWixFQUFlLFVBQVU2L0IsSUFBVixFQUFnQjtJQUN0RCxPQUFPLFNBQVNNLFlBQVQsQ0FBc0JwckIsSUFBdEIsRUFBNEJrakIsVUFBNUIsRUFBd0N0MEIsTUFBeEMsRUFBZ0Q7TUFDckQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztBQ0FBM0QsYUFBeUIsQ0FBQyxTQUFELEVBQVksQ0FBWixFQUFlLFVBQVU2L0IsSUFBVixFQUFnQjtJQUN0RCxPQUFPLFNBQVNPLFlBQVQsQ0FBc0JyckIsSUFBdEIsRUFBNEJrakIsVUFBNUIsRUFBd0N0MEIsTUFBeEMsRUFBZ0Q7TUFDckQsT0FBT2s4QixJQUFJLENBQUMsSUFBRCxFQUFPOXFCLElBQVAsRUFBYWtqQixVQUFiLEVBQXlCdDBCLE1BQXpCLENBQVg7S0FERjtFQUdELENBSndCLENBQXpCOztFQ0lBLElBQUkwOEIsTUFBTSxHQUFHLENBQUNyZ0MsT0FBb0IsQ0FBQ3NnQyxPQUFyQixJQUFnQyxFQUFqQyxFQUFxQ3Y4QixLQUFsRDtFQUNBLElBQUl3OEIsTUFBTSxHQUFHL2dDLFFBQVEsQ0FBQ3VFLEtBQXRCOztBQUVBRyxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZLENBQUMxRCxNQUFtQixDQUFDLFlBQVk7SUFDL0R3L0IsTUFBTSxDQUFDLFlBQVk7O0tBQWIsQ0FBTjtFQUNELENBRm1ELENBQTdDLEVBRUgsU0FGRyxFQUVRO0lBQ2J0OEIsS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZWUsTUFBZixFQUF1QjA3QixZQUF2QixFQUFxQ0MsYUFBckMsRUFBb0Q7TUFDekQsSUFBSXp3QixDQUFDLEdBQUdwTSxVQUFTLENBQUNrQixNQUFELENBQWpCO01BQ0EsSUFBSTQ3QixDQUFDLEdBQUdsL0IsU0FBUSxDQUFDaS9CLGFBQUQsQ0FBaEI7TUFDQSxPQUFPSixNQUFNLEdBQUdBLE1BQU0sQ0FBQ3J3QixDQUFELEVBQUl3d0IsWUFBSixFQUFrQkUsQ0FBbEIsQ0FBVCxHQUFnQ0gsTUFBTSxDQUFDMWdDLElBQVAsQ0FBWW1RLENBQVosRUFBZXd3QixZQUFmLEVBQTZCRSxDQUE3QixDQUE3Qzs7RUFKVyxDQUZSLENBQVA7O0VDQ0EsSUFBSUMsVUFBVSxHQUFHLENBQUMzZ0MsT0FBb0IsQ0FBQ3NnQyxPQUFyQixJQUFnQyxFQUFqQyxFQUFxQ3J2QixTQUF0RDtFQUdBOztFQUNBLElBQUkydkIsY0FBYyxHQUFHL3hCLE1BQUssQ0FBQyxZQUFZO0lBQ3JDLFNBQVN0SyxDQUFULEdBQWE7Ozs7SUFDYixPQUFPLEVBQUVvOEIsVUFBVSxDQUFDLFlBQVk7O0tBQWIsRUFBOEIsRUFBOUIsRUFBa0NwOEIsQ0FBbEMsQ0FBVixZQUEwREEsQ0FBNUQsQ0FBUDtFQUNELENBSHlCLENBQTFCO0VBSUEsSUFBSXM4QixRQUFRLEdBQUcsQ0FBQ2h5QixNQUFLLENBQUMsWUFBWTtJQUNoQzh4QixVQUFVLENBQUMsWUFBWTs7S0FBYixDQUFWO0VBQ0QsQ0FGb0IsQ0FBckI7QUFJQXo4QixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixJQUFhcThCLGNBQWMsSUFBSUMsUUFBL0IsQ0FBYixFQUF1RCxTQUF2RCxFQUFrRTtJQUN2RTV2QixTQUFTLEVBQUUsU0FBU0EsU0FBVCxDQUFtQjZ2QixNQUFuQixFQUEyQnR5Qjs7TUFBd0I7TUFDNUQ1SyxVQUFTLENBQUNrOUIsTUFBRCxDQUFUO01BQ0F0L0IsU0FBUSxDQUFDZ04sSUFBRCxDQUFSO01BQ0EsSUFBSXV5QixTQUFTLEdBQUcvOEIsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCbTlCLE1BQXZCLEdBQWdDbDlCLFVBQVMsQ0FBQ0ksU0FBUyxDQUFDLENBQUQsQ0FBVixDQUF6RDtNQUNBLElBQUk2OEIsUUFBUSxJQUFJLENBQUNELGNBQWpCLEVBQWlDLE9BQU9ELFVBQVUsQ0FBQ0csTUFBRCxFQUFTdHlCLElBQVQsRUFBZXV5QixTQUFmLENBQWpCOztNQUNqQyxJQUFJRCxNQUFNLElBQUlDLFNBQWQsRUFBeUI7O1FBRXZCLFFBQVF2eUIsSUFBSSxDQUFDN0ssTUFBYjtVQUNFLEtBQUssQ0FBTDtZQUFRLE9BQU8sSUFBSW05QixNQUFKLEVBQVA7O1VBQ1IsS0FBSyxDQUFMO1lBQVEsT0FBTyxJQUFJQSxNQUFKLENBQVd0eUIsSUFBSSxDQUFDLENBQUQsQ0FBZixDQUFQOztVQUNSLEtBQUssQ0FBTDtZQUFRLE9BQU8sSUFBSXN5QixNQUFKLENBQVd0eUIsSUFBSSxDQUFDLENBQUQsQ0FBZixFQUFvQkEsSUFBSSxDQUFDLENBQUQsQ0FBeEIsQ0FBUDs7VUFDUixLQUFLLENBQUw7WUFBUSxPQUFPLElBQUlzeUIsTUFBSixDQUFXdHlCLElBQUksQ0FBQyxDQUFELENBQWYsRUFBb0JBLElBQUksQ0FBQyxDQUFELENBQXhCLEVBQTZCQSxJQUFJLENBQUMsQ0FBRCxDQUFqQyxDQUFQOztVQUNSLEtBQUssQ0FBTDtZQUFRLE9BQU8sSUFBSXN5QixNQUFKLENBQVd0eUIsSUFBSSxDQUFDLENBQUQsQ0FBZixFQUFvQkEsSUFBSSxDQUFDLENBQUQsQ0FBeEIsRUFBNkJBLElBQUksQ0FBQyxDQUFELENBQWpDLEVBQXNDQSxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFQO1NBUGE7OztRQVV2QixJQUFJd3lCLEtBQUssR0FBRyxDQUFDLElBQUQsQ0FBWjtRQUNBQSxLQUFLLENBQUN0K0IsSUFBTixDQUFXcUIsS0FBWCxDQUFpQmk5QixLQUFqQixFQUF3Qnh5QixJQUF4QjtRQUNBLE9BQU8sS0FBSzRDLEtBQUksQ0FBQ3JOLEtBQUwsQ0FBVys4QixNQUFYLEVBQW1CRSxLQUFuQixDQUFMLEdBQVA7T0FqQjBEOzs7TUFvQjVELElBQUkzd0IsS0FBSyxHQUFHMHdCLFNBQVMsQ0FBQ3Q5QixTQUF0QjtNQUNBLElBQUlvdkIsUUFBUSxHQUFHM3NCLGFBQU0sQ0FBQzFGLFNBQVEsQ0FBQzZQLEtBQUQsQ0FBUixHQUFrQkEsS0FBbEIsR0FBMEJwUSxNQUFNLENBQUN3RCxTQUFsQyxDQUFyQjtNQUNBLElBQUlrRixNQUFNLEdBQUduSixRQUFRLENBQUN1RSxLQUFULENBQWVsRSxJQUFmLENBQW9CaWhDLE1BQXBCLEVBQTRCak8sUUFBNUIsRUFBc0Nya0IsSUFBdEMsQ0FBYjtNQUNBLE9BQU9oTyxTQUFRLENBQUNtSSxNQUFELENBQVIsR0FBbUJBLE1BQW5CLEdBQTRCa3FCLFFBQW5DOztFQXhCcUUsQ0FBbEUsQ0FBUDs7RUNkQTs7QUFDQTN1QixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWW1ELE9BQU8sQ0FBQ0ssQ0FBUixHQUFZdkUsTUFBbUIsQ0FBQyxZQUFZOztJQUU5RHNnQyxPQUFPLENBQUNwZ0MsY0FBUixDQUF1QmtCLFNBQUUsQ0FBQ2EsQ0FBSCxDQUFLLEVBQUwsRUFBUyxDQUFULEVBQVk7TUFBRU4sS0FBSyxFQUFFO0tBQXJCLENBQXZCLEVBQWtELENBQWxELEVBQXFEO01BQUVBLEtBQUssRUFBRTtLQUE5RDtFQUNELENBSGtELENBQTVDLEVBR0gsU0FIRyxFQUdRO0lBQ2J6QixjQUFjLEVBQUUsU0FBU0EsY0FBVCxDQUF3QjRFLE1BQXhCLEVBQWdDbThCLFdBQWhDLEVBQTZDQyxVQUE3QyxFQUF5RDtNQUN2RTEvQixTQUFRLENBQUNzRCxNQUFELENBQVI7TUFDQW04QixXQUFXLEdBQUd4L0IsWUFBVyxDQUFDdy9CLFdBQUQsRUFBYyxJQUFkLENBQXpCO01BQ0F6L0IsU0FBUSxDQUFDMC9CLFVBQUQsQ0FBUjs7TUFDQSxJQUFJO1FBQ0Y5L0IsU0FBRSxDQUFDYSxDQUFILENBQUs2QyxNQUFMLEVBQWFtOEIsV0FBYixFQUEwQkMsVUFBMUI7UUFDQSxPQUFPLElBQVA7T0FGRixDQUdFLE9BQU9uaEMsQ0FBUCxFQUFVO1FBQ1YsT0FBTyxLQUFQOzs7RUFUUyxDQUhSLENBQVA7O0VDTEEsSUFBSWlMLE1BQUksR0FBR2hMLFdBQXlCLENBQUNpQyxDQUFyQztBQUdBaUMsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksU0FBWixFQUF1QjtJQUM1Qm9nQyxjQUFjLEVBQUUsU0FBU0EsY0FBVCxDQUF3QnI4QixNQUF4QixFQUFnQ204QixXQUFoQyxFQUE2QztNQUMzRCxJQUFJdEMsSUFBSSxHQUFHM3pCLE1BQUksQ0FBQ3hKLFNBQVEsQ0FBQ3NELE1BQUQsQ0FBVCxFQUFtQm04QixXQUFuQixDQUFmO01BQ0EsT0FBT3RDLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUM3OEIsWUFBZCxHQUE2QixLQUE3QixHQUFxQyxPQUFPZ0QsTUFBTSxDQUFDbThCLFdBQUQsQ0FBekQ7O0VBSDBCLENBQXZCLENBQVA7O0VDREEsSUFBSUcsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBVTNsQixRQUFWLEVBQW9CO0lBQ2xDLEtBQUtDLEVBQUwsR0FBVWxhLFNBQVEsQ0FBQ2lhLFFBQUQsQ0FBbEIsQ0FEa0M7O0lBRWxDLEtBQUtFLEVBQUwsR0FBVSxDQUFWLENBRmtDOztJQUdsQyxJQUFJL1MsSUFBSSxHQUFHLEtBQUtpRSxFQUFMLEdBQVUsRUFBckIsQ0FIa0M7O0lBSWxDLElBQUlqTixHQUFKOztJQUNBLEtBQUtBLEdBQUwsSUFBWTZiLFFBQVo7TUFBc0I3UyxJQUFJLENBQUNsRyxJQUFMLENBQVU5QyxHQUFWOztFQUN2QixDQU5EOztBQU9BSSxhQUF5QixDQUFDb2hDLFNBQUQsRUFBWSxRQUFaLEVBQXNCLFlBQVk7SUFDekQsSUFBSTE5QixJQUFJLEdBQUcsSUFBWDtJQUNBLElBQUlrRixJQUFJLEdBQUdsRixJQUFJLENBQUNtSixFQUFoQjtJQUNBLElBQUlqTixHQUFKOztJQUNBLEdBQUc7TUFDRCxJQUFJOEQsSUFBSSxDQUFDaVksRUFBTCxJQUFXL1MsSUFBSSxDQUFDakYsTUFBcEIsRUFBNEIsT0FBTztRQUFFaEMsS0FBSyxFQUFFWSxTQUFUO1FBQW9Cc1osSUFBSSxFQUFFO09BQWpDO0tBRDlCLFFBRVMsRUFBRSxDQUFDamMsR0FBRyxHQUFHZ0osSUFBSSxDQUFDbEYsSUFBSSxDQUFDaVksRUFBTCxFQUFELENBQVgsS0FBMkJqWSxJQUFJLENBQUNnWSxFQUFsQyxDQUZUOztJQUdBLE9BQU87TUFBRS9aLEtBQUssRUFBRS9CLEdBQVQ7TUFBY2ljLElBQUksRUFBRTtLQUEzQjtFQUNELENBUndCLENBQXpCO0FBVUEzWCxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxTQUFaLEVBQXVCO0lBQzVCc2dDLFNBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CdjhCLE1BQW5CLEVBQTJCO01BQ3BDLE9BQU8sSUFBSXM4QixTQUFKLENBQWN0OEIsTUFBZCxDQUFQOztFQUYwQixDQUF2QixDQUFQOztFQ2JBLFNBQVMzRSxHQUFULENBQWEyRSxNQUFiLEVBQXFCbThCOztFQUFyQixFQUFtRDtJQUNqRCxJQUFJSyxRQUFRLEdBQUd0OUIsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCbUIsTUFBdkIsR0FBZ0NkLFNBQVMsQ0FBQyxDQUFELENBQXhEO0lBQ0EsSUFBSTI2QixJQUFKLEVBQVV0dUIsS0FBVjtJQUNBLElBQUk3TyxTQUFRLENBQUNzRCxNQUFELENBQVIsS0FBcUJ3OEIsUUFBekIsRUFBbUMsT0FBT3g4QixNQUFNLENBQUNtOEIsV0FBRCxDQUFiO0lBQ25DLElBQUl0QyxJQUFJLEdBQUczekIsV0FBSSxDQUFDL0ksQ0FBTCxDQUFPNkMsTUFBUCxFQUFlbThCLFdBQWYsQ0FBWCxFQUF3QyxPQUFPNTlCLElBQUcsQ0FBQ3M3QixJQUFELEVBQU8sT0FBUCxDQUFILEdBQzNDQSxJQUFJLENBQUNoOUIsS0FEc0MsR0FFM0NnOUIsSUFBSSxDQUFDeCtCLEdBQUwsS0FBYW9DLFNBQWIsR0FDRW84QixJQUFJLENBQUN4K0IsR0FBTCxDQUFTTixJQUFULENBQWN5aEMsUUFBZCxDQURGLEdBRUUvK0IsU0FKa0M7SUFLeEMsSUFBSS9CLFNBQVEsQ0FBQzZQLEtBQUssR0FBR3ZCLFVBQWMsQ0FBQ2hLLE1BQUQsQ0FBdkIsQ0FBWixFQUE4QyxPQUFPM0UsR0FBRyxDQUFDa1EsS0FBRCxFQUFRNHdCLFdBQVIsRUFBcUJLLFFBQXJCLENBQVY7RUFDL0M7O0FBRURwOUIsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksU0FBWixFQUF1QjtJQUFFWixHQUFHLEVBQUVBO0VBQVAsQ0FBdkIsQ0FBUDs7QUNmQStELFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFNBQVosRUFBdUI7SUFDNUJrSyx3QkFBd0IsRUFBRSxTQUFTQSx3QkFBVCxDQUFrQ25HLE1BQWxDLEVBQTBDbThCLFdBQTFDLEVBQXVEO01BQy9FLE9BQU9qMkIsV0FBSSxDQUFDL0ksQ0FBTCxDQUFPVCxTQUFRLENBQUNzRCxNQUFELENBQWYsRUFBeUJtOEIsV0FBekIsQ0FBUDs7RUFGMEIsQ0FBdkIsQ0FBUDs7QUNBQS84QixTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxTQUFaLEVBQXVCO0lBQzVCK04sY0FBYyxFQUFFLFNBQVNBLGNBQVQsQ0FBd0JoSyxNQUF4QixFQUFnQztNQUM5QyxPQUFPeThCLFVBQVEsQ0FBQy8vQixTQUFRLENBQUNzRCxNQUFELENBQVQsQ0FBZjs7RUFGMEIsQ0FBdkIsQ0FBUDs7QUNGQVosU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksU0FBWixFQUF1QjtJQUM1QnNDLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWF5QixNQUFiLEVBQXFCbThCLFdBQXJCLEVBQWtDO01BQ3JDLE9BQU9BLFdBQVcsSUFBSW44QixNQUF0Qjs7RUFGMEIsQ0FBdkIsQ0FBUDs7RUNBQSxJQUFJNEssYUFBYSxHQUFHelAsTUFBTSxDQUFDMEYsWUFBM0I7QUFFQXpCLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFNBQVosRUFBdUI7SUFDNUI0RSxZQUFZLEVBQUUsU0FBU0EsWUFBVCxDQUFzQmIsTUFBdEIsRUFBOEI7TUFDMUN0RCxTQUFRLENBQUNzRCxNQUFELENBQVI7TUFDQSxPQUFPNEssYUFBYSxHQUFHQSxhQUFhLENBQUM1SyxNQUFELENBQWhCLEdBQTJCLElBQS9DOztFQUgwQixDQUF2QixDQUFQOztFQ0RBLElBQUl3N0IsU0FBTyxHQUFHdGdDLE9BQW9CLENBQUNzZ0MsT0FBbkM7O0VBQ0EsWUFBYyxHQUFHQSxTQUFPLElBQUlBLFNBQU8sQ0FBQ2tCLE9BQW5CLElBQThCLFNBQVNBLE9BQVQsQ0FBaUI3aEMsRUFBakIsRUFBcUI7SUFDbEUsSUFBSWlKLElBQUksR0FBR2lDLFdBQUksQ0FBQzVJLENBQUwsQ0FBT1QsU0FBUSxDQUFDN0IsRUFBRCxDQUFmLENBQVg7SUFDQSxJQUFJc0osVUFBVSxHQUFHQyxXQUFJLENBQUNqSCxDQUF0QjtJQUNBLE9BQU9nSCxVQUFVLEdBQUdMLElBQUksQ0FBQ3RHLE1BQUwsQ0FBWTJHLFVBQVUsQ0FBQ3RKLEVBQUQsQ0FBdEIsQ0FBSCxHQUFpQ2lKLElBQWxEO0VBQ0QsQ0FKRDs7QUNGQTFFLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFNBQVosRUFBdUI7SUFBRXlnQyxPQUFPLEVBQUV4aEM7RUFBWCxDQUF2QixDQUFQOztFQ0FBLElBQUlxUCxrQkFBa0IsR0FBR3BQLE1BQU0sQ0FBQzRGLGlCQUFoQztBQUVBM0IsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksU0FBWixFQUF1QjtJQUM1QjhFLGlCQUFpQixFQUFFLFNBQVNBLGlCQUFULENBQTJCZixNQUEzQixFQUFtQztNQUNwRHRELFNBQVEsQ0FBQ3NELE1BQUQsQ0FBUjs7TUFDQSxJQUFJO1FBQ0YsSUFBSXVLLGtCQUFKLEVBQXdCQSxrQkFBa0IsQ0FBQ3ZLLE1BQUQsQ0FBbEI7UUFDeEIsT0FBTyxJQUFQO09BRkYsQ0FHRSxPQUFPL0UsQ0FBUCxFQUFVO1FBQ1YsT0FBTyxLQUFQOzs7RUFQd0IsQ0FBdkIsQ0FBUDs7RUNLQSxTQUFTNk4sR0FBVCxDQUFhOUksTUFBYixFQUFxQm04QixXQUFyQixFQUFrQ1E7O0VBQWxDLEVBQXNEO0lBQ3BELElBQUlILFFBQVEsR0FBR3Q5QixTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJtQixNQUF2QixHQUFnQ2QsU0FBUyxDQUFDLENBQUQsQ0FBeEQ7SUFDQSxJQUFJMDlCLE9BQU8sR0FBRzEyQixXQUFJLENBQUMvSSxDQUFMLENBQU9ULFNBQVEsQ0FBQ3NELE1BQUQsQ0FBZixFQUF5Qm04QixXQUF6QixDQUFkO0lBQ0EsSUFBSVUsa0JBQUosRUFBd0J0eEIsS0FBeEI7O0lBQ0EsSUFBSSxDQUFDcXhCLE9BQUwsRUFBYztNQUNaLElBQUlsaEMsU0FBUSxDQUFDNlAsS0FBSyxHQUFHdkIsVUFBYyxDQUFDaEssTUFBRCxDQUF2QixDQUFaLEVBQThDO1FBQzVDLE9BQU84SSxHQUFHLENBQUN5QyxLQUFELEVBQVE0d0IsV0FBUixFQUFxQlEsQ0FBckIsRUFBd0JILFFBQXhCLENBQVY7OztNQUVGSSxPQUFPLEdBQUd4L0IsYUFBVSxDQUFDLENBQUQsQ0FBcEI7OztJQUVGLElBQUltQixJQUFHLENBQUNxK0IsT0FBRCxFQUFVLE9BQVYsQ0FBUCxFQUEyQjtNQUN6QixJQUFJQSxPQUFPLENBQUMzL0IsUUFBUixLQUFxQixLQUFyQixJQUE4QixDQUFDdkIsU0FBUSxDQUFDOGdDLFFBQUQsQ0FBM0MsRUFBdUQsT0FBTyxLQUFQOztNQUN2RCxJQUFJSyxrQkFBa0IsR0FBRzMyQixXQUFJLENBQUMvSSxDQUFMLENBQU9xL0IsUUFBUCxFQUFpQkwsV0FBakIsQ0FBekIsRUFBd0Q7UUFDdEQsSUFBSVUsa0JBQWtCLENBQUN4aEMsR0FBbkIsSUFBMEJ3aEMsa0JBQWtCLENBQUMvekIsR0FBN0MsSUFBb0QrekIsa0JBQWtCLENBQUM1L0IsUUFBbkIsS0FBZ0MsS0FBeEYsRUFBK0YsT0FBTyxLQUFQO1FBQy9GNC9CLGtCQUFrQixDQUFDaGdDLEtBQW5CLEdBQTJCOC9CLENBQTNCO1FBQ0FyZ0MsU0FBRSxDQUFDYSxDQUFILENBQUtxL0IsUUFBTCxFQUFlTCxXQUFmLEVBQTRCVSxrQkFBNUI7T0FIRixNQUlPdmdDLFNBQUUsQ0FBQ2EsQ0FBSCxDQUFLcS9CLFFBQUwsRUFBZUwsV0FBZixFQUE0Qi8rQixhQUFVLENBQUMsQ0FBRCxFQUFJdS9CLENBQUosQ0FBdEM7O01BQ1AsT0FBTyxJQUFQOzs7SUFFRixPQUFPQyxPQUFPLENBQUM5ekIsR0FBUixLQUFnQnJMLFNBQWhCLEdBQTRCLEtBQTVCLElBQXFDbS9CLE9BQU8sQ0FBQzl6QixHQUFSLENBQVkvTixJQUFaLENBQWlCeWhDLFFBQWpCLEVBQTJCRyxDQUEzQixHQUErQixJQUFwRSxDQUFQO0VBQ0Q7O0FBRUR2OUIsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksU0FBWixFQUF1QjtJQUFFNk0sR0FBRyxFQUFFQTtFQUFQLENBQXZCLENBQVA7O0VDNUJBLElBQUlnMEIsU0FBSixFQUFjMTlCLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDbkQsQ0FBVCxFQUFZLFNBQVosRUFBdUI7SUFDMUN1UCxjQUFjLEVBQUUsU0FBU0EsY0FBVCxDQUF3QnhMLE1BQXhCLEVBQWdDdUwsS0FBaEMsRUFBdUM7TUFDckR1eEIsU0FBUSxDQUFDeHhCLEtBQVQsQ0FBZXRMLE1BQWYsRUFBdUJ1TCxLQUF2Qjs7TUFDQSxJQUFJO1FBQ0Z1eEIsU0FBUSxDQUFDaDBCLEdBQVQsQ0FBYTlJLE1BQWIsRUFBcUJ1TCxLQUFyQjtRQUNBLE9BQU8sSUFBUDtPQUZGLENBR0UsT0FBT3RRLENBQVAsRUFBVTtRQUNWLE9BQU8sS0FBUDs7O0VBUHNDLENBQXZCLENBQVA7O0VDRGQsSUFBSThoQyxTQUFTLEdBQUc3aEMsY0FBNEIsQ0FBQyxJQUFELENBQTVDO0FBRUFrRSxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVQsRUFBWSxPQUFaLEVBQXFCO0lBQzFCcWIsUUFBUSxFQUFFLFNBQVNBLFFBQVQsQ0FBa0J6VTs7TUFBMEI7TUFDcEQsT0FBTzI1QixTQUFTLENBQUMsSUFBRCxFQUFPMzVCLEVBQVAsRUFBV2xFLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUFuQixHQUF1QkssU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0N6QixTQUFqRCxDQUFoQjs7RUFGd0IsQ0FBckIsQ0FBUDtBQU1BMUIsbUJBQWdDLENBQUMsVUFBRCxDQUFoQzs7RUNWQSxZQUFjLEdBQUdBLEtBQThCLENBQUN5SSxLQUEvQixDQUFxQ3FULFFBQXREOztFQ0tBLElBQUltbEIsb0JBQW9CLEdBQUc5aEMsSUFBaUIsQ0FBQyxvQkFBRCxDQUE1Qzs7RUFFQSxTQUFTK2hDLGdCQUFULENBQTBCajlCLE1BQTFCLEVBQWtDMGMsUUFBbEMsRUFBNENuZCxNQUE1QyxFQUFvRDI5QixTQUFwRCxFQUErRC9nQixLQUEvRCxFQUFzRWdoQixLQUF0RSxFQUE2RUMsTUFBN0UsRUFBcUZDLE9BQXJGLEVBQThGO0lBQzVGLElBQUlDLFdBQVcsR0FBR25oQixLQUFsQjtJQUNBLElBQUlvaEIsV0FBVyxHQUFHLENBQWxCO0lBQ0EsSUFBSUMsS0FBSyxHQUFHSixNQUFNLEdBQUc5OEIsSUFBRyxDQUFDODhCLE1BQUQsRUFBU0MsT0FBVCxFQUFrQixDQUFsQixDQUFOLEdBQTZCLEtBQS9DO0lBQ0EsSUFBSUksT0FBSixFQUFhQyxVQUFiOztJQUVBLE9BQU9ILFdBQVcsR0FBR0wsU0FBckIsRUFBZ0M7TUFDOUIsSUFBSUssV0FBVyxJQUFJaCtCLE1BQW5CLEVBQTJCO1FBQ3pCaytCLE9BQU8sR0FBR0QsS0FBSyxHQUFHQSxLQUFLLENBQUNqK0IsTUFBTSxDQUFDZytCLFdBQUQsQ0FBUCxFQUFzQkEsV0FBdEIsRUFBbUM3Z0IsUUFBbkMsQ0FBUixHQUF1RG5kLE1BQU0sQ0FBQ2crQixXQUFELENBQTVFO1FBRUFHLFVBQVUsR0FBRyxLQUFiOztRQUNBLElBQUloaUMsU0FBUSxDQUFDK2hDLE9BQUQsQ0FBWixFQUF1QjtVQUNyQkMsVUFBVSxHQUFHRCxPQUFPLENBQUNULG9CQUFELENBQXBCO1VBQ0FVLFVBQVUsR0FBR0EsVUFBVSxLQUFLamdDLFNBQWYsR0FBMkIsQ0FBQyxDQUFDaWdDLFVBQTdCLEdBQTBDajVCLFFBQU8sQ0FBQ2c1QixPQUFELENBQTlEOzs7UUFHRixJQUFJQyxVQUFVLElBQUlQLEtBQUssR0FBRyxDQUExQixFQUE2QjtVQUMzQkcsV0FBVyxHQUFHTCxnQkFBZ0IsQ0FBQ2o5QixNQUFELEVBQVMwYyxRQUFULEVBQW1CK2dCLE9BQW5CLEVBQTRCbDZCLFNBQVEsQ0FBQ2s2QixPQUFPLENBQUM1K0IsTUFBVCxDQUFwQyxFQUFzRHkrQixXQUF0RCxFQUFtRUgsS0FBSyxHQUFHLENBQTNFLENBQWhCLEdBQWdHLENBQTlHO1NBREYsTUFFTztVQUNMLElBQUlHLFdBQVcsSUFBSSxnQkFBbkIsRUFBcUMsTUFBTTNoQyxTQUFTLEVBQWY7VUFDckNxRSxNQUFNLENBQUNzOUIsV0FBRCxDQUFOLEdBQXNCRyxPQUF0Qjs7O1FBR0ZILFdBQVc7OztNQUViQyxXQUFXOzs7SUFFYixPQUFPRCxXQUFQO0VBQ0Q7O0VBRUQscUJBQWMsR0FBR0wsZ0JBQWpCOztBQzdCQTc5QixTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVQsRUFBWSxPQUFaLEVBQXFCO0lBQzFCbWhDLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCeGdCOztNQUE0QjtNQUNwRCxJQUFJNWdCLENBQUMsR0FBR2tOLFNBQVEsQ0FBQyxJQUFELENBQWhCO01BQ0EsSUFBSXl6QixTQUFKLEVBQWVueUIsQ0FBZjtNQUNBak0sVUFBUyxDQUFDcWUsVUFBRCxDQUFUO01BQ0ErZixTQUFTLEdBQUczNUIsU0FBUSxDQUFDaEgsQ0FBQyxDQUFDc0MsTUFBSCxDQUFwQjtNQUNBa00sQ0FBQyxHQUFHNnlCLG1CQUFrQixDQUFDcmhDLENBQUQsRUFBSSxDQUFKLENBQXRCO01BQ0EwZ0MsaUJBQWdCLENBQUNseUIsQ0FBRCxFQUFJeE8sQ0FBSixFQUFPQSxDQUFQLEVBQVUyZ0MsU0FBVixFQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQi9mLFVBQTNCLEVBQXVDamUsU0FBUyxDQUFDLENBQUQsQ0FBaEQsQ0FBaEI7TUFDQSxPQUFPNkwsQ0FBUDs7RUFSd0IsQ0FBckIsQ0FBUDtBQVlBN1AsbUJBQWdDLENBQUMsU0FBRCxDQUFoQzs7RUNwQkEsV0FBYyxHQUFHYSxLQUE4QixDQUFDeUksS0FBL0IsQ0FBcUNtNUIsT0FBdEQ7O0VDSUEsY0FBYyxHQUFHLG1CQUFBLENBQVUvK0IsSUFBVixFQUFnQmkvQixTQUFoQixFQUEyQkMsVUFBM0IsRUFBdUNDLElBQXZDLEVBQTZDO0lBQzVELElBQUk5aEMsQ0FBQyxHQUFHeUMsTUFBTSxDQUFDZ0UsUUFBTyxDQUFDOUQsSUFBRCxDQUFSLENBQWQ7SUFDQSxJQUFJby9CLFlBQVksR0FBRy9oQyxDQUFDLENBQUM0QyxNQUFyQjtJQUNBLElBQUlvL0IsT0FBTyxHQUFHSCxVQUFVLEtBQUtyZ0MsU0FBZixHQUEyQixHQUEzQixHQUFpQ2lCLE1BQU0sQ0FBQ28vQixVQUFELENBQXJEO0lBQ0EsSUFBSUksWUFBWSxHQUFHMzZCLFNBQVEsQ0FBQ3M2QixTQUFELENBQTNCO0lBQ0EsSUFBSUssWUFBWSxJQUFJRixZQUFoQixJQUFnQ0MsT0FBTyxJQUFJLEVBQS9DLEVBQW1ELE9BQU9oaUMsQ0FBUDtJQUNuRCxJQUFJa2lDLE9BQU8sR0FBR0QsWUFBWSxHQUFHRixZQUE3QjtJQUNBLElBQUlJLFlBQVksR0FBR3p1QixhQUFNLENBQUM1VSxJQUFQLENBQVlrakMsT0FBWixFQUFxQnpqQyxJQUFJLENBQUNtSSxJQUFMLENBQVV3N0IsT0FBTyxHQUFHRixPQUFPLENBQUNwL0IsTUFBNUIsQ0FBckIsQ0FBbkI7SUFDQSxJQUFJdS9CLFlBQVksQ0FBQ3YvQixNQUFiLEdBQXNCcy9CLE9BQTFCLEVBQW1DQyxZQUFZLEdBQUdBLFlBQVksQ0FBQzk3QixLQUFiLENBQW1CLENBQW5CLEVBQXNCNjdCLE9BQXRCLENBQWY7SUFDbkMsT0FBT0osSUFBSSxHQUFHSyxZQUFZLEdBQUduaUMsQ0FBbEIsR0FBc0JBLENBQUMsR0FBR21pQyxZQUFyQztFQUNELENBVkQ7O0VDQ0E7OztFQUNBLElBQUlDLFVBQVUsR0FBRyxtREFBbUQ1eUIsSUFBbkQsQ0FBd0R3ZCxVQUF4RCxDQUFqQjtBQUVBN3BCLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLEdBQVk0K0IsVUFBekIsRUFBcUMsUUFBckMsRUFBK0M7SUFDcERDLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCVDs7TUFBb0M7TUFDOUQsT0FBT1UsVUFBSSxDQUFDLElBQUQsRUFBT1YsU0FBUCxFQUFrQjMrQixTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBeEQsRUFBbUUsSUFBbkUsQ0FBWDs7RUFGa0QsQ0FBL0MsQ0FBUDs7RUNSQSxZQUFjLEdBQUcxQixLQUE4QixDQUFDMkMsTUFBL0IsQ0FBc0M0L0IsUUFBdkQ7O0VDS0E7OztFQUNBLElBQUlELFlBQVUsR0FBRyxtREFBbUQ1eUIsSUFBbkQsQ0FBd0R3ZCxVQUF4RCxDQUFqQjtBQUVBN3BCLFNBQU8sQ0FBQ0EsT0FBTyxDQUFDNUMsQ0FBUixHQUFZNEMsT0FBTyxDQUFDSyxDQUFSLEdBQVk0K0IsWUFBekIsRUFBcUMsUUFBckMsRUFBK0M7SUFDcERHLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCWDs7TUFBb0M7TUFDMUQsT0FBT1UsVUFBSSxDQUFDLElBQUQsRUFBT1YsU0FBUCxFQUFrQjMrQixTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJLLFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDekIsU0FBeEQsRUFBbUUsS0FBbkUsQ0FBWDs7RUFGa0QsQ0FBL0MsQ0FBUDs7RUNSQSxVQUFjLEdBQUcxQixLQUE4QixDQUFDMkMsTUFBL0IsQ0FBc0M4L0IsTUFBdkQ7O0FDQ0F0akMsYUFBeUIsQ0FBQyxVQUFELEVBQWEsVUFBVTZTLEtBQVYsRUFBaUI7SUFDckQsT0FBTyxTQUFTMHdCLFFBQVQsR0FBb0I7TUFDekIsT0FBTzF3QixLQUFLLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBWjtLQURGO0VBR0QsQ0FKd0IsRUFJdEIsV0FKc0IsQ0FBekI7O0VDREEsYUFBYyxHQUFHaFMsS0FBOEIsQ0FBQzJDLE1BQS9CLENBQXNDKy9CLFFBQXZEOztBQ0NBdmpDLGFBQXlCLENBQUMsV0FBRCxFQUFjLFVBQVU2UyxLQUFWLEVBQWlCO0lBQ3RELE9BQU8sU0FBUzJ3QixTQUFULEdBQXFCO01BQzFCLE9BQU8zd0IsS0FBSyxDQUFDLElBQUQsRUFBTyxDQUFQLENBQVo7S0FERjtFQUdELENBSndCLEVBSXRCLFNBSnNCLENBQXpCOztFQ0RBLFdBQWMsR0FBR2hTLEtBQThCLENBQUMyQyxNQUEvQixDQUFzQ2dnQyxTQUF2RDs7QUNEQXhqQyxZQUF3QixDQUFDLGVBQUQsQ0FBeEI7O0VDQ0EsaUJBQWMsR0FBR2EsT0FBaUMsQ0FBQ29CLENBQWxDLENBQW9DLGVBQXBDLENBQWpCOztBQ01BaUMsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUMzQjBpQyx5QkFBeUIsRUFBRSxTQUFTQSx5QkFBVCxDQUFtQ3poQyxNQUFuQyxFQUEyQztNQUNwRSxJQUFJWCxDQUFDLEdBQUcrRyxVQUFTLENBQUNwRyxNQUFELENBQWpCO01BQ0EsSUFBSTBoQyxPQUFPLEdBQUcxNEIsV0FBSSxDQUFDL0ksQ0FBbkI7TUFDQSxJQUFJMkcsSUFBSSxHQUFHNDRCLFFBQU8sQ0FBQ25nQyxDQUFELENBQWxCO01BQ0EsSUFBSXNILE1BQU0sR0FBRyxFQUFiO01BQ0EsSUFBSTVDLENBQUMsR0FBRyxDQUFSO01BQ0EsSUFBSW5HLEdBQUosRUFBUysrQixJQUFUOztNQUNBLE9BQU8vMUIsSUFBSSxDQUFDakYsTUFBTCxHQUFjb0MsQ0FBckIsRUFBd0I7UUFDdEI0NEIsSUFBSSxHQUFHK0UsT0FBTyxDQUFDcmlDLENBQUQsRUFBSXpCLEdBQUcsR0FBR2dKLElBQUksQ0FBQzdDLENBQUMsRUFBRixDQUFkLENBQWQ7UUFDQSxJQUFJNDRCLElBQUksS0FBS3A4QixTQUFiLEVBQXdCa2UsZUFBYyxDQUFDOVgsTUFBRCxFQUFTL0ksR0FBVCxFQUFjKytCLElBQWQsQ0FBZDs7O01BRTFCLE9BQU9oMkIsTUFBUDs7RUFaeUIsQ0FBdEIsQ0FBUDs7RUNOQSw2QkFBYyxHQUFHOUgsS0FBOEIsQ0FBQ1osTUFBL0IsQ0FBc0N3akMseUJBQXZEOztFQ0VBLElBQUlyNkIsUUFBTSxHQUFHcEosVUFBd0IsQ0FBQ2lDLENBQXRDOztFQUNBLGtCQUFjLEdBQUcsdUJBQUEsQ0FBVTBoQyxTQUFWLEVBQXFCO0lBQ3BDLE9BQU8sVUFBVWhrQyxFQUFWLEVBQWM7TUFDbkIsSUFBSTBCLENBQUMsR0FBRytHLFVBQVMsQ0FBQ3pJLEVBQUQsQ0FBakI7TUFDQSxJQUFJaUosSUFBSSxHQUFHSSxXQUFPLENBQUMzSCxDQUFELENBQWxCO01BQ0EsSUFBSXNDLE1BQU0sR0FBR2lGLElBQUksQ0FBQ2pGLE1BQWxCO01BQ0EsSUFBSW9DLENBQUMsR0FBRyxDQUFSO01BQ0EsSUFBSTRDLE1BQU0sR0FBRyxFQUFiO01BQ0EsSUFBSS9JLEdBQUo7O01BQ0EsT0FBTytELE1BQU0sR0FBR29DLENBQWhCLEVBQW1CO1FBQ2pCbkcsR0FBRyxHQUFHZ0osSUFBSSxDQUFDN0MsQ0FBQyxFQUFGLENBQVY7O1FBQ0EsSUFBSSxDQUFDdUcsWUFBRCxJQUFnQmxELFFBQU0sQ0FBQ3ZKLElBQVAsQ0FBWXdCLENBQVosRUFBZXpCLEdBQWYsQ0FBcEIsRUFBeUM7VUFDdkMrSSxNQUFNLENBQUNqRyxJQUFQLENBQVlpaEMsU0FBUyxHQUFHLENBQUMvakMsR0FBRCxFQUFNeUIsQ0FBQyxDQUFDekIsR0FBRCxDQUFQLENBQUgsR0FBbUJ5QixDQUFDLENBQUN6QixHQUFELENBQXpDOzs7O01BR0osT0FBTytJLE1BQVA7S0FiRjtFQWVELENBaEJEOztFQ0ZBLElBQUlpN0IsT0FBTyxHQUFHNWpDLGNBQTZCLENBQUMsS0FBRCxDQUEzQztBQUVBa0UsU0FBTyxDQUFDQSxPQUFPLENBQUNuRCxDQUFULEVBQVksUUFBWixFQUFzQjtJQUMzQitaLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCbmIsRUFBaEIsRUFBb0I7TUFDMUIsT0FBT2lrQyxPQUFPLENBQUNqa0MsRUFBRCxDQUFkOztFQUZ5QixDQUF0QixDQUFQOztFQ0hBLFVBQWMsR0FBR2tCLEtBQThCLENBQUNaLE1BQS9CLENBQXNDNmEsTUFBdkQ7O0VDQ0EsSUFBSU0sUUFBUSxHQUFHcGIsY0FBNkIsQ0FBQyxJQUFELENBQTVDO0FBRUFrRSxTQUFPLENBQUNBLE9BQU8sQ0FBQ25ELENBQVQsRUFBWSxRQUFaLEVBQXNCO0lBQzNCZ2EsT0FBTyxFQUFFLFNBQVNBLE9BQVQsQ0FBaUJwYixFQUFqQixFQUFxQjtNQUM1QixPQUFPeWIsUUFBUSxDQUFDemIsRUFBRCxDQUFmOztFQUZ5QixDQUF0QixDQUFQOztFQ0hBLFdBQWMsR0FBR2tCLEtBQThCLENBQUNaLE1BQS9CLENBQXNDOGEsT0FBdkQ7O0FDT0E3VyxTQUFPLENBQUNBLE9BQU8sQ0FBQzVDLENBQVIsR0FBWTRDLE9BQU8sQ0FBQ3NCLENBQXJCLEVBQXdCLFNBQXhCLEVBQW1DO0lBQUUsV0FBVyxrQkFBVXErQixTQUFWLEVBQXFCO01BQzFFLElBQUl4d0IsQ0FBQyxHQUFHb08sbUJBQWtCLENBQUMsSUFBRCxFQUFPcGhCLEtBQUksQ0FBQ2dzQixPQUFMLElBQWdCbHRCLE9BQU0sQ0FBQ2t0QixPQUE5QixDQUExQjtNQUNBLElBQUlqcEIsVUFBVSxHQUFHLE9BQU95Z0MsU0FBUCxJQUFvQixVQUFyQztNQUNBLE9BQU8sS0FBS3JXLElBQUwsQ0FDTHBxQixVQUFVLEdBQUcsVUFBVThNLENBQVYsRUFBYTtRQUN4QixPQUFPa2hCLGVBQWMsQ0FBQy9kLENBQUQsRUFBSXd3QixTQUFTLEVBQWIsQ0FBZCxDQUErQnJXLElBQS9CLENBQW9DLFlBQVk7VUFBRSxPQUFPdGQsQ0FBUDtTQUFsRCxDQUFQO09BRFEsR0FFTjJ6QixTQUhDLEVBSUx6Z0MsVUFBVSxHQUFHLFVBQVVyRCxDQUFWLEVBQWE7UUFDeEIsT0FBT3F4QixlQUFjLENBQUMvZCxDQUFELEVBQUl3d0IsU0FBUyxFQUFiLENBQWQsQ0FBK0JyVyxJQUEvQixDQUFvQyxZQUFZO1VBQUUsTUFBTXp0QixDQUFOO1NBQWxELENBQVA7T0FEUSxHQUVOOGpDLFNBTkMsQ0FBUDs7RUFId0MsQ0FBbkMsQ0FBUDs7RUNMQSxZQUFjLEdBQUcvaUMsS0FBOEIsQ0FBQ3VyQixPQUEvQixDQUF1QyxTQUF2QyxDQUFqQjs7RUNDQSxJQUFJamxCLEtBQUssR0FBRyxHQUFHQSxLQUFmO0VBQ0EsSUFBSTA4QixJQUFJLEdBQUcsV0FBV3Z6QixJQUFYLENBQWdCd2QsVUFBaEIsQ0FBWDs7RUFDQSxJQUFJcGhCLE1BQUksR0FBRyxTQUFQQSxJQUFPLENBQVVpQixHQUFWLEVBQWU7SUFDeEIsT0FBTyxVQUFVNU0sRUFBVixFQUFjK2lDOztNQUFzQjtNQUN6QyxJQUFJQyxTQUFTLEdBQUdoZ0MsU0FBUyxDQUFDTCxNQUFWLEdBQW1CLENBQW5DO01BQ0EsSUFBSTZLLElBQUksR0FBR3cxQixTQUFTLEdBQUc1OEIsS0FBSyxDQUFDdkgsSUFBTixDQUFXbUUsU0FBWCxFQUFzQixDQUF0QixDQUFILEdBQThCLEtBQWxEO01BQ0EsT0FBTzRKLEdBQUcsQ0FBQ28yQixTQUFTLEdBQUcsWUFBWTs7UUFFakMsQ0FBQyxPQUFPaGpDLEVBQVAsSUFBYSxVQUFiLEdBQTBCQSxFQUExQixHQUErQnhCLFFBQVEsQ0FBQ3dCLEVBQUQsQ0FBeEMsRUFBOEMrQyxLQUE5QyxDQUFvRCxJQUFwRCxFQUEwRHlLLElBQTFEO09BRmtCLEdBR2hCeE4sRUFITSxFQUdGK2lDLElBSEUsQ0FBVjtLQUhGO0VBUUQsQ0FURDs7QUFVQTcvQixTQUFPLENBQUNBLE9BQU8sQ0FBQ08sQ0FBUixHQUFZUCxPQUFPLENBQUNXLENBQXBCLEdBQXdCWCxPQUFPLENBQUNLLENBQVIsR0FBWXUvQixJQUFyQyxFQUEyQztJQUNoRC9YLFVBQVUsRUFBRXBmLE1BQUksQ0FBQ3hOLE9BQU0sQ0FBQzRzQixVQUFSLENBRGdDO0lBRWhEa1ksV0FBVyxFQUFFdDNCLE1BQUksQ0FBQ3hOLE9BQU0sQ0FBQzhrQyxXQUFSO0VBRitCLENBQTNDLENBQVA7O0FDZEEvL0IsU0FBTyxDQUFDQSxPQUFPLENBQUNPLENBQVIsR0FBWVAsT0FBTyxDQUFDVyxDQUFyQixFQUF3QjtJQUM3QjJsQixZQUFZLEVBQUUwWixLQUFLLENBQUN0MkIsR0FEUztJQUU3QjhjLGNBQWMsRUFBRXdaLEtBQUssQ0FBQ2xZO0VBRk8sQ0FBeEIsQ0FBUDs7RUNLQSxJQUFJOVIsVUFBUSxHQUFHeE8sSUFBRyxDQUFDLFVBQUQsQ0FBbEI7RUFDQSxJQUFJeTRCLGFBQWEsR0FBR3o0QixJQUFHLENBQUMsYUFBRCxDQUF2QjtFQUNBLElBQUkwNEIsV0FBVyxHQUFHN29CLFVBQVMsQ0FBQ2pTLEtBQTVCO0VBRUEsSUFBSSs2QixZQUFZLEdBQUc7SUFDakJDLFdBQVcsRUFBRSxJQURJOztJQUVqQkMsbUJBQW1CLEVBQUUsS0FGSjtJQUdqQkMsWUFBWSxFQUFFLEtBSEc7SUFJakJDLGNBQWMsRUFBRSxLQUpDO0lBS2pCQyxXQUFXLEVBQUUsS0FMSTtJQU1qQkMsYUFBYSxFQUFFLEtBTkU7SUFPakJDLFlBQVksRUFBRSxJQVBHO0lBUWpCQyxvQkFBb0IsRUFBRSxLQVJMO0lBU2pCQyxRQUFRLEVBQUUsS0FUTztJQVVqQkMsaUJBQWlCLEVBQUUsS0FWRjtJQVdqQkMsY0FBYyxFQUFFLEtBWEM7SUFZakJDLGVBQWUsRUFBRSxLQVpBO0lBYWpCQyxpQkFBaUIsRUFBRSxLQWJGO0lBY2pCQyxTQUFTLEVBQUUsSUFkTTs7SUFlakJDLGFBQWEsRUFBRSxLQWZFO0lBZ0JqQkMsWUFBWSxFQUFFLEtBaEJHO0lBaUJqQkMsUUFBUSxFQUFFLElBakJPO0lBa0JqQkMsZ0JBQWdCLEVBQUUsS0FsQkQ7SUFtQmpCQyxNQUFNLEVBQUUsS0FuQlM7SUFvQmpCQyxXQUFXLEVBQUUsS0FwQkk7SUFxQmpCQyxhQUFhLEVBQUUsS0FyQkU7SUFzQmpCQyxhQUFhLEVBQUUsS0F0QkU7SUF1QmpCQyxjQUFjLEVBQUUsS0F2QkM7SUF3QmpCQyxZQUFZLEVBQUUsS0F4Qkc7SUF5QmpCQyxhQUFhLEVBQUUsS0F6QkU7SUEwQmpCQyxnQkFBZ0IsRUFBRSxLQTFCRDtJQTJCakJDLGdCQUFnQixFQUFFLEtBM0JEO0lBNEJqQkMsY0FBYyxFQUFFLElBNUJDOztJQTZCakJDLGdCQUFnQixFQUFFLEtBN0JEO0lBOEJqQkMsYUFBYSxFQUFFLEtBOUJFO0lBK0JqQkMsU0FBUyxFQUFFO0VBL0JNLENBQW5COztFQWtDQSxLQUFLLElBQUlDLFdBQVcsR0FBR3I5QixXQUFPLENBQUNxN0IsWUFBRCxDQUF6QixFQUF5Q3QrQixHQUFDLEdBQUcsQ0FBbEQsRUFBcURBLEdBQUMsR0FBR3NnQyxXQUFXLENBQUMxaUMsTUFBckUsRUFBNkVvQyxHQUFDLEVBQTlFLEVBQWtGO0lBQ2hGLElBQUkyTCxNQUFJLEdBQUcyMEIsV0FBVyxDQUFDdGdDLEdBQUQsQ0FBdEI7SUFDQSxJQUFJdWdDLFFBQVEsR0FBR2pDLFlBQVksQ0FBQzN5QixNQUFELENBQTNCO0lBQ0EsSUFBSTYwQixVQUFVLEdBQUdwbkMsT0FBTSxDQUFDdVMsTUFBRCxDQUF2QjtJQUNBLElBQUlyQixPQUFLLEdBQUdrMkIsVUFBVSxJQUFJQSxVQUFVLENBQUM5aUMsU0FBckM7SUFDQSxJQUFJN0QsS0FBSjs7SUFDQSxJQUFJeVEsT0FBSixFQUFXO01BQ1QsSUFBSSxDQUFDQSxPQUFLLENBQUM2SixVQUFELENBQVYsRUFBc0I1VyxLQUFJLENBQUMrTSxPQUFELEVBQVE2SixVQUFSLEVBQWtCa3FCLFdBQWxCLENBQUo7TUFDdEIsSUFBSSxDQUFDL3pCLE9BQUssQ0FBQzh6QixhQUFELENBQVYsRUFBMkI3Z0MsS0FBSSxDQUFDK00sT0FBRCxFQUFROHpCLGFBQVIsRUFBdUJ6eUIsTUFBdkIsQ0FBSjtNQUMzQjZKLFVBQVMsQ0FBQzdKLE1BQUQsQ0FBVCxHQUFrQjB5QixXQUFsQjtNQUNBLElBQUlrQyxRQUFKLEVBQWMsS0FBSzFtQyxLQUFMLElBQVkyK0Isa0JBQVo7UUFBd0IsSUFBSSxDQUFDbHVCLE9BQUssQ0FBQ3pRLEtBQUQsQ0FBVixFQUFpQnlGLFNBQVEsQ0FBQ2dMLE9BQUQsRUFBUXpRLEtBQVIsRUFBYTIrQixrQkFBVSxDQUFDMytCLEtBQUQsQ0FBdkIsRUFBOEIsSUFBOUIsQ0FBUjs7Ozs7OztFQ3REM0Q7RUFDQTtFQUNBO0VBQ0E7RUFDQTtJQUVBLElBQUk0bUMsT0FBTyxHQUFJLFVBQVV6aEMsT0FBVixFQUFtQjs7TUFHaEMsSUFBSTBoQyxFQUFFLEdBQUd4bUMsTUFBTSxDQUFDd0QsU0FBaEI7TUFDQSxJQUFJaWpDLE1BQU0sR0FBR0QsRUFBRSxDQUFDL21DLGNBQWhCO01BQ0EsSUFBSTZDLFdBQUosQ0FMZ0M7O01BTWhDLElBQUl5RSxPQUFPLEdBQUcsT0FBT1IsTUFBUCxLQUFrQixVQUFsQixHQUErQkEsTUFBL0IsR0FBd0MsRUFBdEQ7TUFDQSxJQUFJbWdDLGNBQWMsR0FBRzMvQixPQUFPLENBQUMrRixRQUFSLElBQW9CLFlBQXpDO01BQ0EsSUFBSTY1QixtQkFBbUIsR0FBRzUvQixPQUFPLENBQUM2L0IsYUFBUixJQUF5QixpQkFBbkQ7TUFDQSxJQUFJQyxpQkFBaUIsR0FBRzkvQixPQUFPLENBQUMrL0IsV0FBUixJQUF1QixlQUEvQzs7TUFFQSxTQUFTcGhCLE1BQVQsQ0FBZ0JxaEIsR0FBaEIsRUFBcUJwbkMsR0FBckIsRUFBMEIrQixLQUExQixFQUFpQztRQUMvQjFCLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQjhtQyxHQUF0QixFQUEyQnBuQyxHQUEzQixFQUFnQztVQUM5QitCLEtBQUssRUFBRUEsS0FEdUI7VUFFOUJFLFVBQVUsRUFBRSxJQUZrQjtVQUc5QkMsWUFBWSxFQUFFLElBSGdCO1VBSTlCQyxRQUFRLEVBQUU7U0FKWjtRQU1BLE9BQU9pbEMsR0FBRyxDQUFDcG5DLEdBQUQsQ0FBVjs7O01BRUYsSUFBSTs7UUFFRitsQixNQUFNLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBTjtPQUZGLENBR0UsT0FBT29MLEdBQVAsRUFBWTtRQUNacEwsTUFBTSxHQUFHLGdCQUFTcWhCLEdBQVQsRUFBY3BuQyxHQUFkLEVBQW1CK0IsS0FBbkIsRUFBMEI7VUFDakMsT0FBT3FsQyxHQUFHLENBQUNwbkMsR0FBRCxDQUFILEdBQVcrQixLQUFsQjtTQURGOzs7TUFLRixTQUFTZ0wsSUFBVCxDQUFjczZCLE9BQWQsRUFBdUJDLE9BQXZCLEVBQWdDM25DLElBQWhDLEVBQXNDNG5DLFdBQXRDLEVBQW1EOztRQUVqRCxJQUFJQyxjQUFjLEdBQUdGLE9BQU8sSUFBSUEsT0FBTyxDQUFDempDLFNBQVIsWUFBNkI0akMsU0FBeEMsR0FBb0RILE9BQXBELEdBQThERyxTQUFuRjtRQUNBLElBQUlDLFNBQVMsR0FBR3JuQyxNQUFNLENBQUNpRyxNQUFQLENBQWNraEMsY0FBYyxDQUFDM2pDLFNBQTdCLENBQWhCO1FBQ0EsSUFBSTZZLE9BQU8sR0FBRyxJQUFJaXJCLE9BQUosQ0FBWUosV0FBVyxJQUFJLEVBQTNCLENBQWQsQ0FKaUQ7OztRQVFqREcsU0FBUyxDQUFDRSxPQUFWLEdBQW9CQyxnQkFBZ0IsQ0FBQ1IsT0FBRCxFQUFVMW5DLElBQVYsRUFBZ0IrYyxPQUFoQixDQUFwQztRQUVBLE9BQU9nckIsU0FBUDs7O01BRUZ2aUMsT0FBTyxDQUFDNEgsSUFBUixHQUFlQSxJQUFmLENBekNnQzs7Ozs7Ozs7Ozs7TUFxRGhDLFNBQVMrNkIsUUFBVCxDQUFrQjFtQyxFQUFsQixFQUFzQmdtQyxHQUF0QixFQUEyQng5QixHQUEzQixFQUFnQztRQUM5QixJQUFJO1VBQ0YsT0FBTztZQUFFckYsSUFBSSxFQUFFLFFBQVI7WUFBa0JxRixHQUFHLEVBQUV4SSxFQUFFLENBQUNuQixJQUFILENBQVFtbkMsR0FBUixFQUFheDlCLEdBQWI7V0FBOUI7U0FERixDQUVFLE9BQU91bkIsR0FBUCxFQUFZO1VBQ1osT0FBTztZQUFFNXNCLElBQUksRUFBRSxPQUFSO1lBQWlCcUYsR0FBRyxFQUFFdW5CO1dBQTdCOzs7O01BSUosSUFBSTRXLHNCQUFzQixHQUFHLGdCQUE3QjtNQUNBLElBQUlDLHNCQUFzQixHQUFHLGdCQUE3QjtNQUNBLElBQUlDLGlCQUFpQixHQUFHLFdBQXhCO01BQ0EsSUFBSUMsaUJBQWlCLEdBQUcsV0FBeEIsQ0FoRWdDOzs7TUFvRWhDLElBQUlDLGdCQUFnQixHQUFHLEVBQXZCLENBcEVnQzs7Ozs7TUEwRWhDLFNBQVNWLFNBQVQsR0FBcUI7O01BQ3JCLFNBQVNXLGlCQUFULEdBQTZCOztNQUM3QixTQUFTQywwQkFBVCxHQUFzQyxFQTVFTjs7OztNQWdGaEMsSUFBSW51QixpQkFBaUIsR0FBRyxFQUF4QjtNQUNBNkwsTUFBTSxDQUFDN0wsaUJBQUQsRUFBb0I2c0IsY0FBcEIsRUFBb0MsWUFBWTtRQUNwRCxPQUFPLElBQVA7T0FESSxDQUFOO01BSUEsSUFBSXBGLFFBQVEsR0FBR3RoQyxNQUFNLENBQUM2TyxjQUF0QjtNQUNBLElBQUlvNUIsdUJBQXVCLEdBQUczRyxRQUFRLElBQUlBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDem1CLE1BQU0sQ0FBQyxFQUFELENBQVAsQ0FBVCxDQUFsRDs7TUFDQSxJQUFJb3RCLHVCQUF1QixJQUN2QkEsdUJBQXVCLEtBQUt6QixFQUQ1QixJQUVBQyxNQUFNLENBQUM3bUMsSUFBUCxDQUFZcW9DLHVCQUFaLEVBQXFDdkIsY0FBckMsQ0FGSixFQUUwRDs7O1FBR3hEN3NCLGlCQUFpQixHQUFHb3VCLHVCQUFwQjs7O01BR0YsSUFBSUMsRUFBRSxHQUFHRiwwQkFBMEIsQ0FBQ3hrQyxTQUEzQixHQUNQNGpDLFNBQVMsQ0FBQzVqQyxTQUFWLEdBQXNCeEQsTUFBTSxDQUFDaUcsTUFBUCxDQUFjNFQsaUJBQWQsQ0FEeEI7TUFFQWt1QixpQkFBaUIsQ0FBQ3ZrQyxTQUFsQixHQUE4QndrQywwQkFBOUI7TUFDQXRpQixNQUFNLENBQUN3aUIsRUFBRCxFQUFLLGFBQUwsRUFBb0JGLDBCQUFwQixDQUFOO01BQ0F0aUIsTUFBTSxDQUFDc2lCLDBCQUFELEVBQTZCLGFBQTdCLEVBQTRDRCxpQkFBNUMsQ0FBTjtNQUNBQSxpQkFBaUIsQ0FBQ0ksV0FBbEIsR0FBZ0N6aUIsTUFBTSxDQUNwQ3NpQiwwQkFEb0MsRUFFcENuQixpQkFGb0MsRUFHcEMsbUJBSG9DLENBQXRDLENBcEdnQzs7O01BNEdoQyxTQUFTdUIscUJBQVQsQ0FBK0I1a0MsU0FBL0IsRUFBMEM7UUFDeEMsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QnNNLE9BQTVCLENBQW9DLFVBQVM0USxNQUFULEVBQWlCO1VBQ25EZ0YsTUFBTSxDQUFDbGlCLFNBQUQsRUFBWWtkLE1BQVosRUFBb0IsVUFBU25YLEdBQVQsRUFBYztZQUN0QyxPQUFPLEtBQUtnK0IsT0FBTCxDQUFhN21CLE1BQWIsRUFBcUJuWCxHQUFyQixDQUFQO1dBREksQ0FBTjtTQURGOzs7TUFPRnpFLE9BQU8sQ0FBQ3VqQyxtQkFBUixHQUE4QixVQUFTQyxNQUFULEVBQWlCO1FBQzdDLElBQUlDLElBQUksR0FBRyxPQUFPRCxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxNQUFNLENBQUN4NUIsV0FBbEQ7UUFDQSxPQUFPeTVCLElBQUksR0FDUEEsSUFBSSxLQUFLUixpQkFBVDs7UUFHQSxDQUFDUSxJQUFJLENBQUNKLFdBQUwsSUFBb0JJLElBQUksQ0FBQ3BrQyxJQUExQixNQUFvQyxtQkFKN0IsR0FLUCxLQUxKO09BRkY7O01BVUFXLE9BQU8sQ0FBQzBqQyxJQUFSLEdBQWUsVUFBU0YsTUFBVCxFQUFpQjtRQUM5QixJQUFJdG9DLE1BQU0sQ0FBQ3FRLGNBQVgsRUFBMkI7VUFDekJyUSxNQUFNLENBQUNxUSxjQUFQLENBQXNCaTRCLE1BQXRCLEVBQThCTiwwQkFBOUI7U0FERixNQUVPO1VBQ0xNLE1BQU0sQ0FBQzkzQixTQUFQLEdBQW1CdzNCLDBCQUFuQjtVQUNBdGlCLE1BQU0sQ0FBQzRpQixNQUFELEVBQVN6QixpQkFBVCxFQUE0QixtQkFBNUIsQ0FBTjs7O1FBRUZ5QixNQUFNLENBQUM5a0MsU0FBUCxHQUFtQnhELE1BQU0sQ0FBQ2lHLE1BQVAsQ0FBY2lpQyxFQUFkLENBQW5CO1FBQ0EsT0FBT0ksTUFBUDtPQVJGLENBOUhnQzs7Ozs7O01BNkloQ3hqQyxPQUFPLENBQUMyakMsS0FBUixHQUFnQixVQUFTbC9CLEdBQVQsRUFBYztRQUM1QixPQUFPO1VBQUVtL0IsT0FBTyxFQUFFbi9CO1NBQWxCO09BREY7O01BSUEsU0FBU28vQixhQUFULENBQXVCdEIsU0FBdkIsRUFBa0N1QixXQUFsQyxFQUErQztRQUM3QyxTQUFTdDNCLE1BQVQsQ0FBZ0JvUCxNQUFoQixFQUF3Qm5YLEdBQXhCLEVBQTZCOGpCLE9BQTdCLEVBQXNDSyxNQUF0QyxFQUE4QztVQUM1QyxJQUFJbWIsTUFBTSxHQUFHcEIsUUFBUSxDQUFDSixTQUFTLENBQUMzbUIsTUFBRCxDQUFWLEVBQW9CMm1CLFNBQXBCLEVBQStCOTlCLEdBQS9CLENBQXJCOztVQUNBLElBQUlzL0IsTUFBTSxDQUFDM2tDLElBQVAsS0FBZ0IsT0FBcEIsRUFBNkI7WUFDM0J3cEIsTUFBTSxDQUFDbWIsTUFBTSxDQUFDdC9CLEdBQVIsQ0FBTjtXQURGLE1BRU87WUFDTCxJQUFJYixNQUFNLEdBQUdtZ0MsTUFBTSxDQUFDdC9CLEdBQXBCO1lBQ0EsSUFBSTdILEtBQUssR0FBR2dILE1BQU0sQ0FBQ2hILEtBQW5COztZQUNBLElBQUlBLEtBQUssSUFDTCxPQUFPQSxLQUFQLEtBQWlCLFFBRGpCLElBRUEra0MsTUFBTSxDQUFDN21DLElBQVAsQ0FBWThCLEtBQVosRUFBbUIsU0FBbkIsQ0FGSixFQUVtQztjQUNqQyxPQUFPa25DLFdBQVcsQ0FBQ3ZiLE9BQVosQ0FBb0IzckIsS0FBSyxDQUFDZ25DLE9BQTFCLEVBQW1DbmIsSUFBbkMsQ0FBd0MsVUFBUzdyQixLQUFULEVBQWdCO2dCQUM3RDRQLE1BQU0sQ0FBQyxNQUFELEVBQVM1UCxLQUFULEVBQWdCMnJCLE9BQWhCLEVBQXlCSyxNQUF6QixDQUFOO2VBREssRUFFSixVQUFTb0QsR0FBVCxFQUFjO2dCQUNmeGYsTUFBTSxDQUFDLE9BQUQsRUFBVXdmLEdBQVYsRUFBZXpELE9BQWYsRUFBd0JLLE1BQXhCLENBQU47ZUFISyxDQUFQOzs7WUFPRixPQUFPa2IsV0FBVyxDQUFDdmIsT0FBWixDQUFvQjNyQixLQUFwQixFQUEyQjZyQixJQUEzQixDQUFnQyxVQUFTdWIsU0FBVCxFQUFvQjs7OztjQUl6RHBnQyxNQUFNLENBQUNoSCxLQUFQLEdBQWVvbkMsU0FBZjtjQUNBemIsT0FBTyxDQUFDM2tCLE1BQUQsQ0FBUDthQUxLLEVBTUosVUFBUzBuQixLQUFULEVBQWdCOzs7Y0FHakIsT0FBTzllLE1BQU0sQ0FBQyxPQUFELEVBQVU4ZSxLQUFWLEVBQWlCL0MsT0FBakIsRUFBMEJLLE1BQTFCLENBQWI7YUFUSyxDQUFQOzs7O1FBY0osSUFBSXFiLGVBQUo7O1FBRUEsU0FBU0MsT0FBVCxDQUFpQnRvQixNQUFqQixFQUF5Qm5YLEdBQXpCLEVBQThCO1VBQzVCLFNBQVMwL0IsMEJBQVQsR0FBc0M7WUFDcEMsT0FBTyxJQUFJTCxXQUFKLENBQWdCLFVBQVN2YixPQUFULEVBQWtCSyxNQUFsQixFQUEwQjtjQUMvQ3BjLE1BQU0sQ0FBQ29QLE1BQUQsRUFBU25YLEdBQVQsRUFBYzhqQixPQUFkLEVBQXVCSyxNQUF2QixDQUFOO2FBREssQ0FBUDs7O1VBS0YsT0FBT3FiLGVBQWU7Ozs7Ozs7Ozs7OztVQWFwQkEsZUFBZSxHQUFHQSxlQUFlLENBQUN4YixJQUFoQixDQUNoQjBiLDBCQURnQjs7VUFJaEJBLDBCQUpnQixDQUFILEdBS1hBLDBCQUEwQixFQWxCaEM7U0F6QzJDOzs7O1FBZ0U3QyxLQUFLMUIsT0FBTCxHQUFleUIsT0FBZjs7O01BR0ZaLHFCQUFxQixDQUFDTyxhQUFhLENBQUNubEMsU0FBZixDQUFyQjtNQUNBa2lCLE1BQU0sQ0FBQ2lqQixhQUFhLENBQUNubEMsU0FBZixFQUEwQm1qQyxtQkFBMUIsRUFBK0MsWUFBWTtRQUMvRCxPQUFPLElBQVA7T0FESSxDQUFOO01BR0E3aEMsT0FBTyxDQUFDNmpDLGFBQVIsR0FBd0JBLGFBQXhCLENBeE5nQzs7OztNQTZOaEM3akMsT0FBTyxDQUFDb2tDLEtBQVIsR0FBZ0IsVUFBU2xDLE9BQVQsRUFBa0JDLE9BQWxCLEVBQTJCM25DLElBQTNCLEVBQWlDNG5DLFdBQWpDLEVBQThDMEIsV0FBOUMsRUFBMkQ7UUFDekUsSUFBSUEsV0FBVyxLQUFLLEtBQUssQ0FBekIsRUFBNEJBLFdBQVcsR0FBR3hjLE9BQWQ7UUFFNUIsSUFBSXBNLElBQUksR0FBRyxJQUFJMm9CLGFBQUosQ0FDVGo4QixJQUFJLENBQUNzNkIsT0FBRCxFQUFVQyxPQUFWLEVBQW1CM25DLElBQW5CLEVBQXlCNG5DLFdBQXpCLENBREssRUFFVDBCLFdBRlMsQ0FBWDtRQUtBLE9BQU85akMsT0FBTyxDQUFDdWpDLG1CQUFSLENBQTRCcEIsT0FBNUIsSUFDSGpuQixJQURHO1VBRUhBLElBQUksQ0FBQ2pHLElBQUwsR0FBWXdULElBQVosQ0FBaUIsVUFBUzdrQixNQUFULEVBQWlCO1VBQ2hDLE9BQU9BLE1BQU0sQ0FBQ2tULElBQVAsR0FBY2xULE1BQU0sQ0FBQ2hILEtBQXJCLEdBQTZCc2UsSUFBSSxDQUFDakcsSUFBTCxFQUFwQztTQURGLENBRko7T0FSRjs7TUFlQSxTQUFTeXRCLGdCQUFULENBQTBCUixPQUExQixFQUFtQzFuQyxJQUFuQyxFQUF5QytjLE9BQXpDLEVBQWtEO1FBQ2hELElBQUk4c0IsS0FBSyxHQUFHekIsc0JBQVo7UUFFQSxPQUFPLFNBQVNwMkIsTUFBVCxDQUFnQm9QLE1BQWhCLEVBQXdCblgsR0FBeEIsRUFBNkI7VUFDbEMsSUFBSTQvQixLQUFLLEtBQUt2QixpQkFBZCxFQUFpQztZQUMvQixNQUFNLElBQUl3QixLQUFKLENBQVUsOEJBQVYsQ0FBTjs7O1VBR0YsSUFBSUQsS0FBSyxLQUFLdEIsaUJBQWQsRUFBaUM7WUFDL0IsSUFBSW5uQixNQUFNLEtBQUssT0FBZixFQUF3QjtjQUN0QixNQUFNblgsR0FBTjthQUY2Qjs7OztZQU8vQixPQUFPOC9CLFVBQVUsRUFBakI7OztVQUdGaHRCLE9BQU8sQ0FBQ3FFLE1BQVIsR0FBaUJBLE1BQWpCO1VBQ0FyRSxPQUFPLENBQUM5UyxHQUFSLEdBQWNBLEdBQWQ7O1VBRUEsT0FBTyxJQUFQLEVBQWE7WUFDWCxJQUFJKy9CLFFBQVEsR0FBR2p0QixPQUFPLENBQUNpdEIsUUFBdkI7O1lBQ0EsSUFBSUEsUUFBSixFQUFjO2NBQ1osSUFBSUMsY0FBYyxHQUFHQyxtQkFBbUIsQ0FBQ0YsUUFBRCxFQUFXanRCLE9BQVgsQ0FBeEM7O2NBQ0EsSUFBSWt0QixjQUFKLEVBQW9CO2dCQUNsQixJQUFJQSxjQUFjLEtBQUt6QixnQkFBdkIsRUFBeUM7Z0JBQ3pDLE9BQU95QixjQUFQOzs7O1lBSUosSUFBSWx0QixPQUFPLENBQUNxRSxNQUFSLEtBQW1CLE1BQXZCLEVBQStCOzs7Y0FHN0JyRSxPQUFPLENBQUNvdEIsSUFBUixHQUFlcHRCLE9BQU8sQ0FBQ3F0QixLQUFSLEdBQWdCcnRCLE9BQU8sQ0FBQzlTLEdBQXZDO2FBSEYsTUFLTyxJQUFJOFMsT0FBTyxDQUFDcUUsTUFBUixLQUFtQixPQUF2QixFQUFnQztjQUNyQyxJQUFJeW9CLEtBQUssS0FBS3pCLHNCQUFkLEVBQXNDO2dCQUNwQ3lCLEtBQUssR0FBR3RCLGlCQUFSO2dCQUNBLE1BQU14ckIsT0FBTyxDQUFDOVMsR0FBZDs7O2NBR0Y4UyxPQUFPLENBQUNzdEIsaUJBQVIsQ0FBMEJ0dEIsT0FBTyxDQUFDOVMsR0FBbEM7YUFOSyxNQVFBLElBQUk4UyxPQUFPLENBQUNxRSxNQUFSLEtBQW1CLFFBQXZCLEVBQWlDO2NBQ3RDckUsT0FBTyxDQUFDdXRCLE1BQVIsQ0FBZSxRQUFmLEVBQXlCdnRCLE9BQU8sQ0FBQzlTLEdBQWpDOzs7WUFHRjQvQixLQUFLLEdBQUd2QixpQkFBUjtZQUVBLElBQUlpQixNQUFNLEdBQUdwQixRQUFRLENBQUNULE9BQUQsRUFBVTFuQyxJQUFWLEVBQWdCK2MsT0FBaEIsQ0FBckI7O1lBQ0EsSUFBSXdzQixNQUFNLENBQUMza0MsSUFBUCxLQUFnQixRQUFwQixFQUE4Qjs7O2NBRzVCaWxDLEtBQUssR0FBRzlzQixPQUFPLENBQUNULElBQVIsR0FDSmlzQixpQkFESSxHQUVKRixzQkFGSjs7Y0FJQSxJQUFJa0IsTUFBTSxDQUFDdC9CLEdBQVAsS0FBZXUrQixnQkFBbkIsRUFBcUM7Z0JBQ25DOzs7Y0FHRixPQUFPO2dCQUNMcG1DLEtBQUssRUFBRW1uQyxNQUFNLENBQUN0L0IsR0FEVDtnQkFFTHFTLElBQUksRUFBRVMsT0FBTyxDQUFDVDtlQUZoQjthQVhGLE1BZ0JPLElBQUlpdEIsTUFBTSxDQUFDM2tDLElBQVAsS0FBZ0IsT0FBcEIsRUFBNkI7Y0FDbENpbEMsS0FBSyxHQUFHdEIsaUJBQVIsQ0FEa0M7OztjQUlsQ3hyQixPQUFPLENBQUNxRSxNQUFSLEdBQWlCLE9BQWpCO2NBQ0FyRSxPQUFPLENBQUM5UyxHQUFSLEdBQWNzL0IsTUFBTSxDQUFDdC9CLEdBQXJCOzs7U0FyRU47T0EvTzhCOzs7Ozs7TUE4VGhDLFNBQVNpZ0MsbUJBQVQsQ0FBNkJGLFFBQTdCLEVBQXVDanRCLE9BQXZDLEVBQWdEO1FBQzlDLElBQUlxRSxNQUFNLEdBQUc0b0IsUUFBUSxDQUFDeDhCLFFBQVQsQ0FBa0J1UCxPQUFPLENBQUNxRSxNQUExQixDQUFiOztRQUNBLElBQUlBLE1BQU0sS0FBS3BlLFdBQWYsRUFBMEI7OztVQUd4QitaLE9BQU8sQ0FBQ2l0QixRQUFSLEdBQW1CLElBQW5COztVQUVBLElBQUlqdEIsT0FBTyxDQUFDcUUsTUFBUixLQUFtQixPQUF2QixFQUFnQzs7WUFFOUIsSUFBSTRvQixRQUFRLENBQUN4OEIsUUFBVCxDQUFrQixRQUFsQixDQUFKLEVBQWlDOzs7Y0FHL0J1UCxPQUFPLENBQUNxRSxNQUFSLEdBQWlCLFFBQWpCO2NBQ0FyRSxPQUFPLENBQUM5UyxHQUFSLEdBQWNqSCxXQUFkO2NBQ0FrbkMsbUJBQW1CLENBQUNGLFFBQUQsRUFBV2p0QixPQUFYLENBQW5COztjQUVBLElBQUlBLE9BQU8sQ0FBQ3FFLE1BQVIsS0FBbUIsT0FBdkIsRUFBZ0M7OztnQkFHOUIsT0FBT29uQixnQkFBUDs7OztZQUlKenJCLE9BQU8sQ0FBQ3FFLE1BQVIsR0FBaUIsT0FBakI7WUFDQXJFLE9BQU8sQ0FBQzlTLEdBQVIsR0FBYyxJQUFJL0ksU0FBSixDQUNaLGdEQURZLENBQWQ7OztVQUlGLE9BQU9zbkMsZ0JBQVA7OztRQUdGLElBQUllLE1BQU0sR0FBR3BCLFFBQVEsQ0FBQy9tQixNQUFELEVBQVM0b0IsUUFBUSxDQUFDeDhCLFFBQWxCLEVBQTRCdVAsT0FBTyxDQUFDOVMsR0FBcEMsQ0FBckI7O1FBRUEsSUFBSXMvQixNQUFNLENBQUMza0MsSUFBUCxLQUFnQixPQUFwQixFQUE2QjtVQUMzQm1ZLE9BQU8sQ0FBQ3FFLE1BQVIsR0FBaUIsT0FBakI7VUFDQXJFLE9BQU8sQ0FBQzlTLEdBQVIsR0FBY3MvQixNQUFNLENBQUN0L0IsR0FBckI7VUFDQThTLE9BQU8sQ0FBQ2l0QixRQUFSLEdBQW1CLElBQW5CO1VBQ0EsT0FBT3hCLGdCQUFQOzs7UUFHRixJQUFJK0IsSUFBSSxHQUFHaEIsTUFBTSxDQUFDdC9CLEdBQWxCOztRQUVBLElBQUksQ0FBRXNnQyxJQUFOLEVBQVk7VUFDVnh0QixPQUFPLENBQUNxRSxNQUFSLEdBQWlCLE9BQWpCO1VBQ0FyRSxPQUFPLENBQUM5UyxHQUFSLEdBQWMsSUFBSS9JLFNBQUosQ0FBYyxrQ0FBZCxDQUFkO1VBQ0E2YixPQUFPLENBQUNpdEIsUUFBUixHQUFtQixJQUFuQjtVQUNBLE9BQU94QixnQkFBUDs7O1FBR0YsSUFBSStCLElBQUksQ0FBQ2p1QixJQUFULEVBQWU7OztVQUdiUyxPQUFPLENBQUNpdEIsUUFBUSxDQUFDUSxVQUFWLENBQVAsR0FBK0JELElBQUksQ0FBQ25vQyxLQUFwQyxDQUhhOztVQU1iMmEsT0FBTyxDQUFDdEMsSUFBUixHQUFldXZCLFFBQVEsQ0FBQ1MsT0FBeEIsQ0FOYTs7Ozs7OztVQWNiLElBQUkxdEIsT0FBTyxDQUFDcUUsTUFBUixLQUFtQixRQUF2QixFQUFpQztZQUMvQnJFLE9BQU8sQ0FBQ3FFLE1BQVIsR0FBaUIsTUFBakI7WUFDQXJFLE9BQU8sQ0FBQzlTLEdBQVIsR0FBY2pILFdBQWQ7O1NBaEJKLE1BbUJPOztVQUVMLE9BQU91bkMsSUFBUDtTQXRFNEM7Ozs7UUEyRTlDeHRCLE9BQU8sQ0FBQ2l0QixRQUFSLEdBQW1CLElBQW5CO1FBQ0EsT0FBT3hCLGdCQUFQO09BMVk4Qjs7OztNQStZaENNLHFCQUFxQixDQUFDRixFQUFELENBQXJCO01BRUF4aUIsTUFBTSxDQUFDd2lCLEVBQUQsRUFBS3JCLGlCQUFMLEVBQXdCLFdBQXhCLENBQU4sQ0FqWmdDOzs7Ozs7TUF3WmhDbmhCLE1BQU0sQ0FBQ3dpQixFQUFELEVBQUt4QixjQUFMLEVBQXFCLFlBQVc7UUFDcEMsT0FBTyxJQUFQO09BREksQ0FBTjtNQUlBaGhCLE1BQU0sQ0FBQ3dpQixFQUFELEVBQUssVUFBTCxFQUFpQixZQUFXO1FBQ2hDLE9BQU8sb0JBQVA7T0FESSxDQUFOOztNQUlBLFNBQVM4QixZQUFULENBQXNCQyxJQUF0QixFQUE0QjtRQUMxQixJQUFJcFksS0FBSyxHQUFHO1VBQUVxWSxNQUFNLEVBQUVELElBQUksQ0FBQyxDQUFEO1NBQTFCOztRQUVBLElBQUksS0FBS0EsSUFBVCxFQUFlO1VBQ2JwWSxLQUFLLENBQUNzWSxRQUFOLEdBQWlCRixJQUFJLENBQUMsQ0FBRCxDQUFyQjs7O1FBR0YsSUFBSSxLQUFLQSxJQUFULEVBQWU7VUFDYnBZLEtBQUssQ0FBQ3VZLFVBQU4sR0FBbUJILElBQUksQ0FBQyxDQUFELENBQXZCO1VBQ0FwWSxLQUFLLENBQUN3WSxRQUFOLEdBQWlCSixJQUFJLENBQUMsQ0FBRCxDQUFyQjs7O1FBR0YsS0FBS0ssVUFBTCxDQUFnQjduQyxJQUFoQixDQUFxQm92QixLQUFyQjs7O01BR0YsU0FBUzBZLGFBQVQsQ0FBdUIxWSxLQUF2QixFQUE4QjtRQUM1QixJQUFJZ1gsTUFBTSxHQUFHaFgsS0FBSyxDQUFDMlksVUFBTixJQUFvQixFQUFqQztRQUNBM0IsTUFBTSxDQUFDM2tDLElBQVAsR0FBYyxRQUFkO1FBQ0EsT0FBTzJrQyxNQUFNLENBQUN0L0IsR0FBZDtRQUNBc29CLEtBQUssQ0FBQzJZLFVBQU4sR0FBbUIzQixNQUFuQjs7O01BR0YsU0FBU3ZCLE9BQVQsQ0FBaUJKLFdBQWpCLEVBQThCOzs7O1FBSTVCLEtBQUtvRCxVQUFMLEdBQWtCLENBQUM7VUFBRUosTUFBTSxFQUFFO1NBQVgsQ0FBbEI7UUFDQWhELFdBQVcsQ0FBQ3AzQixPQUFaLENBQW9CazZCLFlBQXBCLEVBQWtDLElBQWxDO1FBQ0EsS0FBS1MsS0FBTCxDQUFXLElBQVg7OztNQUdGM2xDLE9BQU8sQ0FBQzZELElBQVIsR0FBZSxVQUFTNUcsTUFBVCxFQUFpQjtRQUM5QixJQUFJNEcsSUFBSSxHQUFHLEVBQVg7O1FBQ0EsS0FBSyxJQUFJaEosR0FBVCxJQUFnQm9DLE1BQWhCLEVBQXdCO1VBQ3RCNEcsSUFBSSxDQUFDbEcsSUFBTCxDQUFVOUMsR0FBVjs7O1FBRUZnSixJQUFJLENBQUNndkIsT0FBTCxHQUw4Qjs7O1FBUzlCLE9BQU8sU0FBUzVkLElBQVQsR0FBZ0I7VUFDckIsT0FBT3BSLElBQUksQ0FBQ2pGLE1BQVosRUFBb0I7WUFDbEIsSUFBSS9ELEdBQUcsR0FBR2dKLElBQUksQ0FBQytoQyxHQUFMLEVBQVY7O1lBQ0EsSUFBSS9xQyxHQUFHLElBQUlvQyxNQUFYLEVBQW1CO2NBQ2pCZ1ksSUFBSSxDQUFDclksS0FBTCxHQUFhL0IsR0FBYjtjQUNBb2EsSUFBSSxDQUFDNkIsSUFBTCxHQUFZLEtBQVo7Y0FDQSxPQUFPN0IsSUFBUDs7V0FOaUI7Ozs7O1VBYXJCQSxJQUFJLENBQUM2QixJQUFMLEdBQVksSUFBWjtVQUNBLE9BQU83QixJQUFQO1NBZEY7T0FURjs7TUEyQkEsU0FBU2MsTUFBVCxDQUFnQnVQLFFBQWhCLEVBQTBCO1FBQ3hCLElBQUlBLFFBQUosRUFBYztVQUNaLElBQUl1Z0IsY0FBYyxHQUFHdmdCLFFBQVEsQ0FBQ3NjLGNBQUQsQ0FBN0I7O1VBQ0EsSUFBSWlFLGNBQUosRUFBb0I7WUFDbEIsT0FBT0EsY0FBYyxDQUFDL3FDLElBQWYsQ0FBb0J3cUIsUUFBcEIsQ0FBUDs7O1VBR0YsSUFBSSxPQUFPQSxRQUFRLENBQUNyUSxJQUFoQixLQUF5QixVQUE3QixFQUF5QztZQUN2QyxPQUFPcVEsUUFBUDs7O1VBR0YsSUFBSSxDQUFDMWlCLEtBQUssQ0FBQzBpQixRQUFRLENBQUMxbUIsTUFBVixDQUFWLEVBQTZCO1lBQzNCLElBQUlvQyxDQUFDLEdBQUcsQ0FBQyxDQUFUO2dCQUFZaVUsSUFBSSxHQUFHLFNBQVNBLElBQVQsR0FBZ0I7Y0FDakMsT0FBTyxFQUFFalUsQ0FBRixHQUFNc2tCLFFBQVEsQ0FBQzFtQixNQUF0QixFQUE4QjtnQkFDNUIsSUFBSStpQyxNQUFNLENBQUM3bUMsSUFBUCxDQUFZd3FCLFFBQVosRUFBc0J0a0IsQ0FBdEIsQ0FBSixFQUE4QjtrQkFDNUJpVSxJQUFJLENBQUNyWSxLQUFMLEdBQWEwb0IsUUFBUSxDQUFDdGtCLENBQUQsQ0FBckI7a0JBQ0FpVSxJQUFJLENBQUM2QixJQUFMLEdBQVksS0FBWjtrQkFDQSxPQUFPN0IsSUFBUDs7OztjQUlKQSxJQUFJLENBQUNyWSxLQUFMLEdBQWFZLFdBQWI7Y0FDQXlYLElBQUksQ0FBQzZCLElBQUwsR0FBWSxJQUFaO2NBRUEsT0FBTzdCLElBQVA7YUFaRjs7WUFlQSxPQUFPQSxJQUFJLENBQUNBLElBQUwsR0FBWUEsSUFBbkI7O1NBM0JvQjs7O1FBZ0N4QixPQUFPO1VBQUVBLElBQUksRUFBRXN2QjtTQUFmOzs7TUFFRnZrQyxPQUFPLENBQUMrVixNQUFSLEdBQWlCQSxNQUFqQjs7TUFFQSxTQUFTd3VCLFVBQVQsR0FBc0I7UUFDcEIsT0FBTztVQUFFM25DLEtBQUssRUFBRVksV0FBVDtVQUFvQnNaLElBQUksRUFBRTtTQUFqQzs7O01BR0YwckIsT0FBTyxDQUFDOWpDLFNBQVIsR0FBb0I7UUFDbEJzTCxXQUFXLEVBQUV3NEIsT0FESztRQUdsQm1ELEtBQUssRUFBRSxlQUFTRyxhQUFULEVBQXdCO1VBQzdCLEtBQUt4WSxJQUFMLEdBQVksQ0FBWjtVQUNBLEtBQUtyWSxJQUFMLEdBQVksQ0FBWixDQUY2Qjs7O1VBSzdCLEtBQUswdkIsSUFBTCxHQUFZLEtBQUtDLEtBQUwsR0FBYXBuQyxXQUF6QjtVQUNBLEtBQUtzWixJQUFMLEdBQVksS0FBWjtVQUNBLEtBQUswdEIsUUFBTCxHQUFnQixJQUFoQjtVQUVBLEtBQUs1b0IsTUFBTCxHQUFjLE1BQWQ7VUFDQSxLQUFLblgsR0FBTCxHQUFXakgsV0FBWDtVQUVBLEtBQUtnb0MsVUFBTCxDQUFnQng2QixPQUFoQixDQUF3Qnk2QixhQUF4Qjs7VUFFQSxJQUFJLENBQUNLLGFBQUwsRUFBb0I7WUFDbEIsS0FBSyxJQUFJem1DLElBQVQsSUFBaUIsSUFBakIsRUFBdUI7O2NBRXJCLElBQUlBLElBQUksQ0FBQzhDLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLElBQ0F3L0IsTUFBTSxDQUFDN21DLElBQVAsQ0FBWSxJQUFaLEVBQWtCdUUsSUFBbEIsQ0FEQSxJQUVBLENBQUN1RCxLQUFLLENBQUMsQ0FBQ3ZELElBQUksQ0FBQ2dELEtBQUwsQ0FBVyxDQUFYLENBQUYsQ0FGVixFQUU0QjtnQkFDMUIsS0FBS2hELElBQUwsSUFBYTdCLFdBQWI7Ozs7U0F2QlU7UUE2QmxCdW9DLElBQUksRUFBRSxnQkFBVztVQUNmLEtBQUtqdkIsSUFBTCxHQUFZLElBQVo7VUFFQSxJQUFJa3ZCLFNBQVMsR0FBRyxLQUFLUixVQUFMLENBQWdCLENBQWhCLENBQWhCO1VBQ0EsSUFBSVMsVUFBVSxHQUFHRCxTQUFTLENBQUNOLFVBQTNCOztVQUNBLElBQUlPLFVBQVUsQ0FBQzdtQyxJQUFYLEtBQW9CLE9BQXhCLEVBQWlDO1lBQy9CLE1BQU02bUMsVUFBVSxDQUFDeGhDLEdBQWpCOzs7VUFHRixPQUFPLEtBQUt5aEMsSUFBWjtTQXRDZ0I7UUF5Q2xCckIsaUJBQWlCLEVBQUUsMkJBQVNzQixTQUFULEVBQW9CO1VBQ3JDLElBQUksS0FBS3J2QixJQUFULEVBQWU7WUFDYixNQUFNcXZCLFNBQU47OztVQUdGLElBQUk1dUIsT0FBTyxHQUFHLElBQWQ7O1VBQ0EsU0FBUzZ1QixNQUFULENBQWdCQyxHQUFoQixFQUFxQkMsTUFBckIsRUFBNkI7WUFDM0J2QyxNQUFNLENBQUMza0MsSUFBUCxHQUFjLE9BQWQ7WUFDQTJrQyxNQUFNLENBQUN0L0IsR0FBUCxHQUFhMGhDLFNBQWI7WUFDQTV1QixPQUFPLENBQUN0QyxJQUFSLEdBQWVveEIsR0FBZjs7WUFFQSxJQUFJQyxNQUFKLEVBQVk7OztjQUdWL3VCLE9BQU8sQ0FBQ3FFLE1BQVIsR0FBaUIsTUFBakI7Y0FDQXJFLE9BQU8sQ0FBQzlTLEdBQVIsR0FBY2pILFdBQWQ7OztZQUdGLE9BQU8sQ0FBQyxDQUFFOG9DLE1BQVY7OztVQUdGLEtBQUssSUFBSXRsQyxDQUFDLEdBQUcsS0FBS3drQyxVQUFMLENBQWdCNW1DLE1BQWhCLEdBQXlCLENBQXRDLEVBQXlDb0MsQ0FBQyxJQUFJLENBQTlDLEVBQWlELEVBQUVBLENBQW5ELEVBQXNEO1lBQ3BELElBQUkrckIsS0FBSyxHQUFHLEtBQUt5WSxVQUFMLENBQWdCeGtDLENBQWhCLENBQVo7WUFDQSxJQUFJK2lDLE1BQU0sR0FBR2hYLEtBQUssQ0FBQzJZLFVBQW5COztZQUVBLElBQUkzWSxLQUFLLENBQUNxWSxNQUFOLEtBQWlCLE1BQXJCLEVBQTZCOzs7O2NBSTNCLE9BQU9nQixNQUFNLENBQUMsS0FBRCxDQUFiOzs7WUFHRixJQUFJclosS0FBSyxDQUFDcVksTUFBTixJQUFnQixLQUFLOVgsSUFBekIsRUFBK0I7Y0FDN0IsSUFBSWlaLFFBQVEsR0FBRzVFLE1BQU0sQ0FBQzdtQyxJQUFQLENBQVlpeUIsS0FBWixFQUFtQixVQUFuQixDQUFmO2NBQ0EsSUFBSXlaLFVBQVUsR0FBRzdFLE1BQU0sQ0FBQzdtQyxJQUFQLENBQVlpeUIsS0FBWixFQUFtQixZQUFuQixDQUFqQjs7Y0FFQSxJQUFJd1osUUFBUSxJQUFJQyxVQUFoQixFQUE0QjtnQkFDMUIsSUFBSSxLQUFLbFosSUFBTCxHQUFZUCxLQUFLLENBQUNzWSxRQUF0QixFQUFnQztrQkFDOUIsT0FBT2UsTUFBTSxDQUFDclosS0FBSyxDQUFDc1ksUUFBUCxFQUFpQixJQUFqQixDQUFiO2lCQURGLE1BRU8sSUFBSSxLQUFLL1gsSUFBTCxHQUFZUCxLQUFLLENBQUN1WSxVQUF0QixFQUFrQztrQkFDdkMsT0FBT2MsTUFBTSxDQUFDclosS0FBSyxDQUFDdVksVUFBUCxDQUFiOztlQUpKLE1BT08sSUFBSWlCLFFBQUosRUFBYztnQkFDbkIsSUFBSSxLQUFLalosSUFBTCxHQUFZUCxLQUFLLENBQUNzWSxRQUF0QixFQUFnQztrQkFDOUIsT0FBT2UsTUFBTSxDQUFDclosS0FBSyxDQUFDc1ksUUFBUCxFQUFpQixJQUFqQixDQUFiOztlQUZHLE1BS0EsSUFBSW1CLFVBQUosRUFBZ0I7Z0JBQ3JCLElBQUksS0FBS2xaLElBQUwsR0FBWVAsS0FBSyxDQUFDdVksVUFBdEIsRUFBa0M7a0JBQ2hDLE9BQU9jLE1BQU0sQ0FBQ3JaLEtBQUssQ0FBQ3VZLFVBQVAsQ0FBYjs7ZUFGRyxNQUtBO2dCQUNMLE1BQU0sSUFBSWhCLEtBQUosQ0FBVSx3Q0FBVixDQUFOOzs7O1NBL0ZVO1FBcUdsQlEsTUFBTSxFQUFFLGdCQUFTMWxDLElBQVQsRUFBZXFGLEdBQWYsRUFBb0I7VUFDMUIsS0FBSyxJQUFJekQsQ0FBQyxHQUFHLEtBQUt3a0MsVUFBTCxDQUFnQjVtQyxNQUFoQixHQUF5QixDQUF0QyxFQUF5Q29DLENBQUMsSUFBSSxDQUE5QyxFQUFpRCxFQUFFQSxDQUFuRCxFQUFzRDtZQUNwRCxJQUFJK3JCLEtBQUssR0FBRyxLQUFLeVksVUFBTCxDQUFnQnhrQyxDQUFoQixDQUFaOztZQUNBLElBQUkrckIsS0FBSyxDQUFDcVksTUFBTixJQUFnQixLQUFLOVgsSUFBckIsSUFDQXFVLE1BQU0sQ0FBQzdtQyxJQUFQLENBQVlpeUIsS0FBWixFQUFtQixZQUFuQixDQURBLElBRUEsS0FBS08sSUFBTCxHQUFZUCxLQUFLLENBQUN1WSxVQUZ0QixFQUVrQztjQUNoQyxJQUFJbUIsWUFBWSxHQUFHMVosS0FBbkI7Y0FDQTs7OztVQUlKLElBQUkwWixZQUFZLEtBQ1hybkMsSUFBSSxLQUFLLE9BQVQsSUFDQUEsSUFBSSxLQUFLLFVBRkUsQ0FBWixJQUdBcW5DLFlBQVksQ0FBQ3JCLE1BQWIsSUFBdUIzZ0MsR0FIdkIsSUFJQUEsR0FBRyxJQUFJZ2lDLFlBQVksQ0FBQ25CLFVBSnhCLEVBSW9DOzs7WUFHbENtQixZQUFZLEdBQUcsSUFBZjs7O1VBR0YsSUFBSTFDLE1BQU0sR0FBRzBDLFlBQVksR0FBR0EsWUFBWSxDQUFDZixVQUFoQixHQUE2QixFQUF0RDtVQUNBM0IsTUFBTSxDQUFDM2tDLElBQVAsR0FBY0EsSUFBZDtVQUNBMmtDLE1BQU0sQ0FBQ3QvQixHQUFQLEdBQWFBLEdBQWI7O1VBRUEsSUFBSWdpQyxZQUFKLEVBQWtCO1lBQ2hCLEtBQUs3cUIsTUFBTCxHQUFjLE1BQWQ7WUFDQSxLQUFLM0csSUFBTCxHQUFZd3hCLFlBQVksQ0FBQ25CLFVBQXpCO1lBQ0EsT0FBT3RDLGdCQUFQOzs7VUFHRixPQUFPLEtBQUswRCxRQUFMLENBQWMzQyxNQUFkLENBQVA7U0FwSWdCO1FBdUlsQjJDLFFBQVEsRUFBRSxrQkFBUzNDLE1BQVQsRUFBaUJ3QixRQUFqQixFQUEyQjtVQUNuQyxJQUFJeEIsTUFBTSxDQUFDM2tDLElBQVAsS0FBZ0IsT0FBcEIsRUFBNkI7WUFDM0IsTUFBTTJrQyxNQUFNLENBQUN0L0IsR0FBYjs7O1VBR0YsSUFBSXMvQixNQUFNLENBQUMza0MsSUFBUCxLQUFnQixPQUFoQixJQUNBMmtDLE1BQU0sQ0FBQzNrQyxJQUFQLEtBQWdCLFVBRHBCLEVBQ2dDO1lBQzlCLEtBQUs2VixJQUFMLEdBQVk4dUIsTUFBTSxDQUFDdC9CLEdBQW5CO1dBRkYsTUFHTyxJQUFJcy9CLE1BQU0sQ0FBQzNrQyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO1lBQ25DLEtBQUs4bUMsSUFBTCxHQUFZLEtBQUt6aEMsR0FBTCxHQUFXcy9CLE1BQU0sQ0FBQ3QvQixHQUE5QjtZQUNBLEtBQUttWCxNQUFMLEdBQWMsUUFBZDtZQUNBLEtBQUszRyxJQUFMLEdBQVksS0FBWjtXQUhLLE1BSUEsSUFBSTh1QixNQUFNLENBQUMza0MsSUFBUCxLQUFnQixRQUFoQixJQUE0Qm1tQyxRQUFoQyxFQUEwQztZQUMvQyxLQUFLdHdCLElBQUwsR0FBWXN3QixRQUFaOzs7VUFHRixPQUFPdkMsZ0JBQVA7U0F2SmdCO1FBMEpsQjJELE1BQU0sRUFBRSxnQkFBU3JCLFVBQVQsRUFBcUI7VUFDM0IsS0FBSyxJQUFJdGtDLENBQUMsR0FBRyxLQUFLd2tDLFVBQUwsQ0FBZ0I1bUMsTUFBaEIsR0FBeUIsQ0FBdEMsRUFBeUNvQyxDQUFDLElBQUksQ0FBOUMsRUFBaUQsRUFBRUEsQ0FBbkQsRUFBc0Q7WUFDcEQsSUFBSStyQixLQUFLLEdBQUcsS0FBS3lZLFVBQUwsQ0FBZ0J4a0MsQ0FBaEIsQ0FBWjs7WUFDQSxJQUFJK3JCLEtBQUssQ0FBQ3VZLFVBQU4sS0FBcUJBLFVBQXpCLEVBQXFDO2NBQ25DLEtBQUtvQixRQUFMLENBQWMzWixLQUFLLENBQUMyWSxVQUFwQixFQUFnQzNZLEtBQUssQ0FBQ3dZLFFBQXRDO2NBQ0FFLGFBQWEsQ0FBQzFZLEtBQUQsQ0FBYjtjQUNBLE9BQU9pVyxnQkFBUDs7O1NBaEtZO1FBcUtsQixTQUFTLGdCQUFTb0MsTUFBVCxFQUFpQjtVQUN4QixLQUFLLElBQUlwa0MsQ0FBQyxHQUFHLEtBQUt3a0MsVUFBTCxDQUFnQjVtQyxNQUFoQixHQUF5QixDQUF0QyxFQUF5Q29DLENBQUMsSUFBSSxDQUE5QyxFQUFpRCxFQUFFQSxDQUFuRCxFQUFzRDtZQUNwRCxJQUFJK3JCLEtBQUssR0FBRyxLQUFLeVksVUFBTCxDQUFnQnhrQyxDQUFoQixDQUFaOztZQUNBLElBQUkrckIsS0FBSyxDQUFDcVksTUFBTixLQUFpQkEsTUFBckIsRUFBNkI7Y0FDM0IsSUFBSXJCLE1BQU0sR0FBR2hYLEtBQUssQ0FBQzJZLFVBQW5COztjQUNBLElBQUkzQixNQUFNLENBQUMza0MsSUFBUCxLQUFnQixPQUFwQixFQUE2QjtnQkFDM0IsSUFBSXduQyxNQUFNLEdBQUc3QyxNQUFNLENBQUN0L0IsR0FBcEI7Z0JBQ0FnaEMsYUFBYSxDQUFDMVksS0FBRCxDQUFiOzs7Y0FFRixPQUFPNlosTUFBUDs7V0FUb0I7Ozs7VUFleEIsTUFBTSxJQUFJdEMsS0FBSixDQUFVLHVCQUFWLENBQU47U0FwTGdCO1FBdUxsQnVDLGFBQWEsRUFBRSx1QkFBU3ZoQixRQUFULEVBQW1CMGYsVUFBbkIsRUFBK0JDLE9BQS9CLEVBQXdDO1VBQ3JELEtBQUtULFFBQUwsR0FBZ0I7WUFDZHg4QixRQUFRLEVBQUUrTixNQUFNLENBQUN1UCxRQUFELENBREY7WUFFZDBmLFVBQVUsRUFBRUEsVUFGRTtZQUdkQyxPQUFPLEVBQUVBO1dBSFg7O1VBTUEsSUFBSSxLQUFLcnBCLE1BQUwsS0FBZ0IsTUFBcEIsRUFBNEI7OztZQUcxQixLQUFLblgsR0FBTCxHQUFXakgsV0FBWDs7O1VBR0YsT0FBT3dsQyxnQkFBUDs7T0FwTUosQ0FsZ0JnQzs7Ozs7TUE4c0JoQyxPQUFPaGpDLE9BQVA7S0E5c0JhOzs7O0lBcXRCYixDQUE2QjNGLE1BQU0sQ0FBQzJGLE9BQXBDLENBcnRCYSxDQUFmOztJQXd0QkEsSUFBSTtNQUNGOG1DLGtCQUFrQixHQUFHckYsT0FBckI7S0FERixDQUVFLE9BQU9zRixvQkFBUCxFQUE2Qjs7Ozs7Ozs7Ozs7TUFXN0IsSUFBSSxPQUFPQyxVQUFQLEtBQXNCLFFBQTFCLEVBQW9DO1FBQ2xDQSxVQUFVLENBQUNGLGtCQUFYLEdBQWdDckYsT0FBaEM7T0FERixNQUVPO1FBQ0xobkMsUUFBUSxDQUFDLEdBQUQsRUFBTSx3QkFBTixDQUFSLENBQXdDZ25DLE9BQXhDOzs7Ozs7O0lDOXVCSixJQUFJcm5DLE1BQU0sR0FBR0MsY0FBQSxHQUFpQixPQUFPQyxNQUFQLElBQWlCLFdBQWpCLElBQWdDQSxNQUFNLENBQUNDLElBQVAsSUFBZUEsSUFBL0MsR0FDMUJELE1BRDBCLEdBQ2pCLE9BQU9FLElBQVAsSUFBZSxXQUFmLElBQThCQSxJQUFJLENBQUNELElBQUwsSUFBYUEsSUFBM0MsR0FBa0RDLElBQWxEO01BRVRDLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFISjtJQUlBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxHQUFHLEdBQUdOLE1BQU47Ozs7SUNMNUIsSUFBSWtCLElBQUksR0FBR2pCLGNBQUEsR0FBaUI7TUFBRWtCLE9BQU8sRUFBRTtLQUF2QztJQUNBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxHQUFHLEdBQUdGLElBQU47OztFQ0Q1QixnQkFBYyxHQUFHLG1CQUFBLENBQVVWLEVBQVYsRUFBYztJQUM3QixJQUFJLE9BQU9BLEVBQVAsSUFBYSxVQUFqQixFQUE2QixNQUFNYyxTQUFTLENBQUNkLEVBQUUsR0FBRyxxQkFBTixDQUFmO0lBQzdCLE9BQU9BLEVBQVA7RUFDRCxDQUhEOztFQ0VBLFVBQWMsR0FBRyxhQUFBLENBQVVxQixFQUFWLEVBQWMwQyxJQUFkLEVBQW9CQyxNQUFwQixFQUE0QjtJQUMzQ0MsWUFBUyxDQUFDNUMsRUFBRCxDQUFUO0lBQ0EsSUFBSTBDLElBQUksS0FBS25CLFNBQWIsRUFBd0IsT0FBT3ZCLEVBQVA7O0lBQ3hCLFFBQVEyQyxNQUFSO01BQ0UsS0FBSyxDQUFMO1FBQVEsT0FBTyxVQUFVdkQsQ0FBVixFQUFhO1VBQzFCLE9BQU9ZLEVBQUUsQ0FBQ25CLElBQUgsQ0FBUTZELElBQVIsRUFBY3RELENBQWQsQ0FBUDtTQURNOztNQUdSLEtBQUssQ0FBTDtRQUFRLE9BQU8sVUFBVUEsQ0FBVixFQUFheUQsQ0FBYixFQUFnQjtVQUM3QixPQUFPN0MsRUFBRSxDQUFDbkIsSUFBSCxDQUFRNkQsSUFBUixFQUFjdEQsQ0FBZCxFQUFpQnlELENBQWpCLENBQVA7U0FETTs7TUFHUixLQUFLLENBQUw7UUFBUSxPQUFPLFVBQVV6RCxDQUFWLEVBQWF5RCxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtVQUNoQyxPQUFPOUMsRUFBRSxDQUFDbkIsSUFBSCxDQUFRNkQsSUFBUixFQUFjdEQsQ0FBZCxFQUFpQnlELENBQWpCLEVBQW9CQyxDQUFwQixDQUFQO1NBRE07OztJQUlWLE9BQU87O09BQXlCO01BQzlCLE9BQU85QyxFQUFFLENBQUMrQyxLQUFILENBQVNMLElBQVQsRUFBZU0sU0FBZixDQUFQO0tBREY7RUFHRCxDQWpCRDs7RUNGQSxlQUFjLEdBQUcsa0JBQUEsQ0FBVXJFLEVBQVYsRUFBYztJQUM3QixPQUFPLE9BQU9BLEVBQVAsS0FBYyxRQUFkLEdBQXlCQSxFQUFFLEtBQUssSUFBaEMsR0FBdUMsT0FBT0EsRUFBUCxLQUFjLFVBQTVEO0VBQ0QsQ0FGRDs7RUNDQSxlQUFjLEdBQUcsa0JBQUEsQ0FBVUEsRUFBVixFQUFjO0lBQzdCLElBQUksQ0FBQ2EsV0FBUSxDQUFDYixFQUFELENBQWIsRUFBbUIsTUFBTWMsU0FBUyxDQUFDZCxFQUFFLEdBQUcsb0JBQU4sQ0FBZjtJQUNuQixPQUFPQSxFQUFQO0VBQ0QsQ0FIRDs7RUNEQSxZQUFjLEdBQUcsZUFBQSxDQUFVRyxJQUFWLEVBQWdCO0lBQy9CLElBQUk7TUFDRixPQUFPLENBQUMsQ0FBQ0EsSUFBSSxFQUFiO0tBREYsQ0FFRSxPQUFPQyxDQUFQLEVBQVU7TUFDVixPQUFPLElBQVA7O0VBRUgsQ0FORDs7RUNDQSxrQkFBYyxHQUFHLENBQUNDLFFBQW1CLENBQUMsWUFBWTtJQUNoRCxPQUFPQyxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0I7TUFBRUMsR0FBRyxFQUFFLGVBQVk7UUFBRSxPQUFPLENBQVA7O0tBQXBELEVBQW1FQyxDQUFuRSxJQUF3RSxDQUEvRTtFQUNELENBRm9DLENBQXJDOztFQ0FBLElBQUlNLFVBQVEsR0FBR1YsU0FBb0IsQ0FBQ1UsUUFBcEM7O0VBRUEsSUFBSUMsSUFBRSxHQUFHSCxXQUFRLENBQUNFLFVBQUQsQ0FBUixJQUFzQkYsV0FBUSxDQUFDRSxVQUFRLENBQUNFLGFBQVYsQ0FBdkM7O0VBQ0EsZ0JBQWMsR0FBRyxtQkFBQSxDQUFVakIsRUFBVixFQUFjO0lBQzdCLE9BQU9nQixJQUFFLEdBQUdELFVBQVEsQ0FBQ0UsYUFBVCxDQUF1QmpCLEVBQXZCLENBQUgsR0FBZ0MsRUFBekM7RUFDRCxDQUZEOztFQ0pBLG1CQUFjLEdBQUcsQ0FBQ0ssY0FBRCxJQUE4QixDQUFDYSxRQUFtQixDQUFDLFlBQVk7SUFDOUUsT0FBT1osTUFBTSxDQUFDQyxjQUFQLENBQXNCWSxZQUF3QixDQUFDLEtBQUQsQ0FBOUMsRUFBdUQsR0FBdkQsRUFBNEQ7TUFBRVgsR0FBRyxFQUFFLGVBQVk7UUFBRSxPQUFPLENBQVA7O0tBQWpGLEVBQWdHQyxDQUFoRyxJQUFxRyxDQUE1RztFQUNELENBRmtFLENBQW5FOztFQ0VBO0VBQ0E7O0VBQ0Esa0JBQWMsR0FBRyxxQkFBQSxDQUFVVCxFQUFWLEVBQWNvQixDQUFkLEVBQWlCO0lBQ2hDLElBQUksQ0FBQ1AsV0FBUSxDQUFDYixFQUFELENBQWIsRUFBbUIsT0FBT0EsRUFBUDtJQUNuQixJQUFJcUIsRUFBSixFQUFRQyxHQUFSO0lBQ0EsSUFBSUYsQ0FBQyxJQUFJLFFBQVFDLEVBQUUsR0FBR3JCLEVBQUUsQ0FBQ3VCLFFBQWhCLEtBQTZCLFVBQWxDLElBQWdELENBQUNWLFdBQVEsQ0FBQ1MsR0FBRyxHQUFHRCxFQUFFLENBQUNuQixJQUFILENBQVFGLEVBQVIsQ0FBUCxDQUE3RCxFQUFrRixPQUFPc0IsR0FBUDtJQUNsRixJQUFJLFFBQVFELEVBQUUsR0FBR3JCLEVBQUUsQ0FBQ3dCLE9BQWhCLEtBQTRCLFVBQTVCLElBQTBDLENBQUNYLFdBQVEsQ0FBQ1MsR0FBRyxHQUFHRCxFQUFFLENBQUNuQixJQUFILENBQVFGLEVBQVIsQ0FBUCxDQUF2RCxFQUE0RSxPQUFPc0IsR0FBUDtJQUM1RSxJQUFJLENBQUNGLENBQUQsSUFBTSxRQUFRQyxFQUFFLEdBQUdyQixFQUFFLENBQUN1QixRQUFoQixLQUE2QixVQUFuQyxJQUFpRCxDQUFDVixXQUFRLENBQUNTLEdBQUcsR0FBR0QsRUFBRSxDQUFDbkIsSUFBSCxDQUFRRixFQUFSLENBQVAsQ0FBOUQsRUFBbUYsT0FBT3NCLEdBQVA7SUFDbkYsTUFBTVIsU0FBUyxDQUFDLHlDQUFELENBQWY7RUFDRCxDQVBEOztFQ0RBLElBQUlXLElBQUUsR0FBR25CLE1BQU0sQ0FBQ0MsY0FBaEI7RUFFQSxPQUFTLEdBQUdGLGNBQXlCLEdBQUdDLE1BQU0sQ0FBQ0MsY0FBVixHQUEyQixTQUFTQSxjQUFULENBQXdCbUIsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCQyxVQUE5QixFQUEwQztJQUN4R0MsV0FBUSxDQUFDSCxDQUFELENBQVI7SUFDQUMsQ0FBQyxHQUFHRyxjQUFXLENBQUNILENBQUQsRUFBSSxJQUFKLENBQWY7SUFDQUUsV0FBUSxDQUFDRCxVQUFELENBQVI7SUFDQSxJQUFJRyxlQUFKLEVBQW9CLElBQUk7TUFDdEIsT0FBT04sSUFBRSxDQUFDQyxDQUFELEVBQUlDLENBQUosRUFBT0MsVUFBUCxDQUFUO0tBRGtCLENBRWxCLE9BQU94QixDQUFQLEVBQVU7OztJQUNaLElBQUksU0FBU3dCLFVBQVQsSUFBdUIsU0FBU0EsVUFBcEMsRUFBZ0QsTUFBTWQsU0FBUyxDQUFDLDBCQUFELENBQWY7SUFDaEQsSUFBSSxXQUFXYyxVQUFmLEVBQTJCRixDQUFDLENBQUNDLENBQUQsQ0FBRCxHQUFPQyxVQUFVLENBQUNJLEtBQWxCO0lBQzNCLE9BQU9OLENBQVA7RUFDRCxDQVZEOzs7OztFQ0xBLG1CQUFjLEdBQUcsc0JBQUEsQ0FBVU8sTUFBVixFQUFrQkQsS0FBbEIsRUFBeUI7SUFDeEMsT0FBTztNQUNMRSxVQUFVLEVBQUUsRUFBRUQsTUFBTSxHQUFHLENBQVgsQ0FEUDtNQUVMRSxZQUFZLEVBQUUsRUFBRUYsTUFBTSxHQUFHLENBQVgsQ0FGVDtNQUdMRyxRQUFRLEVBQUUsRUFBRUgsTUFBTSxHQUFHLENBQVgsQ0FITDtNQUlMRCxLQUFLLEVBQUVBO0tBSlQ7RUFNRCxDQVBEOztFQ0VBLFdBQWMsR0FBRzNCLGNBQXlCLEdBQUcsVUFBVWdDLE1BQVYsRUFBa0JwQyxHQUFsQixFQUF1QitCLEtBQXZCLEVBQThCO0lBQ3pFLE9BQU9QLFdBQUUsQ0FBQ2EsQ0FBSCxDQUFLRCxNQUFMLEVBQWFwQyxHQUFiLEVBQWtCc0MsZUFBVSxDQUFDLENBQUQsRUFBSVAsS0FBSixDQUE1QixDQUFQO0VBQ0QsQ0FGeUMsR0FFdEMsVUFBVUssTUFBVixFQUFrQnBDLEdBQWxCLEVBQXVCK0IsS0FBdkIsRUFBOEI7SUFDaENLLE1BQU0sQ0FBQ3BDLEdBQUQsQ0FBTixHQUFjK0IsS0FBZDtJQUNBLE9BQU9LLE1BQVA7RUFDRCxDQUxEOztFQ0ZBLElBQUl0QyxnQkFBYyxHQUFHLEdBQUdBLGNBQXhCOztFQUNBLFVBQWMsR0FBRyxhQUFBLENBQVVDLEVBQVYsRUFBY0MsR0FBZCxFQUFtQjtJQUNsQyxPQUFPRixnQkFBYyxDQUFDRyxJQUFmLENBQW9CRixFQUFwQixFQUF3QkMsR0FBeEIsQ0FBUDtFQUNELENBRkQ7O0VDSUEsSUFBSXFFLFdBQVMsR0FBRyxXQUFoQjs7RUFFQSxJQUFJQyxTQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVQyxJQUFWLEVBQWdCQyxJQUFoQixFQUFzQkMsTUFBdEIsRUFBOEI7SUFDMUMsSUFBSUMsU0FBUyxHQUFHSCxJQUFJLEdBQUdELE9BQU8sQ0FBQ0ssQ0FBL0I7SUFDQSxJQUFJQyxTQUFTLEdBQUdMLElBQUksR0FBR0QsT0FBTyxDQUFDTyxDQUEvQjtJQUNBLElBQUlDLFNBQVMsR0FBR1AsSUFBSSxHQUFHRCxPQUFPLENBQUNuRCxDQUEvQjtJQUNBLElBQUk0RCxRQUFRLEdBQUdSLElBQUksR0FBR0QsT0FBTyxDQUFDNUMsQ0FBOUI7SUFDQSxJQUFJc0QsT0FBTyxHQUFHVCxJQUFJLEdBQUdELE9BQU8sQ0FBQ1csQ0FBN0I7SUFDQSxJQUFJbW5DLE9BQU8sR0FBRzduQyxJQUFJLEdBQUdELE9BQU8sQ0FBQ3FCLENBQTdCO0lBQ0EsSUFBSVIsT0FBTyxHQUFHUCxTQUFTLEdBQUduRSxPQUFILEdBQVVBLE9BQUksQ0FBQytELElBQUQsQ0FBSixLQUFlL0QsT0FBSSxDQUFDK0QsSUFBRCxDQUFKLEdBQWEsRUFBNUIsQ0FBakM7SUFDQSxJQUFJWSxRQUFRLEdBQUdELE9BQU8sQ0FBQ2QsV0FBRCxDQUF0QjtJQUNBLElBQUlhLE1BQU0sR0FBR04sU0FBUyxHQUFHckYsU0FBSCxHQUFZdUYsU0FBUyxHQUFHdkYsU0FBTSxDQUFDaUYsSUFBRCxDQUFULEdBQWtCLENBQUNqRixTQUFNLENBQUNpRixJQUFELENBQU4sSUFBZ0IsRUFBakIsRUFBcUJILFdBQXJCLENBQTdEO0lBQ0EsSUFBSXJFLEdBQUosRUFBU3FGLEdBQVQsRUFBY0MsR0FBZDtJQUNBLElBQUlWLFNBQUosRUFBZUgsTUFBTSxHQUFHRCxJQUFUOztJQUNmLEtBQUt4RSxHQUFMLElBQVl5RSxNQUFaLEVBQW9COztNQUVsQlksR0FBRyxHQUFHLENBQUNYLFNBQUQsSUFBY1EsTUFBZCxJQUF3QkEsTUFBTSxDQUFDbEYsR0FBRCxDQUFOLEtBQWdCMkMsU0FBOUM7TUFDQSxJQUFJMEMsR0FBRyxJQUFJNUIsTUFBRyxDQUFDMEIsT0FBRCxFQUFVbkYsR0FBVixDQUFkLEVBQThCLFNBSFo7O01BS2xCc0YsR0FBRyxHQUFHRCxHQUFHLEdBQUdILE1BQU0sQ0FBQ2xGLEdBQUQsQ0FBVCxHQUFpQnlFLE1BQU0sQ0FBQ3pFLEdBQUQsQ0FBaEMsQ0FMa0I7O01BT2xCbUYsT0FBTyxDQUFDbkYsR0FBRCxDQUFQLEdBQWU0RSxTQUFTLElBQUksT0FBT00sTUFBTSxDQUFDbEYsR0FBRCxDQUFiLElBQXNCLFVBQW5DLEdBQWdEeUUsTUFBTSxDQUFDekUsR0FBRCxDQUF0RDtRQUViZ0YsT0FBTyxJQUFJSyxHQUFYLEdBQWlCRyxNQUFHLENBQUNGLEdBQUQsRUFBTS9GLFNBQU4sQ0FBcEI7UUFFQTZzQyxPQUFPLElBQUlsbkMsTUFBTSxDQUFDbEYsR0FBRCxDQUFOLElBQWVzRixHQUExQixHQUFpQyxVQUFVbU8sQ0FBVixFQUFhO1FBQzlDLElBQUk5TyxDQUFDLEdBQUcsU0FBSkEsQ0FBSSxDQUFVbkUsQ0FBVixFQUFheUQsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI7VUFDekIsSUFBSSxnQkFBZ0J1UCxDQUFwQixFQUF1QjtZQUNyQixRQUFRclAsU0FBUyxDQUFDTCxNQUFsQjtjQUNFLEtBQUssQ0FBTDtnQkFBUSxPQUFPLElBQUkwUCxDQUFKLEVBQVA7O2NBQ1IsS0FBSyxDQUFMO2dCQUFRLE9BQU8sSUFBSUEsQ0FBSixDQUFNalQsQ0FBTixDQUFQOztjQUNSLEtBQUssQ0FBTDtnQkFBUSxPQUFPLElBQUlpVCxDQUFKLENBQU1qVCxDQUFOLEVBQVN5RCxDQUFULENBQVA7OztZQUNSLE9BQU8sSUFBSXdQLENBQUosQ0FBTWpULENBQU4sRUFBU3lELENBQVQsRUFBWUMsQ0FBWixDQUFQOzs7VUFDRixPQUFPdVAsQ0FBQyxDQUFDdFAsS0FBRixDQUFRLElBQVIsRUFBY0MsU0FBZCxDQUFQO1NBUEo7O1FBU0FPLENBQUMsQ0FBQ04sV0FBRCxDQUFELEdBQWVvUCxDQUFDLENBQUNwUCxXQUFELENBQWhCO1FBQ0EsT0FBT00sQ0FBUCxDQVg4QztPQUFkLENBYS9CVyxHQWIrQixDQUFoQyxHQWFRUCxRQUFRLElBQUksT0FBT08sR0FBUCxJQUFjLFVBQTFCLEdBQXVDRSxNQUFHLENBQUM1RixRQUFRLENBQUNLLElBQVYsRUFBZ0JxRixHQUFoQixDQUExQyxHQUFpRUEsR0FqQjNFLENBUGtCOztNQTBCbEIsSUFBSVAsUUFBSixFQUFjO1FBQ1osQ0FBQ0ksT0FBTyxDQUFDa25DLE9BQVIsS0FBb0JsbkMsT0FBTyxDQUFDa25DLE9BQVIsR0FBa0IsRUFBdEMsQ0FBRCxFQUE0Q3JzQyxHQUE1QyxJQUFtRHNGLEdBQW5ELENBRFk7O1FBR1osSUFBSWYsSUFBSSxHQUFHRCxPQUFPLENBQUNzQixDQUFmLElBQW9CUixRQUFwQixJQUFnQyxDQUFDQSxRQUFRLENBQUNwRixHQUFELENBQTdDLEVBQW9EMEQsT0FBSSxDQUFDMEIsUUFBRCxFQUFXcEYsR0FBWCxFQUFnQnNGLEdBQWhCLENBQUo7OztFQUd6RCxDQTVDRDs7O0FBOENBaEIsV0FBTyxDQUFDSyxDQUFSLEdBQVksQ0FBWjs7QUFDQUwsV0FBTyxDQUFDTyxDQUFSLEdBQVksQ0FBWjs7QUFDQVAsV0FBTyxDQUFDbkQsQ0FBUixHQUFZLENBQVo7O0FBQ0FtRCxXQUFPLENBQUM1QyxDQUFSLEdBQVksQ0FBWjs7QUFDQTRDLFdBQU8sQ0FBQ1csQ0FBUixHQUFZLEVBQVo7O0FBQ0FYLFdBQU8sQ0FBQ3FCLENBQVIsR0FBWSxFQUFaOztBQUNBckIsV0FBTyxDQUFDb0IsQ0FBUixHQUFZLEVBQVo7O0FBQ0FwQixXQUFPLENBQUNzQixDQUFSLEdBQVksR0FBWjs7RUFDQSxhQUFjLEdBQUd0QixTQUFqQjs7QUMxREFBLFdBQU8sQ0FBQ0EsU0FBTyxDQUFDTyxDQUFULEVBQVk7SUFBRXRGLE1BQU0sRUFBRWE7RUFBVixDQUFaLENBQVA7O0VDRkEsWUFBYyxHQUFHYSxPQUEyQixDQUFDMUIsTUFBN0M7Ozs7SUNHQSxJQUFJK3NDLE9BQU8sR0FBR0Msc0JBQXNCLENBQUN0ckMsUUFBRCxDQUFwQzs7SUFFQSxTQUFTc3JDLHNCQUFULENBQWdDbkYsR0FBaEMsRUFBcUM7TUFBRSxPQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ29GLFVBQVgsR0FBd0JwRixHQUF4QixHQUE4QjtRQUFFLFdBQVdBO09BQWxEOzs7SUFFdkMsSUFBSWtGLE9BQU8sQ0FBQyxTQUFELENBQVAsQ0FBbUJHLGNBQW5CLElBQXFDLE9BQU9yYyxPQUFQLEtBQW1CLFdBQXhELElBQXVFQSxPQUFPLENBQUNzYyxJQUFuRixFQUF5RjtNQUN2RnRjLE9BQU8sQ0FBQ3NjLElBQVIsQ0FBYSxvR0FBb0csNkZBQXBHLEdBQW9NLHFGQUFwTSxHQUE0UixnQ0FBelM7OztJQUdGSixPQUFPLENBQUMsU0FBRCxDQUFQLENBQW1CRyxjQUFuQixHQUFvQyxJQUFwQzs7Ozs7Ozs7OztBQ2tPQSxNQU9NRSxNQUFnQlIsV0FBMENRLFlBUGhFO0VBQUEsSUFpQk1DLElBQVNELE1BQ1hBLElBQWFFLFlBQWJGLENBQTBCLFVBQTFCQSxFQUFzQztJQUNwQ3R2QixZQUFhM0g7TUFBQUEsT0FBTUEsQ0FBTkE7O0VBRHVCLENBQXRDaTNCLENBRFdBLEdBRVVqM0IsS0FFckIvUyxDQXJCSjtFQUFBLElBdUdNbXFDLGtCQUFTLENBQWNwdEMsS0FBSytDLE1BQUwvQyxLQUFQa0UsRUFBUCxFQUE2QjRELEtBQTdCLENBQW1DLENBQW5DLENBQVRzbEMsTUF2R047RUFBQSxJQTBHTUMsSUFBYyxNQUFNRCxDQTFHMUI7RUFBQSxJQThHTUUsZUFBaUJELENBQWpCQyxNQTlHTjtFQUFBLElBZ0hNOXRCLE1BQUlwZSxRQWhIVjtFQUFBLElBbUhNbXNDLElBQWUsU0FBZkEsQ0FBZTtJQUFBLElBQUMvZSxDQUFELHVFQUFLLEVBQUw7SUFBQSxPQUFZaFAsSUFBRWd1QixhQUFGaHVCLENBQWdCZ1AsQ0FBaEJoUCxDQUFaO0VBQUEsQ0FuSHJCO0VBQUEsSUF1SE1pdUIsSUFBZXByQyxTQUFmb3JDLENBQWVwckM7SUFBQUEsT0FDVCxTQUFWQSxDQUFVLElBQXlCLG1CQUFUQSxDQUFTLElBQTRCLHFCQUFUQSxDQURuQ0E7RUFBQUEsQ0F2SHJCO0VBQUEsSUF5SE00SCxJQUFVRCxNQUFNQyxPQXpIdEI7RUFBQSxJQTBITXlqQyxJQUFjcnJDLFNBQWRxckMsQ0FBY3JyQztJQUFBQTtJQUNsQixTQUFRQSxDQUFSNEgsS0FFNkMsc0JBQXJCLFVBQWhCK21CLEtBQWdCLEtBQWhCM3VCLEtBQWdCLENBQWhCQSxLQUFnQjJ1QixzQkFBT3ZqQixRQUFQdWpCLENBQXFCLENBRjdDO0VBRStCdmpCLENBN0hqQztFQUFBLElBaUpNa2dDLElBQWUscURBakpyQjtFQUFBLElBc0pNQyxJQUFrQixNQXRKeEI7RUFBQSxJQTBKTUMsSUFBbUIsSUExSnpCO0VBQUEsSUFrTE1DLE1BQWMsbUZBbExwQjtFQUFBLElBMkxNQyxJQUEwQixJQTNMaEM7RUFBQSxJQTRMTUMsSUFBMEIsSUE1TGhDO0VBQUEsSUFtTU1DLElBQWlCLG9DQW5NdkI7RUFBQSxJQXVQTXptQyxJQUNtQjNDLFNBRG5CMkMsQ0FDbUIzQztJQUFBQSxPQUN2QixVQUFDcXBDLENBQUQ7TUFBQSxrQ0FBbUMxeUIsQ0FBbkM7UUFBbUNBLENBQW5DOzs7TUFBQSxPQVVTO1FBRUwyeUIsWUFBZ0J0cEMsQ0FGWDtRQUdMcXBDLFVBSEs7UUFJTDF5QjtPQWRKO0tBRHVCM1c7RUFBQUEsQ0F4UHpCO0VBQUEsSUF3UmEyYyxJQUFPaGEsRUFsRkEsQ0FrRkFBLENBeFJwQjtFQUFBLElBaVRhNG1DLEFBTUFDLElBQVdubkMsT0FBT29uQyxHQUFQcG5DLENBQVcsY0FBWEEsQ0F2VHhCO0VBQUEsSUE0VWFxbkMsSUFBVXJuQyxPQUFPb25DLEdBQVBwbkMsQ0FBVyxhQUFYQSxDQTVVdkI7RUFBQSxJQXFWTXNuQyxJQUFnQixJQUFJclosT0FBSixFQXJWdEI7RUFBQSxJQTRZYXNaLElBQVMsU0FBVEEsQ0FBUyxDQUNwQnBzQyxDQURvQixFQUVwQnFzQyxDQUZvQixFQUdwQkMsQ0FIb0IsRUFHcEJBO0lBQUFBO0lBVUEsSUFBTUMsSUFBeUMsVUFBekI1ZCwyQkFBUzZkLFlBQWdCLEtBQWhCQSxLQUFnQixDQUFoQkEsS0FBZ0I3ZCxTQUEvQztJQUdBLElBQUk4ZCxJQUFtQkYsRUFBa0NHLFVBQXpEOztJQVNBLFNBQWE5ckMsQ0FBYixLQUFJNnJDLENBQUosRUFBd0I7TUFDdEIsSUFBTUUsS0FBbUMsVUFBekI1VywyQkFBU3lXLFlBQWdCLEtBQWhCQSxLQUFnQixDQUFoQkEsS0FBZ0J6VyxZQUF6Qzs7TUFpQkN3VyxFQUFrQ0csVUFBbENILEdBQXNDRSxJQUFPLElBQUlHLENBQUosQ0FDNUNQLEVBQVVRLFlBQVZSLENBQXVCbkIsR0FBdkJtQixFQUF1Q00sRUFBdkNOLENBRDRDLEVBRTVDTSxFQUY0QyxFQUU1Q0EsS0FDQS9yQyxDQUg0QyxFQUk1QzByQyxnQkFBVyxFQUppQyxDQUE3Q0M7OztJQWdCSCxPQVRBRSxFQUFLSyxJQUFMTCxDQUFnQnpzQyxDQUFoQnlzQyxHQVNPQSxDQUFQO0VBQU9BLENBdmNUO0VBQUEsSUFtZE1NLElBQVM1dkIsSUFBRTZ2QixnQkFBRjd2QixDQUNiQSxHQURhQSxFQUViLEdBRmFBLEVBR2IsSUFIYUEsRUFHYixDQUNBLENBSmFBLENBbmRmO0VBQUEsSUF3Zk04dkIsSUFBa0IsU0FBbEJBLENBQWtCLENBQ3RCcEIsQ0FEc0IsRUFFdEJycEMsQ0FGc0IsRUFFdEJBO0lBUUEsSUFBTWdKLElBQUlxZ0MsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQTNCO1FBSU1xQixJQUF1QyxFQUo3QztJQUtBLElBS0lDLENBTEo7UUFBSWh1QixJQWhVYSxNQWdVTjNjLENBaFVNLEdBZ1VnQixPQWhVaEIsR0FnVTBCLEVBQTNDO1FBU0k0cUMsSUFBUTlCLENBVFo7O0lBV0EsS0FBSyxJQUFJbG5DLEtBQUksQ0FBYixFQUFnQkEsS0FBSW9ILENBQXBCLEVBQXVCcEgsSUFBdkIsRUFBNEI7TUFDMUIsSUFBTXVQLEtBQUlrNEIsRUFBUXpuQyxFQUFSeW5DLENBQVY7O01BTUEsSUFDSXdCLFdBREo7VUFHSXI5QixXQUhKO1VBQUlzOUIsTUFBb0IsQ0FBeEI7VUFFSTNwQixLQUFZLENBRmhCOztNQU9BLE9BQU9BLEtBQVloUSxHQUFFM1IsTUFBZDJoQixLQUVMeXBCLEVBQU16cEIsU0FBTnlwQixHQUFrQnpwQixFQUFsQnlwQixFQUNBcDlCLEtBQVFvOUIsRUFBTWp2QyxJQUFOaXZDLENBQVd6NUIsRUFBWHk1QixDQURSQSxFQUVjLFNBQVZwOUIsRUFKQzJULENBQVA7UUFPRUEsS0FBWXlwQixFQUFNenBCLFNBQWxCQSxFQUNJeXBCLE1BQVU5QixDQUFWOEIsR0FDMkIsVUFBekJwOUIsR0F2WlUsQ0F1WlZBLENBQXlCLEdBQzNCbzlCLElBQVE3QixDQURtQixHQUNuQkEsS0FDMEIzcUMsQ0FEMUIycUMsS0FDQ3Y3QixHQXpaRyxDQXlaSEEsQ0FERHU3QixHQUdSNkIsSUFBUTVCLENBSEFELEdBR0FDLEtBQ3FCNXFDLENBRHJCNHFDLEtBQ0N4N0IsR0EzWkYsQ0EyWkVBLENBRER3N0IsSUFFSkksRUFBZWg5QixJQUFmZzlCLENBQW9CNTdCLEdBNVpqQixDQTRaaUJBLENBQXBCNDdCLE1BR0Z1QixJQUFzQjU4QixPQUFPLE9BQUtQLEdBL1o3QixDQStaNkJBLENBQVpPLEVBQStCLEdBQS9CQSxDQUhwQnE3QixHQUtKd0IsSUFBUTNCLEdBUEFELElBT0FDLEtBQzZCN3FDLENBRDdCNnFDLEtBQ0N6N0IsR0FqYU0sQ0FpYU5BLENBRER5N0IsS0FRUjJCLElBQVEzQixHQVJBQSxDQVpSMkIsR0FzQk9BLE1BQVUzQixHQUFWMkIsR0FDbUIsUUFBeEJwOUIsR0F6WVMsQ0F5WVRBLENBQXdCLElBRzFCbzlCLElBQVFELGdCQUFtQjdCLENBQTNCOEIsRUFHQUUsTUFBb0IsQ0FOTSxJQU1OLEtBQ2Uxc0MsQ0FEZixLQUNYb1AsR0EvWUksQ0ErWUpBLENBRFcsR0FHcEJzOUIsTUFBb0IsQ0FIQSxJQUtwQkEsS0FBbUJGLEVBQU16cEIsU0FBTnlwQixHQUFrQnA5QixHQWxackIsQ0FrWnFCQSxFQUF5QmhPLE1BQTlEc3JDLEVBQ0FELEtBQVdyOUIsR0FwWkUsQ0FvWkZBLENBRFhzOUIsRUFFQUYsU0FDd0J4c0MsQ0FEeEJ3c0MsS0FDRXA5QixHQXBaTyxDQW9aUEEsQ0FERm85QixHQUVNM0IsR0FGTjJCLEdBRzRCLFFBQXRCcDlCLEdBdFpHLENBc1pIQSxDQUFzQixHQUN0QjI3QixDQURzQixHQUV0QkQsQ0FaYyxDQVBiMEIsR0FzQlRBLE1BQVV6QixDQUFWeUIsSUFDQUEsTUFBVTFCLENBRFYwQixHQUdBQSxJQUFRM0IsR0FIUjJCLEdBSVNBLE1BQVU3QixDQUFWNkIsSUFBNkJBLE1BQVU1QixDQUF2QzRCLEdBQ1RBLElBQVE5QixDQURDOEIsSUFLVEEsSUFBUTNCLEdBQVIyQixFQUNBRCxTQUFrQnZzQyxDQU5Ud3NDLENBakRYenBCOzs7TUFxRkYsSUFBTTlJLEtBQ0p1eUIsTUFBVTNCLEdBQVYyQixJQUF5QnZCLEVBQVF6bkMsS0FBSSxDQUFaeW5DLEVBQWV6d0IsVUFBZnl3QixDQUEwQixJQUExQkEsQ0FBekJ1QixHQUEyRCxHQUEzREEsR0FBaUUsRUFEbkU7O01BRUFqdUIsS0FDRWl1QixNQUFVOUIsQ0FBVjhCLEdBQ0l6NUIsS0FBSXMzQixDQURSbUMsR0FFSUUsTUFBb0IsQ0FBcEJBLElBQ0NKLEVBQVVuc0MsSUFBVm1zQyxDQUFlRyxFQUFmSCxHQUNEdjVCLEdBQUVsTyxLQUFGa08sQ0FBUSxDQUFSQSxFQUFXMjVCLEVBQVgzNUIsSUFsaUJtQixPQWtpQm5CQSxHQUVFQSxHQUFFbE8sS0FBRmtPLENBQVEyNUIsRUFBUjM1QixDQUZGQSxHQUdBbzNCLENBSEFwM0IsR0FJQWtILEVBTkF5eUIsSUFPQTM1QixLQUNBbzNCLENBREFwM0IsSUFDQW8zQixDQUN1QixDQUR2QkEsS0FDQ3VDLEVBRER2QyxJQUM0Qm1DLEVBQVVuc0MsSUFBVm1zQyxDQUFVbnNDLEtBQUtILENBQWZzc0MsR0FBMkI5b0MsRUFEdkQybUMsSUFDNERsd0IsRUFGNURsSCxDQVZOd0w7OztJQWVGLElBQU1vdUIsSUFDSnB1QixLQUFRMHNCLEVBQVFyZ0MsQ0FBUnFnQyxLQUFjLEtBQXRCMXNCLEtBdmNlLE1BdWNpQjNjLENBdmNqQixHQXVjdUMsUUF2Y3ZDLEdBdWNrRCxFQUFqRTJjLENBREY7SUFRQSxLQUFLeFgsTUFBTUMsT0FBTkQsQ0FBY2trQyxDQUFkbGtDLENBQUwsSUFBbUJra0MsQ0FBYUEsRUFBUTl0QyxjQUFSOHRDLENBQXVCLEtBQXZCQSxDQUFoQyxFQWtCRSxNQUFVbkUsTUFqQkksZ0NBaUJKQSxDQUFWO0lBR0YsT0FBTyxNQUNNOW1DLENBRE4sS0FDTGlxQyxDQURLLEdBRURBLEVBQU92dkIsVUFBUHV2QixDQUFrQjBDLENBQWxCMUMsQ0FGQyxHQUdBMEMsQ0FIQSxFQUlMTCxDQUpLLENBQVA7RUFJRUEsQ0E5cUJKOztNQW9yQk1NO0lBTUpwZ0MsaUJBR0VrL0IsQ0FIRmwvQixFQUdFay9CO01BQUFBLElBRENULENBQ0RTLFFBREFULE9BQ0FTO1VBRDBCOXBDLENBQzFCOHBDLFFBRFVSLFVBQ1ZROztNQUFBQTs7TUFFQSxJQUFJL2dCLENBQUo7TUFQRmtpQixLQUFLQyxLQUFMRCxHQUE2QixFQUE3QkE7TUFRRSxJQUFJRSxJQUFZLENBQWhCO1VBQ0lDLElBQWdCLENBRHBCOztNQUVNQyxRQUFZaEMsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQTdCZ0M7VUFDQUgsQ0FEQUcsR0FDUUosS0FBS0MsS0FEYkc7ZUFJb0JaLEVBQWdCcEIsQ0FBaEJvQixFQUF5QnpxQyxDQUF6QnlxQyxDQUpwQlk7O1VBSUMxdUIsQ0FKRDB1QjtVQUlPWCxDQUpQVzs7TUFTTixJQUpBSixLQUFLbG5DLEVBQUxrbkMsR0FBVUQsRUFBU3Z1QyxhQUFUdXVDLENBQXVCcnVCLENBQXZCcXVCLEVBQTZCbEIsQ0FBN0JrQixDQUFWQyxFQUNBVixFQUFPZSxXQUFQZixHQUFxQlUsS0FBS2xuQyxFQUFMa25DLENBQVFNLE9BRDdCTixFQWhnQmUsTUFvZ0JYanJDLENBQUosRUFBeUI7UUFDdkIsSUFBTXVyQyxNQUFVTixLQUFLbG5DLEVBQUxrbkMsQ0FBUU0sT0FBeEI7WUFDTUMsTUFBYUQsSUFBUUUsVUFEM0I7UUFFQUQsSUFBV0UsTUFBWEYsSUFDQUQsSUFBUUksTUFBUkosK0JBQWtCQyxJQUFXSSxVQUE3QkwsRUFEQUM7OztNQUtGLE9BQXNDLFVBQTlCemlCLElBQU93aEIsRUFBT3NCLFFBQVB0QixFQUF1QixLQUFRVyxFQUFNMXJDLE1BQU4wckMsR0FBZUcsQ0FBN0QsR0FBd0U7UUFDdEUsSUFBc0IsTUFBbEJ0aUIsRUFBSytpQixRQUFULEVBQXlCO1VBdUJ2QixJQUFLL2lCLEVBQWlCZ2pCLGFBQWpCaGpCLEVBQUwsRUFBdUM7WUFJckMsSUFBTWlqQixNQUFnQixFQUF0Qjs7WUFKcUMsMkNBS2pCampCLEVBQWlCa2pCLGlCQUFqQmxqQixFQUxpQjs7O1lBQUE7Y0FLckM7Z0JBQUEsSUFBVzlvQixHQUFYOztnQkFRRSxJQUNFQSxJQUFLaVksUUFBTGpZLENBeHBCZSxPQXdwQmZBLEtBQ0FBLElBQUsyWSxVQUFMM1ksQ0FBZ0Jzb0MsQ0FBaEJ0b0MsQ0FGRixFQUdFO2tCQUNBLElBQU1pc0MsTUFBV3hCLEVBQVVVLEdBQVZWLENBQWpCOztrQkFFQSxJQURBc0IsSUFBY3p0QyxJQUFkeXRDLENBQW1CL3JDLEdBQW5CK3JDLEdBQW1CL3JDLEtBQ0Y3QixDQURFNkIsS0FDZmlzQyxHQUFKLEVBQTRCO29CQUUxQixJQUdNQyxNQUhTcGpCLEVBQWlCcWpCLFlBQWpCcmpCLENBQ2JtakIsSUFBU2p6QixXQUFUaXpCLEtBaHFCVyxPQStwQkVuakIsRUFHT2pxQixLQUhQaXFCLENBR2F3ZixDQUhieGYsQ0FBZjt3QkFJTXBYLE1BQUksZUFBZWhXLElBQWYsQ0FBb0J1d0MsR0FBcEIsQ0FKVjs7b0JBS0FoQixFQUFNM3NDLElBQU4yc0MsQ0FBVztzQkFDVGxyQyxNQXpqQkssQ0F3akJJO3NCQUVUNEQsT0FBT3VuQyxDQUZFO3NCQUdUbHJDLE1BQU0wUixJQUFFLENBQUZBLENBSEc7c0JBSVQwM0IsU0FBUzhDLEdBSkE7c0JBS1Q5SCxNQUNXLFFBQVQxeUIsSUFBRSxDQUFGQSxDQUFTLEdBQ0wwNkIsQ0FESyxHQUVJLFFBQVQxNkIsSUFBRSxDQUFGQSxDQUFTLEdBQ1QyNkIsQ0FEUyxHQUVBLFFBQVQzNkIsSUFBRSxDQUFGQSxDQUFTLEdBQ1Q0NkIsQ0FEUyxHQUVUQztxQkFaUnRCO21CQVBGLE1Bc0JFQSxFQUFNM3NDLElBQU4yc0MsQ0FBVztvQkFDVGxyQyxNQW5rQkcsQ0Fra0JNO29CQUVUNEQsT0FBT3VuQzttQkFGVEQ7Ozs7Y0F6QytCOztjQUFBOzs7WUFnRHJDLHdCQUFtQmMsR0FBbkI7Y0FBSyxJQUFNL3JDLGNBQU47Y0FDRjhvQixFQUFpQjBqQixlQUFqQjFqQixDQUFpQzlvQixHQUFqQzhvQjs7OztVQUtMLElBQUlxZ0IsRUFBZWg5QixJQUFmZzlCLENBQXFCcmdCLEVBQWlCMmpCLE9BQXRDdEQsQ0FBSixFQUFvRDtZQUlsRCxJQUFNQyxNQUFXdGdCLEVBQWlCNGpCLFdBQWpCNWpCLENBQThCanFCLEtBQTlCaXFCLENBQW9Dd2YsQ0FBcEN4ZixDQUFqQjtnQkFDTTVILE1BQVlrb0IsSUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBRG5DOztZQUVBLElBQUlsb0IsTUFBWSxDQUFoQixFQUFtQjtjQUNoQjRILEVBQWlCNGpCLFdBQWpCNWpCLEdBQStCcWYsTUFDM0JBLElBQWF3RSxXQURjeEUsR0FFNUIsRUFGSHJmOztjQVFELEtBQUssSUFBSW5uQixNQUFJLENBQWIsRUFBZ0JBLE1BQUl1ZixHQUFwQixFQUErQnZmLEtBQS9CO2dCQUNHbW5CLEVBQWlCNGlCLE1BQWpCNWlCLENBQXdCc2dCLElBQVF6bkMsR0FBUnluQyxDQUF4QnRnQixFQUFvQzJmLEdBQXBDM2YsR0FFRHdoQixFQUFPc0IsUUFBUHRCLEVBRkN4aEIsRUFHRG1pQixFQUFNM3NDLElBQU4yc0MsQ0FBVztrQkFBQ2xyQyxNQXRtQlAsQ0FzbUJNO2tCQUFtQjRELFNBQVN1bkM7aUJBQXZDRCxDQUhDbmlCOzs7Y0FRRkEsRUFBaUI0aUIsTUFBakI1aUIsQ0FBd0JzZ0IsSUFBUWxvQixHQUFSa29CLENBQXhCdGdCLEVBQTRDMmYsR0FBNUMzZjs7O1NBckdQLE1Bd0dPLElBQXNCLE1BQWxCQSxFQUFLK2lCLFFBQVQsRUFFTCxJQURjL2lCLEVBQWlCblksSUFBakJtWSxLQUNEeWYsQ0FBYixFQUNFMEMsRUFBTTNzQyxJQUFOMnNDLENBQVc7VUFBQ2xyQyxNQWpuQkgsQ0FpbkJFO1VBQW1CNEQsT0FBT3VuQztTQUFyQ0QsRUFERixLQUVPO1VBQ0wsSUFBSXRwQyxPQUFLLENBQVQ7O1VBQ0EsUUFBZ0UsQ0FBaEUsTUFBUUEsTUFBS21uQixFQUFpQm5ZLElBQWpCbVksQ0FBc0J0USxPQUF0QnNRLENBQThCd2YsQ0FBOUJ4ZixFQUFzQ25uQixNQUFJLENBQTFDbW5CLENBQWI7WUFHRW1pQixFQUFNM3NDLElBQU4yc0MsQ0FBVztjQUFDbHJDLE1BbG5CSCxDQWtuQkU7Y0FBcUI0RCxPQUFPdW5DO2FBQXZDRCxHQUVBdHBDLE9BQUsybUMsRUFBTy9vQyxNQUFQK29DLEdBQWdCLENBRnJCMkM7Ozs7UUFNTkM7Ozs7OzthQWFKMEIsdUJBQXFCbHdCLENBQXJCa3dCLEVBQXdDQyxDQUF4Q0QsRUFBd0NDO1FBQ3RDLElBQU0vb0MsSUFBSzRXLElBQUVsZSxhQUFGa2UsQ0FBZ0IsVUFBaEJBLENBQVg7UUFFQSxPQURBNVcsRUFBR2dwQyxTQUFIaHBDLEdBQWU0WSxDQUFmNVksRUFDT0EsQ0FBUDs7Ozs7OztFQWlCSixTQUFTaXBDLENBQVQsQ0FDRS9DLENBREYsRUFFRXpzQyxDQUZGLEVBSUV5dkM7SUFBQUEsSUFEQXprQixDQUNBeWtCLHVFQUQwQmhELENBQzFCZ0Q7SUFBQUE7SUFBQUE7SUFJQSxJQUFJenZDLE1BQVVnc0MsQ0FBZCxFQUNFLE9BQU9oc0MsQ0FBUDtJQUVGLElBQUkwdkMsU0FDaUI5dUMsQ0FEakI4dUMsS0FDRkQsQ0FERUMsR0FFd0MsVUFBckMvZ0IsTUFBeUJnaEIsSUFBWSxLQUFaQSxLQUFZLENBQVpBLEtBQVloaEIsZUFBRzhnQixDQUFIOWdCLENBRnhDK2dCLEdBR0cxa0IsRUFBK0M0a0IsSUFIdEQ7SUFJQSxJQUFNQyxJQUEyQnpFLEVBQVlwckMsQ0FBWm9yQyxJQUFZcHJDLEtBQ3pDWSxDQUQ2QndxQyxHQUc1QnByQyxFQUEyQzh2QyxlQUhoRDtJQTRCQSxRQXhCSUosaUJBQWdCLENBQWhCQSxLQUFrQnRpQyxXQXdCdEIsTUF4QnNDeWlDLENBd0J0QyxLQXRCRSwrQkFBZ0IsQ0FBaEJILEtBQXVESyxJQUF2RCxLQUF1RCxLQUF2RCxDQUF1RCxLQUF2RGhhLGdCQUEyRCxDQUEzREEsR0FBMkQsS0FDMUJuMUIsQ0FEMEIsS0FDdkRpdkMsQ0FEdUQsR0FFekRILFNBQW1COXVDLENBRnNDLElBSXpEOHVDLElBQW1CLElBQUlHLENBQUosQ0FBNkJwRCxDQUE3QixDQUFuQmlELEVBQ0FBLEVBQWlCTSxJQUFqQk4sQ0FBOEJqRCxDQUE5QmlELEVBQW9DMWtCLENBQXBDMGtCLEVBQTRDRCxDQUE1Q0MsQ0FMeUQsQ0FBM0QsRUFLOENELEtBRXZCN3VDLENBRnVCNnVDLEtBRTFDQSxDQUYwQ0EsR0FFMUNBLENBQ3lCLFVBQXpCamlCLFlBQXlCbWlCLHFDQUFpQixFQUQxQ0YsRUFDOENBLENBRDlDQSxJQUVBQyxDQUowQ0QsR0FNM0N6a0IsRUFBaUM0a0IsSUFBakM1a0IsR0FBK0Mwa0IsQ0FXcEQsR0FYb0RBLEtBRzNCOXVDLENBSDJCOHVDLEtBR2hEQSxDQUhnREEsS0FJbEQxdkMsSUFBUXd2QyxFQUNOL0MsQ0FETStDLEVBRU5FLEVBQWlCTyxJQUFqQlAsQ0FBMkJqRCxDQUEzQmlELEVBQWtDMXZDLEVBQTBCbVosTUFBNUR1MkIsQ0FGTUYsRUFHTkUsQ0FITUYsRUFJTkMsQ0FKTUQsQ0FKMENFLENBV3BELEVBQU8xdkMsQ0FBUDtFQU9GOztNQUFNa3dDO0lBV0o5aUMsV0FBWStpQyxDQUFaL2lDLEVBQWdDNGQsQ0FBaEM1ZCxFQUFnQzRkO01BQUFBOztNQVBoQ3lpQixLQUFNMkMsQ0FBTjNDLEdBQWtDLEVBQWxDQSxFQUtBQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQUxqRDZzQyxFQVFFQSxLQUFLNkMsSUFBTDdDLEdBQWtCMEMsQ0FScEIxQyxFQVNFQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBVGxCeWlCOzs7OztXQWFJK0M7UUFDRixPQUFPL0MsS0FBSzhDLElBQUw5QyxDQUFjK0MsVUFBckI7Ozs7V0FJRUM7UUFDRixPQUFPaEQsS0FBSzhDLElBQUw5QyxDQUFjZ0QsSUFBckI7Ozs7YUFLRkMsV0FBT3BFLENBQVBvRSxFQUFPcEU7UUFBQUE7UUFDTCxpQkFHSW1CLEtBQUs2QyxJQUhUO1lBQ092QyxDQURQLGNBQ0V4bkMsRUFERixDQUNNd25DLE9BRE47WUFFU0wsQ0FGVCxjQUVFQSxLQUZGO1lBSU1pRCxDQUpOLEdBSU1BLENBQXNDLFVBQTFCaGlCLDJCQUFTaWlCLGFBQWlCLEtBQWpCQSxLQUFpQixDQUFqQkEsS0FBaUJqaUIsV0FBdENnaUIsRUFBeUNFLFVBQXpDRixDQUFvRDVDLENBQXBENEMsRUFBb0Q1QyxDQUFTLENBQTdENEMsQ0FKTjtRQUtBNUQsRUFBT2UsV0FBUGYsR0FBcUI0RCxDQUFyQjVEO1FBRUEsSUFBSXhoQixJQUFPd2hCLEVBQU9zQixRQUFQdEIsRUFBWDtZQUNJWSxJQUFZLENBRGhCO1lBRUltRCxJQUFZLENBRmhCO1lBR0lDLElBQWVyRCxFQUFNLENBQU5BLENBSG5COztRQUtBLFlBQXdCOXNDLENBQXhCLEtBQU9td0MsQ0FBUCxHQUFtQztVQUNqQyxJQUFJcEQsTUFBY29ELEVBQWEzcUMsS0FBL0IsRUFBc0M7WUFDcEMsSUFBSXFtQyxZQUFKOztZQTN2QlcsTUE0dkJQc0UsRUFBYXZ1QyxJQTV2Qk4sR0E2dkJUaXFDLE1BQU8sSUFBSUcsQ0FBSixDQUNMcmhCLENBREssRUFFTEEsRUFBS3lsQixXQUZBLEVBR0x2RCxJQUhLLEVBSUxuQixDQUpLLENBN3ZCRSxHQURJLE1Bb3dCSnlFLEVBQWF2dUMsSUFwd0JULEdBcXdCYmlxQyxNQUFPLElBQUlzRSxFQUFhbEssSUFBakIsQ0FDTHRiLENBREssRUFFTHdsQixFQUFhdHVDLElBRlIsRUFHTHN1QyxFQUFhbEYsT0FIUixFQUlMNEIsSUFKSyxFQUtMbkIsQ0FMSyxDQXJ3Qk0sR0FLRixNQXV3QkZ5RSxFQUFhdnVDLElBdndCWCxLQXd3QlhpcUMsTUFBTyxJQUFJd0UsQ0FBSixDQUFnQjFsQixDQUFoQixFQUFxQ2tpQixJQUFyQyxFQUEyQ25CLENBQTNDLENBeHdCSSxDQUpGLEVBOHdCWG1CLEtBQUsyQyxDQUFMM0MsQ0FBWTFzQyxJQUFaMHNDLENBQWlCaEIsR0FBakJnQixDQTl3QlcsRUErd0JYc0QsSUFBZXJELElBQVFvRCxDQUFScEQsQ0Evd0JKOzs7VUFpeEJUQyxPQUFjb0QsdUJBQWMzcUMsS0FBNUJ1bkMsTUFDRnBpQixJQUFPd2hCLEVBQU9zQixRQUFQdEIsRUFBUHhoQixFQUNBb2lCLEdBRkVBOzs7UUFLTixPQUFPZ0QsQ0FBUDs7OzthQUdGTyxXQUFRLzNCLENBQVIrM0IsRUFBUS8zQjtRQUNOLElBQUkvVSxJQUFJLENBQVI7O1FBRE0rVSw0Q0FFYXMwQixLQUFLMkMsQ0FGbEJqM0I7OztRQUFBQTtVQUVOO1lBQUEsSUFBV3N6QixHQUFYO1lBQXdCMkQsS0FDVHh2QyxDQURTd3ZDLEtBQ2xCM0QsR0FEa0IyRCxLQUNsQjNELEtBU3NDN3JDLENBVHRDNnJDLEtBU0dBLElBQXVCWixPQVQxQlksSUFVQ0EsSUFBdUJLLElBQXZCTCxDQUFrQ3R6QixDQUFsQ3N6QixFQUEwQ0EsR0FBMUNBLEVBQWlFcm9DLENBQWpFcW9DLEdBSURyb0MsS0FBTXFvQyxJQUF1QlosT0FBdkJZLENBQWdDenFDLE1BQWhDeXFDLEdBQXlDLENBZC9DQSxJQWdCQUEsSUFBS0ssSUFBTEwsQ0FBZ0J0ekIsRUFBTy9VLENBQVArVSxDQUFoQnN6QixDQWpCa0IyRCxHQW9CdEJoc0MsR0FwQnNCZ3NDOzs7VUFGbEJqM0I7O1VBQUFBOzs7Ozs7OztNQXdFSnl6QjtJQTRDSngvQixXQUNFK2pDLENBREYvakMsRUFFRXUvQixDQUZGdi9CLEVBR0U0ZCxDQUhGNWQsRUFJRWsvQixDQUpGbC9CLEVBSUVrL0I7TUFBQUE7O01BQUFBO01BL0NPbUIsS0FBSWpyQyxJQUFKaXJDLEdBbDJCUSxDQWsyQlJBLEVBRVRBLEtBQWdCMkQsSUFBaEIzRCxHQUE0QnZCLENBRm5CdUIsRUFpQ1RBLEtBQXdCNEMsSUFBeEI1QyxHQUF3QjRDLEtBQXlCenZDLENBakN4QzZzQyxFQWlEUEEsS0FBSzRELElBQUw1RCxHQUFtQjBELENBakRaMUQsRUFrRFBBLEtBQUs2RCxJQUFMN0QsR0FBaUJkLENBbERWYyxFQW1EUEEsS0FBSzhDLElBQUw5QyxHQUFnQnppQixDQW5EVHlpQixFQW9EUEEsS0FBS25CLE9BQUxtQixHQUFlbkIsQ0FwRFJtQixFQXdEUEEsS0FBSzhELElBQUw5RCxHQUF5QyxVQUFwQjllLHFCQUFPLENBQVAyZCxLQUFTa0YsV0FBVyxLQUFYQSxLQUFXLENBQVhBLEtBQVc3aUIsTUF4RGxDOGU7Ozs7O1dBdUJMZ0Q7UUFBQUE7UUFJRixPQUF1QyxVQUFoQzFhLElBQWUsVUFBZnBILFNBQUs0aEIsSUFBVSxLQUFWQSxLQUFVLENBQVZBLEtBQVU1aEIsbUJBQWlCLEtBQWpCOGhCLEtBQWlCLENBQWpCQSxLQUFpQjFhLGFBQUt3YixJQUE1Qzs7OztXQXNERWY7UUFDRixJQUFJQSxJQUF3Qi9DLEtBQUs0RCxJQUFMNUQsQ0FBa0IrQyxVQUE5QztRQUNBLElBQU14bEIsSUFBU3lpQixLQUFLOEMsSUFBcEI7UUFVQSxZQVJhM3ZDLENBUWIsS0FSRW9xQixDQVFGLElBUDBCLE9BQXhCd2xCLEVBQVdsQyxRQU9iLEtBRkVrQyxJQUFjeGxCLEVBQXdDd2xCLFVBRXhELEdBQU9BLENBQVA7Ozs7V0FPRVc7UUFDRixPQUFPMUQsS0FBSzRELElBQVo7Ozs7V0FPRTFFO1FBQ0YsT0FBT2MsS0FBSzZELElBQVo7Ozs7YUFHRnhFLGNBQVc5c0MsQ0FBWDhzQyxFQUE4RFc7UUFBQUEsSUFBbkNnRSxDQUFtQ2hFO1FBTTVEenRDLElBQVF3dkMsRUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDLEVBQThCaUMsQ0FBOUJqQyxDQUFSeHZDLEVBQ0lvckMsRUFBWXByQyxDQUFab3JDLElBSUVwckMsTUFBVWtzQyxDQUFWbHNDLElBQThCLFFBQVRBLENBQXJCQSxJQUFnRCxPQUFWQSxDQUF0Q0EsSUFDRXl0QyxLQUFLMkQsSUFBTDNELEtBQTBCdkIsQ0FBMUJ1QixJQVFGQSxLQUFLaUUsSUFBTGpFLEVBUkVBLEVBVUpBLEtBQUsyRCxJQUFMM0QsR0FBd0J2QixDQVh0QmxzQyxJQVlPQSxNQUFVeXRDLEtBQUsyRCxJQUFmcHhDLElBQW1DQSxNQUFVZ3NDLENBQTdDaHNDLElBQ1R5dEMsS0FBS2tFLENBQUxsRSxDQUFpQnp0QyxDQUFqQnl0QyxDQWpCQXJDLEdBaUJpQnByQyxLQUdrQ1ksQ0FIbENaLEtBR1RBLEVBQXFDOHJDLFVBSDVCOXJDLEdBSW5CeXRDLEtBQUttRSxDQUFMbkUsQ0FBMkJ6dEMsQ0FBM0J5dEMsQ0FKbUJ6dEMsR0FJUUEsS0FDV1ksQ0FEWFosS0FDakJBLEVBQWVzdUMsUUFERXR1QyxHQUUzQnl0QyxLQUFLb0UsQ0FBTHBFLENBQWlCenRDLENBQWpCeXRDLENBRjJCenRDLEdBR2xCcXJDLEVBQVdyckMsQ0FBWHFyQyxJQUNUb0MsS0FBS3FFLENBQUxyRSxDQUFxQnp0QyxDQUFyQnl0QyxDQURTcEMsR0FJVG9DLEtBQUtrRSxDQUFMbEUsQ0FBaUJ6dEMsQ0FBakJ5dEMsQ0E3QkZ6dEM7Ozs7YUFpQ00reEMsV0FBd0J4bUIsQ0FBeEJ3bUIsRUFBNENUO1FBQUFBLElBQVhVLENBQVdWLHVFQUFMN0QsS0FBSzZEO1FBQ2xELE9BQWlCN0QsS0FBSzRELElBQUw1RCxDQUFrQitDLFVBQWxCL0MsQ0FBK0JaLFlBQS9CWSxDQUE0Q2xpQixDQUE1Q2tpQixFQUFrRHVFLENBQWxEdkUsQ0FBakI7Ozs7YUFHTW9FLFdBQVk3eEMsQ0FBWjZ4QyxFQUFZN3hDO1FBQ2R5dEMsS0FBSzJELElBQUwzRCxLQUEwQnp0QyxDQUExQnl0QyxLQUNGQSxLQUFLaUUsSUFBTGpFLElBbUNBQSxLQUFLMkQsSUFBTDNELEdBQXdCQSxLQUFLc0UsQ0FBTHRFLENBQWF6dEMsQ0FBYnl0QyxDQXBDdEJBOzs7O2FBd0NFa0UsV0FBWTN4QyxDQUFaMnhDLEVBQVkzeEM7UUFLaEJ5dEMsS0FBSzJELElBQUwzRCxLQUEwQnZCLENBQTFCdUIsSUFDQXJDLEVBQVlxQyxLQUFLMkQsSUFBakJoRyxDQURBcUMsR0FHa0JBLEtBQUs0RCxJQUFMNUQsQ0FBa0J1RCxXQUFsQnZELENBYUhyNkIsSUFiR3E2QixHQWFJenRDLENBaEJ0Qnl0QyxHQXFDRUEsS0FBS29FLENBQUxwRSxDQUFpQnR3QixJQUFFcU8sY0FBRnJPLENBQWlCbmQsQ0FBakJtZCxDQUFqQnN3QixDQXJDRkEsRUE4Q0ZBLEtBQUsyRCxJQUFMM0QsR0FBd0J6dEMsQ0E5Q3RCeXRDOzs7O2FBaURJbUUsV0FDTjVxQyxDQURNNHFDLEVBQ041cUM7UUFBQUE7UUFHQSxJQUFPbVMsQ0FBUCxHQUF1Q25TLENBQXZDLENBQU1tUyxNQUFOO1lBQStCM1csQ0FBL0IsR0FBdUN3RSxDQUF2QyxDQUFlOGtDLFVBQWY7WUFLTXFFLENBTE4sR0FNa0IsbUJBQVQzdEMsQ0FBUyxHQUNaaXJDLEtBQUt3RSxJQUFMeEUsQ0FBbUJ6bUMsQ0FBbkJ5bUMsQ0FEWSxJQUNPem1DLEtBQ05wRyxDQURNb0csS0FDbEJ4RSxFQUFLK0QsRUFEYVMsS0FFaEJ4RSxFQUFLK0QsRUFBTC9ELEdBQVVnckMsRUFBU3Z1QyxhQUFUdXVDLENBQXVCaHJDLEVBQUswdkMsQ0FBNUIxRSxFQUErQkMsS0FBS25CLE9BQXBDa0IsQ0FGTXhtQyxHQUduQnhFLENBSlksQ0FObEI7UUFZQSxLQUFpRCxjQUE1Q2lyQyxLQUFLMkQsSUFBdUMsS0FBdkNBLEtBQXVDLENBQXZDQSxLQUF1Q3ppQixtQkFBakQsTUFBZ0V3aEIsQ0FBaEUsRUFTRzFDLEtBQUsyRCxJQUFMM0QsQ0FBMkN5RCxDQUEzQ3pELENBQW1EdDBCLENBQW5EczBCLEVBVEgsS0FVTztVQUNMLElBQU12YyxNQUFXLElBQUlnZixDQUFKLENBQXFCQyxDQUFyQixFQUEyQzFDLElBQTNDLENBQWpCO2NBQ01rRCxNQUFXemYsSUFBU3dmLENBQVR4ZixDQUFnQnVjLEtBQUtuQixPQUFyQnBiLENBRGpCOztVQVdBQSxJQUFTZ2dCLENBQVRoZ0IsQ0FBaUIvWCxDQUFqQitYLEdBVUF1YyxLQUFLb0UsQ0FBTHBFLENBQWlCa0QsR0FBakJsRCxDQVZBdmMsRUFXQXVjLEtBQUsyRCxJQUFMM0QsR0FBd0J2YyxHQVh4QkE7Ozs7O2FBaUJKK2dCLGNBQWNqckMsQ0FBZGlyQyxFQUFjanJDO1FBQ1osSUFBSW1wQyxJQUFXaEUsRUFBYzN0QyxHQUFkMnRDLENBQWtCbmxDLEVBQU82a0MsT0FBekJNLENBQWY7UUFJQSxZQUhpQnZyQyxDQUdqQixLQUhJdXZDLENBR0osSUFGRWhFLEVBQWNsZ0MsR0FBZGtnQyxDQUFrQm5sQyxFQUFPNmtDLE9BQXpCTSxFQUFtQ2dFLElBQVcsSUFBSTNDLENBQUosQ0FBYXhtQyxDQUFiLENBQTlDbWxDLENBRUYsRUFBT2dFLENBQVA7Ozs7YUFHTTJCLFdBQWdCOXhDLENBQWhCOHhDLEVBQWdCOXhDO1FBV2pCNEgsRUFBUTZsQyxLQUFLMkQsSUFBYnhwQyxNQUNINmxDLEtBQUsyRCxJQUFMM0QsR0FBd0IsRUFBeEJBLEVBQ0FBLEtBQUtpRSxJQUFMakUsRUFGRzdsQztRQU9MLElBQU11cUMsSUFBWTFFLEtBQUsyRCxJQUF2QjtRQUNBLElBQ0lnQixDQURKO1lBQUl0QixJQUFZLENBQWhCOztRQW5Cc0I5d0MsNENBc0JIQSxDQXRCR0E7OztRQUFBQTtVQXNCdEI7WUFBQSxJQUFXcXlDLEdBQVg7WUFDTXZCLE1BQWNxQixFQUFVbndDLE1BQXhCOHVDLEdBS0ZxQixFQUFVcHhDLElBQVZveEMsQ0FDR0MsSUFBVyxJQUFJeEYsQ0FBSixDQUNWYSxLQUFLc0UsQ0FBTHRFLENBQWF2QyxHQUFidUMsQ0FEVSxFQUVWQSxLQUFLc0UsQ0FBTHRFLENBQWF2QyxHQUFidUMsQ0FGVSxFQUdWQSxJQUhVLEVBSVZBLEtBQUtuQixPQUpLLENBRGQ2RixDQUxFckIsR0FlRnNCLElBQVdELEVBQVVyQixDQUFWcUIsQ0FmVHJCLEVBaUJKc0IsRUFBU3RGLElBQVRzRixDQUFvQkMsR0FBcEJELENBakJJdEIsRUFrQkpBLEdBbEJJQTs7O1VBdkJnQjl3Qzs7VUFBQUE7OztRQTRDbEI4d0MsSUFBWXFCLEVBQVVud0MsTUFBdEI4dUMsS0FFRnJELEtBQUtpRSxJQUFMakUsQ0FDRTJFLEtBQWlCQSxFQUFTZCxJQUFUYyxDQUFxQnBCLFdBRHhDdkQsRUFFRXFELENBRkZyRCxHQUtBMEUsRUFBVW53QyxNQUFWbXdDLEdBQW1CckIsQ0FQakJBOzs7O2FBc0JOWSxnQkFFRXZ6QjtRQUFBQSxJQURBbUIsQ0FDQW5CLHVFQUQrQnN2QixLQUFLNEQsSUFBTDVELENBQWtCdUQsV0FDakQ3eUI7UUFBQUE7UUFBQUE7O1FBR0EsS0FEOEIsVUFBOUJ3USxTQUFLMmpCLElBQXlCLEtBQXpCQSxLQUF5QixDQUF6QkEsS0FBeUIzakIsWUFBOUI4ZSxJQUE4QjllLEVBQTlCOGUsQ0FBaUMsQ0FBSDllLEVBQUcsQ0FBTyxDQUFWQSxFQUFnQnhRLENBQWhCd1EsQ0FDOUIsRUFBT3JQLEtBQVNBLE1BQVVtdUIsS0FBSzZELElBQS9CLEdBQTBDO1VBQ3hDLElBQU05aEMsT0FBUzhQLEVBQVEweEIsV0FBdkI7VUFDTTF4QixFQUFvQjR1QixNQUFwQjV1QixJQUNOQSxJQUFROVAsSUFERjhQOzs7OzthQVdWaXpCLHNCQUFhZixDQUFiZSxFQUFhZjtRQUFBQTtRQUFBQSxLQUNXNXdDLENBRFg0d0MsS0FDUC9ELEtBQUs4QyxJQURFaUIsS0FFVC9ELEtBQUs4RCxJQUFMOUQsR0FBcUIrRCxDQUFyQi9ELEVBQzhCLFVBQTlCOWUsU0FBSzJqQixJQUF5QixLQUF6QkEsS0FBeUIsQ0FBekJBLEtBQXlCM2pCLFlBQTlCOGUsSUFBOEI5ZSxFQUFHNmlCLENBQUg3aUIsQ0FIckI2aUI7Ozs7Ozs7TUFxQ1R4QztJQW9DSjVoQyxXQUNFd3pCLENBREZ4ekIsRUFFRTNLLENBRkYySyxFQUdFeStCLENBSEZ6K0IsRUFJRTRkLENBSkY1ZCxFQUtFay9CLENBTEZsL0IsRUFLRWsvQjtNQUFBQTs7TUF4Q09tQixLQUFJanJDLElBQUppckMsR0F0eENZLENBc3hDWkEsRUFnQlRBLEtBQWdCMkQsSUFBaEIzRCxHQUE2Q3ZCLENBaEJwQ3VCLEVBc0JUQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQXRCeEM2c0MsRUEwQ1BBLEtBQUs3TSxPQUFMNk0sR0FBZTdNLENBMUNSNk0sRUEyQ1BBLEtBQUtockMsSUFBTGdyQyxHQUFZaHJDLENBM0NMZ3JDLEVBNENQQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBNUNUeWlCLEVBNkNQQSxLQUFLbkIsT0FBTG1CLEdBQWVuQixDQTdDUm1CLEVBOENINUIsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQWpCQSxJQUFxQyxPQUFmQSxFQUFRLENBQVJBLENBQXRCQSxJQUEwRCxPQUFmQSxFQUFRLENBQVJBLENBQTNDQSxJQUNGNEIsS0FBSzJELElBQUwzRCxHQUE0QjlsQyxNQUFNa2tDLEVBQVE3cEMsTUFBUjZwQyxHQUFpQixDQUF2QmxrQyxFQUEwQm1hLElBQTFCbmEsQ0FBK0IsSUFBSTlGLE1BQUosRUFBL0I4RixDQUE1QjhsQyxFQUNBQSxLQUFLNUIsT0FBTDRCLEdBQWU1QixDQUZiQSxJQUlGNEIsS0FBSzJELElBQUwzRCxHQUF3QnZCLENBbERuQnVCOzs7OztXQTBCTHlCO1FBQ0YsT0FBT3pCLEtBQUs3TSxPQUFMNk0sQ0FBYXlCLE9BQXBCOzs7O1dBSUV1QjtRQUNGLE9BQU9oRCxLQUFLOEMsSUFBTDlDLENBQWNnRCxJQUFyQjs7OzthQStDRjNELGNBQ0U5c0MsQ0FERjhzQyxFQUlFMEY7UUFBQUEsSUFGQWYsQ0FFQWUsdUVBRm1DL0UsSUFFbkMrRTtRQUFBQSxJQURBQyxDQUNBRDtRQUFBQTtRQUVBLElBQU0zRyxJQUFVNEIsS0FBSzVCLE9BQXJCO1FBR0EsSUFBSTZHLEtBQVMsQ0FBYjtRQUVBLFNBQWdCOXhDLENBQWhCLEtBQUlpckMsQ0FBSixFQUVFN3JDLElBQVF3dkMsRUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDLEVBQThCaUMsQ0FBOUJqQyxFQUErQyxDQUEvQ0EsQ0FBUnh2QyxFQUNBMHlDLEtBQ0d0SCxFQUFZcHJDLENBQVpvckMsQ0FESHNILElBRUcxeUMsTUFBVXl0QyxLQUFLMkQsSUFBZnB4QyxJQUFtQ0EsTUFBVWdzQyxDQUhoRGhzQyxFQUlJMHlDLE1BQ0ZqRixLQUFLMkQsSUFBTDNELEdBQXdCenRDLENBRHRCMHlDLENBSkoxeUMsQ0FGRixLQVNPO1VBRUwsSUFBTW1aLEtBQVNuWixDQUFmOztVQUdBLElBQUlvRSxFQUFKLEVBQU8rbkIsRUFBUDs7VUFDQSxLQUhBbnNCLElBQVE2ckMsRUFBUSxDQUFSQSxDQUFSN3JDLEVBR0tvRSxLQUFJLENBQVQsRUFBWUEsS0FBSXluQyxFQUFRN3BDLE1BQVI2cEMsR0FBaUIsQ0FBakMsRUFBb0N6bkMsSUFBcEM7WUFDRStuQixLQUFJcWpCLEVBQWlCL0IsSUFBakIrQixFQUF1QnIyQixHQUFPczVCLElBQWNydUMsRUFBckIrVSxDQUF2QnEyQixFQUFnRGlDLENBQWhEakMsRUFBaUVwckMsRUFBakVvckMsQ0FBSnJqQixFQUVJQSxPQUFNNmYsQ0FBTjdmLEtBRUZBLEtBQUtzaEIsS0FBSzJELElBQUwzRCxDQUF5Q3JwQyxFQUF6Q3FwQyxDQUZIdGhCLENBRkpBLEVBTUF1bUIsV0FDR3RILEVBQVlqZixFQUFaaWYsQ0FESHNILElBQ3FCdm1CLE9BQU9zaEIsS0FBSzJELElBQUwzRCxDQUF5Q3JwQyxFQUF6Q3FwQyxDQUQ1QmlGLENBTkF2bUIsRUFRSUEsT0FBTStmLENBQU4vZixHQUNGbnNCLElBQVFrc0MsQ0FETi9mLEdBRU9uc0IsTUFBVWtzQyxDQUFWbHNDLEtBQ1RBLE1BQVVtc0Isa0JBQUssRUFBZm5zQixJQUFxQjZyQyxFQUFRem5DLEtBQUksQ0FBWnluQyxDQURaN3JDLENBVlhtc0IsRUFlQ3NoQixLQUFLMkQsSUFBTDNELENBQXlDcnBDLEVBQXpDcXBDLElBQThDdGhCLEVBZi9DQTs7O1FBa0JBdW1CLE1BQVdGLENBQVhFLElBQ0ZqRixLQUFLa0YsQ0FBTGxGLENBQWtCenRDLENBQWxCeXRDLENBREVpRjs7OzthQU1OQyxXQUFhM3lDLENBQWIyeUMsRUFBYTN5QztRQUNQQSxNQUFVa3NDLENBQVZsc0MsR0FDSXl0QyxLQUFLN00sT0FBTDZNLENBQTBCd0IsZUFBMUJ4QixDQUEwQ0EsS0FBS2hyQyxJQUEvQ2dyQyxDQURKenRDLEdBb0JJeXRDLEtBQUs3TSxPQUFMNk0sQ0FBMEJtRixZQUExQm5GLENBQ0pBLEtBQUtockMsSUFERGdyQyxFQUVIenRDLGdCQUFTLEVBRk55dEMsQ0FwQkp6dEM7Ozs7Ozs7TUE2QkY2dUM7Ozs7O0lBQU56aEM7TUFBQUE7O01BQUFBOztNQUFBQSx1Q0FDb0JxZ0MsTUFBSWpyQyxJQUFKaXJDLEdBcjdDRSxDQW83Q3RCcmdDO01BQUFBOzs7OzthQUlXdWxDLFdBQWEzeUMsQ0FBYjJ5QyxFQUFhM3lDO1FBbUJuQnl0QyxLQUFLN00sT0FBTDZNLENBQXFCQSxLQUFLaHJDLElBQTFCZ3JDLElBQWtDenRDLE1BQVVrc0MsQ0FBVmxzQyxHQUFVa3NDLEtBQVV0ckMsQ0FBcEJaLEdBQWdDQSxDQUFsRXl0Qzs7Ozs7SUF2QnNCdUI7O0VBK0IzQixJQUFNNkQsTUFBaUNqSSxNQUNsQ0EsSUFBYXdFLFdBRHFCeEUsR0FFbkMsRUFGSjs7TUFLTWtFOzs7OztJQUFOMWhDO01BQUFBOztNQUFBQTs7TUFBQUEseUNBQ29CcWdDLE9BQUlqckMsSUFBSmlyQyxHQXg5Q1csQ0F1OUMvQnJnQztNQUFBQTs7Ozs7YUFJV3VsQyxXQUFhM3lDLENBQWIyeUMsRUFBYTN5QztRQVFoQkEsS0FBU0EsTUFBVWtzQyxDQUFuQmxzQyxHQUNJeXRDLEtBQUs3TSxPQUFMNk0sQ0FBMEJtRixZQUExQm5GLENBQ0pBLEtBQUtockMsSUFERGdyQyxFQUVKb0YsR0FGSXBGLENBREp6dEMsR0FNSXl0QyxLQUFLN00sT0FBTDZNLENBQTBCd0IsZUFBMUJ4QixDQUEwQ0EsS0FBS2hyQyxJQUEvQ2dyQyxDQU5KenRDOzs7OztJQVoyQmd2Qzs7TUFzQzdCRDs7Ozs7SUFHSjNoQyxXQUNFd3pCLENBREZ4ekIsRUFFRTNLLENBRkYySyxFQUdFeStCLENBSEZ6K0IsRUFJRTRkLENBSkY1ZCxFQUtFay9CLENBTEZsL0IsRUFLRWsvQjtNQUFBQTs7TUFBQUE7O01BRUF3Ryw0QkFBTWxTLENBQU5rUyxFQUFlcndDLENBQWZxd0MsRUFBcUJqSCxDQUFyQmlILEVBQThCOW5CLENBQTlCOG5CLEVBQXNDeEcsQ0FBdEN3RyxHQVRnQnJGLE9BQUlqckMsSUFBSmlyQyxHQTcvQ0QsQ0FzZ0RmcUY7TUFGQXhHOzs7OzthQWdCT1EsY0FDUGlHLENBRE9qRyxFQUU0Qlc7UUFBQUEsSUFBbkNnRSxDQUFtQ2hFO1FBQUFBO1FBSW5DLEtBRkFzRixJQUM2RCxVQUEzRHBrQixNQUFpQjhlLElBQWpCK0IsRUFBdUJ1RCxDQUF2QnZELEVBQW9DaUMsQ0FBcENqQyxFQUFxRCxDQUFyREEsQ0FBMkQsS0FBTixLQUFNLENBQU4sS0FBTTdnQixTQUM3RCxNQUFvQnFkLENBQXBCLEVBQ0U7UUFFRixJQUFNZ0gsSUFBY3ZGLEtBQUsyRCxJQUF6QjtZQUlNNkIsSUFDSEYsTUFBZ0I3RyxDQUFoQjZHLElBQTJCQyxNQUFnQjlHLENBQTNDNkcsSUFDQUEsRUFBeUNqc0IsT0FBekNpc0IsS0FDRUMsRUFBeUNsc0IsT0FGM0Npc0IsSUFHQUEsRUFBeUNHLElBQXpDSCxLQUNFQyxFQUF5Q0UsSUFKM0NILElBS0FBLEVBQXlDSSxPQUF6Q0osS0FDRUMsRUFBeUNHLE9BWDlDO1lBZU1DLElBQ0pMLE1BQWdCN0csQ0FBaEI2RyxLQUNDQyxNQUFnQjlHLENBQWhCOEcsSUFBMkJDLENBRDVCRixDQWhCRjtRQTZCSUUsS0FDRnhGLEtBQUs3TSxPQUFMNk0sQ0FBYTRGLG1CQUFiNUYsQ0FDRUEsS0FBS2hyQyxJQURQZ3JDLEVBRUVBLElBRkZBLEVBR0V1RixDQUhGdkYsQ0FERXdGLEVBT0FHLEtBSUYzRixLQUFLN00sT0FBTDZNLENBQWF6akIsZ0JBQWJ5akIsQ0FDRUEsS0FBS2hyQyxJQURQZ3JDLEVBRUVBLElBRkZBLEVBR0VzRixDQUhGdEYsQ0FYRXdGLEVBaUJKeEYsS0FBSzJELElBQUwzRCxHQUF3QnNGLENBakJwQkU7Ozs7YUFvQk5LLHFCQUFZNXBCLENBQVo0cEIsRUFBWTVwQjtRQUFBQTtRQUMyQixxQkFBMUIrakIsS0FBSzJELElBQXFCLEdBQ25DM0QsS0FBSzJELElBQUwzRCxDQUFzQnZ2QyxJQUF0QnV2QyxDQUFzQnZ2QyxVQUFLNjNCLElBQWMsY0FBZDBYLEtBQUtuQixPQUFTLEtBQVRBLEtBQVMsQ0FBVEEsS0FBUzNkLG1CQUFuQnp3QixLQUFtQnExQyxZQUFuQnIxQyxHQUFtQnExQyxDQUFuQnIxQyxHQUEyQnV2QyxLQUFLN00sT0FBdEQ2TSxFQUErRC9qQixDQUEvRCtqQixDQURtQyxHQUdsQ0EsS0FBSzJELElBQUwzRCxDQUE4QzZGLFdBQTlDN0YsQ0FBMEQvakIsQ0FBMUQrakIsQ0FIa0M7Ozs7O0lBbkZqQnVCOztNQTRGbEJpQztJQWlCSjdqQyxXQUNTd3pCLENBRFR4ekIsRUFFRTRkLENBRkY1ZCxFQUdFay9CLENBSEZsL0IsRUFHRWsvQjtNQUFBQTs7TUFGT21CLEtBQU83TSxPQUFQNk0sTUFqQkFBLEtBQUlqckMsSUFBSmlyQyxHQXhsRFUsQ0F5bURWQSxFQUxUQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQUt4QzZzQyxFQUlQQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBSlR5aUIsRUFLUEEsS0FBS25CLE9BQUxtQixHQUFlbkIsQ0FMUm1COzs7OztXQVNMZ0Q7UUFDRixPQUFPaEQsS0FBSzhDLElBQUw5QyxDQUFjZ0QsSUFBckI7Ozs7YUFHRjNELGNBQVc5c0MsQ0FBWDhzQyxFQUFXOXNDO1FBT1R3dkMsRUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDOzs7Ozs7O0FBc0JTLE1BcUJQZ0UsSUFFRjkxQyxPQUFPKzFDLHNCQXZCRTtFQXdCYkQsZUFBa0JoRyxDQUFsQmdHLEVBQTRCNUcsQ0FBNUI0RyxHQUE0QjVHLENBSUQsVUFBM0I5ZCxJQUFDc2IsV0FBV3NKLGVBQWUsS0FBZkEsS0FBZSxDQUFmQSxLQUFlNWtCLFFBQTFCc2IsV0FBV3NKLGVBQVh0SixHQUErQixFQUpKd0MsRUFJUTdyQyxJQUpSNnJDLENBSWEsT0FKYkEsQ0FBNUI0Rzs7Ozs7OztFQ2xtRWEsVUFDWDkxQyxPQUFPaTJDLFVBQVBqMkMsS0FBT2kyQyxLQUNjL3lDLENBRGQreUMsS0FDTmoyQyxPQUFPazJDLFFBRERELElBQzJCajJDLE9BQU9rMkMsUUFBUGwyQyxDQUFnQm0yQyxZQURsRG4yQyxLQUVBLHdCQUF3Qm8yQyxTQUFTaHlDLFNBRmpDcEUsSUFHQSxhQUFhcTJDLGNBQWNqeUMsU0FKaEI7RUFBQSxJQXNCUGt5QyxNQUFvQm52QyxRQXRCYjtFQUFBLElBd0JQb3ZDLE1BQWtCLElBQUl2aUIsR0FBSixFQXhCWDs7TUFpQ0F3aUI7SUFLWDltQyxXQUFvQittQyxDQUFwQi9tQyxFQUFxQ2duQyxDQUFyQ2huQyxFQUFxQ2duQztNQUFBQTs7TUFDbkMsSUFKRjNHLEtBQWU0RyxZQUFmNUcsR0FBZSxDQUFJLENBQW5CQSxFQUlNMkcsTUFBY0osR0FBbEIsRUFDRSxNQUFVdE0sTUFDUixtRUFEUUEsQ0FBVjtNQUlGK0YsS0FBSzBHLE9BQUwxRyxHQUFlMEcsQ0FBZjFHOzs7OztXQUtFNkc7UUFHRixJQUFJQSxJQUFhTCxJQUFnQnoxQyxHQUFoQnkxQyxDQUFvQnhHLEtBQUswRyxPQUF6QkYsQ0FBakI7UUFLQSxPQUpJTSxZQUE4QzN6QyxDQUE5QzJ6QyxLQUErQkQsQ0FBL0JDLEtBQ0ZOLElBQWdCaG9DLEdBQWhCZ29DLENBQW9CeEcsS0FBSzBHLE9BQXpCRixFQUFtQ0ssSUFBYSxJQUFJUCxhQUFKLEVBQWhERSxHQUNBSyxFQUFXRSxXQUFYRixDQUF1QjdHLEtBQUswRyxPQUE1QkcsQ0FGRUMsR0FJR0QsQ0FBUDs7OzthQUdGLzBDO1FBQ0UsT0FBT2t1QyxLQUFLMEcsT0FBWjs7Ozs7OztFQVFKLElBc0JhTSxNQUFhejBDLFNBQWJ5MEMsQ0FBYXowQztJQUFBQSxPQUN4QixJQUFLazBDLEdBQUwsQ0FDbUIsbUJBQVZsMEMsQ0FBVSxHQUFXQSxDQUFYLEdBQTBCQSxJQUFQNkIsRUFEdEMsRUFFRW15QyxHQUZGLENBRHdCaDBDO0VBQUFBLENBdEIxQjtFQUFBLElBb0NhMDBDLE1BQU0sU0FBTkEsQ0FBTSxDQUNqQjdJLENBRGlCLEVBRWQxeUI7SUFBQUE7TUFBQUE7OztJQUVILElBQU1nN0IsSUFDZSxNQUFuQnRJLEVBQVE3cEMsTUFBVyxHQUNmNnBDLEVBQVEsQ0FBUkEsQ0FEZSxHQUVmMXlCLEVBQU9nSSxNQUFQaEksQ0FDRSxVQUFDckYsQ0FBRCxFQUFNcVksQ0FBTixFQUFTd29CLENBQVQ7TUFBQSxPQUFpQjdnQyxJQTVDQTlUO1FBRXpCLEtBQTZDLENBQTdDLEtBQUtBLEVBQWtDcTBDLFlBQXZDLEVBQ0UsT0FBUXIwQyxFQUFvQm0wQyxPQUE1QjtRQUNLLElBQXFCLG1CQUFWbjBDLENBQVgsRUFDTCxPQUFPQSxDQUFQO1FBRUEsTUFBVTBuQyxNQUNSLHFFQUNLMW5DLENBREwseUZBRFEwbkMsQ0FBVjtPQVBzQixDQTRDeUJ2YixDQTVDekIsQ0E0Q0NyWSxHQUE2QiszQixFQUFROEksSUFBTSxDQUFkOUksQ0FBOUM7S0FERjF5QixFQUVFMHlCLEVBQVEsQ0FBUkEsQ0FGRjF5QixDQUhOO0lBT0EsT0FBTyxJQUFLKzZCLEdBQUwsQ0FBMENDLENBQTFDLEVBQW1ESCxHQUFuRCxDQUFQO0VBQTBEQSxDQS9DNUQ7RUFBQSxJQTJEYVksTUFBYyxTQUFkQSxDQUFjLENBQ3pCQyxDQUR5QixFQUV6QkMsQ0FGeUIsRUFFekJBO0lBRUlQLE1BQ0RNLEVBQTBCRSxrQkFBMUJGLEdBQStDQyxFQUFPcDBCLEdBQVBvMEIsQ0FBWW5oQztNQUFBQSxPQUMxREEsYUFBYW9nQyxhQUFicGdDLEdBQTZCQSxDQUE3QkEsR0FBaUNBLEVBQUUyZ0MsVUFEdUIzZ0M7S0FBWm1oQyxDQUQ5Q1AsR0FLRk8sRUFBTzFtQyxPQUFQMG1DLENBQWdCbmhDO01BQ2QsSUFBTXBMLElBQVF4SixTQUFTRSxhQUFURixDQUF1QixPQUF2QkEsQ0FBZDtVQUVNaTJDLElBQVN0M0MsT0FBeUJ1M0MsUUFGeEM7TUFFd0MsS0FDMUJyMEMsQ0FEMEIsS0FDcENvMEMsQ0FEb0MsSUFFdEN6c0MsRUFBTXFxQyxZQUFOcnFDLENBQW1CLE9BQW5CQSxFQUE0QnlzQyxDQUE1QnpzQyxDQUZzQyxFQUl4Q0EsRUFBTTRtQyxXQUFONW1DLEdBQXFCb0wsRUFBZ0J3Z0MsT0FKRyxFQUt4Q1UsRUFBV3BzQyxXQUFYb3NDLENBQXVCdHNDLENBQXZCc3NDLENBTHdDO0tBSDFDQyxDQUxFUDtFQWF1QmhzQyxDQTVFN0I7RUFBQSxJQXlGYTJzQyxNQUFxQlgsTUFDN0I1Z0M7SUFBQUEsT0FBeUJBLENBQXpCQTtFQUFBQSxDQUQ2QjRnQyxHQUU3QjVnQztJQUFBQSxPQUNDQSxhQUFhb2dDLGFBQWJwZ0MsR0FYMkJ3aEM7TUFDL0IsSUFBSWhCLElBQVUsRUFBZDs7TUFEK0JnQiwyQ0FFWkEsRUFBTUMsUUFGTUQ7OztNQUFBQTtRQUUvQjtVQUFBLElBQVdFLEVBQVg7VUFDRWxCLEtBQVdrQixHQUFLbEIsT0FBaEJBOzs7UUFINkJnQjs7UUFBQUE7OztNQUsvQixPQUFPVixJQUFVTixDQUFWTSxDQUFQO0tBTDhCLENBVzJCOWdDLENBWDNCLENBVzFCQSxHQUEwREEsQ0FEM0RBO0VBQUFBLENBM0ZMOzs7Ozs7Ozs7O0VDdENBLElBQU1pM0IsTUFBZ0JsdEMsT0FDbkJrdEMsWUFESDtFQUFBLElBT01pSSxNQUFpQ2pJLE1BQ2xDQSxJQUFhd0UsV0FEcUJ4RSxHQUVuQyxFQVRKO0VBQUEsSUFXTTRJLE1BRUY5MUMsT0FBTzQzQyw4QkFiWDtFQUFBLElBMlFhQyxNQUE4QztJQUN6REMsWUFBWXgxQyxDQUFadzFDLEVBQTRCaHpDLENBQTVCZ3pDLEVBQTRCaHpDO01BQzFCLFFBQVFBLENBQVI7UUFDRSxLQUFLaXpDLE9BQUw7VUFDRXoxQyxJQUFRQSxJQUFRNnlDLEdBQVI3eUMsR0FBeUMsSUFBakRBO1VBQ0E7O1FBQ0YsS0FBSzFCLE1BQUw7UUFDQSxLQUFLcUosS0FBTDtVQUdFM0gsSUFBaUIsUUFBVEEsQ0FBUyxHQUFPQSxDQUFQLEdBQWUySixLQUFLRSxTQUFMRixDQUFlM0osQ0FBZjJKLENBQWhDM0o7OztNQUdKLE9BQU9BLENBQVA7S0FidUQ7O0lBZ0J6RDAxQyxjQUFjMTFDLENBQWQwMUMsRUFBb0NsekMsQ0FBcENrekMsRUFBb0NsekM7TUFDbEMsSUFBSW16QyxJQUFxQjMxQyxDQUF6Qjs7TUFDQSxRQUFRd0MsQ0FBUjtRQUNFLEtBQUtpekMsT0FBTDtVQUNFRSxJQUFzQixTQUFWMzFDLENBQVoyMUM7VUFDQTs7UUFDRixLQUFLbGpDLE1BQUw7VUFDRWtqQyxJQUFzQixTQUFWMzFDLENBQVUsR0FBTyxJQUFQLEdBQWN5UyxPQUFPelMsQ0FBUHlTLENBQXBDa2pDO1VBQ0E7O1FBQ0YsS0FBS3IzQyxNQUFMO1FBQ0EsS0FBS3FKLEtBQUw7VUFJRTtZQUVFZ3VDLElBQVloc0MsS0FBS2lzQyxLQUFManNDLENBQVczSixDQUFYMkosQ0FBWmdzQztXQUZGLENBR0UsT0FBT3YzQyxDQUFQLEVBQU9BO1lBQ1B1M0MsSUFBWSxJQUFaQTs7Ozs7TUFJTixPQUFPQSxDQUFQOzs7RUF0Q3VELENBM1EzRDtFQUFBLElBNlRhRSxNQUF1QixTQUF2QkEsQ0FBdUIsQ0FBQzcxQyxDQUFELEVBQWlCODFDLENBQWpCO0lBQUEsT0FFM0JBLE1BQVE5MUMsQ0FBUjgxQyxLQUFrQkEsS0FBUUEsQ0FBUkEsSUFBZTkxQyxLQUFVQSxDQUEzQzgxQyxDQUYyQjtFQUFBLENBN1RwQztFQUFBLElBa1VNQyxNQUFrRDtJQUN0RHg2QixZQUFXLENBRDJDO0lBRXREL1ksTUFBTVgsTUFGZ0Q7SUFHdERtMEMsV0FBV1QsR0FIMkM7SUFJdERVLFVBQVMsQ0FKNkM7SUFLdERDLFlBQVlMO0VBTDBDLENBbFV4RDs7TUErVnNCTTs7Ozs7SUFpZ0JwQi9vQztNQUFBQTs7TUFBQUE7O01BQ0UwbEMsMkJBM0NNckYsYUFBd0MsSUFBSS9iLEdBQUosRUEyQzlDb2hCLEVBakNGckYsTUFBZTJJLGVBQWYzSSxHQUFlMkksQ0FBRyxDQWlDaEJ0RCxFQTFCRnJGLE1BQVU0SSxVQUFWNUksR0FBVTRJLENBQUcsQ0EwQlh2RCxFQVJNckYsTUFBb0I2SSxJQUFwQjdJLEdBQTJDLElBUWpEcUYsRUFDQXJGLE1BQUs4SSxDQUFMOUksRUFEQXFGO01BREYxbEM7Ozs7O2FBV0FtcEM7UUFBQUE7O1FBQUFBO1FBQ0U5SSxLQUFLK0ksSUFBTC9JLEdBQXVCLElBQUkvaUIsT0FBSixDQUNwQjFYO1VBQUFBLE9BQVN5NkIsT0FBS2dKLGNBQUxoSixHQUFzQno2QixDQUEvQkE7U0FEb0IsQ0FBdkJ5NkIsRUFHQUEsS0FBS2lKLElBQUxqSixHQUEyQixJQUFJL2IsR0FBSixFQUgzQitiLEVBSUFBLEtBQUtrSixJQUFMbEosRUFKQUEsRUFPQUEsS0FBS21KLGFBQUxuSixFQVBBQSxFQVEwRCxVQUExRDllLElBQUM4ZSxLQUFLcmdDLFdBQUxxZ0MsQ0FBNENvSixDQUFhLEtBQWJBLEtBQWEsQ0FBYkEsS0FBYWxvQixPQUFFdmdCLE9BQUZ1Z0IsQ0FBV3ZxQjtVQUFBQSxPQUNuRUEsRUFBRXFwQyxNQUFGcnBDLENBRG1FQTtTQUFYdXFCLENBUjFEOGU7Ozs7YUFzQkZxSix1QkFBY0MsQ0FBZEQsRUFBY0M7UUFBQUE7UUFBQUEsQ0FDTyxVQUFuQnBvQixJQUFDOGUsS0FBS3VKLElBQWEsS0FBYkEsS0FBYSxDQUFiQSxLQUFhcm9CLFFBQWxCOGUsS0FBS3VKLElBQUx2SixHQUF1QixFQURac0osRUFDZ0JoMkMsSUFEaEJnMkMsQ0FDcUJBLENBRHJCQSxHQUNxQkEsS0FLVG4yQyxDQUxTbTJDLEtBSzdCdEosS0FBS29ILFVBTHdCa0MsSUFLSXRKLEtBQUsrRCxXQUxUdUYsS0FNL0IsZ0JBQVdFLGFBQVgsS0FBV0EsS0FBWCxDQUFXQSxLQUFYbGhCLGNBTitCZ2hCLENBRHJCQTs7OzthQWVkRywwQkFBaUJILENBQWpCRyxFQUFpQkg7UUFBQUE7UUFBQUEsVUFHZnBvQixTQUFLcW9CLElBSFVELEtBR1ZDLFlBSFVELElBR1ZDLEVBQWU1a0IsTUFBZjRrQixDQUFzQnZKLEtBQUt1SixJQUFMdkosQ0FBbUJ4eUIsT0FBbkJ3eUIsQ0FBMkJzSixDQUEzQnRKLE1BQTJDLENBQWpFdUosRUFBb0UsQ0FBcEVBLENBSFVEOzs7O2FBa0JUSjtRQUFBQTs7UUFHTGxKLEtBQUtyZ0MsV0FBTHFnQyxDQUE0QzBKLGlCQUE1QzFKLENBQThEci9CLE9BQTlEcS9CLENBQ0MsVUFBQ2hnQixDQUFELEVBQUszSyxDQUFMLEVBQUtBO1VBQ0MycUIsT0FBSzF2QyxjQUFMMHZDLENBQW9CM3FCLENBQXBCMnFCLE1BQ0ZBLE9BQUsySixJQUFMM0osQ0FBMkJ4aEMsR0FBM0J3aEMsQ0FBK0IzcUIsQ0FBL0IycUIsRUFBa0NBLE9BQUszcUIsQ0FBTDJxQixDQUFsQ0EsR0FBdUMzcUIsT0FDaEMycUIsT0FBSzNxQixDQUFMMnFCLENBRkxBO1NBRlBBOzs7O2FBbUJPNEo7UUFBQUE7UUFDUixJQUFNeEMsSUFFSixVQURBbG1CLFNBQUsyb0IsVUFDTCxLQURLQSxLQUNMLENBREtBLEtBQ0wzb0IsYUFBSzRvQixZQUFMOUosQ0FDR0EsS0FBS3JnQyxXQUFMcWdDLENBQTRDK0osaUJBRC9DL0osQ0FGRjtRQVNBLE9BSkFtSCxJQUNFQyxDQURGRCxFQUVHbkgsS0FBS3JnQyxXQUFMcWdDLENBQTRDZ0ssYUFGL0M3QyxHQUlPQyxDQUFQOzs7O2FBUUY2QztRQUFBQTtRQUFBQSxLQUUwQjkyQyxDQUYxQjgyQyxLQUVNakssS0FBS29ILFVBRlg2QyxLQUlNakssS0FHQW9ILFVBSEFwSCxHQUdhQSxLQUFLNEosZ0JBQUw1SixFQVBuQmlLLEdBU0VqSyxLQUFLZ0osY0FBTGhKLENBQUtnSixDQUFlLENBQXBCaEosQ0FURmlLLEVBVW9CLFVBQWxCL29CLFNBQUtxb0IsSUFBYSxLQUFiQSxLQUFhLENBQWJBLEtBQWFyb0IsT0FBRXZnQixPQUFGdWdCLENBQVd4c0I7VUFBSztVQUFDLE9BQWUsVUFBZndzQixNQUFFc29CLGFBQWEsS0FBYkEsS0FBYSxDQUFiQSxLQUFhdG9CLG9CQUFmeHNCLENBQWV3c0IsQ0FBZjtTQUFqQkEsQ0FWcEIrb0I7Ozs7YUFtQlVqQix3QkFBZWtCLENBQWZsQixFQUFla0I7OzthQVF6QkM7UUFBQUE7UUFDb0IsVUFBbEJqcEIsU0FBS3FvQixJQUFhLEtBQWJBLEtBQWEsQ0FBYkEsS0FBYXJvQixPQUFFdmdCLE9BQUZ1Z0IsQ0FBV3hzQjtVQUFLO1VBQUMsT0FBa0IsVUFBbEJ3c0IsTUFBRWtwQixnQkFBZ0IsS0FBaEJBLEtBQWdCLENBQWhCQSxLQUFnQmxwQixvQkFBbEJ4c0IsQ0FBa0J3c0IsQ0FBbEI7U0FBakJBOzs7O2FBZXBCbXBCLGtDQUNFcjFDLENBREZxMUMsRUFFRUMsQ0FGRkQsRUFHRTkzQyxDQUhGODNDLEVBR0U5M0M7UUFFQXl0QyxLQUFLdUssSUFBTHZLLENBQTJCaHJDLENBQTNCZ3JDLEVBQWlDenRDLENBQWpDeXRDOzs7O2FBR013SyxjQUNOeDFDLENBRE13MUMsRUFFTmo0QyxDQUZNaTRDLEVBR3lCbEM7UUFBQUEsSUFBL0J6SixDQUErQnlKO1FBQUFBOztRQUUvQixJQUFNbUMsSUFDSnpLLEtBQUtyZ0MsV0FBTHFnQyxDQUNBMEssSUFEQTFLLENBQzJCaHJDLENBRDNCZ3JDLEVBQ2lDbkIsQ0FEakNtQixDQURGOztRQUdBLFNBQWE3c0MsQ0FBYixLQUFJczNDLENBQUosSUFBSUEsQ0FBMEMsQ0FBMUNBLEtBQXNCNUwsRUFBUTJKLE9BQWxDLEVBQW9EO1VBQ2xELElBR01tQyxNQUZ5RCxVQUE3RHJpQixJQUFnRCxVQUFoRHBILElBQUMyZCxFQUFRMEosU0FBdUMsS0FBdkNBLEtBQXVDLENBQXZDQSxLQUF1Q3JuQixlQUFFNm1CLFdBQVcsS0FBWEEsS0FBVyxDQUFYQSxLQUFXemYsUUFDN0R3ZixJQUFpQkMsV0FDYjRDLEVBQXlCcDRDLENBQXpCbzRDLEVBQWdDOUwsRUFBUTlwQyxJQUF4QzQxQyxDQUhOOztVQTJCQTNLLEtBQUs2SSxJQUFMN0ksR0FBNEJockMsQ0FBNUJnckMsRUFDaUIsUUFBYjJLLEVBQWEsR0FDZjNLLEtBQUt3QixlQUFMeEIsQ0FBcUJ5SyxDQUFyQnpLLENBRGUsR0FHZkEsS0FBS21GLFlBQUxuRixDQUFrQnlLLENBQWxCekssRUFBd0IySyxFQUF4QjNLLENBSkZBLEVBT0FBLEtBQUs2SSxJQUFMN0ksR0FBNEIsSUFQNUJBOzs7OzthQVlKdUssY0FBc0J2MUMsQ0FBdEJ1MUMsRUFBb0NoNEMsQ0FBcENnNEMsRUFBb0NoNEM7UUFBQUE7O1FBQ2xDLElBQU02bUMsSUFBTzRHLEtBQUtyZ0MsV0FBbEI7WUFHTWlyQyxJQUFZeFIsRUFBS3lSLElBQUx6UixDQUErQ3JvQyxHQUEvQ3FvQyxDQUFtRHBrQyxDQUFuRG9rQyxDQUhsQjs7UUFNQSxTQUFpQmptQyxDQUFqQixLQUFJeTNDLENBQUosSUFBOEI1SyxLQUFLNkksSUFBTDdJLEtBQThCNEssQ0FBNUQsRUFBc0U7VUFDcEUsSUFBTS9MLEtBQVV6RixFQUFLMFIsa0JBQUwxUixDQUF3QndSLENBQXhCeFIsQ0FBaEI7Y0FDTW1QLEtBQVkxSixHQUFRMEosU0FEMUI7Y0FFTU4sZ0JBQ0psb0IsSUFDQSxVQURBdUksSUFBMEMsVUFBekNwSCxNQUF5QyxLQUF6Q3FuQixLQUF5QyxDQUF6Q0EsS0FBeUNybkIsNEJBQzFDLEtBRDBDK21CLEtBQzFDLENBRDBDQSxLQUMxQzNmLFFBQXNCLHFCQUFkaWdCLEVBQWMsR0FDakJBLEVBRGlCLEdBRWxCLElBSkFOLEtBSUEsWUFKQUEsR0FJQW5tQixDQUpBbW1CLEdBS0pILElBQWlCRyxhQVBuQjs7VUFTQWpJLEtBQUs2SSxJQUFMN0ksR0FBNEI0SyxDQUE1QjVLLEVBRUFBLEtBQUs0SyxDQUFMNUssSUFBK0JpSSxJQUFlMTFDLENBQWYwMUMsRUFBc0JwSixHQUFROXBDLElBQTlCa3pDLENBRi9CakksRUFJQUEsS0FBSzZJLElBQUw3SSxHQUE0QixJQUo1QkE7Ozs7O2FBc0JKbUosdUJBQ0VuMEMsQ0FERm0wQyxFQUVFNEIsQ0FGRjVCLEVBR0V0SyxDQUhGc0ssRUFHRXRLO1FBRUEsSUFBSW1NLEtBQXNCLENBQTFCO1FBQTBCLEtBRWI3M0MsQ0FGYSxLQUV0QjZCLENBRnNCLEtBRXRCQSxFQUNGNnBDLElBQ0VBLEtBQ0NtQixLQUFLcmdDLFdBQUxxZ0MsQ0FBNEM4SyxrQkFBNUM5SyxDQUErRGhyQyxDQUEvRGdyQyxDQUhEaHJDLEVBSXlCeXpDLFVBSnpCenpDLElBSXVDb3pDLEdBSnZDcHpDLEVBS2FnckMsS0FBS2hyQyxDQUFMZ3JDLENBTGJockMsRUFLdUMrMUMsQ0FMdkMvMUMsS0FNS2dyQyxLQUFLaUosSUFBTGpKLENBQXlCL3JDLEdBQXpCK3JDLENBQTZCaHJDLENBQTdCZ3JDLEtBQ0hBLEtBQUtpSixJQUFMakosQ0FBeUJ4aEMsR0FBekJ3aEMsQ0FBNkJockMsQ0FBN0JnckMsRUFBbUMrSyxDQUFuQy9LLENBREdBLEVBQ2dDK0ssQ0FNYixDQU5hQSxLQU1qQ2xNLEVBQVEySixPQU55QnVDLElBTUwvSyxLQUFLNkksSUFBTDdJLEtBQThCaHJDLENBTnpCKzFDLEtBTXlCLzFDLEtBQ3hCN0IsQ0FEd0I2QixLQUN4RGdyQyxLQUFLaUwsSUFEbURqMkMsS0FFMURnckMsS0FBS2lMLElBQUxqTCxHQUE4QixJQUFJL2IsR0FBSixFQUY0Qmp2QixHQUk1RGdyQyxLQUFLaUwsSUFBTGpMLENBQTRCeGhDLEdBQTVCd2hDLENBQWdDaHJDLENBQWhDZ3JDLEVBQXNDbkIsQ0FBdENtQixDQVZtQytLLENBUHJDLzFDLElBcUJBZzJDLEtBQXNCLENBdkJBLEdBdUJBLENBR3JCaEwsS0FBSzJJLGVBSGdCLElBR0dxQyxDQUhILEtBSXhCaEwsS0FBSytJLElBQUwvSSxHQUF1QkEsS0FBS2tMLElBQUxsTCxFQUpDLENBdkJBOzs7Ozs0RUF1Q3BCakc7VUFBQUE7VUFBQUE7WUFBQUE7Y0FBQUE7Z0JBQUFBO2tCQUNOaUcsS0FBSzJJLGVBQUwzSSxHQUFLMkksQ0FBa0IsQ0FBdkIzSTtrQkFETWpHO2tCQUFBQTtrQkFBQUEsT0FLRWlHLEtBQUsrSSxJQUxQaFA7O2dCQUFBQTtrQkFBQUE7a0JBQUFBOztnQkFBQUE7a0JBQUFBO2tCQUFBQTtrQkFXSjljLFFBQVFzQixNQUFSdEI7O2dCQVhJOGM7a0JBYUF4Z0MsQ0FiQXdnQyxHQWFTaUcsS0FBS21MLGNBQUxuTCxFQWJUakc7a0JBQUFBLGNBaUJRLFFBQVZ4Z0MsQ0FqQkV3Z0M7O2tCQUFBQTtvQkFBQUE7b0JBQUFBOzs7a0JBQUFBO2tCQUFBQSxPQWtCRXhnQyxDQWxCRndnQzs7Z0JBQUFBO2tCQUFBQSxpQ0FrQkV4Z0MsQ0FFQXltQyxLQUFLMkksZUFwQlA1Tzs7Z0JBQUFBO2dCQUFBQTtrQkFBQUE7Ozs7Ozs7Ozs7Ozs7O2FBd0NFb1I7UUFDUixPQUFPbkwsS0FBS29MLGFBQUxwTCxFQUFQOzs7O2FBb0JRb0w7UUFBQUE7O1FBQUFBO1FBSVIsS0FBS3BMLEtBQUsySSxlQUFWLEVBQ0U7UUFJRzNJLEtBQUs0SSxVQUFMNUksRUF5QkRBLEtBQUsySixJQUFMM0osS0FJRkEsS0FBSzJKLElBQUwzSixDQUEyQnIvQixPQUEzQnEvQixDQUFtQyxVQUFDdGhCLENBQUQsRUFBSXJKLENBQUo7VUFBQSxPQUFZMnFCLE9BQWEzcUIsQ0FBYjJxQixJQUFrQnRoQixDQUE5QjtTQUFuQ3NoQixHQUNBQSxLQUFLMkosSUFBTDNKLEdBQUsySixLQUF1QngyQyxDQUwxQjZzQyxDQXpCQ0E7UUFnQ0wsSUFBSXFMLEtBQWUsQ0FBbkI7UUFDQSxJQUFNQyxJQUFvQnRMLEtBQUtpSixJQUEvQjs7UUFDQTtVQUNFb0MsSUFBZXJMLEtBQUtxTCxZQUFMckwsQ0FBa0JzTCxDQUFsQnRMLENBQWZxTCxFQUNJQSxLQUNGckwsS0FBS3VMLFVBQUx2TCxDQUFnQnNMLENBQWhCdEwsR0FDa0IsVUFBbEIxWCxTQUFLaWhCLElBQWEsS0FBYkEsS0FBYSxDQUFiQSxLQUFhamhCLE9BQUUzbkIsT0FBRjJuQixDQUFXNXpCO1lBQUs7WUFBQyxPQUFZLFVBQVp3c0IsTUFBRXNxQixVQUFVLEtBQVZBLEtBQVUsQ0FBVkEsS0FBVXRxQixvQkFBWnhzQixDQUFZd3NCLENBQVo7V0FBakJvSCxDQURsQjBYLEVBRUFBLEtBQUt5TCxNQUFMekwsQ0FBWXNMLENBQVp0TCxDQUhFcUwsSUFLRnJMLEtBQUswTCxJQUFMMUwsRUFORnFMO1NBREYsQ0FTRSxPQUFPMTZDLENBQVAsRUFBT0E7VUFNUCxNQUhBMDZDLEtBQWUsQ0FBZkEsRUFFQXJMLEtBQUswTCxJQUFMMUwsRUFGQXFMLEVBR00xNkMsQ0FBTjs7O1FBR0UwNkMsS0FDRnJMLEtBQUsyTCxJQUFMM0wsQ0FBaUJzTCxDQUFqQnRMLENBREVxTDs7OzthQTBCSUUsb0JBQVdLLENBQVhMLEVBQVdLOzs7YUFJckJELGNBQVlMLENBQVpLLEVBQVlMO1FBQUFBO1FBQ1EsVUFBbEJwcUIsU0FBS3FvQixJQUFhLEtBQWJBLEtBQWEsQ0FBYkEsS0FBYXJvQixPQUFFdmdCLE9BQUZ1Z0IsQ0FBV3hzQjtVQUFLO1VBQUMsT0FBYSxVQUFid3NCLE1BQUUycUIsV0FBVyxLQUFYQSxLQUFXLENBQVhBLEtBQVczcUIsb0JBQWJ4c0IsQ0FBYXdzQixDQUFiO1NBQWpCQSxHQUNiOGUsS0FBSzRJLFVBQUw1SSxLQUNIQSxLQUFLNEksVUFBTDVJLEdBQUs0SSxDQUFhLENBQWxCNUksRUFDQUEsS0FBSzhMLFlBQUw5TCxDQUFrQnNMLENBQWxCdEwsQ0FGR0EsQ0FEYSxFQUtsQkEsS0FBSytMLE9BQUwvTCxDQUFhc0wsQ0FBYnRMLENBTGtCOzs7O2FBd0JaMEw7UUFDTjFMLEtBQUtpSixJQUFMakosR0FBMkIsSUFBSS9iLEdBQUosRUFBM0IrYixFQUNBQSxLQUFLMkksZUFBTDNJLEdBQUsySSxDQUFrQixDQUR2QjNJOzs7O1dBb0JFZ007UUFDRixPQUFPaE0sS0FBS2lNLGlCQUFMak0sRUFBUDs7OzthQTBCUWlNO1FBQ1IsT0FBT2pNLEtBQUsrSSxJQUFaOzs7O2FBV1FzQyxzQkFBYU8sQ0FBYlAsRUFBYU87UUFDckIsUUFBTyxDQUFQOzs7O2FBWVFILGdCQUFPRyxDQUFQSCxFQUFPRztRQUFBQTs7UUFBQUEsS0FDcUJ6NEMsQ0FEckJ5NEMsS0FDWDVMLEtBQUtpTCxJQURNVyxLQUliNUwsS0FBS2lMLElBQUxqTCxDQUE0QnIvQixPQUE1QnEvQixDQUFvQyxVQUFDdGhCLENBQUQsRUFBSTdmLENBQUo7VUFBQSxPQUNsQ21oQyxPQUFLd0ssSUFBTHhLLENBQTJCbmhDLENBQTNCbWhDLEVBQThCQSxPQUFLbmhDLENBQUxtaEMsQ0FBOUJBLEVBQXFEdGhCLENBQXJEc2hCLENBRGtDO1NBQXBDQSxHQUdBQSxLQUFLaUwsSUFBTGpMLEdBQUtpTCxLQUF5QjkzQyxDQVBqQnk0QyxHQVNmNUwsS0FBSzBMLElBQUwxTCxFQVRlNEw7Ozs7YUFzQlBHLGlCQUFRSCxDQUFSRyxFQUFRSDs7O2FBa0JSRSxzQkFBYUYsQ0FBYkUsRUFBYUY7OzthQTkrQnZCaEssd0JBQXNCc0ssQ0FBdEJ0SyxFQUFzQnNLO1FBQUFBO1FBQ0YsVUFBbEJockIsU0FBS2tvQixDQUFhLEtBQWJBLEtBQWEsQ0FBYkEsS0FBYWxvQixNQUFsQjhlLEtBQUtvSixDQUFMcEosR0FBdUIsRUFBTCxHQUNsQkEsS0FBS29KLENBQUxwSixDQUFtQjFzQyxJQUFuQjBzQyxDQUF3QmtNLENBQXhCbE0sQ0FEa0I7Ozs7V0E0R1RtTTtRQUFBQTs7UUFFVG5NLEtBQUtvTSxRQUFMcE07UUFDQSxJQUFNbE8sSUFBdUIsRUFBN0I7UUFVQSxPQVBBa08sS0FBSzBKLGlCQUFMMUosQ0FBdUJyL0IsT0FBdkJxL0IsQ0FBK0IsVUFBQ3RoQixDQUFELEVBQUlySixDQUFKLEVBQUlBO1VBQ2pDLElBQU1vMUIsSUFBT3pLLE9BQUswSyxJQUFMMUssQ0FBZ0MzcUIsQ0FBaEMycUIsRUFBbUN0aEIsQ0FBbkNzaEIsQ0FBYjs7VUFBZ0R0aEIsS0FDbkN2ckIsQ0FEbUN1ckIsS0FDNUMrckIsQ0FENEMvckIsS0FFOUNzaEIsT0FBSzZLLElBQUw3SyxDQUE4QnhoQyxHQUE5QndoQyxDQUFrQ3lLLENBQWxDekssRUFBd0MzcUIsQ0FBeEMycUIsR0FDQWxPLEVBQVd4K0IsSUFBWHcrQixDQUFnQjJZLENBQWhCM1ksQ0FIOENwVDtTQURsRHNoQixHQU9PbE8sQ0FBUDs7OzthQTRCRjhQLHdCQUNFNXNDLENBREY0c0MsRUFFaUMwRztRQUFBQSxJQUEvQnpKLENBQStCeUo7O1FBaUIvQixJQWRJekosRUFBUTdFLEtBQVI2RSxLQUdEQSxFQUFnQi93QixTQUFoQit3QixHQUFnQi93QixDQUFZLENBSDNCK3dCLEdBT0ptQixLQUFLb00sUUFBTHBNLEVBUEluQixFQVFKbUIsS0FBSzBKLGlCQUFMMUosQ0FBdUJ4aEMsR0FBdkJ3aEMsQ0FBMkJockMsQ0FBM0JnckMsRUFBaUNuQixDQUFqQ21CLENBUkluQixFQVE2QkEsQ0FNNUJBLEVBQVF3TixVQU5vQnhOLElBTXBCd04sQ0FBZXJNLEtBQUszckMsU0FBTDJyQyxDQUFlMXZDLGNBQWYwdkMsQ0FBOEJockMsQ0FBOUJnckMsQ0FBNUIsRUFBaUU7VUFDL0QsSUFBTXh2QyxLQUFzQixtQkFBVHdFLENBQVMsR0FBV29DLFFBQVgsR0FBc0IsT0FBS3BDLENBQXZEO2NBQ002VixLQUFhbTFCLEtBQUtzTSxxQkFBTHRNLENBQTJCaHJDLENBQTNCZ3JDLEVBQWlDeHZDLEVBQWpDd3ZDLEVBQXNDbkIsQ0FBdENtQixDQURuQjs7VUFDeURuQixLQUN0QzFyQyxDQURzQzByQyxLQUNyRGgwQixFQURxRGcwQixJQUV2RGh1QyxPQUFPQyxjQUFQRCxDQUFzQm12QyxLQUFLM3JDLFNBQTNCeEQsRUFBc0NtRSxDQUF0Q25FLEVBQTRDZ2EsRUFBNUNoYSxDQUZ1RGd1Qzs7Ozs7YUE0Q25EK0MsK0JBQ1I1c0MsQ0FEUTRzQyxFQUVScHhDLENBRlFveEMsRUFHUi9DLENBSFErQyxFQUdSL0M7UUFFQSxPQUFPO1VBRUw5dEM7WUFDRSxPQUFRaXZDLEtBQWtDeHZDLENBQWxDd3ZDLENBQVI7V0FIRzs7VUFLTHhoQyxJQUEyQmpNLENBQTNCaU0sRUFBMkJqTTtZQUN6QixJQUFNdzRDLElBQVkvSyxLQUNoQmhyQyxDQURnQmdyQyxDQUFsQjtZQUdDQSxLQUF3Q3h2QyxDQUF4Q3d2QyxJQUF5RHp0QyxDQUF6RHl0QyxFQUNBQSxLQUFvQ21KLGFBQXBDbkosQ0FDQ2hyQyxDQUREZ3JDLEVBRUMrSyxDQUZEL0ssRUFHQ25CLENBSERtQixDQURBQTtXQVRFOztVQWdCTHR0QyxlQUFjLENBaEJUO1VBaUJMRCxhQUFZO1NBakJkOzs7O2FBbUNGbXZDLDRCQUEwQjVzQyxDQUExQjRzQyxFQUEwQjVzQztRQUN4QixPQUFPZ3JDLEtBQUswSixpQkFBTDFKLENBQXVCanZDLEdBQXZCaXZDLENBQTJCaHJDLENBQTNCZ3JDLEtBQW9Dc0ksR0FBM0M7Ozs7YUFTUTFHO1FBQ1IsSUFBSTVCLEtBQUsxdkMsY0FBTDB2QyxDQS9XVSxXQStXVkEsQ0FBSixFQUNFLFFBQU8sQ0FBUDtRQUVGQSxLQUFjdU0sU0FBZHZNLEdBQWMsQ0FBSSxDQUFsQkE7UUFFQSxJQUFNd00sSUFBWTM3QyxPQUFPNk8sY0FBUDdPLENBQXNCbXZDLElBQXRCbnZDLENBQWxCOztRQVNBLElBUkEyN0MsRUFBVUosUUFBVkksSUFDQXhNLEtBQUswSixpQkFBTDFKLEdBQXlCLElBQUkvYixHQUFKLENBQVF1b0IsRUFBVTlDLGlCQUFsQixDQUR6QjhDLEVBR0F4TSxLQUFLNkssSUFBTDdLLEdBQWdDLElBQUkvYixHQUFKLEVBSGhDdW9CLEVBUUl4TSxLQUFLMXZDLGNBQUwwdkMsQ0FBOEMsWUFBOUNBLENBQUosRUFBd0U7VUFDdEUsSUFBTXlNLE1BQVF6TSxLQUFLME0sVUFBbkI7Y0FFTUMsa0NBQ0Q5N0MsT0FBTzJLLG1CQUFQM0ssQ0FBMkI0N0MsR0FBM0I1N0MsQ0FEQzg3QyxzQkFFRDk3QyxPQUFPOEkscUJBQVA5SSxDQUE2QjQ3QyxHQUE3QjU3QyxDQUZDODdDLEVBRk47O1VBRHNFLDJDQVF0REEsRUFSc0Q7OztVQUFBO1lBUXRFO2NBQUEsSUFBV3QzQixHQUFYO2NBSUUycUIsS0FBSzN1QixjQUFMMnVCLENBQW9CM3FCLEdBQXBCMnFCLEVBQXdCeU0sSUFBY3AzQixHQUFkbzNCLENBQXhCek07OztZQVpvRTs7WUFBQTs7OztRQWdDeEUsT0FqQkFBLEtBQUtnSyxhQUFMaEssR0FBcUJBLEtBQUs0TSxjQUFMNU0sQ0FBb0JBLEtBQUtxSCxNQUF6QnJILENBQXJCQSxFQUE4Q3FILENBaUJ2QyxDQUFQOzs7O2FBNkJRekYsd0JBQ1J5RixDQURRekYsRUFDUnlGO1FBRUEsSUFBTTJDLElBQWdCLEVBQXRCOztRQUNBLElBQUk5dkMsTUFBTUMsT0FBTkQsQ0FBY210QyxDQUFkbnRDLENBQUosRUFBMkI7VUFJekIsSUFBTXNFLE1BQU0sSUFBSTRsQixHQUFKLENBQVNpakIsRUFBMEJ3RixJQUExQnhGLENBQStCcmpDLEtBQS9CcWpDLEVBQXlDN2UsT0FBekM2ZSxFQUFULENBQVo7O1VBSnlCLDRDQU1UN29DLEdBTlM7OztVQUFBO1lBTXpCO2NBQUEsSUFBVzBILEdBQVg7Y0FDRThqQyxFQUFjOEMsT0FBZDlDLENBQXNCdkMsSUFBbUJ2aEMsR0FBbkJ1aEMsQ0FBdEJ1Qzs7O1lBUHVCOztZQUFBOztTQUEzQixNQU82QzlqQyxLQUV2Qi9TLENBRnVCK1MsS0FFbENtaEMsQ0FGa0NuaEMsSUFHM0M4akMsRUFBYzEyQyxJQUFkMDJDLENBQW1CdkMsSUFBbUJKLENBQW5CSSxDQUFuQnVDLENBSDJDOWpDOztRQUs3QyxPQUFPOGpDLENBQVA7Ozs7YUFjTXBJLGNBQ041c0MsQ0FETTRzQyxFQUVOL0MsQ0FGTStDLEVBRU4vQztRQUVBLElBQU0vd0IsSUFBWSt3QixFQUFRL3dCLFNBQTFCO1FBQ0EsUUFBcUIsQ0FBckIsS0FBT0EsQ0FBUCxHQUFPQSxLQUNIM2EsQ0FESixHQUV5QixtQkFBZDJhLENBQWMsR0FDckJBLENBRHFCLEdBRUwsbUJBQVQ5WSxDQUFTLEdBQ2hCQSxFQUFLZ1osV0FBTGhaLEVBRGdCLEdBQ1hnWixLQUNMN2EsQ0FOSjs7Ozs7bUNBN2NNNDVDOztBQTZHU3JFLE1BQVc2RCxTQUFYN0QsR0FBVyxDQUFHLENBQWRBLEVBUVZBLHdCQUE0QyxJQUFJemtCLEdBQUosRUFSbEN5a0IsRUEyQ1ZBLElBQWFzQixhQUFidEIsR0FBMEMsRUEzQ2hDQSxFQTZTVkEsd0JBQW9DO0lBQUNuMUMsTUFBTTtFQUFQLENBN1MxQm0xQyxFQTA5Qm5CM0MsbUJBQWtCO0lBQUMyQztFQUFELENBQWxCM0MsQ0ExOUJtQjJDLEVBMDlCQUEsQ0FvQ2dCLFVBQW5DM29CLE1BQUM0YyxXQUFXcVEsdUJBQXVCLEtBQXZCQSxLQUF1QixDQUF2QkEsS0FBdUJqdEIsWUFBbEM0YyxXQUFXcVEsdUJBQVhyUSxHQUF1QyxFQXBDckIrTCxFQW9DeUJwMUMsSUFwQ3pCbzFDLENBb0M4QixPQXBDOUJBLENBMTlCQUE7Ozs7Ozs7OztFQ3ZRbkIsSUFPTXZMLE1BQWdCUixXQUEwQ1EsWUFQaEU7RUFBQSxJQWlCTUMsTUFBU0QsTUFDWEEsSUFBYUUsWUFBYkYsQ0FBMEIsVUFBMUJBLEVBQXNDO0lBQ3BDdHZCLFlBQWEzSDtNQUFBQSxPQUFNQSxDQUFOQTs7RUFEdUIsQ0FBdENpM0IsQ0FEV0EsR0FFVWozQixLQUVyQi9TLENBckJKO0VBQUEsSUF1R01tcUMsb0JBQVMsQ0FBY3B0QyxLQUFLK0MsTUFBTC9DLEtBQVBrRSxFQUFQLEVBQTZCNEQsS0FBN0IsQ0FBbUMsQ0FBbkMsQ0FBVHNsQyxNQXZHTjtFQUFBLElBMEdNQyxNQUFjLE1BQU1ELEdBMUcxQjtFQUFBLElBOEdNRSxpQkFBaUJELEdBQWpCQyxNQTlHTjtFQUFBLElBZ0hNOXRCLE1BQUlwZSxRQWhIVjtFQUFBLElBbUhNbXNDLE1BQWUsU0FBZkEsQ0FBZTtJQUFBLElBQUMvZSxDQUFELHVFQUFLLEVBQUw7SUFBQSxPQUFZaFAsSUFBRWd1QixhQUFGaHVCLENBQWdCZ1AsQ0FBaEJoUCxDQUFaO0VBQUEsQ0FuSHJCO0VBQUEsSUF1SE1pdUIsTUFBZXByQyxTQUFmb3JDLENBQWVwckM7SUFBQUEsT0FDVCxTQUFWQSxDQUFVLElBQXlCLG1CQUFUQSxDQUFTLElBQTRCLHFCQUFUQSxDQURuQ0E7RUFBQUEsQ0F2SHJCO0VBQUEsSUF5SE00SCxNQUFVRCxNQUFNQyxPQXpIdEI7RUFBQSxJQTBITXlqQyxNQUFjcnJDLFNBQWRxckMsQ0FBY3JyQztJQUFBQTtJQUNsQixXQUFRQSxDQUFSNEgsS0FFNkMsc0JBQXJCLFVBQWhCK21CLEtBQWdCLEtBQWhCM3VCLEtBQWdCLENBQWhCQSxLQUFnQjJ1QixzQkFBT3ZqQixRQUFQdWpCLENBQXFCLENBRjdDO0VBRStCdmpCLENBN0hqQztFQUFBLElBaUpNa2dDLE1BQWUscURBakpyQjtFQUFBLElBc0pNQyxNQUFrQixNQXRKeEI7RUFBQSxJQTBKTUMsTUFBbUIsSUExSnpCO0VBQUEsSUFrTE1DLE1BQWMsbUZBbExwQjtFQUFBLElBMkxNQyxNQUEwQixJQTNMaEM7RUFBQSxJQTRMTUMsTUFBMEIsSUE1TGhDO0VBQUEsSUFtTU1DLE1BQWlCLG9DQW5NdkI7RUFBQSxJQXVQTXptQyxNQUNtQjNDLFNBRG5CMkMsQ0FDbUIzQztJQUFBQSxPQUN2QixVQUFDcXBDLENBQUQ7TUFBQSxrQ0FBbUMxeUIsQ0FBbkM7UUFBbUNBLENBQW5DOzs7TUFBQSxPQVVTO1FBRUwyeUIsWUFBZ0J0cEMsQ0FGWDtRQUdMcXBDLFVBSEs7UUFJTDF5QjtPQWRKO0tBRHVCM1c7RUFBQUEsQ0F4UHpCO0VBQUEsSUF3UmEyYyxNQUFPaGEsSUFsRkEsQ0FrRkFBLENBeFJwQjtFQUFBLElBaVRhNG1DLElBQU01bUMsSUExR0EsQ0EwR0FBLENBalRuQjtFQUFBLElBdVRhNm1DLE1BQVdubkMsT0FBT29uQyxHQUFQcG5DLENBQVcsY0FBWEEsQ0F2VHhCO0VBQUEsSUE0VWFxbkMsTUFBVXJuQyxPQUFPb25DLEdBQVBwbkMsQ0FBVyxhQUFYQSxDQTVVdkI7RUFBQSxJQXFWTXNuQyxNQUFnQixJQUFJclosT0FBSixFQXJWdEI7RUFBQSxJQTRZYXNaLE1BQVMsU0FBVEEsQ0FBUyxDQUNwQnBzQyxDQURvQixFQUVwQnFzQyxDQUZvQixFQUdwQkMsQ0FIb0IsRUFHcEJBO0lBQUFBO0lBVUEsSUFBTUMsSUFBeUMsVUFBekI1ZCwyQkFBUzZkLFlBQWdCLEtBQWhCQSxLQUFnQixDQUFoQkEsS0FBZ0I3ZCxTQUEvQztJQUdBLElBQUk4ZCxJQUFtQkYsRUFBa0NHLFVBQXpEOztJQVNBLFNBQWE5ckMsQ0FBYixLQUFJNnJDLENBQUosRUFBd0I7TUFDdEIsSUFBTUUsS0FBbUMsVUFBekI1VywyQkFBU3lXLFlBQWdCLEtBQWhCQSxLQUFnQixDQUFoQkEsS0FBZ0J6VyxZQUF6Qzs7TUFpQkN3VyxFQUFrQ0csVUFBbENILEdBQXNDRSxJQUFPLElBQUlHLEdBQUosQ0FDNUNQLEVBQVVRLFlBQVZSLENBQXVCbkIsS0FBdkJtQixFQUF1Q00sRUFBdkNOLENBRDRDLEVBRTVDTSxFQUY0QyxFQUU1Q0EsS0FDQS9yQyxDQUg0QyxFQUk1QzByQyxnQkFBVyxFQUppQyxDQUE3Q0M7OztJQWdCSCxPQVRBRSxFQUFLSyxJQUFMTCxDQUFnQnpzQyxDQUFoQnlzQyxHQVNPQSxDQUFQO0VBQU9BLENBdmNUO0VBQUEsSUFtZE1NLE1BQVM1dkIsSUFBRTZ2QixnQkFBRjd2QixDQUNiQSxHQURhQSxFQUViLEdBRmFBLEVBR2IsSUFIYUEsRUFHYixDQUNBLENBSmFBLENBbmRmO0VBQUEsSUF3Zk04dkIsTUFBa0IsU0FBbEJBLENBQWtCLENBQ3RCcEIsQ0FEc0IsRUFFdEJycEMsQ0FGc0IsRUFFdEJBO0lBUUEsSUFBTWdKLElBQUlxZ0MsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQTNCO1FBSU1xQixJQUF1QyxFQUo3QztJQUtBLElBS0lDLENBTEo7UUFBSWh1QixJQWhVYSxNQWdVTjNjLENBaFVNLEdBZ1VnQixPQWhVaEIsR0FnVTBCLEVBQTNDO1FBU0k0cUMsSUFBUTlCLEdBVFo7O0lBV0EsS0FBSyxJQUFJbG5DLEtBQUksQ0FBYixFQUFnQkEsS0FBSW9ILENBQXBCLEVBQXVCcEgsSUFBdkIsRUFBNEI7TUFDMUIsSUFBTXVQLEtBQUlrNEIsRUFBUXpuQyxFQUFSeW5DLENBQVY7O01BTUEsSUFDSXdCLFdBREo7VUFHSXI5QixXQUhKO1VBQUlzOUIsTUFBb0IsQ0FBeEI7VUFFSTNwQixLQUFZLENBRmhCOztNQU9BLE9BQU9BLEtBQVloUSxHQUFFM1IsTUFBZDJoQixLQUVMeXBCLEVBQU16cEIsU0FBTnlwQixHQUFrQnpwQixFQUFsQnlwQixFQUNBcDlCLEtBQVFvOUIsRUFBTWp2QyxJQUFOaXZDLENBQVd6NUIsRUFBWHk1QixDQURSQSxFQUVjLFNBQVZwOUIsRUFKQzJULENBQVA7UUFPRUEsS0FBWXlwQixFQUFNenBCLFNBQWxCQSxFQUNJeXBCLE1BQVU5QixHQUFWOEIsR0FDMkIsVUFBekJwOUIsR0F2WlUsQ0F1WlZBLENBQXlCLEdBQzNCbzlCLElBQVE3QixHQURtQixHQUNuQkEsS0FDMEIzcUMsQ0FEMUIycUMsS0FDQ3Y3QixHQXpaRyxDQXlaSEEsQ0FERHU3QixHQUdSNkIsSUFBUTVCLEdBSEFELEdBR0FDLEtBQ3FCNXFDLENBRHJCNHFDLEtBQ0N4N0IsR0EzWkYsQ0EyWkVBLENBRER3N0IsSUFFSkksSUFBZWg5QixJQUFmZzlCLENBQW9CNTdCLEdBNVpqQixDQTRaaUJBLENBQXBCNDdCLE1BR0Z1QixJQUFzQjU4QixPQUFPLE9BQUtQLEdBL1o3QixDQStaNkJBLENBQVpPLEVBQStCLEdBQS9CQSxDQUhwQnE3QixHQUtKd0IsSUFBUTNCLEdBUEFELElBT0FDLEtBQzZCN3FDLENBRDdCNnFDLEtBQ0N6N0IsR0FqYU0sQ0FpYU5BLENBRER5N0IsS0FRUjJCLElBQVEzQixHQVJBQSxDQVpSMkIsR0FzQk9BLE1BQVUzQixHQUFWMkIsR0FDbUIsUUFBeEJwOUIsR0F6WVMsQ0F5WVRBLENBQXdCLElBRzFCbzlCLElBQVFELGdCQUFtQjdCLEdBQTNCOEIsRUFHQUUsTUFBb0IsQ0FOTSxJQU1OLEtBQ2Uxc0MsQ0FEZixLQUNYb1AsR0EvWUksQ0ErWUpBLENBRFcsR0FHcEJzOUIsTUFBb0IsQ0FIQSxJQUtwQkEsS0FBbUJGLEVBQU16cEIsU0FBTnlwQixHQUFrQnA5QixHQWxackIsQ0FrWnFCQSxFQUF5QmhPLE1BQTlEc3JDLEVBQ0FELEtBQVdyOUIsR0FwWkUsQ0FvWkZBLENBRFhzOUIsRUFFQUYsU0FDd0J4c0MsQ0FEeEJ3c0MsS0FDRXA5QixHQXBaTyxDQW9aUEEsQ0FERm85QixHQUVNM0IsR0FGTjJCLEdBRzRCLFFBQXRCcDlCLEdBdFpHLENBc1pIQSxDQUFzQixHQUN0QjI3QixHQURzQixHQUV0QkQsR0FaYyxDQVBiMEIsR0FzQlRBLE1BQVV6QixHQUFWeUIsSUFDQUEsTUFBVTFCLEdBRFYwQixHQUdBQSxJQUFRM0IsR0FIUjJCLEdBSVNBLE1BQVU3QixHQUFWNkIsSUFBNkJBLE1BQVU1QixHQUF2QzRCLEdBQ1RBLElBQVE5QixHQURDOEIsSUFLVEEsSUFBUTNCLEdBQVIyQixFQUNBRCxTQUFrQnZzQyxDQU5Ud3NDLENBakRYenBCOzs7TUFxRkYsSUFBTTlJLEtBQ0p1eUIsTUFBVTNCLEdBQVYyQixJQUF5QnZCLEVBQVF6bkMsS0FBSSxDQUFaeW5DLEVBQWV6d0IsVUFBZnl3QixDQUEwQixJQUExQkEsQ0FBekJ1QixHQUEyRCxHQUEzREEsR0FBaUUsRUFEbkU7O01BRUFqdUIsS0FDRWl1QixNQUFVOUIsR0FBVjhCLEdBQ0l6NUIsS0FBSXMzQixHQURSbUMsR0FFSUUsTUFBb0IsQ0FBcEJBLElBQ0NKLEVBQVVuc0MsSUFBVm1zQyxDQUFlRyxFQUFmSCxHQUNEdjVCLEdBQUVsTyxLQUFGa08sQ0FBUSxDQUFSQSxFQUFXMjVCLEVBQVgzNUIsSUFsaUJtQixPQWtpQm5CQSxHQUVFQSxHQUFFbE8sS0FBRmtPLENBQVEyNUIsRUFBUjM1QixDQUZGQSxHQUdBbzNCLEdBSEFwM0IsR0FJQWtILEVBTkF5eUIsSUFPQTM1QixLQUNBbzNCLEdBREFwM0IsSUFDQW8zQixDQUN1QixDQUR2QkEsS0FDQ3VDLEVBRER2QyxJQUM0Qm1DLEVBQVVuc0MsSUFBVm1zQyxDQUFVbnNDLEtBQUtILENBQWZzc0MsR0FBMkI5b0MsRUFEdkQybUMsSUFDNERsd0IsRUFGNURsSCxDQVZOd0w7OztJQWVGLElBQU1vdUIsSUFDSnB1QixLQUFRMHNCLEVBQVFyZ0MsQ0FBUnFnQyxLQUFjLEtBQXRCMXNCLEtBdmNlLE1BdWNpQjNjLENBdmNqQixHQXVjdUMsUUF2Y3ZDLEdBdWNrRCxFQUFqRTJjLENBREY7SUFRQSxLQUFLeFgsTUFBTUMsT0FBTkQsQ0FBY2trQyxDQUFkbGtDLENBQUwsSUFBbUJra0MsQ0FBYUEsRUFBUTl0QyxjQUFSOHRDLENBQXVCLEtBQXZCQSxDQUFoQyxFQWtCRSxNQUFVbkUsTUFqQkksZ0NBaUJKQSxDQUFWO0lBR0YsT0FBTyxNQUNNOW1DLENBRE4sS0FDTGlxQyxHQURLLEdBRURBLElBQU92dkIsVUFBUHV2QixDQUFrQjBDLENBQWxCMUMsQ0FGQyxHQUdBMEMsQ0FIQSxFQUlMTCxDQUpLLENBQVA7RUFJRUEsQ0E5cUJKOztNQW9yQk1NO0lBTUpwZ0MsaUJBR0VrL0IsQ0FIRmwvQixFQUdFay9CO01BQUFBLElBRENULENBQ0RTLFFBREFULE9BQ0FTO1VBRDBCOXBDLENBQzFCOHBDLFFBRFVSLFVBQ1ZROztNQUFBQTs7TUFFQSxJQUFJL2dCLENBQUo7TUFQRmtpQixLQUFLQyxLQUFMRCxHQUE2QixFQUE3QkE7TUFRRSxJQUFJRSxJQUFZLENBQWhCO1VBQ0lDLElBQWdCLENBRHBCOztNQUVNQyxRQUFZaEMsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQTdCZ0M7VUFDQUgsQ0FEQUcsR0FDUUosS0FBS0MsS0FEYkc7ZUFJb0JaLElBQWdCcEIsQ0FBaEJvQixFQUF5QnpxQyxDQUF6QnlxQyxDQUpwQlk7O1VBSUMxdUIsQ0FKRDB1QjtVQUlPWCxDQUpQVzs7TUFTTixJQUpBSixLQUFLbG5DLEVBQUxrbkMsR0FBVUQsRUFBU3Z1QyxhQUFUdXVDLENBQXVCcnVCLENBQXZCcXVCLEVBQTZCbEIsQ0FBN0JrQixDQUFWQyxFQUNBVixJQUFPZSxXQUFQZixHQUFxQlUsS0FBS2xuQyxFQUFMa25DLENBQVFNLE9BRDdCTixFQWhnQmUsTUFvZ0JYanJDLENBQUosRUFBeUI7UUFDdkIsSUFBTXVyQyxNQUFVTixLQUFLbG5DLEVBQUxrbkMsQ0FBUU0sT0FBeEI7WUFDTUMsTUFBYUQsSUFBUUUsVUFEM0I7UUFFQUQsSUFBV0UsTUFBWEYsSUFDQUQsSUFBUUksTUFBUkosK0JBQWtCQyxJQUFXSSxVQUE3QkwsRUFEQUM7OztNQUtGLE9BQXNDLFVBQTlCemlCLElBQU93aEIsSUFBT3NCLFFBQVB0QixFQUF1QixLQUFRVyxFQUFNMXJDLE1BQU4wckMsR0FBZUcsQ0FBN0QsR0FBd0U7UUFDdEUsSUFBc0IsTUFBbEJ0aUIsRUFBSytpQixRQUFULEVBQXlCO1VBdUJ2QixJQUFLL2lCLEVBQWlCZ2pCLGFBQWpCaGpCLEVBQUwsRUFBdUM7WUFJckMsSUFBTWlqQixNQUFnQixFQUF0Qjs7WUFKcUMsMkNBS2pCampCLEVBQWlCa2pCLGlCQUFqQmxqQixFQUxpQjs7O1lBQUE7Y0FLckM7Z0JBQUEsSUFBVzlvQixHQUFYOztnQkFRRSxJQUNFQSxJQUFLaVksUUFBTGpZLENBeHBCZSxPQXdwQmZBLEtBQ0FBLElBQUsyWSxVQUFMM1ksQ0FBZ0Jzb0MsR0FBaEJ0b0MsQ0FGRixFQUdFO2tCQUNBLElBQU1pc0MsTUFBV3hCLEVBQVVVLEdBQVZWLENBQWpCOztrQkFFQSxJQURBc0IsSUFBY3p0QyxJQUFkeXRDLENBQW1CL3JDLEdBQW5CK3JDLEdBQW1CL3JDLEtBQ0Y3QixDQURFNkIsS0FDZmlzQyxHQUFKLEVBQTRCO29CQUUxQixJQUdNQyxNQUhTcGpCLEVBQWlCcWpCLFlBQWpCcmpCLENBQ2JtakIsSUFBU2p6QixXQUFUaXpCLEtBaHFCVyxPQStwQkVuakIsRUFHT2pxQixLQUhQaXFCLENBR2F3ZixHQUhieGYsQ0FBZjt3QkFJTXBYLE1BQUksZUFBZWhXLElBQWYsQ0FBb0J1d0MsR0FBcEIsQ0FKVjs7b0JBS0FoQixFQUFNM3NDLElBQU4yc0MsQ0FBVztzQkFDVGxyQyxNQXpqQkssQ0F3akJJO3NCQUVUNEQsT0FBT3VuQyxDQUZFO3NCQUdUbHJDLE1BQU0wUixJQUFFLENBQUZBLENBSEc7c0JBSVQwM0IsU0FBUzhDLEdBSkE7c0JBS1Q5SCxNQUNXLFFBQVQxeUIsSUFBRSxDQUFGQSxDQUFTLEdBQ0wwNkIsR0FESyxHQUVJLFFBQVQxNkIsSUFBRSxDQUFGQSxDQUFTLEdBQ1QyNkIsR0FEUyxHQUVBLFFBQVQzNkIsSUFBRSxDQUFGQSxDQUFTLEdBQ1Q0NkIsR0FEUyxHQUVUQztxQkFaUnRCO21CQVBGLE1Bc0JFQSxFQUFNM3NDLElBQU4yc0MsQ0FBVztvQkFDVGxyQyxNQW5rQkcsQ0Fra0JNO29CQUVUNEQsT0FBT3VuQzttQkFGVEQ7Ozs7Y0F6QytCOztjQUFBOzs7WUFnRHJDLHdCQUFtQmMsR0FBbkI7Y0FBSyxJQUFNL3JDLGNBQU47Y0FDRjhvQixFQUFpQjBqQixlQUFqQjFqQixDQUFpQzlvQixHQUFqQzhvQjs7OztVQUtMLElBQUlxZ0IsSUFBZWg5QixJQUFmZzlCLENBQXFCcmdCLEVBQWlCMmpCLE9BQXRDdEQsQ0FBSixFQUFvRDtZQUlsRCxJQUFNQyxNQUFXdGdCLEVBQWlCNGpCLFdBQWpCNWpCLENBQThCanFCLEtBQTlCaXFCLENBQW9Dd2YsR0FBcEN4ZixDQUFqQjtnQkFDTTVILE1BQVlrb0IsSUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBRG5DOztZQUVBLElBQUlsb0IsTUFBWSxDQUFoQixFQUFtQjtjQUNoQjRILEVBQWlCNGpCLFdBQWpCNWpCLEdBQStCcWYsTUFDM0JBLElBQWF3RSxXQURjeEUsR0FFNUIsRUFGSHJmOztjQVFELEtBQUssSUFBSW5uQixNQUFJLENBQWIsRUFBZ0JBLE1BQUl1ZixHQUFwQixFQUErQnZmLEtBQS9CO2dCQUNHbW5CLEVBQWlCNGlCLE1BQWpCNWlCLENBQXdCc2dCLElBQVF6bkMsR0FBUnluQyxDQUF4QnRnQixFQUFvQzJmLEtBQXBDM2YsR0FFRHdoQixJQUFPc0IsUUFBUHRCLEVBRkN4aEIsRUFHRG1pQixFQUFNM3NDLElBQU4yc0MsQ0FBVztrQkFBQ2xyQyxNQXRtQlAsQ0FzbUJNO2tCQUFtQjRELFNBQVN1bkM7aUJBQXZDRCxDQUhDbmlCOzs7Y0FRRkEsRUFBaUI0aUIsTUFBakI1aUIsQ0FBd0JzZ0IsSUFBUWxvQixHQUFSa29CLENBQXhCdGdCLEVBQTRDMmYsS0FBNUMzZjs7O1NBckdQLE1Bd0dPLElBQXNCLE1BQWxCQSxFQUFLK2lCLFFBQVQsRUFFTCxJQURjL2lCLEVBQWlCblksSUFBakJtWSxLQUNEeWYsR0FBYixFQUNFMEMsRUFBTTNzQyxJQUFOMnNDLENBQVc7VUFBQ2xyQyxNQWpuQkgsQ0FpbkJFO1VBQW1CNEQsT0FBT3VuQztTQUFyQ0QsRUFERixLQUVPO1VBQ0wsSUFBSXRwQyxPQUFLLENBQVQ7O1VBQ0EsUUFBZ0UsQ0FBaEUsTUFBUUEsTUFBS21uQixFQUFpQm5ZLElBQWpCbVksQ0FBc0J0USxPQUF0QnNRLENBQThCd2YsR0FBOUJ4ZixFQUFzQ25uQixNQUFJLENBQTFDbW5CLENBQWI7WUFHRW1pQixFQUFNM3NDLElBQU4yc0MsQ0FBVztjQUFDbHJDLE1BbG5CSCxDQWtuQkU7Y0FBcUI0RCxPQUFPdW5DO2FBQXZDRCxHQUVBdHBDLE9BQUsybUMsSUFBTy9vQyxNQUFQK29DLEdBQWdCLENBRnJCMkM7Ozs7UUFNTkM7Ozs7OzthQWFKMEIsdUJBQXFCbHdCLENBQXJCa3dCLEVBQXdDQyxDQUF4Q0QsRUFBd0NDO1FBQ3RDLElBQU0vb0MsSUFBSzRXLElBQUVsZSxhQUFGa2UsQ0FBZ0IsVUFBaEJBLENBQVg7UUFFQSxPQURBNVcsRUFBR2dwQyxTQUFIaHBDLEdBQWU0WSxDQUFmNVksRUFDT0EsQ0FBUDs7Ozs7OztFQWlCSixTQUFTaXBDLEdBQVQsQ0FDRS9DLENBREYsRUFFRXpzQyxDQUZGLEVBSUV5dkM7SUFBQUEsSUFEQXprQixDQUNBeWtCLHVFQUQwQmhELENBQzFCZ0Q7SUFBQUE7SUFBQUE7SUFJQSxJQUFJenZDLE1BQVVnc0MsR0FBZCxFQUNFLE9BQU9oc0MsQ0FBUDtJQUVGLElBQUkwdkMsU0FDaUI5dUMsQ0FEakI4dUMsS0FDRkQsQ0FERUMsR0FFd0MsVUFBckMvZ0IsTUFBeUJnaEIsSUFBWSxLQUFaQSxLQUFZLENBQVpBLEtBQVloaEIsZUFBRzhnQixDQUFIOWdCLENBRnhDK2dCLEdBR0cxa0IsRUFBK0M0a0IsSUFIdEQ7SUFJQSxJQUFNQyxJQUEyQnpFLElBQVlwckMsQ0FBWm9yQyxJQUFZcHJDLEtBQ3pDWSxDQUQ2QndxQyxHQUc1QnByQyxFQUEyQzh2QyxlQUhoRDtJQTRCQSxRQXhCSUosaUJBQWdCLENBQWhCQSxLQUFrQnRpQyxXQXdCdEIsTUF4QnNDeWlDLENBd0J0QyxLQXRCRSwrQkFBZ0IsQ0FBaEJILEtBQXVESyxJQUF2RCxLQUF1RCxLQUF2RCxDQUF1RCxLQUF2RGhhLGdCQUEyRCxDQUEzREEsR0FBMkQsS0FDMUJuMUIsQ0FEMEIsS0FDdkRpdkMsQ0FEdUQsR0FFekRILFNBQW1COXVDLENBRnNDLElBSXpEOHVDLElBQW1CLElBQUlHLENBQUosQ0FBNkJwRCxDQUE3QixDQUFuQmlELEVBQ0FBLEVBQWlCTSxJQUFqQk4sQ0FBOEJqRCxDQUE5QmlELEVBQW9DMWtCLENBQXBDMGtCLEVBQTRDRCxDQUE1Q0MsQ0FMeUQsQ0FBM0QsRUFLOENELEtBRXZCN3VDLENBRnVCNnVDLEtBRTFDQSxDQUYwQ0EsR0FFMUNBLENBQ3lCLFVBQXpCamlCLFlBQXlCbWlCLHFDQUFpQixFQUQxQ0YsRUFDOENBLENBRDlDQSxJQUVBQyxDQUowQ0QsR0FNM0N6a0IsRUFBaUM0a0IsSUFBakM1a0IsR0FBK0Mwa0IsQ0FXcEQsR0FYb0RBLEtBRzNCOXVDLENBSDJCOHVDLEtBR2hEQSxDQUhnREEsS0FJbEQxdkMsSUFBUXd2QyxJQUNOL0MsQ0FETStDLEVBRU5FLEVBQWlCTyxJQUFqQlAsQ0FBMkJqRCxDQUEzQmlELEVBQWtDMXZDLEVBQTBCbVosTUFBNUR1MkIsQ0FGTUYsRUFHTkUsQ0FITUYsRUFJTkMsQ0FKTUQsQ0FKMENFLENBV3BELEVBQU8xdkMsQ0FBUDtFQU9GOztNQUFNa3dDO0lBV0o5aUMsV0FBWStpQyxDQUFaL2lDLEVBQWdDNGQsQ0FBaEM1ZCxFQUFnQzRkO01BQUFBOztNQVBoQ3lpQixLQUFNMkMsQ0FBTjNDLEdBQWtDLEVBQWxDQSxFQUtBQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQUxqRDZzQyxFQVFFQSxLQUFLNkMsSUFBTDdDLEdBQWtCMEMsQ0FScEIxQyxFQVNFQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBVGxCeWlCOzs7OztXQWFJK0M7UUFDRixPQUFPL0MsS0FBSzhDLElBQUw5QyxDQUFjK0MsVUFBckI7Ozs7V0FJRUM7UUFDRixPQUFPaEQsS0FBSzhDLElBQUw5QyxDQUFjZ0QsSUFBckI7Ozs7YUFLRkMsV0FBT3BFLENBQVBvRSxFQUFPcEU7UUFBQUE7UUFDTCxpQkFHSW1CLEtBQUs2QyxJQUhUO1lBQ092QyxDQURQLGNBQ0V4bkMsRUFERixDQUNNd25DLE9BRE47WUFFU0wsQ0FGVCxjQUVFQSxLQUZGO1lBSU1pRCxDQUpOLEdBSU1BLENBQXNDLFVBQTFCaGlCLDJCQUFTaWlCLGFBQWlCLEtBQWpCQSxLQUFpQixDQUFqQkEsS0FBaUJqaUIsV0FBdENnaUIsRUFBeUNFLFVBQXpDRixDQUFvRDVDLENBQXBENEMsRUFBb0Q1QyxDQUFTLENBQTdENEMsQ0FKTjtRQUtBNUQsSUFBT2UsV0FBUGYsR0FBcUI0RCxDQUFyQjVEO1FBRUEsSUFBSXhoQixJQUFPd2hCLElBQU9zQixRQUFQdEIsRUFBWDtZQUNJWSxJQUFZLENBRGhCO1lBRUltRCxJQUFZLENBRmhCO1lBR0lDLElBQWVyRCxFQUFNLENBQU5BLENBSG5COztRQUtBLFlBQXdCOXNDLENBQXhCLEtBQU9td0MsQ0FBUCxHQUFtQztVQUNqQyxJQUFJcEQsTUFBY29ELEVBQWEzcUMsS0FBL0IsRUFBc0M7WUFDcEMsSUFBSXFtQyxZQUFKOztZQTN2QlcsTUE0dkJQc0UsRUFBYXZ1QyxJQTV2Qk4sR0E2dkJUaXFDLE1BQU8sSUFBSUcsR0FBSixDQUNMcmhCLENBREssRUFFTEEsRUFBS3lsQixXQUZBLEVBR0x2RCxJQUhLLEVBSUxuQixDQUpLLENBN3ZCRSxHQURJLE1Bb3dCSnlFLEVBQWF2dUMsSUFwd0JULEdBcXdCYmlxQyxNQUFPLElBQUlzRSxFQUFhbEssSUFBakIsQ0FDTHRiLENBREssRUFFTHdsQixFQUFhdHVDLElBRlIsRUFHTHN1QyxFQUFhbEYsT0FIUixFQUlMNEIsSUFKSyxFQUtMbkIsQ0FMSyxDQXJ3Qk0sR0FLRixNQXV3QkZ5RSxFQUFhdnVDLElBdndCWCxLQXd3QlhpcUMsTUFBTyxJQUFJd0UsR0FBSixDQUFnQjFsQixDQUFoQixFQUFxQ2tpQixJQUFyQyxFQUEyQ25CLENBQTNDLENBeHdCSSxDQUpGLEVBOHdCWG1CLEtBQUsyQyxDQUFMM0MsQ0FBWTFzQyxJQUFaMHNDLENBQWlCaEIsR0FBakJnQixDQTl3QlcsRUErd0JYc0QsSUFBZXJELElBQVFvRCxDQUFScEQsQ0Evd0JKOzs7VUFpeEJUQyxPQUFjb0QsdUJBQWMzcUMsS0FBNUJ1bkMsTUFDRnBpQixJQUFPd2hCLElBQU9zQixRQUFQdEIsRUFBUHhoQixFQUNBb2lCLEdBRkVBOzs7UUFLTixPQUFPZ0QsQ0FBUDs7OzthQUdGTyxXQUFRLzNCLENBQVIrM0IsRUFBUS8zQjtRQUNOLElBQUkvVSxJQUFJLENBQVI7O1FBRE0rVSw0Q0FFYXMwQixLQUFLMkMsQ0FGbEJqM0I7OztRQUFBQTtVQUVOO1lBQUEsSUFBV3N6QixHQUFYO1lBQXdCMkQsS0FDVHh2QyxDQURTd3ZDLEtBQ2xCM0QsR0FEa0IyRCxLQUNsQjNELEtBU3NDN3JDLENBVHRDNnJDLEtBU0dBLElBQXVCWixPQVQxQlksSUFVQ0EsSUFBdUJLLElBQXZCTCxDQUFrQ3R6QixDQUFsQ3N6QixFQUEwQ0EsR0FBMUNBLEVBQWlFcm9DLENBQWpFcW9DLEdBSURyb0MsS0FBTXFvQyxJQUF1QlosT0FBdkJZLENBQWdDenFDLE1BQWhDeXFDLEdBQXlDLENBZC9DQSxJQWdCQUEsSUFBS0ssSUFBTEwsQ0FBZ0J0ekIsRUFBTy9VLENBQVArVSxDQUFoQnN6QixDQWpCa0IyRCxHQW9CdEJoc0MsR0FwQnNCZ3NDOzs7VUFGbEJqM0I7O1VBQUFBOzs7Ozs7OztNQXdFSnl6QjtJQTRDSngvQixXQUNFK2pDLENBREYvakMsRUFFRXUvQixDQUZGdi9CLEVBR0U0ZCxDQUhGNWQsRUFJRWsvQixDQUpGbC9CLEVBSUVrL0I7TUFBQUE7O01BQUFBO01BL0NPbUIsS0FBSWpyQyxJQUFKaXJDLEdBbDJCUSxDQWsyQlJBLEVBRVRBLEtBQWdCMkQsSUFBaEIzRCxHQUE0QnZCLEdBRm5CdUIsRUFpQ1RBLEtBQXdCNEMsSUFBeEI1QyxHQUF3QjRDLEtBQXlCenZDLENBakN4QzZzQyxFQWlEUEEsS0FBSzRELElBQUw1RCxHQUFtQjBELENBakRaMUQsRUFrRFBBLEtBQUs2RCxJQUFMN0QsR0FBaUJkLENBbERWYyxFQW1EUEEsS0FBSzhDLElBQUw5QyxHQUFnQnppQixDQW5EVHlpQixFQW9EUEEsS0FBS25CLE9BQUxtQixHQUFlbkIsQ0FwRFJtQixFQXdEUEEsS0FBSzhELElBQUw5RCxHQUF5QyxVQUFwQjllLHFCQUFPLENBQVAyZCxLQUFTa0YsV0FBVyxLQUFYQSxLQUFXLENBQVhBLEtBQVc3aUIsTUF4RGxDOGU7Ozs7O1dBdUJMZ0Q7UUFBQUE7UUFJRixPQUF1QyxVQUFoQzFhLElBQWUsVUFBZnBILFNBQUs0aEIsSUFBVSxLQUFWQSxLQUFVLENBQVZBLEtBQVU1aEIsbUJBQWlCLEtBQWpCOGhCLEtBQWlCLENBQWpCQSxLQUFpQjFhLGFBQUt3YixJQUE1Qzs7OztXQXNERWY7UUFDRixJQUFJQSxJQUF3Qi9DLEtBQUs0RCxJQUFMNUQsQ0FBa0IrQyxVQUE5QztRQUNBLElBQU14bEIsSUFBU3lpQixLQUFLOEMsSUFBcEI7UUFVQSxZQVJhM3ZDLENBUWIsS0FSRW9xQixDQVFGLElBUDBCLE9BQXhCd2xCLEVBQVdsQyxRQU9iLEtBRkVrQyxJQUFjeGxCLEVBQXdDd2xCLFVBRXhELEdBQU9BLENBQVA7Ozs7V0FPRVc7UUFDRixPQUFPMUQsS0FBSzRELElBQVo7Ozs7V0FPRTFFO1FBQ0YsT0FBT2MsS0FBSzZELElBQVo7Ozs7YUFHRnhFLGNBQVc5c0MsQ0FBWDhzQyxFQUE4RFc7UUFBQUEsSUFBbkNnRSxDQUFtQ2hFO1FBTTVEenRDLElBQVF3dkMsSUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDLEVBQThCaUMsQ0FBOUJqQyxDQUFSeHZDLEVBQ0lvckMsSUFBWXByQyxDQUFab3JDLElBSUVwckMsTUFBVWtzQyxHQUFWbHNDLElBQThCLFFBQVRBLENBQXJCQSxJQUFnRCxPQUFWQSxDQUF0Q0EsSUFDRXl0QyxLQUFLMkQsSUFBTDNELEtBQTBCdkIsR0FBMUJ1QixJQVFGQSxLQUFLaUUsSUFBTGpFLEVBUkVBLEVBVUpBLEtBQUsyRCxJQUFMM0QsR0FBd0J2QixHQVh0QmxzQyxJQVlPQSxNQUFVeXRDLEtBQUsyRCxJQUFmcHhDLElBQW1DQSxNQUFVZ3NDLEdBQTdDaHNDLElBQ1R5dEMsS0FBS2tFLENBQUxsRSxDQUFpQnp0QyxDQUFqQnl0QyxDQWpCQXJDLEdBaUJpQnByQyxLQUdrQ1ksQ0FIbENaLEtBR1RBLEVBQXFDOHJDLFVBSDVCOXJDLEdBSW5CeXRDLEtBQUttRSxDQUFMbkUsQ0FBMkJ6dEMsQ0FBM0J5dEMsQ0FKbUJ6dEMsR0FJUUEsS0FDV1ksQ0FEWFosS0FDakJBLEVBQWVzdUMsUUFERXR1QyxHQUUzQnl0QyxLQUFLb0UsQ0FBTHBFLENBQWlCenRDLENBQWpCeXRDLENBRjJCenRDLEdBR2xCcXJDLElBQVdyckMsQ0FBWHFyQyxJQUNUb0MsS0FBS3FFLENBQUxyRSxDQUFxQnp0QyxDQUFyQnl0QyxDQURTcEMsR0FJVG9DLEtBQUtrRSxDQUFMbEUsQ0FBaUJ6dEMsQ0FBakJ5dEMsQ0E3QkZ6dEM7Ozs7YUFpQ00reEMsV0FBd0J4bUIsQ0FBeEJ3bUIsRUFBNENUO1FBQUFBLElBQVhVLENBQVdWLHVFQUFMN0QsS0FBSzZEO1FBQ2xELE9BQWlCN0QsS0FBSzRELElBQUw1RCxDQUFrQitDLFVBQWxCL0MsQ0FBK0JaLFlBQS9CWSxDQUE0Q2xpQixDQUE1Q2tpQixFQUFrRHVFLENBQWxEdkUsQ0FBakI7Ozs7YUFHTW9FLFdBQVk3eEMsQ0FBWjZ4QyxFQUFZN3hDO1FBQ2R5dEMsS0FBSzJELElBQUwzRCxLQUEwQnp0QyxDQUExQnl0QyxLQUNGQSxLQUFLaUUsSUFBTGpFLElBbUNBQSxLQUFLMkQsSUFBTDNELEdBQXdCQSxLQUFLc0UsQ0FBTHRFLENBQWF6dEMsQ0FBYnl0QyxDQXBDdEJBOzs7O2FBd0NFa0UsV0FBWTN4QyxDQUFaMnhDLEVBQVkzeEM7UUFLaEJ5dEMsS0FBSzJELElBQUwzRCxLQUEwQnZCLEdBQTFCdUIsSUFDQXJDLElBQVlxQyxLQUFLMkQsSUFBakJoRyxDQURBcUMsR0FHa0JBLEtBQUs0RCxJQUFMNUQsQ0FBa0J1RCxXQUFsQnZELENBYUhyNkIsSUFiR3E2QixHQWFJenRDLENBaEJ0Qnl0QyxHQXFDRUEsS0FBS29FLENBQUxwRSxDQUFpQnR3QixJQUFFcU8sY0FBRnJPLENBQWlCbmQsQ0FBakJtZCxDQUFqQnN3QixDQXJDRkEsRUE4Q0ZBLEtBQUsyRCxJQUFMM0QsR0FBd0J6dEMsQ0E5Q3RCeXRDOzs7O2FBaURJbUUsV0FDTjVxQyxDQURNNHFDLEVBQ041cUM7UUFBQUE7UUFHQSxJQUFPbVMsQ0FBUCxHQUF1Q25TLENBQXZDLENBQU1tUyxNQUFOO1lBQStCM1csQ0FBL0IsR0FBdUN3RSxDQUF2QyxDQUFlOGtDLFVBQWY7WUFLTXFFLENBTE4sR0FNa0IsbUJBQVQzdEMsQ0FBUyxHQUNaaXJDLEtBQUt3RSxJQUFMeEUsQ0FBbUJ6bUMsQ0FBbkJ5bUMsQ0FEWSxJQUNPem1DLEtBQ05wRyxDQURNb0csS0FDbEJ4RSxFQUFLK0QsRUFEYVMsS0FFaEJ4RSxFQUFLK0QsRUFBTC9ELEdBQVVnckMsSUFBU3Z1QyxhQUFUdXVDLENBQXVCaHJDLEVBQUswdkMsQ0FBNUIxRSxFQUErQkMsS0FBS25CLE9BQXBDa0IsQ0FGTXhtQyxHQUduQnhFLENBSlksQ0FObEI7UUFZQSxLQUFpRCxjQUE1Q2lyQyxLQUFLMkQsSUFBdUMsS0FBdkNBLEtBQXVDLENBQXZDQSxLQUF1Q3ppQixtQkFBakQsTUFBZ0V3aEIsQ0FBaEUsRUFTRzFDLEtBQUsyRCxJQUFMM0QsQ0FBMkN5RCxDQUEzQ3pELENBQW1EdDBCLENBQW5EczBCLEVBVEgsS0FVTztVQUNMLElBQU12YyxNQUFXLElBQUlnZixHQUFKLENBQXFCQyxDQUFyQixFQUEyQzFDLElBQTNDLENBQWpCO2NBQ01rRCxNQUFXemYsSUFBU3dmLENBQVR4ZixDQUFnQnVjLEtBQUtuQixPQUFyQnBiLENBRGpCOztVQVdBQSxJQUFTZ2dCLENBQVRoZ0IsQ0FBaUIvWCxDQUFqQitYLEdBVUF1YyxLQUFLb0UsQ0FBTHBFLENBQWlCa0QsR0FBakJsRCxDQVZBdmMsRUFXQXVjLEtBQUsyRCxJQUFMM0QsR0FBd0J2YyxHQVh4QkE7Ozs7O2FBaUJKK2dCLGNBQWNqckMsQ0FBZGlyQyxFQUFjanJDO1FBQ1osSUFBSW1wQyxJQUFXaEUsSUFBYzN0QyxHQUFkMnRDLENBQWtCbmxDLEVBQU82a0MsT0FBekJNLENBQWY7UUFJQSxZQUhpQnZyQyxDQUdqQixLQUhJdXZDLENBR0osSUFGRWhFLElBQWNsZ0MsR0FBZGtnQyxDQUFrQm5sQyxFQUFPNmtDLE9BQXpCTSxFQUFtQ2dFLElBQVcsSUFBSTNDLEdBQUosQ0FBYXhtQyxDQUFiLENBQTlDbWxDLENBRUYsRUFBT2dFLENBQVA7Ozs7YUFHTTJCLFdBQWdCOXhDLENBQWhCOHhDLEVBQWdCOXhDO1FBV2pCNEgsSUFBUTZsQyxLQUFLMkQsSUFBYnhwQyxNQUNINmxDLEtBQUsyRCxJQUFMM0QsR0FBd0IsRUFBeEJBLEVBQ0FBLEtBQUtpRSxJQUFMakUsRUFGRzdsQztRQU9MLElBQU11cUMsSUFBWTFFLEtBQUsyRCxJQUF2QjtRQUNBLElBQ0lnQixDQURKO1lBQUl0QixJQUFZLENBQWhCOztRQW5Cc0I5d0MsNENBc0JIQSxDQXRCR0E7OztRQUFBQTtVQXNCdEI7WUFBQSxJQUFXcXlDLEdBQVg7WUFDTXZCLE1BQWNxQixFQUFVbndDLE1BQXhCOHVDLEdBS0ZxQixFQUFVcHhDLElBQVZveEMsQ0FDR0MsSUFBVyxJQUFJeEYsQ0FBSixDQUNWYSxLQUFLc0UsQ0FBTHRFLENBQWF2QyxLQUFidUMsQ0FEVSxFQUVWQSxLQUFLc0UsQ0FBTHRFLENBQWF2QyxLQUFidUMsQ0FGVSxFQUdWQSxJQUhVLEVBSVZBLEtBQUtuQixPQUpLLENBRGQ2RixDQUxFckIsR0FlRnNCLElBQVdELEVBQVVyQixDQUFWcUIsQ0FmVHJCLEVBaUJKc0IsRUFBU3RGLElBQVRzRixDQUFvQkMsR0FBcEJELENBakJJdEIsRUFrQkpBLEdBbEJJQTs7O1VBdkJnQjl3Qzs7VUFBQUE7OztRQTRDbEI4d0MsSUFBWXFCLEVBQVVud0MsTUFBdEI4dUMsS0FFRnJELEtBQUtpRSxJQUFMakUsQ0FDRTJFLEtBQWlCQSxFQUFTZCxJQUFUYyxDQUFxQnBCLFdBRHhDdkQsRUFFRXFELENBRkZyRCxHQUtBMEUsRUFBVW53QyxNQUFWbXdDLEdBQW1CckIsQ0FQakJBOzs7O2FBc0JOWSxnQkFFRXZ6QjtRQUFBQSxJQURBbUIsQ0FDQW5CLHVFQUQrQnN2QixLQUFLNEQsSUFBTDVELENBQWtCdUQsV0FDakQ3eUI7UUFBQUE7UUFBQUE7O1FBR0EsS0FEOEIsVUFBOUJ3USxTQUFLMmpCLElBQXlCLEtBQXpCQSxLQUF5QixDQUF6QkEsS0FBeUIzakIsWUFBOUI4ZSxJQUE4QjllLEVBQTlCOGUsQ0FBaUMsQ0FBSDllLEVBQUcsQ0FBTyxDQUFWQSxFQUFnQnhRLENBQWhCd1EsQ0FDOUIsRUFBT3JQLEtBQVNBLE1BQVVtdUIsS0FBSzZELElBQS9CLEdBQTBDO1VBQ3hDLElBQU05aEMsT0FBUzhQLEVBQVEweEIsV0FBdkI7VUFDTTF4QixFQUFvQjR1QixNQUFwQjV1QixJQUNOQSxJQUFROVAsSUFERjhQOzs7OzthQVdWaXpCLHNCQUFhZixDQUFiZSxFQUFhZjtRQUFBQTtRQUFBQSxLQUNXNXdDLENBRFg0d0MsS0FDUC9ELEtBQUs4QyxJQURFaUIsS0FFVC9ELEtBQUs4RCxJQUFMOUQsR0FBcUIrRCxDQUFyQi9ELEVBQzhCLFVBQTlCOWUsU0FBSzJqQixJQUF5QixLQUF6QkEsS0FBeUIsQ0FBekJBLEtBQXlCM2pCLFlBQTlCOGUsSUFBOEI5ZSxFQUFHNmlCLENBQUg3aUIsQ0FIckI2aUI7Ozs7Ozs7TUFxQ1R4QztJQW9DSjVoQyxXQUNFd3pCLENBREZ4ekIsRUFFRTNLLENBRkYySyxFQUdFeStCLENBSEZ6K0IsRUFJRTRkLENBSkY1ZCxFQUtFay9CLENBTEZsL0IsRUFLRWsvQjtNQUFBQTs7TUF4Q09tQixLQUFJanJDLElBQUppckMsR0F0eENZLENBc3hDWkEsRUFnQlRBLEtBQWdCMkQsSUFBaEIzRCxHQUE2Q3ZCLEdBaEJwQ3VCLEVBc0JUQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQXRCeEM2c0MsRUEwQ1BBLEtBQUs3TSxPQUFMNk0sR0FBZTdNLENBMUNSNk0sRUEyQ1BBLEtBQUtockMsSUFBTGdyQyxHQUFZaHJDLENBM0NMZ3JDLEVBNENQQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBNUNUeWlCLEVBNkNQQSxLQUFLbkIsT0FBTG1CLEdBQWVuQixDQTdDUm1CLEVBOENINUIsRUFBUTdwQyxNQUFSNnBDLEdBQWlCLENBQWpCQSxJQUFxQyxPQUFmQSxFQUFRLENBQVJBLENBQXRCQSxJQUEwRCxPQUFmQSxFQUFRLENBQVJBLENBQTNDQSxJQUNGNEIsS0FBSzJELElBQUwzRCxHQUE0QjlsQyxNQUFNa2tDLEVBQVE3cEMsTUFBUjZwQyxHQUFpQixDQUF2QmxrQyxFQUEwQm1hLElBQTFCbmEsQ0FBK0IsSUFBSTlGLE1BQUosRUFBL0I4RixDQUE1QjhsQyxFQUNBQSxLQUFLNUIsT0FBTDRCLEdBQWU1QixDQUZiQSxJQUlGNEIsS0FBSzJELElBQUwzRCxHQUF3QnZCLEdBbERuQnVCOzs7OztXQTBCTHlCO1FBQ0YsT0FBT3pCLEtBQUs3TSxPQUFMNk0sQ0FBYXlCLE9BQXBCOzs7O1dBSUV1QjtRQUNGLE9BQU9oRCxLQUFLOEMsSUFBTDlDLENBQWNnRCxJQUFyQjs7OzthQStDRjNELGNBQ0U5c0MsQ0FERjhzQyxFQUlFMEY7UUFBQUEsSUFGQWYsQ0FFQWUsdUVBRm1DL0UsSUFFbkMrRTtRQUFBQSxJQURBQyxDQUNBRDtRQUFBQTtRQUVBLElBQU0zRyxJQUFVNEIsS0FBSzVCLE9BQXJCO1FBR0EsSUFBSTZHLEtBQVMsQ0FBYjtRQUVBLFNBQWdCOXhDLENBQWhCLEtBQUlpckMsQ0FBSixFQUVFN3JDLElBQVF3dkMsSUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDLEVBQThCaUMsQ0FBOUJqQyxFQUErQyxDQUEvQ0EsQ0FBUnh2QyxFQUNBMHlDLEtBQ0d0SCxJQUFZcHJDLENBQVpvckMsQ0FESHNILElBRUcxeUMsTUFBVXl0QyxLQUFLMkQsSUFBZnB4QyxJQUFtQ0EsTUFBVWdzQyxHQUhoRGhzQyxFQUlJMHlDLE1BQ0ZqRixLQUFLMkQsSUFBTDNELEdBQXdCenRDLENBRHRCMHlDLENBSkoxeUMsQ0FGRixLQVNPO1VBRUwsSUFBTW1aLEtBQVNuWixDQUFmOztVQUdBLElBQUlvRSxFQUFKLEVBQU8rbkIsRUFBUDs7VUFDQSxLQUhBbnNCLElBQVE2ckMsRUFBUSxDQUFSQSxDQUFSN3JDLEVBR0tvRSxLQUFJLENBQVQsRUFBWUEsS0FBSXluQyxFQUFRN3BDLE1BQVI2cEMsR0FBaUIsQ0FBakMsRUFBb0N6bkMsSUFBcEM7WUFDRStuQixLQUFJcWpCLElBQWlCL0IsSUFBakIrQixFQUF1QnIyQixHQUFPczVCLElBQWNydUMsRUFBckIrVSxDQUF2QnEyQixFQUFnRGlDLENBQWhEakMsRUFBaUVwckMsRUFBakVvckMsQ0FBSnJqQixFQUVJQSxPQUFNNmYsR0FBTjdmLEtBRUZBLEtBQUtzaEIsS0FBSzJELElBQUwzRCxDQUF5Q3JwQyxFQUF6Q3FwQyxDQUZIdGhCLENBRkpBLEVBTUF1bUIsV0FDR3RILElBQVlqZixFQUFaaWYsQ0FESHNILElBQ3FCdm1CLE9BQU9zaEIsS0FBSzJELElBQUwzRCxDQUF5Q3JwQyxFQUF6Q3FwQyxDQUQ1QmlGLENBTkF2bUIsRUFRSUEsT0FBTStmLEdBQU4vZixHQUNGbnNCLElBQVFrc0MsR0FETi9mLEdBRU9uc0IsTUFBVWtzQyxHQUFWbHNDLEtBQ1RBLE1BQVVtc0Isa0JBQUssRUFBZm5zQixJQUFxQjZyQyxFQUFRem5DLEtBQUksQ0FBWnluQyxDQURaN3JDLENBVlhtc0IsRUFlQ3NoQixLQUFLMkQsSUFBTDNELENBQXlDcnBDLEVBQXpDcXBDLElBQThDdGhCLEVBZi9DQTs7O1FBa0JBdW1CLE1BQVdGLENBQVhFLElBQ0ZqRixLQUFLa0YsQ0FBTGxGLENBQWtCenRDLENBQWxCeXRDLENBREVpRjs7OzthQU1OQyxXQUFhM3lDLENBQWIyeUMsRUFBYTN5QztRQUNQQSxNQUFVa3NDLEdBQVZsc0MsR0FDSXl0QyxLQUFLN00sT0FBTDZNLENBQTBCd0IsZUFBMUJ4QixDQUEwQ0EsS0FBS2hyQyxJQUEvQ2dyQyxDQURKenRDLEdBb0JJeXRDLEtBQUs3TSxPQUFMNk0sQ0FBMEJtRixZQUExQm5GLENBQ0pBLEtBQUtockMsSUFERGdyQyxFQUVIenRDLGdCQUFTLEVBRk55dEMsQ0FwQkp6dEM7Ozs7Ozs7TUE2QkY2dUM7Ozs7O0lBQU56aEM7TUFBQUE7O01BQUFBOztNQUFBQSx1Q0FDb0JxZ0MsTUFBSWpyQyxJQUFKaXJDLEdBcjdDRSxDQW83Q3RCcmdDO01BQUFBOzs7OzthQUlXdWxDLFdBQWEzeUMsQ0FBYjJ5QyxFQUFhM3lDO1FBbUJuQnl0QyxLQUFLN00sT0FBTDZNLENBQXFCQSxLQUFLaHJDLElBQTFCZ3JDLElBQWtDenRDLE1BQVVrc0MsR0FBVmxzQyxHQUFVa3NDLEtBQVV0ckMsQ0FBcEJaLEdBQWdDQSxDQUFsRXl0Qzs7Ozs7SUF2QnNCdUI7O0VBK0IzQixJQUFNNkQsTUFBaUNqSSxNQUNsQ0EsSUFBYXdFLFdBRHFCeEUsR0FFbkMsRUFGSjs7TUFLTWtFOzs7OztJQUFOMWhDO01BQUFBOztNQUFBQTs7TUFBQUEseUNBQ29CcWdDLE9BQUlqckMsSUFBSmlyQyxHQXg5Q1csQ0F1OUMvQnJnQztNQUFBQTs7Ozs7YUFJV3VsQyxXQUFhM3lDLENBQWIyeUMsRUFBYTN5QztRQVFoQkEsS0FBU0EsTUFBVWtzQyxHQUFuQmxzQyxHQUNJeXRDLEtBQUs3TSxPQUFMNk0sQ0FBMEJtRixZQUExQm5GLENBQ0pBLEtBQUtockMsSUFERGdyQyxFQUVKb0YsR0FGSXBGLENBREp6dEMsR0FNSXl0QyxLQUFLN00sT0FBTDZNLENBQTBCd0IsZUFBMUJ4QixDQUEwQ0EsS0FBS2hyQyxJQUEvQ2dyQyxDQU5KenRDOzs7OztJQVoyQmd2Qzs7TUFzQzdCRDs7Ozs7SUFHSjNoQyxXQUNFd3pCLENBREZ4ekIsRUFFRTNLLENBRkYySyxFQUdFeStCLENBSEZ6K0IsRUFJRTRkLENBSkY1ZCxFQUtFay9CLENBTEZsL0IsRUFLRWsvQjtNQUFBQTs7TUFBQUE7O01BRUF3Ryw0QkFBTWxTLENBQU5rUyxFQUFlcndDLENBQWZxd0MsRUFBcUJqSCxDQUFyQmlILEVBQThCOW5CLENBQTlCOG5CLEVBQXNDeEcsQ0FBdEN3RyxHQVRnQnJGLE9BQUlqckMsSUFBSmlyQyxHQTcvQ0QsQ0FzZ0RmcUY7TUFGQXhHOzs7OzthQWdCT1EsY0FDUGlHLENBRE9qRyxFQUU0Qlc7UUFBQUEsSUFBbkNnRSxDQUFtQ2hFO1FBQUFBO1FBSW5DLEtBRkFzRixJQUM2RCxVQUEzRHBrQixRQUFpQjhlLElBQWpCK0IsRUFBdUJ1RCxDQUF2QnZELEVBQW9DaUMsQ0FBcENqQyxFQUFxRCxDQUFyREEsQ0FBMkQsS0FBTixLQUFNLENBQU4sS0FBTTdnQixXQUM3RCxNQUFvQnFkLEdBQXBCLEVBQ0U7UUFFRixJQUFNZ0gsSUFBY3ZGLEtBQUsyRCxJQUF6QjtZQUlNNkIsSUFDSEYsTUFBZ0I3RyxHQUFoQjZHLElBQTJCQyxNQUFnQjlHLEdBQTNDNkcsSUFDQUEsRUFBeUNqc0IsT0FBekNpc0IsS0FDRUMsRUFBeUNsc0IsT0FGM0Npc0IsSUFHQUEsRUFBeUNHLElBQXpDSCxLQUNFQyxFQUF5Q0UsSUFKM0NILElBS0FBLEVBQXlDSSxPQUF6Q0osS0FDRUMsRUFBeUNHLE9BWDlDO1lBZU1DLElBQ0pMLE1BQWdCN0csR0FBaEI2RyxLQUNDQyxNQUFnQjlHLEdBQWhCOEcsSUFBMkJDLENBRDVCRixDQWhCRjtRQTZCSUUsS0FDRnhGLEtBQUs3TSxPQUFMNk0sQ0FBYTRGLG1CQUFiNUYsQ0FDRUEsS0FBS2hyQyxJQURQZ3JDLEVBRUVBLElBRkZBLEVBR0V1RixDQUhGdkYsQ0FERXdGLEVBT0FHLEtBSUYzRixLQUFLN00sT0FBTDZNLENBQWF6akIsZ0JBQWJ5akIsQ0FDRUEsS0FBS2hyQyxJQURQZ3JDLEVBRUVBLElBRkZBLEVBR0VzRixDQUhGdEYsQ0FYRXdGLEVBaUJKeEYsS0FBSzJELElBQUwzRCxHQUF3QnNGLENBakJwQkU7Ozs7YUFvQk5LLHFCQUFZNXBCLENBQVo0cEIsRUFBWTVwQjtRQUFBQTtRQUMyQixxQkFBMUIrakIsS0FBSzJELElBQXFCLEdBQ25DM0QsS0FBSzJELElBQUwzRCxDQUFzQnZ2QyxJQUF0QnV2QyxDQUFzQnZ2QyxVQUFLNjNCLElBQWMsY0FBZDBYLEtBQUtuQixPQUFTLEtBQVRBLEtBQVMsQ0FBVEEsS0FBUzNkLG1CQUFuQnp3QixLQUFtQnExQyxZQUFuQnIxQyxHQUFtQnExQyxDQUFuQnIxQyxHQUEyQnV2QyxLQUFLN00sT0FBdEQ2TSxFQUErRC9qQixDQUEvRCtqQixDQURtQyxHQUdsQ0EsS0FBSzJELElBQUwzRCxDQUE4QzZGLFdBQTlDN0YsQ0FBMEQvakIsQ0FBMUQrakIsQ0FIa0M7Ozs7O0lBbkZqQnVCOztNQTRGbEJpQztJQWlCSjdqQyxXQUNTd3pCLENBRFR4ekIsRUFFRTRkLENBRkY1ZCxFQUdFay9CLENBSEZsL0IsRUFHRWsvQjtNQUFBQTs7TUFGT21CLEtBQU83TSxPQUFQNk0sTUFqQkFBLEtBQUlqckMsSUFBSmlyQyxHQXhsRFUsQ0F5bURWQSxFQUxUQSxLQUF3QjRDLElBQXhCNUMsR0FBd0I0QyxLQUF5Qnp2QyxDQUt4QzZzQyxFQUlQQSxLQUFLOEMsSUFBTDlDLEdBQWdCemlCLENBSlR5aUIsRUFLUEEsS0FBS25CLE9BQUxtQixHQUFlbkIsQ0FMUm1COzs7OztXQVNMZ0Q7UUFDRixPQUFPaEQsS0FBSzhDLElBQUw5QyxDQUFjZ0QsSUFBckI7Ozs7YUFHRjNELGNBQVc5c0MsQ0FBWDhzQyxFQUFXOXNDO1FBT1R3dkMsSUFBaUIvQixJQUFqQitCLEVBQXVCeHZDLENBQXZCd3ZDOzs7Ozs7O0VBc0JTLFFBQU87SUFFbEJrTCxHQXR3RDJCLE9Bb3dEVDtJQUdsQkMsR0FBUzVQLEdBSFM7SUFJbEI2UCxHQUFjNVAsR0FKSTtJQUtsQjZQLEdBcHFEa0IsQ0ErcERBO0lBTWxCQyxHQUFrQjdOLEdBTkE7SUFRbEI4TixHQUFtQjdLLEdBUkQ7SUFTbEI4SyxHQUFhM1AsR0FUSztJQVVsQjRQLEdBQW1CekwsR0FWRDtJQVlsQjBMLEdBQVl0TyxHQVpNO0lBYWxCdU8sR0FBZ0JuTSxHQWJFO0lBY2xCb00sR0FBdUJ0TSxHQWRMO0lBZWxCdU0sR0FBWXRNLEdBZk07SUFnQmxCdU0sR0FBZXpNLEdBaEJHO0lBaUJsQjBNLEdBQWN0SztFQWpCSSxDQUFQO0VBQUEsSUFxQlB1QyxNQUVGOTFDLE9BQU8rMUMsc0JBdkJFO0VBd0JiRCxtQkFBa0JoRyxHQUFsQmdHLEVBQTRCNUcsR0FBNUI0RyxHQUE0QjVHLENBSUQsVUFBM0I5ZCxNQUFDc2IsV0FBV3NKLGVBQWUsS0FBZkEsS0FBZSxDQUFmQSxLQUFlNWtCLFlBQTFCc2IsV0FBV3NKLGVBQVh0SixHQUErQixFQUpKd0MsRUFJUTdyQyxJQUpSNnJDLENBSWEsT0FKYkEsQ0FBNUI0Rzs7Ozs7Ozs7OztNQ3ovRGFnSTs7Ozs7SUFBYnB1QztNQUFBQTs7TUFBQUE7O01BQUFBLHVDQWdCV3FnQyxzQkFBK0I7UUFBQzhGO09BaEIzQ25tQyxFQWtCVXFnQyxrQkFBb0M3c0MsQ0FsQjlDd007TUFBQUE7Ozs7O2FBdUJxQmlxQztRQUFBQTs7UUFDakIsSUFBTXhDLDJFQUFOOztRQU9BLDBCQURBcEgsS0FBS2dPLGFBQ0wsRUFEbUJqUCxZQUNuQixLQURtQkEsWUFDbkIsS0FEbUJBLGlCQUFpQnFJLEVBQVk1RyxVQUNoRCxHQUFPNEcsQ0FBUDs7OzthQVVpQnFFLGdCQUFPSCxDQUFQRyxFQUFPSDtRQUl4QixJQUFNLzRDLElBQVF5dEMsS0FBS3JCLE1BQUxxQixFQUFkO1FBQ0tBLEtBQUs0SSxVQUFMNUksS0FDSEEsS0FBS2dPLGFBQUxoTyxDQUFtQitELFdBQW5CL0QsR0FBaUNBLEtBQUsrRCxXQURuQy9ELGlFQUdRc0wsQ0FIUnRMLEdBSUxBLEtBQUtpTyxJQUFMak8sR0FBbUJyQixJQUFPcHNDLENBQVBvc0MsRUFBY3FCLEtBQUtvSCxVQUFuQnpJLEVBQStCcUIsS0FBS2dPLGFBQXBDclAsQ0FKZHFCOzs7O2FBMkJFaUs7UUFBQUE7UUFDUDVFLDBFQUFNNEUsY0FDTmpLLEtBQUtpTyxJQURDaEUsS0FDRGdFLFlBRENoRSxJQUNEZ0UsRUFBYW5KLFlBQWJtSixDQUFhbkosQ0FBYSxDQUExQm1KLENBREw1STs7OzthQXVCTzhFO1FBQUFBO1FBQ1A5RSw2RUFBTThFLGNBQ05uSyxLQUFLaU8sSUFEQzlELEtBQ0Q4RCxZQURDOUQsSUFDRDhELEVBQWFuSixZQUFibUosQ0FBYW5KLENBQWEsQ0FBMUJtSixDQURMNUk7Ozs7YUFXUTFHO1FBQ1IsT0FBT0osR0FBUDs7Ozs7SUE5RzRCbUs7O0FBUUpxRixNQUFZeEIsU0FBWndCLEdBQVksQ0FBSSxDQUFoQkEsRUFHbkJBLElBQWdCRyxhQUFoQkgsR0FBZ0IsQ0FBSSxDQUhEQSxFQUdDLGdCQXdHN0JwUixXQUFXd1Isd0JBeEdrQixLQXdHbEJBLGNBeEdrQixJQXdHbEJBLFNBQVh4UixVQUFXd1IsRUFBMkI7SUFBQ0o7RUFBRCxDQUEzQkksQ0EzR2lCSjtFQThHNUIsSUFBTWhJLE1BRUZwSixXQUFXeVIseUJBRmY7RUFHQXJJLG1CQUFrQjtJQUFDZ0k7RUFBRCxDQUFsQmhJO0FBQW1CZ0ksRUE0RG9DOUUsaUJBS3REdE0sV0FBVzBSLGtCQUwyQ3BGLEtBSzNDb0YsY0FMMkNwRixHQUszQ29GLEdBTDJDcEYsR0FLdER0TSxXQUFXMFIsa0JBQVgxUixHQUFrQyxFQUxvQnNNLEVBS2hCMzFDLElBTGdCMjFDLENBS1gsT0FMV0E7O0VDaFN2RDs7RUFFQSxJQUFJbDJDLElBQUUsR0FBRyxDQUFUO0VBRUEsSUFBTXU3Qyw0QkFBNEIsR0FBRyxJQUFJbHFCLEdBQUosRUFBckM7O01BRU1tcUI7Ozs7O0lBQ0oscUJBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtDLEtBQUwsYUFBZ0IsTUFBSzd1QyxXQUFMLENBQWlCM0ssSUFBakIsQ0FBc0JnWixXQUF0QixFQUFoQixjQUF1RGpiLElBQUUsRUFBekQ7TUFIWTs7Ozs7YUFNZCw2QkFBb0JwQyxDQUFwQixFQUF1QjtRQUNyQkEsQ0FBQyxDQUFDODlDLGNBQUY7Ozs7YUFHRix3Q0FBK0I7UUFDN0IsSUFBSUgsNEJBQTRCLENBQUM3L0IsSUFBN0IsS0FBc0MsQ0FBMUMsRUFBNkM7VUFDM0NuZCxRQUFRLENBQUNvOUMsSUFBVCxDQUFjNXpDLEtBQWQsQ0FBb0I2ekMsVUFBcEIsR0FBaUMsTUFBakM7OztRQUdGTCw0QkFBNEIsQ0FBQzlxQixHQUE3QixDQUFpQyxLQUFLZ3JCLEtBQXRDOzs7O2FBR0YsdUNBQThCO1FBQzVCRiw0QkFBNEIsQ0FBQ00sTUFBN0IsQ0FBb0MsS0FBS0osS0FBekM7O1FBRUEsSUFBSUYsNEJBQTRCLENBQUM3L0IsSUFBN0IsS0FBc0MsQ0FBMUMsRUFBNkM7VUFDM0NuZCxRQUFRLENBQUNvOUMsSUFBVCxDQUFjNXpDLEtBQWQsQ0FBb0I2ekMsVUFBcEIsR0FBaUMsTUFBakM7Ozs7OztJQXZCa0JaOzs7O01DVmxCYzs7Ozs7SUFpQ0osNkJBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtDLE1BQUwsR0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWQ7TUFDQSxNQUFLQyxNQUFMLEdBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFkO01BQ0EsTUFBS0MsY0FBTCxHQUFzQixLQUF0QjtNQUVBLE1BQUtDLGNBQUwsR0FBc0IsSUFBSWhyQixHQUFKLEVBQXRCO01BQ0EsTUFBS2lyQixVQUFMLEdBQWtCLEVBQWxCLENBUlk7O01BVVosTUFBS0MsU0FBTCxHQUFpQixNQUFLQSxTQUFMLENBQWVudEMsSUFBZiwrQkFBakI7TUFDQSxNQUFLb3RDLE9BQUwsR0FBZSxNQUFLQSxPQUFMLENBQWFwdEMsSUFBYiwrQkFBZjtNQUNBLE1BQUtxdEMsVUFBTCxHQUFrQixNQUFLQSxVQUFMLENBQWdCcnRDLElBQWhCLCtCQUFsQjtNQUNBLE1BQUtzdEMsU0FBTCxHQUFpQixNQUFLQSxTQUFMLENBQWV0dEMsSUFBZiwrQkFBakI7TUFDQSxNQUFLdXRDLFFBQUwsR0FBZ0IsTUFBS0EsUUFBTCxDQUFjdnRDLElBQWQsK0JBQWhCO01BRUEsTUFBS3d0QyxlQUFMLEdBQXVCLE1BQUtBLGVBQUwsQ0FBcUJ4dEMsSUFBckIsK0JBQXZCO01BQ0EsTUFBS3l0QyxLQUFMLEdBQWEsSUFBYjtNQWpCWTs7O0VBcUJoQjtFQUNBOzs7OzthQUNFLHlCQUFnQjtRQUFBOztRQUNkLElBQU1DLE1BQU0sR0FBRyxLQUFLWixNQUFMLENBQVksQ0FBWixJQUFpQixLQUFLQSxNQUFMLENBQVksQ0FBWixDQUFoQztRQUNBLElBQU1hLE1BQU0sR0FBRyxLQUFLWixNQUFMLENBQVksQ0FBWixJQUFpQixLQUFLQSxNQUFMLENBQVksQ0FBWixDQUFoQzs7UUFFQSxLQUFLYSxJQUFMLEdBQVksVUFBQzU4QyxFQUFELEVBQVE7VUFDbEIsSUFBSW5CLEdBQUcsR0FBR21CLEVBQUUsR0FBRyxNQUFJLENBQUM2OEMsS0FBVixHQUFrQkgsTUFBbEIsR0FBMkIsTUFBSSxDQUFDWixNQUFMLENBQVksQ0FBWixDQUFyQzs7VUFFQSxJQUFJLE1BQUksQ0FBQ0UsY0FBVCxFQUF5QjtZQUN2Qm45QyxHQUFHLEdBQUczQixJQUFJLENBQUNzSSxHQUFMLENBQVMsTUFBSSxDQUFDczJDLE1BQUwsQ0FBWSxDQUFaLENBQVQsRUFBeUI1K0MsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLE1BQUksQ0FBQ28yQyxNQUFMLENBQVksQ0FBWixDQUFULEVBQXlCajlDLEdBQXpCLENBQXpCLENBQU47OztVQUdGLE9BQU9BLEdBQVA7U0FQRjs7UUFVQSxLQUFLaStDLElBQUwsR0FBWSxVQUFDOThDLEVBQUQsRUFBUTtVQUNsQixJQUFJbkIsR0FBRyxHQUFHbUIsRUFBRSxHQUFHLE1BQUksQ0FBQys4QyxNQUFWLEdBQW1CSixNQUFuQixHQUE0QixNQUFJLENBQUNaLE1BQUwsQ0FBWSxDQUFaLENBQXRDOztVQUVBLElBQUksTUFBSSxDQUFDQyxjQUFULEVBQXlCO1lBQ3ZCbjlDLEdBQUcsR0FBRzNCLElBQUksQ0FBQ3NJLEdBQUwsQ0FBUyxNQUFJLENBQUN1MkMsTUFBTCxDQUFZLENBQVosQ0FBVCxFQUF5QjcrQyxJQUFJLENBQUN3SSxHQUFMLENBQVMsTUFBSSxDQUFDcTJDLE1BQUwsQ0FBWSxDQUFaLENBQVQsRUFBeUJsOUMsR0FBekIsQ0FBekIsQ0FBTjs7O1VBR0YsT0FBT0EsR0FBUDtTQVBGOztRQVVBOzs7O2FBR0Ysa0JBQVM7UUFDUCxPQUFPNmYsR0FBUCxxUEFFb0IsS0FBS20rQixLQUZ6QixFQUU2QyxLQUFLRSxNQUZsRCxFQUlrQixLQUFLQyxTQUp2QixFQUttQjtVQUNibkssV0FBVyxFQUFFLEtBQUt3SixVQURMO1VBRWIzSixPQUFPLEVBQUU7U0FQZixFQVNvQixLQUFLdUssbUJBVHpCOzs7O2FBY0YsbUJBQVV0L0MsQ0FBVixFQUFhO1FBQ1hWLE1BQU0sQ0FBQ3NzQixnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxLQUFLNHlCLFNBQTFDLEVBQXFEO1VBQUV6SixPQUFPLEVBQUU7U0FBaEU7UUFDQXoxQyxNQUFNLENBQUNzc0IsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsS0FBSzZ5QixPQUF4QztRQUVBLEtBQUtGLFVBQUwsQ0FBZ0I1N0MsSUFBaEIsQ0FBcUIsT0FBckI7UUFDQSxLQUFLMjdDLGNBQUwsQ0FBb0J6d0MsR0FBcEIsQ0FBd0IsT0FBeEIsRUFBaUM3TixDQUFqQzs7UUFFQSxLQUFLdS9DLDRCQUFMOztRQUVBLEtBQUtDLHNCQUFMLENBQTRCeC9DLENBQTVCOzs7O2FBR0YsbUJBQVVBLENBQVYsRUFBYTtRQUNYLEtBQUtzK0MsY0FBTCxDQUFvQnp3QyxHQUFwQixDQUF3QixPQUF4QixFQUFpQzdOLENBQWpDO1FBQ0EsS0FBS3cvQyxzQkFBTCxDQUE0QngvQyxDQUE1Qjs7OzthQUdGLGlCQUFRQSxDQUFSLEVBQVc7UUFDVFYsTUFBTSxDQUFDMjFDLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLEtBQUt1SixTQUE3QztRQUNBbC9DLE1BQU0sQ0FBQzIxQyxtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxLQUFLd0osT0FBM0M7UUFFQSxLQUFLRixVQUFMLENBQWdCdnFCLE1BQWhCLENBQXVCLEtBQUt1cUIsVUFBTCxDQUFnQjFoQyxPQUFoQixDQUF3QixPQUF4QixDQUF2QjtRQUNBLEtBQUt5aEMsY0FBTCxDQUFvQkwsTUFBcEIsQ0FBMkIsT0FBM0I7O1FBRUEsS0FBS3dCLDJCQUFMLEdBUFM7Ozs7UUFXVCxJQUFNbjBCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsWUFBaEIsRUFBOEI7VUFDMUNDLE9BQU8sRUFBRSxJQURpQztVQUUxQ0MsUUFBUSxFQUFFLElBRmdDO1VBRzFDQyxNQUFNLEVBQUU7WUFBRUMsU0FBUyxFQUFFOztTQUhULENBQWQ7UUFNQSxLQUFLQyxhQUFMLENBQW1CejBCLEtBQW5CO1FBRUEsS0FBS2swQixzQkFBTCxDQUE0QngvQyxDQUE1Qjs7OzthQUdGLG9CQUFXQSxDQUFYLEVBQWM7UUFDWkEsQ0FBQyxDQUFDODlDLGNBQUYsR0FEWTs7UUFHWixJQUFJLEtBQUtTLFVBQUwsQ0FBZ0IzNkMsTUFBaEIsS0FBMkIsQ0FBL0IsRUFBa0M7VUFDaEN0RSxNQUFNLENBQUNzc0IsZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsS0FBSyt5QixTQUExQyxFQUFxRDtZQUFFNUosT0FBTyxFQUFFO1dBQWhFO1VBQ0F6MUMsTUFBTSxDQUFDc3NCLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLEtBQUtnekIsUUFBekM7VUFDQXQvQyxNQUFNLENBQUNzc0IsZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUMsS0FBS2d6QixRQUE1Qzs7VUFFQSxLQUFLVyw0QkFBTDs7O1FBUlUsMkNBV012L0MsQ0FBQyxDQUFDZ2dELGNBWFI7OztRQUFBO1VBV1osb0RBQW9DO1lBQUEsSUFBM0JDLEtBQTJCO1lBQ2xDLElBQU03OUMsRUFBRSxHQUFHNjlDLEtBQUssQ0FBQ0MsVUFBakI7WUFDQSxLQUFLM0IsVUFBTCxDQUFnQjU3QyxJQUFoQixDQUFxQlAsRUFBckI7WUFDQSxLQUFLazhDLGNBQUwsQ0FBb0J6d0MsR0FBcEIsQ0FBd0J6TCxFQUF4QixFQUE0QjY5QyxLQUE1Qjs7O1VBZFU7O1VBQUE7OztRQWlCWixLQUFLVCxzQkFBTCxDQUE0QngvQyxDQUE1Qjs7OzthQUdGLG1CQUFVQSxDQUFWLEVBQWE7UUFDWEEsQ0FBQyxDQUFDODlDLGNBQUYsR0FEVzs7UUFBQSw0Q0FHTzk5QyxDQUFDLENBQUNnZ0QsY0FIVDs7O1FBQUE7VUFHWCx1REFBb0M7WUFBQSxJQUEzQkMsS0FBMkI7WUFDbEMsSUFBTTc5QyxFQUFFLEdBQUc2OUMsS0FBSyxDQUFDQyxVQUFqQixDQURrQzs7WUFHbEMsSUFBSSxLQUFLM0IsVUFBTCxDQUFnQjFoQyxPQUFoQixDQUF3QnphLEVBQXhCLE1BQWdDLENBQUMsQ0FBckMsRUFBd0M7Y0FDdEMsS0FBS2s4QyxjQUFMLENBQW9CendDLEdBQXBCLENBQXdCekwsRUFBeEIsRUFBNEI2OUMsS0FBNUI7Ozs7VUFQTzs7VUFBQTs7O1FBV1gsS0FBS1Qsc0JBQUwsQ0FBNEJ4L0MsQ0FBNUI7Ozs7YUFHRixrQkFBU0EsQ0FBVCxFQUFZO1FBQUEsNENBQ1FBLENBQUMsQ0FBQ2dnRCxjQURWOzs7UUFBQTtVQUNWLHVEQUFvQztZQUFBLElBQTNCQyxLQUEyQjtZQUNsQyxJQUFNSCxTQUFTLEdBQUdHLEtBQUssQ0FBQ0MsVUFBeEI7WUFDQSxJQUFNbDRDLEtBQUssR0FBRyxLQUFLdTJDLFVBQUwsQ0FBZ0IxaEMsT0FBaEIsQ0FBd0JpakMsU0FBeEIsQ0FBZCxDQUZrQzs7WUFJbEMsSUFBSTkzQyxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO2NBQ2hCLEtBQUt1MkMsVUFBTCxDQUFnQnZxQixNQUFoQixDQUF1QmhzQixLQUF2QixFQUE4QixDQUE5QjtjQUNBLEtBQUtzMkMsY0FBTCxDQUFvQkwsTUFBcEIsQ0FBMkI2QixTQUEzQixFQUZnQjs7O2NBTWhCLElBQU14MEIsS0FBSyxHQUFHLElBQUlvMEIsV0FBSixDQUFnQixZQUFoQixFQUE4QjtnQkFDMUNDLE9BQU8sRUFBRSxJQURpQztnQkFFMUNDLFFBQVEsRUFBRSxJQUZnQztnQkFHMUNDLE1BQU0sRUFBRTtrQkFBRUM7O2VBSEUsQ0FBZDtjQU1BLEtBQUtDLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7O1dBakJNOzs7VUFBQTs7VUFBQTs7O1FBc0JWLElBQUksS0FBS2l6QixVQUFMLENBQWdCMzZDLE1BQWhCLEtBQTJCLENBQS9CLEVBQWtDO1VBQ2hDdEUsTUFBTSxDQUFDMjFDLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLEtBQUswSixTQUE3QztVQUNBci9DLE1BQU0sQ0FBQzIxQyxtQkFBUCxDQUEyQixVQUEzQixFQUF1QyxLQUFLMkosUUFBNUM7VUFDQXQvQyxNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsYUFBM0IsRUFBMEMsS0FBSzJKLFFBQS9DOztVQUVBLEtBQUthLDJCQUFMLENBQWlDei9DLENBQWpDOzs7UUFHRixLQUFLdy9DLHNCQUFMLENBQTRCeC9DLENBQTVCOzs7O2FBR0YsZ0NBQXVCQSxDQUF2QixFQUEwQjtRQUFBOztRQUN4QlYsTUFBTSxDQUFDNmdELG9CQUFQLENBQTRCLEtBQUtyQixLQUFqQztRQUNBLEtBQUtBLEtBQUwsR0FBYXgvQyxNQUFNLENBQUM4Z0QscUJBQVAsQ0FBNkI7VUFBQSxPQUFNLE1BQUksQ0FBQ3ZCLGVBQUwsQ0FBcUI3K0MsQ0FBckIsQ0FBTjtTQUE3QixDQUFiOzs7O2FBR0YseUJBQWdCQSxDQUFoQixFQUFtQjtRQUFBOztRQUNqQixJQUFNcWdELElBQUksR0FBRyxLQUFLQyxxQkFBTCxFQUFiO1FBRUEsSUFBTXZsQyxNQUFNLEdBQUcsS0FBS3dqQyxVQUFMLENBQWdCajhCLEdBQWhCLENBQW9CLFVBQUF3OUIsU0FBUyxFQUFJO1VBQzlDLElBQU14MEIsS0FBSyxHQUFHLE1BQUksQ0FBQ2d6QixjQUFMLENBQW9CbCtDLEdBQXBCLENBQXdCMC9DLFNBQXhCLENBQWQsQ0FEOEM7Ozs7VUFJOUMsSUFBTTN2QyxDQUFDLEdBQUdtYixLQUFLLENBQUNpMUIsT0FBTixHQUFnQkYsSUFBSSxDQUFDdmQsSUFBL0I7O1VBQ0EsSUFBTTBkLE9BQU8sR0FBRyxNQUFJLENBQUN2QixJQUFMLENBQVU5dUMsQ0FBVixDQUFoQjs7VUFDQSxJQUFNQyxDQUFDLEdBQUdrYixLQUFLLENBQUNtMUIsT0FBTixHQUFnQkosSUFBSSxDQUFDSyxHQUEvQjs7VUFDQSxJQUFNQyxPQUFPLEdBQUcsTUFBSSxDQUFDeEIsSUFBTCxDQUFVL3VDLENBQVYsQ0FBaEI7O1VBRUEsT0FBTztZQUFFRCxDQUFDLEVBQUVxd0MsT0FBTDtZQUFjcHdDLENBQUMsRUFBRXV3QyxPQUFqQjtZQUEwQmI7V0FBakM7U0FUYSxDQUFmLENBSGlCOzs7UUFpQmpCLElBQU14MEIsS0FBSyxHQUFHLElBQUlvMEIsV0FBSixDQUFnQixPQUFoQixFQUF5QjtVQUNyQ0MsT0FBTyxFQUFFLElBRDRCO1VBRXJDQyxRQUFRLEVBQUUsSUFGMkI7VUFHckNDLE1BQU0sRUFBRTtZQUFFaitDLEtBQUssRUFBRW1aOztTQUhMLENBQWQ7UUFNQSxLQUFLZ2xDLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7Ozs7V0F2T0YsZUFBd0I7UUFDdEIsT0FBTztVQUNMNnlCLE1BQU0sRUFBRTtZQUNOLzVDLElBQUksRUFBRW1GLEtBREE7WUFFTjRULFNBQVMsRUFBRTtXQUhSO1VBS0xpaEMsTUFBTSxFQUFFO1lBQ05oNkMsSUFBSSxFQUFFbUYsS0FEQTtZQUVONFQsU0FBUyxFQUFFO1dBUFI7VUFTTCtoQyxLQUFLLEVBQUU7WUFDTDk2QyxJQUFJLEVBQUVpUTtXQVZIO1VBWUwrcUMsTUFBTSxFQUFFO1lBQ05oN0MsSUFBSSxFQUFFaVE7V0FiSDtVQWVMdXNDLEtBQUssRUFBRTtZQUNMeDhDLElBQUksRUFBRWl6QyxPQUREO1lBRUxsNkIsU0FBUyxFQUFFOztTQWpCZjs7OztXQXNCRixlQUFvQjtRQUNsQixPQUFPbTVCLEdBQVA7Ozs7O0lBekI0QnNIOztFQTRPaENpRCxjQUFjLENBQUNqN0IsTUFBZixDQUFzQixxQkFBdEIsRUFBNkNzNEIsaUJBQTdDOzs7O0VDNU9BLFNBQVMxL0IsU0FBVCxHQUFtQjtJQUNqQixJQUFJbGYsTUFBTSxDQUFDd2hELFdBQVgsRUFBd0I7TUFDdEIsT0FBT3hoRCxNQUFNLENBQUN3aEQsV0FBUCxDQUFtQnhpQyxHQUFuQixFQUFQO0tBREYsTUFFTztNQUNMLE9BQU9DLElBQUksQ0FBQ0QsR0FBTCxFQUFQOztFQUVIOztNQUVLeWlDOzs7OztJQXFCSiwwQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBSzdCLEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBS0UsTUFBTCxHQUFjLEdBQWQ7TUFFQSxNQUFLVSxTQUFMLEdBQWlCLElBQWpCO01BQ0EsTUFBS2tCLFdBQUwsR0FBbUIsSUFBbkI7TUFDQSxNQUFLQyxRQUFMLEdBQWdCLElBQWhCO01BRUEsTUFBS3pDLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFlbnRDLElBQWYsK0JBQWpCO01BQ0EsTUFBS290QyxPQUFMLEdBQWUsTUFBS0EsT0FBTCxDQUFhcHRDLElBQWIsK0JBQWY7TUFFQSxNQUFLcXRDLFVBQUwsR0FBa0IsTUFBS0EsVUFBTCxDQUFnQnJ0QyxJQUFoQiwrQkFBbEI7TUFDQSxNQUFLc3RDLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFldHRDLElBQWYsK0JBQWpCO01BQ0EsTUFBS3V0QyxRQUFMLEdBQWdCLE1BQUtBLFFBQUwsQ0FBY3Z0QyxJQUFkLCtCQUFoQjtNQUVBLE1BQUt3dEMsZUFBTCxHQUF1QixNQUFLQSxlQUFMLENBQXFCeHRDLElBQXJCLCtCQUF2QjtNQUNBLE1BQUt5dEMsS0FBTCxHQUFhLElBQWI7TUFsQlk7Ozs7O2FBcUJkLGtCQUFTO1FBQ1AsT0FBTy85QixHQUFQLHdSQUdlLEtBQUttK0IsS0FIcEIsRUFJZ0IsS0FBS0UsTUFKckIsRUFNa0IsS0FBS0MsU0FOdkIsRUFPbUI7VUFDYm5LLFdBQVcsRUFBRSxLQUFLd0osVUFETDtVQUViM0osT0FBTyxFQUFFO1NBVGYsRUFXb0IsS0FBS3VLLG1CQVh6Qjs7OzthQWdCRixtQkFBVXQvQyxDQUFWLEVBQWE7UUFDWFYsTUFBTSxDQUFDc3NCLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLEtBQUs0eUIsU0FBMUM7UUFDQWwvQyxNQUFNLENBQUNzc0IsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsS0FBSzZ5QixPQUF4Qzs7UUFFQSxLQUFLYyw0QkFBTDs7UUFDQSxLQUFLTyxTQUFMLEdBQWlCLE9BQWpCO1FBRUEsS0FBS21CLFFBQUwsR0FBZ0J6aUMsU0FBTyxFQUF2QjtRQUNBLEtBQUt3aUMsV0FBTCxHQUFtQmhoRCxDQUFuQjs7OzthQUdGLG1CQUFVQSxDQUFWLEVBQWE7UUFDWCxLQUFLdy9DLHNCQUFMLENBQTRCeC9DLENBQTVCOzs7O2FBR0YsaUJBQVFBLENBQVIsRUFBVztRQUFBOztRQUNUVixNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsS0FBS3VKLFNBQTdDO1FBQ0FsL0MsTUFBTSxDQUFDMjFDLG1CQUFQLENBQTJCLFNBQTNCLEVBQXNDLEtBQUt3SixPQUEzQzs7UUFFQSxLQUFLZ0IsMkJBQUw7O1FBQ0EsS0FBS0Qsc0JBQUwsQ0FBNEJ4L0MsQ0FBNUIsRUFMUzs7O1FBUVRnc0IsVUFBVSxDQUFDLFlBQU07VUFDZixNQUFJLENBQUM4ekIsU0FBTCxHQUFpQixJQUFqQjs7VUFDQSxNQUFJLENBQUNOLHNCQUFMLENBQTRCeC9DLENBQTVCO1NBRlEsRUFHUCxFQUhPLENBQVY7Ozs7O2FBT0Ysb0JBQVdBLENBQVgsRUFBYztRQUNaQSxDQUFDLENBQUM4OUMsY0FBRixHQURZOztRQUdaLElBQUksS0FBS2dDLFNBQUwsS0FBbUIsSUFBdkIsRUFBNkI7VUFDM0IsSUFBTUcsS0FBSyxHQUFHamdELENBQUMsQ0FBQ2dnRCxjQUFGLENBQWlCLENBQWpCLENBQWQ7VUFDQSxLQUFLRixTQUFMLEdBQWlCRyxLQUFLLENBQUNDLFVBQXZCO1VBRUE1Z0QsTUFBTSxDQUFDc3NCLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLEtBQUsreUIsU0FBMUMsRUFBcUQ7WUFBRTVKLE9BQU8sRUFBRTtXQUFoRTtVQUNBejFDLE1BQU0sQ0FBQ3NzQixnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxLQUFLZ3pCLFFBQXpDO1VBQ0F0L0MsTUFBTSxDQUFDc3NCLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLEtBQUtnekIsUUFBNUM7O1VBRUEsS0FBS1csNEJBQUw7O1VBRUEsS0FBSzBCLFFBQUwsR0FBZ0J6aUMsU0FBTyxFQUF2QjtVQUNBLEtBQUt3aUMsV0FBTCxHQUFtQmYsS0FBbkI7Ozs7O2FBSUosbUJBQVVqZ0QsQ0FBVixFQUFhO1FBQ1hBLENBQUMsQ0FBQzg5QyxjQUFGLEdBRFc7O1FBQUEsMkNBR085OUMsQ0FBQyxDQUFDZ2dELGNBSFQ7OztRQUFBO1VBR1gsb0RBQW9DO1lBQUEsSUFBM0JDLEtBQTJCOztZQUNsQyxJQUFJQSxLQUFLLENBQUNDLFVBQU4sS0FBcUIsS0FBS0osU0FBOUIsRUFBeUM7Y0FDdkMsS0FBS04sc0JBQUwsQ0FBNEJTLEtBQTVCOzs7O1VBTE87O1VBQUE7Ozs7O2FBVWIsa0JBQVNqZ0QsQ0FBVCxFQUFZO1FBQUE7O1FBQUEsNENBQ1FBLENBQUMsQ0FBQ2dnRCxjQURWOzs7UUFBQTtVQUFBO1lBQUEsSUFDREMsS0FEQzs7WUFFUixJQUFJQSxLQUFLLENBQUNDLFVBQU4sS0FBcUIsTUFBSSxDQUFDSixTQUE5QixFQUF5QztjQUN2Q3hnRCxNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsTUFBSSxDQUFDMEosU0FBN0M7Y0FDQXIvQyxNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsVUFBM0IsRUFBdUMsTUFBSSxDQUFDMkosUUFBNUM7Y0FDQXQvQyxNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsYUFBM0IsRUFBMEMsTUFBSSxDQUFDMkosUUFBL0M7O2NBRUEsTUFBSSxDQUFDYSwyQkFBTDs7Y0FDQSxNQUFJLENBQUNELHNCQUFMLENBQTRCUyxLQUE1QixFQU51Qzs7OztjQVN2Q2owQixVQUFVLENBQUMsWUFBTTtnQkFDZixNQUFJLENBQUM4ekIsU0FBTCxHQUFpQixJQUFqQjs7Z0JBQ0EsTUFBSSxDQUFDTixzQkFBTCxDQUE0QlMsS0FBNUI7ZUFGUSxFQUdQLEVBSE8sQ0FBVjs7OztVQVZKLHVEQUFvQztZQUFBOzs7VUFEMUI7O1VBQUE7Ozs7O2FBbUJaLGdDQUF1QmpnRCxDQUF2QixFQUEwQjtRQUFBOztRQUN4QlYsTUFBTSxDQUFDNmdELG9CQUFQLENBQTRCLEtBQUtyQixLQUFqQztRQUNBLEtBQUtBLEtBQUwsR0FBYXgvQyxNQUFNLENBQUM4Z0QscUJBQVAsQ0FBNkI7VUFBQSxPQUFNLE1BQUksQ0FBQ3ZCLGVBQUwsQ0FBcUI3K0MsQ0FBckIsQ0FBTjtTQUE3QixDQUFiOzs7OzthQUlGLHlCQUFnQkEsQ0FBaEIsRUFBbUI7UUFDakIsSUFBTWtoRCxLQUFLLEdBQUcsS0FBS0YsV0FBTCxDQUFpQkcsT0FBL0I7UUFDQSxJQUFNQyxLQUFLLEdBQUcsS0FBS0osV0FBTCxDQUFpQkssT0FBL0I7UUFDQSxJQUFNbHhDLENBQUMsR0FBR25RLENBQUMsQ0FBQ21oRCxPQUFaO1FBQ0EsSUFBTS93QyxDQUFDLEdBQUdwUSxDQUFDLENBQUNxaEQsT0FBWjtRQUVBLElBQU0vaUMsR0FBRyxHQUFHRSxTQUFPLEVBQW5CO1FBQ0EsSUFBTThpQyxFQUFFLEdBQUksS0FBS0wsUUFBTCxHQUFnQjNpQyxHQUE1QjtRQUVBLElBQU1pakMsRUFBRSxHQUFHLENBQUNweEMsQ0FBQyxHQUFHK3dDLEtBQUwsSUFBY0ksRUFBekI7UUFDQSxJQUFNRSxFQUFFLEdBQUcsQ0FBQ3B4QyxDQUFDLEdBQUdneEMsS0FBTCxJQUFjRSxFQUF6QjtRQUVBLEtBQUtMLFFBQUwsR0FBZ0IzaUMsR0FBaEI7UUFDQSxLQUFLMGlDLFdBQUwsR0FBbUJoaEQsQ0FBbkIsQ0FiaUI7OztRQWdCakIsSUFBTXNyQixLQUFLLEdBQUcsSUFBSW8wQixXQUFKLENBQWdCLE9BQWhCLEVBQXlCO1VBQ3JDQyxPQUFPLEVBQUUsSUFENEI7VUFFckNDLFFBQVEsRUFBRSxJQUYyQjtVQUdyQ0MsTUFBTSxFQUFFO1lBQUUwQixFQUFGO1lBQU1DLEVBQU47WUFBVTFCLFNBQVMsRUFBRSxLQUFLQTs7U0FIdEIsQ0FBZDtRQU1BLEtBQUtDLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7Ozs7V0FuS0YsZUFBd0I7UUFDdEIsT0FBTztVQUNMNHpCLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTs7U0FMVjs7OztXQVVGLGVBQW9CO1FBQ2xCLE9BQU9paUMsR0FBUDs7Ozs7SUFieUJzSDs7RUF3SzdCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0Isa0JBQXRCLEVBQTBDbTdCLGNBQTFDOzs7O0FDaExBLEVBQU8sSUFBTVUsVUFBVSxHQUFHbkwsR0FBSCxvR0FBaEI7QUFDUCxFQUFPLElBQU1vTCxRQUFRLEdBQUdwTCxHQUFILCtFQUFkO0FBRVAsRUFBTyxJQUFNcUwsS0FBSyxHQUFHLEVBQWQ7RUFDUEEsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkJyTCxHQUE3QjtFQUNBcUwsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkJyTCxHQUE3QjtFQUNBcUwsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkJyTCxHQUE3QjtFQUNBcUwsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkJyTCxHQUE3QjtFQUNBcUwsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkJyTCxHQUE3QjtFQUNBcUwsS0FBSyxDQUFDLHFCQUFELENBQUwsR0FBK0JyTCxHQUEvQjs7RUFDQXFMLEtBQUssQ0FBQyxxQkFBRCxDQUFMLEdBQStCckwsR0FBL0I7O0VBQ0FxTCxLQUFLLENBQUMscUJBQUQsQ0FBTCxHQUErQnJMLEdBQS9COztFQUNBcUwsS0FBSyxDQUFDLHFCQUFELENBQUwsR0FBK0JyTCxHQUEvQjtFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFFQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0FBRUEsRUFBTyxJQUFNc0wsS0FBSyxHQUFHdEwsR0FBSCwyakNBQVg7QUFFUCxFQUFPLElBQU11TCxVQUFVLEdBQUd2TCxHQUFILDJ1REFBaEI7QUFFUCxFQUFPLElBQU13TCxTQUFTLEdBQUd4TCxHQUFILDJtRUFBZjs7OztNQ2pERHlMOzs7OztJQWdFSixvQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBSzdDLEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBS0UsTUFBTCxHQUFjLEVBQWQ7TUFDQSxNQUFLNEMsSUFBTCxHQUFZLEVBQVo7TUFDQSxNQUFLcGdELEtBQUwsR0FBYSxJQUFiO01BQ0EsTUFBS3FnRCxRQUFMLEdBQWdCLEtBQWhCO01BRUEsTUFBS0MsUUFBTCxHQUFnQixLQUFoQjtNQUNBLE1BQUtDLE9BQUwsR0FBZSxNQUFLQSxPQUFMLENBQWE5d0MsSUFBYiwrQkFBZjtNQVZZOzs7RUFjaEI7RUFDQTs7Ozs7YUFDRSxrQkFBUztRQUNQLElBQU0yd0MsSUFBSSxHQUFHLEtBQUtBLElBQUwsR0FBWSxLQUFLQSxJQUFqQixHQUF3QixLQUFLcGdELEtBQTFDO1FBRUEsT0FBT21mLEdBQVAsbVpBR2UsS0FBS20rQixLQUhwQixFQUlnQixLQUFLRSxNQUpyQixFQUtxQixLQUFLQSxNQUwxQixFQU9hLEtBQUs2QyxRQUFMLEdBQWdCLFVBQWhCLEdBQTZCLEVBUDFDLEVBUWtCLEtBQUtFLE9BUnZCLEVBU2dCLEtBQUtBLE9BVHJCLEVBV21CO1VBQ2JqTixXQUFXLEVBQUMsS0FBS2lOLE9BREo7VUFFYnBOLE9BQU8sRUFBRTtTQWJmLEVBZWlCLEtBQUtvTixPQWZ0QixFQWdCb0IsS0FBSzdDLG1CQWhCekIsRUFpQkswQyxJQWpCTDs7OzthQXFCRixpQkFBUWhpRCxDQUFSLEVBQVc7UUFDVEEsQ0FBQyxDQUFDODlDLGNBQUY7UUFDQSxJQUFJc0UsU0FBSjs7UUFFQSxJQUFJcGlELENBQUMsQ0FBQ29FLElBQUYsS0FBVyxVQUFYLElBQXlCcEUsQ0FBQyxDQUFDb0UsSUFBRixLQUFXLFNBQXhDLEVBQW1EO1VBQ2pEZytDLFNBQVMsR0FBRyxTQUFaO1NBREYsTUFFTztVQUNMQSxTQUFTLEdBQUcsT0FBWjtTQVBPOzs7UUFXVCxJQUFJQSxTQUFTLEtBQUssU0FBZCxJQUEyQixLQUFLRixRQUFMLEtBQWtCLEtBQWpELEVBQXdEO1VBQ3REOzs7UUFHRixLQUFLQSxRQUFMLEdBQWlCRSxTQUFTLEtBQUssT0FBL0I7UUFFQSxJQUFNOTJCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IwQyxTQUFoQixFQUEyQjtVQUN2Q3pDLE9BQU8sRUFBRSxJQUQ4QjtVQUV2Q0MsUUFBUSxFQUFFLElBRjZCO1VBR3ZDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1NBSFYsQ0FBZDtRQU1BLEtBQUttK0MsYUFBTCxDQUFtQnowQixLQUFuQjs7UUFFQSxJQUFJODJCLFNBQVMsS0FBSyxPQUFsQixFQUEyQjtVQUN6QixJQUFNQyxVQUFVLEdBQUcsSUFBSTNDLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUI7WUFDMUNDLE9BQU8sRUFBRSxJQURpQztZQUUxQ0MsUUFBUSxFQUFFLElBRmdDO1lBRzFDQyxNQUFNLEVBQUU7Y0FBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1dBSEwsQ0FBbkI7VUFNQSxLQUFLbStDLGFBQUwsQ0FBbUJzQyxVQUFuQjs7Ozs7V0F2SUosZUFBd0I7UUFDdEIsT0FBTztVQUNMbkQsS0FBSyxFQUFFO1lBQ0w5NkMsSUFBSSxFQUFFaVE7V0FGSDtVQUlMK3FDLE1BQU0sRUFBRTtZQUNOaDdDLElBQUksRUFBRWlRO1dBTEg7VUFPTDJ0QyxJQUFJLEVBQUU7WUFDSjU5QyxJQUFJLEVBQUVYO1dBUkg7VUFVTDdCLEtBQUssRUFBRTtZQUNMd0MsSUFBSSxFQUFFWDtXQVhIO1VBYUx3K0MsUUFBUSxFQUFFO1lBQ1I3OUMsSUFBSSxFQUFFaXpDOztTQWRWOzs7O1dBbUJGLGVBQW9CO1FBQ2xCLE9BQU9mLEdBQVAsMjFCQVVtQm1MLFVBVm5CLEVBV2lCQyxRQVhqQixFQWF3QkMsS0FBSyxDQUFDLG1CQUFELENBYjdCLEVBY3dCQSxLQUFLLENBQUMsbUJBQUQsQ0FkN0IsRUFxQndCQSxLQUFLLENBQUMsbUJBQUQsQ0FyQjdCLEVBMEJ3QkEsS0FBSyxDQUFDLG1CQUFELENBMUI3QixFQStCd0JBLEtBQUssQ0FBQyxxQkFBRCxDQS9CN0IsRUFnQ3dCQSxLQUFLLENBQUMscUJBQUQsQ0FoQzdCOzs7OztJQXRCbUIvRDs7RUE2SXZCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUNtOEIsUUFBbkM7Ozs7TUM3SU1POzs7OztJQStESixvQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBS3BELEtBQUwsR0FBYSxFQUFiO01BQ0EsTUFBS3FELE1BQUwsR0FBYyxLQUFkO01BRUEsTUFBS0MsV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCbnhDLElBQWpCLCtCQUFuQjtNQU5ZOzs7OztXQXRCZCxlQUFZO1FBQ1YsT0FBTyxLQUFLb3hDLEtBQVo7O1dBTkYsYUFBVTdnRCxLQUFWLEVBQWlCO1FBQ2YsS0FBSzZnRCxLQUFMLEdBQWE3Z0QsS0FBYjtRQUNBLEtBQUs0MkMsYUFBTDs7OztXQVlGLGVBQWE7UUFDWCxPQUFPLEtBQUtpSyxLQUFaOzs7V0FORixhQUFXN2dELEtBQVgsRUFBa0I7UUFDaEIsS0FBSzZnRCxLQUFMLEdBQWE3Z0QsS0FBYjtRQUNBLEtBQUs0MkMsYUFBTDs7OztXQVFGLGVBQVk7UUFDVixPQUFPLEtBQUsrSixNQUFaOztXQUdGLGFBQVVBLE1BQVYsRUFBa0I7UUFDaEIsS0FBS0EsTUFBTCxHQUFjQSxNQUFkOzs7O2FBWUYsa0JBQVM7UUFDUCxJQUFNRyxPQUFPLEdBQUcsRUFBaEI7UUFDQSxJQUFNQyxXQUFXLEdBQUcsRUFBcEI7UUFFQSxPQUFPNWhDLEdBQVAsbWNBRW9CLEtBQUswaEMsS0FGekIsRUFFNkMsS0FBS0EsS0FGbEQsRUFJa0IsS0FBS0QsV0FKdkIsRUFLbUI7VUFDYnROLFdBQVcsRUFBRSxLQUFLc04sV0FETDtVQUViek4sT0FBTyxFQUFFO1NBUGYsRUFVb0IsS0FBS3VLLG1CQVZ6QixFQWlCY3FDLEtBQUssQ0FBQyxtQkFBRCxDQWpCbkIsRUFtQk0sS0FBS1ksTUFBTCxHQUNFNVUsQ0FERiw4ZUFHWStVLE9BSFosRUFJWUEsT0FKWixFQUtZLE1BQU1BLE9BTGxCLEVBTVksTUFBTUEsT0FObEIsRUFPNEJDLFdBUDVCLEVBU1lELE9BVFosRUFVWSxNQUFNQSxPQVZsQixFQVdZLE1BQU1BLE9BWGxCLEVBWVlBLE9BWlosRUFhNEJDLFdBYjVCLElBZUVoVixDQWZGLHdlQWlCWStVLE9BakJaLEVBa0JZQSxPQWxCWixFQW1CWSxNQUFNQSxPQW5CbEIsRUFvQlksTUFBTUEsT0FwQmxCLEVBcUI0QkMsV0FyQjVCLEVBcUJtRGhCLEtBQUssQ0FBQyxtQkFBRCxDQXJCeEQsRUF1QlllLE9BdkJaLEVBd0JZLE1BQU1BLE9BeEJsQixFQXlCWSxNQUFNQSxPQXpCbEIsRUEwQllBLE9BMUJaLEVBMkI0QkMsV0EzQjVCLEVBMkJtRGhCLEtBQUssQ0FBQyxtQkFBRCxDQTNCeEQsQ0FuQk47Ozs7YUFxREYscUJBQVkzaEQsQ0FBWixFQUFlO1FBQ2JBLENBQUMsQ0FBQzg5QyxjQUFGO1FBQ0E5OUMsQ0FBQyxDQUFDNGlELGVBQUY7UUFFQSxLQUFLTCxNQUFMLEdBQWMsQ0FBQyxLQUFLQSxNQUFwQjtRQUVBLElBQU1NLFdBQVcsR0FBRyxJQUFJbkQsV0FBSixDQUFnQixRQUFoQixFQUEwQjtVQUM1Q0MsT0FBTyxFQUFFLElBRG1DO1VBRTVDQyxRQUFRLEVBQUUsSUFGa0M7VUFHNUNDLE1BQU0sRUFBRTtZQUFFaitDLEtBQUssRUFBRSxLQUFLMmdEOztTQUhKLENBQXBCO1FBTUEsS0FBS3hDLGFBQUwsQ0FBbUI4QyxXQUFuQjtRQUNBLEtBQUtySyxhQUFMOzs7O1dBN0lGLGVBQXdCO1FBQ3RCLE9BQU87VUFDTDBHLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTtXQUxIO1VBT0xrdUMsTUFBTSxFQUFFO1lBQ05uK0MsSUFBSSxFQUFFaXpDLE9BREE7WUFFTlEsT0FBTyxFQUFFO1dBVE47VUFXTGoyQyxLQUFLLEVBQUU7WUFDTHdDLElBQUksRUFBRWl6Qzs7U0FaVjs7OztXQWlCRixlQUFvQjtRQUNsQixPQUFPZixHQUFQLGlXQVd3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQVg3Qjs7Ozs7SUFwQm1CL0Q7O0VBa0p2QmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLFdBQXRCLEVBQW1DMDhCLFFBQW5DOztFQ3RKZSxTQUFTUSxRQUFULENBQWtCajJCLE1BQWxCLEVBQTBCazJCLEtBQTFCLEVBQWlDO0lBQzlDLElBQU1DLEtBQUssR0FBRyxDQUFDRCxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQWpCLEtBQXlCbDJCLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWUEsTUFBTSxDQUFDLENBQUQsQ0FBM0MsQ0FBZDtJQUNBLElBQU1vMkIsU0FBUyxHQUFHRixLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdDLEtBQUssR0FBR24yQixNQUFNLENBQUMsQ0FBRCxDQUEzQzs7SUFFQSxTQUFTcTJCLEtBQVQsQ0FBZWhpRCxHQUFmLEVBQW9CO01BQ2xCLE9BQU84aEQsS0FBSyxHQUFHOWhELEdBQVIsR0FBYytoRCxTQUFyQjs7O0lBR0ZDLEtBQUssQ0FBQ0MsTUFBTixHQUFlLFVBQVNqaUQsR0FBVCxFQUFjO01BQzNCLE9BQU8sQ0FBQ0EsR0FBRyxHQUFHK2hELFNBQVAsSUFBb0JELEtBQTNCO0tBREY7O0lBSUEsT0FBT0UsS0FBUDtFQUNEOztFQ2JjLFNBQVNFLFVBQVQsQ0FBb0J2N0MsR0FBcEIsRUFBeUJFLEdBQXpCLEVBQThCeVksSUFBOUIsRUFBb0M7SUFDakQsT0FBTyxVQUFDdGYsR0FBRCxFQUFTO01BQ2QsSUFBTW1pRCxZQUFZLEdBQUc5akQsSUFBSSxDQUFDKy9CLEtBQUwsQ0FBV3ArQixHQUFHLEdBQUdzZixJQUFqQixJQUF5QkEsSUFBOUM7TUFDQSxJQUFNOUMsS0FBSyxHQUFHbmUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTeEksSUFBSSxDQUFDMlosS0FBTCxDQUFXLElBQUlzSCxJQUFmLENBQVQsRUFBK0IsQ0FBL0IsQ0FBZDtNQUNBLElBQU04aUMsVUFBVSxHQUFHRCxZQUFZLENBQUN0dUMsT0FBYixDQUFxQjJJLEtBQXJCLENBQW5CLENBSGM7O01BSWQsT0FBT25lLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU0UsR0FBVCxFQUFjeEksSUFBSSxDQUFDd0ksR0FBTCxDQUFTRixHQUFULEVBQWN1TCxVQUFVLENBQUNrd0MsVUFBRCxDQUF4QixDQUFkLENBQVA7S0FKRjtFQU1EOzs7Ozs7O0VDa0NZLFVBQVc7SUFDdEJDLFdBQVcsQ0FEVztJQUV0QkMsT0FBTyxDQUZlO0lBR3RCQyxVQUFVLENBSFk7SUFJdEJDLG1CQUFtQixDQUpHO0lBS3RCQyxPQUFPLENBTGU7SUFNdEJDLFNBQVM7RUFOYSxDQUFYO0VBQUEsSUEwQ0FDLE1BQ2dCOS9DLFNBRGhCOC9DLENBQ2dCOS9DO0lBQUFBLE9BQzNCO01BQUEsa0NBQUlnWCxDQUFKO1FBQUlBLENBQUo7OztNQUFBLE9BQTBFO1FBRXhFMjJCLGlCQUFxQjN0QyxDQUZtRDtRQUd4RWdYO09BSEY7S0FEMkJoWDtFQUFBQSxDQTNDaEI7O01BdURTKy9DO0lBa0JwQjkwQyxXQUFZKzBDLENBQVovMEMsRUFBWSswQztNQUFBQTs7Ozs7V0FHUjFSO1FBQ0YsT0FBT2hELEtBQUs4QyxJQUFMOUMsQ0FBY2dELElBQXJCOzs7O2FBSUZULGNBQ0V2RCxDQURGdUQsRUFFRWhsQixDQUZGZ2xCLEVBR0VQLEVBSEZPLEVBR0VQO1FBRUFoQyxLQUFLMlUsSUFBTDNVLEdBQWNoQixDQUFkZ0IsRUFDQUEsS0FBSzhDLElBQUw5QyxHQUFnQnppQixDQURoQnlpQixFQUVBQSxLQUFLNFUsSUFBTDVVLEdBQXdCZ0MsRUFGeEJoQzs7OzthQUtGd0MsY0FBVXhELENBQVZ3RCxFQUFzQmlLLENBQXRCakssRUFBc0JpSztRQUNwQixPQUFPek0sS0FBS3lMLE1BQUx6TCxDQUFZaEIsQ0FBWmdCLEVBQWtCeU0sQ0FBbEJ6TSxDQUFQOzs7O2FBS0Z5TCxnQkFBT29KLENBQVBwSixFQUFvQmdCLENBQXBCaEIsRUFBb0JnQjtRQUNsQixPQUFPek0sS0FBS3JCLE1BQUxxQixnQ0FBZXlNLENBQWZ6TSxFQUFQOzs7Ozs7Ozs7Ozs7O01DaEJTOFUsTUFBV047SUFBQUE7O0lBQUFBOztJQTdGdEI3MEMsZ0JBQVlvMUMsQ0FBWnAxQyxFQUFZbzFDO01BQUFBOztNQUFBQTs7TUFBQUE7TUFFVixJQURBMVAsMEJBQU0wUCxDQUFOMVAsR0FFRTBQLEVBQVNoZ0QsSUFBVGdnRCxLQUFrQkMsSUFBU2QsU0FBM0JhLElBQ2tCLFlBQWxCQSxFQUFTLy9DLElBRFQrL0MsSUFDUy8vQyxXQUNSa3NCLE1BQVNrZCxPQUREcHBDLEtBQ0NvcEMsWUFERHBwQyxHQUNDb3BDLE1BRERwcEMsR0FDQ29wQyxFQUFTN3BDLE1BRFZTLElBQzhCLENBSHpDLEVBS0UsTUFBVWlsQyxNQUNSLG9HQURRQSxDQUFWO01BUFE4YTs7O0lBNkZVUDtNQUFBQTtNQUFBQSxPQS9FdEI3VixnQkFBT3NXLENBQVB0VyxFQUFPc1c7UUFFTCxPQUNFLE1BQ0Fwa0QsT0FBTzJJLElBQVAzSSxDQUFZb2tELENBQVpwa0QsRUFDR3NpQixNQURIdGlCLENBQ1dMO1VBQUFBLE9BQVF5a0QsRUFBVXprRCxDQUFWeWtELENBQVJ6a0Q7U0FEWEssRUFFR3NELElBRkh0RCxDQUVRLEdBRlJBLENBREEsR0FJQSxHQUxGOzs7TUE2RW9CMmpEO01BQUFBLE9BcEViL0ksZ0JBQU96TSxDQUFQeU0sUUFBNkJ3SjtRQUFBQTs7UUFBQUE7OztRQUFBQTs7UUFFcEMsU0FBOEI5aEQsQ0FBOUIsS0FBSTZzQyxLQUFLa1YsRUFBVCxFQUF5QztVQUN2Q2xWLEtBQUtrVixFQUFMbFYsR0FBd0IsSUFBSTViLEdBQUosRUFBeEI0YixFQUE0QjViLEtBQ1BqeEIsQ0FET2l4QixLQUN4QjRhLEVBQUtaLE9BRG1CaGEsS0FFMUI0YixLQUFLbVYsRUFBTG5WLEdBQXNCLElBQUk1YixHQUFKLENBQ3BCNGEsRUFBS1osT0FBTFksQ0FDRzdxQyxJQURINnFDLENBQ1EsR0FEUkEsRUFFR25yQyxLQUZIbXJDLENBRVMsSUFGVEEsRUFHRzdyQixNQUhINnJCLENBR1c5NEI7WUFBQUEsT0FBWSxPQUFOQSxDQUFOQTtXQUhYODRCLENBRG9CLENBRkk1YSxDQUE1QjRiOztVQVNBLEtBQUssSUFBTWhyQyxFQUFYLElBQW1CaWdELENBQW5CO1lBQ01BLEVBQVVqZ0QsRUFBVmlnRCxLQUFVamdELEVBQStCLFVBQXJCa3NCLFNBQUtpMEIsRUFBZ0IsS0FBaEJBLEtBQWdCLENBQWhCQSxLQUFnQmowQixtQkFBSWxzQixFQUFKa3NCLENBQS9CbHNCLENBQVZpZ0QsSUFDRmpWLEtBQUtrVixFQUFMbFYsQ0FBc0J4YyxHQUF0QndjLENBQTBCaHJDLEVBQTFCZ3JDLENBREVpVjs7O1VBSU4sT0FBT2pWLEtBQUtyQixNQUFMcUIsQ0FBWWlWLENBQVpqVixDQUFQOzs7UUFHRixJQUFNb1YsSUFBWXBXLEVBQUs3TCxPQUFMNkwsQ0FBYW9XLFNBQS9CO1FBS0FwVixLQUFLa1YsRUFBTGxWLENBQXNCci9CLE9BQXRCcS9CLENBQStCaHJDO1VBQ3ZCQSxLQUFRaWdELENBQVJqZ0QsS0FDSm9nRCxFQUFVM1UsTUFBVjJVLENBQWlCcGdELENBQWpCb2dELEdBQ0FwVixPQUFLa1YsRUFBTGxWLENBQXVCNE8sTUFBdkI1TyxDQUE4QmhyQyxDQUE5QmdyQyxDQUZJaHJDO1NBRFJnckM7O1FBUUEsS0FBSyxJQUFNaHJDLEdBQVgsSUFBbUJpZ0QsQ0FBbkIsRUFBOEI7VUFHNUIsSUFBTTFpRCxPQUFVMGlELEVBQVVqZ0QsR0FBVmlnRCxDQUFoQjs7VUFFRTFpRCxPQUFVeXRDLEtBQUtrVixFQUFMbFYsQ0FBc0IvckMsR0FBdEIrckMsQ0FBMEJockMsR0FBMUJnckMsQ0FBVnp0QyxLQUNzQixVQUFyQisxQixTQUFLNnNCLEVBQWdCLEtBQWhCQSxLQUFnQixDQUFoQkEsS0FBZ0I3c0IsbUJBQUl0ekIsR0FBSnN6QixDQUR0Qi8xQixNQUdJQSxNQUNGNmlELEVBQVU1eEIsR0FBVjR4QixDQUFjcGdELEdBQWRvZ0QsR0FDQXBWLEtBQUtrVixFQUFMbFYsQ0FBc0J4YyxHQUF0QndjLENBQTBCaHJDLEdBQTFCZ3JDLENBRkV6dEMsS0FJRjZpRCxFQUFVM1UsTUFBVjJVLENBQWlCcGdELEdBQWpCb2dELEdBQ0FwVixLQUFLa1YsRUFBTGxWLENBQXNCNE8sTUFBdEI1TyxDQUE2QmhyQyxHQUE3QmdyQyxDQUxFenRDLENBSEpBOzs7UUFZSixPQUFPZ3NDLEdBQVA7Ozs7SUFrQm9CaVc7RUFBQUEsRUFyR1FDLEdBcUdSRDs7RUMzSHhCO0VBQ0E7RUFDQTtFQUNBOztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsU0FBU2EsS0FBVCxDQUFlNWxDLEdBQWYsRUFBb0IzSSxTQUFwQixFQUErQjtJQUMzQixJQUFJQSxTQUFTLEtBQUssS0FBSyxDQUF2QixFQUEwQjtNQUFFQSxTQUFTLEdBQUcsRUFBWjs7O0lBQzVCLE9BQU8sQ0FBQy9DLFVBQVUsQ0FBQ2lCLE1BQU0sQ0FBQ3lLLEdBQUQsQ0FBTixDQUFZNUksV0FBWixDQUF3QkMsU0FBeEIsQ0FBRCxDQUFsQjtFQUNIO0VBQ0Q7RUFDQTtFQUNBO0VBQ0E7OztFQUNBLFNBQVN3dUMsV0FBVCxDQUFxQjdsQyxHQUFyQixFQUEwQjs7SUFFdEIsSUFBSThsQyxNQUFNLEdBQUc5bEMsR0FBRyxDQUFDM2QsUUFBSixHQUFlK0IsS0FBZixDQUFxQixNQUFyQixDQUFiO0lBQ0EsSUFBSWlPLEdBQUcsR0FBRyxDQUFDeXpDLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTFoRCxLQUFWLENBQWdCLEdBQWhCLEVBQXFCLENBQXJCLEtBQTJCLEVBQTVCLEVBQWdDVSxNQUFoQyxHQUF5QyxFQUFFZ2hELE1BQU0sQ0FBQyxDQUFELENBQU4sSUFBYSxDQUFmLENBQW5EO0lBQ0EsT0FBT3p6QyxHQUFHLEdBQUcsQ0FBTixHQUFVQSxHQUFWLEdBQWdCLENBQXZCO0VBQ0g7RUFDRDtFQUNBO0VBQ0E7RUFDQTs7O0VBQ0EsU0FBUzB6QyxXQUFULENBQXFCL2xDLEdBQXJCLEVBQTBCO0lBQ3RCLElBQUlBLEdBQUcsQ0FBQzNkLFFBQUosR0FBZTBiLE9BQWYsQ0FBdUIsR0FBdkIsTUFBZ0MsQ0FBQyxDQUFyQyxFQUF3QztNQUNwQyxPQUFPeEksTUFBTSxDQUFDeUssR0FBRyxDQUFDM2QsUUFBSixHQUFld1IsT0FBZixDQUF1QixHQUF2QixFQUE0QixFQUE1QixDQUFELENBQWI7OztJQUVKLElBQUlteUMsSUFBSSxHQUFHSCxXQUFXLENBQUM3bEMsR0FBRCxDQUF0QjtJQUNBLE9BQU9nbUMsSUFBSSxHQUFHLENBQVAsR0FBV0osS0FBSyxDQUFDcndDLE1BQU0sQ0FBQ3lLLEdBQUQsQ0FBTixHQUFjdmYsSUFBSSxDQUFDa1csR0FBTCxDQUFTLEVBQVQsRUFBYXF2QyxJQUFiLENBQWYsQ0FBaEIsR0FBcUR6d0MsTUFBTSxDQUFDeUssR0FBRCxDQUFsRTtFQUNIO0VBQ0Q7RUFDQTtFQUNBO0VBQ0E7OztFQUNBLFNBQVNpbUMsYUFBVCxDQUF1QmptQyxHQUF2QixFQUE0QjtJQUN4QixJQUFJa21DLHNCQUFKLEVBQTRCO01BQ3hCLElBQUlsbUMsR0FBRyxHQUFHekssTUFBTSxDQUFDc0MsZ0JBQWIsSUFBaUNtSSxHQUFHLEdBQUd6SyxNQUFNLENBQUN1QyxnQkFBbEQsRUFBb0U7UUFDaEVxWixPQUFPLENBQUNzYyxJQUFSLENBQWF6dEIsR0FBRyxHQUFHLCtFQUFuQjs7O0VBR1g7RUFDRDtFQUNBO0VBQ0E7OztFQUNBLFNBQVNtbUMsaUJBQVQsQ0FBMkJobEMsR0FBM0IsRUFBZ0NpbEMsU0FBaEMsRUFBMkM7SUFDdkMsSUFBSUMsSUFBSSxHQUFHbGxDLEdBQUcsQ0FBQyxDQUFELENBQWQ7UUFBbUJtbEMsSUFBSSxHQUFHbmxDLEdBQUcsQ0FBQyxDQUFELENBQTdCO1FBQWtDb2xDLE1BQU0sR0FBR3BsQyxHQUFHLENBQUM1WSxLQUFKLENBQVUsQ0FBVixDQUEzQztJQUNBLElBQUl1TixHQUFHLEdBQUdzd0MsU0FBUyxDQUFDQyxJQUFELEVBQU9DLElBQVAsQ0FBbkI7SUFDQUMsTUFBTSxDQUFDcjFDLE9BQVAsQ0FBZSxVQUFVOE8sR0FBVixFQUFlO01BQzFCbEssR0FBRyxHQUFHc3dDLFNBQVMsQ0FBQ3R3QyxHQUFELEVBQU1rSyxHQUFOLENBQWY7S0FESjtJQUdBLE9BQU9sSyxHQUFQO0VBQ0g7RUFDRDtFQUNBO0VBQ0E7OztFQUNBLFNBQVMwd0MsS0FBVCxHQUFpQjtJQUNiLElBQUlDLElBQUksR0FBRyxFQUFYOztJQUNBLEtBQUssSUFBSTNwQyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHM1gsU0FBUyxDQUFDTCxNQUFoQyxFQUF3Q2dZLEVBQUUsRUFBMUMsRUFBOEM7TUFDMUMycEMsSUFBSSxDQUFDM3BDLEVBQUQsQ0FBSixHQUFXM1gsU0FBUyxDQUFDMlgsRUFBRCxDQUFwQjs7O0lBRUosSUFBSTJwQyxJQUFJLENBQUMzaEQsTUFBTCxHQUFjLENBQWxCLEVBQXFCO01BQ2pCLE9BQU9xaEQsaUJBQWlCLENBQUNNLElBQUQsRUFBT0QsS0FBUCxDQUF4Qjs7O0lBRUosSUFBSUgsSUFBSSxHQUFHSSxJQUFJLENBQUMsQ0FBRCxDQUFmO1FBQW9CSCxJQUFJLEdBQUdHLElBQUksQ0FBQyxDQUFELENBQS9CO0lBQ0EsSUFBSUMsV0FBVyxHQUFHWCxXQUFXLENBQUNNLElBQUQsQ0FBN0I7SUFDQSxJQUFJTSxXQUFXLEdBQUdaLFdBQVcsQ0FBQ08sSUFBRCxDQUE3QjtJQUNBLElBQUlNLE9BQU8sR0FBR2YsV0FBVyxDQUFDUSxJQUFELENBQVgsR0FBb0JSLFdBQVcsQ0FBQ1MsSUFBRCxDQUE3QztJQUNBLElBQUlPLFNBQVMsR0FBR0gsV0FBVyxHQUFHQyxXQUE5QjtJQUNBVixhQUFhLENBQUNZLFNBQUQsQ0FBYjtJQUNBLE9BQU9BLFNBQVMsR0FBR3BtRCxJQUFJLENBQUNrVyxHQUFMLENBQVMsRUFBVCxFQUFhaXdDLE9BQWIsQ0FBbkI7RUFDSDtFQUNEO0VBQ0E7RUFDQTs7O0VBQ0EsU0FBU0UsSUFBVCxHQUFnQjtJQUNaLElBQUlMLElBQUksR0FBRyxFQUFYOztJQUNBLEtBQUssSUFBSTNwQyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHM1gsU0FBUyxDQUFDTCxNQUFoQyxFQUF3Q2dZLEVBQUUsRUFBMUMsRUFBOEM7TUFDMUMycEMsSUFBSSxDQUFDM3BDLEVBQUQsQ0FBSixHQUFXM1gsU0FBUyxDQUFDMlgsRUFBRCxDQUFwQjs7O0lBRUosSUFBSTJwQyxJQUFJLENBQUMzaEQsTUFBTCxHQUFjLENBQWxCLEVBQXFCO01BQ2pCLE9BQU9xaEQsaUJBQWlCLENBQUNNLElBQUQsRUFBT0ssSUFBUCxDQUF4Qjs7O0lBRUosSUFBSVQsSUFBSSxHQUFHSSxJQUFJLENBQUMsQ0FBRCxDQUFmO1FBQW9CSCxJQUFJLEdBQUdHLElBQUksQ0FBQyxDQUFELENBQS9CLENBUlk7O0lBVVosSUFBSUcsT0FBTyxHQUFHbm1ELElBQUksQ0FBQ2tXLEdBQUwsQ0FBUyxFQUFULEVBQWFsVyxJQUFJLENBQUN3SSxHQUFMLENBQVM0OEMsV0FBVyxDQUFDUSxJQUFELENBQXBCLEVBQTRCUixXQUFXLENBQUNTLElBQUQsQ0FBdkMsQ0FBYixDQUFkLENBVlk7O0lBWVosT0FBTyxDQUFDRSxLQUFLLENBQUNILElBQUQsRUFBT08sT0FBUCxDQUFMLEdBQXVCSixLQUFLLENBQUNGLElBQUQsRUFBT00sT0FBUCxDQUE3QixJQUFnREEsT0FBdkQ7RUFDSDtFQUNEO0VBQ0E7RUFDQTs7O0VBQ0EsU0FBU0csS0FBVCxHQUFpQjtJQUNiLElBQUlOLElBQUksR0FBRyxFQUFYOztJQUNBLEtBQUssSUFBSTNwQyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHM1gsU0FBUyxDQUFDTCxNQUFoQyxFQUF3Q2dZLEVBQUUsRUFBMUMsRUFBOEM7TUFDMUMycEMsSUFBSSxDQUFDM3BDLEVBQUQsQ0FBSixHQUFXM1gsU0FBUyxDQUFDMlgsRUFBRCxDQUFwQjs7O0lBRUosSUFBSTJwQyxJQUFJLENBQUMzaEQsTUFBTCxHQUFjLENBQWxCLEVBQXFCO01BQ2pCLE9BQU9xaEQsaUJBQWlCLENBQUNNLElBQUQsRUFBT00sS0FBUCxDQUF4Qjs7O0lBRUosSUFBSVYsSUFBSSxHQUFHSSxJQUFJLENBQUMsQ0FBRCxDQUFmO1FBQW9CSCxJQUFJLEdBQUdHLElBQUksQ0FBQyxDQUFELENBQS9CO0lBQ0EsSUFBSUcsT0FBTyxHQUFHbm1ELElBQUksQ0FBQ2tXLEdBQUwsQ0FBUyxFQUFULEVBQWFsVyxJQUFJLENBQUN3SSxHQUFMLENBQVM0OEMsV0FBVyxDQUFDUSxJQUFELENBQXBCLEVBQTRCUixXQUFXLENBQUNTLElBQUQsQ0FBdkMsQ0FBYixDQUFkO0lBQ0EsT0FBTyxDQUFDRSxLQUFLLENBQUNILElBQUQsRUFBT08sT0FBUCxDQUFMLEdBQXVCSixLQUFLLENBQUNGLElBQUQsRUFBT00sT0FBUCxDQUE3QixJQUFnREEsT0FBdkQ7RUFDSDtFQUNEO0VBQ0E7RUFDQTs7O0VBQ0EsU0FBU3J3QyxRQUFULEdBQWtCO0lBQ2QsSUFBSWt3QyxJQUFJLEdBQUcsRUFBWDs7SUFDQSxLQUFLLElBQUkzcEMsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBRzNYLFNBQVMsQ0FBQ0wsTUFBaEMsRUFBd0NnWSxFQUFFLEVBQTFDLEVBQThDO01BQzFDMnBDLElBQUksQ0FBQzNwQyxFQUFELENBQUosR0FBVzNYLFNBQVMsQ0FBQzJYLEVBQUQsQ0FBcEI7OztJQUVKLElBQUkycEMsSUFBSSxDQUFDM2hELE1BQUwsR0FBYyxDQUFsQixFQUFxQjtNQUNqQixPQUFPcWhELGlCQUFpQixDQUFDTSxJQUFELEVBQU9sd0MsUUFBUCxDQUF4Qjs7O0lBRUosSUFBSTh2QyxJQUFJLEdBQUdJLElBQUksQ0FBQyxDQUFELENBQWY7UUFBb0JILElBQUksR0FBR0csSUFBSSxDQUFDLENBQUQsQ0FBL0I7SUFDQSxJQUFJQyxXQUFXLEdBQUdYLFdBQVcsQ0FBQ00sSUFBRCxDQUE3QjtJQUNBLElBQUlNLFdBQVcsR0FBR1osV0FBVyxDQUFDTyxJQUFELENBQTdCO0lBQ0FMLGFBQWEsQ0FBQ1MsV0FBRCxDQUFiO0lBQ0FULGFBQWEsQ0FBQ1UsV0FBRCxDQUFiLENBWmM7O0lBY2QsT0FBT0gsS0FBSyxDQUFDRSxXQUFXLEdBQUdDLFdBQWYsRUFBNEJmLEtBQUssQ0FBQ25sRCxJQUFJLENBQUNrVyxHQUFMLENBQVMsRUFBVCxFQUFha3ZDLFdBQVcsQ0FBQ1MsSUFBRCxDQUFYLEdBQW9CVCxXQUFXLENBQUNRLElBQUQsQ0FBNUMsQ0FBRCxDQUFqQyxDQUFaO0VBQ0g7RUFDRDtFQUNBO0VBQ0E7OztFQUNBLFNBQVM3bEIsS0FBVCxDQUFleGdCLEdBQWYsRUFBb0JnbkMsS0FBcEIsRUFBMkI7SUFDdkIsSUFBSUMsSUFBSSxHQUFHeG1ELElBQUksQ0FBQ2tXLEdBQUwsQ0FBUyxFQUFULEVBQWFxd0MsS0FBYixDQUFYO0lBQ0EsSUFBSWw5QyxNQUFNLEdBQUd5TSxRQUFNLENBQUM5VixJQUFJLENBQUMrL0IsS0FBTCxDQUFXLy9CLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzZ1QyxLQUFLLENBQUN4bUMsR0FBRCxFQUFNaW5DLElBQU4sQ0FBZCxDQUFYLENBQUQsRUFBeUNBLElBQXpDLENBQW5COztJQUNBLElBQUlqbkMsR0FBRyxHQUFHLENBQU4sSUFBV2xXLE1BQU0sS0FBSyxDQUExQixFQUE2QjtNQUN6QkEsTUFBTSxHQUFHMDhDLEtBQUssQ0FBQzE4QyxNQUFELEVBQVMsQ0FBQyxDQUFWLENBQWQ7OztJQUVKLE9BQU9BLE1BQVA7RUFDSDs7RUFDRCxJQUFJbzhDLHNCQUFzQixHQUFHLElBQTdCO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBQ0EsU0FBU2dCLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzQztJQUNsQyxJQUFJQSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtNQUFFQSxJQUFJLEdBQUcsSUFBUDs7O0lBQ3ZCakIsc0JBQXNCLEdBQUdpQixJQUF6QjtFQUNIOztFQUNELElBQUlqK0MsS0FBSyxHQUFHO0lBQ1IwOEMsS0FBSyxFQUFFQSxLQURDO0lBRVJrQixJQUFJLEVBQUVBLElBRkU7SUFHUkMsS0FBSyxFQUFFQSxLQUhDO0lBSVJQLEtBQUssRUFBRUEsS0FKQztJQUtSandDLE1BQU0sRUFBRUEsUUFMQTtJQU1SaXFCLEtBQUssRUFBRUEsS0FOQztJQU9ScWxCLFdBQVcsRUFBRUEsV0FQTDtJQVFSRSxXQUFXLEVBQUVBLFdBUkw7SUFTUm1CLHNCQUFzQixFQUFFQTtFQVRoQixDQUFaOzs7O01DMUlNRTs7Ozs7SUFtSUosb0JBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtoSCxLQUFMLEdBQWEsR0FBYjtNQUNBLE1BQUtFLE1BQUwsR0FBYyxFQUFkO01BQ0EsTUFBSytHLE9BQUwsR0FBZSxLQUFmO01BQ0EsTUFBS0MsSUFBTCxHQUFZLENBQUMveUMsUUFBYjtNQUNBLE1BQUtnekMsSUFBTCxHQUFZLENBQUNoekMsUUFBYjtNQUNBLE1BQUtpekMsTUFBTCxHQUFjLENBQWQ7TUFDQSxNQUFLQyxhQUFMLEdBQXFCLEdBQXJCLENBVFk7Ozs7O01BZ0JaLE1BQUtDLGFBQUwsR0FBcUIsS0FBckI7TUFFQSxNQUFLQyxhQUFMLEdBQXFCLE1BQUtDLHNCQUFMLENBQTRCLENBQTVCLENBQXJCO01BQ0EsTUFBS0MsY0FBTCxHQUFzQixNQUFLRCxzQkFBTCxDQUE0QixHQUE1QixDQUF0QjtNQUNBLE1BQUtFLGVBQUwsR0FBdUIsTUFBS0Ysc0JBQUwsQ0FBNEIsSUFBNUIsQ0FBdkI7TUFDQSxNQUFLRyxnQkFBTCxHQUF3QixNQUFLSCxzQkFBTCxDQUE0QixLQUE1QixDQUF4QjtNQUNBLE1BQUtJLGlCQUFMLEdBQXlCLE1BQUtKLHNCQUFMLENBQTRCLE1BQTVCLENBQXpCO01BQ0EsTUFBS0ssa0JBQUwsR0FBMEIsTUFBS0wsc0JBQUwsQ0FBNEIsT0FBNUIsQ0FBMUI7TUFDQSxNQUFLTSxtQkFBTCxHQUEyQixNQUFLTixzQkFBTCxDQUE0QixRQUE1QixDQUEzQjtNQUdBLE1BQUtPLGNBQUwsR0FBc0IsQ0FBdEI7TUFDQSxNQUFLQyxTQUFMLEdBQWlCLE1BQUtBLFNBQUwsQ0FBZTcxQyxJQUFmLCtCQUFqQjtNQTVCWTs7O0VBZ0NoQjtFQUNBO0VBQ0E7Ozs7O1dBakVFLGVBQVU7UUFDUixPQUFPLEtBQUsrMEMsSUFBWjs7V0FWRixhQUFReGtELEtBQVIsRUFBZTtRQUNiLEtBQUt3a0QsSUFBTCxHQUFZN21ELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU2pHLEtBQVQsRUFBZ0IsS0FBS3lrRCxJQUFyQixDQUFaOztRQUVBLElBQUksS0FBS0MsTUFBTCxHQUFjLEtBQUtGLElBQXZCLEVBQTZCO1VBQzNCLEtBQUt4a0QsS0FBTCxHQUFhLEtBQUt3a0QsSUFBbEI7O1VBQ0EsS0FBS2UsV0FBTDs7Ozs7V0FpQkosZUFBVTtRQUNSLE9BQU8sS0FBS2QsSUFBWjs7V0FWRixhQUFRemtELEtBQVIsRUFBZTtRQUNiLEtBQUt5a0QsSUFBTCxHQUFZOW1ELElBQUksQ0FBQ3dJLEdBQUwsQ0FBU25HLEtBQVQsRUFBZ0IsS0FBS3drRCxJQUFyQixDQUFaOztRQUVBLElBQUksS0FBS0UsTUFBTCxHQUFjLEtBQUtELElBQXZCLEVBQTZCO1VBQzNCLEtBQUt6a0QsS0FBTCxHQUFhLEtBQUt5a0QsSUFBbEI7O1VBQ0EsS0FBS2MsV0FBTDs7Ozs7V0FrQkosZUFBWTtRQUNWLE9BQU8sS0FBS2IsTUFBWjs7V0FYRixhQUFVcGxELEdBQVYsRUFBZTtRQUNiQSxHQUFHLEdBQUczQixJQUFJLENBQUNzSSxHQUFMLENBQVMsS0FBS3crQyxJQUFkLEVBQW9COW1ELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxLQUFLcStDLElBQWQsRUFBb0JsbEQsR0FBcEIsQ0FBcEIsQ0FBTjs7UUFFQSxJQUFJQSxHQUFHLEtBQUssS0FBS29sRCxNQUFqQixFQUF5QjtVQUN2QixLQUFLQSxNQUFMLEdBQWNwbEQsR0FBZDtVQUNBLEtBQUtxbEQsYUFBTCxHQUFxQnJsRCxHQUFHLENBQUNDLFFBQUosRUFBckI7VUFDQSxLQUFLcTNDLGFBQUw7Ozs7O2FBMkNKLGtCQUFTO1FBQ1AsSUFBTWxKLEtBQUssR0FBRyxLQUFLaVgsYUFBTCxDQUFtQnJqRCxLQUFuQixDQUF5QixHQUF6QixDQUFkOztRQUVBLElBQUksQ0FBQ29zQyxLQUFLLENBQUMsQ0FBRCxDQUFWLEVBQWU7VUFDYkEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEVBQVg7OztRQUdGLElBQU04WCxVQUFVLEdBQUcsR0FBbkI7UUFDQSxJQUFNQyxjQUFjLEdBQUcsQ0FBdkIsQ0FSTzs7UUFVUCxJQUFNQyxRQUFRLEdBQUc7VUFBRUMsTUFBTSxFQUFHLEtBQUtOLGNBQUwsS0FBd0I7U0FBcEQ7UUFFQSxPQUFPbG1DLEdBQVAsKzdCQUtlLEtBQUttK0IsS0FMcEIsRUFNZ0IsS0FBS0UsTUFOckIsRUFRYyxLQUFLb0ksT0FSbkIsRUFTYSxLQUFLQyxNQVRsQixFQVVtQixLQUFLQyxZQVZ4QixFQVdvQixLQUFLcEksbUJBWHpCLEVBY29CNkUsR0FBUSxDQUFDbUQsUUFBRCxDQWQ1QixFQWV1QixLQUFLbEksTUFmNUIsRUFvQnVCLEtBQUtBLE1BcEI1QixFQXlCb0IsS0FBS0EsTUF6QnpCLEVBMEJ5QixLQUFLQSxNQTFCOUIsRUEyQm1CaUksY0FBYyxHQUFHL1gsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMXJDLE1BM0I3QyxFQThCVTByQyxLQUFLLENBQUMsQ0FBRCxDQTlCZixFQWdDbUIrWCxjQUFjLEdBQUc5bkQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTdW5DLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzFyQyxNQUFsQixFQUEwQixDQUExQixDQWhDcEMsRUFpQ29CLEtBQUt3N0MsTUFqQ3pCLEVBa0NvQixLQUFLcUgsYUFsQ3pCLEVBcUNRLENBQUMsS0FBS04sT0FBTixHQUNFcGxDLEdBREYsd3NGQUVtQyxLQUFLcStCLE1BRnhDLEVBRWtFLEtBQUtBLE1BRnZFLEVBT2dCLEtBQUtBLE1BUHJCLEVBUXFCLEtBQUtBLE1BUjFCLEVBU2VpSSxjQVRmLEVBWU0vWCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMsQ0FBVCxLQUFlOFgsVUFackIsRUFjZUMsY0FkZixFQWVnQixLQUFLakksTUFmckIsRUFnQmdCLEtBQUt1SCxjQWhCckIsRUFxQmdCLEtBQUt2SCxNQXJCckIsRUFzQnFCLEtBQUtBLE1BdEIxQixFQXVCZWlJLGNBdkJmLEVBMEJNL1gsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTLENBQVQsS0FBZThYLFVBMUJyQixFQTRCZUMsY0E1QmYsRUE2QmdCLEtBQUtqSSxNQTdCckIsRUE4QmdCLEtBQUt3SCxlQTlCckIsRUFtQ2dCLEtBQUt4SCxNQW5DckIsRUFvQ3FCLEtBQUtBLE1BcEMxQixFQXFDZWlJLGNBckNmLEVBd0NNL1gsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTLENBQVQsS0FBZThYLFVBeENyQixFQTBDZUMsY0ExQ2YsRUEyQ2dCLEtBQUtqSSxNQTNDckIsRUE0Q2dCLEtBQUt5SCxnQkE1Q3JCLEVBaURnQixLQUFLekgsTUFqRHJCLEVBa0RxQixLQUFLQSxNQWxEMUIsRUFtRGVpSSxjQW5EZixFQXNETS9YLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUyxDQUFULEtBQWU4WCxVQXREckIsRUF3RGVDLGNBeERmLEVBeURnQixLQUFLakksTUF6RHJCLEVBMERnQixLQUFLMEgsaUJBMURyQixFQStEZ0IsS0FBSzFILE1BL0RyQixFQWdFcUIsS0FBS0EsTUFoRTFCLEVBaUVlaUksY0FqRWYsRUFvRU0vWCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMsQ0FBVCxLQUFlOFgsVUFwRXJCLEVBc0VlQyxjQXRFZixFQXVFZ0IsS0FBS2pJLE1BdkVyQixFQXdFZ0IsS0FBSzJILGtCQXhFckIsRUE2RWdCLEtBQUszSCxNQTdFckIsRUE4RXFCLEtBQUtBLE1BOUUxQixFQStFZWlJLGNBL0VmLEVBa0ZNL1gsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTLENBQVQsS0FBZThYLFVBbEZyQixFQW9GZUMsY0FwRmYsRUFxRmdCLEtBQUtqSSxNQXJGckIsRUFzRmdCLEtBQUs0SCxtQkF0RnJCLElBeUZFbFosR0E5SFY7Ozs7O2FBcUlGLHdCQUFlO1FBQ2IsSUFBTTZaLFVBQVUsR0FBRyxLQUFLek8sVUFBTCxDQUFnQjBPLGFBQWhCLENBQThCLFlBQTlCLENBQW5CO1FBQ0FELFVBQVUsQ0FBQ0UsS0FBWDs7Ozs7YUFJRixtQkFBVTtRQUNSLEtBQUtaLGNBQUwsR0FBc0IsQ0FBdEI7UUFDQTNuRCxNQUFNLENBQUNzc0IsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsS0FBS3M3QixTQUF4Qzs7OzthQUdGLGtCQUFTO1FBQ1AsS0FBS1ksMkJBQUw7UUFDQXhvRCxNQUFNLENBQUMyMUMsbUJBQVAsQ0FBMkIsU0FBM0IsRUFBc0MsS0FBS2lTLFNBQTNDOzs7O2FBR0YsbUJBQVVsbkQsQ0FBVixFQUFhO1FBQ1gsSUFBTStuRCxZQUFZLEdBQUcsS0FBSzVCLE9BQUwsR0FDakIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IsR0FBL0IsRUFBb0MsR0FBcEMsRUFBeUMsR0FBekMsRUFBOEMsR0FBOUMsRUFBbUQsR0FBbkQsQ0FEaUIsR0FFakIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IsR0FBL0IsRUFBb0MsR0FBcEMsRUFBeUMsR0FBekMsRUFBOEMsR0FBOUMsRUFBbUQsR0FBbkQsRUFBd0QsR0FBeEQsRUFBNkQsR0FBN0QsQ0FGSjs7UUFJQSxJQUFJNEIsWUFBWSxDQUFDbHJDLE9BQWIsQ0FBcUI3YyxDQUFDLENBQUNILEdBQXZCLE1BQWdDLENBQUMsQ0FBckMsRUFBd0M7VUFDdEMsSUFBSSxLQUFLb25ELGNBQUwsS0FBd0IsQ0FBNUIsRUFBK0I7WUFDN0IsS0FBS1YsYUFBTCxHQUFxQixFQUFyQjs7O1VBR0YsSUFBSXlCLE1BQU0sR0FBR2hvRCxDQUFDLENBQUNILEdBQWY7O1VBRUEsSUFBSW1vRCxNQUFNLEtBQUssR0FBZixFQUFvQjtZQUNsQkEsTUFBTSxHQUFHLEdBQVQ7OztVQUdGLEtBQUt6QixhQUFMLElBQXNCeUIsTUFBdEI7VUFDQSxLQUFLZixjQUFMLElBQXVCLENBQXZCO1VBRUEsS0FBS3pPLGFBQUw7U0FuQlM7OztRQXVCWCxJQUFJeDRDLENBQUMsQ0FBQ0gsR0FBRixLQUFVLFdBQVYsSUFBeUJHLENBQUMsQ0FBQ2lvRCxLQUFGLEtBQVksQ0FBekMsRUFBNEM7O1VBRTFDLElBQUksS0FBSzFCLGFBQUwsQ0FBbUIsS0FBS0EsYUFBTCxDQUFtQjNpRCxNQUFuQixHQUEyQixDQUE5QyxNQUFxRCxHQUF6RCxFQUE4RDtZQUM1RCxLQUFLMmlELGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQjJCLFNBQW5CLENBQTZCLENBQTdCLEVBQWdDLEtBQUszQixhQUFMLENBQW1CM2lELE1BQW5CLEdBQTRCLENBQTVELENBQXJCOzs7VUFHRixLQUFLMmlELGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQjJCLFNBQW5CLENBQTZCLENBQTdCLEVBQWdDLEtBQUszQixhQUFMLENBQW1CM2lELE1BQW5CLEdBQTRCLENBQTVELENBQXJCO1VBRUEsS0FBS3FqRCxjQUFMLElBQXVCLENBQXZCO1VBQ0EsS0FBS3pPLGFBQUw7U0FoQ1M7OztRQW9DWCxJQUFJeDRDLENBQUMsQ0FBQ0gsR0FBRixLQUFVLE9BQVYsSUFBcUJHLENBQUMsQ0FBQ2lvRCxLQUFGLEtBQVksRUFBckMsRUFBeUM7VUFDdkMsS0FBS0gsMkJBQUw7Ozs7O2FBSUosdUNBQThCO1FBQzVCLElBQUksS0FBS2IsY0FBTCxHQUFzQixDQUExQixFQUE2QjtVQUMzQixLQUFLWCxNQUFMLEdBQWMsS0FBS0gsT0FBTCxHQUNWdHpDLFFBQVEsQ0FBQyxLQUFLMHpDLGFBQU4sQ0FERSxHQUVWbnpDLFVBQVUsQ0FBQyxLQUFLbXpDLGFBQU4sQ0FGZCxDQUQyQjs7VUFNM0IsSUFBSSxLQUFLRCxNQUFMLEdBQWMsS0FBS0YsSUFBbkIsSUFBMkIsS0FBS0UsTUFBTCxHQUFjLEtBQUtELElBQWxELEVBQXdEO1lBQ3RELEtBQUtDLE1BQUwsR0FBYy9tRCxJQUFJLENBQUN3SSxHQUFMLENBQVMsS0FBS3ErQyxJQUFkLEVBQW9CN21ELElBQUksQ0FBQ3NJLEdBQUwsQ0FBUyxLQUFLdytDLElBQWQsRUFBb0IsS0FBS0MsTUFBekIsQ0FBcEIsQ0FBZDtZQUNBLEtBQUtDLGFBQUwsR0FBcUIsS0FBS0QsTUFBTCxDQUFZbmxELFFBQVosRUFBckI7OztVQUdGLEtBQUs4bEQsY0FBTCxHQUFzQixDQUF0Qjs7VUFFQSxLQUFLa0IsVUFBTDs7VUFDQSxLQUFLaEIsV0FBTDs7VUFDQSxLQUFLM08sYUFBTDs7Ozs7YUFJSixnQ0FBdUJoNEIsSUFBdkIsRUFBNkI7UUFBQTs7UUFDM0IsT0FBTyxVQUFBeGdCLENBQUMsRUFBSTtVQUNWQSxDQUFDLENBQUM0aUQsZUFBRixHQURVOzs7VUFLVixJQUFJNWlELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNDLFNBQVQsS0FBdUIsSUFBM0IsRUFBaUM7O1lBRS9CLElBQUl2Z0QsSUFBSSxDQUFDa1gsR0FBTCxDQUFTelcsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBUzJCLEVBQWxCLElBQXdCLElBQTVCLEVBQWtDO2NBQ2hDOzs7WUFHRixJQUFNNEcsU0FBUyxHQUFHLE1BQUksQ0FBQzlCLE1BQXZCO1lBRUEsSUFBTS91QyxJQUFJLEdBQUd2WCxDQUFDLENBQUM2L0MsTUFBRixDQUFTMkIsRUFBVCxHQUFjLENBQWQsR0FBa0IsQ0FBQyxDQUFuQixHQUF1QixDQUFwQyxDQVIrQjs7WUFVL0IsSUFBTTBCLEtBQUssR0FBRyxDQUFkO1lBQ0EsSUFBTW1GLFFBQVEsR0FBRyxHQUFqQixDQVgrQjs7WUFhL0IsSUFBSTdHLEVBQUUsR0FBR2ppRCxJQUFJLENBQUNrVyxHQUFMLENBQVNsVyxJQUFJLENBQUNrWCxHQUFMLENBQVN6VyxDQUFDLENBQUM2L0MsTUFBRixDQUFTMkIsRUFBVCxHQUFjMEIsS0FBdkIsQ0FBVCxFQUF3Q21GLFFBQXhDLENBQVQsQ0FiK0I7O1lBZS9CN0csRUFBRSxHQUFHamlELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVl5NUMsRUFBWixDQUFMLENBZitCOztZQWlCL0JBLEVBQUUsR0FBR0EsRUFBRSxHQUFHanFDLElBQVY7WUFFQSxNQUFJLENBQUMrdUMsTUFBTCxJQUFlOWxDLElBQUksR0FBR2doQyxFQUF0QixDQW5CK0I7O1lBcUIvQixNQUFJLENBQUM4RSxNQUFMLEdBQWNnQyxLQUFFLENBQUNoRCxLQUFILENBQVMvbEQsSUFBSSxDQUFDKy9CLEtBQUwsQ0FBVyxNQUFJLENBQUNnbkIsTUFBTCxHQUFjOWxDLElBQXpCLENBQVQsRUFBeUNBLElBQXpDLENBQWQ7WUFDQSxNQUFJLENBQUM4bEMsTUFBTCxHQUFjL21ELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxNQUFJLENBQUNxK0MsSUFBZCxFQUFvQjdtRCxJQUFJLENBQUNzSSxHQUFMLENBQVMsTUFBSSxDQUFDdytDLElBQWQsRUFBb0IsTUFBSSxDQUFDQyxNQUF6QixDQUFwQixDQUFkLENBdEIrQjs7WUF5Qi9CLElBQU1pQyxZQUFZLEdBQUcsTUFBSSxDQUFDakMsTUFBTCxDQUFZbmxELFFBQVosRUFBckI7O1lBQ0EsSUFBTXFuRCxVQUFVLEdBQUdELFlBQVksQ0FBQ3BuRCxRQUFiLEdBQXdCK0IsS0FBeEIsQ0FBOEIsR0FBOUIsQ0FBbkI7WUFDQSxJQUFNdWxELFlBQVksR0FBR2pvQyxJQUFJLENBQUNyZixRQUFMLEdBQWdCK0IsS0FBaEIsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBM0IsQ0FBckI7O1lBRUEsSUFBSXVsRCxZQUFKLEVBQWtCO2NBQ2hCLElBQUksQ0FBQ0QsVUFBVSxDQUFDLENBQUQsQ0FBZixFQUFvQjtnQkFDbEJBLFVBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0IsRUFBaEI7OztjQUdGLE9BQU9BLFVBQVUsQ0FBQyxDQUFELENBQVYsQ0FBYzVrRCxNQUFkLEdBQXVCNmtELFlBQVksQ0FBQzdrRCxNQUEzQyxFQUFtRDtnQkFDakQ0a0QsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQixHQUFqQjs7OztZQUlKLE1BQUksQ0FBQ2pDLGFBQUwsR0FBcUJpQyxVQUFVLENBQUNobEQsSUFBWCxDQUFnQixHQUFoQixDQUFyQjs7WUFFQSxJQUFJLE1BQUksQ0FBQzhpRCxNQUFMLEtBQWdCOEIsU0FBcEIsRUFBK0I7Y0FDN0IsTUFBSSxDQUFDNUIsYUFBTCxHQUFxQixJQUFyQjs7Y0FDQSxNQUFJLENBQUMyQixVQUFMOztXQTNDSixNQTZDTzs7WUFFTCxJQUFJLE1BQUksQ0FBQzNCLGFBQUwsS0FBdUIsSUFBM0IsRUFBaUM7Y0FDL0IsTUFBSSxDQUFDQSxhQUFMLEdBQXFCLEtBQXJCOztjQUNBLE1BQUksQ0FBQ1csV0FBTDs7OztVQUlKLE1BQUksQ0FBQzNPLGFBQUw7U0ExREY7Ozs7YUE4REYsc0JBQWE7UUFDWCxJQUFNbHRCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUI7VUFDckNDLE9BQU8sRUFBRSxJQUQ0QjtVQUVyQ0MsUUFBUSxFQUFFLElBRjJCO1VBR3JDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBSzBrRDs7U0FIVixDQUFkO1FBTUEsS0FBS3ZHLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7Ozs7YUFHRix1QkFBYztRQUNaLElBQU1BLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEI7VUFDdENDLE9BQU8sRUFBRSxJQUQ2QjtVQUV0Q0MsUUFBUSxFQUFFLElBRjRCO1VBR3RDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBSzBrRDs7U0FIVixDQUFkO1FBTUEsS0FBS3ZHLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7Ozs7V0FuZEYsZUFBd0I7UUFDdEIsT0FBTztVQUNMNHpCLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTtXQUxIO1VBT0x4TSxHQUFHLEVBQUU7WUFDSHpELElBQUksRUFBRWlRO1dBUkg7VUFVTHRNLEdBQUcsRUFBRTtZQUNIM0QsSUFBSSxFQUFFaVE7V0FYSDtVQWFMelMsS0FBSyxFQUFFO1lBQ0x3QyxJQUFJLEVBQUVpUTtXQWRIO1VBZ0JMOHhDLE9BQU8sRUFBRTtZQUNQL2hELElBQUksRUFBRWl6QyxPQURDO1lBRVBRLE9BQU8sRUFBRTs7U0FsQmI7Ozs7V0F1QkYsZUFBb0I7UUFDbEIsT0FBT3ZCLEdBQVAsMHdDQVV3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQVY3QixFQVd3QkEsS0FBSyxDQUFDLG1CQUFELENBWDdCLEVBWW1CRixVQVpuQixFQXdCd0JFLEtBQUssQ0FBQyxtQkFBRCxDQXhCN0IsRUE0QnlCQSxLQUFLLENBQUMscUJBQUQsQ0E1QjlCLEVBZ0N3QkEsS0FBSyxDQUFDLG1CQUFELENBaEM3QixFQWlEaUJELFFBakRqQjs7Ozs7SUExQm1COUQ7O0VBd2R2QmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLFdBQXRCLEVBQW1Dc2dDLFFBQW5DOzs7O01DdmRNd0M7Ozs7O0lBNEVKLG9CQUFjO01BQUE7O01BQUE7O01BQ1o7TUFFQSxNQUFLOWxELElBQUwsR0FBWSxNQUFaLENBSFk7O01BSVosTUFBS3M4QyxLQUFMLEdBQWEsR0FBYjtNQUNBLE1BQUtFLE1BQUwsR0FBYyxFQUFkO01BQ0EsTUFBS3YzQyxHQUFMLEdBQVcsQ0FBWDtNQUNBLE1BQUtFLEdBQUwsR0FBVyxDQUFYO01BQ0EsTUFBS3lZLElBQUwsR0FBWSxLQUFaO01BQ0EsTUFBSzVlLEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBSyttRCxXQUFMLEdBQW1CLFlBQW5CO01BQ0EsTUFBS0MsYUFBTCxHQUFxQixLQUFyQjtNQUNBLE1BQUtockMsS0FBTCxHQUFhK2pDLEtBQUssQ0FBQyxtQkFBRCxDQUFsQjtNQUVBLE1BQUtrSCxtQkFBTCxHQUEyQixDQUEzQjtNQUNBLE1BQUtDLFlBQUwsR0FBb0IsRUFBcEI7TUFFQSxNQUFLQyxVQUFMLEdBQWtCLElBQWxCO01BQ0EsTUFBS0MsTUFBTCxHQUFjLElBQWQ7TUFsQlk7Ozs7O2FBcUJkLDZCQUFvQjtRQUNsQixLQUFLQSxNQUFMLEdBQWMsSUFBZDs7UUFDQTs7OzthQUdGLGdCQUFPck8saUJBQVAsRUFBMEI7UUFDeEIsS0FBS3FPLE1BQUwsR0FBYyxJQUFkOztRQUNBLHFFQUFhck8saUJBQWI7Ozs7YUFHRixrQkFBUztRQUNQLElBQUksS0FBS3FPLE1BQVQsRUFBaUI7VUFDZixJQUFJLEtBQUtMLFdBQUwsS0FBcUIsWUFBekIsRUFBdUM7WUFDckMsS0FBS00sWUFBTCxHQUFvQixLQUFLTCxhQUFMLEdBQ2hCLEtBQUsxSixLQUFMLEdBQWEsS0FBSzRKLFlBQWxCLEdBQWlDLEtBQUtELG1CQUR0QixHQUVoQixLQUFLM0osS0FGVDtXQURGLE1BSU87O1lBRUwsS0FBSytKLFlBQUwsR0FBb0IsS0FBSy9KLEtBQXpCOzs7VUFHRixLQUFLK0osWUFBTCxJQUFxQixDQUFyQixDQVZlOztVQVdmLEtBQUtDLGFBQUwsR0FBcUIsS0FBSzlKLE1BQUwsR0FBYyxDQUFuQyxDQVhlOztVQWFmLElBQUksS0FBS3IzQyxHQUFMLEdBQVcsS0FBS0YsR0FBcEIsRUFBeUI7WUFDdkIsSUFBTXNoRCxHQUFHLEdBQUcsS0FBS3BoRCxHQUFqQjtZQUNBLEtBQUtBLEdBQUwsR0FBVyxLQUFLRixHQUFoQjtZQUNBLEtBQUtBLEdBQUwsR0FBV3NoRCxHQUFYO1dBaEJhOzs7VUFvQmYsS0FBS2pHLEtBQUwsR0FBYUosUUFBUSxDQUNuQixDQUFDLEtBQUtqN0MsR0FBTixFQUFXLEtBQUtFLEdBQWhCLENBRG1CLEVBRW5CLENBQUMsQ0FBRCxFQUFJLEtBQUs0Z0QsV0FBTCxLQUFxQixZQUFyQixHQUFvQyxLQUFLTSxZQUF6QyxHQUF3RCxLQUFLQyxhQUFqRSxDQUZtQixDQUFyQjtVQUtBLEtBQUtFLE9BQUwsR0FBZWhHLFVBQVUsQ0FBQyxLQUFLdjdDLEdBQU4sRUFBVyxLQUFLRSxHQUFoQixFQUFxQixLQUFLeVksSUFBMUIsQ0FBekIsQ0F6QmU7O1VBNEJmLEtBQUs1ZSxLQUFMLEdBQWEsS0FBS3duRCxPQUFMLENBQWEsS0FBS3huRCxLQUFsQixDQUFiO1VBRUEsS0FBS29uRCxNQUFMLEdBQWMsS0FBZDs7O1FBR0YsT0FBT2pvQyxHQUFQLHlsQkFFb0IsS0FBS3UrQixtQkFGekIsRUFHb0IsS0FBSzJKLFlBSHpCLEVBR29ELEtBQUtDLGFBSHpELEVBTXNCLEtBQUtELFlBTjNCLEVBTXNELEtBQUtDLGFBTjNELEVBT3NCLEtBQUtELFlBUDNCLEVBTzJDLEtBQUtDLGFBUGhELEVBU1EsS0FBS1AsV0FBTCxLQUFxQixZQUFyQixHQUNBaGIsQ0FEQSwwUUFFb0MsS0FBS3NiLFlBRnpDLEVBRWtFLEtBQUtDLGFBRnZFLEVBR29DM3BELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBS203QyxLQUFMLENBQVcsS0FBS3RoRCxLQUFoQixDQUFaLENBSHBDLEVBR29GLEtBQUtzbkQsYUFIekYsRUFHaUgsS0FBS3RyQyxLQUh0SCxJQUtBK3ZCLENBTEEsMFFBTW9DLEtBQUtzYixZQU56QyxFQU1rRSxLQUFLQyxhQU52RSxFQU0rRixLQUFLdHJDLEtBTnBHLEVBT29DLEtBQUtxckMsWUFQekMsRUFPa0UxcEQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLbWhELGFBQUwsR0FBcUIsS0FBS2hHLEtBQUwsQ0FBVyxLQUFLdGhELEtBQWhCLENBQWpDLENBUGxFLENBVFIsRUFxQmUsS0FBS3FuRCxZQXJCcEIsRUFzQmdCLEtBQUtDLGFBdEJyQixFQXdCaUIzOUMsSUFBSSxDQUFDRSxTQUFMLENBQWUsQ0FBQyxLQUFLNUQsR0FBTixFQUFXLEtBQUtFLEdBQWhCLENBQWYsQ0F4QmpCLEVBeUJpQndELElBQUksQ0FBQ0UsU0FBTCxDQUFlLENBQUMsS0FBSzFELEdBQU4sRUFBVyxLQUFLRixHQUFoQixDQUFmLENBekJqQixFQTBCZ0IsS0FBSzI2QyxXQTFCckIsRUEyQnFCLEtBQUs2RyxXQTNCMUIsRUE4QkksS0FBS1QsYUFBTCxHQUNFN25DLEdBREYseVRBRzBCLEtBQUs4bkMsbUJBSC9CLEVBSWEsS0FBS0MsWUFKbEIsRUFLVyxLQUFLamhELEdBTGhCLEVBTVcsS0FBS0UsR0FOaEIsRUFPYSxLQUFLbkcsS0FQbEIsRUFRYyxLQUFLMG5ELHFCQVJuQixJQVdFeGIsR0F6Q047Ozs7YUE4Q0YsK0JBQXNCOXRDLENBQXRCLEVBQXlCO1FBQ3ZCQSxDQUFDLENBQUM0aUQsZUFBRjtRQUVBLEtBQUtoaEQsS0FBTCxHQUFhLEtBQUt3bkQsT0FBTCxDQUFhcHBELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBdEIsQ0FBYjtRQUVBLElBQU15Z0QsVUFBVSxHQUFHLElBQUkzQyxXQUFKLENBQWdCLE9BQWhCLEVBQXlCO1VBQzFDQyxPQUFPLEVBQUUsSUFEaUM7VUFFMUNDLFFBQVEsRUFBRSxJQUZnQztVQUcxQ0MsTUFBTSxFQUFFO1lBQUVqK0MsS0FBSyxFQUFFLEtBQUtBOztTQUhMLENBQW5CO1FBTUEsS0FBS20rQyxhQUFMLENBQW1Cc0MsVUFBbkI7UUFFQSxJQUFNUSxXQUFXLEdBQUcsSUFBSW5ELFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEI7VUFDNUNDLE9BQU8sRUFBRSxJQURtQztVQUU1Q0MsUUFBUSxFQUFFLElBRmtDO1VBRzVDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1NBSEosQ0FBcEI7UUFNQSxLQUFLbStDLGFBQUwsQ0FBbUI4QyxXQUFuQjtRQUVBLEtBQUtySyxhQUFMOzs7O2FBR0YscUJBQVl4NEMsQ0FBWixFQUFlO1FBQ2IsSUFBSUEsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU0MsU0FBVCxLQUF1QixLQUFLaUosVUFBaEMsRUFBNEM7VUFDMUMsS0FBS0EsVUFBTCxHQUFrQixJQUFsQjtVQUVBLElBQU16OUIsS0FBSyxHQUFHLElBQUlvMEIsV0FBSixDQUFnQixRQUFoQixFQUEwQjtZQUN0Q0MsT0FBTyxFQUFFLElBRDZCO1lBRXRDQyxRQUFRLEVBQUUsSUFGNEI7WUFHdENDLE1BQU0sRUFBRTtjQUFFaitDLEtBQUssRUFBRSxLQUFLQTs7V0FIVixDQUFkO1VBTUEsS0FBS20rQyxhQUFMLENBQW1CejBCLEtBQW5COzs7OzthQUlKLHFCQUFZdHJCLENBQVosRUFBZTtRQUNiQSxDQUFDLENBQUM0aUQsZUFBRixHQURhOzs7UUFJYixJQUNFNWlELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBVCxDQUFlLENBQWYsTUFDQyxLQUFLbW5ELFVBQUwsS0FBb0IsSUFBcEIsSUFBNEIvb0QsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFULENBQWUsQ0FBZixFQUFrQmsrQyxTQUFsQixLQUFnQyxLQUFLaUosVUFEbEUsQ0FERixFQUdFO1VBQ0EsdUJBQTRCL29ELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBVCxDQUFlLENBQWYsQ0FBNUI7Y0FBUXVPLENBQVIsb0JBQVFBLENBQVI7Y0FBV0MsQ0FBWCxvQkFBV0EsQ0FBWDtjQUFjMHZDLFNBQWQsb0JBQWNBLFNBQWQ7VUFDQSxJQUFNbCtDLEtBQUssR0FBRyxLQUFLK21ELFdBQUwsS0FBcUIsWUFBckIsR0FBb0N4NEMsQ0FBcEMsR0FBd0NDLENBQXREO1VBQ0EsS0FBSzI0QyxVQUFMLEdBQWtCakosU0FBbEI7VUFDQSxLQUFLbCtDLEtBQUwsR0FBYSxLQUFLd25ELE9BQUwsQ0FBYXhuRCxLQUFiLENBQWI7VUFFQSxJQUFNMHBCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUI7WUFDckNDLE9BQU8sRUFBRSxJQUQ0QjtZQUVyQ0MsUUFBUSxFQUFFLElBRjJCO1lBR3JDQyxNQUFNLEVBQUU7Y0FBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1dBSFYsQ0FBZDtVQU1BLEtBQUttK0MsYUFBTCxDQUFtQnowQixLQUFuQjtVQUNBLEtBQUtrdEIsYUFBTDs7Ozs7V0FwUEosZUFBd0I7UUFDdEIsT0FBTzs7OztVQUlMMEcsS0FBSyxFQUFFO1lBQ0w5NkMsSUFBSSxFQUFFaVE7V0FMSDtVQU9MK3FDLE1BQU0sRUFBRTtZQUNOaDdDLElBQUksRUFBRWlRO1dBUkg7VUFVTHhNLEdBQUcsRUFBRTtZQUNIekQsSUFBSSxFQUFFaVE7V0FYSDtVQWFMdE0sR0FBRyxFQUFFO1lBQ0gzRCxJQUFJLEVBQUVpUTtXQWRIO1VBZ0JMbU0sSUFBSSxFQUFFO1lBQ0pwYyxJQUFJLEVBQUVpUTtXQWpCSDtVQW1CTHMwQyxXQUFXLEVBQUU7WUFDWHZrRCxJQUFJLEVBQUVYO1dBcEJIO1VBc0JMbWxELGFBQWEsRUFBRTtZQUNieGtELElBQUksRUFBRWl6QyxPQURPO1lBRWJsNkIsU0FBUyxFQUFFLGdCQUZFO1lBR2IwNkIsT0FBTyxFQUFFO1dBekJOO1VBMkJMajJDLEtBQUssRUFBRTtZQUNMd0MsSUFBSSxFQUFFaVE7V0E1Qkg7VUE4Qkx1SixLQUFLLEVBQUU7WUFDTHhaLElBQUksRUFBRVg7O1NBL0JWOzs7O1dBb0NGLGVBQW9CO1FBQ2xCLE9BQU82eUMsR0FBUCx5dUJBY3dCcUwsS0FBSyxDQUFDLG1CQUFELENBZDdCLEVBNEJZQSxLQUFLLENBQUMsbUJBQUQsQ0E1QmpCOzs7OztJQXZDbUIvRDs7RUEwUHZCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUM4aUMsUUFBbkM7Ozs7Ozs7Ozs7SUN6UEMsV0FBVXRwRCxNQUFWLEVBQWtCbXFELE9BQWxCLEVBQTJCO01BQzFCLENBQStEbHFELGNBQUEsR0FBaUJrcUQsT0FBTyxFQUF2RixDQUFBO0tBREQsRUFJQ2xhLGNBSkQsRUFJUSxZQUFZOzs7TUFJbkIsSUFBSXJoQixTQUFTLEdBQUdoQixTQUFTLENBQUNnQixTQUExQjtNQUNBLElBQUl3N0IsUUFBUSxHQUFHeDhCLFNBQVMsQ0FBQ3c4QixRQUF6QjtNQUVBLElBQUlDLEtBQUssR0FBRyxhQUFhajVDLElBQWIsQ0FBa0J3ZCxTQUFsQixDQUFaO01BQ0EsSUFBSTA3QixTQUFTLEdBQUcsVUFBVWw1QyxJQUFWLENBQWV3ZCxTQUFmLENBQWhCO01BQ0EsSUFBSTI3QixPQUFPLEdBQUcsd0NBQXdDNXBELElBQXhDLENBQTZDaXVCLFNBQTdDLENBQWQ7TUFDQSxJQUFJNDdCLElBQUksR0FBRyxjQUFjN3BELElBQWQsQ0FBbUJpdUIsU0FBbkIsQ0FBWDtNQUNBLElBQUk2N0IsRUFBRSxHQUFHSCxTQUFTLElBQUlDLE9BQWIsSUFBd0JDLElBQWpDO01BQ0EsSUFBSUUsVUFBVSxHQUFHRCxFQUFFLEtBQUtILFNBQVMsR0FBRy9vRCxRQUFRLENBQUNvcEQsWUFBVCxJQUF5QixDQUE1QixHQUFnQyxDQUFDLENBQUNILElBQUksSUFBSUQsT0FBVCxFQUFrQixDQUFsQixDQUEvQyxDQUFuQjtNQUNBLElBQUlLLE1BQU0sR0FBRyxDQUFDSixJQUFELElBQVMsV0FBV3A1QyxJQUFYLENBQWdCd2QsU0FBaEIsQ0FBdEI7TUFDQSxJQUFJaThCLFFBQVEsR0FBR0QsTUFBTSxJQUFJLGVBQWV4NUMsSUFBZixDQUFvQndkLFNBQXBCLENBQXpCO01BQ0EsSUFBSWs4QixNQUFNLEdBQUcsQ0FBQ04sSUFBRCxJQUFTLFdBQVdwNUMsSUFBWCxDQUFnQndkLFNBQWhCLENBQXRCO01BQ0EsSUFBSW04QixNQUFNLEdBQUcsVUFBVTM1QyxJQUFWLENBQWV3ZCxTQUFmLENBQWI7TUFDQSxJQUFJbzhCLE1BQU0sR0FBRyxpQkFBaUI1NUMsSUFBakIsQ0FBc0J3YyxTQUFTLENBQUNxOUIsTUFBaEMsQ0FBYjtNQUNBLElBQUlDLGtCQUFrQixHQUFHLCtCQUErQjk1QyxJQUEvQixDQUFvQ3dkLFNBQXBDLENBQXpCO01BQ0EsSUFBSXU4QixPQUFPLEdBQUcsWUFBWS81QyxJQUFaLENBQWlCd2QsU0FBakIsQ0FBZDtNQUVBLElBQUl3OEIsR0FBRyxHQUFHSixNQUFNLEtBQUssY0FBYzU1QyxJQUFkLENBQW1Cd2QsU0FBbkIsS0FBaUNoQixTQUFTLENBQUN5OUIsY0FBVixHQUEyQixDQUFqRSxDQUFoQjtNQUNBLElBQUlDLE9BQU8sR0FBRyxVQUFVbDZDLElBQVYsQ0FBZXdkLFNBQWYsQ0FBZCxDQXRCbUI7O01Bd0JuQixJQUFJMjhCLE1BQU0sR0FBR0gsR0FBRyxJQUFJRSxPQUFQLElBQWtCLG1EQUFtRGw2QyxJQUFuRCxDQUF3RHdkLFNBQXhELENBQS9CO01BQ0EsSUFBSTQ4QixHQUFHLEdBQUdKLEdBQUcsSUFBSSxNQUFNaDZDLElBQU4sQ0FBV2c1QyxRQUFYLENBQWpCO01BQ0EsSUFBSXFCLFFBQVEsR0FBRyxXQUFXcjZDLElBQVgsQ0FBZ0J3ZCxTQUFoQixDQUFmO01BQ0EsSUFBSTg4QixPQUFPLEdBQUcsT0FBT3Q2QyxJQUFQLENBQVlnNUMsUUFBWixDQUFkO01BRUEsSUFBSXVCLGNBQWMsR0FBR1osTUFBTSxJQUFJbjhCLFNBQVMsQ0FBQ3BjLEtBQVYsQ0FBZ0IscUJBQWhCLENBQS9COztNQUNBLElBQUltNUMsY0FBSixFQUFvQjtRQUFFQSxjQUFjLEdBQUcxMkMsTUFBTSxDQUFDMDJDLGNBQWMsQ0FBQyxDQUFELENBQWYsQ0FBdkI7OztNQUN0QixJQUFJQSxjQUFjLElBQUlBLGNBQWMsSUFBSSxFQUF4QyxFQUE0QztRQUFFWixNQUFNLEdBQUcsS0FBVDtRQUFnQkgsTUFBTSxHQUFHLElBQVQ7T0EvQjNDOzs7TUFpQ25CLElBQUlnQixXQUFXLEdBQUdKLEdBQUcsS0FBS1gsUUFBUSxJQUFJRSxNQUFNLEtBQUtZLGNBQWMsSUFBSSxJQUFsQixJQUEwQkEsY0FBYyxHQUFHLEtBQWhELENBQXZCLENBQXJCO01BQ0EsSUFBSUUsaUJBQWlCLEdBQUd4QixLQUFLLElBQUtJLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXREOztNQUVBLFNBQVNvQixTQUFULENBQW1CQyxHQUFuQixFQUF3QjtRQUFFLE9BQU8sSUFBSWg1QyxNQUFKLENBQVcsWUFBWWc1QyxHQUFaLEdBQWtCLGVBQTdCLENBQVA7OztNQUUxQixJQUFJQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFTaitCLElBQVQsRUFBZWcrQixHQUFmLEVBQW9CO1FBQ2hDLElBQUlFLE9BQU8sR0FBR2wrQixJQUFJLENBQUNtK0IsU0FBbkI7UUFDQSxJQUFJMTVDLEtBQUssR0FBR3M1QyxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlcHJELElBQWYsQ0FBb0JzckQsT0FBcEIsQ0FBWjs7UUFDQSxJQUFJejVDLEtBQUosRUFBVztVQUNULElBQUkyNUMsS0FBSyxHQUFHRixPQUFPLENBQUNoa0QsS0FBUixDQUFjdUssS0FBSyxDQUFDNUosS0FBTixHQUFjNEosS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTaE8sTUFBckMsQ0FBWjtVQUNBdXBCLElBQUksQ0FBQ20rQixTQUFMLEdBQWlCRCxPQUFPLENBQUNoa0QsS0FBUixDQUFjLENBQWQsRUFBaUJ1SyxLQUFLLENBQUM1SixLQUF2QixLQUFpQ3VqRCxLQUFLLEdBQUczNUMsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXMjVDLEtBQWQsR0FBc0IsRUFBNUQsQ0FBakI7O09BTEo7O01BU0EsU0FBU0MsY0FBVCxDQUF3QnhyRCxDQUF4QixFQUEyQjtRQUN6QixLQUFLLElBQUkyVSxLQUFLLEdBQUczVSxDQUFDLENBQUNnd0MsVUFBRixDQUFhcHNDLE1BQTlCLEVBQXNDK1EsS0FBSyxHQUFHLENBQTlDLEVBQWlELEVBQUVBLEtBQW5ELEVBQ0U7VUFBRTNVLENBQUMsQ0FBQytyQixXQUFGLENBQWMvckIsQ0FBQyxDQUFDNnZDLFVBQWhCOzs7UUFDSixPQUFPN3ZDLENBQVA7OztNQUdGLFNBQVN5ckQsb0JBQVQsQ0FBOEI3K0IsTUFBOUIsRUFBc0M1c0IsQ0FBdEMsRUFBeUM7UUFDdkMsT0FBT3dyRCxjQUFjLENBQUM1K0IsTUFBRCxDQUFkLENBQXVCdmlCLFdBQXZCLENBQW1DckssQ0FBbkMsQ0FBUDs7O01BR0YsU0FBUzByRCxHQUFULENBQWEza0QsR0FBYixFQUFrQjRvQyxPQUFsQixFQUEyQjJiLFNBQTNCLEVBQXNDbmhELEtBQXRDLEVBQTZDO1FBQzNDLElBQUluSyxDQUFDLEdBQUdXLFFBQVEsQ0FBQ0UsYUFBVCxDQUF1QmtHLEdBQXZCLENBQVI7O1FBQ0EsSUFBSXVrRCxTQUFKLEVBQWU7VUFBRXRyRCxDQUFDLENBQUNzckQsU0FBRixHQUFjQSxTQUFkOzs7UUFDakIsSUFBSW5oRCxLQUFKLEVBQVc7VUFBRW5LLENBQUMsQ0FBQ21LLEtBQUYsQ0FBUTRyQyxPQUFSLEdBQWtCNXJDLEtBQWxCOzs7UUFDYixJQUFJLE9BQU93bEMsT0FBUCxJQUFrQixRQUF0QixFQUFnQztVQUFFM3ZDLENBQUMsQ0FBQ3FLLFdBQUYsQ0FBYzFKLFFBQVEsQ0FBQ3lzQixjQUFULENBQXdCdWlCLE9BQXhCLENBQWQ7U0FBbEMsTUFDSyxJQUFJQSxPQUFKLEVBQWE7VUFBRSxLQUFLLElBQUkzcEMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJwQyxPQUFPLENBQUMvckMsTUFBNUIsRUFBb0MsRUFBRW9DLENBQXRDLEVBQXlDO1lBQUVoRyxDQUFDLENBQUNxSyxXQUFGLENBQWNzbEMsT0FBTyxDQUFDM3BDLENBQUQsQ0FBckI7Ozs7UUFDL0QsT0FBT2hHLENBQVA7T0EvRGlCOzs7TUFrRW5CLFNBQVMyckQsSUFBVCxDQUFjNWtELEdBQWQsRUFBbUI0b0MsT0FBbkIsRUFBNEIyYixTQUE1QixFQUF1Q25oRCxLQUF2QyxFQUE4QztRQUM1QyxJQUFJbkssQ0FBQyxHQUFHMHJELEdBQUcsQ0FBQzNrRCxHQUFELEVBQU00b0MsT0FBTixFQUFlMmIsU0FBZixFQUEwQm5oRCxLQUExQixDQUFYO1FBQ0FuSyxDQUFDLENBQUN3MEMsWUFBRixDQUFlLE1BQWYsRUFBdUIsY0FBdkI7UUFDQSxPQUFPeDBDLENBQVA7OztNQUdGLElBQUkraUQsS0FBSjs7TUFDQSxJQUFJcGlELFFBQVEsQ0FBQ2lyRCxXQUFiLEVBQTBCO1FBQUU3SSxLQUFLLEdBQUcsZUFBUzUxQixJQUFULEVBQWVqTSxLQUFmLEVBQXNCekUsR0FBdEIsRUFBMkI4eEIsT0FBM0IsRUFBb0M7VUFDdEUsSUFBSXBkLENBQUMsR0FBR3h3QixRQUFRLENBQUNpckQsV0FBVCxFQUFSO1VBQ0F6NkIsQ0FBQyxDQUFDMDZCLE1BQUYsQ0FBU3RkLE9BQU8sSUFBSXBoQixJQUFwQixFQUEwQjFRLEdBQTFCO1VBQ0EwVSxDQUFDLENBQUMyNkIsUUFBRixDQUFXMytCLElBQVgsRUFBaUJqTSxLQUFqQjtVQUNBLE9BQU9pUSxDQUFQO1NBSjBCO09BQTVCLE1BTUs7UUFBRTR4QixLQUFLLEdBQUcsZUFBUzUxQixJQUFULEVBQWVqTSxLQUFmLEVBQXNCekUsR0FBdEIsRUFBMkI7VUFDeEMsSUFBSTBVLENBQUMsR0FBR3h3QixRQUFRLENBQUNvOUMsSUFBVCxDQUFjZ08sZUFBZCxFQUFSOztVQUNBLElBQUk7WUFBRTU2QixDQUFDLENBQUM2NkIsaUJBQUYsQ0FBb0I3K0IsSUFBSSxDQUFDaWxCLFVBQXpCO1dBQU4sQ0FDQSxPQUFNcHlDLENBQU4sRUFBUztZQUFFLE9BQU9teEIsQ0FBUDs7O1VBQ1hBLENBQUMsQ0FBQzg2QixRQUFGLENBQVcsSUFBWDtVQUNBOTZCLENBQUMsQ0FBQys2QixPQUFGLENBQVUsV0FBVixFQUF1Qnp2QyxHQUF2QjtVQUNBMFUsQ0FBQyxDQUFDZzdCLFNBQUYsQ0FBWSxXQUFaLEVBQXlCanJDLEtBQXpCO1VBQ0EsT0FBT2lRLENBQVA7U0FQSzs7O01BVVAsU0FBU2k3QixRQUFULENBQWtCeC9CLE1BQWxCLEVBQTBCeS9CLEtBQTFCLEVBQWlDO1FBQy9CLElBQUlBLEtBQUssQ0FBQ25jLFFBQU4sSUFBa0IsQ0FBdEI7VUFDRTtZQUFFbWMsS0FBSyxHQUFHQSxLQUFLLENBQUNqYSxVQUFkOzs7UUFDSixJQUFJeGxCLE1BQU0sQ0FBQ3cvQixRQUFYLEVBQ0U7VUFBRSxPQUFPeC9CLE1BQU0sQ0FBQ3cvQixRQUFQLENBQWdCQyxLQUFoQixDQUFQOzs7UUFDSixHQUFHO1VBQ0QsSUFBSUEsS0FBSyxDQUFDbmMsUUFBTixJQUFrQixFQUF0QixFQUEwQjtZQUFFbWMsS0FBSyxHQUFHQSxLQUFLLENBQUNsWCxJQUFkOzs7VUFDNUIsSUFBSWtYLEtBQUssSUFBSXovQixNQUFiLEVBQXFCO1lBQUUsT0FBTyxJQUFQOztTQUZ6QixRQUdTeS9CLEtBQUssR0FBR0EsS0FBSyxDQUFDamEsVUFIdkI7OztNQU1GLFNBQVNrYSxTQUFULEdBQXFCOzs7O1FBSW5CLElBQUlDLGFBQUo7O1FBQ0EsSUFBSTtVQUNGQSxhQUFhLEdBQUc1ckQsUUFBUSxDQUFDNHJELGFBQXpCO1NBREYsQ0FFRSxPQUFNdnNELENBQU4sRUFBUztVQUNUdXNELGFBQWEsR0FBRzVyRCxRQUFRLENBQUNvOUMsSUFBVCxJQUFpQixJQUFqQzs7O1FBRUYsT0FBT3dPLGFBQWEsSUFBSUEsYUFBYSxDQUFDclQsVUFBL0IsSUFBNkNxVCxhQUFhLENBQUNyVCxVQUFkLENBQXlCcVQsYUFBN0UsRUFDRTtVQUFFQSxhQUFhLEdBQUdBLGFBQWEsQ0FBQ3JULFVBQWQsQ0FBeUJxVCxhQUF6Qzs7O1FBQ0osT0FBT0EsYUFBUDs7O01BR0YsU0FBU0MsUUFBVCxDQUFrQnIvQixJQUFsQixFQUF3QmcrQixHQUF4QixFQUE2QjtRQUMzQixJQUFJRSxPQUFPLEdBQUdsK0IsSUFBSSxDQUFDbStCLFNBQW5COztRQUNBLElBQUksQ0FBQ0osU0FBUyxDQUFDQyxHQUFELENBQVQsQ0FBZTM2QyxJQUFmLENBQW9CNjZDLE9BQXBCLENBQUwsRUFBbUM7VUFBRWwrQixJQUFJLENBQUNtK0IsU0FBTCxJQUFrQixDQUFDRCxPQUFPLEdBQUcsR0FBSCxHQUFTLEVBQWpCLElBQXVCRixHQUF6Qzs7OztNQUV2QyxTQUFTc0IsV0FBVCxDQUFxQnBzRCxDQUFyQixFQUF3QnlELENBQXhCLEVBQTJCO1FBQ3pCLElBQUk0b0QsRUFBRSxHQUFHcnNELENBQUMsQ0FBQzZDLEtBQUYsQ0FBUSxHQUFSLENBQVQ7O1FBQ0EsS0FBSyxJQUFJOEMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBtRCxFQUFFLENBQUM5b0QsTUFBdkIsRUFBK0JvQyxDQUFDLEVBQWhDLEVBQ0U7VUFBRSxJQUFJMG1ELEVBQUUsQ0FBQzFtRCxDQUFELENBQUYsSUFBUyxDQUFDa2xELFNBQVMsQ0FBQ3dCLEVBQUUsQ0FBQzFtRCxDQUFELENBQUgsQ0FBVCxDQUFpQndLLElBQWpCLENBQXNCMU0sQ0FBdEIsQ0FBZCxFQUF3QztZQUFFQSxDQUFDLElBQUksTUFBTTRvRCxFQUFFLENBQUMxbUQsQ0FBRCxDQUFiOzs7O1FBQzlDLE9BQU9sQyxDQUFQOzs7TUFHRixJQUFJNm9ELFdBQVcsR0FBRyxxQkFBU3gvQixJQUFULEVBQWU7UUFBRUEsSUFBSSxDQUFDeS9CLE1BQUw7T0FBbkM7O01BQ0EsSUFBSXBDLEdBQUo7UUFDRTtVQUFFbUMsV0FBVyxHQUFHLHFCQUFTeC9CLElBQVQsRUFBZTtZQUFFQSxJQUFJLENBQUMwL0IsY0FBTCxHQUFzQixDQUF0QjtZQUF5QjEvQixJQUFJLENBQUMyL0IsWUFBTCxHQUFvQjMvQixJQUFJLENBQUN2ckIsS0FBTCxDQUFXZ0MsTUFBL0I7V0FBeEQ7U0FESixNQUVLLElBQUlpbUQsRUFBSjtRQUNIO1VBQUU4QyxXQUFXLEdBQUcscUJBQVN4L0IsSUFBVCxFQUFlO1lBQUUsSUFBSTtjQUFFQSxJQUFJLENBQUN5L0IsTUFBTDthQUFOLENBQXVCLE9BQU1HLEVBQU4sRUFBVTtXQUFoRTs7O01BRUosU0FBUzE3QyxJQUFULENBQWNuUCxDQUFkLEVBQWlCO1FBQ2YsSUFBSXVNLElBQUksR0FBR2xGLEtBQUssQ0FBQzdGLFNBQU4sQ0FBZ0IyRCxLQUFoQixDQUFzQnZILElBQXRCLENBQTJCbUUsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDtRQUNBLE9BQU8sWUFBVTtVQUFDLE9BQU8vQixDQUFDLENBQUM4QixLQUFGLENBQVEsSUFBUixFQUFjeUssSUFBZCxDQUFQO1NBQWxCOzs7TUFHRixTQUFTdStDLE9BQVQsQ0FBaUIvbEIsR0FBakIsRUFBc0JsaUMsTUFBdEIsRUFBOEJrb0QsU0FBOUIsRUFBeUM7UUFDdkMsSUFBSSxDQUFDbG9ELE1BQUwsRUFBYTtVQUFFQSxNQUFNLEdBQUcsRUFBVDs7O1FBQ2YsS0FBSyxJQUFJbW9ELElBQVQsSUFBaUJqbUIsR0FBakIsRUFDRTtVQUFFLElBQUlBLEdBQUcsQ0FBQ3RuQyxjQUFKLENBQW1CdXRELElBQW5CLE1BQTZCRCxTQUFTLEtBQUssS0FBZCxJQUF1QixDQUFDbG9ELE1BQU0sQ0FBQ3BGLGNBQVAsQ0FBc0J1dEQsSUFBdEIsQ0FBckQsQ0FBSixFQUNBO1lBQUVub0QsTUFBTSxDQUFDbW9ELElBQUQsQ0FBTixHQUFlam1CLEdBQUcsQ0FBQ2ltQixJQUFELENBQWxCOzs7O1FBQ04sT0FBT25vRCxNQUFQO09BOUlpQjs7OztNQW1KbkIsU0FBU29vRCxXQUFULENBQXFCMTZDLE1BQXJCLEVBQTZCZ0ssR0FBN0IsRUFBa0Myd0MsT0FBbEMsRUFBMkNDLFVBQTNDLEVBQXVEQyxVQUF2RCxFQUFtRTtRQUNqRSxJQUFJN3dDLEdBQUcsSUFBSSxJQUFYLEVBQWlCO1VBQ2ZBLEdBQUcsR0FBR2hLLE1BQU0sQ0FBQ2lLLE1BQVAsQ0FBYyxhQUFkLENBQU47O1VBQ0EsSUFBSUQsR0FBRyxJQUFJLENBQUMsQ0FBWixFQUFlO1lBQUVBLEdBQUcsR0FBR2hLLE1BQU0sQ0FBQzdPLE1BQWI7Ozs7UUFFbkIsS0FBSyxJQUFJb0MsQ0FBQyxHQUFHcW5ELFVBQVUsSUFBSSxDQUF0QixFQUF5Qmo4QyxDQUFDLEdBQUdrOEMsVUFBVSxJQUFJLENBQWhELElBQXFEO1VBQ25ELElBQUlDLE9BQU8sR0FBRzk2QyxNQUFNLENBQUNvSyxPQUFQLENBQWUsSUFBZixFQUFxQjdXLENBQXJCLENBQWQ7O1VBQ0EsSUFBSXVuRCxPQUFPLEdBQUcsQ0FBVixJQUFlQSxPQUFPLElBQUk5d0MsR0FBOUIsRUFDRTtZQUFFLE9BQU9yTCxDQUFDLElBQUlxTCxHQUFHLEdBQUd6VyxDQUFWLENBQVI7OztVQUNKb0wsQ0FBQyxJQUFJbThDLE9BQU8sR0FBR3ZuRCxDQUFmO1VBQ0FvTCxDQUFDLElBQUlnOEMsT0FBTyxHQUFJaDhDLENBQUMsR0FBR2c4QyxPQUFwQjtVQUNBcG5ELENBQUMsR0FBR3VuRCxPQUFPLEdBQUcsQ0FBZDs7OztNQUlKLElBQUlDLE9BQU8sR0FBRyxTQUFWQSxPQUFVLEdBQVc7UUFDdkIsS0FBS3ByRCxFQUFMLEdBQVUsSUFBVjtRQUNBLEtBQUtGLENBQUwsR0FBUyxJQUFUO1FBQ0EsS0FBSzhoQyxJQUFMLEdBQVksQ0FBWjtRQUNBLEtBQUt2VSxPQUFMLEdBQWVwZSxJQUFJLENBQUMsS0FBS284QyxTQUFOLEVBQWlCLElBQWpCLENBQW5CO09BSkY7O01BTUFELE9BQU8sQ0FBQzlwRCxTQUFSLENBQWtCK3BELFNBQWxCLEdBQThCLFVBQVVqdUQsSUFBVixFQUFnQjtRQUM1Q0EsSUFBSSxDQUFDNEMsRUFBTCxHQUFVLENBQVY7O1FBQ0EsSUFBSTVDLElBQUksQ0FBQ3drQyxJQUFMLElBQWEsQ0FBQyxJQUFJemxCLElBQUosRUFBbEIsRUFBNEI7VUFDMUIvZSxJQUFJLENBQUMwQyxDQUFMO1NBREYsTUFFTztVQUNMOHBCLFVBQVUsQ0FBQ3hzQixJQUFJLENBQUNpd0IsT0FBTixFQUFlandCLElBQUksQ0FBQ3drQyxJQUFMLEdBQVksQ0FBQyxJQUFJemxCLElBQUosRUFBNUIsQ0FBVjs7T0FMSjs7TUFRQWl2QyxPQUFPLENBQUM5cEQsU0FBUixDQUFrQm1LLEdBQWxCLEdBQXdCLFVBQVU2L0MsRUFBVixFQUFjeHJELENBQWQsRUFBaUI7UUFDdkMsS0FBS0EsQ0FBTCxHQUFTQSxDQUFUO1FBQ0EsSUFBSThoQyxJQUFJLEdBQUcsQ0FBQyxJQUFJemxCLElBQUosRUFBRCxHQUFZbXZDLEVBQXZCOztRQUNBLElBQUksQ0FBQyxLQUFLdHJELEVBQU4sSUFBWTRoQyxJQUFJLEdBQUcsS0FBS0EsSUFBNUIsRUFBa0M7VUFDaEMycEIsWUFBWSxDQUFDLEtBQUt2ckQsRUFBTixDQUFaO1VBQ0EsS0FBS0EsRUFBTCxHQUFVNHBCLFVBQVUsQ0FBQyxLQUFLeUQsT0FBTixFQUFlaStCLEVBQWYsQ0FBcEI7VUFDQSxLQUFLMXBCLElBQUwsR0FBWUEsSUFBWjs7T0FOSjs7TUFVQSxTQUFTbm5CLE9BQVQsQ0FBaUIrd0MsS0FBakIsRUFBd0JsQyxHQUF4QixFQUE2QjtRQUMzQixLQUFLLElBQUkxbEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRuRCxLQUFLLENBQUNocUQsTUFBMUIsRUFBa0MsRUFBRW9DLENBQXBDLEVBQ0U7VUFBRSxJQUFJNG5ELEtBQUssQ0FBQzVuRCxDQUFELENBQUwsSUFBWTBsRCxHQUFoQixFQUFxQjtZQUFFLE9BQU8xbEQsQ0FBUDs7OztRQUMzQixPQUFPLENBQUMsQ0FBUjtPQTdMaUI7OztNQWlNbkIsSUFBSTZuRCxXQUFXLEdBQUcsRUFBbEIsQ0FqTW1COzs7TUFxTW5CLElBQUlDLElBQUksR0FBRztRQUFDM3NELFFBQVEsRUFBRSxvQkFBVTtVQUFDLE9BQU8saUJBQVA7O09BQWpDLENBck1tQjs7TUF3TW5CLElBQUk0c0QsY0FBYyxHQUFHO1FBQUNDLE1BQU0sRUFBRTtPQUE5QjtVQUFzQ0MsU0FBUyxHQUFHO1FBQUNDLE1BQU0sRUFBRTtPQUEzRDtVQUFzRUMsUUFBUSxHQUFHO1FBQUNELE1BQU0sRUFBRTtPQUExRixDQXhNbUI7OztNQTRNbkIsU0FBU0UsVUFBVCxDQUFvQjM3QyxNQUFwQixFQUE0QjQ3QyxJQUE1QixFQUFrQ2pCLE9BQWxDLEVBQTJDO1FBQ3pDLEtBQUssSUFBSXR6QyxHQUFHLEdBQUcsQ0FBVixFQUFhdzBDLEdBQUcsR0FBRyxDQUF4QixJQUE2QjtVQUMzQixJQUFJZixPQUFPLEdBQUc5NkMsTUFBTSxDQUFDb0ssT0FBUCxDQUFlLElBQWYsRUFBcUIvQyxHQUFyQixDQUFkOztVQUNBLElBQUl5ekMsT0FBTyxJQUFJLENBQUMsQ0FBaEIsRUFBbUI7WUFBRUEsT0FBTyxHQUFHOTZDLE1BQU0sQ0FBQzdPLE1BQWpCOzs7VUFDckIsSUFBSTJxRCxPQUFPLEdBQUdoQixPQUFPLEdBQUd6ekMsR0FBeEI7O1VBQ0EsSUFBSXl6QyxPQUFPLElBQUk5NkMsTUFBTSxDQUFDN08sTUFBbEIsSUFBNEIwcUQsR0FBRyxHQUFHQyxPQUFOLElBQWlCRixJQUFqRCxFQUNFO1lBQUUsT0FBT3YwQyxHQUFHLEdBQUd2YSxJQUFJLENBQUNzSSxHQUFMLENBQVMwbUQsT0FBVCxFQUFrQkYsSUFBSSxHQUFHQyxHQUF6QixDQUFiOzs7VUFDSkEsR0FBRyxJQUFJZixPQUFPLEdBQUd6ekMsR0FBakI7VUFDQXcwQyxHQUFHLElBQUlsQixPQUFPLEdBQUlrQixHQUFHLEdBQUdsQixPQUF4QjtVQUNBdHpDLEdBQUcsR0FBR3l6QyxPQUFPLEdBQUcsQ0FBaEI7O1VBQ0EsSUFBSWUsR0FBRyxJQUFJRCxJQUFYLEVBQWlCO1lBQUUsT0FBT3YwQyxHQUFQOzs7OztNQUl2QixJQUFJMDBDLFNBQVMsR0FBRyxDQUFDLEVBQUQsQ0FBaEI7O01BQ0EsU0FBU0MsUUFBVCxDQUFrQnI5QyxDQUFsQixFQUFxQjtRQUNuQixPQUFPbzlDLFNBQVMsQ0FBQzVxRCxNQUFWLElBQW9Cd04sQ0FBM0IsRUFDRTtVQUFFbzlDLFNBQVMsQ0FBQzdyRCxJQUFWLENBQWUrckQsR0FBRyxDQUFDRixTQUFELENBQUgsR0FBaUIsR0FBaEM7OztRQUNKLE9BQU9BLFNBQVMsQ0FBQ3A5QyxDQUFELENBQWhCOzs7TUFHRixTQUFTczlDLEdBQVQsQ0FBYXp1QyxHQUFiLEVBQWtCO1FBQUUsT0FBT0EsR0FBRyxDQUFDQSxHQUFHLENBQUNyYyxNQUFKLEdBQVcsQ0FBWixDQUFWOzs7TUFFcEIsU0FBUzBlLEdBQVQsQ0FBYXNyQyxLQUFiLEVBQW9CMXJELENBQXBCLEVBQXVCO1FBQ3JCLElBQUlpRCxHQUFHLEdBQUcsRUFBVjs7UUFDQSxLQUFLLElBQUlhLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0bkQsS0FBSyxDQUFDaHFELE1BQTFCLEVBQWtDb0MsQ0FBQyxFQUFuQyxFQUF1QztVQUFFYixHQUFHLENBQUNhLENBQUQsQ0FBSCxHQUFTOUQsQ0FBQyxDQUFDMHJELEtBQUssQ0FBQzVuRCxDQUFELENBQU4sRUFBV0EsQ0FBWCxDQUFWOzs7UUFDekMsT0FBT2IsR0FBUDs7O01BR0YsU0FBU3dwRCxZQUFULENBQXNCZixLQUF0QixFQUE2QmhzRCxLQUE3QixFQUFvQ2d0RCxLQUFwQyxFQUEyQztRQUN6QyxJQUFJOTBDLEdBQUcsR0FBRyxDQUFWO1lBQWErMEMsUUFBUSxHQUFHRCxLQUFLLENBQUNodEQsS0FBRCxDQUE3Qjs7UUFDQSxPQUFPa1ksR0FBRyxHQUFHOHpDLEtBQUssQ0FBQ2hxRCxNQUFaLElBQXNCZ3JELEtBQUssQ0FBQ2hCLEtBQUssQ0FBQzl6QyxHQUFELENBQU4sQ0FBTCxJQUFxQiswQyxRQUFsRCxFQUE0RDtVQUFFLzBDLEdBQUc7OztRQUNqRTh6QyxLQUFLLENBQUM1NUIsTUFBTixDQUFhbGEsR0FBYixFQUFrQixDQUFsQixFQUFxQmxZLEtBQXJCOzs7TUFHRixTQUFTa3NDLE9BQVQsR0FBbUI7O01BRW5CLFNBQVNnaEIsU0FBVCxDQUFtQi9JLElBQW5CLEVBQXlCakssS0FBekIsRUFBZ0M7UUFDOUIsSUFBSWlULElBQUo7O1FBQ0EsSUFBSTd1RCxNQUFNLENBQUNpRyxNQUFYLEVBQW1CO1VBQ2pCNG9ELElBQUksR0FBRzd1RCxNQUFNLENBQUNpRyxNQUFQLENBQWM0L0MsSUFBZCxDQUFQO1NBREYsTUFFTztVQUNMalksT0FBTyxDQUFDcHFDLFNBQVIsR0FBb0JxaUQsSUFBcEI7VUFDQWdKLElBQUksR0FBRyxJQUFJamhCLE9BQUosRUFBUDs7O1FBRUYsSUFBSWdPLEtBQUosRUFBVztVQUFFa1IsT0FBTyxDQUFDbFIsS0FBRCxFQUFRaVQsSUFBUixDQUFQOzs7UUFDYixPQUFPQSxJQUFQOzs7TUFHRixJQUFJQywwQkFBMEIsR0FBRywyR0FBakM7O01BQ0EsU0FBU0MsZUFBVCxDQUF5QnhtQyxFQUF6QixFQUE2QjtRQUMzQixPQUFPLEtBQUtqWSxJQUFMLENBQVVpWSxFQUFWLEtBQWlCQSxFQUFFLEdBQUcsTUFBTCxLQUNyQkEsRUFBRSxDQUFDeW1DLFdBQUgsTUFBb0J6bUMsRUFBRSxDQUFDcEwsV0FBSCxFQUFwQixJQUF3QzJ4QywwQkFBMEIsQ0FBQ3grQyxJQUEzQixDQUFnQ2lZLEVBQWhDLENBRG5CLENBQXhCOzs7TUFHRixTQUFTMG1DLFVBQVQsQ0FBb0IxbUMsRUFBcEIsRUFBd0IybUMsTUFBeEIsRUFBZ0M7UUFDOUIsSUFBSSxDQUFDQSxNQUFMLEVBQWE7VUFBRSxPQUFPSCxlQUFlLENBQUN4bUMsRUFBRCxDQUF0Qjs7O1FBQ2YsSUFBSTJtQyxNQUFNLENBQUM5cUQsTUFBUCxDQUFjdVksT0FBZCxDQUFzQixLQUF0QixJQUErQixDQUFDLENBQWhDLElBQXFDb3lDLGVBQWUsQ0FBQ3htQyxFQUFELENBQXhELEVBQThEO1VBQUUsT0FBTyxJQUFQOzs7UUFDaEUsT0FBTzJtQyxNQUFNLENBQUM1K0MsSUFBUCxDQUFZaVksRUFBWixDQUFQOzs7TUFHRixTQUFTNG1DLE9BQVQsQ0FBaUJwb0IsR0FBakIsRUFBc0I7UUFDcEIsS0FBSyxJQUFJNzFCLENBQVQsSUFBYzYxQixHQUFkLEVBQW1CO1VBQUUsSUFBSUEsR0FBRyxDQUFDdG5DLGNBQUosQ0FBbUJ5UixDQUFuQixLQUF5QjYxQixHQUFHLENBQUM3MUIsQ0FBRCxDQUFoQyxFQUFxQztZQUFFLE9BQU8sS0FBUDs7OztRQUM1RCxPQUFPLElBQVA7T0ExUWlCOzs7Ozs7O01Ba1JuQixJQUFJaytDLGNBQWMsR0FBRyw0NERBQXJCOztNQUNBLFNBQVNDLGVBQVQsQ0FBeUI5bUMsRUFBekIsRUFBNkI7UUFBRSxPQUFPQSxFQUFFLENBQUMxVSxVQUFILENBQWMsQ0FBZCxLQUFvQixHQUFwQixJQUEyQnU3QyxjQUFjLENBQUM5K0MsSUFBZixDQUFvQmlZLEVBQXBCLENBQWxDO09BblJaOzs7TUFzUm5CLFNBQVMrbUMsa0JBQVQsQ0FBNEJ2OEMsR0FBNUIsRUFBaUM2RyxHQUFqQyxFQUFzQzIxQyxHQUF0QyxFQUEyQztRQUN6QyxPQUFPLENBQUNBLEdBQUcsR0FBRyxDQUFOLEdBQVUzMUMsR0FBRyxHQUFHLENBQWhCLEdBQW9CQSxHQUFHLEdBQUc3RyxHQUFHLENBQUNyUCxNQUEvQixLQUEwQzJyRCxlQUFlLENBQUN0OEMsR0FBRyxDQUFDOUwsTUFBSixDQUFXMlMsR0FBWCxDQUFELENBQWhFLEVBQW1GO1VBQUVBLEdBQUcsSUFBSTIxQyxHQUFQOzs7UUFDckYsT0FBTzMxQyxHQUFQO09BeFJpQjs7Ozs7TUE4Um5CLFNBQVM0MUMsU0FBVCxDQUFtQkMsSUFBbkIsRUFBeUI1dkMsSUFBekIsRUFBK0J3RCxFQUEvQixFQUFtQzs7O1FBR2pDLElBQUlrc0MsR0FBRyxHQUFHMXZDLElBQUksR0FBR3dELEVBQVAsR0FBWSxDQUFDLENBQWIsR0FBaUIsQ0FBM0I7O1FBQ0EsU0FBUztVQUNQLElBQUl4RCxJQUFJLElBQUl3RCxFQUFaLEVBQWdCO1lBQUUsT0FBT3hELElBQVA7OztVQUNsQixJQUFJNnZDLElBQUksR0FBRyxDQUFDN3ZDLElBQUksR0FBR3dELEVBQVIsSUFBYyxDQUF6QjtjQUE0QnNzQyxHQUFHLEdBQUdKLEdBQUcsR0FBRyxDQUFOLEdBQVVsd0QsSUFBSSxDQUFDbUksSUFBTCxDQUFVa29ELElBQVYsQ0FBVixHQUE0QnJ3RCxJQUFJLENBQUNvSSxLQUFMLENBQVdpb0QsSUFBWCxDQUE5RDs7VUFDQSxJQUFJQyxHQUFHLElBQUk5dkMsSUFBWCxFQUFpQjtZQUFFLE9BQU80dkMsSUFBSSxDQUFDRSxHQUFELENBQUosR0FBWTl2QyxJQUFaLEdBQW1Cd0QsRUFBMUI7OztVQUNuQixJQUFJb3NDLElBQUksQ0FBQ0UsR0FBRCxDQUFSLEVBQWU7WUFBRXRzQyxFQUFFLEdBQUdzc0MsR0FBTDtXQUFqQixNQUNLO1lBQUU5dkMsSUFBSSxHQUFHOHZDLEdBQUcsR0FBR0osR0FBYjs7O09BdlNROzs7TUE2U25CLFNBQVNLLG1CQUFULENBQTZCQyxLQUE3QixFQUFvQ2h3QyxJQUFwQyxFQUEwQ3dELEVBQTFDLEVBQThDcmhCLENBQTlDLEVBQWlEO1FBQy9DLElBQUksQ0FBQzZ0RCxLQUFMLEVBQVk7VUFBRSxPQUFPN3RELENBQUMsQ0FBQzZkLElBQUQsRUFBT3dELEVBQVAsRUFBVyxLQUFYLEVBQWtCLENBQWxCLENBQVI7OztRQUNkLElBQUl5c0MsS0FBSyxHQUFHLEtBQVo7O1FBQ0EsS0FBSyxJQUFJaHFELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrcEQsS0FBSyxDQUFDbnNELE1BQTFCLEVBQWtDLEVBQUVvQyxDQUFwQyxFQUF1QztVQUNyQyxJQUFJcW9DLElBQUksR0FBRzBoQixLQUFLLENBQUMvcEQsQ0FBRCxDQUFoQjs7VUFDQSxJQUFJcW9DLElBQUksQ0FBQ3R1QixJQUFMLEdBQVl3RCxFQUFaLElBQWtCOHFCLElBQUksQ0FBQzlxQixFQUFMLEdBQVV4RCxJQUE1QixJQUFvQ0EsSUFBSSxJQUFJd0QsRUFBUixJQUFjOHFCLElBQUksQ0FBQzlxQixFQUFMLElBQVd4RCxJQUFqRSxFQUF1RTtZQUNyRTdkLENBQUMsQ0FBQzNDLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3NtQyxJQUFJLENBQUN0dUIsSUFBZCxFQUFvQkEsSUFBcEIsQ0FBRCxFQUE0QnhnQixJQUFJLENBQUNzSSxHQUFMLENBQVN3bUMsSUFBSSxDQUFDOXFCLEVBQWQsRUFBa0JBLEVBQWxCLENBQTVCLEVBQW1EOHFCLElBQUksQ0FBQzRoQixLQUFMLElBQWMsQ0FBZCxHQUFrQixLQUFsQixHQUEwQixLQUE3RSxFQUFvRmpxRCxDQUFwRixDQUFEO1lBQ0FncUQsS0FBSyxHQUFHLElBQVI7Ozs7UUFHSixJQUFJLENBQUNBLEtBQUwsRUFBWTtVQUFFOXRELENBQUMsQ0FBQzZkLElBQUQsRUFBT3dELEVBQVAsRUFBVyxLQUFYLENBQUQ7Ozs7TUFHaEIsSUFBSTJzQyxTQUFTLEdBQUcsSUFBaEI7O01BQ0EsU0FBU0MsYUFBVCxDQUF1QkosS0FBdkIsRUFBOEJ0bkMsRUFBOUIsRUFBa0NwRSxNQUFsQyxFQUEwQztRQUN4QyxJQUFJMnJDLEtBQUo7UUFDQUUsU0FBUyxHQUFHLElBQVo7O1FBQ0EsS0FBSyxJQUFJbHFELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrcEQsS0FBSyxDQUFDbnNELE1BQTFCLEVBQWtDLEVBQUVvQyxDQUFwQyxFQUF1QztVQUNyQyxJQUFJb3FELEdBQUcsR0FBR0wsS0FBSyxDQUFDL3BELENBQUQsQ0FBZjs7VUFDQSxJQUFJb3FELEdBQUcsQ0FBQ3J3QyxJQUFKLEdBQVcwSSxFQUFYLElBQWlCMm5DLEdBQUcsQ0FBQzdzQyxFQUFKLEdBQVNrRixFQUE5QixFQUFrQztZQUFFLE9BQU96aUIsQ0FBUDs7O1VBQ3BDLElBQUlvcUQsR0FBRyxDQUFDN3NDLEVBQUosSUFBVWtGLEVBQWQsRUFBa0I7WUFDaEIsSUFBSTJuQyxHQUFHLENBQUNyd0MsSUFBSixJQUFZcXdDLEdBQUcsQ0FBQzdzQyxFQUFoQixJQUFzQmMsTUFBTSxJQUFJLFFBQXBDLEVBQThDO2NBQUUyckMsS0FBSyxHQUFHaHFELENBQVI7YUFBaEQsTUFDSztjQUFFa3FELFNBQVMsR0FBR2xxRCxDQUFaOzs7O1VBRVQsSUFBSW9xRCxHQUFHLENBQUNyd0MsSUFBSixJQUFZMEksRUFBaEIsRUFBb0I7WUFDbEIsSUFBSTJuQyxHQUFHLENBQUNyd0MsSUFBSixJQUFZcXdDLEdBQUcsQ0FBQzdzQyxFQUFoQixJQUFzQmMsTUFBTSxJQUFJLFFBQXBDLEVBQThDO2NBQUUyckMsS0FBSyxHQUFHaHFELENBQVI7YUFBaEQsTUFDSztjQUFFa3FELFNBQVMsR0FBR2xxRCxDQUFaOzs7OztRQUdYLE9BQU9ncUQsS0FBSyxJQUFJLElBQVQsR0FBZ0JBLEtBQWhCLEdBQXdCRSxTQUEvQjtPQTFVaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Bb1duQixJQUFJRyxZQUFZLEdBQUksWUFBVzs7UUFFN0IsSUFBSUMsUUFBUSxHQUFHLDBQQUFmLENBRjZCOztRQUk3QixJQUFJQyxXQUFXLEdBQUcsNFBBQWxCOztRQUNBLFNBQVNDLFFBQVQsQ0FBa0JwOEMsSUFBbEIsRUFBd0I7VUFDdEIsSUFBSUEsSUFBSSxJQUFJLElBQVosRUFBa0I7WUFBRSxPQUFPazhDLFFBQVEsQ0FBQ25wRCxNQUFULENBQWdCaU4sSUFBaEIsQ0FBUDtXQUFwQixNQUNLLElBQUksU0FBU0EsSUFBVCxJQUFpQkEsSUFBSSxJQUFJLEtBQTdCLEVBQW9DO1lBQUUsT0FBTyxHQUFQO1dBQXRDLE1BQ0EsSUFBSSxTQUFTQSxJQUFULElBQWlCQSxJQUFJLElBQUksS0FBN0IsRUFBb0M7WUFBRSxPQUFPbThDLFdBQVcsQ0FBQ3BwRCxNQUFaLENBQW1CaU4sSUFBSSxHQUFHLEtBQTFCLENBQVA7V0FBdEMsTUFDQSxJQUFJLFNBQVNBLElBQVQsSUFBaUJBLElBQUksSUFBSSxLQUE3QixFQUFvQztZQUFFLE9BQU8sR0FBUDtXQUF0QyxNQUNBLElBQUksVUFBVUEsSUFBVixJQUFrQkEsSUFBSSxJQUFJLE1BQTlCLEVBQXNDO1lBQUUsT0FBTyxHQUFQO1dBQXhDLE1BQ0EsSUFBSUEsSUFBSSxJQUFJLE1BQVosRUFBb0I7WUFBRSxPQUFPLEdBQVA7V0FBdEIsTUFDQTtZQUFFLE9BQU8sR0FBUDs7OztRQUdULElBQUlxOEMsTUFBTSxHQUFHLDJDQUFiO1FBQ0EsSUFBSUMsU0FBUyxHQUFHLFFBQWhCO1lBQTBCQyxRQUFRLEdBQUcsT0FBckM7WUFBOENDLFlBQVksR0FBRyxRQUE3RDtZQUF1RUMsV0FBVyxHQUFHLE1BQXJGOztRQUVBLFNBQVNDLFFBQVQsQ0FBa0JiLEtBQWxCLEVBQXlCbHdDLElBQXpCLEVBQStCd0QsRUFBL0IsRUFBbUM7VUFDakMsS0FBSzBzQyxLQUFMLEdBQWFBLEtBQWI7VUFDQSxLQUFLbHdDLElBQUwsR0FBWUEsSUFBWjtVQUFrQixLQUFLd0QsRUFBTCxHQUFVQSxFQUFWOzs7UUFHcEIsT0FBTyxVQUFTdFEsR0FBVCxFQUFjODlDLFNBQWQsRUFBeUI7VUFDOUIsSUFBSUMsU0FBUyxHQUFHRCxTQUFTLElBQUksS0FBYixHQUFxQixHQUFyQixHQUEyQixHQUEzQzs7VUFFQSxJQUFJOTlDLEdBQUcsQ0FBQ3JQLE1BQUosSUFBYyxDQUFkLElBQW1CbXRELFNBQVMsSUFBSSxLQUFiLElBQXNCLENBQUNOLE1BQU0sQ0FBQ2pnRCxJQUFQLENBQVl5QyxHQUFaLENBQTlDLEVBQWdFO1lBQUUsT0FBTyxLQUFQOzs7VUFDbEUsSUFBSTlCLEdBQUcsR0FBRzhCLEdBQUcsQ0FBQ3JQLE1BQWQ7Y0FBc0JxdEQsS0FBSyxHQUFHLEVBQTlCOztVQUNBLEtBQUssSUFBSWpyRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbUwsR0FBcEIsRUFBeUIsRUFBRW5MLENBQTNCLEVBQ0U7WUFBRWlyRCxLQUFLLENBQUN0dUQsSUFBTixDQUFXNnRELFFBQVEsQ0FBQ3Y5QyxHQUFHLENBQUNjLFVBQUosQ0FBZS9OLENBQWYsQ0FBRCxDQUFuQjtXQU4wQjs7Ozs7O1VBWTlCLEtBQUssSUFBSWtyRCxHQUFHLEdBQUcsQ0FBVixFQUFhNStCLElBQUksR0FBRzArQixTQUF6QixFQUFvQ0UsR0FBRyxHQUFHLy9DLEdBQTFDLEVBQStDLEVBQUUrL0MsR0FBakQsRUFBc0Q7WUFDcEQsSUFBSTlzRCxJQUFJLEdBQUc2c0QsS0FBSyxDQUFDQyxHQUFELENBQWhCOztZQUNBLElBQUk5c0QsSUFBSSxJQUFJLEdBQVosRUFBaUI7Y0FBRTZzRCxLQUFLLENBQUNDLEdBQUQsQ0FBTCxHQUFhNStCLElBQWI7YUFBbkIsTUFDSztjQUFFQSxJQUFJLEdBQUdsdUIsSUFBUDs7V0FmcUI7Ozs7Ozs7VUF1QjlCLEtBQUssSUFBSStzRCxHQUFHLEdBQUcsQ0FBVixFQUFhZixHQUFHLEdBQUdZLFNBQXhCLEVBQW1DRyxHQUFHLEdBQUdoZ0QsR0FBekMsRUFBOEMsRUFBRWdnRCxHQUFoRCxFQUFxRDtZQUNuRCxJQUFJQyxNQUFNLEdBQUdILEtBQUssQ0FBQ0UsR0FBRCxDQUFsQjs7WUFDQSxJQUFJQyxNQUFNLElBQUksR0FBVixJQUFpQmhCLEdBQUcsSUFBSSxHQUE1QixFQUFpQztjQUFFYSxLQUFLLENBQUNFLEdBQUQsQ0FBTCxHQUFhLEdBQWI7YUFBbkMsTUFDSyxJQUFJUixRQUFRLENBQUNuZ0QsSUFBVCxDQUFjNGdELE1BQWQsQ0FBSixFQUEyQjtjQUFFaEIsR0FBRyxHQUFHZ0IsTUFBTjs7Y0FBYyxJQUFJQSxNQUFNLElBQUksR0FBZCxFQUFtQjtnQkFBRUgsS0FBSyxDQUFDRSxHQUFELENBQUwsR0FBYSxHQUFiOzs7V0ExQnpDOzs7OztVQWdDOUIsS0FBSyxJQUFJRSxHQUFHLEdBQUcsQ0FBVixFQUFhQyxNQUFNLEdBQUdMLEtBQUssQ0FBQyxDQUFELENBQWhDLEVBQXFDSSxHQUFHLEdBQUdsZ0QsR0FBRyxHQUFHLENBQWpELEVBQW9ELEVBQUVrZ0QsR0FBdEQsRUFBMkQ7WUFDekQsSUFBSUUsTUFBTSxHQUFHTixLQUFLLENBQUNJLEdBQUQsQ0FBbEI7O1lBQ0EsSUFBSUUsTUFBTSxJQUFJLEdBQVYsSUFBaUJELE1BQU0sSUFBSSxHQUEzQixJQUFrQ0wsS0FBSyxDQUFDSSxHQUFHLEdBQUMsQ0FBTCxDQUFMLElBQWdCLEdBQXRELEVBQTJEO2NBQUVKLEtBQUssQ0FBQ0ksR0FBRCxDQUFMLEdBQWEsR0FBYjthQUE3RCxNQUNLLElBQUlFLE1BQU0sSUFBSSxHQUFWLElBQWlCRCxNQUFNLElBQUlMLEtBQUssQ0FBQ0ksR0FBRyxHQUFDLENBQUwsQ0FBaEMsS0FDQ0MsTUFBTSxJQUFJLEdBQVYsSUFBaUJBLE1BQU0sSUFBSSxHQUQ1QixDQUFKLEVBQ3NDO2NBQUVMLEtBQUssQ0FBQ0ksR0FBRCxDQUFMLEdBQWFDLE1BQWI7OztZQUM3Q0EsTUFBTSxHQUFHQyxNQUFUO1dBckM0Qjs7Ozs7O1VBNEM5QixLQUFLLElBQUlDLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdyZ0QsR0FBeEIsRUFBNkIsRUFBRXFnRCxHQUEvQixFQUFvQztZQUNsQyxJQUFJQyxNQUFNLEdBQUdSLEtBQUssQ0FBQ08sR0FBRCxDQUFsQjs7WUFDQSxJQUFJQyxNQUFNLElBQUksR0FBZCxFQUFtQjtjQUFFUixLQUFLLENBQUNPLEdBQUQsQ0FBTCxHQUFhLEdBQWI7YUFBckIsTUFDSyxJQUFJQyxNQUFNLElBQUksR0FBZCxFQUFtQjtjQUN0QixJQUFJaDFDLEdBQUcsR0FBSSxLQUFLLENBQWhCOztjQUNBLEtBQUtBLEdBQUcsR0FBRyswQyxHQUFHLEdBQUcsQ0FBakIsRUFBb0IvMEMsR0FBRyxHQUFHdEwsR0FBTixJQUFhOC9DLEtBQUssQ0FBQ3gwQyxHQUFELENBQUwsSUFBYyxHQUEvQyxFQUFvRCxFQUFFQSxHQUF0RCxFQUEyRDs7Y0FDM0QsSUFBSTlKLE9BQU8sR0FBSTYrQyxHQUFHLElBQUlQLEtBQUssQ0FBQ08sR0FBRyxHQUFDLENBQUwsQ0FBTCxJQUFnQixHQUF4QixJQUFpQy8wQyxHQUFHLEdBQUd0TCxHQUFOLElBQWE4L0MsS0FBSyxDQUFDeDBDLEdBQUQsQ0FBTCxJQUFjLEdBQTVELEdBQW1FLEdBQW5FLEdBQXlFLEdBQXZGOztjQUNBLEtBQUssSUFBSXpPLENBQUMsR0FBR3dqRCxHQUFiLEVBQWtCeGpELENBQUMsR0FBR3lPLEdBQXRCLEVBQTJCLEVBQUV6TyxDQUE3QixFQUFnQztnQkFBRWlqRCxLQUFLLENBQUNqakQsQ0FBRCxDQUFMLEdBQVcyRSxPQUFYOzs7Y0FDbEM2K0MsR0FBRyxHQUFHLzBDLEdBQUcsR0FBRyxDQUFaOztXQXBEMEI7Ozs7O1VBMkQ5QixLQUFLLElBQUlpMUMsR0FBRyxHQUFHLENBQVYsRUFBYUMsS0FBSyxHQUFHWCxTQUExQixFQUFxQ1UsR0FBRyxHQUFHdmdELEdBQTNDLEVBQWdELEVBQUV1Z0QsR0FBbEQsRUFBdUQ7WUFDckQsSUFBSUUsTUFBTSxHQUFHWCxLQUFLLENBQUNTLEdBQUQsQ0FBbEI7O1lBQ0EsSUFBSUMsS0FBSyxJQUFJLEdBQVQsSUFBZ0JDLE1BQU0sSUFBSSxHQUE5QixFQUFtQztjQUFFWCxLQUFLLENBQUNTLEdBQUQsQ0FBTCxHQUFhLEdBQWI7YUFBckMsTUFDSyxJQUFJZixRQUFRLENBQUNuZ0QsSUFBVCxDQUFjb2hELE1BQWQsQ0FBSixFQUEyQjtjQUFFRCxLQUFLLEdBQUdDLE1BQVI7O1dBOUROOzs7Ozs7OztVQXVFOUIsS0FBSyxJQUFJQyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHMWdELEdBQXhCLEVBQTZCLEVBQUUwZ0QsR0FBL0IsRUFBb0M7WUFDbEMsSUFBSW5CLFNBQVMsQ0FBQ2xnRCxJQUFWLENBQWV5Z0QsS0FBSyxDQUFDWSxHQUFELENBQXBCLENBQUosRUFBZ0M7Y0FDOUIsSUFBSUMsS0FBSyxHQUFJLEtBQUssQ0FBbEI7O2NBQ0EsS0FBS0EsS0FBSyxHQUFHRCxHQUFHLEdBQUcsQ0FBbkIsRUFBc0JDLEtBQUssR0FBRzNnRCxHQUFSLElBQWV1L0MsU0FBUyxDQUFDbGdELElBQVYsQ0FBZXlnRCxLQUFLLENBQUNhLEtBQUQsQ0FBcEIsQ0FBckMsRUFBbUUsRUFBRUEsS0FBckUsRUFBNEU7O2NBQzVFLElBQUlDLE1BQU0sR0FBRyxDQUFDRixHQUFHLEdBQUdaLEtBQUssQ0FBQ1ksR0FBRyxHQUFDLENBQUwsQ0FBUixHQUFrQmIsU0FBdEIsS0FBb0MsR0FBakQ7Y0FDQSxJQUFJekYsS0FBSyxHQUFHLENBQUN1RyxLQUFLLEdBQUczZ0QsR0FBUixHQUFjOC9DLEtBQUssQ0FBQ2EsS0FBRCxDQUFuQixHQUE2QmQsU0FBOUIsS0FBNEMsR0FBeEQ7Y0FDQSxJQUFJZ0IsU0FBUyxHQUFHRCxNQUFNLElBQUl4RyxLQUFWLEdBQW1Cd0csTUFBTSxHQUFHLEdBQUgsR0FBUyxHQUFsQyxHQUF5Q2YsU0FBekQ7O2NBQ0EsS0FBSyxJQUFJaUIsR0FBRyxHQUFHSixHQUFmLEVBQW9CSSxHQUFHLEdBQUdILEtBQTFCLEVBQWlDLEVBQUVHLEdBQW5DLEVBQXdDO2dCQUFFaEIsS0FBSyxDQUFDZ0IsR0FBRCxDQUFMLEdBQWFELFNBQWI7OztjQUMxQ0gsR0FBRyxHQUFHQyxLQUFLLEdBQUcsQ0FBZDs7V0EvRTBCOzs7Ozs7O1VBd0Y5QixJQUFJL0IsS0FBSyxHQUFHLEVBQVo7Y0FBZ0JoNkMsQ0FBaEI7O1VBQ0EsS0FBSyxJQUFJbThDLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUcvZ0QsR0FBeEIsR0FBOEI7WUFDNUIsSUFBSXkvQyxZQUFZLENBQUNwZ0QsSUFBYixDQUFrQnlnRCxLQUFLLENBQUNpQixHQUFELENBQXZCLENBQUosRUFBbUM7Y0FDakMsSUFBSWh4QyxLQUFLLEdBQUdneEMsR0FBWjs7Y0FDQSxLQUFLLEVBQUVBLEdBQVAsRUFBWUEsR0FBRyxHQUFHL2dELEdBQU4sSUFBYXkvQyxZQUFZLENBQUNwZ0QsSUFBYixDQUFrQnlnRCxLQUFLLENBQUNpQixHQUFELENBQXZCLENBQXpCLEVBQXdELEVBQUVBLEdBQTFELEVBQStEOztjQUMvRG5DLEtBQUssQ0FBQ3B0RCxJQUFOLENBQVcsSUFBSW11RCxRQUFKLENBQWEsQ0FBYixFQUFnQjV2QyxLQUFoQixFQUF1Qmd4QyxHQUF2QixDQUFYO2FBSEYsTUFJTztjQUNMLElBQUlwNEMsR0FBRyxHQUFHbzRDLEdBQVY7a0JBQWVyc0MsRUFBRSxHQUFHa3FDLEtBQUssQ0FBQ25zRCxNQUExQjtrQkFBa0N1dUQsS0FBSyxHQUFHcEIsU0FBUyxJQUFJLEtBQWIsR0FBcUIsQ0FBckIsR0FBeUIsQ0FBbkU7O2NBQ0EsS0FBSyxFQUFFbUIsR0FBUCxFQUFZQSxHQUFHLEdBQUcvZ0QsR0FBTixJQUFhOC9DLEtBQUssQ0FBQ2lCLEdBQUQsQ0FBTCxJQUFjLEdBQXZDLEVBQTRDLEVBQUVBLEdBQTlDLEVBQW1EOztjQUNuRCxLQUFLLElBQUlFLEdBQUcsR0FBR3Q0QyxHQUFmLEVBQW9CczRDLEdBQUcsR0FBR0YsR0FBMUIsR0FBZ0M7Z0JBQzlCLElBQUlyQixXQUFXLENBQUNyZ0QsSUFBWixDQUFpQnlnRCxLQUFLLENBQUNtQixHQUFELENBQXRCLENBQUosRUFBa0M7a0JBQ2hDLElBQUl0NEMsR0FBRyxHQUFHczRDLEdBQVYsRUFBZTtvQkFBRXJDLEtBQUssQ0FBQy83QixNQUFOLENBQWFuTyxFQUFiLEVBQWlCLENBQWpCLEVBQW9CLElBQUlpckMsUUFBSixDQUFhLENBQWIsRUFBZ0JoM0MsR0FBaEIsRUFBcUJzNEMsR0FBckIsQ0FBcEI7b0JBQWdEdnNDLEVBQUUsSUFBSXNzQyxLQUFOOzs7a0JBQ2pFLElBQUlFLE1BQU0sR0FBR0QsR0FBYjs7a0JBQ0EsS0FBSyxFQUFFQSxHQUFQLEVBQVlBLEdBQUcsR0FBR0YsR0FBTixJQUFhckIsV0FBVyxDQUFDcmdELElBQVosQ0FBaUJ5Z0QsS0FBSyxDQUFDbUIsR0FBRCxDQUF0QixDQUF6QixFQUF1RCxFQUFFQSxHQUF6RCxFQUE4RDs7a0JBQzlEckMsS0FBSyxDQUFDLzdCLE1BQU4sQ0FBYW5PLEVBQWIsRUFBaUIsQ0FBakIsRUFBb0IsSUFBSWlyQyxRQUFKLENBQWEsQ0FBYixFQUFnQnVCLE1BQWhCLEVBQXdCRCxHQUF4QixDQUFwQjtrQkFDQXZzQyxFQUFFLElBQUlzc0MsS0FBTjtrQkFDQXI0QyxHQUFHLEdBQUdzNEMsR0FBTjtpQkFORixNQU9PO2tCQUFFLEVBQUVBLEdBQUY7Ozs7Y0FFWCxJQUFJdDRDLEdBQUcsR0FBR280QyxHQUFWLEVBQWU7Z0JBQUVuQyxLQUFLLENBQUMvN0IsTUFBTixDQUFhbk8sRUFBYixFQUFpQixDQUFqQixFQUFvQixJQUFJaXJDLFFBQUosQ0FBYSxDQUFiLEVBQWdCaDNDLEdBQWhCLEVBQXFCbzRDLEdBQXJCLENBQXBCOzs7OztVQUdyQixJQUFJbkIsU0FBUyxJQUFJLEtBQWpCLEVBQXdCO1lBQ3RCLElBQUloQixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNFLEtBQVQsSUFBa0IsQ0FBbEIsS0FBd0JsNkMsQ0FBQyxHQUFHOUMsR0FBRyxDQUFDckIsS0FBSixDQUFVLE1BQVYsQ0FBNUIsQ0FBSixFQUFvRDtjQUNsRG0rQyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNod0MsSUFBVCxHQUFnQmhLLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS25TLE1BQXJCO2NBQ0Ftc0QsS0FBSyxDQUFDNVQsT0FBTixDQUFjLElBQUkyVSxRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQi82QyxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtuUyxNQUF4QixDQUFkOzs7WUFFRixJQUFJOHFELEdBQUcsQ0FBQ3FCLEtBQUQsQ0FBSCxDQUFXRSxLQUFYLElBQW9CLENBQXBCLEtBQTBCbDZDLENBQUMsR0FBRzlDLEdBQUcsQ0FBQ3JCLEtBQUosQ0FBVSxNQUFWLENBQTlCLENBQUosRUFBc0Q7Y0FDcEQ4OEMsR0FBRyxDQUFDcUIsS0FBRCxDQUFILENBQVd4c0MsRUFBWCxJQUFpQnhOLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS25TLE1BQXRCO2NBQ0Ftc0QsS0FBSyxDQUFDcHRELElBQU4sQ0FBVyxJQUFJbXVELFFBQUosQ0FBYSxDQUFiLEVBQWdCMy9DLEdBQUcsR0FBRzRFLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS25TLE1BQTNCLEVBQW1DdU4sR0FBbkMsQ0FBWDs7OztVQUlKLE9BQU80L0MsU0FBUyxJQUFJLEtBQWIsR0FBcUJoQixLQUFLLENBQUNsNEIsT0FBTixFQUFyQixHQUF1Q2s0QixLQUE5QztTQXpIRjtPQXZCaUIsRUFBbkIsQ0FwV21COzs7OztNQTJmbkIsU0FBU3VDLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCeEIsU0FBeEIsRUFBbUM7UUFDakMsSUFBSWhCLEtBQUssR0FBR3dDLElBQUksQ0FBQ3hDLEtBQWpCOztRQUNBLElBQUlBLEtBQUssSUFBSSxJQUFiLEVBQW1CO1VBQUVBLEtBQUssR0FBR3dDLElBQUksQ0FBQ3hDLEtBQUwsR0FBYU0sWUFBWSxDQUFDa0MsSUFBSSxDQUFDdlEsSUFBTixFQUFZK08sU0FBWixDQUFqQzs7O1FBQ3JCLE9BQU9oQixLQUFQO09BOWZpQjs7Ozs7TUFzZ0JuQixJQUFJeUMsVUFBVSxHQUFHLEVBQWpCOztNQUVBLElBQUlDLEVBQUUsR0FBRyxTQUFMQSxFQUFLLENBQVNDLE9BQVQsRUFBa0J0dUQsSUFBbEIsRUFBd0JsQyxDQUF4QixFQUEyQjtRQUNsQyxJQUFJd3dELE9BQU8sQ0FBQzltQyxnQkFBWixFQUE4QjtVQUM1QjhtQyxPQUFPLENBQUM5bUMsZ0JBQVIsQ0FBeUJ4bkIsSUFBekIsRUFBK0JsQyxDQUEvQixFQUFrQyxLQUFsQztTQURGLE1BRU8sSUFBSXd3RCxPQUFPLENBQUNDLFdBQVosRUFBeUI7VUFDOUJELE9BQU8sQ0FBQ0MsV0FBUixDQUFvQixPQUFPdnVELElBQTNCLEVBQWlDbEMsQ0FBakM7U0FESyxNQUVBO1VBQ0wsSUFBSW9nQixHQUFHLEdBQUdvd0MsT0FBTyxDQUFDRSxTQUFSLEtBQXNCRixPQUFPLENBQUNFLFNBQVIsR0FBb0IsRUFBMUMsQ0FBVjtVQUNBdHdDLEdBQUcsQ0FBQ2xlLElBQUQsQ0FBSCxHQUFZLENBQUNrZSxHQUFHLENBQUNsZSxJQUFELENBQUgsSUFBYW91RCxVQUFkLEVBQTBCandELE1BQTFCLENBQWlDTCxDQUFqQyxDQUFaOztPQVBKOztNQVdBLFNBQVMyd0QsV0FBVCxDQUFxQkgsT0FBckIsRUFBOEJ0dUQsSUFBOUIsRUFBb0M7UUFDbEMsT0FBT3N1RCxPQUFPLENBQUNFLFNBQVIsSUFBcUJGLE9BQU8sQ0FBQ0UsU0FBUixDQUFrQnh1RCxJQUFsQixDQUFyQixJQUFnRG91RCxVQUF2RDs7O01BR0YsU0FBU00sR0FBVCxDQUFhSixPQUFiLEVBQXNCdHVELElBQXRCLEVBQTRCbEMsQ0FBNUIsRUFBK0I7UUFDN0IsSUFBSXd3RCxPQUFPLENBQUN6ZCxtQkFBWixFQUFpQztVQUMvQnlkLE9BQU8sQ0FBQ3pkLG1CQUFSLENBQTRCN3dDLElBQTVCLEVBQWtDbEMsQ0FBbEMsRUFBcUMsS0FBckM7U0FERixNQUVPLElBQUl3d0QsT0FBTyxDQUFDSyxXQUFaLEVBQXlCO1VBQzlCTCxPQUFPLENBQUNLLFdBQVIsQ0FBb0IsT0FBTzN1RCxJQUEzQixFQUFpQ2xDLENBQWpDO1NBREssTUFFQTtVQUNMLElBQUlvZ0IsR0FBRyxHQUFHb3dDLE9BQU8sQ0FBQ0UsU0FBbEI7Y0FBNkIzeUMsR0FBRyxHQUFHcUMsR0FBRyxJQUFJQSxHQUFHLENBQUNsZSxJQUFELENBQTdDOztVQUNBLElBQUk2YixHQUFKLEVBQVM7WUFDUCxJQUFJalksS0FBSyxHQUFHNlUsT0FBTyxDQUFDb0QsR0FBRCxFQUFNL2QsQ0FBTixDQUFuQjs7WUFDQSxJQUFJOEYsS0FBSyxHQUFHLENBQUMsQ0FBYixFQUNFO2NBQUVzYSxHQUFHLENBQUNsZSxJQUFELENBQUgsR0FBWTZiLEdBQUcsQ0FBQzVZLEtBQUosQ0FBVSxDQUFWLEVBQWFXLEtBQWIsRUFBb0J6RixNQUFwQixDQUEyQjBkLEdBQUcsQ0FBQzVZLEtBQUosQ0FBVVcsS0FBSyxHQUFHLENBQWxCLENBQTNCLENBQVo7Ozs7OztNQUtWLFNBQVNnckQsTUFBVCxDQUFnQk4sT0FBaEIsRUFBeUJ0dUQ7O1FBQXNCO1FBQzdDLElBQUk2dUQsUUFBUSxHQUFHSixXQUFXLENBQUNILE9BQUQsRUFBVXR1RCxJQUFWLENBQTFCOztRQUNBLElBQUksQ0FBQzZ1RCxRQUFRLENBQUNydkQsTUFBZCxFQUFzQjtVQUFFOzs7UUFDeEIsSUFBSTZLLElBQUksR0FBR2xGLEtBQUssQ0FBQzdGLFNBQU4sQ0FBZ0IyRCxLQUFoQixDQUFzQnZILElBQXRCLENBQTJCbUUsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDs7UUFDQSxLQUFLLElBQUkrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaXRELFFBQVEsQ0FBQ3J2RCxNQUE3QixFQUFxQyxFQUFFb0MsQ0FBdkMsRUFBMEM7VUFBRWl0RCxRQUFRLENBQUNqdEQsQ0FBRCxDQUFSLENBQVloQyxLQUFaLENBQWtCLElBQWxCLEVBQXdCeUssSUFBeEI7O09BMWlCM0I7Ozs7O01BZ2pCbkIsU0FBU3lrRCxjQUFULENBQXdCQyxFQUF4QixFQUE0Qm56RCxDQUE1QixFQUErQm96RCxRQUEvQixFQUF5QztRQUN2QyxJQUFJLE9BQU9wekQsQ0FBUCxJQUFZLFFBQWhCLEVBQ0U7VUFBRUEsQ0FBQyxHQUFHO1lBQUNvRSxJQUFJLEVBQUVwRSxDQUFQO1lBQVU4OUMsY0FBYyxFQUFFLDBCQUFXO2NBQUUsS0FBS3VWLGdCQUFMLEdBQXdCLElBQXhCOztXQUEzQzs7O1FBQ0pMLE1BQU0sQ0FBQ0csRUFBRCxFQUFLQyxRQUFRLElBQUlwekQsQ0FBQyxDQUFDb0UsSUFBbkIsRUFBeUIrdUQsRUFBekIsRUFBNkJuekQsQ0FBN0IsQ0FBTjtRQUNBLE9BQU9zekQsa0JBQWtCLENBQUN0ekQsQ0FBRCxDQUFsQixJQUF5QkEsQ0FBQyxDQUFDdXpELGdCQUFsQzs7O01BR0YsU0FBU0Msb0JBQVQsQ0FBOEJMLEVBQTlCLEVBQWtDO1FBQ2hDLElBQUlsekMsR0FBRyxHQUFHa3pDLEVBQUUsQ0FBQ1AsU0FBSCxJQUFnQk8sRUFBRSxDQUFDUCxTQUFILENBQWFhLGNBQXZDOztRQUNBLElBQUksQ0FBQ3h6QyxHQUFMLEVBQVU7VUFBRTs7O1FBQ1osSUFBSXBTLEdBQUcsR0FBR3NsRCxFQUFFLENBQUNPLEtBQUgsQ0FBU0Msc0JBQVQsS0FBb0NSLEVBQUUsQ0FBQ08sS0FBSCxDQUFTQyxzQkFBVCxHQUFrQyxFQUF0RSxDQUFWOztRQUNBLEtBQUssSUFBSTN0RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaWEsR0FBRyxDQUFDcmMsTUFBeEIsRUFBZ0MsRUFBRW9DLENBQWxDLEVBQXFDO1VBQUUsSUFBSTZXLE9BQU8sQ0FBQ2hQLEdBQUQsRUFBTW9TLEdBQUcsQ0FBQ2phLENBQUQsQ0FBVCxDQUFQLElBQXdCLENBQUMsQ0FBN0IsRUFDckM7WUFBRTZILEdBQUcsQ0FBQ2xMLElBQUosQ0FBU3NkLEdBQUcsQ0FBQ2phLENBQUQsQ0FBWjs7Ozs7TUFHTixTQUFTNHRELFVBQVQsQ0FBb0JsQixPQUFwQixFQUE2QnR1RCxJQUE3QixFQUFtQztRQUNqQyxPQUFPeXVELFdBQVcsQ0FBQ0gsT0FBRCxFQUFVdHVELElBQVYsQ0FBWCxDQUEyQlIsTUFBM0IsR0FBb0MsQ0FBM0M7T0Foa0JpQjs7OztNQXFrQm5CLFNBQVNpd0QsVUFBVCxDQUFvQnByQixJQUFwQixFQUEwQjtRQUN4QkEsSUFBSSxDQUFDL2tDLFNBQUwsQ0FBZSt1RCxFQUFmLEdBQW9CLFVBQVNydUQsSUFBVCxFQUFlbEMsQ0FBZixFQUFrQjtVQUFDdXdELEVBQUUsQ0FBQyxJQUFELEVBQU9ydUQsSUFBUCxFQUFhbEMsQ0FBYixDQUFGO1NBQXZDOztRQUNBdW1DLElBQUksQ0FBQy9rQyxTQUFMLENBQWVvdkQsR0FBZixHQUFxQixVQUFTMXVELElBQVQsRUFBZWxDLENBQWYsRUFBa0I7VUFBQzR3RCxHQUFHLENBQUMsSUFBRCxFQUFPMXVELElBQVAsRUFBYWxDLENBQWIsQ0FBSDtTQUF4QztPQXZrQmlCOzs7O01BNmtCbkIsU0FBUzR4RCxnQkFBVCxDQUEwQjl6RCxDQUExQixFQUE2QjtRQUMzQixJQUFJQSxDQUFDLENBQUM4OUMsY0FBTixFQUFzQjtVQUFFOTlDLENBQUMsQ0FBQzg5QyxjQUFGO1NBQXhCLE1BQ0s7VUFBRTk5QyxDQUFDLENBQUMrekQsV0FBRixHQUFnQixLQUFoQjs7OztNQUVULFNBQVNDLGlCQUFULENBQTJCaDBELENBQTNCLEVBQThCO1FBQzVCLElBQUlBLENBQUMsQ0FBQzRpRCxlQUFOLEVBQXVCO1VBQUU1aUQsQ0FBQyxDQUFDNGlELGVBQUY7U0FBekIsTUFDSztVQUFFNWlELENBQUMsQ0FBQ2kwRCxZQUFGLEdBQWlCLElBQWpCOzs7O01BRVQsU0FBU1gsa0JBQVQsQ0FBNEJ0ekQsQ0FBNUIsRUFBK0I7UUFDN0IsT0FBT0EsQ0FBQyxDQUFDcXpELGdCQUFGLElBQXNCLElBQXRCLEdBQTZCcnpELENBQUMsQ0FBQ3F6RCxnQkFBL0IsR0FBa0RyekQsQ0FBQyxDQUFDK3pELFdBQUYsSUFBaUIsS0FBMUU7OztNQUVGLFNBQVNHLE1BQVQsQ0FBZ0JsMEQsQ0FBaEIsRUFBbUI7UUFBQzh6RCxnQkFBZ0IsQ0FBQzl6RCxDQUFELENBQWhCO1FBQXFCZzBELGlCQUFpQixDQUFDaDBELENBQUQsQ0FBakI7OztNQUV6QyxTQUFTbTBELFFBQVQsQ0FBa0JuMEQsQ0FBbEIsRUFBcUI7UUFBQyxPQUFPQSxDQUFDLENBQUMrRSxNQUFGLElBQVkvRSxDQUFDLENBQUNvMEQsVUFBckI7OztNQUN0QixTQUFTQyxRQUFULENBQWtCcjBELENBQWxCLEVBQXFCO1FBQ25CLElBQUk4RCxDQUFDLEdBQUc5RCxDQUFDLENBQUNpb0QsS0FBVjs7UUFDQSxJQUFJbmtELENBQUMsSUFBSSxJQUFULEVBQWU7VUFDYixJQUFJOUQsQ0FBQyxDQUFDczBELE1BQUYsR0FBVyxDQUFmLEVBQWtCO1lBQUV4d0QsQ0FBQyxHQUFHLENBQUo7V0FBcEIsTUFDSyxJQUFJOUQsQ0FBQyxDQUFDczBELE1BQUYsR0FBVyxDQUFmLEVBQWtCO1lBQUV4d0QsQ0FBQyxHQUFHLENBQUo7V0FBcEIsTUFDQSxJQUFJOUQsQ0FBQyxDQUFDczBELE1BQUYsR0FBVyxDQUFmLEVBQWtCO1lBQUV4d0QsQ0FBQyxHQUFHLENBQUo7Ozs7UUFFM0IsSUFBSThtRCxHQUFHLElBQUk1cUQsQ0FBQyxDQUFDdTBELE9BQVQsSUFBb0J6d0QsQ0FBQyxJQUFJLENBQTdCLEVBQWdDO1VBQUVBLENBQUMsR0FBRyxDQUFKOzs7UUFDbEMsT0FBT0EsQ0FBUDtPQW5tQmlCOzs7TUF1bUJuQixJQUFJMHdELFdBQVcsR0FBRyxZQUFXOzs7UUFHM0IsSUFBSTNLLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO1VBQUUsT0FBTyxLQUFQOzs7UUFDNUIsSUFBSXB4QyxHQUFHLEdBQUdnekMsR0FBRyxDQUFDLEtBQUQsQ0FBYjtRQUNBLE9BQU8sZUFBZWh6QyxHQUFmLElBQXNCLGNBQWNBLEdBQTNDO09BTGdCLEVBQWxCOztNQVFBLElBQUkrN0MsYUFBSjs7TUFDQSxTQUFTQyxnQkFBVCxDQUEwQkMsT0FBMUIsRUFBbUM7UUFDakMsSUFBSUYsYUFBYSxJQUFJLElBQXJCLEVBQTJCO1VBQ3pCLElBQUlqa0QsSUFBSSxHQUFHazdDLEdBQUcsQ0FBQyxNQUFELEVBQVMsUUFBVCxDQUFkO1VBQ0FELG9CQUFvQixDQUFDa0osT0FBRCxFQUFVakosR0FBRyxDQUFDLE1BQUQsRUFBUyxDQUFDbDdDLElBQUQsRUFBTzdQLFFBQVEsQ0FBQ3lzQixjQUFULENBQXdCLEdBQXhCLENBQVAsQ0FBVCxDQUFiLENBQXBCOztVQUNBLElBQUl1bkMsT0FBTyxDQUFDOWtCLFVBQVIsQ0FBbUIra0IsWUFBbkIsSUFBbUMsQ0FBdkMsRUFDRTtZQUFFSCxhQUFhLEdBQUdqa0QsSUFBSSxDQUFDcWtELFdBQUwsSUFBb0IsQ0FBcEIsSUFBeUJya0QsSUFBSSxDQUFDb2tELFlBQUwsR0FBb0IsQ0FBN0MsSUFBa0QsRUFBRS9LLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXJCLENBQWxFOzs7O1FBRU4sSUFBSTM4QixJQUFJLEdBQUdzbkMsYUFBYSxHQUFHL0ksR0FBRyxDQUFDLE1BQUQsRUFBUyxRQUFULENBQU4sR0FDdEJBLEdBQUcsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixJQUFuQixFQUF5Qix1REFBekIsQ0FETDtRQUVBditCLElBQUksQ0FBQ3FuQixZQUFMLENBQWtCLFNBQWxCLEVBQTZCLEVBQTdCO1FBQ0EsT0FBT3JuQixJQUFQO09BMW5CaUI7OztNQThuQm5CLElBQUkybkMsWUFBSjs7TUFDQSxTQUFTQyxlQUFULENBQXlCSixPQUF6QixFQUFrQztRQUNoQyxJQUFJRyxZQUFZLElBQUksSUFBcEIsRUFBMEI7VUFBRSxPQUFPQSxZQUFQOzs7UUFDNUIsSUFBSUUsR0FBRyxHQUFHdkosb0JBQW9CLENBQUNrSixPQUFELEVBQVVoMEQsUUFBUSxDQUFDeXNCLGNBQVQsQ0FBd0IsVUFBeEIsQ0FBVixDQUE5QjtRQUNBLElBQUk2bkMsRUFBRSxHQUFHbFMsS0FBSyxDQUFDaVMsR0FBRCxFQUFNLENBQU4sRUFBUyxDQUFULENBQUwsQ0FBaUIxVSxxQkFBakIsRUFBVDtRQUNBLElBQUk0VSxFQUFFLEdBQUduUyxLQUFLLENBQUNpUyxHQUFELEVBQU0sQ0FBTixFQUFTLENBQVQsQ0FBTCxDQUFpQjFVLHFCQUFqQixFQUFUO1FBQ0FrTCxjQUFjLENBQUNtSixPQUFELENBQWQ7O1FBQ0EsSUFBSSxDQUFDTSxFQUFELElBQU9BLEVBQUUsQ0FBQ255QixJQUFILElBQVdteUIsRUFBRSxDQUFDRSxLQUF6QixFQUFnQztVQUFFLE9BQU8sS0FBUDtTQU5GOzs7UUFPaEMsT0FBT0wsWUFBWSxHQUFJSSxFQUFFLENBQUNDLEtBQUgsR0FBV0YsRUFBRSxDQUFDRSxLQUFkLEdBQXNCLENBQTdDO09BdG9CaUI7Ozs7TUEyb0JuQixJQUFJQyxjQUFjLEdBQUcsUUFBUWx5RCxLQUFSLENBQWMsSUFBZCxFQUFvQlUsTUFBcEIsSUFBOEIsQ0FBOUIsR0FBa0MsVUFBVTZPLE1BQVYsRUFBa0I7UUFDdkUsSUFBSXFILEdBQUcsR0FBRyxDQUFWO1lBQWFsUixNQUFNLEdBQUcsRUFBdEI7WUFBMEJ3RSxDQUFDLEdBQUdxRixNQUFNLENBQUM3TyxNQUFyQzs7UUFDQSxPQUFPa1csR0FBRyxJQUFJMU0sQ0FBZCxFQUFpQjtVQUNmLElBQUlpb0QsRUFBRSxHQUFHNWlELE1BQU0sQ0FBQ29LLE9BQVAsQ0FBZSxJQUFmLEVBQXFCL0MsR0FBckIsQ0FBVDs7VUFDQSxJQUFJdTdDLEVBQUUsSUFBSSxDQUFDLENBQVgsRUFBYztZQUFFQSxFQUFFLEdBQUc1aUQsTUFBTSxDQUFDN08sTUFBWjs7O1VBQ2hCLElBQUkydUQsSUFBSSxHQUFHOS9DLE1BQU0sQ0FBQ3BMLEtBQVAsQ0FBYXlTLEdBQWIsRUFBa0JySCxNQUFNLENBQUN0TCxNQUFQLENBQWNrdUQsRUFBRSxHQUFHLENBQW5CLEtBQXlCLElBQXpCLEdBQWdDQSxFQUFFLEdBQUcsQ0FBckMsR0FBeUNBLEVBQTNELENBQVg7VUFDQSxJQUFJMytCLEVBQUUsR0FBRzY3QixJQUFJLENBQUMxMUMsT0FBTCxDQUFhLElBQWIsQ0FBVDs7VUFDQSxJQUFJNlosRUFBRSxJQUFJLENBQUMsQ0FBWCxFQUFjO1lBQ1o5dEIsTUFBTSxDQUFDakcsSUFBUCxDQUFZNHZELElBQUksQ0FBQ2xyRCxLQUFMLENBQVcsQ0FBWCxFQUFjcXZCLEVBQWQsQ0FBWjtZQUNBNWMsR0FBRyxJQUFJNGMsRUFBRSxHQUFHLENBQVo7V0FGRixNQUdPO1lBQ0w5dEIsTUFBTSxDQUFDakcsSUFBUCxDQUFZNHZELElBQVo7WUFDQXo0QyxHQUFHLEdBQUd1N0MsRUFBRSxHQUFHLENBQVg7Ozs7UUFHSixPQUFPenNELE1BQVA7T0FmbUIsR0FnQmpCLFVBQVU2SixNQUFWLEVBQWtCO1FBQUUsT0FBT0EsTUFBTSxDQUFDdlAsS0FBUCxDQUFhLFVBQWIsQ0FBUDtPQWhCeEI7TUFrQkEsSUFBSW95RCxZQUFZLEdBQUdoMkQsTUFBTSxDQUFDaTJELFlBQVAsR0FBc0IsVUFBVUMsRUFBVixFQUFjO1FBQ3JELElBQUk7VUFBRSxPQUFPQSxFQUFFLENBQUMzSSxjQUFILElBQXFCMkksRUFBRSxDQUFDMUksWUFBL0I7U0FBTixDQUNBLE9BQU05c0QsQ0FBTixFQUFTO1VBQUUsT0FBTyxLQUFQOztPQUZNLEdBR2YsVUFBVXcxRCxFQUFWLEVBQWM7UUFDaEIsSUFBSXpTLEtBQUo7O1FBQ0EsSUFBSTtVQUFDQSxLQUFLLEdBQUd5UyxFQUFFLENBQUNDLGFBQUgsQ0FBaUJDLFNBQWpCLENBQTJCOUosV0FBM0IsRUFBUjtTQUFMLENBQ0EsT0FBTTVyRCxDQUFOLEVBQVM7O1FBQ1QsSUFBSSxDQUFDK2lELEtBQUQsSUFBVUEsS0FBSyxDQUFDNFMsYUFBTixNQUF5QkgsRUFBdkMsRUFBMkM7VUFBRSxPQUFPLEtBQVA7OztRQUM3QyxPQUFPelMsS0FBSyxDQUFDNlMsZ0JBQU4sQ0FBdUIsWUFBdkIsRUFBcUM3UyxLQUFyQyxLQUErQyxDQUF0RDtPQVJGOztNQVdBLElBQUk4UyxZQUFZLEdBQUksWUFBWTtRQUM5QixJQUFJNzFELENBQUMsR0FBRzByRCxHQUFHLENBQUMsS0FBRCxDQUFYOztRQUNBLElBQUksWUFBWTFyRCxDQUFoQixFQUFtQjtVQUFFLE9BQU8sSUFBUDs7O1FBQ3JCQSxDQUFDLENBQUN3MEMsWUFBRixDQUFlLFFBQWYsRUFBeUIsU0FBekI7UUFDQSxPQUFPLE9BQU94MEMsQ0FBQyxDQUFDODFELE1BQVQsSUFBbUIsVUFBMUI7T0FKaUIsRUFBbkI7O01BT0EsSUFBSUMsY0FBYyxHQUFHLElBQXJCOztNQUNBLFNBQVNDLGlCQUFULENBQTJCckIsT0FBM0IsRUFBb0M7UUFDbEMsSUFBSW9CLGNBQWMsSUFBSSxJQUF0QixFQUE0QjtVQUFFLE9BQU9BLGNBQVA7OztRQUM5QixJQUFJNW9DLElBQUksR0FBR3MrQixvQkFBb0IsQ0FBQ2tKLE9BQUQsRUFBVWpKLEdBQUcsQ0FBQyxNQUFELEVBQVMsR0FBVCxDQUFiLENBQS9CO1FBQ0EsSUFBSXVLLE1BQU0sR0FBRzlvQyxJQUFJLENBQUNtekIscUJBQUwsRUFBYjtRQUNBLElBQUk0VixTQUFTLEdBQUduVCxLQUFLLENBQUM1MUIsSUFBRCxFQUFPLENBQVAsRUFBVSxDQUFWLENBQUwsQ0FBa0JtekIscUJBQWxCLEVBQWhCO1FBQ0EsT0FBT3lWLGNBQWMsR0FBR3gyRCxJQUFJLENBQUNrWCxHQUFMLENBQVN3L0MsTUFBTSxDQUFDbnpCLElBQVAsR0FBY296QixTQUFTLENBQUNwekIsSUFBakMsSUFBeUMsQ0FBakU7T0FyckJpQjs7O01BeXJCbkIsSUFBSXF6QixLQUFLLEdBQUcsRUFBWjtVQUFnQkMsU0FBUyxHQUFHLEVBQTVCLENBenJCbUI7Ozs7TUE4ckJuQixTQUFTQyxVQUFULENBQW9CaHlELElBQXBCLEVBQTBCekIsSUFBMUIsRUFBZ0M7UUFDOUIsSUFBSXFCLFNBQVMsQ0FBQ0wsTUFBVixHQUFtQixDQUF2QixFQUNFO1VBQUVoQixJQUFJLENBQUMwekQsWUFBTCxHQUFvQi9zRCxLQUFLLENBQUM3RixTQUFOLENBQWdCMkQsS0FBaEIsQ0FBc0J2SCxJQUF0QixDQUEyQm1FLFNBQTNCLEVBQXNDLENBQXRDLENBQXBCOzs7UUFDSmt5RCxLQUFLLENBQUM5eEQsSUFBRCxDQUFMLEdBQWN6QixJQUFkOzs7TUFHRixTQUFTMnpELFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCQyxJQUExQixFQUFnQztRQUM5QkwsU0FBUyxDQUFDSSxJQUFELENBQVQsR0FBa0JDLElBQWxCO09BcnNCaUI7Ozs7TUEwc0JuQixTQUFTQyxXQUFULENBQXFCRCxJQUFyQixFQUEyQjtRQUN6QixJQUFJLE9BQU9BLElBQVAsSUFBZSxRQUFmLElBQTJCTCxTQUFTLENBQUN6MkQsY0FBVixDQUF5QjgyRCxJQUF6QixDQUEvQixFQUErRDtVQUM3REEsSUFBSSxHQUFHTCxTQUFTLENBQUNLLElBQUQsQ0FBaEI7U0FERixNQUVPLElBQUlBLElBQUksSUFBSSxPQUFPQSxJQUFJLENBQUNweUQsSUFBWixJQUFvQixRQUE1QixJQUF3Qyt4RCxTQUFTLENBQUN6MkQsY0FBVixDQUF5QjgyRCxJQUFJLENBQUNweUQsSUFBOUIsQ0FBNUMsRUFBaUY7VUFDdEYsSUFBSTJyRCxLQUFLLEdBQUdvRyxTQUFTLENBQUNLLElBQUksQ0FBQ3B5RCxJQUFOLENBQXJCOztVQUNBLElBQUksT0FBTzJyRCxLQUFQLElBQWdCLFFBQXBCLEVBQThCO1lBQUVBLEtBQUssR0FBRztjQUFDM3JELElBQUksRUFBRTJyRDthQUFmOzs7VUFDaEN5RyxJQUFJLEdBQUczSCxTQUFTLENBQUNrQixLQUFELEVBQVF5RyxJQUFSLENBQWhCO1VBQ0FBLElBQUksQ0FBQ3B5RCxJQUFMLEdBQVkyckQsS0FBSyxDQUFDM3JELElBQWxCO1NBSkssTUFLQSxJQUFJLE9BQU9veUQsSUFBUCxJQUFlLFFBQWYsSUFBMkIsMEJBQTBCam1ELElBQTFCLENBQStCaW1ELElBQS9CLENBQS9CLEVBQXFFO1VBQzFFLE9BQU9DLFdBQVcsQ0FBQyxpQkFBRCxDQUFsQjtTQURLLE1BRUEsSUFBSSxPQUFPRCxJQUFQLElBQWUsUUFBZixJQUEyQiwyQkFBMkJqbUQsSUFBM0IsQ0FBZ0NpbUQsSUFBaEMsQ0FBL0IsRUFBc0U7VUFDM0UsT0FBT0MsV0FBVyxDQUFDLGtCQUFELENBQWxCOzs7UUFFRixJQUFJLE9BQU9ELElBQVAsSUFBZSxRQUFuQixFQUE2QjtVQUFFLE9BQU87WUFBQ3B5RCxJQUFJLEVBQUVveUQ7V0FBZDtTQUEvQixNQUNLO1VBQUUsT0FBT0EsSUFBSSxJQUFJO1lBQUNweUQsSUFBSSxFQUFFO1dBQXRCOztPQXh0QlU7Ozs7TUE2dEJuQixTQUFTc3lELE9BQVQsQ0FBaUJ6b0IsT0FBakIsRUFBMEJ1b0IsSUFBMUIsRUFBZ0M7UUFDOUJBLElBQUksR0FBR0MsV0FBVyxDQUFDRCxJQUFELENBQWxCO1FBQ0EsSUFBSUcsUUFBUSxHQUFHVCxLQUFLLENBQUNNLElBQUksQ0FBQ3B5RCxJQUFOLENBQXBCOztRQUNBLElBQUksQ0FBQ3V5RCxRQUFMLEVBQWU7VUFBRSxPQUFPRCxPQUFPLENBQUN6b0IsT0FBRCxFQUFVLFlBQVYsQ0FBZDs7O1FBQ2pCLElBQUkyb0IsT0FBTyxHQUFHRCxRQUFRLENBQUMxb0IsT0FBRCxFQUFVdW9CLElBQVYsQ0FBdEI7O1FBQ0EsSUFBSUssY0FBYyxDQUFDbjNELGNBQWYsQ0FBOEI4MkQsSUFBSSxDQUFDcHlELElBQW5DLENBQUosRUFBOEM7VUFDNUMsSUFBSTB5RCxJQUFJLEdBQUdELGNBQWMsQ0FBQ0wsSUFBSSxDQUFDcHlELElBQU4sQ0FBekI7O1VBQ0EsS0FBSyxJQUFJNm9ELElBQVQsSUFBaUI2SixJQUFqQixFQUF1QjtZQUNyQixJQUFJLENBQUNBLElBQUksQ0FBQ3AzRCxjQUFMLENBQW9CdXRELElBQXBCLENBQUwsRUFBZ0M7Y0FBRTs7O1lBQ2xDLElBQUkySixPQUFPLENBQUNsM0QsY0FBUixDQUF1QnV0RCxJQUF2QixDQUFKLEVBQWtDO2NBQUUySixPQUFPLENBQUMsTUFBTTNKLElBQVAsQ0FBUCxHQUFzQjJKLE9BQU8sQ0FBQzNKLElBQUQsQ0FBN0I7OztZQUNwQzJKLE9BQU8sQ0FBQzNKLElBQUQsQ0FBUCxHQUFnQjZKLElBQUksQ0FBQzdKLElBQUQsQ0FBcEI7Ozs7UUFHSjJKLE9BQU8sQ0FBQ3h5RCxJQUFSLEdBQWVveUQsSUFBSSxDQUFDcHlELElBQXBCOztRQUNBLElBQUlveUQsSUFBSSxDQUFDTyxVQUFULEVBQXFCO1VBQUVILE9BQU8sQ0FBQ0csVUFBUixHQUFxQlAsSUFBSSxDQUFDTyxVQUExQjs7O1FBQ3ZCLElBQUlQLElBQUksQ0FBQ1EsU0FBVCxFQUFvQjtVQUFFLEtBQUssSUFBSUMsTUFBVCxJQUFtQlQsSUFBSSxDQUFDUSxTQUF4QixFQUNwQjtZQUFFSixPQUFPLENBQUNLLE1BQUQsQ0FBUCxHQUFrQlQsSUFBSSxDQUFDUSxTQUFMLENBQWVDLE1BQWYsQ0FBbEI7Ozs7UUFFSixPQUFPTCxPQUFQO09BL3VCaUI7Ozs7TUFvdkJuQixJQUFJQyxjQUFjLEdBQUcsRUFBckI7O01BQ0EsU0FBU0ssVUFBVCxDQUFvQnYwRCxJQUFwQixFQUEwQm01QyxVQUExQixFQUFzQztRQUNwQyxJQUFJZ2IsSUFBSSxHQUFHRCxjQUFjLENBQUNuM0QsY0FBZixDQUE4QmlELElBQTlCLElBQXNDazBELGNBQWMsQ0FBQ2wwRCxJQUFELENBQXBELEdBQThEazBELGNBQWMsQ0FBQ2wwRCxJQUFELENBQWQsR0FBdUIsRUFBaEc7UUFDQW9xRCxPQUFPLENBQUNqUixVQUFELEVBQWFnYixJQUFiLENBQVA7OztNQUdGLFNBQVNLLFNBQVQsQ0FBbUJ4MEQsSUFBbkIsRUFBeUJ5bUMsS0FBekIsRUFBZ0M7UUFDOUIsSUFBSUEsS0FBSyxLQUFLLElBQWQsRUFBb0I7VUFBRSxPQUFPQSxLQUFQOzs7UUFDdEIsSUFBSXptQyxJQUFJLENBQUN3MEQsU0FBVCxFQUFvQjtVQUFFLE9BQU94MEQsSUFBSSxDQUFDdzBELFNBQUwsQ0FBZS90QixLQUFmLENBQVA7OztRQUN0QixJQUFJZ3VCLE1BQU0sR0FBRyxFQUFiOztRQUNBLEtBQUssSUFBSWptRCxDQUFULElBQWNpNEIsS0FBZCxFQUFxQjtVQUNuQixJQUFJbm9DLEdBQUcsR0FBR21vQyxLQUFLLENBQUNqNEIsQ0FBRCxDQUFmOztVQUNBLElBQUlsUSxHQUFHLFlBQVlxSSxLQUFuQixFQUEwQjtZQUFFckksR0FBRyxHQUFHQSxHQUFHLENBQUNxQixNQUFKLENBQVcsRUFBWCxDQUFOOzs7VUFDNUI4MEQsTUFBTSxDQUFDam1ELENBQUQsQ0FBTixHQUFZbFEsR0FBWjs7O1FBRUYsT0FBT20yRCxNQUFQO09BbndCaUI7Ozs7TUF3d0JuQixTQUFTQyxTQUFULENBQW1CMTBELElBQW5CLEVBQXlCeW1DLEtBQXpCLEVBQWdDO1FBQzlCLElBQUlVLElBQUo7O1FBQ0EsT0FBT25uQyxJQUFJLENBQUMwMEQsU0FBWixFQUF1QjtVQUNyQnZ0QixJQUFJLEdBQUdubkMsSUFBSSxDQUFDMDBELFNBQUwsQ0FBZWp1QixLQUFmLENBQVA7O1VBQ0EsSUFBSSxDQUFDVSxJQUFELElBQVNBLElBQUksQ0FBQ25uQyxJQUFMLElBQWFBLElBQTFCLEVBQWdDO1lBQUU7OztVQUNsQ3ltQyxLQUFLLEdBQUdVLElBQUksQ0FBQ1YsS0FBYjtVQUNBem1DLElBQUksR0FBR21uQyxJQUFJLENBQUNubkMsSUFBWjs7O1FBRUYsT0FBT21uQyxJQUFJLElBQUk7VUFBQ25uQyxJQUFJLEVBQUVBLElBQVA7VUFBYXltQyxLQUFLLEVBQUVBO1NBQW5DOzs7TUFHRixTQUFTa3VCLFVBQVQsQ0FBb0IzMEQsSUFBcEIsRUFBMEI0MEQsRUFBMUIsRUFBOEJDLEVBQTlCLEVBQWtDO1FBQ2hDLE9BQU83MEQsSUFBSSxDQUFDMjBELFVBQUwsR0FBa0IzMEQsSUFBSSxDQUFDMjBELFVBQUwsQ0FBZ0JDLEVBQWhCLEVBQW9CQyxFQUFwQixDQUFsQixHQUE0QyxJQUFuRDtPQXB4QmlCOzs7OztNQTR4Qm5CLElBQUlDLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQVNqbEQsTUFBVCxFQUFpQjI2QyxPQUFqQixFQUEwQnVLLFVBQTFCLEVBQXNDO1FBQ3ZELEtBQUs3OUMsR0FBTCxHQUFXLEtBQUtvSCxLQUFMLEdBQWEsQ0FBeEI7UUFDQSxLQUFLek8sTUFBTCxHQUFjQSxNQUFkO1FBQ0EsS0FBSzI2QyxPQUFMLEdBQWVBLE9BQU8sSUFBSSxDQUExQjtRQUNBLEtBQUt3SyxhQUFMLEdBQXFCLEtBQUtDLGVBQUwsR0FBdUIsQ0FBNUM7UUFDQSxLQUFLQyxTQUFMLEdBQWlCLENBQWpCO1FBQ0EsS0FBS0gsVUFBTCxHQUFrQkEsVUFBbEI7T0FORjs7TUFTQUQsWUFBWSxDQUFDaDBELFNBQWIsQ0FBdUJxMEQsR0FBdkIsR0FBNkIsWUFBWTtRQUFDLE9BQU8sS0FBS2orQyxHQUFMLElBQVksS0FBS3JILE1BQUwsQ0FBWTdPLE1BQS9CO09BQTFDOztNQUNBOHpELFlBQVksQ0FBQ2gwRCxTQUFiLENBQXVCczBELEdBQXZCLEdBQTZCLFlBQVk7UUFBQyxPQUFPLEtBQUtsK0MsR0FBTCxJQUFZLEtBQUtnK0MsU0FBeEI7T0FBMUM7O01BQ0FKLFlBQVksQ0FBQ2gwRCxTQUFiLENBQXVCdTBELElBQXZCLEdBQThCLFlBQVk7UUFBQyxPQUFPLEtBQUt4bEQsTUFBTCxDQUFZdEwsTUFBWixDQUFtQixLQUFLMlMsR0FBeEIsS0FBZ0N0WCxTQUF2QztPQUEzQzs7TUFDQWsxRCxZQUFZLENBQUNoMEQsU0FBYixDQUF1QnVXLElBQXZCLEdBQThCLFlBQVk7UUFDeEMsSUFBSSxLQUFLSCxHQUFMLEdBQVcsS0FBS3JILE1BQUwsQ0FBWTdPLE1BQTNCLEVBQ0U7VUFBRSxPQUFPLEtBQUs2TyxNQUFMLENBQVl0TCxNQUFaLENBQW1CLEtBQUsyUyxHQUFMLEVBQW5CLENBQVA7O09BRk47O01BSUE0OUMsWUFBWSxDQUFDaDBELFNBQWIsQ0FBdUJ3MEQsR0FBdkIsR0FBNkIsVUFBVXRtRCxLQUFWLEVBQWlCO1FBQzVDLElBQUk2VyxFQUFFLEdBQUcsS0FBS2hXLE1BQUwsQ0FBWXRMLE1BQVosQ0FBbUIsS0FBSzJTLEdBQXhCLENBQVQ7UUFDQSxJQUFJd1YsRUFBSjs7UUFDQSxJQUFJLE9BQU8xZCxLQUFQLElBQWdCLFFBQXBCLEVBQThCO1VBQUUwZCxFQUFFLEdBQUc3RyxFQUFFLElBQUk3VyxLQUFYO1NBQWhDLE1BQ0s7VUFBRTBkLEVBQUUsR0FBRzdHLEVBQUUsS0FBSzdXLEtBQUssQ0FBQ3BCLElBQU4sR0FBYW9CLEtBQUssQ0FBQ3BCLElBQU4sQ0FBV2lZLEVBQVgsQ0FBYixHQUE4QjdXLEtBQUssQ0FBQzZXLEVBQUQsQ0FBeEMsQ0FBUDs7O1FBQ1AsSUFBSTZHLEVBQUosRUFBUTtVQUFDLEVBQUUsS0FBS3hWLEdBQVA7VUFBWSxPQUFPMk8sRUFBUDs7T0FMdkI7O01BT0FpdkMsWUFBWSxDQUFDaDBELFNBQWIsQ0FBdUJ5MEQsUUFBdkIsR0FBa0MsVUFBVXZtRCxLQUFWLEVBQWlCO1FBQ2pELElBQUlzUCxLQUFLLEdBQUcsS0FBS3BILEdBQWpCOztRQUNBLE9BQU8sS0FBS28rQyxHQUFMLENBQVN0bUQsS0FBVCxDQUFQLEVBQXVCOztRQUN2QixPQUFPLEtBQUtrSSxHQUFMLEdBQVdvSCxLQUFsQjtPQUhGOztNQUtBdzJDLFlBQVksQ0FBQ2gwRCxTQUFiLENBQXVCMDBELFFBQXZCLEdBQWtDLFlBQVk7UUFDNUMsSUFBSWwzQyxLQUFLLEdBQUcsS0FBS3BILEdBQWpCOztRQUNBLE9BQU8sYUFBYXRKLElBQWIsQ0FBa0IsS0FBS2lDLE1BQUwsQ0FBWXRMLE1BQVosQ0FBbUIsS0FBSzJTLEdBQXhCLENBQWxCLENBQVAsRUFBd0Q7VUFBRSxFQUFFLEtBQUtBLEdBQVA7OztRQUMxRCxPQUFPLEtBQUtBLEdBQUwsR0FBV29ILEtBQWxCO09BSEY7O01BS0F3MkMsWUFBWSxDQUFDaDBELFNBQWIsQ0FBdUIyMEQsU0FBdkIsR0FBbUMsWUFBWTtRQUFDLEtBQUt2K0MsR0FBTCxHQUFXLEtBQUtySCxNQUFMLENBQVk3TyxNQUF2QjtPQUFoRDs7TUFDQTh6RCxZQUFZLENBQUNoMEQsU0FBYixDQUF1QjQwRCxNQUF2QixHQUFnQyxVQUFVN3ZDLEVBQVYsRUFBYztRQUM1QyxJQUFJdW5DLEtBQUssR0FBRyxLQUFLdjlDLE1BQUwsQ0FBWW9LLE9BQVosQ0FBb0I0TCxFQUFwQixFQUF3QixLQUFLM08sR0FBN0IsQ0FBWjs7UUFDQSxJQUFJazJDLEtBQUssR0FBRyxDQUFDLENBQWIsRUFBZ0I7VUFBQyxLQUFLbDJDLEdBQUwsR0FBV2syQyxLQUFYO1VBQWtCLE9BQU8sSUFBUDs7T0FGckM7O01BSUEwSCxZQUFZLENBQUNoMEQsU0FBYixDQUF1QjYwRCxNQUF2QixHQUFnQyxVQUFVbm5ELENBQVYsRUFBYTtRQUFDLEtBQUswSSxHQUFMLElBQVkxSSxDQUFaO09BQTlDOztNQUNBc21ELFlBQVksQ0FBQ2gwRCxTQUFiLENBQXVCODBELE1BQXZCLEdBQWdDLFlBQVk7UUFDMUMsSUFBSSxLQUFLWixhQUFMLEdBQXFCLEtBQUsxMkMsS0FBOUIsRUFBcUM7VUFDbkMsS0FBSzIyQyxlQUFMLEdBQXVCMUssV0FBVyxDQUFDLEtBQUsxNkMsTUFBTixFQUFjLEtBQUt5TyxLQUFuQixFQUEwQixLQUFLa3NDLE9BQS9CLEVBQXdDLEtBQUt3SyxhQUE3QyxFQUE0RCxLQUFLQyxlQUFqRSxDQUFsQztVQUNBLEtBQUtELGFBQUwsR0FBcUIsS0FBSzEyQyxLQUExQjs7O1FBRUYsT0FBTyxLQUFLMjJDLGVBQUwsSUFBd0IsS0FBS0MsU0FBTCxHQUFpQjNLLFdBQVcsQ0FBQyxLQUFLMTZDLE1BQU4sRUFBYyxLQUFLcWxELFNBQW5CLEVBQThCLEtBQUsxSyxPQUFuQyxDQUE1QixHQUEwRSxDQUFsRyxDQUFQO09BTEY7O01BT0FzSyxZQUFZLENBQUNoMEQsU0FBYixDQUF1QiswRCxXQUF2QixHQUFxQyxZQUFZO1FBQy9DLE9BQU90TCxXQUFXLENBQUMsS0FBSzE2QyxNQUFOLEVBQWMsSUFBZCxFQUFvQixLQUFLMjZDLE9BQXpCLENBQVgsSUFDSixLQUFLMEssU0FBTCxHQUFpQjNLLFdBQVcsQ0FBQyxLQUFLMTZDLE1BQU4sRUFBYyxLQUFLcWxELFNBQW5CLEVBQThCLEtBQUsxSyxPQUFuQyxDQUE1QixHQUEwRSxDQUR0RSxDQUFQO09BREY7O01BSUFzSyxZQUFZLENBQUNoMEQsU0FBYixDQUF1QmtPLEtBQXZCLEdBQStCLFVBQVU4bUQsT0FBVixFQUFtQkMsT0FBbkIsRUFBNEJDLGVBQTVCLEVBQTZDO1FBQzFFLElBQUksT0FBT0YsT0FBUCxJQUFrQixRQUF0QixFQUFnQztVQUM5QixJQUFJRyxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFVNWxELEdBQVYsRUFBZTtZQUFFLE9BQU8ybEQsZUFBZSxHQUFHM2xELEdBQUcsQ0FBQ29LLFdBQUosRUFBSCxHQUF1QnBLLEdBQTdDO1dBQTdCOztVQUNBLElBQUk2bEQsTUFBTSxHQUFHLEtBQUtybUQsTUFBTCxDQUFZcW1ELE1BQVosQ0FBbUIsS0FBS2gvQyxHQUF4QixFQUE2QjQrQyxPQUFPLENBQUM5MEQsTUFBckMsQ0FBYjs7VUFDQSxJQUFJaTFELEtBQUssQ0FBQ0MsTUFBRCxDQUFMLElBQWlCRCxLQUFLLENBQUNILE9BQUQsQ0FBMUIsRUFBcUM7WUFDbkMsSUFBSUMsT0FBTyxLQUFLLEtBQWhCLEVBQXVCO2NBQUUsS0FBSzcrQyxHQUFMLElBQVk0K0MsT0FBTyxDQUFDOTBELE1BQXBCOzs7WUFDekIsT0FBTyxJQUFQOztTQUxKLE1BT087VUFDTCxJQUFJZ08sS0FBSyxHQUFHLEtBQUthLE1BQUwsQ0FBWXBMLEtBQVosQ0FBa0IsS0FBS3lTLEdBQXZCLEVBQTRCbEksS0FBNUIsQ0FBa0M4bUQsT0FBbEMsQ0FBWjs7VUFDQSxJQUFJOW1ELEtBQUssSUFBSUEsS0FBSyxDQUFDNUosS0FBTixHQUFjLENBQTNCLEVBQThCO1lBQUUsT0FBTyxJQUFQOzs7VUFDaEMsSUFBSTRKLEtBQUssSUFBSSttRCxPQUFPLEtBQUssS0FBekIsRUFBZ0M7WUFBRSxLQUFLNytDLEdBQUwsSUFBWWxJLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2hPLE1BQXJCOzs7VUFDbEMsT0FBT2dPLEtBQVA7O09BWko7O01BZUE4bEQsWUFBWSxDQUFDaDBELFNBQWIsQ0FBdUIybkQsT0FBdkIsR0FBaUMsWUFBVztRQUFDLE9BQU8sS0FBSzU0QyxNQUFMLENBQVlwTCxLQUFaLENBQWtCLEtBQUs2WixLQUF2QixFQUE4QixLQUFLcEgsR0FBbkMsQ0FBUDtPQUE3Qzs7TUFDQTQ5QyxZQUFZLENBQUNoMEQsU0FBYixDQUF1QnExRCxjQUF2QixHQUF3QyxVQUFVM25ELENBQVYsRUFBYTRuRCxLQUFiLEVBQW9CO1FBQzFELEtBQUtsQixTQUFMLElBQWtCMW1ELENBQWxCOztRQUNBLElBQUk7VUFBRSxPQUFPNG5ELEtBQUssRUFBWjtTQUFOLFNBQ1E7VUFBRSxLQUFLbEIsU0FBTCxJQUFrQjFtRCxDQUFsQjs7T0FIWjs7TUFLQXNtRCxZQUFZLENBQUNoMEQsU0FBYixDQUF1QnUxRCxTQUF2QixHQUFtQyxVQUFVN25ELENBQVYsRUFBYTtRQUM5QyxJQUFJOG5ELE1BQU0sR0FBRyxLQUFLdkIsVUFBbEI7UUFDQSxPQUFPdUIsTUFBTSxJQUFJQSxNQUFNLENBQUNELFNBQVAsQ0FBaUI3bkQsQ0FBakIsQ0FBakI7T0FGRjs7TUFJQXNtRCxZQUFZLENBQUNoMEQsU0FBYixDQUF1QnkxRCxTQUF2QixHQUFtQyxZQUFZO1FBQzdDLElBQUlELE1BQU0sR0FBRyxLQUFLdkIsVUFBbEI7UUFDQSxPQUFPdUIsTUFBTSxJQUFJQSxNQUFNLENBQUNDLFNBQVAsQ0FBaUIsS0FBS3IvQyxHQUF0QixDQUFqQjtPQUZGLENBdjJCbUI7OztNQTYyQm5CLFNBQVNzL0MsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0Jqb0QsQ0FBdEIsRUFBeUI7UUFDdkJBLENBQUMsSUFBSWlvRCxHQUFHLENBQUN2bEQsS0FBVDs7UUFDQSxJQUFJMUMsQ0FBQyxHQUFHLENBQUosSUFBU0EsQ0FBQyxJQUFJaW9ELEdBQUcsQ0FBQ3Y3QyxJQUF0QixFQUE0QjtVQUFFLE1BQU0sSUFBSXdyQixLQUFKLENBQVUsdUJBQXVCbDRCLENBQUMsR0FBR2lvRCxHQUFHLENBQUN2bEQsS0FBL0IsSUFBd0MsbUJBQWxELENBQU47OztRQUM5QixJQUFJd2xELEtBQUssR0FBR0QsR0FBWjs7UUFDQSxPQUFPLENBQUNDLEtBQUssQ0FBQ0MsS0FBZCxFQUFxQjtVQUNuQixLQUFLLElBQUl2ekQsQ0FBQyxHQUFHLENBQWIsR0FBaUIsRUFBRUEsQ0FBbkIsRUFBc0I7WUFDcEIsSUFBSXFtRCxLQUFLLEdBQUdpTixLQUFLLENBQUNFLFFBQU4sQ0FBZXh6RCxDQUFmLENBQVo7Z0JBQStCeXpELEVBQUUsR0FBR3BOLEtBQUssQ0FBQ3FOLFNBQU4sRUFBcEM7O1lBQ0EsSUFBSXRvRCxDQUFDLEdBQUdxb0QsRUFBUixFQUFZO2NBQUVILEtBQUssR0FBR2pOLEtBQVI7Y0FBZTs7O1lBQzdCajdDLENBQUMsSUFBSXFvRCxFQUFMOzs7O1FBR0osT0FBT0gsS0FBSyxDQUFDQyxLQUFOLENBQVlub0QsQ0FBWixDQUFQO09BeDNCaUI7Ozs7TUE2M0JuQixTQUFTdW9ELFVBQVQsQ0FBb0JOLEdBQXBCLEVBQXlCbjRDLEtBQXpCLEVBQWdDekUsR0FBaEMsRUFBcUM7UUFDbkMsSUFBSXRYLEdBQUcsR0FBRyxFQUFWO1lBQWNpTSxDQUFDLEdBQUc4UCxLQUFLLENBQUNxeEMsSUFBeEI7UUFDQThHLEdBQUcsQ0FBQ241QyxJQUFKLENBQVNnQixLQUFLLENBQUNxeEMsSUFBZixFQUFxQjkxQyxHQUFHLENBQUM4MUMsSUFBSixHQUFXLENBQWhDLEVBQW1DLFVBQVVBLElBQVYsRUFBZ0I7VUFDakQsSUFBSXZRLElBQUksR0FBR3VRLElBQUksQ0FBQ3ZRLElBQWhCOztVQUNBLElBQUk1d0MsQ0FBQyxJQUFJcUwsR0FBRyxDQUFDODFDLElBQWIsRUFBbUI7WUFBRXZRLElBQUksR0FBR0EsSUFBSSxDQUFDMzZDLEtBQUwsQ0FBVyxDQUFYLEVBQWNvVixHQUFHLENBQUNnTSxFQUFsQixDQUFQOzs7VUFDckIsSUFBSXJYLENBQUMsSUFBSThQLEtBQUssQ0FBQ3F4QyxJQUFmLEVBQXFCO1lBQUV2USxJQUFJLEdBQUdBLElBQUksQ0FBQzM2QyxLQUFMLENBQVc2WixLQUFLLENBQUN1SCxFQUFqQixDQUFQOzs7VUFDdkJ0akIsR0FBRyxDQUFDeEMsSUFBSixDQUFTcS9DLElBQVQ7VUFDQSxFQUFFNXdDLENBQUY7U0FMRjtRQU9BLE9BQU9qTSxHQUFQO09BdDRCaUI7OztNQXk0Qm5CLFNBQVN5MEQsUUFBVCxDQUFrQlAsR0FBbEIsRUFBdUJ0NUMsSUFBdkIsRUFBNkJ3RCxFQUE3QixFQUFpQztRQUMvQixJQUFJcGUsR0FBRyxHQUFHLEVBQVY7UUFDQWswRCxHQUFHLENBQUNuNUMsSUFBSixDQUFTSCxJQUFULEVBQWV3RCxFQUFmLEVBQW1CLFVBQVVndkMsSUFBVixFQUFnQjtVQUFFcHRELEdBQUcsQ0FBQ3hDLElBQUosQ0FBUzR2RCxJQUFJLENBQUN2USxJQUFkO1NBQXJDLEVBRitCOztRQUcvQixPQUFPNzhDLEdBQVA7T0E1NEJpQjs7OztNQWk1Qm5CLFNBQVMwMEQsZ0JBQVQsQ0FBMEJ0SCxJQUExQixFQUFnQ25ULE1BQWhDLEVBQXdDO1FBQ3RDLElBQUkwYSxJQUFJLEdBQUcxYSxNQUFNLEdBQUdtVCxJQUFJLENBQUNuVCxNQUF6Qjs7UUFDQSxJQUFJMGEsSUFBSixFQUFVO1VBQUUsS0FBSyxJQUFJMW9ELENBQUMsR0FBR21oRCxJQUFiLEVBQW1CbmhELENBQW5CLEVBQXNCQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ3diLE1BQTVCLEVBQW9DO1lBQUV4YixDQUFDLENBQUNndUMsTUFBRixJQUFZMGEsSUFBWjs7O09BbjVCakM7Ozs7TUF3NUJuQixTQUFTQyxNQUFULENBQWdCeEgsSUFBaEIsRUFBc0I7UUFDcEIsSUFBSUEsSUFBSSxDQUFDM2xDLE1BQUwsSUFBZSxJQUFuQixFQUF5QjtVQUFFLE9BQU8sSUFBUDs7O1FBQzNCLElBQUl3akMsR0FBRyxHQUFHbUMsSUFBSSxDQUFDM2xDLE1BQWY7WUFBdUJvdEMsRUFBRSxHQUFHbjlDLE9BQU8sQ0FBQ3V6QyxHQUFHLENBQUNtSixLQUFMLEVBQVloSCxJQUFaLENBQW5DOztRQUNBLEtBQUssSUFBSStHLEtBQUssR0FBR2xKLEdBQUcsQ0FBQ3hqQyxNQUFyQixFQUE2QjBzQyxLQUE3QixFQUFvQ2xKLEdBQUcsR0FBR2tKLEtBQU4sRUFBYUEsS0FBSyxHQUFHQSxLQUFLLENBQUMxc0MsTUFBL0QsRUFBdUU7VUFDckUsS0FBSyxJQUFJNW1CLENBQUMsR0FBRyxDQUFiLEdBQWlCLEVBQUVBLENBQW5CLEVBQXNCO1lBQ3BCLElBQUlzekQsS0FBSyxDQUFDRSxRQUFOLENBQWV4ekQsQ0FBZixLQUFxQm9xRCxHQUF6QixFQUE4QjtjQUFFOzs7WUFDaEM0SixFQUFFLElBQUlWLEtBQUssQ0FBQ0UsUUFBTixDQUFleHpELENBQWYsRUFBa0IwekQsU0FBbEIsRUFBTjs7OztRQUdKLE9BQU9NLEVBQUUsR0FBRzVKLEdBQUcsQ0FBQ3Q4QyxLQUFoQjtPQWo2QmlCOzs7O01BczZCbkIsU0FBU21tRCxhQUFULENBQXNCWCxLQUF0QixFQUE2QnhsQixDQUE3QixFQUFnQztRQUM5QixJQUFJMWlDLENBQUMsR0FBR2tvRCxLQUFLLENBQUN4bEQsS0FBZDs7UUFDQW9tRCxLQUFLLEVBQUUsR0FBRztVQUNSLEtBQUssSUFBSWhKLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdvSSxLQUFLLENBQUNFLFFBQU4sQ0FBZTUxRCxNQUF2QyxFQUErQyxFQUFFc3RELEdBQWpELEVBQXNEO1lBQ3BELElBQUk3RSxLQUFLLEdBQUdpTixLQUFLLENBQUNFLFFBQU4sQ0FBZXRJLEdBQWYsQ0FBWjtnQkFBaUN6b0MsRUFBRSxHQUFHNGpDLEtBQUssQ0FBQ2pOLE1BQTVDOztZQUNBLElBQUl0TCxDQUFDLEdBQUdyckIsRUFBUixFQUFZO2NBQUU2d0MsS0FBSyxHQUFHak4sS0FBUjtjQUFlLFNBQVM2TixLQUFUOzs7WUFDN0JwbUIsQ0FBQyxJQUFJcnJCLEVBQUw7WUFDQXJYLENBQUMsSUFBSWk3QyxLQUFLLENBQUNxTixTQUFOLEVBQUw7OztVQUVGLE9BQU90b0QsQ0FBUDtTQVBLLFFBUUUsQ0FBQ2tvRCxLQUFLLENBQUNDLEtBUlQ7O1FBU1AsSUFBSXZ6RCxDQUFDLEdBQUcsQ0FBUjs7UUFDQSxPQUFPQSxDQUFDLEdBQUdzekQsS0FBSyxDQUFDQyxLQUFOLENBQVkzMUQsTUFBdkIsRUFBK0IsRUFBRW9DLENBQWpDLEVBQW9DO1VBQ2xDLElBQUl1c0QsSUFBSSxHQUFHK0csS0FBSyxDQUFDQyxLQUFOLENBQVl2ekQsQ0FBWixDQUFYO2NBQTJCbTBELEVBQUUsR0FBRzVILElBQUksQ0FBQ25ULE1BQXJDOztVQUNBLElBQUl0TCxDQUFDLEdBQUdxbUIsRUFBUixFQUFZO1lBQUU7OztVQUNkcm1CLENBQUMsSUFBSXFtQixFQUFMOzs7UUFFRixPQUFPL29ELENBQUMsR0FBR3BMLENBQVg7OztNQUdGLFNBQVNvMEQsTUFBVCxDQUFnQmYsR0FBaEIsRUFBcUJqc0QsQ0FBckIsRUFBd0I7UUFBQyxPQUFPQSxDQUFDLElBQUlpc0QsR0FBRyxDQUFDdmxELEtBQVQsSUFBa0IxRyxDQUFDLEdBQUdpc0QsR0FBRyxDQUFDdmxELEtBQUosR0FBWXVsRCxHQUFHLENBQUN2N0MsSUFBN0M7OztNQUV6QixTQUFTdThDLGFBQVQsQ0FBdUJuc0IsT0FBdkIsRUFBZ0Nsb0MsQ0FBaEMsRUFBbUM7UUFDakMsT0FBT3ZDLE1BQU0sQ0FBQ3lxQyxPQUFPLENBQUNvc0IsbUJBQVIsQ0FBNEJ0MEQsQ0FBQyxHQUFHa29DLE9BQU8sQ0FBQ3FzQixlQUF4QyxDQUFELENBQWI7T0E3N0JpQjs7O01BaThCbkIsU0FBU0MsR0FBVCxDQUFhakksSUFBYixFQUFtQjlwQyxFQUFuQixFQUF1QnBFLE1BQXZCLEVBQStCO1FBQzdCLElBQUtBLE1BQU0sS0FBSyxLQUFLLENBQXJCLEVBQXlCQSxNQUFNLEdBQUcsSUFBVDs7UUFFekIsSUFBSSxFQUFFLGdCQUFnQm0yQyxHQUFsQixDQUFKLEVBQTRCO1VBQUUsT0FBTyxJQUFJQSxHQUFKLENBQVFqSSxJQUFSLEVBQWM5cEMsRUFBZCxFQUFrQnBFLE1BQWxCLENBQVA7OztRQUM5QixLQUFLa3VDLElBQUwsR0FBWUEsSUFBWjtRQUNBLEtBQUs5cEMsRUFBTCxHQUFVQSxFQUFWO1FBQ0EsS0FBS3BFLE1BQUwsR0FBY0EsTUFBZDtPQXY4QmlCOzs7O01BNDhCbkIsU0FBU28yQyxHQUFULENBQWFwNkQsQ0FBYixFQUFnQnlELENBQWhCLEVBQW1CO1FBQUUsT0FBT3pELENBQUMsQ0FBQ2t5RCxJQUFGLEdBQVN6dUQsQ0FBQyxDQUFDeXVELElBQVgsSUFBbUJseUQsQ0FBQyxDQUFDb29CLEVBQUYsR0FBTzNrQixDQUFDLENBQUMya0IsRUFBbkM7OztNQUVyQixTQUFTaXlDLGNBQVQsQ0FBd0JyNkQsQ0FBeEIsRUFBMkJ5RCxDQUEzQixFQUE4QjtRQUFFLE9BQU96RCxDQUFDLENBQUNna0IsTUFBRixJQUFZdmdCLENBQUMsQ0FBQ3VnQixNQUFkLElBQXdCbzJDLEdBQUcsQ0FBQ3A2RCxDQUFELEVBQUl5RCxDQUFKLENBQUgsSUFBYSxDQUE1Qzs7O01BRWhDLFNBQVM2MkQsT0FBVCxDQUFpQnhxRCxDQUFqQixFQUFvQjtRQUFDLE9BQU9xcUQsR0FBRyxDQUFDcnFELENBQUMsQ0FBQ29pRCxJQUFILEVBQVNwaUQsQ0FBQyxDQUFDc1ksRUFBWCxDQUFWOzs7TUFDckIsU0FBU215QyxNQUFULENBQWdCdjZELENBQWhCLEVBQW1CeUQsQ0FBbkIsRUFBc0I7UUFBRSxPQUFPMjJELEdBQUcsQ0FBQ3A2RCxDQUFELEVBQUl5RCxDQUFKLENBQUgsR0FBWSxDQUFaLEdBQWdCQSxDQUFoQixHQUFvQnpELENBQTNCOzs7TUFDeEIsU0FBU3c2RCxNQUFULENBQWdCeDZELENBQWhCLEVBQW1CeUQsQ0FBbkIsRUFBc0I7UUFBRSxPQUFPMjJELEdBQUcsQ0FBQ3A2RCxDQUFELEVBQUl5RCxDQUFKLENBQUgsR0FBWSxDQUFaLEdBQWdCekQsQ0FBaEIsR0FBb0J5RCxDQUEzQjtPQWw5Qkw7Ozs7TUFzOUJuQixTQUFTZzNELFFBQVQsQ0FBa0J6QixHQUFsQixFQUF1QmpvRCxDQUF2QixFQUEwQjtRQUFDLE9BQU83UixJQUFJLENBQUN3SSxHQUFMLENBQVNzeEQsR0FBRyxDQUFDdmxELEtBQWIsRUFBb0J2VSxJQUFJLENBQUNzSSxHQUFMLENBQVN1SixDQUFULEVBQVlpb0QsR0FBRyxDQUFDdmxELEtBQUosR0FBWXVsRCxHQUFHLENBQUN2N0MsSUFBaEIsR0FBdUIsQ0FBbkMsQ0FBcEIsQ0FBUDs7O01BQzNCLFNBQVNpOUMsUUFBVCxDQUFpQjFCLEdBQWpCLEVBQXNCdi9DLEdBQXRCLEVBQTJCO1FBQ3pCLElBQUlBLEdBQUcsQ0FBQ3k0QyxJQUFKLEdBQVc4RyxHQUFHLENBQUN2bEQsS0FBbkIsRUFBMEI7VUFBRSxPQUFPMG1ELEdBQUcsQ0FBQ25CLEdBQUcsQ0FBQ3ZsRCxLQUFMLEVBQVksQ0FBWixDQUFWOzs7UUFDNUIsSUFBSTJZLElBQUksR0FBRzRzQyxHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUFoQixHQUF1QixDQUFsQzs7UUFDQSxJQUFJaEUsR0FBRyxDQUFDeTRDLElBQUosR0FBVzlsQyxJQUFmLEVBQXFCO1VBQUUsT0FBTyt0QyxHQUFHLENBQUMvdEMsSUFBRCxFQUFPMnNDLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNNXNDLElBQU4sQ0FBUCxDQUFtQnUxQixJQUFuQixDQUF3QnArQyxNQUEvQixDQUFWOzs7UUFDdkIsT0FBT28zRCxTQUFTLENBQUNsaEQsR0FBRCxFQUFNcy9DLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNdi9DLEdBQUcsQ0FBQ3k0QyxJQUFWLENBQVAsQ0FBdUJ2USxJQUF2QixDQUE0QnArQyxNQUFsQyxDQUFoQjs7O01BRUYsU0FBU28zRCxTQUFULENBQW1CbGhELEdBQW5CLEVBQXdCbWhELE9BQXhCLEVBQWlDO1FBQy9CLElBQUl4eUMsRUFBRSxHQUFHM08sR0FBRyxDQUFDMk8sRUFBYjs7UUFDQSxJQUFJQSxFQUFFLElBQUksSUFBTixJQUFjQSxFQUFFLEdBQUd3eUMsT0FBdkIsRUFBZ0M7VUFBRSxPQUFPVCxHQUFHLENBQUMxZ0QsR0FBRyxDQUFDeTRDLElBQUwsRUFBVzBJLE9BQVgsQ0FBVjtTQUFsQyxNQUNLLElBQUl4eUMsRUFBRSxHQUFHLENBQVQsRUFBWTtVQUFFLE9BQU8reEMsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFMLEVBQVcsQ0FBWCxDQUFWO1NBQWQsTUFDQTtVQUFFLE9BQU96NEMsR0FBUDs7OztNQUVULFNBQVNvaEQsWUFBVCxDQUFzQjdCLEdBQXRCLEVBQTJCekwsS0FBM0IsRUFBa0M7UUFDaEMsSUFBSXpvRCxHQUFHLEdBQUcsRUFBVjs7UUFDQSxLQUFLLElBQUlhLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0bkQsS0FBSyxDQUFDaHFELE1BQTFCLEVBQWtDb0MsQ0FBQyxFQUFuQyxFQUF1QztVQUFFYixHQUFHLENBQUNhLENBQUQsQ0FBSCxHQUFTKzBELFFBQU8sQ0FBQzFCLEdBQUQsRUFBTXpMLEtBQUssQ0FBQzVuRCxDQUFELENBQVgsQ0FBaEI7OztRQUN6QyxPQUFPYixHQUFQOzs7TUFHRixJQUFJZzJELFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQVM5eEIsS0FBVCxFQUFnQjR2QixTQUFoQixFQUEyQjtRQUM1QyxLQUFLNXZCLEtBQUwsR0FBYUEsS0FBYjtRQUNBLEtBQUs0dkIsU0FBTCxHQUFpQkEsU0FBakI7T0FGRjs7TUFLQSxJQUFJenhCLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVM2eEIsR0FBVCxFQUFjaHdCLEtBQWQsRUFBcUJrcEIsSUFBckIsRUFBMkIwRyxTQUEzQixFQUFzQztRQUNsRCxLQUFLNXZCLEtBQUwsR0FBYUEsS0FBYjtRQUNBLEtBQUtnd0IsR0FBTCxHQUFXQSxHQUFYO1FBQ0EsS0FBSzlHLElBQUwsR0FBWUEsSUFBWjtRQUNBLEtBQUs2SSxZQUFMLEdBQW9CbkMsU0FBUyxJQUFJLENBQWpDO1FBQ0EsS0FBS29DLFVBQUwsR0FBa0IsSUFBbEI7UUFDQSxLQUFLQyxZQUFMLEdBQW9CLENBQXBCO09BTkY7O01BU0E5ekIsT0FBTyxDQUFDOWpDLFNBQVIsQ0FBa0J1MUQsU0FBbEIsR0FBOEIsVUFBVTduRCxDQUFWLEVBQWE7UUFDekMsSUFBSW1oRCxJQUFJLEdBQUcsS0FBSzhHLEdBQUwsQ0FBU0QsT0FBVCxDQUFpQixLQUFLN0csSUFBTCxHQUFZbmhELENBQTdCLENBQVg7O1FBQ0EsSUFBSW1oRCxJQUFJLElBQUksSUFBUixJQUFnQm5oRCxDQUFDLEdBQUcsS0FBS2dxRCxZQUE3QixFQUEyQztVQUFFLEtBQUtBLFlBQUwsR0FBb0JocUQsQ0FBcEI7OztRQUM3QyxPQUFPbWhELElBQVA7T0FIRjs7TUFNQS9xQixPQUFPLENBQUM5akMsU0FBUixDQUFrQnkxRCxTQUFsQixHQUE4QixVQUFVL25ELENBQVYsRUFBYTtRQUN6QyxJQUFJLENBQUMsS0FBS2lxRCxVQUFWLEVBQXNCO1VBQUUsT0FBTyxJQUFQOzs7UUFDeEIsT0FBTyxLQUFLQSxVQUFMLENBQWdCLEtBQUtDLFlBQXJCLEtBQXNDbHFELENBQTdDLEVBQ0U7VUFBRSxLQUFLa3FELFlBQUwsSUFBcUIsQ0FBckI7OztRQUNKLElBQUlsM0QsSUFBSSxHQUFHLEtBQUtpM0QsVUFBTCxDQUFnQixLQUFLQyxZQUFMLEdBQW9CLENBQXBDLENBQVg7UUFDQSxPQUFPO1VBQUNsM0QsSUFBSSxFQUFFQSxJQUFJLElBQUlBLElBQUksQ0FBQ3VPLE9BQUwsQ0FBYSxpQkFBYixFQUFnQyxFQUFoQyxDQUFmO1VBQ0NtTCxJQUFJLEVBQUUsS0FBS3U5QyxVQUFMLENBQWdCLEtBQUtDLFlBQXJCLElBQXFDbHFEO1NBRG5EO09BTEY7O01BU0FvMkIsT0FBTyxDQUFDOWpDLFNBQVIsQ0FBa0I2M0QsUUFBbEIsR0FBNkIsWUFBWTtRQUN2QyxLQUFLaEosSUFBTDs7UUFDQSxJQUFJLEtBQUs2SSxZQUFMLEdBQW9CLENBQXhCLEVBQTJCO1VBQUUsS0FBS0EsWUFBTDs7T0FGL0I7O01BS0E1ekIsT0FBTyxDQUFDZzBCLFNBQVIsR0FBb0IsVUFBVW5DLEdBQVYsRUFBZW9DLEtBQWYsRUFBc0JsSixJQUF0QixFQUE0QjtRQUM5QyxJQUFJa0osS0FBSyxZQUFZTixZQUFyQixFQUNFO1VBQUUsT0FBTyxJQUFJM3pCLE9BQUosQ0FBWTZ4QixHQUFaLEVBQWlCakMsU0FBUyxDQUFDaUMsR0FBRyxDQUFDejJELElBQUwsRUFBVzY0RCxLQUFLLENBQUNweUIsS0FBakIsQ0FBMUIsRUFBbURrcEIsSUFBbkQsRUFBeURrSixLQUFLLENBQUN4QyxTQUEvRCxDQUFQO1NBREosTUFHRTtVQUFFLE9BQU8sSUFBSXp4QixPQUFKLENBQVk2eEIsR0FBWixFQUFpQmpDLFNBQVMsQ0FBQ2lDLEdBQUcsQ0FBQ3oyRCxJQUFMLEVBQVc2NEQsS0FBWCxDQUExQixFQUE2Q2xKLElBQTdDLENBQVA7O09BSk47O01BT0EvcUIsT0FBTyxDQUFDOWpDLFNBQVIsQ0FBa0JnNEQsSUFBbEIsR0FBeUIsVUFBVUMsSUFBVixFQUFnQjtRQUN2QyxJQUFJdHlCLEtBQUssR0FBR3N5QixJQUFJLEtBQUssS0FBVCxHQUFpQnZFLFNBQVMsQ0FBQyxLQUFLaUMsR0FBTCxDQUFTejJELElBQVYsRUFBZ0IsS0FBS3ltQyxLQUFyQixDQUExQixHQUF3RCxLQUFLQSxLQUF6RTtRQUNBLE9BQU8sS0FBSyt4QixZQUFMLEdBQW9CLENBQXBCLEdBQXdCLElBQUlELFlBQUosQ0FBaUI5eEIsS0FBakIsRUFBd0IsS0FBSyt4QixZQUE3QixDQUF4QixHQUFxRS94QixLQUE1RTtPQUZGLENBbGhDbUI7Ozs7OztNQTRoQ25CLFNBQVN1eUIsYUFBVCxDQUF1QnpJLEVBQXZCLEVBQTJCWixJQUEzQixFQUFpQ2gyQyxPQUFqQyxFQUEwQ3MvQyxVQUExQyxFQUFzRDs7O1FBR3BELElBQUlDLEVBQUUsR0FBRyxDQUFDM0ksRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzB5QixPQUFWLENBQVQ7WUFBNkJDLFdBQVcsR0FBRyxFQUEzQyxDQUhvRDs7UUFLcERDLE9BQU8sQ0FBQzlJLEVBQUQsRUFBS1osSUFBSSxDQUFDdlEsSUFBVixFQUFnQm1SLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3oyRCxJQUF2QixFQUE2QjJaLE9BQTdCLEVBQXNDLFVBQVVFLEdBQVYsRUFBZXRTLEtBQWYsRUFBc0I7VUFBRSxPQUFPMnhELEVBQUUsQ0FBQ241RCxJQUFILENBQVE4WixHQUFSLEVBQWF0UyxLQUFiLENBQVA7U0FBOUQsRUFDQzZ4RCxXQURELEVBQ2NILFVBRGQsQ0FBUDtRQUVBLElBQUl4eUIsS0FBSyxHQUFHOXNCLE9BQU8sQ0FBQzhzQixLQUFwQixDQVBvRDs7UUFVcEQsSUFBSTZ5QixJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFXNzhCLENBQVgsRUFBZTtVQUN4QjlpQixPQUFPLENBQUM4K0MsVUFBUixHQUFxQlMsRUFBckI7VUFDQSxJQUFJSyxPQUFPLEdBQUdoSixFQUFFLENBQUM5cEIsS0FBSCxDQUFTK3lCLFFBQVQsQ0FBa0IvOEIsQ0FBbEIsQ0FBZDtjQUFvQ3I1QixDQUFDLEdBQUcsQ0FBeEM7Y0FBMkM2ZixFQUFFLEdBQUcsQ0FBaEQ7VUFDQXRKLE9BQU8sQ0FBQzhzQixLQUFSLEdBQWdCLElBQWhCO1VBQ0E0eUIsT0FBTyxDQUFDOUksRUFBRCxFQUFLWixJQUFJLENBQUN2USxJQUFWLEVBQWdCbWEsT0FBTyxDQUFDdjVELElBQXhCLEVBQThCMlosT0FBOUIsRUFBdUMsVUFBVUUsR0FBVixFQUFldFMsS0FBZixFQUFzQjtZQUNsRSxJQUFJK1csS0FBSyxHQUFHbGIsQ0FBWixDQURrRTs7WUFHbEUsT0FBTzZmLEVBQUUsR0FBR3BKLEdBQVosRUFBaUI7Y0FDZixJQUFJNC9DLEtBQUssR0FBR1AsRUFBRSxDQUFDOTFELENBQUQsQ0FBZDs7Y0FDQSxJQUFJcTJELEtBQUssR0FBRzUvQyxHQUFaLEVBQ0U7Z0JBQUVxL0MsRUFBRSxDQUFDOW5DLE1BQUgsQ0FBVWh1QixDQUFWLEVBQWEsQ0FBYixFQUFnQnlXLEdBQWhCLEVBQXFCcS9DLEVBQUUsQ0FBQzkxRCxDQUFDLEdBQUMsQ0FBSCxDQUF2QixFQUE4QnEyRCxLQUE5Qjs7O2NBQ0pyMkQsQ0FBQyxJQUFJLENBQUw7Y0FDQTZmLEVBQUUsR0FBR3RtQixJQUFJLENBQUNzSSxHQUFMLENBQVM0VSxHQUFULEVBQWM0L0MsS0FBZCxDQUFMOzs7WUFFRixJQUFJLENBQUNseUQsS0FBTCxFQUFZO2NBQUU7OztZQUNkLElBQUlneUQsT0FBTyxDQUFDRyxNQUFaLEVBQW9CO2NBQ2xCUixFQUFFLENBQUM5bkMsTUFBSCxDQUFVOVMsS0FBVixFQUFpQmxiLENBQUMsR0FBR2tiLEtBQXJCLEVBQTRCekUsR0FBNUIsRUFBaUMsYUFBYXRTLEtBQTlDO2NBQ0FuRSxDQUFDLEdBQUdrYixLQUFLLEdBQUcsQ0FBWjthQUZGLE1BR087Y0FDTCxPQUFPQSxLQUFLLEdBQUdsYixDQUFmLEVBQWtCa2IsS0FBSyxJQUFJLENBQTNCLEVBQThCO2dCQUM1QixJQUFJa3ZDLEdBQUcsR0FBRzBMLEVBQUUsQ0FBQzU2QyxLQUFLLEdBQUMsQ0FBUCxDQUFaO2dCQUNBNDZDLEVBQUUsQ0FBQzU2QyxLQUFLLEdBQUMsQ0FBUCxDQUFGLEdBQWMsQ0FBQ2t2QyxHQUFHLEdBQUdBLEdBQUcsR0FBRyxHQUFULEdBQWUsRUFBbkIsSUFBeUIsVUFBekIsR0FBc0NqbUQsS0FBcEQ7OztXQWpCQyxFQW9CSjZ4RCxXQXBCSSxDQUFQO1VBcUJBei9DLE9BQU8sQ0FBQzhzQixLQUFSLEdBQWdCQSxLQUFoQjtVQUNBOXNCLE9BQU8sQ0FBQzgrQyxVQUFSLEdBQXFCLElBQXJCO1VBQ0E5K0MsT0FBTyxDQUFDKytDLFlBQVIsR0FBdUIsQ0FBdkI7U0EzQkY7O1FBOEJBLEtBQUssSUFBSWo4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOHpCLEVBQUUsQ0FBQzlwQixLQUFILENBQVMreUIsUUFBVCxDQUFrQng0RCxNQUF0QyxFQUE4QyxFQUFFeTdCLENBQWhEO1VBQW1ENjhCLElBQUksQ0FBRTc4QixDQUFGLENBQUo7OztRQUVuRCxPQUFPO1VBQUNxWCxNQUFNLEVBQUVvbEIsRUFBVDtVQUFhUyxPQUFPLEVBQUVQLFdBQVcsQ0FBQ1EsT0FBWixJQUF1QlIsV0FBVyxDQUFDUyxTQUFuQyxHQUErQ1QsV0FBL0MsR0FBNkQ7U0FBMUY7OztNQUdGLFNBQVNVLGFBQVQsQ0FBdUJ2SixFQUF2QixFQUEyQlosSUFBM0IsRUFBaUNvSyxjQUFqQyxFQUFpRDtRQUMvQyxJQUFJLENBQUNwSyxJQUFJLENBQUM3YixNQUFOLElBQWdCNmIsSUFBSSxDQUFDN2IsTUFBTCxDQUFZLENBQVosS0FBa0J5YyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHlCLE9BQS9DLEVBQXdEO1VBQ3RELElBQUl4L0MsT0FBTyxHQUFHcWdELGdCQUFnQixDQUFDekosRUFBRCxFQUFLNEcsTUFBTSxDQUFDeEgsSUFBRCxDQUFYLENBQTlCO1VBQ0EsSUFBSXNLLFVBQVUsR0FBR3RLLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFWLEdBQW1CdXZELEVBQUUsQ0FBQ2psQixPQUFILENBQVc0dUIsa0JBQTlCLElBQW9EMUYsU0FBUyxDQUFDakUsRUFBRSxDQUFDa0csR0FBSCxDQUFPejJELElBQVIsRUFBYzJaLE9BQU8sQ0FBQzhzQixLQUF0QixDQUE5RTtVQUNBLElBQUl6Z0MsTUFBTSxHQUFHZ3pELGFBQWEsQ0FBQ3pJLEVBQUQsRUFBS1osSUFBTCxFQUFXaDJDLE9BQVgsQ0FBMUI7O1VBQ0EsSUFBSXNnRCxVQUFKLEVBQWdCO1lBQUV0Z0QsT0FBTyxDQUFDOHNCLEtBQVIsR0FBZ0J3ekIsVUFBaEI7OztVQUNsQnRLLElBQUksQ0FBQ3dLLFVBQUwsR0FBa0J4Z0QsT0FBTyxDQUFDbS9DLElBQVIsQ0FBYSxDQUFDbUIsVUFBZCxDQUFsQjtVQUNBdEssSUFBSSxDQUFDN2IsTUFBTCxHQUFjOXRDLE1BQU0sQ0FBQzh0QyxNQUFyQjs7VUFDQSxJQUFJOXRDLE1BQU0sQ0FBQzJ6RCxPQUFYLEVBQW9CO1lBQUVoSyxJQUFJLENBQUN5SyxZQUFMLEdBQW9CcDBELE1BQU0sQ0FBQzJ6RCxPQUEzQjtXQUF0QixNQUNLLElBQUloSyxJQUFJLENBQUN5SyxZQUFULEVBQXVCO1lBQUV6SyxJQUFJLENBQUN5SyxZQUFMLEdBQW9CLElBQXBCOzs7VUFDOUIsSUFBSUwsY0FBYyxLQUFLeEosRUFBRSxDQUFDa0csR0FBSCxDQUFPNEQsaUJBQTlCLEVBQ0U7WUFBRTlKLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzZELFlBQVAsR0FBc0IzOUQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTb3JELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzZELFlBQWhCLEVBQThCLEVBQUUvSixFQUFFLENBQUNrRyxHQUFILENBQU80RCxpQkFBdkMsQ0FBdEI7Ozs7UUFFTixPQUFPMUssSUFBSSxDQUFDN2IsTUFBWjs7O01BR0YsU0FBU2ttQixnQkFBVCxDQUEwQnpKLEVBQTFCLEVBQThCL2hELENBQTlCLEVBQWlDK3JELE9BQWpDLEVBQTBDO1FBQ3hDLElBQUk5RCxHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFiO1lBQWtCanZELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBL0I7O1FBQ0EsSUFBSSxDQUFDaXZELEdBQUcsQ0FBQ3oyRCxJQUFKLENBQVMyMEQsVUFBZCxFQUEwQjtVQUFFLE9BQU8sSUFBSS92QixPQUFKLENBQVk2eEIsR0FBWixFQUFpQixJQUFqQixFQUF1QmpvRCxDQUF2QixDQUFQOzs7UUFDNUIsSUFBSThQLEtBQUssR0FBR2s4QyxhQUFhLENBQUNqSyxFQUFELEVBQUsvaEQsQ0FBTCxFQUFRK3JELE9BQVIsQ0FBekI7UUFDQSxJQUFJMUIsS0FBSyxHQUFHdjZDLEtBQUssR0FBR200QyxHQUFHLENBQUN2bEQsS0FBWixJQUFxQnNsRCxPQUFPLENBQUNDLEdBQUQsRUFBTW40QyxLQUFLLEdBQUcsQ0FBZCxDQUFQLENBQXdCNjdDLFVBQXpEO1FBQ0EsSUFBSXhnRCxPQUFPLEdBQUdrL0MsS0FBSyxHQUFHajBCLE9BQU8sQ0FBQ2cwQixTQUFSLENBQWtCbkMsR0FBbEIsRUFBdUJvQyxLQUF2QixFQUE4QnY2QyxLQUE5QixDQUFILEdBQTBDLElBQUlzbUIsT0FBSixDQUFZNnhCLEdBQVosRUFBaUI5QixVQUFVLENBQUM4QixHQUFHLENBQUN6MkQsSUFBTCxDQUEzQixFQUF1Q3NlLEtBQXZDLENBQTdEO1FBRUFtNEMsR0FBRyxDQUFDbjVDLElBQUosQ0FBU2dCLEtBQVQsRUFBZ0I5UCxDQUFoQixFQUFtQixVQUFVbWhELElBQVYsRUFBZ0I7VUFDakM4SyxXQUFXLENBQUNsSyxFQUFELEVBQUtaLElBQUksQ0FBQ3ZRLElBQVYsRUFBZ0J6bEMsT0FBaEIsQ0FBWDtVQUNBLElBQUl6QyxHQUFHLEdBQUd5QyxPQUFPLENBQUNnMkMsSUFBbEI7VUFDQUEsSUFBSSxDQUFDd0ssVUFBTCxHQUFrQmpqRCxHQUFHLElBQUkxSSxDQUFDLEdBQUcsQ0FBWCxJQUFnQjBJLEdBQUcsR0FBRyxDQUFOLElBQVcsQ0FBM0IsSUFBZ0NBLEdBQUcsSUFBSTFQLE9BQU8sQ0FBQ2t6RCxRQUFmLElBQTJCeGpELEdBQUcsR0FBRzFQLE9BQU8sQ0FBQ216RCxNQUF6RSxHQUFrRmhoRCxPQUFPLENBQUNtL0MsSUFBUixFQUFsRixHQUFtRyxJQUFySDtVQUNBbi9DLE9BQU8sQ0FBQ2cvQyxRQUFSO1NBSkY7O1FBTUEsSUFBSTRCLE9BQUosRUFBYTtVQUFFOUQsR0FBRyxDQUFDNkQsWUFBSixHQUFtQjNnRCxPQUFPLENBQUNnMkMsSUFBM0I7OztRQUNmLE9BQU9oMkMsT0FBUDtPQXZtQ2lCOzs7OztNQTZtQ25CLFNBQVM4Z0QsV0FBVCxDQUFxQmxLLEVBQXJCLEVBQXlCblIsSUFBekIsRUFBK0J6bEMsT0FBL0IsRUFBd0NpaEQsT0FBeEMsRUFBaUQ7UUFDL0MsSUFBSTU2RCxJQUFJLEdBQUd1d0QsRUFBRSxDQUFDa0csR0FBSCxDQUFPejJELElBQWxCO1FBQ0EsSUFBSTY2RCxNQUFNLEdBQUcsSUFBSS9GLFlBQUosQ0FBaUIxVixJQUFqQixFQUF1Qm1SLEVBQUUsQ0FBQ2psQixPQUFILENBQVdrZixPQUFsQyxFQUEyQzd3QyxPQUEzQyxDQUFiO1FBQ0FraEQsTUFBTSxDQUFDdjhDLEtBQVAsR0FBZXU4QyxNQUFNLENBQUMzakQsR0FBUCxHQUFhMGpELE9BQU8sSUFBSSxDQUF2Qzs7UUFDQSxJQUFJeGIsSUFBSSxJQUFJLEVBQVosRUFBZ0I7VUFBRTBiLGFBQWEsQ0FBQzk2RCxJQUFELEVBQU8yWixPQUFPLENBQUM4c0IsS0FBZixDQUFiOzs7UUFDbEIsT0FBTyxDQUFDbzBCLE1BQU0sQ0FBQzFGLEdBQVAsRUFBUixFQUFzQjtVQUNwQjRGLFNBQVMsQ0FBQy82RCxJQUFELEVBQU82NkQsTUFBUCxFQUFlbGhELE9BQU8sQ0FBQzhzQixLQUF2QixDQUFUO1VBQ0FvMEIsTUFBTSxDQUFDdjhDLEtBQVAsR0FBZXU4QyxNQUFNLENBQUMzakQsR0FBdEI7Ozs7TUFJSixTQUFTNGpELGFBQVQsQ0FBdUI5NkQsSUFBdkIsRUFBNkJ5bUMsS0FBN0IsRUFBb0M7UUFDbEMsSUFBSXptQyxJQUFJLENBQUNnN0QsU0FBVCxFQUFvQjtVQUFFLE9BQU9oN0QsSUFBSSxDQUFDZzdELFNBQUwsQ0FBZXYwQixLQUFmLENBQVA7OztRQUN0QixJQUFJLENBQUN6bUMsSUFBSSxDQUFDMDBELFNBQVYsRUFBcUI7VUFBRTs7O1FBQ3ZCLElBQUkwQixLQUFLLEdBQUcxQixTQUFTLENBQUMxMEQsSUFBRCxFQUFPeW1DLEtBQVAsQ0FBckI7O1FBQ0EsSUFBSTJ2QixLQUFLLENBQUNwMkQsSUFBTixDQUFXZzdELFNBQWYsRUFBMEI7VUFBRSxPQUFPNUUsS0FBSyxDQUFDcDJELElBQU4sQ0FBV2c3RCxTQUFYLENBQXFCNUUsS0FBSyxDQUFDM3ZCLEtBQTNCLENBQVA7Ozs7TUFHOUIsU0FBU3MwQixTQUFULENBQW1CLzZELElBQW5CLEVBQXlCNjZELE1BQXpCLEVBQWlDcDBCLEtBQWpDLEVBQXdDMnZCLEtBQXhDLEVBQStDO1FBQzdDLEtBQUssSUFBSWh6RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO1VBQzNCLElBQUlnekQsS0FBSixFQUFXO1lBQUVBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVzFCLFNBQVMsQ0FBQzEwRCxJQUFELEVBQU95bUMsS0FBUCxDQUFULENBQXVCem1DLElBQWxDOzs7VUFDYixJQUFJdUgsS0FBSyxHQUFHdkgsSUFBSSxDQUFDaTdELEtBQUwsQ0FBV0osTUFBWCxFQUFtQnAwQixLQUFuQixDQUFaOztVQUNBLElBQUlvMEIsTUFBTSxDQUFDM2pELEdBQVAsR0FBYTJqRCxNQUFNLENBQUN2OEMsS0FBeEIsRUFBK0I7WUFBRSxPQUFPL1csS0FBUDs7OztRQUVuQyxNQUFNLElBQUltL0IsS0FBSixDQUFVLFVBQVUxbUMsSUFBSSxDQUFDeUIsSUFBZixHQUFzQiw0QkFBaEMsQ0FBTjs7O01BR0YsSUFBSXk1RCxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFTTCxNQUFULEVBQWlCcjVELElBQWpCLEVBQXVCaWxDLEtBQXZCLEVBQThCO1FBQ3hDLEtBQUtub0IsS0FBTCxHQUFhdThDLE1BQU0sQ0FBQ3Y4QyxLQUFwQjtRQUEyQixLQUFLekUsR0FBTCxHQUFXZ2hELE1BQU0sQ0FBQzNqRCxHQUFsQjtRQUMzQixLQUFLckgsTUFBTCxHQUFjZ3JELE1BQU0sQ0FBQ3BTLE9BQVAsRUFBZDtRQUNBLEtBQUtqbkQsSUFBTCxHQUFZQSxJQUFJLElBQUksSUFBcEI7UUFDQSxLQUFLaWxDLEtBQUwsR0FBYUEsS0FBYjtPQUpGLENBeG9DbUI7OztNQWdwQ25CLFNBQVMwMEIsU0FBVCxDQUFtQjVLLEVBQW5CLEVBQXVCcjVDLEdBQXZCLEVBQTRCcWpELE9BQTVCLEVBQXFDYSxPQUFyQyxFQUE4QztRQUM1QyxJQUFJM0UsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjtZQUFrQnoyRCxJQUFJLEdBQUd5MkQsR0FBRyxDQUFDejJELElBQTdCO1lBQW1DdUgsS0FBbkM7UUFDQTJQLEdBQUcsR0FBR2loRCxRQUFPLENBQUMxQixHQUFELEVBQU12L0MsR0FBTixDQUFiO1FBQ0EsSUFBSXk0QyxJQUFJLEdBQUc2RyxPQUFPLENBQUNDLEdBQUQsRUFBTXYvQyxHQUFHLENBQUN5NEMsSUFBVixDQUFsQjtZQUFtQ2gyQyxPQUFPLEdBQUdxZ0QsZ0JBQWdCLENBQUN6SixFQUFELEVBQUtyNUMsR0FBRyxDQUFDeTRDLElBQVQsRUFBZTRLLE9BQWYsQ0FBN0Q7UUFDQSxJQUFJTSxNQUFNLEdBQUcsSUFBSS9GLFlBQUosQ0FBaUJuRixJQUFJLENBQUN2USxJQUF0QixFQUE0Qm1SLEVBQUUsQ0FBQ2psQixPQUFILENBQVdrZixPQUF2QyxFQUFnRDd3QyxPQUFoRCxDQUFiO1lBQXVFMGhELE1BQXZFOztRQUNBLElBQUlELE9BQUosRUFBYTtVQUFFQyxNQUFNLEdBQUcsRUFBVDs7O1FBQ2YsT0FBTyxDQUFDRCxPQUFPLElBQUlQLE1BQU0sQ0FBQzNqRCxHQUFQLEdBQWFBLEdBQUcsQ0FBQzJPLEVBQTdCLEtBQW9DLENBQUNnMUMsTUFBTSxDQUFDMUYsR0FBUCxFQUE1QyxFQUEwRDtVQUN4RDBGLE1BQU0sQ0FBQ3Y4QyxLQUFQLEdBQWV1OEMsTUFBTSxDQUFDM2pELEdBQXRCO1VBQ0EzUCxLQUFLLEdBQUd3ekQsU0FBUyxDQUFDLzZELElBQUQsRUFBTzY2RCxNQUFQLEVBQWVsaEQsT0FBTyxDQUFDOHNCLEtBQXZCLENBQWpCOztVQUNBLElBQUkyMEIsT0FBSixFQUFhO1lBQUVDLE1BQU0sQ0FBQ3Q3RCxJQUFQLENBQVksSUFBSW03RCxLQUFKLENBQVVMLE1BQVYsRUFBa0J0ekQsS0FBbEIsRUFBeUJpdEQsU0FBUyxDQUFDaUMsR0FBRyxDQUFDejJELElBQUwsRUFBVzJaLE9BQU8sQ0FBQzhzQixLQUFuQixDQUFsQyxDQUFaOzs7O1FBRWpCLE9BQU8yMEIsT0FBTyxHQUFHQyxNQUFILEdBQVksSUFBSUgsS0FBSixDQUFVTCxNQUFWLEVBQWtCdHpELEtBQWxCLEVBQXlCb1MsT0FBTyxDQUFDOHNCLEtBQWpDLENBQTFCOzs7TUFHRixTQUFTNjBCLGtCQUFULENBQTRCOTVELElBQTVCLEVBQWtDcWxCLE1BQWxDLEVBQTBDO1FBQ3hDLElBQUlybEIsSUFBSixFQUFVO1VBQUUsU0FBUztZQUNuQixJQUFJKzVELFNBQVMsR0FBRy81RCxJQUFJLENBQUN3TixLQUFMLENBQVcsbUNBQVgsQ0FBaEI7O1lBQ0EsSUFBSSxDQUFDdXNELFNBQUwsRUFBZ0I7Y0FBRTs7O1lBQ2xCLzVELElBQUksR0FBR0EsSUFBSSxDQUFDaUQsS0FBTCxDQUFXLENBQVgsRUFBYzgyRCxTQUFTLENBQUNuMkQsS0FBeEIsSUFBaUM1RCxJQUFJLENBQUNpRCxLQUFMLENBQVc4MkQsU0FBUyxDQUFDbjJELEtBQVYsR0FBa0JtMkQsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhdjZELE1BQTFDLENBQXhDO1lBQ0EsSUFBSXNwRCxJQUFJLEdBQUdpUixTQUFTLENBQUMsQ0FBRCxDQUFULEdBQWUsU0FBZixHQUEyQixXQUF0Qzs7WUFDQSxJQUFJMTBDLE1BQU0sQ0FBQ3lqQyxJQUFELENBQU4sSUFBZ0IsSUFBcEIsRUFDRTtjQUFFempDLE1BQU0sQ0FBQ3lqQyxJQUFELENBQU4sR0FBZWlSLFNBQVMsQ0FBQyxDQUFELENBQXhCO2FBREosTUFFSyxJQUFJLENBQUUsSUFBSWhzRCxNQUFKLENBQVcsY0FBY2dzRCxTQUFTLENBQUMsQ0FBRCxDQUF2QixHQUE2QixXQUF4QyxDQUFELENBQXVEM3RELElBQXZELENBQTREaVosTUFBTSxDQUFDeWpDLElBQUQsQ0FBbEUsQ0FBTCxFQUNIO2NBQUV6akMsTUFBTSxDQUFDeWpDLElBQUQsQ0FBTixJQUFnQixNQUFNaVIsU0FBUyxDQUFDLENBQUQsQ0FBL0I7Ozs7O1FBRU4sT0FBTy81RCxJQUFQO09BenFDaUI7OztNQTZxQ25CLFNBQVM2M0QsT0FBVCxDQUFpQjlJLEVBQWpCLEVBQXFCblIsSUFBckIsRUFBMkJwL0MsSUFBM0IsRUFBaUMyWixPQUFqQyxFQUEwQ3JhLENBQTFDLEVBQTZDODVELFdBQTdDLEVBQTBESCxVQUExRCxFQUFzRTtRQUNwRSxJQUFJdUMsWUFBWSxHQUFHeDdELElBQUksQ0FBQ3c3RCxZQUF4Qjs7UUFDQSxJQUFJQSxZQUFZLElBQUksSUFBcEIsRUFBMEI7VUFBRUEsWUFBWSxHQUFHakwsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2t3QixZQUExQjs7O1FBQzVCLElBQUlDLFFBQVEsR0FBRyxDQUFmO1lBQWtCQyxRQUFRLEdBQUcsSUFBN0I7UUFDQSxJQUFJYixNQUFNLEdBQUcsSUFBSS9GLFlBQUosQ0FBaUIxVixJQUFqQixFQUF1Qm1SLEVBQUUsQ0FBQ2psQixPQUFILENBQVdrZixPQUFsQyxFQUEyQzd3QyxPQUEzQyxDQUFiO1lBQWtFcFMsS0FBbEU7UUFDQSxJQUFJNnVELEtBQUssR0FBRzdGLEVBQUUsQ0FBQ2psQixPQUFILENBQVdxd0IsWUFBWCxJQUEyQixDQUFDLElBQUQsQ0FBdkM7O1FBQ0EsSUFBSXZjLElBQUksSUFBSSxFQUFaLEVBQWdCO1VBQUVrYyxrQkFBa0IsQ0FBQ1IsYUFBYSxDQUFDOTZELElBQUQsRUFBTzJaLE9BQU8sQ0FBQzhzQixLQUFmLENBQWQsRUFBcUMyeUIsV0FBckMsQ0FBbEI7OztRQUNsQixPQUFPLENBQUN5QixNQUFNLENBQUMxRixHQUFQLEVBQVIsRUFBc0I7VUFDcEIsSUFBSTBGLE1BQU0sQ0FBQzNqRCxHQUFQLEdBQWFxNUMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzR1QixrQkFBNUIsRUFBZ0Q7WUFDOUNzQixZQUFZLEdBQUcsS0FBZjs7WUFDQSxJQUFJdkMsVUFBSixFQUFnQjtjQUFFd0IsV0FBVyxDQUFDbEssRUFBRCxFQUFLblIsSUFBTCxFQUFXemxDLE9BQVgsRUFBb0JraEQsTUFBTSxDQUFDM2pELEdBQTNCLENBQVg7OztZQUNsQjJqRCxNQUFNLENBQUMzakQsR0FBUCxHQUFha29DLElBQUksQ0FBQ3ArQyxNQUFsQjtZQUNBdUcsS0FBSyxHQUFHLElBQVI7V0FKRixNQUtPO1lBQ0xBLEtBQUssR0FBRyt6RCxrQkFBa0IsQ0FBQ1AsU0FBUyxDQUFDLzZELElBQUQsRUFBTzY2RCxNQUFQLEVBQWVsaEQsT0FBTyxDQUFDOHNCLEtBQXZCLEVBQThCMnZCLEtBQTlCLENBQVYsRUFBZ0RnRCxXQUFoRCxDQUExQjs7O1VBRUYsSUFBSWhELEtBQUosRUFBVztZQUNULElBQUl3RixLQUFLLEdBQUd4RixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMzMEQsSUFBckI7O1lBQ0EsSUFBSW02RCxLQUFKLEVBQVc7Y0FBRXIwRCxLQUFLLEdBQUcsUUFBUUEsS0FBSyxHQUFHcTBELEtBQUssR0FBRyxHQUFSLEdBQWNyMEQsS0FBakIsR0FBeUJxMEQsS0FBdEMsQ0FBUjs7OztVQUVmLElBQUksQ0FBQ0osWUFBRCxJQUFpQkUsUUFBUSxJQUFJbjBELEtBQWpDLEVBQXdDO1lBQ3RDLE9BQU9rMEQsUUFBUSxHQUFHWixNQUFNLENBQUN2OEMsS0FBekIsRUFBZ0M7Y0FDOUJtOUMsUUFBUSxHQUFHOStELElBQUksQ0FBQ3NJLEdBQUwsQ0FBUzQxRCxNQUFNLENBQUN2OEMsS0FBaEIsRUFBdUJtOUMsUUFBUSxHQUFHLElBQWxDLENBQVg7Y0FDQW44RCxDQUFDLENBQUNtOEQsUUFBRCxFQUFXQyxRQUFYLENBQUQ7OztZQUVGQSxRQUFRLEdBQUduMEQsS0FBWDs7O1VBRUZzekQsTUFBTSxDQUFDdjhDLEtBQVAsR0FBZXU4QyxNQUFNLENBQUMzakQsR0FBdEI7OztRQUVGLE9BQU91a0QsUUFBUSxHQUFHWixNQUFNLENBQUMzakQsR0FBekIsRUFBOEI7Ozs7VUFJNUIsSUFBSUEsR0FBRyxHQUFHdmEsSUFBSSxDQUFDc0ksR0FBTCxDQUFTNDFELE1BQU0sQ0FBQzNqRCxHQUFoQixFQUFxQnVrRCxRQUFRLEdBQUcsSUFBaEMsQ0FBVjtVQUNBbjhELENBQUMsQ0FBQzRYLEdBQUQsRUFBTXdrRCxRQUFOLENBQUQ7VUFDQUQsUUFBUSxHQUFHdmtELEdBQVg7O09BaHRDZTs7Ozs7OztNQXl0Q25CLFNBQVNzakQsYUFBVCxDQUF1QmpLLEVBQXZCLEVBQTJCL2hELENBQTNCLEVBQThCK3JELE9BQTlCLEVBQXVDO1FBQ3JDLElBQUlzQixTQUFKO1lBQWVDLE9BQWY7WUFBd0JyRixHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFqQztRQUNBLElBQUlydkMsR0FBRyxHQUFHbXpDLE9BQU8sR0FBRyxDQUFDLENBQUosR0FBUS9yRCxDQUFDLElBQUkraEQsRUFBRSxDQUFDa0csR0FBSCxDQUFPejJELElBQVAsQ0FBWTAwRCxTQUFaLEdBQXdCLElBQXhCLEdBQStCLEdBQW5DLENBQTFCOztRQUNBLEtBQUssSUFBSTU2QyxNQUFNLEdBQUd0TCxDQUFsQixFQUFxQnNMLE1BQU0sR0FBR3NOLEdBQTlCLEVBQW1DLEVBQUV0TixNQUFyQyxFQUE2QztVQUMzQyxJQUFJQSxNQUFNLElBQUkyOEMsR0FBRyxDQUFDdmxELEtBQWxCLEVBQXlCO1lBQUUsT0FBT3VsRCxHQUFHLENBQUN2bEQsS0FBWDs7O1VBQzNCLElBQUl5K0MsSUFBSSxHQUFHNkcsT0FBTyxDQUFDQyxHQUFELEVBQU0zOEMsTUFBTSxHQUFHLENBQWYsQ0FBbEI7Y0FBcUM2dUMsS0FBSyxHQUFHZ0gsSUFBSSxDQUFDd0ssVUFBbEQ7O1VBQ0EsSUFBSXhSLEtBQUssS0FBSyxDQUFDNFIsT0FBRCxJQUFZemdELE1BQU0sSUFBSTZ1QyxLQUFLLFlBQVk0UCxZQUFqQixHQUFnQzVQLEtBQUssQ0FBQzBOLFNBQXRDLEdBQWtELENBQXRELENBQU4sSUFBa0VJLEdBQUcsQ0FBQzZELFlBQXZGLENBQVQsRUFDRTtZQUFFLE9BQU94Z0QsTUFBUDs7O1VBQ0osSUFBSWlpRCxRQUFRLEdBQUd4UixXQUFXLENBQUNvRixJQUFJLENBQUN2USxJQUFOLEVBQVksSUFBWixFQUFrQm1SLEVBQUUsQ0FBQ2psQixPQUFILENBQVdrZixPQUE3QixDQUExQjs7VUFDQSxJQUFJc1IsT0FBTyxJQUFJLElBQVgsSUFBbUJELFNBQVMsR0FBR0UsUUFBbkMsRUFBNkM7WUFDM0NELE9BQU8sR0FBR2hpRCxNQUFNLEdBQUcsQ0FBbkI7WUFDQStoRCxTQUFTLEdBQUdFLFFBQVo7Ozs7UUFHSixPQUFPRCxPQUFQOzs7TUFHRixTQUFTRSxlQUFULENBQXlCdkYsR0FBekIsRUFBOEJqb0QsQ0FBOUIsRUFBaUM7UUFDL0Jpb0QsR0FBRyxDQUFDNkQsWUFBSixHQUFtQjM5RCxJQUFJLENBQUNzSSxHQUFMLENBQVN3eEQsR0FBRyxDQUFDNkQsWUFBYixFQUEyQjlyRCxDQUEzQixDQUFuQjs7UUFDQSxJQUFJaW9ELEdBQUcsQ0FBQzRELGlCQUFKLEdBQXdCN3JELENBQUMsR0FBRyxFQUFoQyxFQUFvQztVQUFFOzs7UUFDdEMsSUFBSThQLEtBQUssR0FBR200QyxHQUFHLENBQUN2bEQsS0FBaEI7O1FBQ0EsS0FBSyxJQUFJeStDLElBQUksR0FBR25oRCxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJtaEQsSUFBSSxHQUFHcnhDLEtBQTlCLEVBQXFDcXhDLElBQUksRUFBekMsRUFBNkM7VUFDM0MsSUFBSWtKLEtBQUssR0FBR3JDLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNOUcsSUFBTixDQUFQLENBQW1Cd0ssVUFBL0IsQ0FEMkM7Ozs7VUFLM0MsSUFBSXRCLEtBQUssS0FBSyxFQUFFQSxLQUFLLFlBQVlOLFlBQW5CLEtBQW9DNUksSUFBSSxHQUFHa0osS0FBSyxDQUFDeEMsU0FBYixHQUF5QjduRCxDQUFsRSxDQUFULEVBQStFO1lBQzdFOFAsS0FBSyxHQUFHcXhDLElBQUksR0FBRyxDQUFmO1lBQ0E7Ozs7UUFHSjhHLEdBQUcsQ0FBQzRELGlCQUFKLEdBQXdCMTlELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3d4RCxHQUFHLENBQUM0RCxpQkFBYixFQUFnQy83QyxLQUFoQyxDQUF4QjtPQXh2Q2lCOzs7TUE0dkNuQixJQUFJMjlDLGdCQUFnQixHQUFHLEtBQXZCO1VBQThCQyxpQkFBaUIsR0FBRyxLQUFsRDs7TUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtRQUMxQkYsZ0JBQWdCLEdBQUcsSUFBbkI7OztNQUdGLFNBQVNHLGlCQUFULEdBQTZCO1FBQzNCRixpQkFBaUIsR0FBRyxJQUFwQjtPQW53Q2lCOzs7TUF3d0NuQixTQUFTRyxVQUFULENBQW9CdHlCLE1BQXBCLEVBQTRCNXNCLElBQTVCLEVBQWtDd0QsRUFBbEMsRUFBc0M7UUFDcEMsS0FBS29wQixNQUFMLEdBQWNBLE1BQWQ7UUFDQSxLQUFLNXNCLElBQUwsR0FBWUEsSUFBWjtRQUFrQixLQUFLd0QsRUFBTCxHQUFVQSxFQUFWO09BMXdDRDs7O01BOHdDbkIsU0FBUzI3QyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUN4eUIsTUFBakMsRUFBeUM7UUFDdkMsSUFBSXd5QixLQUFKLEVBQVc7VUFBRSxLQUFLLElBQUluNUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR201RCxLQUFLLENBQUN2N0QsTUFBMUIsRUFBa0MsRUFBRW9DLENBQXBDLEVBQXVDO1lBQ2xELElBQUlvNUQsSUFBSSxHQUFHRCxLQUFLLENBQUNuNUQsQ0FBRCxDQUFoQjs7WUFDQSxJQUFJbzVELElBQUksQ0FBQ3p5QixNQUFMLElBQWVBLE1BQW5CLEVBQTJCO2NBQUUsT0FBT3l5QixJQUFQOzs7O09BanhDZDs7OztNQXV4Q25CLFNBQVNDLGdCQUFULENBQTBCRixLQUExQixFQUFpQ0MsSUFBakMsRUFBdUM7UUFDckMsSUFBSWp1QyxDQUFKOztRQUNBLEtBQUssSUFBSW5yQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbTVELEtBQUssQ0FBQ3Y3RCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFDRTtVQUFFLElBQUltNUQsS0FBSyxDQUFDbjVELENBQUQsQ0FBTCxJQUFZbzVELElBQWhCLEVBQXNCO1lBQUUsQ0FBQ2p1QyxDQUFDLEtBQUtBLENBQUMsR0FBRyxFQUFULENBQUYsRUFBZ0J4dUIsSUFBaEIsQ0FBcUJ3OEQsS0FBSyxDQUFDbjVELENBQUQsQ0FBMUI7Ozs7UUFDNUIsT0FBT21yQixDQUFQO09BM3hDaUI7OztNQSt4Q25CLFNBQVNtdUMsYUFBVCxDQUF1Qi9NLElBQXZCLEVBQTZCNk0sSUFBN0IsRUFBbUNHLEVBQW5DLEVBQXVDO1FBQ3JDLElBQUlDLFFBQVEsR0FBR0QsRUFBRSxJQUFJamdFLE1BQU0sQ0FBQ3UxQixPQUFiLEtBQXlCMHFDLEVBQUUsQ0FBQ0UsV0FBSCxLQUFtQkYsRUFBRSxDQUFDRSxXQUFILEdBQWlCLElBQUk1cUMsT0FBSixFQUFwQyxDQUF6QixDQUFmOztRQUNBLElBQUkycUMsUUFBUSxJQUFJQSxRQUFRLENBQUNsOEQsR0FBVCxDQUFhaXZELElBQUksQ0FBQ2tOLFdBQWxCLENBQWhCLEVBQWdEO1VBQzlDbE4sSUFBSSxDQUFDa04sV0FBTCxDQUFpQjk4RCxJQUFqQixDQUFzQnk4RCxJQUF0QjtTQURGLE1BRU87VUFDTDdNLElBQUksQ0FBQ2tOLFdBQUwsR0FBbUJsTixJQUFJLENBQUNrTixXQUFMLEdBQW1CbE4sSUFBSSxDQUFDa04sV0FBTCxDQUFpQmw5RCxNQUFqQixDQUF3QixDQUFDNjhELElBQUQsQ0FBeEIsQ0FBbkIsR0FBcUQsQ0FBQ0EsSUFBRCxDQUF4RTs7VUFDQSxJQUFJSSxRQUFKLEVBQWM7WUFBRUEsUUFBUSxDQUFDM3NDLEdBQVQsQ0FBYTAvQixJQUFJLENBQUNrTixXQUFsQjs7OztRQUVsQkwsSUFBSSxDQUFDenlCLE1BQUwsQ0FBWSt5QixVQUFaLENBQXVCbk4sSUFBdkI7T0F2eUNpQjs7Ozs7O01BOHlDbkIsU0FBU29OLGlCQUFULENBQTJCam9CLEdBQTNCLEVBQWdDa29CLE9BQWhDLEVBQXlDQyxRQUF6QyxFQUFtRDtRQUNqRCxJQUFJQyxFQUFKOztRQUNBLElBQUlwb0IsR0FBSixFQUFTO1VBQUUsS0FBSyxJQUFJMXhDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcweEMsR0FBRyxDQUFDOXpDLE1BQXhCLEVBQWdDLEVBQUVvQyxDQUFsQyxFQUFxQztZQUM5QyxJQUFJbzVELElBQUksR0FBRzFuQixHQUFHLENBQUMxeEMsQ0FBRCxDQUFkO2dCQUFtQjJtQyxNQUFNLEdBQUd5eUIsSUFBSSxDQUFDenlCLE1BQWpDO1lBQ0EsSUFBSW96QixZQUFZLEdBQUdYLElBQUksQ0FBQ3IvQyxJQUFMLElBQWEsSUFBYixLQUFzQjRzQixNQUFNLENBQUNxekIsYUFBUCxHQUF1QlosSUFBSSxDQUFDci9DLElBQUwsSUFBYTYvQyxPQUFwQyxHQUE4Q1IsSUFBSSxDQUFDci9DLElBQUwsR0FBWTYvQyxPQUFoRixDQUFuQjs7WUFDQSxJQUFJRyxZQUFZLElBQUlYLElBQUksQ0FBQ3IvQyxJQUFMLElBQWE2L0MsT0FBYixJQUF3Qmp6QixNQUFNLENBQUN2b0MsSUFBUCxJQUFlLFVBQXZDLEtBQXNELENBQUN5N0QsUUFBRCxJQUFhLENBQUNULElBQUksQ0FBQ3p5QixNQUFMLENBQVlzekIsVUFBaEYsQ0FBcEIsRUFBaUg7Y0FDL0csSUFBSUMsU0FBUyxHQUFHZCxJQUFJLENBQUM3N0MsRUFBTCxJQUFXLElBQVgsS0FBb0JvcEIsTUFBTSxDQUFDd3pCLGNBQVAsR0FBd0JmLElBQUksQ0FBQzc3QyxFQUFMLElBQVdxOEMsT0FBbkMsR0FBNkNSLElBQUksQ0FBQzc3QyxFQUFMLEdBQVVxOEMsT0FBM0UsQ0FBaEI7Y0FDQyxDQUFDRSxFQUFFLEtBQUtBLEVBQUUsR0FBRyxFQUFWLENBQUgsRUFBa0JuOUQsSUFBbEIsQ0FBdUIsSUFBSXM4RCxVQUFKLENBQWV0eUIsTUFBZixFQUF1Qnl5QixJQUFJLENBQUNyL0MsSUFBNUIsRUFBa0NtZ0QsU0FBUyxHQUFHLElBQUgsR0FBVWQsSUFBSSxDQUFDNzdDLEVBQTFELENBQXZCOzs7OztRQUdMLE9BQU91OEMsRUFBUDs7O01BRUYsU0FBU00sZ0JBQVQsQ0FBMEIxb0IsR0FBMUIsRUFBK0Iyb0IsS0FBL0IsRUFBc0NSLFFBQXRDLEVBQWdEO1FBQzlDLElBQUlDLEVBQUo7O1FBQ0EsSUFBSXBvQixHQUFKLEVBQVM7VUFBRSxLQUFLLElBQUkxeEMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzB4QyxHQUFHLENBQUM5ekMsTUFBeEIsRUFBZ0MsRUFBRW9DLENBQWxDLEVBQXFDO1lBQzlDLElBQUlvNUQsSUFBSSxHQUFHMW5CLEdBQUcsQ0FBQzF4QyxDQUFELENBQWQ7Z0JBQW1CMm1DLE1BQU0sR0FBR3l5QixJQUFJLENBQUN6eUIsTUFBakM7WUFDQSxJQUFJdXpCLFNBQVMsR0FBR2QsSUFBSSxDQUFDNzdDLEVBQUwsSUFBVyxJQUFYLEtBQW9Cb3BCLE1BQU0sQ0FBQ3d6QixjQUFQLEdBQXdCZixJQUFJLENBQUM3N0MsRUFBTCxJQUFXODhDLEtBQW5DLEdBQTJDakIsSUFBSSxDQUFDNzdDLEVBQUwsR0FBVTg4QyxLQUF6RSxDQUFoQjs7WUFDQSxJQUFJSCxTQUFTLElBQUlkLElBQUksQ0FBQ3IvQyxJQUFMLElBQWFzZ0QsS0FBYixJQUFzQjF6QixNQUFNLENBQUN2b0MsSUFBUCxJQUFlLFVBQXJDLEtBQW9ELENBQUN5N0QsUUFBRCxJQUFhVCxJQUFJLENBQUN6eUIsTUFBTCxDQUFZc3pCLFVBQTdFLENBQWpCLEVBQTJHO2NBQ3pHLElBQUlGLFlBQVksR0FBR1gsSUFBSSxDQUFDci9DLElBQUwsSUFBYSxJQUFiLEtBQXNCNHNCLE1BQU0sQ0FBQ3F6QixhQUFQLEdBQXVCWixJQUFJLENBQUNyL0MsSUFBTCxJQUFhc2dELEtBQXBDLEdBQTRDakIsSUFBSSxDQUFDci9DLElBQUwsR0FBWXNnRCxLQUE5RSxDQUFuQjtjQUNDLENBQUNQLEVBQUUsS0FBS0EsRUFBRSxHQUFHLEVBQVYsQ0FBSCxFQUFrQm45RCxJQUFsQixDQUF1QixJQUFJczhELFVBQUosQ0FBZXR5QixNQUFmLEVBQXVCb3pCLFlBQVksR0FBRyxJQUFILEdBQVVYLElBQUksQ0FBQ3IvQyxJQUFMLEdBQVlzZ0QsS0FBekQsRUFDY2pCLElBQUksQ0FBQzc3QyxFQUFMLElBQVcsSUFBWCxHQUFrQixJQUFsQixHQUF5QjY3QyxJQUFJLENBQUM3N0MsRUFBTCxHQUFVODhDLEtBRGpELENBQXZCOzs7OztRQUlMLE9BQU9QLEVBQVA7T0FyMENpQjs7Ozs7Ozs7TUE4MENuQixTQUFTUSxzQkFBVCxDQUFnQ2pILEdBQWhDLEVBQXFDL2tCLE1BQXJDLEVBQTZDO1FBQzNDLElBQUlBLE1BQU0sQ0FBQ2lzQixJQUFYLEVBQWlCO1VBQUUsT0FBTyxJQUFQOzs7UUFDbkIsSUFBSUMsUUFBUSxHQUFHcEcsTUFBTSxDQUFDZixHQUFELEVBQU0va0IsTUFBTSxDQUFDdjBCLElBQVAsQ0FBWXd5QyxJQUFsQixDQUFOLElBQWlDNkcsT0FBTyxDQUFDQyxHQUFELEVBQU0va0IsTUFBTSxDQUFDdjBCLElBQVAsQ0FBWXd5QyxJQUFsQixDQUFQLENBQStCa04sV0FBL0U7UUFDQSxJQUFJZ0IsT0FBTyxHQUFHckcsTUFBTSxDQUFDZixHQUFELEVBQU0va0IsTUFBTSxDQUFDL3dCLEVBQVAsQ0FBVWd2QyxJQUFoQixDQUFOLElBQStCNkcsT0FBTyxDQUFDQyxHQUFELEVBQU0va0IsTUFBTSxDQUFDL3dCLEVBQVAsQ0FBVWd2QyxJQUFoQixDQUFQLENBQTZCa04sV0FBMUU7O1FBQ0EsSUFBSSxDQUFDZSxRQUFELElBQWEsQ0FBQ0MsT0FBbEIsRUFBMkI7VUFBRSxPQUFPLElBQVA7OztRQUU3QixJQUFJYixPQUFPLEdBQUd0ckIsTUFBTSxDQUFDdjBCLElBQVAsQ0FBWTBJLEVBQTFCO1lBQThCNDNDLEtBQUssR0FBRy9yQixNQUFNLENBQUMvd0IsRUFBUCxDQUFVa0YsRUFBaEQ7WUFBb0RvM0MsUUFBUSxHQUFHcEYsR0FBRyxDQUFDbm1CLE1BQU0sQ0FBQ3YwQixJQUFSLEVBQWN1MEIsTUFBTSxDQUFDL3dCLEVBQXJCLENBQUgsSUFBK0IsQ0FBOUYsQ0FOMkM7O1FBUTNDLElBQUl6UCxLQUFLLEdBQUc2ckQsaUJBQWlCLENBQUNhLFFBQUQsRUFBV1osT0FBWCxFQUFvQkMsUUFBcEIsQ0FBN0I7UUFDQSxJQUFJcHpDLElBQUksR0FBRzJ6QyxnQkFBZ0IsQ0FBQ0ssT0FBRCxFQUFVSixLQUFWLEVBQWlCUixRQUFqQixDQUEzQixDQVQyQzs7UUFZM0MsSUFBSWEsUUFBUSxHQUFHcHNCLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWXArQyxNQUFaLElBQXNCLENBQXJDO1lBQXdDdzBCLE1BQU0sR0FBR3MyQixHQUFHLENBQUNwYSxNQUFNLENBQUMwTixJQUFSLENBQUgsQ0FBaUJwK0MsTUFBakIsSUFBMkI4OEQsUUFBUSxHQUFHZCxPQUFILEdBQWEsQ0FBaEQsQ0FBakQ7O1FBQ0EsSUFBSTlyRCxLQUFKLEVBQVc7O1VBRVQsS0FBSyxJQUFJOU4sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhOLEtBQUssQ0FBQ2xRLE1BQTFCLEVBQWtDLEVBQUVvQyxDQUFwQyxFQUF1QztZQUNyQyxJQUFJbzVELElBQUksR0FBR3RyRCxLQUFLLENBQUM5TixDQUFELENBQWhCOztZQUNBLElBQUlvNUQsSUFBSSxDQUFDNzdDLEVBQUwsSUFBVyxJQUFmLEVBQXFCO2NBQ25CLElBQUl5c0MsS0FBSyxHQUFHa1AsZ0JBQWdCLENBQUN6eUMsSUFBRCxFQUFPMnlDLElBQUksQ0FBQ3p5QixNQUFaLENBQTVCOztjQUNBLElBQUksQ0FBQ3FqQixLQUFMLEVBQVk7Z0JBQUVvUCxJQUFJLENBQUM3N0MsRUFBTCxHQUFVcThDLE9BQVY7ZUFBZCxNQUNLLElBQUljLFFBQUosRUFBYztnQkFBRXRCLElBQUksQ0FBQzc3QyxFQUFMLEdBQVV5c0MsS0FBSyxDQUFDenNDLEVBQU4sSUFBWSxJQUFaLEdBQW1CLElBQW5CLEdBQTBCeXNDLEtBQUssQ0FBQ3pzQyxFQUFOLEdBQVc2VSxNQUEvQzs7Ozs7O1FBSTNCLElBQUkzTCxJQUFKLEVBQVU7O1VBRVIsS0FBSyxJQUFJeWtDLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd6a0MsSUFBSSxDQUFDN29CLE1BQTdCLEVBQXFDLEVBQUVzdEQsR0FBdkMsRUFBNEM7WUFDMUMsSUFBSXlQLE1BQU0sR0FBR2wwQyxJQUFJLENBQUN5a0MsR0FBRCxDQUFqQjs7WUFDQSxJQUFJeVAsTUFBTSxDQUFDcDlDLEVBQVAsSUFBYSxJQUFqQixFQUF1QjtjQUFFbzlDLE1BQU0sQ0FBQ3A5QyxFQUFQLElBQWE2VSxNQUFiOzs7WUFDekIsSUFBSXVvQyxNQUFNLENBQUM1Z0QsSUFBUCxJQUFlLElBQW5CLEVBQXlCO2NBQ3ZCLElBQUk2Z0QsT0FBTyxHQUFHMUIsZ0JBQWdCLENBQUNwckQsS0FBRCxFQUFRNnNELE1BQU0sQ0FBQ2gwQixNQUFmLENBQTlCOztjQUNBLElBQUksQ0FBQ2kwQixPQUFMLEVBQWM7Z0JBQ1pELE1BQU0sQ0FBQzVnRCxJQUFQLEdBQWNxWSxNQUFkOztnQkFDQSxJQUFJc29DLFFBQUosRUFBYztrQkFBRSxDQUFDNXNELEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3Qm5SLElBQXhCLENBQTZCZytELE1BQTdCOzs7YUFKcEIsTUFNTztjQUNMQSxNQUFNLENBQUM1Z0QsSUFBUCxJQUFlcVksTUFBZjs7Y0FDQSxJQUFJc29DLFFBQUosRUFBYztnQkFBRSxDQUFDNXNELEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3Qm5SLElBQXhCLENBQTZCZytELE1BQTdCOzs7O1NBckNxQjs7O1FBMEMzQyxJQUFJN3NELEtBQUosRUFBVztVQUFFQSxLQUFLLEdBQUcrc0QsZUFBZSxDQUFDL3NELEtBQUQsQ0FBdkI7OztRQUNiLElBQUkyWSxJQUFJLElBQUlBLElBQUksSUFBSTNZLEtBQXBCLEVBQTJCO1VBQUUyWSxJQUFJLEdBQUdvMEMsZUFBZSxDQUFDcDBDLElBQUQsQ0FBdEI7OztRQUU3QixJQUFJcTBDLFVBQVUsR0FBRyxDQUFDaHRELEtBQUQsQ0FBakI7O1FBQ0EsSUFBSSxDQUFDNHNELFFBQUwsRUFBZTs7VUFFYixJQUFJSyxHQUFHLEdBQUd6c0IsTUFBTSxDQUFDME4sSUFBUCxDQUFZcCtDLE1BQVosR0FBcUIsQ0FBL0I7Y0FBa0NvOUQsVUFBbEM7O1VBQ0EsSUFBSUQsR0FBRyxHQUFHLENBQU4sSUFBV2p0RCxLQUFmLEVBQ0U7WUFBRSxLQUFLLElBQUlxOUMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3I5QyxLQUFLLENBQUNsUSxNQUE5QixFQUFzQyxFQUFFdXRELEdBQXhDLEVBQ0E7Y0FBRSxJQUFJcjlDLEtBQUssQ0FBQ3E5QyxHQUFELENBQUwsQ0FBVzV0QyxFQUFYLElBQWlCLElBQXJCLEVBQ0E7Z0JBQUUsQ0FBQ3k5QyxVQUFVLEtBQUtBLFVBQVUsR0FBRyxFQUFsQixDQUFYLEVBQWtDcitELElBQWxDLENBQXVDLElBQUlzOEQsVUFBSixDQUFlbnJELEtBQUssQ0FBQ3E5QyxHQUFELENBQUwsQ0FBV3hrQixNQUExQixFQUFrQyxJQUFsQyxFQUF3QyxJQUF4QyxDQUF2Qzs7Ozs7VUFDUixLQUFLLElBQUkwa0IsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzBQLEdBQXhCLEVBQTZCLEVBQUUxUCxHQUEvQixFQUNFO1lBQUV5UCxVQUFVLENBQUNuK0QsSUFBWCxDQUFnQnErRCxVQUFoQjs7O1VBQ0pGLFVBQVUsQ0FBQ24rRCxJQUFYLENBQWdCOHBCLElBQWhCOzs7UUFFRixPQUFPcTBDLFVBQVA7T0F2NENpQjs7OztNQTQ0Q25CLFNBQVNELGVBQVQsQ0FBeUIxQixLQUF6QixFQUFnQztRQUM5QixLQUFLLElBQUluNUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR201RCxLQUFLLENBQUN2N0QsTUFBMUIsRUFBa0MsRUFBRW9DLENBQXBDLEVBQXVDO1VBQ3JDLElBQUlvNUQsSUFBSSxHQUFHRCxLQUFLLENBQUNuNUQsQ0FBRCxDQUFoQjs7VUFDQSxJQUFJbzVELElBQUksQ0FBQ3IvQyxJQUFMLElBQWEsSUFBYixJQUFxQnEvQyxJQUFJLENBQUNyL0MsSUFBTCxJQUFhcS9DLElBQUksQ0FBQzc3QyxFQUF2QyxJQUE2QzY3QyxJQUFJLENBQUN6eUIsTUFBTCxDQUFZczBCLGNBQVosS0FBK0IsS0FBaEYsRUFDRTtZQUFFOUIsS0FBSyxDQUFDbnJDLE1BQU4sQ0FBYWh1QixDQUFDLEVBQWQsRUFBa0IsQ0FBbEI7Ozs7UUFFTixJQUFJLENBQUNtNUQsS0FBSyxDQUFDdjdELE1BQVgsRUFBbUI7VUFBRSxPQUFPLElBQVA7OztRQUNyQixPQUFPdTdELEtBQVA7T0FuNUNpQjs7O01BdTVDbkIsU0FBUytCLG9CQUFULENBQThCN0gsR0FBOUIsRUFBbUN0NUMsSUFBbkMsRUFBeUN3RCxFQUF6QyxFQUE2QztRQUMzQyxJQUFJNDlDLE9BQU8sR0FBRyxJQUFkO1FBQ0E5SCxHQUFHLENBQUNuNUMsSUFBSixDQUFTSCxJQUFJLENBQUN3eUMsSUFBZCxFQUFvQmh2QyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQTlCLEVBQWlDLFVBQVVBLElBQVYsRUFBZ0I7VUFDL0MsSUFBSUEsSUFBSSxDQUFDa04sV0FBVCxFQUFzQjtZQUFFLEtBQUssSUFBSXo1RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdXNELElBQUksQ0FBQ2tOLFdBQUwsQ0FBaUI3N0QsTUFBckMsRUFBNkMsRUFBRW9DLENBQS9DLEVBQWtEO2NBQ3hFLElBQUkwaUMsSUFBSSxHQUFHNnBCLElBQUksQ0FBQ2tOLFdBQUwsQ0FBaUJ6NUQsQ0FBakIsRUFBb0IybUMsTUFBL0I7O2NBQ0EsSUFBSWpFLElBQUksQ0FBQzA0QixRQUFMLEtBQWtCLENBQUNELE9BQUQsSUFBWXRrRCxPQUFPLENBQUNza0QsT0FBRCxFQUFVejRCLElBQVYsQ0FBUCxJQUEwQixDQUFDLENBQXpELENBQUosRUFDRTtnQkFBRSxDQUFDeTRCLE9BQU8sS0FBS0EsT0FBTyxHQUFHLEVBQWYsQ0FBUixFQUE0QngrRCxJQUE1QixDQUFpQytsQyxJQUFqQzs7OztTQUpSOztRQU9BLElBQUksQ0FBQ3k0QixPQUFMLEVBQWM7VUFBRSxPQUFPLElBQVA7OztRQUNoQixJQUFJN3hCLEtBQUssR0FBRyxDQUFDO1VBQUN2dkIsSUFBSSxFQUFFQSxJQUFQO1VBQWF3RCxFQUFFLEVBQUVBO1NBQWxCLENBQVo7O1FBQ0EsS0FBSyxJQUFJdmQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR203RCxPQUFPLENBQUN2OUQsTUFBNUIsRUFBb0MsRUFBRW9DLENBQXRDLEVBQXlDO1VBQ3ZDLElBQUlxN0QsRUFBRSxHQUFHRixPQUFPLENBQUNuN0QsQ0FBRCxDQUFoQjtjQUFxQitQLENBQUMsR0FBR3NyRCxFQUFFLENBQUN2OUMsSUFBSCxDQUFRLENBQVIsQ0FBekI7O1VBQ0EsS0FBSyxJQUFJOVYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NoQyxLQUFLLENBQUMxckMsTUFBMUIsRUFBa0MsRUFBRW9LLENBQXBDLEVBQXVDO1lBQ3JDLElBQUkwVyxDQUFDLEdBQUc0cUIsS0FBSyxDQUFDdGhDLENBQUQsQ0FBYjs7WUFDQSxJQUFJeXNELEdBQUcsQ0FBQy8xQyxDQUFDLENBQUNuQixFQUFILEVBQU94TixDQUFDLENBQUNnSyxJQUFULENBQUgsR0FBb0IsQ0FBcEIsSUFBeUIwNkMsR0FBRyxDQUFDLzFDLENBQUMsQ0FBQzNFLElBQUgsRUFBU2hLLENBQUMsQ0FBQ3dOLEVBQVgsQ0FBSCxHQUFvQixDQUFqRCxFQUFvRDtjQUFFOzs7WUFDdEQsSUFBSSs5QyxRQUFRLEdBQUcsQ0FBQ3R6RCxDQUFELEVBQUksQ0FBSixDQUFmO2dCQUF1QnV6RCxLQUFLLEdBQUc5RyxHQUFHLENBQUMvMUMsQ0FBQyxDQUFDM0UsSUFBSCxFQUFTaEssQ0FBQyxDQUFDZ0ssSUFBWCxDQUFsQztnQkFBb0R5aEQsR0FBRyxHQUFHL0csR0FBRyxDQUFDLzFDLENBQUMsQ0FBQ25CLEVBQUgsRUFBT3hOLENBQUMsQ0FBQ3dOLEVBQVQsQ0FBN0Q7O1lBQ0EsSUFBSWcrQyxLQUFLLEdBQUcsQ0FBUixJQUFhLENBQUNGLEVBQUUsQ0FBQ3JCLGFBQUosSUFBcUIsQ0FBQ3VCLEtBQXZDLEVBQ0U7Y0FBRUQsUUFBUSxDQUFDMytELElBQVQsQ0FBYztnQkFBQ29kLElBQUksRUFBRTJFLENBQUMsQ0FBQzNFLElBQVQ7Z0JBQWV3RCxFQUFFLEVBQUV4TixDQUFDLENBQUNnSztlQUFuQzs7O1lBQ0osSUFBSXloRCxHQUFHLEdBQUcsQ0FBTixJQUFXLENBQUNILEVBQUUsQ0FBQ2xCLGNBQUosSUFBc0IsQ0FBQ3FCLEdBQXRDLEVBQ0U7Y0FBRUYsUUFBUSxDQUFDMytELElBQVQsQ0FBYztnQkFBQ29kLElBQUksRUFBRWhLLENBQUMsQ0FBQ3dOLEVBQVQ7Z0JBQWFBLEVBQUUsRUFBRW1CLENBQUMsQ0FBQ25CO2VBQWpDOzs7WUFDSityQixLQUFLLENBQUN0YixNQUFOLENBQWFod0IsS0FBYixDQUFtQnNyQyxLQUFuQixFQUEwQmd5QixRQUExQjtZQUNBdHpELENBQUMsSUFBSXN6RCxRQUFRLENBQUMxOUQsTUFBVCxHQUFrQixDQUF2Qjs7OztRQUdKLE9BQU8wckMsS0FBUDtPQWg3Q2lCOzs7TUFvN0NuQixTQUFTbXlCLGlCQUFULENBQTJCbFAsSUFBM0IsRUFBaUM7UUFDL0IsSUFBSTRNLEtBQUssR0FBRzVNLElBQUksQ0FBQ2tOLFdBQWpCOztRQUNBLElBQUksQ0FBQ04sS0FBTCxFQUFZO1VBQUU7OztRQUNkLEtBQUssSUFBSW41RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbTVELEtBQUssQ0FBQ3Y3RCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFDRTtVQUFFbTVELEtBQUssQ0FBQ241RCxDQUFELENBQUwsQ0FBUzJtQyxNQUFULENBQWdCKzBCLFVBQWhCLENBQTJCblAsSUFBM0I7OztRQUNKQSxJQUFJLENBQUNrTixXQUFMLEdBQW1CLElBQW5COzs7TUFFRixTQUFTa0MsaUJBQVQsQ0FBMkJwUCxJQUEzQixFQUFpQzRNLEtBQWpDLEVBQXdDO1FBQ3RDLElBQUksQ0FBQ0EsS0FBTCxFQUFZO1VBQUU7OztRQUNkLEtBQUssSUFBSW41RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbTVELEtBQUssQ0FBQ3Y3RCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFDRTtVQUFFbTVELEtBQUssQ0FBQ241RCxDQUFELENBQUwsQ0FBUzJtQyxNQUFULENBQWdCK3lCLFVBQWhCLENBQTJCbk4sSUFBM0I7OztRQUNKQSxJQUFJLENBQUNrTixXQUFMLEdBQW1CTixLQUFuQjtPQS83Q2lCOzs7O01BbzhDbkIsU0FBU3lDLFNBQVQsQ0FBbUJqMUIsTUFBbkIsRUFBMkI7UUFBRSxPQUFPQSxNQUFNLENBQUNxekIsYUFBUCxHQUF1QixDQUFDLENBQXhCLEdBQTRCLENBQW5DOzs7TUFDN0IsU0FBUzZCLFVBQVQsQ0FBb0JsMUIsTUFBcEIsRUFBNEI7UUFBRSxPQUFPQSxNQUFNLENBQUN3ekIsY0FBUCxHQUF3QixDQUF4QixHQUE0QixDQUFuQztPQXI4Q1g7Ozs7O01BMDhDbkIsU0FBUzJCLHVCQUFULENBQWlDemhFLENBQWpDLEVBQW9DeUQsQ0FBcEMsRUFBdUM7UUFDckMsSUFBSWkrRCxPQUFPLEdBQUcxaEUsQ0FBQyxDQUFDazVELEtBQUYsQ0FBUTMxRCxNQUFSLEdBQWlCRSxDQUFDLENBQUN5MUQsS0FBRixDQUFRMzFELE1BQXZDOztRQUNBLElBQUltK0QsT0FBTyxJQUFJLENBQWYsRUFBa0I7VUFBRSxPQUFPQSxPQUFQOzs7UUFDcEIsSUFBSUMsSUFBSSxHQUFHM2hFLENBQUMsQ0FBQ3lqQixJQUFGLEVBQVg7WUFBcUJtK0MsSUFBSSxHQUFHbitELENBQUMsQ0FBQ2dnQixJQUFGLEVBQTVCO1FBQ0EsSUFBSW8rQyxPQUFPLEdBQUd6SCxHQUFHLENBQUN1SCxJQUFJLENBQUNqaUQsSUFBTixFQUFZa2lELElBQUksQ0FBQ2xpRCxJQUFqQixDQUFILElBQTZCNmhELFNBQVMsQ0FBQ3ZoRSxDQUFELENBQVQsR0FBZXVoRSxTQUFTLENBQUM5OUQsQ0FBRCxDQUFuRTs7UUFDQSxJQUFJbytELE9BQUosRUFBYTtVQUFFLE9BQU8sQ0FBQ0EsT0FBUjs7O1FBQ2YsSUFBSUMsS0FBSyxHQUFHMUgsR0FBRyxDQUFDdUgsSUFBSSxDQUFDeitDLEVBQU4sRUFBVTArQyxJQUFJLENBQUMxK0MsRUFBZixDQUFILElBQXlCcytDLFVBQVUsQ0FBQ3hoRSxDQUFELENBQVYsR0FBZ0J3aEUsVUFBVSxDQUFDLzlELENBQUQsQ0FBL0Q7O1FBQ0EsSUFBSXErRCxLQUFKLEVBQVc7VUFBRSxPQUFPQSxLQUFQOzs7UUFDYixPQUFPcitELENBQUMsQ0FBQzFCLEVBQUYsR0FBTy9CLENBQUMsQ0FBQytCLEVBQWhCO09BbDlDaUI7Ozs7TUF1OUNuQixTQUFTZ2dFLG1CQUFULENBQTZCN1AsSUFBN0IsRUFBbUNyeEMsS0FBbkMsRUFBMEM7UUFDeEMsSUFBSW1oRCxHQUFHLEdBQUd2RCxpQkFBaUIsSUFBSXZNLElBQUksQ0FBQ2tOLFdBQXBDO1lBQWlEelAsS0FBakQ7O1FBQ0EsSUFBSXFTLEdBQUosRUFBUztVQUFFLEtBQUssSUFBSUMsRUFBRSxHQUFJLEtBQUssQ0FBZixFQUFtQnQ4RCxDQUFDLEdBQUcsQ0FBNUIsRUFBK0JBLENBQUMsR0FBR3E4RCxHQUFHLENBQUN6K0QsTUFBdkMsRUFBK0MsRUFBRW9DLENBQWpELEVBQW9EO1lBQzdEczhELEVBQUUsR0FBR0QsR0FBRyxDQUFDcjhELENBQUQsQ0FBUjs7WUFDQSxJQUFJczhELEVBQUUsQ0FBQzMxQixNQUFILENBQVU0MUIsU0FBVixJQUF1QixDQUFDcmhELEtBQUssR0FBR29oRCxFQUFFLENBQUN2aUQsSUFBTixHQUFhdWlELEVBQUUsQ0FBQy8rQyxFQUF0QixLQUE2QixJQUFwRCxLQUNDLENBQUN5c0MsS0FBRCxJQUFVOFIsdUJBQXVCLENBQUM5UixLQUFELEVBQVFzUyxFQUFFLENBQUMzMUIsTUFBWCxDQUF2QixHQUE0QyxDQUR2RCxDQUFKLEVBRUU7Y0FBRXFqQixLQUFLLEdBQUdzUyxFQUFFLENBQUMzMUIsTUFBWDs7Ozs7UUFFTixPQUFPcWpCLEtBQVA7OztNQUVGLFNBQVN3UyxvQkFBVCxDQUE4QmpRLElBQTlCLEVBQW9DO1FBQUUsT0FBTzZQLG1CQUFtQixDQUFDN1AsSUFBRCxFQUFPLElBQVAsQ0FBMUI7OztNQUN0QyxTQUFTa1Esa0JBQVQsQ0FBNEJsUSxJQUE1QixFQUFrQztRQUFFLE9BQU82UCxtQkFBbUIsQ0FBQzdQLElBQUQsRUFBTyxLQUFQLENBQTFCOzs7TUFFcEMsU0FBU21RLG1CQUFULENBQTZCblEsSUFBN0IsRUFBbUM5cEMsRUFBbkMsRUFBdUM7UUFDckMsSUFBSTQ1QyxHQUFHLEdBQUd2RCxpQkFBaUIsSUFBSXZNLElBQUksQ0FBQ2tOLFdBQXBDO1lBQWlEelAsS0FBakQ7O1FBQ0EsSUFBSXFTLEdBQUosRUFBUztVQUFFLEtBQUssSUFBSXI4RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcThELEdBQUcsQ0FBQ3orRCxNQUF4QixFQUFnQyxFQUFFb0MsQ0FBbEMsRUFBcUM7WUFDOUMsSUFBSXM4RCxFQUFFLEdBQUdELEdBQUcsQ0FBQ3I4RCxDQUFELENBQVo7O1lBQ0EsSUFBSXM4RCxFQUFFLENBQUMzMUIsTUFBSCxDQUFVNDFCLFNBQVYsS0FBd0JELEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVcsSUFBWCxJQUFtQnVpRCxFQUFFLENBQUN2aUQsSUFBSCxHQUFVMEksRUFBckQsTUFBNkQ2NUMsRUFBRSxDQUFDLytDLEVBQUgsSUFBUyxJQUFULElBQWlCKytDLEVBQUUsQ0FBQy8rQyxFQUFILEdBQVFrRixFQUF0RixNQUNDLENBQUN1bkMsS0FBRCxJQUFVOFIsdUJBQXVCLENBQUM5UixLQUFELEVBQVFzUyxFQUFFLENBQUMzMUIsTUFBWCxDQUF2QixHQUE0QyxDQUR2RCxDQUFKLEVBQytEO2NBQUVxakIsS0FBSyxHQUFHc1MsRUFBRSxDQUFDMzFCLE1BQVg7Ozs7O1FBRW5FLE9BQU9xakIsS0FBUDtPQTMrQ2lCOzs7OztNQWkvQ25CLFNBQVMyUyx5QkFBVCxDQUFtQ3RKLEdBQW5DLEVBQXdDVSxNQUF4QyxFQUFnRGg2QyxJQUFoRCxFQUFzRHdELEVBQXRELEVBQTBEb3BCLE1BQTFELEVBQWtFO1FBQ2hFLElBQUk0bEIsSUFBSSxHQUFHNkcsT0FBTyxDQUFDQyxHQUFELEVBQU1VLE1BQU4sQ0FBbEI7UUFDQSxJQUFJc0ksR0FBRyxHQUFHdkQsaUJBQWlCLElBQUl2TSxJQUFJLENBQUNrTixXQUFwQzs7UUFDQSxJQUFJNEMsR0FBSixFQUFTO1VBQUUsS0FBSyxJQUFJcjhELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxOEQsR0FBRyxDQUFDeitELE1BQXhCLEVBQWdDLEVBQUVvQyxDQUFsQyxFQUFxQztZQUM5QyxJQUFJczhELEVBQUUsR0FBR0QsR0FBRyxDQUFDcjhELENBQUQsQ0FBWjs7WUFDQSxJQUFJLENBQUNzOEQsRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVTQxQixTQUFmLEVBQTBCO2NBQUU7OztZQUM1QixJQUFJdlMsS0FBSyxHQUFHc1MsRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVTdvQixJQUFWLENBQWUsQ0FBZixDQUFaO1lBQ0EsSUFBSW8rQyxPQUFPLEdBQUd6SCxHQUFHLENBQUN6SyxLQUFLLENBQUNqd0MsSUFBUCxFQUFhQSxJQUFiLENBQUgsSUFBeUI2aEQsU0FBUyxDQUFDVSxFQUFFLENBQUMzMUIsTUFBSixDQUFULEdBQXVCaTFCLFNBQVMsQ0FBQ2oxQixNQUFELENBQXZFO1lBQ0EsSUFBSXcxQixLQUFLLEdBQUcxSCxHQUFHLENBQUN6SyxLQUFLLENBQUN6c0MsRUFBUCxFQUFXQSxFQUFYLENBQUgsSUFBcUJzK0MsVUFBVSxDQUFDUyxFQUFFLENBQUMzMUIsTUFBSixDQUFWLEdBQXdCazFCLFVBQVUsQ0FBQ2wxQixNQUFELENBQW5FOztZQUNBLElBQUl1MUIsT0FBTyxJQUFJLENBQVgsSUFBZ0JDLEtBQUssSUFBSSxDQUF6QixJQUE4QkQsT0FBTyxJQUFJLENBQVgsSUFBZ0JDLEtBQUssSUFBSSxDQUEzRCxFQUE4RDtjQUFFOzs7WUFDaEUsSUFBSUQsT0FBTyxJQUFJLENBQVgsS0FBaUJJLEVBQUUsQ0FBQzMxQixNQUFILENBQVV3ekIsY0FBVixJQUE0Qnh6QixNQUFNLENBQUNxekIsYUFBbkMsR0FBbUR2RixHQUFHLENBQUN6SyxLQUFLLENBQUN6c0MsRUFBUCxFQUFXeEQsSUFBWCxDQUFILElBQXVCLENBQTFFLEdBQThFMDZDLEdBQUcsQ0FBQ3pLLEtBQUssQ0FBQ3pzQyxFQUFQLEVBQVd4RCxJQUFYLENBQUgsR0FBc0IsQ0FBckgsS0FDQW1pRCxPQUFPLElBQUksQ0FBWCxLQUFpQkksRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVXd6QixjQUFWLElBQTRCeHpCLE1BQU0sQ0FBQ3F6QixhQUFuQyxHQUFtRHZGLEdBQUcsQ0FBQ3pLLEtBQUssQ0FBQ2p3QyxJQUFQLEVBQWF3RCxFQUFiLENBQUgsSUFBdUIsQ0FBMUUsR0FBOEVrM0MsR0FBRyxDQUFDekssS0FBSyxDQUFDandDLElBQVAsRUFBYXdELEVBQWIsQ0FBSCxHQUFzQixDQUFySCxDQURKLEVBRUU7Y0FBRSxPQUFPLElBQVA7Ozs7T0E3L0NXOzs7Ozs7TUFxZ0RuQixTQUFTcS9DLFVBQVQsQ0FBb0JyUSxJQUFwQixFQUEwQjtRQUN4QixJQUFJc1EsTUFBSjs7UUFDQSxPQUFPQSxNQUFNLEdBQUdMLG9CQUFvQixDQUFDalEsSUFBRCxDQUFwQyxFQUNFO1VBQUVBLElBQUksR0FBR3NRLE1BQU0sQ0FBQy8rQyxJQUFQLENBQVksQ0FBQyxDQUFiLEVBQWdCLElBQWhCLEVBQXNCeXVDLElBQTdCOzs7UUFDSixPQUFPQSxJQUFQOzs7TUFHRixTQUFTdVEsYUFBVCxDQUF1QnZRLElBQXZCLEVBQTZCO1FBQzNCLElBQUlzUSxNQUFKOztRQUNBLE9BQU9BLE1BQU0sR0FBR0osa0JBQWtCLENBQUNsUSxJQUFELENBQWxDLEVBQ0U7VUFBRUEsSUFBSSxHQUFHc1EsTUFBTSxDQUFDLytDLElBQVAsQ0FBWSxDQUFaLEVBQWUsSUFBZixFQUFxQnl1QyxJQUE1Qjs7O1FBQ0osT0FBT0EsSUFBUDtPQWhoRGlCOzs7O01BcWhEbkIsU0FBU3dRLG1CQUFULENBQTZCeFEsSUFBN0IsRUFBbUM7UUFDakMsSUFBSXNRLE1BQUosRUFBWXRKLEtBQVo7O1FBQ0EsT0FBT3NKLE1BQU0sR0FBR0osa0JBQWtCLENBQUNsUSxJQUFELENBQWxDLEVBQTBDO1VBQ3hDQSxJQUFJLEdBQUdzUSxNQUFNLENBQUMvK0MsSUFBUCxDQUFZLENBQVosRUFBZSxJQUFmLEVBQXFCeXVDLElBQTVCO1VBQ0MsQ0FBQ2dILEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3QjUyRCxJQUF4QixDQUE2QjR2RCxJQUE3Qjs7O1FBRUgsT0FBT2dILEtBQVA7T0EzaERpQjs7OztNQWdpRG5CLFNBQVN5SixZQUFULENBQXNCM0osR0FBdEIsRUFBMkI0SixLQUEzQixFQUFrQztRQUNoQyxJQUFJMVEsSUFBSSxHQUFHNkcsT0FBTyxDQUFDQyxHQUFELEVBQU00SixLQUFOLENBQWxCO1lBQWdDQyxHQUFHLEdBQUdOLFVBQVUsQ0FBQ3JRLElBQUQsQ0FBaEQ7O1FBQ0EsSUFBSUEsSUFBSSxJQUFJMlEsR0FBWixFQUFpQjtVQUFFLE9BQU9ELEtBQVA7OztRQUNuQixPQUFPbEosTUFBTSxDQUFDbUosR0FBRCxDQUFiO09BbmlEaUI7Ozs7TUF3aURuQixTQUFTQyxlQUFULENBQXlCOUosR0FBekIsRUFBOEI0SixLQUE5QixFQUFxQztRQUNuQyxJQUFJQSxLQUFLLEdBQUc1SixHQUFHLENBQUMrSixRQUFKLEVBQVosRUFBNEI7VUFBRSxPQUFPSCxLQUFQOzs7UUFDOUIsSUFBSTFRLElBQUksR0FBRzZHLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNNEosS0FBTixDQUFsQjtZQUFnQ0osTUFBaEM7O1FBQ0EsSUFBSSxDQUFDUSxZQUFZLENBQUNoSyxHQUFELEVBQU05RyxJQUFOLENBQWpCLEVBQThCO1VBQUUsT0FBTzBRLEtBQVA7OztRQUNoQyxPQUFPSixNQUFNLEdBQUdKLGtCQUFrQixDQUFDbFEsSUFBRCxDQUFsQyxFQUNFO1VBQUVBLElBQUksR0FBR3NRLE1BQU0sQ0FBQy8rQyxJQUFQLENBQVksQ0FBWixFQUFlLElBQWYsRUFBcUJ5dUMsSUFBNUI7OztRQUNKLE9BQU93SCxNQUFNLENBQUN4SCxJQUFELENBQU4sR0FBZSxDQUF0QjtPQTlpRGlCOzs7OztNQW9qRG5CLFNBQVM4USxZQUFULENBQXNCaEssR0FBdEIsRUFBMkI5RyxJQUEzQixFQUFpQztRQUMvQixJQUFJOFAsR0FBRyxHQUFHdkQsaUJBQWlCLElBQUl2TSxJQUFJLENBQUNrTixXQUFwQzs7UUFDQSxJQUFJNEMsR0FBSixFQUFTO1VBQUUsS0FBSyxJQUFJQyxFQUFFLEdBQUksS0FBSyxDQUFmLEVBQW1CdDhELENBQUMsR0FBRyxDQUE1QixFQUErQkEsQ0FBQyxHQUFHcThELEdBQUcsQ0FBQ3orRCxNQUF2QyxFQUErQyxFQUFFb0MsQ0FBakQsRUFBb0Q7WUFDN0RzOEQsRUFBRSxHQUFHRCxHQUFHLENBQUNyOEQsQ0FBRCxDQUFSOztZQUNBLElBQUksQ0FBQ3M4RCxFQUFFLENBQUMzMUIsTUFBSCxDQUFVNDFCLFNBQWYsRUFBMEI7Y0FBRTs7O1lBQzVCLElBQUlELEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVcsSUFBZixFQUFxQjtjQUFFLE9BQU8sSUFBUDs7O1lBQ3ZCLElBQUl1aUQsRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVTIyQixVQUFkLEVBQTBCO2NBQUU7OztZQUM1QixJQUFJaEIsRUFBRSxDQUFDdmlELElBQUgsSUFBVyxDQUFYLElBQWdCdWlELEVBQUUsQ0FBQzMxQixNQUFILENBQVVxekIsYUFBMUIsSUFBMkN1RCxpQkFBaUIsQ0FBQ2xLLEdBQUQsRUFBTTlHLElBQU4sRUFBWStQLEVBQVosQ0FBaEUsRUFDRTtjQUFFLE9BQU8sSUFBUDs7Ozs7O01BR1IsU0FBU2lCLGlCQUFULENBQTJCbEssR0FBM0IsRUFBZ0M5RyxJQUFoQyxFQUFzQzZNLElBQXRDLEVBQTRDO1FBQzFDLElBQUlBLElBQUksQ0FBQzc3QyxFQUFMLElBQVcsSUFBZixFQUFxQjtVQUNuQixJQUFJOUcsR0FBRyxHQUFHMmlELElBQUksQ0FBQ3p5QixNQUFMLENBQVk3b0IsSUFBWixDQUFpQixDQUFqQixFQUFvQixJQUFwQixDQUFWO1VBQ0EsT0FBT3kvQyxpQkFBaUIsQ0FBQ2xLLEdBQUQsRUFBTTU4QyxHQUFHLENBQUM4MUMsSUFBVixFQUFnQjJNLGdCQUFnQixDQUFDemlELEdBQUcsQ0FBQzgxQyxJQUFKLENBQVNrTixXQUFWLEVBQXVCTCxJQUFJLENBQUN6eUIsTUFBNUIsQ0FBaEMsQ0FBeEI7OztRQUVGLElBQUl5eUIsSUFBSSxDQUFDenlCLE1BQUwsQ0FBWXd6QixjQUFaLElBQThCZixJQUFJLENBQUM3N0MsRUFBTCxJQUFXZ3ZDLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUF2RCxFQUNFO1VBQUUsT0FBTyxJQUFQOzs7UUFDSixLQUFLLElBQUkwK0QsRUFBRSxHQUFJLEtBQUssQ0FBZixFQUFtQnQ4RCxDQUFDLEdBQUcsQ0FBNUIsRUFBK0JBLENBQUMsR0FBR3VzRCxJQUFJLENBQUNrTixXQUFMLENBQWlCNzdELE1BQXBELEVBQTRELEVBQUVvQyxDQUE5RCxFQUFpRTtVQUMvRHM4RCxFQUFFLEdBQUcvUCxJQUFJLENBQUNrTixXQUFMLENBQWlCejVELENBQWpCLENBQUw7O1VBQ0EsSUFBSXM4RCxFQUFFLENBQUMzMUIsTUFBSCxDQUFVNDFCLFNBQVYsSUFBdUIsQ0FBQ0QsRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVTIyQixVQUFsQyxJQUFnRGhCLEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVdxL0MsSUFBSSxDQUFDNzdDLEVBQWhFLEtBQ0MrK0MsRUFBRSxDQUFDLytDLEVBQUgsSUFBUyxJQUFULElBQWlCKytDLEVBQUUsQ0FBQy8rQyxFQUFILElBQVM2N0MsSUFBSSxDQUFDci9DLElBRGhDLE1BRUN1aUQsRUFBRSxDQUFDMzFCLE1BQUgsQ0FBVXF6QixhQUFWLElBQTJCWixJQUFJLENBQUN6eUIsTUFBTCxDQUFZd3pCLGNBRnhDLEtBR0FvRCxpQkFBaUIsQ0FBQ2xLLEdBQUQsRUFBTTlHLElBQU4sRUFBWStQLEVBQVosQ0FIckIsRUFHc0M7WUFBRSxPQUFPLElBQVA7OztPQTNrRHpCOzs7TUFnbERuQixTQUFTa0IsYUFBVCxDQUFzQkMsT0FBdEIsRUFBK0I7UUFDN0JBLE9BQU8sR0FBR2IsVUFBVSxDQUFDYSxPQUFELENBQXBCO1FBRUEsSUFBSTN2QixDQUFDLEdBQUcsQ0FBUjtZQUFXd2xCLEtBQUssR0FBR21LLE9BQU8sQ0FBQzcyQyxNQUEzQjs7UUFDQSxLQUFLLElBQUk1bUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3N6RCxLQUFLLENBQUNDLEtBQU4sQ0FBWTMxRCxNQUFoQyxFQUF3QyxFQUFFb0MsQ0FBMUMsRUFBNkM7VUFDM0MsSUFBSXVzRCxJQUFJLEdBQUcrRyxLQUFLLENBQUNDLEtBQU4sQ0FBWXZ6RCxDQUFaLENBQVg7O1VBQ0EsSUFBSXVzRCxJQUFJLElBQUlrUixPQUFaLEVBQXFCO1lBQUU7V0FBdkIsTUFDSztZQUFFM3ZCLENBQUMsSUFBSXllLElBQUksQ0FBQ25ULE1BQVY7Ozs7UUFFVCxLQUFLLElBQUkxNkIsQ0FBQyxHQUFHNDBDLEtBQUssQ0FBQzFzQyxNQUFuQixFQUEyQmxJLENBQTNCLEVBQThCNDBDLEtBQUssR0FBRzUwQyxDQUFSLEVBQVdBLENBQUMsR0FBRzQwQyxLQUFLLENBQUMxc0MsTUFBbkQsRUFBMkQ7VUFDekQsS0FBSyxJQUFJc2tDLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd4c0MsQ0FBQyxDQUFDODBDLFFBQUYsQ0FBVzUxRCxNQUFuQyxFQUEyQyxFQUFFc3RELEdBQTdDLEVBQWtEO1lBQ2hELElBQUlkLEdBQUcsR0FBRzFyQyxDQUFDLENBQUM4MEMsUUFBRixDQUFXdEksR0FBWCxDQUFWOztZQUNBLElBQUlkLEdBQUcsSUFBSWtKLEtBQVgsRUFBa0I7Y0FBRTthQUFwQixNQUNLO2NBQUV4bEIsQ0FBQyxJQUFJc2MsR0FBRyxDQUFDaFIsTUFBVDs7Ozs7UUFHWCxPQUFPdEwsQ0FBUDtPQWhtRGlCOzs7OztNQXNtRG5CLFNBQVM0dkIsVUFBVCxDQUFvQm5SLElBQXBCLEVBQTBCO1FBQ3hCLElBQUlBLElBQUksQ0FBQ25ULE1BQUwsSUFBZSxDQUFuQixFQUFzQjtVQUFFLE9BQU8sQ0FBUDs7O1FBQ3hCLElBQUlqdUMsR0FBRyxHQUFHb2hELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFwQjtZQUE0QmkvRCxNQUE1QjtZQUFvQ3pTLEdBQUcsR0FBR21DLElBQTFDOztRQUNBLE9BQU9zUSxNQUFNLEdBQUdMLG9CQUFvQixDQUFDcFMsR0FBRCxDQUFwQyxFQUEyQztVQUN6QyxJQUFJSixLQUFLLEdBQUc2UyxNQUFNLENBQUMvK0MsSUFBUCxDQUFZLENBQVosRUFBZSxJQUFmLENBQVo7VUFDQXNzQyxHQUFHLEdBQUdKLEtBQUssQ0FBQ2p3QyxJQUFOLENBQVd3eUMsSUFBakI7VUFDQXBoRCxHQUFHLElBQUk2K0MsS0FBSyxDQUFDandDLElBQU4sQ0FBVzBJLEVBQVgsR0FBZ0J1bkMsS0FBSyxDQUFDenNDLEVBQU4sQ0FBU2tGLEVBQWhDOzs7UUFFRjJuQyxHQUFHLEdBQUdtQyxJQUFOOztRQUNBLE9BQU9zUSxNQUFNLEdBQUdKLGtCQUFrQixDQUFDclMsR0FBRCxDQUFsQyxFQUF5QztVQUN2QyxJQUFJd1EsT0FBTyxHQUFHaUMsTUFBTSxDQUFDLytDLElBQVAsQ0FBWSxDQUFaLEVBQWUsSUFBZixDQUFkO1VBQ0EzUyxHQUFHLElBQUlpL0MsR0FBRyxDQUFDcE8sSUFBSixDQUFTcCtDLE1BQVQsR0FBa0JnOUQsT0FBTyxDQUFDN2dELElBQVIsQ0FBYTBJLEVBQXRDO1VBQ0EybkMsR0FBRyxHQUFHd1EsT0FBTyxDQUFDcjlDLEVBQVIsQ0FBV2d2QyxJQUFqQjtVQUNBcGhELEdBQUcsSUFBSWkvQyxHQUFHLENBQUNwTyxJQUFKLENBQVNwK0MsTUFBVCxHQUFrQmc5RCxPQUFPLENBQUNyOUMsRUFBUixDQUFXa0YsRUFBcEM7OztRQUVGLE9BQU90WCxHQUFQO09Bcm5EaUI7OztNQXluRG5CLFNBQVN3eUQsV0FBVCxDQUFxQnhRLEVBQXJCLEVBQXlCO1FBQ3ZCLElBQUlwMEMsQ0FBQyxHQUFHbzBDLEVBQUUsQ0FBQy9vRCxPQUFYO1lBQW9CaXZELEdBQUcsR0FBR2xHLEVBQUUsQ0FBQ2tHLEdBQTdCO1FBQ0F0NkMsQ0FBQyxDQUFDNmtELE9BQUYsR0FBWXhLLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNQSxHQUFHLENBQUN2bEQsS0FBVixDQUFuQjtRQUNBaUwsQ0FBQyxDQUFDOGtELGFBQUYsR0FBa0JILFVBQVUsQ0FBQzNrRCxDQUFDLENBQUM2a0QsT0FBSCxDQUE1QjtRQUNBN2tELENBQUMsQ0FBQytrRCxjQUFGLEdBQW1CLElBQW5CO1FBQ0F6SyxHQUFHLENBQUNuNUMsSUFBSixDQUFTLFVBQVVxeUMsSUFBVixFQUFnQjtVQUN2QixJQUFJcGhELEdBQUcsR0FBR3V5RCxVQUFVLENBQUNuUixJQUFELENBQXBCOztVQUNBLElBQUlwaEQsR0FBRyxHQUFHNE4sQ0FBQyxDQUFDOGtELGFBQVosRUFBMkI7WUFDekI5a0QsQ0FBQyxDQUFDOGtELGFBQUYsR0FBa0IxeUQsR0FBbEI7WUFDQTROLENBQUMsQ0FBQzZrRCxPQUFGLEdBQVlyUixJQUFaOztTQUpKO09BOW5EaUI7Ozs7O01BMm9EbkIsSUFBSXdSLElBQUksR0FBRyxTQUFQQSxJQUFPLENBQVMvaEIsSUFBVCxFQUFleWQsV0FBZixFQUE0QnVFLGNBQTVCLEVBQTRDO1FBQ3JELEtBQUtoaUIsSUFBTCxHQUFZQSxJQUFaO1FBQ0EyZixpQkFBaUIsQ0FBQyxJQUFELEVBQU9sQyxXQUFQLENBQWpCO1FBQ0EsS0FBS3JnQixNQUFMLEdBQWM0a0IsY0FBYyxHQUFHQSxjQUFjLENBQUMsSUFBRCxDQUFqQixHQUEwQixDQUF0RDtPQUhGOztNQU1BRCxJQUFJLENBQUNyZ0UsU0FBTCxDQUFlcTJELE1BQWYsR0FBd0IsWUFBWTtRQUFFLE9BQU9BLE1BQU0sQ0FBQyxJQUFELENBQWI7T0FBdEM7O01BQ0FsRyxVQUFVLENBQUNrUSxJQUFELENBQVYsQ0FscERtQjs7OztNQXVwRG5CLFNBQVNFLFVBQVQsQ0FBb0IxUixJQUFwQixFQUEwQnZRLElBQTFCLEVBQWdDeWQsV0FBaEMsRUFBNkN1RSxjQUE3QyxFQUE2RDtRQUMzRHpSLElBQUksQ0FBQ3ZRLElBQUwsR0FBWUEsSUFBWjs7UUFDQSxJQUFJdVEsSUFBSSxDQUFDd0ssVUFBVCxFQUFxQjtVQUFFeEssSUFBSSxDQUFDd0ssVUFBTCxHQUFrQixJQUFsQjs7O1FBQ3ZCLElBQUl4SyxJQUFJLENBQUM3YixNQUFULEVBQWlCO1VBQUU2YixJQUFJLENBQUM3YixNQUFMLEdBQWMsSUFBZDs7O1FBQ25CLElBQUk2YixJQUFJLENBQUN4QyxLQUFMLElBQWMsSUFBbEIsRUFBd0I7VUFBRXdDLElBQUksQ0FBQ3hDLEtBQUwsR0FBYSxJQUFiOzs7UUFDMUIwUixpQkFBaUIsQ0FBQ2xQLElBQUQsQ0FBakI7UUFDQW9QLGlCQUFpQixDQUFDcFAsSUFBRCxFQUFPa04sV0FBUCxDQUFqQjtRQUNBLElBQUl5RSxTQUFTLEdBQUdGLGNBQWMsR0FBR0EsY0FBYyxDQUFDelIsSUFBRCxDQUFqQixHQUEwQixDQUF4RDs7UUFDQSxJQUFJMlIsU0FBUyxJQUFJM1IsSUFBSSxDQUFDblQsTUFBdEIsRUFBOEI7VUFBRXlhLGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPMlIsU0FBUCxDQUFoQjs7T0EvcERmOzs7TUFtcURuQixTQUFTQyxXQUFULENBQXFCNVIsSUFBckIsRUFBMkI7UUFDekJBLElBQUksQ0FBQzNsQyxNQUFMLEdBQWMsSUFBZDtRQUNBNjBDLGlCQUFpQixDQUFDbFAsSUFBRCxDQUFqQjtPQXJxRGlCOzs7OztNQTJxRG5CLElBQUk2UixpQkFBaUIsR0FBRyxFQUF4QjtVQUE0QkMseUJBQXlCLEdBQUcsRUFBeEQ7O01BQ0EsU0FBU0MsbUJBQVQsQ0FBNkJuNkQsS0FBN0IsRUFBb0MrakMsT0FBcEMsRUFBNkM7UUFDM0MsSUFBSSxDQUFDL2pDLEtBQUQsSUFBVSxRQUFRcUcsSUFBUixDQUFhckcsS0FBYixDQUFkLEVBQW1DO1VBQUUsT0FBTyxJQUFQOzs7UUFDckMsSUFBSW82RCxLQUFLLEdBQUdyMkIsT0FBTyxDQUFDcXdCLFlBQVIsR0FBdUI4Rix5QkFBdkIsR0FBbURELGlCQUEvRDtRQUNBLE9BQU9HLEtBQUssQ0FBQ3A2RCxLQUFELENBQUwsS0FDSm82RCxLQUFLLENBQUNwNkQsS0FBRCxDQUFMLEdBQWVBLEtBQUssQ0FBQ3dJLE9BQU4sQ0FBYyxNQUFkLEVBQXNCLE9BQXRCLENBRFgsQ0FBUDtPQS9xRGlCOzs7Ozs7O01Bd3JEbkIsU0FBUzZ4RCxnQkFBVCxDQUEwQnJSLEVBQTFCLEVBQThCc1IsUUFBOUIsRUFBd0M7Ozs7UUFJdEMsSUFBSTkwQixPQUFPLEdBQUdnYyxJQUFJLENBQUMsTUFBRCxFQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCM0IsTUFBTSxHQUFHLHFCQUFILEdBQTJCLElBQXRELENBQWxCO1FBQ0EsSUFBSTBhLE9BQU8sR0FBRztVQUFDQyxHQUFHLEVBQUVoWixJQUFJLENBQUMsS0FBRCxFQUFRLENBQUNoYyxPQUFELENBQVIsRUFBbUIsaUJBQW5CLENBQVY7VUFBaURBLE9BQU8sRUFBRUEsT0FBMUQ7VUFDQzJlLEdBQUcsRUFBRSxDQUROO1VBQ1N4MEMsR0FBRyxFQUFFLENBRGQ7VUFDaUJxNUMsRUFBRSxFQUFFQSxFQURyQjtVQUVDeVIsYUFBYSxFQUFFLEtBRmhCO1VBR0NDLFdBQVcsRUFBRTFSLEVBQUUsQ0FBQzJSLFNBQUgsQ0FBYSxjQUFiO1NBSDVCO1FBSUFMLFFBQVEsQ0FBQzlQLE9BQVQsR0FBbUIsRUFBbkIsQ0FUc0M7O1FBWXRDLEtBQUssSUFBSTN1RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxLQUFLeStELFFBQVEsQ0FBQ00sSUFBVCxHQUFnQk4sUUFBUSxDQUFDTSxJQUFULENBQWNuaEUsTUFBOUIsR0FBdUMsQ0FBNUMsQ0FBakIsRUFBaUVvQyxDQUFDLEVBQWxFLEVBQXNFO1VBQ3BFLElBQUl1c0QsSUFBSSxHQUFHdnNELENBQUMsR0FBR3krRCxRQUFRLENBQUNNLElBQVQsQ0FBYy8rRCxDQUFDLEdBQUcsQ0FBbEIsQ0FBSCxHQUEwQnkrRCxRQUFRLENBQUNsUyxJQUEvQztjQUFxRHhDLEtBQUssR0FBSSxLQUFLLENBQW5FO1VBQ0EyVSxPQUFPLENBQUM1cUQsR0FBUixHQUFjLENBQWQ7VUFDQTRxRCxPQUFPLENBQUNNLFFBQVIsR0FBbUJDLFVBQW5CLENBSG9FOzs7VUFNcEUsSUFBSWxRLGVBQWUsQ0FBQzVCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1cUQsT0FBWixDQUFmLEtBQXdDNUUsS0FBSyxHQUFHdUMsUUFBUSxDQUFDQyxJQUFELEVBQU9ZLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3RJLFNBQWQsQ0FBeEQsQ0FBSixFQUNFO1lBQUUyVCxPQUFPLENBQUNNLFFBQVIsR0FBbUJFLGlCQUFpQixDQUFDUixPQUFPLENBQUNNLFFBQVQsRUFBbUJqVixLQUFuQixDQUFwQzs7O1VBQ0oyVSxPQUFPLENBQUNwaUQsR0FBUixHQUFjLEVBQWQ7VUFDQSxJQUFJNmlELG1CQUFtQixHQUFHVixRQUFRLElBQUl0UixFQUFFLENBQUMvb0QsT0FBSCxDQUFXZzdELGdCQUF2QixJQUEyQ3JMLE1BQU0sQ0FBQ3hILElBQUQsQ0FBM0U7VUFDQThTLGlCQUFpQixDQUFDOVMsSUFBRCxFQUFPbVMsT0FBUCxFQUFnQmhJLGFBQWEsQ0FBQ3ZKLEVBQUQsRUFBS1osSUFBTCxFQUFXNFMsbUJBQVgsQ0FBN0IsQ0FBakI7O1VBQ0EsSUFBSTVTLElBQUksQ0FBQ3lLLFlBQVQsRUFBdUI7WUFDckIsSUFBSXpLLElBQUksQ0FBQ3lLLFlBQUwsQ0FBa0JSLE9BQXRCLEVBQ0U7Y0FBRWtJLE9BQU8sQ0FBQ2xJLE9BQVIsR0FBa0IvUCxXQUFXLENBQUM4RixJQUFJLENBQUN5SyxZQUFMLENBQWtCUixPQUFuQixFQUE0QmtJLE9BQU8sQ0FBQ2xJLE9BQVIsSUFBbUIsRUFBL0MsQ0FBN0I7OztZQUNKLElBQUlqSyxJQUFJLENBQUN5SyxZQUFMLENBQWtCUCxTQUF0QixFQUNFO2NBQUVpSSxPQUFPLENBQUNqSSxTQUFSLEdBQW9CaFEsV0FBVyxDQUFDOEYsSUFBSSxDQUFDeUssWUFBTCxDQUFrQlAsU0FBbkIsRUFBOEJpSSxPQUFPLENBQUNqSSxTQUFSLElBQXFCLEVBQW5ELENBQS9COztXQWY4RDs7O1VBbUJwRSxJQUFJaUksT0FBTyxDQUFDcGlELEdBQVIsQ0FBWTFlLE1BQVosSUFBc0IsQ0FBMUIsRUFDRTtZQUFFOGdFLE9BQU8sQ0FBQ3BpRCxHQUFSLENBQVkzZixJQUFaLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCK2hFLE9BQU8sQ0FBQy8wQixPQUFSLENBQWdCdGxDLFdBQWhCLENBQTRCcXFELGdCQUFnQixDQUFDdkIsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VxRCxPQUFaLENBQTVDLENBQXZCO1dBcEJnRTs7O1VBdUJwRSxJQUFJM3VELENBQUMsSUFBSSxDQUFULEVBQVk7WUFDVnkrRCxRQUFRLENBQUM5UCxPQUFULENBQWlCcnlDLEdBQWpCLEdBQXVCb2lELE9BQU8sQ0FBQ3BpRCxHQUEvQjtZQUNBbWlELFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUI0UCxLQUFqQixHQUF5QixFQUF6QjtXQUZGLE1BR087WUFDWCxDQUFDRSxRQUFRLENBQUM5UCxPQUFULENBQWlCMlEsSUFBakIsS0FBMEJiLFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUIyUSxJQUFqQixHQUF3QixFQUFsRCxDQUFELEVBQXdEM2lFLElBQXhELENBQTZEK2hFLE9BQU8sQ0FBQ3BpRCxHQUFyRTtZQUNPLENBQUNtaUQsUUFBUSxDQUFDOVAsT0FBVCxDQUFpQjRRLE1BQWpCLEtBQTRCZCxRQUFRLENBQUM5UCxPQUFULENBQWlCNFEsTUFBakIsR0FBMEIsRUFBdEQsQ0FBRCxFQUE0RDVpRSxJQUE1RCxDQUFpRSxFQUFqRTs7U0F4Q2lDOzs7UUE2Q3RDLElBQUlxbkQsTUFBSixFQUFZO1VBQ1YsSUFBSXY5QixJQUFJLEdBQUdpNEMsT0FBTyxDQUFDLzBCLE9BQVIsQ0FBZ0I2MUIsU0FBM0I7O1VBQ0EsSUFBSSxhQUFhaDFELElBQWIsQ0FBa0JpYyxJQUFJLENBQUM2K0IsU0FBdkIsS0FBc0M3K0IsSUFBSSxDQUFDbTdCLGFBQUwsSUFBc0JuN0IsSUFBSSxDQUFDbTdCLGFBQUwsQ0FBbUIsU0FBbkIsQ0FBaEUsRUFDRTtZQUFFOGMsT0FBTyxDQUFDLzBCLE9BQVIsQ0FBZ0IyYixTQUFoQixHQUE0QixrQkFBNUI7Ozs7UUFHTjBILE1BQU0sQ0FBQ0csRUFBRCxFQUFLLFlBQUwsRUFBbUJBLEVBQW5CLEVBQXVCc1IsUUFBUSxDQUFDbFMsSUFBaEMsRUFBc0NtUyxPQUFPLENBQUNDLEdBQTlDLENBQU47O1FBQ0EsSUFBSUQsT0FBTyxDQUFDQyxHQUFSLENBQVlyWixTQUFoQixFQUNFO1VBQUVvWixPQUFPLENBQUNqSSxTQUFSLEdBQW9CaFEsV0FBVyxDQUFDaVksT0FBTyxDQUFDQyxHQUFSLENBQVlyWixTQUFiLEVBQXdCb1osT0FBTyxDQUFDakksU0FBUixJQUFxQixFQUE3QyxDQUEvQjs7O1FBRUosT0FBT2lJLE9BQVA7OztNQUdGLFNBQVNlLDZCQUFULENBQXVDaDlDLEVBQXZDLEVBQTJDO1FBQ3pDLElBQUlvMUMsS0FBSyxHQUFHblMsR0FBRyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLGdCQUFuQixDQUFmO1FBQ0FtUyxLQUFLLENBQUM2SCxLQUFOLEdBQWMsUUFBUWo5QyxFQUFFLENBQUMxVSxVQUFILENBQWMsQ0FBZCxFQUFpQjVTLFFBQWpCLENBQTBCLEVBQTFCLENBQXRCO1FBQ0EwOEQsS0FBSyxDQUFDcnBCLFlBQU4sQ0FBbUIsWUFBbkIsRUFBaUNxcEIsS0FBSyxDQUFDNkgsS0FBdkM7UUFDQSxPQUFPN0gsS0FBUDtPQXR2RGlCOzs7O01BMnZEbkIsU0FBU29ILFVBQVQsQ0FBb0JQLE9BQXBCLEVBQTZCMWlCLElBQTdCLEVBQW1DNzNDLEtBQW5DLEVBQTBDdzdELFVBQTFDLEVBQXNEQyxRQUF0RCxFQUFnRXR2QixHQUFoRSxFQUFxRW5WLFVBQXJFLEVBQWlGO1FBQy9FLElBQUksQ0FBQzZnQixJQUFMLEVBQVc7VUFBRTs7O1FBQ2IsSUFBSTZqQixXQUFXLEdBQUduQixPQUFPLENBQUNHLFdBQVIsR0FBc0JBLFdBQVcsQ0FBQzdpQixJQUFELEVBQU8waUIsT0FBTyxDQUFDRSxhQUFmLENBQWpDLEdBQWlFNWlCLElBQW5GO1FBQ0EsSUFBSThqQixPQUFPLEdBQUdwQixPQUFPLENBQUN2UixFQUFSLENBQVc5cEIsS0FBWCxDQUFpQjA4QixZQUEvQjtZQUE2Q0MsUUFBUSxHQUFHLEtBQXhEO1FBQ0EsSUFBSXIyQixPQUFKOztRQUNBLElBQUksQ0FBQ20yQixPQUFPLENBQUN0MUQsSUFBUixDQUFhd3hDLElBQWIsQ0FBTCxFQUF5QjtVQUN2QjBpQixPQUFPLENBQUNwVyxHQUFSLElBQWV0TSxJQUFJLENBQUNwK0MsTUFBcEI7VUFDQStyQyxPQUFPLEdBQUdodkMsUUFBUSxDQUFDeXNCLGNBQVQsQ0FBd0J5NEMsV0FBeEIsQ0FBVjtVQUNBbkIsT0FBTyxDQUFDcGlELEdBQVIsQ0FBWTNmLElBQVosQ0FBaUIraEUsT0FBTyxDQUFDNXFELEdBQXpCLEVBQThCNHFELE9BQU8sQ0FBQzVxRCxHQUFSLEdBQWNrb0MsSUFBSSxDQUFDcCtDLE1BQWpELEVBQXlEK3JDLE9BQXpEOztVQUNBLElBQUlrYSxFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtZQUFFa2MsUUFBUSxHQUFHLElBQVg7OztVQUM1QnRCLE9BQU8sQ0FBQzVxRCxHQUFSLElBQWVrb0MsSUFBSSxDQUFDcCtDLE1BQXBCO1NBTEYsTUFNTztVQUNMK3JDLE9BQU8sR0FBR2h2QyxRQUFRLENBQUNzbEUsc0JBQVQsRUFBVjtVQUNBLElBQUluc0QsR0FBRyxHQUFHLENBQVY7O1VBQ0EsT0FBTyxJQUFQLEVBQWE7WUFDWGdzRCxPQUFPLENBQUN2Z0QsU0FBUixHQUFvQnpMLEdBQXBCO1lBQ0EsSUFBSS9ELENBQUMsR0FBRyt2RCxPQUFPLENBQUMvbEUsSUFBUixDQUFhaWlELElBQWIsQ0FBUjtZQUNBLElBQUl1TSxPQUFPLEdBQUd4NEMsQ0FBQyxHQUFHQSxDQUFDLENBQUMvTixLQUFGLEdBQVU4UixHQUFiLEdBQW1Ca29DLElBQUksQ0FBQ3ArQyxNQUFMLEdBQWNrVyxHQUFoRDs7WUFDQSxJQUFJeTBDLE9BQUosRUFBYTtjQUNYLElBQUl5RyxHQUFHLEdBQUdyMEQsUUFBUSxDQUFDeXNCLGNBQVQsQ0FBd0J5NEMsV0FBVyxDQUFDeCtELEtBQVosQ0FBa0J5UyxHQUFsQixFQUF1QkEsR0FBRyxHQUFHeTBDLE9BQTdCLENBQXhCLENBQVY7O2NBQ0EsSUFBSTFFLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO2dCQUFFbmEsT0FBTyxDQUFDdGxDLFdBQVIsQ0FBb0JxaEQsR0FBRyxDQUFDLE1BQUQsRUFBUyxDQUFDc0osR0FBRCxDQUFULENBQXZCO2VBQTVCLE1BQ0s7Z0JBQUVybEIsT0FBTyxDQUFDdGxDLFdBQVIsQ0FBb0IycUQsR0FBcEI7OztjQUNQMFAsT0FBTyxDQUFDcGlELEdBQVIsQ0FBWTNmLElBQVosQ0FBaUIraEUsT0FBTyxDQUFDNXFELEdBQXpCLEVBQThCNHFELE9BQU8sQ0FBQzVxRCxHQUFSLEdBQWN5MEMsT0FBNUMsRUFBcUR5RyxHQUFyRDtjQUNBMFAsT0FBTyxDQUFDcFcsR0FBUixJQUFlQyxPQUFmO2NBQ0FtVyxPQUFPLENBQUM1cUQsR0FBUixJQUFleTBDLE9BQWY7OztZQUVGLElBQUksQ0FBQ3g0QyxDQUFMLEVBQVE7Y0FBRTs7O1lBQ1YrRCxHQUFHLElBQUl5MEMsT0FBTyxHQUFHLENBQWpCO1lBQ0EsSUFBSTJYLEtBQUssR0FBSSxLQUFLLENBQWxCOztZQUNBLElBQUlud0QsQ0FBQyxDQUFDLENBQUQsQ0FBRCxJQUFRLElBQVosRUFBa0I7Y0FDaEIsSUFBSXEzQyxPQUFPLEdBQUdzWCxPQUFPLENBQUN2UixFQUFSLENBQVdqbEIsT0FBWCxDQUFtQmtmLE9BQWpDO2tCQUEwQytZLFFBQVEsR0FBRy9ZLE9BQU8sR0FBR3NYLE9BQU8sQ0FBQ3BXLEdBQVIsR0FBY2xCLE9BQTdFO2NBQ0E4WSxLQUFLLEdBQUd2MkIsT0FBTyxDQUFDdGxDLFdBQVIsQ0FBb0JxaEQsR0FBRyxDQUFDLE1BQUQsRUFBUytDLFFBQVEsQ0FBQzBYLFFBQUQsQ0FBakIsRUFBNkIsUUFBN0IsQ0FBdkIsQ0FBUjtjQUNBRCxLQUFLLENBQUMxeEIsWUFBTixDQUFtQixNQUFuQixFQUEyQixjQUEzQjtjQUNBMHhCLEtBQUssQ0FBQzF4QixZQUFOLENBQW1CLFNBQW5CLEVBQThCLElBQTlCO2NBQ0Frd0IsT0FBTyxDQUFDcFcsR0FBUixJQUFlNlgsUUFBZjthQUxGLE1BTU8sSUFBSXB3RCxDQUFDLENBQUMsQ0FBRCxDQUFELElBQVEsSUFBUixJQUFnQkEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxJQUFRLElBQTVCLEVBQWtDO2NBQ3ZDbXdELEtBQUssR0FBR3YyQixPQUFPLENBQUN0bEMsV0FBUixDQUFvQnFoRCxHQUFHLENBQUMsTUFBRCxFQUFTMzFDLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUSxJQUFSLEdBQWUsUUFBZixHQUEwQixRQUFuQyxFQUE2QyxnQkFBN0MsQ0FBdkIsQ0FBUjtjQUNBbXdELEtBQUssQ0FBQzF4QixZQUFOLENBQW1CLFNBQW5CLEVBQThCeitCLENBQUMsQ0FBQyxDQUFELENBQS9CO2NBQ0EydUQsT0FBTyxDQUFDcFcsR0FBUixJQUFlLENBQWY7YUFISyxNQUlBO2NBQ0w0WCxLQUFLLEdBQUd4QixPQUFPLENBQUN2UixFQUFSLENBQVdqbEIsT0FBWCxDQUFtQms0QixzQkFBbkIsQ0FBMENyd0QsQ0FBQyxDQUFDLENBQUQsQ0FBM0MsQ0FBUjtjQUNBbXdELEtBQUssQ0FBQzF4QixZQUFOLENBQW1CLFNBQW5CLEVBQThCeitCLENBQUMsQ0FBQyxDQUFELENBQS9COztjQUNBLElBQUk4ekMsRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBdkIsRUFBMEI7Z0JBQUVuYSxPQUFPLENBQUN0bEMsV0FBUixDQUFvQnFoRCxHQUFHLENBQUMsTUFBRCxFQUFTLENBQUN3YSxLQUFELENBQVQsQ0FBdkI7ZUFBNUIsTUFDSztnQkFBRXYyQixPQUFPLENBQUN0bEMsV0FBUixDQUFvQjY3RCxLQUFwQjs7O2NBQ1B4QixPQUFPLENBQUNwVyxHQUFSLElBQWUsQ0FBZjs7O1lBRUZvVyxPQUFPLENBQUNwaUQsR0FBUixDQUFZM2YsSUFBWixDQUFpQitoRSxPQUFPLENBQUM1cUQsR0FBekIsRUFBOEI0cUQsT0FBTyxDQUFDNXFELEdBQVIsR0FBYyxDQUE1QyxFQUErQ29zRCxLQUEvQztZQUNBeEIsT0FBTyxDQUFDNXFELEdBQVI7Ozs7UUFHSjRxRCxPQUFPLENBQUNFLGFBQVIsR0FBd0JpQixXQUFXLENBQUM5eEQsVUFBWixDQUF1Qml1QyxJQUFJLENBQUNwK0MsTUFBTCxHQUFjLENBQXJDLEtBQTJDLEVBQW5FOztRQUNBLElBQUl1RyxLQUFLLElBQUl3N0QsVUFBVCxJQUF1QkMsUUFBdkIsSUFBbUNJLFFBQW5DLElBQStDMXZCLEdBQS9DLElBQXNEblYsVUFBMUQsRUFBc0U7VUFDcEUsSUFBSWtsQyxTQUFTLEdBQUdsOEQsS0FBSyxJQUFJLEVBQXpCOztVQUNBLElBQUl3N0QsVUFBSixFQUFnQjtZQUFFVSxTQUFTLElBQUlWLFVBQWI7OztVQUNsQixJQUFJQyxRQUFKLEVBQWM7WUFBRVMsU0FBUyxJQUFJVCxRQUFiOzs7VUFDaEIsSUFBSS9ILEtBQUssR0FBR25TLEdBQUcsQ0FBQyxNQUFELEVBQVMsQ0FBQy9iLE9BQUQsQ0FBVCxFQUFvQjAyQixTQUFwQixFQUErQi92QixHQUEvQixDQUFmOztVQUNBLElBQUluVixVQUFKLEVBQWdCO1lBQ2QsS0FBSyxJQUFJMlksSUFBVCxJQUFpQjNZLFVBQWpCLEVBQTZCO2NBQUUsSUFBSUEsVUFBVSxDQUFDeGhDLGNBQVgsQ0FBMEJtNkMsSUFBMUIsS0FBbUNBLElBQUksSUFBSSxPQUEzQyxJQUFzREEsSUFBSSxJQUFJLE9BQWxFLEVBQzdCO2dCQUFFK2pCLEtBQUssQ0FBQ3JwQixZQUFOLENBQW1Cc0YsSUFBbkIsRUFBeUIzWSxVQUFVLENBQUMyWSxJQUFELENBQW5DOzs7OztVQUVOLE9BQU80cUIsT0FBTyxDQUFDLzBCLE9BQVIsQ0FBZ0J0bEMsV0FBaEIsQ0FBNEJ3ekQsS0FBNUIsQ0FBUDs7O1FBRUY2RyxPQUFPLENBQUMvMEIsT0FBUixDQUFnQnRsQyxXQUFoQixDQUE0QnNsQyxPQUE1QjtPQXp6RGlCOzs7O01BOHpEbkIsU0FBU2sxQixXQUFULENBQXFCN2lCLElBQXJCLEVBQTJCc2tCLGNBQTNCLEVBQTJDO1FBQ3pDLElBQUl0a0IsSUFBSSxDQUFDcCtDLE1BQUwsR0FBYyxDQUFkLElBQW1CLENBQUMsS0FBSzRNLElBQUwsQ0FBVXd4QyxJQUFWLENBQXhCLEVBQXlDO1VBQUUsT0FBT0EsSUFBUDs7O1FBQzNDLElBQUl1a0IsV0FBVyxHQUFHRCxjQUFsQjtZQUFrQzE5RCxNQUFNLEdBQUcsRUFBM0M7O1FBQ0EsS0FBSyxJQUFJNUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2c4QyxJQUFJLENBQUNwK0MsTUFBekIsRUFBaUNvQyxDQUFDLEVBQWxDLEVBQXNDO1VBQ3BDLElBQUl5aUIsRUFBRSxHQUFHdTVCLElBQUksQ0FBQzc2QyxNQUFMLENBQVluQixDQUFaLENBQVQ7O1VBQ0EsSUFBSXlpQixFQUFFLElBQUksR0FBTixJQUFhODlDLFdBQWIsS0FBNkJ2Z0UsQ0FBQyxJQUFJZzhDLElBQUksQ0FBQ3ArQyxNQUFMLEdBQWMsQ0FBbkIsSUFBd0JvK0MsSUFBSSxDQUFDanVDLFVBQUwsQ0FBZ0IvTixDQUFDLEdBQUcsQ0FBcEIsS0FBMEIsRUFBL0UsQ0FBSixFQUNFO1lBQUV5aUIsRUFBRSxHQUFHLFFBQUw7OztVQUNKN2YsTUFBTSxJQUFJNmYsRUFBVjtVQUNBODlDLFdBQVcsR0FBRzk5QyxFQUFFLElBQUksR0FBcEI7OztRQUVGLE9BQU83ZixNQUFQO09BeDBEaUI7Ozs7TUE2MERuQixTQUFTczhELGlCQUFULENBQTJCbE0sS0FBM0IsRUFBa0NqSixLQUFsQyxFQUF5QztRQUN2QyxPQUFPLFVBQVUyVSxPQUFWLEVBQW1CMWlCLElBQW5CLEVBQXlCNzNDLEtBQXpCLEVBQWdDdzdELFVBQWhDLEVBQTRDQyxRQUE1QyxFQUFzRHR2QixHQUF0RCxFQUEyRG5WLFVBQTNELEVBQXVFO1VBQzVFaDNCLEtBQUssR0FBR0EsS0FBSyxHQUFHQSxLQUFLLEdBQUcsa0JBQVgsR0FBZ0MsaUJBQTdDO1VBQ0EsSUFBSStXLEtBQUssR0FBR3dqRCxPQUFPLENBQUM1cUQsR0FBcEI7Y0FBeUIyQyxHQUFHLEdBQUd5RSxLQUFLLEdBQUc4Z0MsSUFBSSxDQUFDcCtDLE1BQTVDOztVQUNBLFNBQVM7O1lBRVAsSUFBSXlxQyxJQUFJLEdBQUksS0FBSyxDQUFqQjs7WUFDQSxLQUFLLElBQUlyb0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytwRCxLQUFLLENBQUNuc0QsTUFBMUIsRUFBa0NvQyxDQUFDLEVBQW5DLEVBQXVDO2NBQ3JDcW9DLElBQUksR0FBRzBoQixLQUFLLENBQUMvcEQsQ0FBRCxDQUFaOztjQUNBLElBQUlxb0MsSUFBSSxDQUFDOXFCLEVBQUwsR0FBVXJDLEtBQVYsSUFBbUJtdEIsSUFBSSxDQUFDdHVCLElBQUwsSUFBYW1CLEtBQXBDLEVBQTJDO2dCQUFFOzs7O1lBRS9DLElBQUltdEIsSUFBSSxDQUFDOXFCLEVBQUwsSUFBVzlHLEdBQWYsRUFBb0I7Y0FBRSxPQUFPdThDLEtBQUssQ0FBQzBMLE9BQUQsRUFBVTFpQixJQUFWLEVBQWdCNzNDLEtBQWhCLEVBQXVCdzdELFVBQXZCLEVBQW1DQyxRQUFuQyxFQUE2Q3R2QixHQUE3QyxFQUFrRG5WLFVBQWxELENBQVo7OztZQUN0QjYzQixLQUFLLENBQUMwTCxPQUFELEVBQVUxaUIsSUFBSSxDQUFDMzZDLEtBQUwsQ0FBVyxDQUFYLEVBQWNnbkMsSUFBSSxDQUFDOXFCLEVBQUwsR0FBVXJDLEtBQXhCLENBQVYsRUFBMEMvVyxLQUExQyxFQUFpRHc3RCxVQUFqRCxFQUE2RCxJQUE3RCxFQUFtRXJ2QixHQUFuRSxFQUF3RW5WLFVBQXhFLENBQUw7WUFDQXdrQyxVQUFVLEdBQUcsSUFBYjtZQUNBM2pCLElBQUksR0FBR0EsSUFBSSxDQUFDMzZDLEtBQUwsQ0FBV2duQyxJQUFJLENBQUM5cUIsRUFBTCxHQUFVckMsS0FBckIsQ0FBUDtZQUNBQSxLQUFLLEdBQUdtdEIsSUFBSSxDQUFDOXFCLEVBQWI7O1NBZEo7OztNQW1CRixTQUFTaWpELGtCQUFULENBQTRCOUIsT0FBNUIsRUFBcUM1bUQsSUFBckMsRUFBMkM2dUIsTUFBM0MsRUFBbUQ4NUIsWUFBbkQsRUFBaUU7UUFDL0QsSUFBSUMsTUFBTSxHQUFHLENBQUNELFlBQUQsSUFBaUI5NUIsTUFBTSxDQUFDMjJCLFVBQXJDOztRQUNBLElBQUlvRCxNQUFKLEVBQVk7VUFBRWhDLE9BQU8sQ0FBQ3BpRCxHQUFSLENBQVkzZixJQUFaLENBQWlCK2hFLE9BQU8sQ0FBQzVxRCxHQUF6QixFQUE4QjRxRCxPQUFPLENBQUM1cUQsR0FBUixHQUFjZ0UsSUFBNUMsRUFBa0Q0b0QsTUFBbEQ7OztRQUNkLElBQUksQ0FBQ0QsWUFBRCxJQUFpQi9CLE9BQU8sQ0FBQ3ZSLEVBQVIsQ0FBVy9vRCxPQUFYLENBQW1CdThELEtBQW5CLENBQXlCQyxxQkFBOUMsRUFBcUU7VUFDbkUsSUFBSSxDQUFDRixNQUFMLEVBQ0U7WUFBRUEsTUFBTSxHQUFHaEMsT0FBTyxDQUFDLzBCLE9BQVIsQ0FBZ0J0bEMsV0FBaEIsQ0FBNEIxSixRQUFRLENBQUNFLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBNUIsQ0FBVDs7O1VBQ0o2bEUsTUFBTSxDQUFDbHlCLFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUM3SCxNQUFNLENBQUN2cUMsRUFBeEM7OztRQUVGLElBQUlza0UsTUFBSixFQUFZO1VBQ1ZoQyxPQUFPLENBQUN2UixFQUFSLENBQVcvb0QsT0FBWCxDQUFtQnU4RCxLQUFuQixDQUF5QkUsYUFBekIsQ0FBdUNILE1BQXZDO1VBQ0FoQyxPQUFPLENBQUMvMEIsT0FBUixDQUFnQnRsQyxXQUFoQixDQUE0QnE4RCxNQUE1Qjs7O1FBRUZoQyxPQUFPLENBQUM1cUQsR0FBUixJQUFlZ0UsSUFBZjtRQUNBNG1ELE9BQU8sQ0FBQ0UsYUFBUixHQUF3QixLQUF4QjtPQTkyRGlCOzs7O01BbTNEbkIsU0FBU1MsaUJBQVQsQ0FBMkI5UyxJQUEzQixFQUFpQ21TLE9BQWpDLEVBQTBDaHVCLE1BQTFDLEVBQWtEO1FBQ2hELElBQUl5b0IsS0FBSyxHQUFHNU0sSUFBSSxDQUFDa04sV0FBakI7WUFBOEJxSCxPQUFPLEdBQUd2VSxJQUFJLENBQUN2USxJQUE3QztZQUFtRG44QixFQUFFLEdBQUcsQ0FBeEQ7O1FBQ0EsSUFBSSxDQUFDczVDLEtBQUwsRUFBWTtVQUNWLEtBQUssSUFBSWpPLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd4YSxNQUFNLENBQUM5eUMsTUFBL0IsRUFBdUNzdEQsR0FBRyxJQUFFLENBQTVDLEVBQ0U7WUFBRXdULE9BQU8sQ0FBQ00sUUFBUixDQUFpQk4sT0FBakIsRUFBMEJvQyxPQUFPLENBQUN6L0QsS0FBUixDQUFjd2UsRUFBZCxFQUFrQkEsRUFBRSxHQUFHNndCLE1BQU0sQ0FBQ3dhLEdBQUQsQ0FBN0IsQ0FBMUIsRUFBK0RvVCxtQkFBbUIsQ0FBQzV0QixNQUFNLENBQUN3YSxHQUFHLEdBQUMsQ0FBTCxDQUFQLEVBQWdCd1QsT0FBTyxDQUFDdlIsRUFBUixDQUFXamxCLE9BQTNCLENBQWxGOzs7VUFDSjs7O1FBR0YsSUFBSS84QixHQUFHLEdBQUcyMUQsT0FBTyxDQUFDbGpFLE1BQWxCO1lBQTBCa1csR0FBRyxHQUFHLENBQWhDO1lBQW1DOVQsQ0FBQyxHQUFHLENBQXZDO1lBQTBDZzhDLElBQUksR0FBRyxFQUFqRDtZQUFxRDczQyxLQUFyRDtZQUE0RG1zQyxHQUE1RDtRQUNBLElBQUl5d0IsVUFBVSxHQUFHLENBQWpCO1lBQW9CQyxTQUFwQjtZQUErQkMsWUFBL0I7WUFBNkNDLGNBQTdDO1lBQTZEM0UsU0FBN0Q7WUFBd0VwaEMsVUFBeEU7O1FBQ0EsU0FBUztVQUNQLElBQUk0bEMsVUFBVSxJQUFJanRELEdBQWxCLEVBQXVCOztZQUNyQmt0RCxTQUFTLEdBQUdDLFlBQVksR0FBR0MsY0FBYyxHQUFHNXdCLEdBQUcsR0FBRyxFQUFsRDtZQUNBblYsVUFBVSxHQUFHLElBQWI7WUFDQW9oQyxTQUFTLEdBQUcsSUFBWjtZQUFrQndFLFVBQVUsR0FBRzF6RCxRQUFiO1lBQ2xCLElBQUk4ekQsY0FBYyxHQUFHLEVBQXJCO2dCQUF5QkMsU0FBUyxHQUFJLEtBQUssQ0FBM0M7O1lBQ0EsS0FBSyxJQUFJcDVELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdteEQsS0FBSyxDQUFDdjdELE1BQTFCLEVBQWtDLEVBQUVvSyxDQUFwQyxFQUF1QztjQUNyQyxJQUFJczBELEVBQUUsR0FBR25ELEtBQUssQ0FBQ254RCxDQUFELENBQWQ7a0JBQW1CK0gsQ0FBQyxHQUFHdXNELEVBQUUsQ0FBQzMxQixNQUExQjs7Y0FDQSxJQUFJNTJCLENBQUMsQ0FBQzNSLElBQUYsSUFBVSxVQUFWLElBQXdCaytELEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVdqRyxHQUFuQyxJQUEwQy9ELENBQUMsQ0FBQ3V0RCxVQUFoRCxFQUE0RDtnQkFDMUQ2RCxjQUFjLENBQUN4a0UsSUFBZixDQUFvQm9ULENBQXBCO2VBREYsTUFFTyxJQUFJdXNELEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVdqRyxHQUFYLEtBQW1Cd29ELEVBQUUsQ0FBQy8rQyxFQUFILElBQVMsSUFBVCxJQUFpQisrQyxFQUFFLENBQUMvK0MsRUFBSCxHQUFRekosR0FBekIsSUFBZ0MvRCxDQUFDLENBQUN3c0QsU0FBRixJQUFlRCxFQUFFLENBQUMvK0MsRUFBSCxJQUFTekosR0FBeEIsSUFBK0J3b0QsRUFBRSxDQUFDdmlELElBQUgsSUFBV2pHLEdBQTdGLENBQUosRUFBdUc7Z0JBQzVHLElBQUl3b0QsRUFBRSxDQUFDLytDLEVBQUgsSUFBUyxJQUFULElBQWlCKytDLEVBQUUsQ0FBQy8rQyxFQUFILElBQVN6SixHQUExQixJQUFpQ2l0RCxVQUFVLEdBQUd6RSxFQUFFLENBQUMvK0MsRUFBckQsRUFBeUQ7a0JBQ3ZEd2pELFVBQVUsR0FBR3pFLEVBQUUsQ0FBQy8rQyxFQUFoQjtrQkFDQTBqRCxZQUFZLEdBQUcsRUFBZjs7O2dCQUVGLElBQUlseEQsQ0FBQyxDQUFDdTFDLFNBQU4sRUFBaUI7a0JBQUUwYixTQUFTLElBQUksTUFBTWp4RCxDQUFDLENBQUN1MUMsU0FBckI7OztnQkFDbkIsSUFBSXYxQyxDQUFDLENBQUN1Z0MsR0FBTixFQUFXO2tCQUFFQSxHQUFHLEdBQUcsQ0FBQ0EsR0FBRyxHQUFHQSxHQUFHLEdBQUcsR0FBVCxHQUFlLEVBQW5CLElBQXlCdmdDLENBQUMsQ0FBQ3VnQyxHQUFqQzs7O2dCQUNiLElBQUl2Z0MsQ0FBQyxDQUFDNHZELFVBQUYsSUFBZ0JyRCxFQUFFLENBQUN2aUQsSUFBSCxJQUFXakcsR0FBL0IsRUFBb0M7a0JBQUVvdEQsY0FBYyxJQUFJLE1BQU1ueEQsQ0FBQyxDQUFDNHZELFVBQTFCOzs7Z0JBQ3RDLElBQUk1dkQsQ0FBQyxDQUFDNnZELFFBQUYsSUFBY3RELEVBQUUsQ0FBQy8rQyxFQUFILElBQVN3akQsVUFBM0IsRUFBdUM7a0JBQUUsQ0FBQ0ssU0FBUyxLQUFLQSxTQUFTLEdBQUcsRUFBakIsQ0FBVixFQUFnQ3prRSxJQUFoQyxDQUFxQ29ULENBQUMsQ0FBQzZ2RCxRQUF2QyxFQUFpRHRELEVBQUUsQ0FBQy8rQyxFQUFwRDtpQkFSbUU7Ozs7Z0JBVzVHLElBQUl4TixDQUFDLENBQUMydkQsS0FBTixFQUFhO2tCQUFFLENBQUN2a0MsVUFBVSxLQUFLQSxVQUFVLEdBQUcsRUFBbEIsQ0FBWCxFQUFrQ3VrQyxLQUFsQyxHQUEwQzN2RCxDQUFDLENBQUMydkQsS0FBNUM7OztnQkFDZixJQUFJM3ZELENBQUMsQ0FBQ29yQixVQUFOLEVBQWtCO2tCQUNoQixLQUFLLElBQUkyWSxJQUFULElBQWlCL2pDLENBQUMsQ0FBQ29yQixVQUFuQixFQUNFO29CQUFFLENBQUNBLFVBQVUsS0FBS0EsVUFBVSxHQUFHLEVBQWxCLENBQVgsRUFBa0MyWSxJQUFsQyxJQUEwQy9qQyxDQUFDLENBQUNvckIsVUFBRixDQUFhMlksSUFBYixDQUExQzs7OztnQkFFTixJQUFJL2pDLENBQUMsQ0FBQ3dzRCxTQUFGLEtBQWdCLENBQUNBLFNBQUQsSUFBY1QsdUJBQXVCLENBQUNTLFNBQVMsQ0FBQzUxQixNQUFYLEVBQW1CNTJCLENBQW5CLENBQXZCLEdBQStDLENBQTdFLENBQUosRUFDRTtrQkFBRXdzRCxTQUFTLEdBQUdELEVBQVo7O2VBakJDLE1Ba0JBLElBQUlBLEVBQUUsQ0FBQ3ZpRCxJQUFILEdBQVVqRyxHQUFWLElBQWlCaXRELFVBQVUsR0FBR3pFLEVBQUUsQ0FBQ3ZpRCxJQUFyQyxFQUEyQztnQkFDaERnbkQsVUFBVSxHQUFHekUsRUFBRSxDQUFDdmlELElBQWhCOzs7O1lBR0osSUFBSXFuRCxTQUFKLEVBQWU7Y0FBRSxLQUFLLElBQUluVixHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHbVYsU0FBUyxDQUFDeGpFLE1BQWxDLEVBQTBDcXVELEdBQUcsSUFBSSxDQUFqRCxFQUNmO2dCQUFFLElBQUltVixTQUFTLENBQUNuVixHQUFHLEdBQUcsQ0FBUCxDQUFULElBQXNCOFUsVUFBMUIsRUFBc0M7a0JBQUVFLFlBQVksSUFBSSxNQUFNRyxTQUFTLENBQUNuVixHQUFELENBQS9COzs7OztZQUU1QyxJQUFJLENBQUNzUSxTQUFELElBQWNBLFNBQVMsQ0FBQ3hpRCxJQUFWLElBQWtCakcsR0FBcEMsRUFBeUM7Y0FBRSxLQUFLLElBQUlzNEMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRytVLGNBQWMsQ0FBQ3ZqRSxNQUF2QyxFQUErQyxFQUFFd3VELEdBQWpELEVBQ3pDO2dCQUFFb1Usa0JBQWtCLENBQUM5QixPQUFELEVBQVUsQ0FBVixFQUFheUMsY0FBYyxDQUFDL1UsR0FBRCxDQUEzQixDQUFsQjs7OztZQUNKLElBQUltUSxTQUFTLElBQUksQ0FBQ0EsU0FBUyxDQUFDeGlELElBQVYsSUFBa0IsQ0FBbkIsS0FBeUJqRyxHQUExQyxFQUErQztjQUM3QzBzRCxrQkFBa0IsQ0FBQzlCLE9BQUQsRUFBVSxDQUFDbkMsU0FBUyxDQUFDaC9DLEVBQVYsSUFBZ0IsSUFBaEIsR0FBdUJwUyxHQUFHLEdBQUcsQ0FBN0IsR0FBaUNveEQsU0FBUyxDQUFDaC9DLEVBQTVDLElBQWtEekosR0FBNUQsRUFDQ3lvRCxTQUFTLENBQUM1MUIsTUFEWCxFQUNtQjQxQixTQUFTLENBQUN4aUQsSUFBVixJQUFrQixJQURyQyxDQUFsQjs7Y0FFQSxJQUFJd2lELFNBQVMsQ0FBQ2gvQyxFQUFWLElBQWdCLElBQXBCLEVBQTBCO2dCQUFFOzs7Y0FDNUIsSUFBSWcvQyxTQUFTLENBQUNoL0MsRUFBVixJQUFnQnpKLEdBQXBCLEVBQXlCO2dCQUFFeW9ELFNBQVMsR0FBRyxLQUFaOzs7OztVQUcvQixJQUFJem9ELEdBQUcsSUFBSTNJLEdBQVgsRUFBZ0I7WUFBRTs7O1VBRWxCLElBQUlrMkQsSUFBSSxHQUFHOW5FLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3NKLEdBQVQsRUFBYzQxRCxVQUFkLENBQVg7O1VBQ0EsT0FBTyxJQUFQLEVBQWE7WUFDWCxJQUFJL2tCLElBQUosRUFBVTtjQUNSLElBQUl2bEMsR0FBRyxHQUFHM0MsR0FBRyxHQUFHa29DLElBQUksQ0FBQ3ArQyxNQUFyQjs7Y0FDQSxJQUFJLENBQUMyK0QsU0FBTCxFQUFnQjtnQkFDZCxJQUFJK0UsU0FBUyxHQUFHN3FELEdBQUcsR0FBRzRxRCxJQUFOLEdBQWFybEIsSUFBSSxDQUFDMzZDLEtBQUwsQ0FBVyxDQUFYLEVBQWNnZ0UsSUFBSSxHQUFHdnRELEdBQXJCLENBQWIsR0FBeUNrb0MsSUFBekQ7Z0JBQ0EwaUIsT0FBTyxDQUFDTSxRQUFSLENBQWlCTixPQUFqQixFQUEwQjRDLFNBQTFCLEVBQXFDbjlELEtBQUssR0FBR0EsS0FBSyxHQUFHNjhELFNBQVgsR0FBdUJBLFNBQWpFLEVBQ2lCRSxjQURqQixFQUNpQ3B0RCxHQUFHLEdBQUd3dEQsU0FBUyxDQUFDMWpFLE1BQWhCLElBQTBCbWpFLFVBQTFCLEdBQXVDRSxZQUF2QyxHQUFzRCxFQUR2RixFQUMyRjN3QixHQUQzRixFQUNnR25WLFVBRGhHOzs7Y0FHRixJQUFJMWtCLEdBQUcsSUFBSTRxRCxJQUFYLEVBQWlCO2dCQUFDcmxCLElBQUksR0FBR0EsSUFBSSxDQUFDMzZDLEtBQUwsQ0FBV2dnRSxJQUFJLEdBQUd2dEQsR0FBbEIsQ0FBUDtnQkFBK0JBLEdBQUcsR0FBR3V0RCxJQUFOO2dCQUFZOzs7Y0FDN0R2dEQsR0FBRyxHQUFHMkMsR0FBTjtjQUNBeXFELGNBQWMsR0FBRyxFQUFqQjs7O1lBRUZsbEIsSUFBSSxHQUFHOGtCLE9BQU8sQ0FBQ3ovRCxLQUFSLENBQWN3ZSxFQUFkLEVBQWtCQSxFQUFFLEdBQUc2d0IsTUFBTSxDQUFDMXdDLENBQUMsRUFBRixDQUE3QixDQUFQO1lBQ0FtRSxLQUFLLEdBQUdtNkQsbUJBQW1CLENBQUM1dEIsTUFBTSxDQUFDMXdDLENBQUMsRUFBRixDQUFQLEVBQWMwK0QsT0FBTyxDQUFDdlIsRUFBUixDQUFXamxCLE9BQXpCLENBQTNCOzs7T0F6N0RhOzs7OztNQWs4RG5CLFNBQVNxNUIsUUFBVCxDQUFrQmxPLEdBQWxCLEVBQXVCOUcsSUFBdkIsRUFBNkIwUSxLQUE3QixFQUFvQzs7UUFFbEMsS0FBSzFRLElBQUwsR0FBWUEsSUFBWixDQUZrQzs7UUFJbEMsS0FBS3dTLElBQUwsR0FBWWhDLG1CQUFtQixDQUFDeFEsSUFBRCxDQUEvQixDQUprQzs7UUFNbEMsS0FBS3owQyxJQUFMLEdBQVksS0FBS2luRCxJQUFMLEdBQVloTCxNQUFNLENBQUNyTCxHQUFHLENBQUMsS0FBS3FXLElBQU4sQ0FBSixDQUFOLEdBQXlCOUIsS0FBekIsR0FBaUMsQ0FBN0MsR0FBaUQsQ0FBN0Q7UUFDQSxLQUFLOTFDLElBQUwsR0FBWSxLQUFLNjBCLElBQUwsR0FBWSxJQUF4QjtRQUNBLEtBQUt3bEIsTUFBTCxHQUFjbkUsWUFBWSxDQUFDaEssR0FBRCxFQUFNOUcsSUFBTixDQUExQjtPQTE4RGlCOzs7TUE4OERuQixTQUFTa1YsY0FBVCxDQUF3QnRVLEVBQXhCLEVBQTRCcHpDLElBQTVCLEVBQWtDd0QsRUFBbEMsRUFBc0M7UUFDcEMsSUFBSXFxQyxLQUFLLEdBQUcsRUFBWjtZQUFnQjhaLE9BQWhCOztRQUNBLEtBQUssSUFBSTV0RCxHQUFHLEdBQUdpRyxJQUFmLEVBQXFCakcsR0FBRyxHQUFHeUosRUFBM0IsRUFBK0J6SixHQUFHLEdBQUc0dEQsT0FBckMsRUFBOEM7VUFDNUMsSUFBSXB3QyxJQUFJLEdBQUcsSUFBSWl3QyxRQUFKLENBQWFwVSxFQUFFLENBQUNrRyxHQUFoQixFQUFxQkQsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTdi9DLEdBQVQsQ0FBNUIsRUFBMkNBLEdBQTNDLENBQVg7VUFDQTR0RCxPQUFPLEdBQUc1dEQsR0FBRyxHQUFHd2QsSUFBSSxDQUFDeFosSUFBckI7VUFDQTh2QyxLQUFLLENBQUNqckQsSUFBTixDQUFXMjBCLElBQVg7OztRQUVGLE9BQU9zMkIsS0FBUDs7O01BR0YsSUFBSStaLGNBQWMsR0FBRyxJQUFyQjs7TUFFQSxTQUFTQyxhQUFULENBQXVCckksRUFBdkIsRUFBMkI7UUFDekIsSUFBSW9JLGNBQUosRUFBb0I7VUFDbEJBLGNBQWMsQ0FBQ0UsR0FBZixDQUFtQmxsRSxJQUFuQixDQUF3QjQ4RCxFQUF4QjtTQURGLE1BRU87VUFDTEEsRUFBRSxDQUFDdUksU0FBSCxHQUFlSCxjQUFjLEdBQUc7WUFDOUJFLEdBQUcsRUFBRSxDQUFDdEksRUFBRCxDQUR5QjtZQUU5QndJLGdCQUFnQixFQUFFO1dBRnBCOzs7O01BT0osU0FBU0MsbUJBQVQsQ0FBNkJDLEtBQTdCLEVBQW9DOzs7UUFHbEMsSUFBSUMsU0FBUyxHQUFHRCxLQUFLLENBQUNGLGdCQUF0QjtZQUF3Qy9oRSxDQUFDLEdBQUcsQ0FBNUM7O1FBQ0EsR0FBRztVQUNELE9BQU9BLENBQUMsR0FBR2tpRSxTQUFTLENBQUN0a0UsTUFBckIsRUFBNkJvQyxDQUFDLEVBQTlCLEVBQ0U7WUFBRWtpRSxTQUFTLENBQUNsaUUsQ0FBRCxDQUFULENBQWFsRyxJQUFiLENBQWtCLElBQWxCOzs7VUFDSixLQUFLLElBQUlrTyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTZELEtBQUssQ0FBQ0osR0FBTixDQUFVamtFLE1BQTlCLEVBQXNDb0ssQ0FBQyxFQUF2QyxFQUEyQztZQUN6QyxJQUFJdXhELEVBQUUsR0FBRzBJLEtBQUssQ0FBQ0osR0FBTixDQUFVNzVELENBQVYsQ0FBVDs7WUFDQSxJQUFJdXhELEVBQUUsQ0FBQzVMLHNCQUFQLEVBQ0U7Y0FBRSxPQUFPNEwsRUFBRSxDQUFDNEksb0JBQUgsR0FBMEI1SSxFQUFFLENBQUM1TCxzQkFBSCxDQUEwQi92RCxNQUEzRCxFQUNBO2dCQUFFMjdELEVBQUUsQ0FBQzVMLHNCQUFILENBQTBCNEwsRUFBRSxDQUFDNEksb0JBQUgsRUFBMUIsRUFBcURyb0UsSUFBckQsQ0FBMEQsSUFBMUQsRUFBZ0V5L0QsRUFBRSxDQUFDcE0sRUFBbkU7Ozs7U0FQVixRQVNTbnRELENBQUMsR0FBR2tpRSxTQUFTLENBQUN0a0UsTUFUdkI7OztNQVlGLFNBQVN3a0UsZUFBVCxDQUF5QjdJLEVBQXpCLEVBQTZCOEksS0FBN0IsRUFBb0M7UUFDbEMsSUFBSUosS0FBSyxHQUFHMUksRUFBRSxDQUFDdUksU0FBZjs7UUFDQSxJQUFJLENBQUNHLEtBQUwsRUFBWTtVQUFFOzs7UUFFZCxJQUFJO1VBQUVELG1CQUFtQixDQUFDQyxLQUFELENBQW5CO1NBQU4sU0FDUTtVQUNOTixjQUFjLEdBQUcsSUFBakI7VUFDQVUsS0FBSyxDQUFDSixLQUFELENBQUw7Ozs7TUFJSixJQUFJSyxzQkFBc0IsR0FBRyxJQUE3QixDQWhnRW1COzs7Ozs7OztNQXlnRW5CLFNBQVNDLFdBQVQsQ0FBcUI3VixPQUFyQixFQUE4QnR1RDs7UUFBc0I7UUFDbEQsSUFBSTZiLEdBQUcsR0FBRzR5QyxXQUFXLENBQUNILE9BQUQsRUFBVXR1RCxJQUFWLENBQXJCOztRQUNBLElBQUksQ0FBQzZiLEdBQUcsQ0FBQ3JjLE1BQVQsRUFBaUI7VUFBRTs7O1FBQ25CLElBQUk2SyxJQUFJLEdBQUdsRixLQUFLLENBQUM3RixTQUFOLENBQWdCMkQsS0FBaEIsQ0FBc0J2SCxJQUF0QixDQUEyQm1FLFNBQTNCLEVBQXNDLENBQXRDLENBQVg7WUFBcUQ2NUIsSUFBckQ7O1FBQ0EsSUFBSTZwQyxjQUFKLEVBQW9CO1VBQ2xCN3BDLElBQUksR0FBRzZwQyxjQUFjLENBQUNJLGdCQUF0QjtTQURGLE1BRU8sSUFBSU8sc0JBQUosRUFBNEI7VUFDakN4cUMsSUFBSSxHQUFHd3FDLHNCQUFQO1NBREssTUFFQTtVQUNMeHFDLElBQUksR0FBR3dxQyxzQkFBc0IsR0FBRyxFQUFoQztVQUNBdDhDLFVBQVUsQ0FBQ3c4QyxpQkFBRCxFQUFvQixDQUFwQixDQUFWOzs7UUFFRixJQUFJdE0sSUFBSSxHQUFHLFNBQVBBLElBQU8sQ0FBV2wyRCxDQUFYLEVBQWU7VUFDeEI4M0IsSUFBSSxDQUFDbjdCLElBQUwsQ0FBVSxZQUFZO1lBQUUsT0FBT3NkLEdBQUcsQ0FBQ2phLENBQUQsQ0FBSCxDQUFPaEMsS0FBUCxDQUFhLElBQWIsRUFBbUJ5SyxJQUFuQixDQUFQO1dBQXhCO1NBREY7O1FBSUEsS0FBSyxJQUFJekksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lhLEdBQUcsQ0FBQ3JjLE1BQXhCLEVBQWdDLEVBQUVvQyxDQUFsQztVQUNFazJELElBQUksQ0FBRWwyRCxDQUFGLENBQUo7Ozs7TUFHSixTQUFTd2lFLGlCQUFULEdBQTZCO1FBQzNCLElBQUlDLE9BQU8sR0FBR0gsc0JBQWQ7UUFDQUEsc0JBQXNCLEdBQUcsSUFBekI7O1FBQ0EsS0FBSyxJQUFJdGlFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5aUUsT0FBTyxDQUFDN2tFLE1BQTVCLEVBQW9DLEVBQUVvQyxDQUF0QyxFQUF5QztVQUFFeWlFLE9BQU8sQ0FBQ3ppRSxDQUFELENBQVA7O09BaGlFMUI7Ozs7O01Bc2lFbkIsU0FBUzBpRSxvQkFBVCxDQUE4QnZWLEVBQTlCLEVBQWtDc1IsUUFBbEMsRUFBNEN4QixLQUE1QyxFQUFtRDBGLElBQW5ELEVBQXlEO1FBQ3ZELEtBQUssSUFBSTM2RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeTJELFFBQVEsQ0FBQ21FLE9BQVQsQ0FBaUJobEUsTUFBckMsRUFBNkNvSyxDQUFDLEVBQTlDLEVBQWtEO1VBQ2hELElBQUk1SixJQUFJLEdBQUdxZ0UsUUFBUSxDQUFDbUUsT0FBVCxDQUFpQjU2RCxDQUFqQixDQUFYOztVQUNBLElBQUk1SixJQUFJLElBQUksTUFBWixFQUFvQjtZQUFFeWtFLGNBQWMsQ0FBQzFWLEVBQUQsRUFBS3NSLFFBQUwsQ0FBZDtXQUF0QixNQUNLLElBQUlyZ0UsSUFBSSxJQUFJLFFBQVosRUFBc0I7WUFBRTBrRSxnQkFBZ0IsQ0FBQzNWLEVBQUQsRUFBS3NSLFFBQUwsRUFBZXhCLEtBQWYsRUFBc0IwRixJQUF0QixDQUFoQjtXQUF4QixNQUNBLElBQUl2a0UsSUFBSSxJQUFJLE9BQVosRUFBcUI7WUFBRTJrRSxpQkFBaUIsQ0FBQzVWLEVBQUQsRUFBS3NSLFFBQUwsQ0FBakI7V0FBdkIsTUFDQSxJQUFJcmdFLElBQUksSUFBSSxRQUFaLEVBQXNCO1lBQUU0a0UsaUJBQWlCLENBQUM3VixFQUFELEVBQUtzUixRQUFMLEVBQWVrRSxJQUFmLENBQWpCOzs7O1FBRS9CbEUsUUFBUSxDQUFDbUUsT0FBVCxHQUFtQixJQUFuQjtPQTlpRWlCOzs7O01BbWpFbkIsU0FBU0ssaUJBQVQsQ0FBMkJ4RSxRQUEzQixFQUFxQztRQUNuQyxJQUFJQSxRQUFRLENBQUN0M0MsSUFBVCxJQUFpQnMzQyxRQUFRLENBQUN6aUIsSUFBOUIsRUFBb0M7VUFDbEN5aUIsUUFBUSxDQUFDdDNDLElBQVQsR0FBZ0J1K0IsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsSUFBZCxFQUFvQixvQkFBcEIsQ0FBbkI7O1VBQ0EsSUFBSStZLFFBQVEsQ0FBQ3ppQixJQUFULENBQWM1UCxVQUFsQixFQUNFO1lBQUVxeUIsUUFBUSxDQUFDemlCLElBQVQsQ0FBYzVQLFVBQWQsQ0FBeUI4MkIsWUFBekIsQ0FBc0N6RSxRQUFRLENBQUN0M0MsSUFBL0MsRUFBcURzM0MsUUFBUSxDQUFDemlCLElBQTlEOzs7VUFDSnlpQixRQUFRLENBQUN0M0MsSUFBVCxDQUFjOWlCLFdBQWQsQ0FBMEJvNkQsUUFBUSxDQUFDemlCLElBQW5DOztVQUNBLElBQUk2SCxFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtZQUFFMmEsUUFBUSxDQUFDdDNDLElBQVQsQ0FBY2hqQixLQUFkLENBQW9CZy9ELE1BQXBCLEdBQTZCLENBQTdCOzs7O1FBRTlCLE9BQU8xRSxRQUFRLENBQUN0M0MsSUFBaEI7OztNQUdGLFNBQVNpOEMsb0JBQVQsQ0FBOEJqVyxFQUE5QixFQUFrQ3NSLFFBQWxDLEVBQTRDO1FBQzFDLElBQUl0WixHQUFHLEdBQUdzWixRQUFRLENBQUNqSSxPQUFULEdBQW1CaUksUUFBUSxDQUFDakksT0FBVCxHQUFtQixHQUFuQixJQUEwQmlJLFFBQVEsQ0FBQ2xTLElBQVQsQ0FBY2lLLE9BQWQsSUFBeUIsRUFBbkQsQ0FBbkIsR0FBNEVpSSxRQUFRLENBQUNsUyxJQUFULENBQWNpSyxPQUFwRzs7UUFDQSxJQUFJclIsR0FBSixFQUFTO1VBQUVBLEdBQUcsSUFBSSw0QkFBUDs7O1FBQ1gsSUFBSXNaLFFBQVEsQ0FBQzRFLFVBQWIsRUFBeUI7VUFDdkIsSUFBSWxlLEdBQUosRUFBUztZQUFFc1osUUFBUSxDQUFDNEUsVUFBVCxDQUFvQi9kLFNBQXBCLEdBQWdDSCxHQUFoQztXQUFYLE1BQ0s7WUFBRXNaLFFBQVEsQ0FBQzRFLFVBQVQsQ0FBb0JqM0IsVUFBcEIsQ0FBK0JybUIsV0FBL0IsQ0FBMkMwNEMsUUFBUSxDQUFDNEUsVUFBcEQ7WUFBaUU1RSxRQUFRLENBQUM0RSxVQUFULEdBQXNCLElBQXRCOztTQUYxRSxNQUdPLElBQUlsZSxHQUFKLEVBQVM7VUFDZCxJQUFJditDLElBQUksR0FBR3E4RCxpQkFBaUIsQ0FBQ3hFLFFBQUQsQ0FBNUI7VUFDQUEsUUFBUSxDQUFDNEUsVUFBVCxHQUFzQno4RCxJQUFJLENBQUM2aEMsWUFBTCxDQUFrQmlkLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjUCxHQUFkLENBQXJCLEVBQXlDditDLElBQUksQ0FBQ2lqQyxVQUE5QyxDQUF0QjtVQUNBc2pCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQkUsYUFBakIsQ0FBK0JwQyxRQUFRLENBQUM0RSxVQUF4Qzs7T0F2a0VlOzs7O01BNmtFbkIsU0FBU0MsY0FBVCxDQUF3Qm5XLEVBQXhCLEVBQTRCc1IsUUFBNUIsRUFBc0M7UUFDcEMsSUFBSThFLEdBQUcsR0FBR3BXLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdnN0QsZ0JBQXJCOztRQUNBLElBQUltRSxHQUFHLElBQUlBLEdBQUcsQ0FBQ2hYLElBQUosSUFBWWtTLFFBQVEsQ0FBQ2xTLElBQWhDLEVBQXNDO1VBQ3BDWSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXZzdELGdCQUFYLEdBQThCLElBQTlCO1VBQ0FYLFFBQVEsQ0FBQzlQLE9BQVQsR0FBbUI0VSxHQUFHLENBQUM1VSxPQUF2QjtVQUNBLE9BQU80VSxHQUFHLENBQUNDLEtBQVg7OztRQUVGLE9BQU9oRixnQkFBZ0IsQ0FBQ3JSLEVBQUQsRUFBS3NSLFFBQUwsQ0FBdkI7T0FwbEVpQjs7Ozs7TUEwbEVuQixTQUFTb0UsY0FBVCxDQUF3QjFWLEVBQXhCLEVBQTRCc1IsUUFBNUIsRUFBc0M7UUFDcEMsSUFBSXRaLEdBQUcsR0FBR3NaLFFBQVEsQ0FBQ3ppQixJQUFULENBQWNzSixTQUF4QjtRQUNBLElBQUlrZSxLQUFLLEdBQUdGLGNBQWMsQ0FBQ25XLEVBQUQsRUFBS3NSLFFBQUwsQ0FBMUI7O1FBQ0EsSUFBSUEsUUFBUSxDQUFDemlCLElBQVQsSUFBaUJ5aUIsUUFBUSxDQUFDdDNDLElBQTlCLEVBQW9DO1VBQUVzM0MsUUFBUSxDQUFDdDNDLElBQVQsR0FBZ0JxOEMsS0FBSyxDQUFDN0UsR0FBdEI7OztRQUN0Q0YsUUFBUSxDQUFDemlCLElBQVQsQ0FBYzVQLFVBQWQsQ0FBeUI4MkIsWUFBekIsQ0FBc0NNLEtBQUssQ0FBQzdFLEdBQTVDLEVBQWlERixRQUFRLENBQUN6aUIsSUFBMUQ7UUFDQXlpQixRQUFRLENBQUN6aUIsSUFBVCxHQUFnQnduQixLQUFLLENBQUM3RSxHQUF0Qjs7UUFDQSxJQUFJNkUsS0FBSyxDQUFDaE4sT0FBTixJQUFpQmlJLFFBQVEsQ0FBQ2pJLE9BQTFCLElBQXFDZ04sS0FBSyxDQUFDL00sU0FBTixJQUFtQmdJLFFBQVEsQ0FBQ2hJLFNBQXJFLEVBQWdGO1VBQzlFZ0ksUUFBUSxDQUFDakksT0FBVCxHQUFtQmdOLEtBQUssQ0FBQ2hOLE9BQXpCO1VBQ0FpSSxRQUFRLENBQUNoSSxTQUFULEdBQXFCK00sS0FBSyxDQUFDL00sU0FBM0I7VUFDQXNNLGlCQUFpQixDQUFDNVYsRUFBRCxFQUFLc1IsUUFBTCxDQUFqQjtTQUhGLE1BSU8sSUFBSXRaLEdBQUosRUFBUztVQUNkc1osUUFBUSxDQUFDemlCLElBQVQsQ0FBY3NKLFNBQWQsR0FBMEJILEdBQTFCOzs7O01BSUosU0FBUzRkLGlCQUFULENBQTJCNVYsRUFBM0IsRUFBK0JzUixRQUEvQixFQUF5QztRQUN2QzJFLG9CQUFvQixDQUFDalcsRUFBRCxFQUFLc1IsUUFBTCxDQUFwQjs7UUFDQSxJQUFJQSxRQUFRLENBQUNsUyxJQUFULENBQWNrWCxTQUFsQixFQUNFO1VBQUVSLGlCQUFpQixDQUFDeEUsUUFBRCxDQUFqQixDQUE0Qm5aLFNBQTVCLEdBQXdDbVosUUFBUSxDQUFDbFMsSUFBVCxDQUFja1gsU0FBdEQ7U0FESixNQUVLLElBQUloRixRQUFRLENBQUN0M0MsSUFBVCxJQUFpQnMzQyxRQUFRLENBQUN6aUIsSUFBOUIsRUFDSDtVQUFFeWlCLFFBQVEsQ0FBQ3QzQyxJQUFULENBQWNtK0IsU0FBZCxHQUEwQixFQUExQjs7O1FBQ0osSUFBSW1SLFNBQVMsR0FBR2dJLFFBQVEsQ0FBQ2hJLFNBQVQsR0FBcUJnSSxRQUFRLENBQUNoSSxTQUFULEdBQXFCLEdBQXJCLElBQTRCZ0ksUUFBUSxDQUFDbFMsSUFBVCxDQUFja0ssU0FBZCxJQUEyQixFQUF2RCxDQUFyQixHQUFrRmdJLFFBQVEsQ0FBQ2xTLElBQVQsQ0FBY2tLLFNBQWhIO1FBQ0FnSSxRQUFRLENBQUN6aUIsSUFBVCxDQUFjc0osU0FBZCxHQUEwQm1SLFNBQVMsSUFBSSxFQUF2Qzs7O01BR0YsU0FBU3FNLGdCQUFULENBQTBCM1YsRUFBMUIsRUFBOEJzUixRQUE5QixFQUF3Q3hCLEtBQXhDLEVBQStDMEYsSUFBL0MsRUFBcUQ7UUFDbkQsSUFBSWxFLFFBQVEsQ0FBQ2lGLE1BQWIsRUFBcUI7VUFDbkJqRixRQUFRLENBQUN0M0MsSUFBVCxDQUFjcEIsV0FBZCxDQUEwQjA0QyxRQUFRLENBQUNpRixNQUFuQztVQUNBakYsUUFBUSxDQUFDaUYsTUFBVCxHQUFrQixJQUFsQjs7O1FBRUYsSUFBSWpGLFFBQVEsQ0FBQ2tGLGdCQUFiLEVBQStCO1VBQzdCbEYsUUFBUSxDQUFDdDNDLElBQVQsQ0FBY3BCLFdBQWQsQ0FBMEIwNEMsUUFBUSxDQUFDa0YsZ0JBQW5DO1VBQ0FsRixRQUFRLENBQUNrRixnQkFBVCxHQUE0QixJQUE1Qjs7O1FBRUYsSUFBSWxGLFFBQVEsQ0FBQ2xTLElBQVQsQ0FBY3FYLFdBQWxCLEVBQStCO1VBQzdCLElBQUloOUQsSUFBSSxHQUFHcThELGlCQUFpQixDQUFDeEUsUUFBRCxDQUE1QjtVQUNBQSxRQUFRLENBQUNrRixnQkFBVCxHQUE0QmplLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLGtDQUFrQytZLFFBQVEsQ0FBQ2xTLElBQVQsQ0FBY3FYLFdBQTlELEVBQ0UsWUFBWXpXLEVBQUUsQ0FBQ2psQixPQUFILENBQVcyN0IsV0FBWCxHQUF5QmxCLElBQUksQ0FBQ21CLFFBQTlCLEdBQXlDLENBQUNuQixJQUFJLENBQUNvQixnQkFBM0QsSUFBK0UsYUFBL0UsR0FBZ0dwQixJQUFJLENBQUNvQixnQkFBckcsR0FBeUgsSUFEM0gsQ0FBL0I7VUFFQTVXLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQkUsYUFBakIsQ0FBK0JwQyxRQUFRLENBQUNrRixnQkFBeEM7VUFDQS84RCxJQUFJLENBQUM2aEMsWUFBTCxDQUFrQmcyQixRQUFRLENBQUNrRixnQkFBM0IsRUFBNkNsRixRQUFRLENBQUN6aUIsSUFBdEQ7OztRQUVGLElBQUltZixPQUFPLEdBQUdzRCxRQUFRLENBQUNsUyxJQUFULENBQWN5WCxhQUE1Qjs7UUFDQSxJQUFJN1csRUFBRSxDQUFDamxCLE9BQUgsQ0FBVys3QixXQUFYLElBQTBCOUksT0FBOUIsRUFBdUM7VUFDckMsSUFBSStJLE1BQU0sR0FBR2pCLGlCQUFpQixDQUFDeEUsUUFBRCxDQUE5QjtVQUNBLElBQUkwRixVQUFVLEdBQUcxRixRQUFRLENBQUNpRixNQUFULEdBQWtCaGUsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsMkJBQWQsRUFBNEMsWUFBWXlILEVBQUUsQ0FBQ2psQixPQUFILENBQVcyN0IsV0FBWCxHQUF5QmxCLElBQUksQ0FBQ21CLFFBQTlCLEdBQXlDLENBQUNuQixJQUFJLENBQUNvQixnQkFBM0QsSUFBK0UsSUFBM0gsQ0FBdEM7VUFDQUksVUFBVSxDQUFDMzFCLFlBQVgsQ0FBd0IsYUFBeEIsRUFBdUMsTUFBdkM7VUFDQTJlLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQkUsYUFBakIsQ0FBK0JzRCxVQUEvQjtVQUNBRCxNQUFNLENBQUN6N0IsWUFBUCxDQUFvQjA3QixVQUFwQixFQUFnQzFGLFFBQVEsQ0FBQ3ppQixJQUF6Qzs7VUFDQSxJQUFJeWlCLFFBQVEsQ0FBQ2xTLElBQVQsQ0FBY3FYLFdBQWxCLEVBQ0U7WUFBRU8sVUFBVSxDQUFDN2UsU0FBWCxJQUF3QixNQUFNbVosUUFBUSxDQUFDbFMsSUFBVCxDQUFjcVgsV0FBNUM7OztVQUNKLElBQUl6VyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXKzdCLFdBQVgsS0FBMkIsQ0FBQzlJLE9BQUQsSUFBWSxDQUFDQSxPQUFPLENBQUMsd0JBQUQsQ0FBL0MsQ0FBSixFQUNFO1lBQUVzRCxRQUFRLENBQUMyRixVQUFULEdBQXNCRCxVQUFVLENBQUM5L0QsV0FBWCxDQUN0QnFoRCxHQUFHLENBQUMsS0FBRCxFQUFRMk8sYUFBYSxDQUFDbEgsRUFBRSxDQUFDamxCLE9BQUosRUFBYSswQixLQUFiLENBQXJCLEVBQ0MsNkNBREQsRUFFRSxXQUFZMEYsSUFBSSxDQUFDMEIsVUFBTCxDQUFnQix3QkFBaEIsQ0FBWixHQUF5RCxhQUF6RCxHQUEwRWxYLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdrZ0UsaUJBQXJGLEdBQTBHLElBRjVHLENBRG1CLENBQXRCOzs7VUFJSixJQUFJbkosT0FBSixFQUFhO1lBQUUsS0FBSyxJQUFJanpELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpbEQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV21nRSxXQUFYLENBQXVCM21FLE1BQTNDLEVBQW1ELEVBQUVzSyxDQUFyRCxFQUF3RDtjQUNyRSxJQUFJOUwsRUFBRSxHQUFHK3dELEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtZ0UsV0FBWCxDQUF1QnI4RCxDQUF2QixFQUEwQm85QyxTQUFuQztrQkFBOEMwRSxLQUFLLEdBQUdtUixPQUFPLENBQUN4aEUsY0FBUixDQUF1QnlDLEVBQXZCLEtBQThCKytELE9BQU8sQ0FBQy8rRCxFQUFELENBQTNGOztjQUNBLElBQUk0dEQsS0FBSixFQUNFO2dCQUFFbWEsVUFBVSxDQUFDOS9ELFdBQVgsQ0FBdUJxaEQsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDc0UsS0FBRCxDQUFSLEVBQWlCLHVCQUFqQixFQUNBLFdBQVkyWSxJQUFJLENBQUMwQixVQUFMLENBQWdCam9FLEVBQWhCLENBQVosR0FBbUMsYUFBbkMsR0FBb0R1bUUsSUFBSSxDQUFDNkIsV0FBTCxDQUFpQnBvRSxFQUFqQixDQUFwRCxHQUE0RSxJQUQ1RSxDQUExQjs7Ozs7OztNQU1WLFNBQVM0bUUsaUJBQVQsQ0FBMkI3VixFQUEzQixFQUErQnNSLFFBQS9CLEVBQXlDa0UsSUFBekMsRUFBK0M7UUFDN0MsSUFBSWxFLFFBQVEsQ0FBQ2dHLFNBQWIsRUFBd0I7VUFBRWhHLFFBQVEsQ0FBQ2dHLFNBQVQsR0FBcUIsSUFBckI7OztRQUMxQixJQUFJQyxRQUFRLEdBQUd4ZixTQUFTLENBQUMsdUJBQUQsQ0FBeEI7O1FBQ0EsS0FBSyxJQUFJLzlCLElBQUksR0FBR3MzQyxRQUFRLENBQUN0M0MsSUFBVCxDQUFjMGlCLFVBQXpCLEVBQXFDNTFCLElBQUksR0FBSSxLQUFLLENBQXZELEVBQTJEa1QsSUFBM0QsRUFBaUVBLElBQUksR0FBR2xULElBQXhFLEVBQThFO1VBQzVFQSxJQUFJLEdBQUdrVCxJQUFJLENBQUN5bEIsV0FBWjs7VUFDQSxJQUFJODNCLFFBQVEsQ0FBQ2w2RCxJQUFULENBQWMyYyxJQUFJLENBQUNtK0IsU0FBbkIsQ0FBSixFQUFtQztZQUFFbVosUUFBUSxDQUFDdDNDLElBQVQsQ0FBY3BCLFdBQWQsQ0FBMEJvQixJQUExQjs7OztRQUV2Q3c5QyxpQkFBaUIsQ0FBQ3hYLEVBQUQsRUFBS3NSLFFBQUwsRUFBZWtFLElBQWYsQ0FBakI7T0FqcUVpQjs7O01BcXFFbkIsU0FBU2lDLGdCQUFULENBQTBCelgsRUFBMUIsRUFBOEJzUixRQUE5QixFQUF3Q3hCLEtBQXhDLEVBQStDMEYsSUFBL0MsRUFBcUQ7UUFDbkQsSUFBSWEsS0FBSyxHQUFHRixjQUFjLENBQUNuVyxFQUFELEVBQUtzUixRQUFMLENBQTFCO1FBQ0FBLFFBQVEsQ0FBQ3ppQixJQUFULEdBQWdCeWlCLFFBQVEsQ0FBQ3QzQyxJQUFULEdBQWdCcThDLEtBQUssQ0FBQzdFLEdBQXRDOztRQUNBLElBQUk2RSxLQUFLLENBQUNoTixPQUFWLEVBQW1CO1VBQUVpSSxRQUFRLENBQUNqSSxPQUFULEdBQW1CZ04sS0FBSyxDQUFDaE4sT0FBekI7OztRQUNyQixJQUFJZ04sS0FBSyxDQUFDL00sU0FBVixFQUFxQjtVQUFFZ0ksUUFBUSxDQUFDaEksU0FBVCxHQUFxQitNLEtBQUssQ0FBQy9NLFNBQTNCOzs7UUFFdkJzTSxpQkFBaUIsQ0FBQzVWLEVBQUQsRUFBS3NSLFFBQUwsQ0FBakI7UUFDQXFFLGdCQUFnQixDQUFDM1YsRUFBRCxFQUFLc1IsUUFBTCxFQUFleEIsS0FBZixFQUFzQjBGLElBQXRCLENBQWhCO1FBQ0FnQyxpQkFBaUIsQ0FBQ3hYLEVBQUQsRUFBS3NSLFFBQUwsRUFBZWtFLElBQWYsQ0FBakI7UUFDQSxPQUFPbEUsUUFBUSxDQUFDdDNDLElBQWhCO09BOXFFaUI7Ozs7TUFtckVuQixTQUFTdzlDLGlCQUFULENBQTJCeFgsRUFBM0IsRUFBK0JzUixRQUEvQixFQUF5Q2tFLElBQXpDLEVBQStDO1FBQzdDa0Msb0JBQW9CLENBQUMxWCxFQUFELEVBQUtzUixRQUFRLENBQUNsUyxJQUFkLEVBQW9Ca1MsUUFBcEIsRUFBOEJrRSxJQUE5QixFQUFvQyxJQUFwQyxDQUFwQjs7UUFDQSxJQUFJbEUsUUFBUSxDQUFDTSxJQUFiLEVBQW1CO1VBQUUsS0FBSyxJQUFJLytELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5K0QsUUFBUSxDQUFDTSxJQUFULENBQWNuaEUsTUFBbEMsRUFBMENvQyxDQUFDLEVBQTNDLEVBQ25CO1lBQUU2a0Usb0JBQW9CLENBQUMxWCxFQUFELEVBQUtzUixRQUFRLENBQUNNLElBQVQsQ0FBYy8rRCxDQUFkLENBQUwsRUFBdUJ5K0QsUUFBdkIsRUFBaUNrRSxJQUFqQyxFQUF1QyxLQUF2QyxDQUFwQjs7Ozs7TUFHTixTQUFTa0Msb0JBQVQsQ0FBOEIxWCxFQUE5QixFQUFrQ1osSUFBbEMsRUFBd0NrUyxRQUF4QyxFQUFrRGtFLElBQWxELEVBQXdEbUMsVUFBeEQsRUFBb0U7UUFDbEUsSUFBSSxDQUFDdlksSUFBSSxDQUFDd1ksT0FBVixFQUFtQjtVQUFFOzs7UUFDckIsSUFBSW4rRCxJQUFJLEdBQUdxOEQsaUJBQWlCLENBQUN4RSxRQUFELENBQTVCOztRQUNBLEtBQUssSUFBSXorRCxDQUFDLEdBQUcsQ0FBUixFQUFXZ04sRUFBRSxHQUFHdS9DLElBQUksQ0FBQ3dZLE9BQTFCLEVBQW1DL2tFLENBQUMsR0FBR2dOLEVBQUUsQ0FBQ3BQLE1BQTFDLEVBQWtELEVBQUVvQyxDQUFwRCxFQUF1RDtVQUNyRCxJQUFJMGdFLE1BQU0sR0FBRzF6RCxFQUFFLENBQUNoTixDQUFELENBQWY7Y0FBb0JtbkIsSUFBSSxHQUFHdStCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQ2diLE1BQU0sQ0FBQ3Y1QyxJQUFSLENBQVIsRUFBdUIsMkJBQTJCdTVDLE1BQU0sQ0FBQ3BiLFNBQVAsR0FBbUIsTUFBTW9iLE1BQU0sQ0FBQ3BiLFNBQWhDLEdBQTRDLEVBQXZFLENBQXZCLENBQTlCOztVQUNBLElBQUksQ0FBQ29iLE1BQU0sQ0FBQ3NFLGlCQUFaLEVBQStCO1lBQUU3OUMsSUFBSSxDQUFDcW5CLFlBQUwsQ0FBa0Isa0JBQWxCLEVBQXNDLE1BQXRDOzs7VUFDakN5MkIsa0JBQWtCLENBQUN2RSxNQUFELEVBQVN2NUMsSUFBVCxFQUFlczNDLFFBQWYsRUFBeUJrRSxJQUF6QixDQUFsQjtVQUNBeFYsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCRSxhQUFqQixDQUErQjE1QyxJQUEvQjs7VUFDQSxJQUFJMjlDLFVBQVUsSUFBSXBFLE1BQU0sQ0FBQ3dFLEtBQXpCLEVBQ0U7WUFBRXQrRCxJQUFJLENBQUM2aEMsWUFBTCxDQUFrQnRoQixJQUFsQixFQUF3QnMzQyxRQUFRLENBQUNpRixNQUFULElBQW1CakYsUUFBUSxDQUFDemlCLElBQXBEO1dBREosTUFHRTtZQUFFcDFDLElBQUksQ0FBQ3ZDLFdBQUwsQ0FBaUI4aUIsSUFBakI7OztVQUNKbzdDLFdBQVcsQ0FBQzdCLE1BQUQsRUFBUyxRQUFULENBQVg7Ozs7TUFJSixTQUFTdUUsa0JBQVQsQ0FBNEJ2RSxNQUE1QixFQUFvQ3Y1QyxJQUFwQyxFQUEwQ3MzQyxRQUExQyxFQUFvRGtFLElBQXBELEVBQTBEO1FBQ3hELElBQUlqQyxNQUFNLENBQUN5RSxTQUFYLEVBQXNCO1VBQ3hCLENBQUMxRyxRQUFRLENBQUNnRyxTQUFULEtBQXVCaEcsUUFBUSxDQUFDZ0csU0FBVCxHQUFxQixFQUE1QyxDQUFELEVBQWtEOW5FLElBQWxELENBQXVEd3FCLElBQXZEO1VBQ0ksSUFBSSt4QixLQUFLLEdBQUd5cEIsSUFBSSxDQUFDeUMsWUFBakI7VUFDQWorQyxJQUFJLENBQUNoakIsS0FBTCxDQUFXMjRCLElBQVgsR0FBa0I2bEMsSUFBSSxDQUFDbUIsUUFBTCxHQUFnQixJQUFsQzs7VUFDQSxJQUFJLENBQUNwRCxNQUFNLENBQUMyRSxXQUFaLEVBQXlCO1lBQ3ZCbnNCLEtBQUssSUFBSXlwQixJQUFJLENBQUNvQixnQkFBZDtZQUNBNThDLElBQUksQ0FBQ2hqQixLQUFMLENBQVdtaEUsV0FBWCxHQUF5QjNDLElBQUksQ0FBQ29CLGdCQUFMLEdBQXdCLElBQWpEOzs7VUFFRjU4QyxJQUFJLENBQUNoakIsS0FBTCxDQUFXKzBDLEtBQVgsR0FBbUJBLEtBQUssR0FBRyxJQUEzQjs7O1FBRUYsSUFBSXduQixNQUFNLENBQUMyRSxXQUFYLEVBQXdCO1VBQ3RCbCtDLElBQUksQ0FBQ2hqQixLQUFMLENBQVdnL0QsTUFBWCxHQUFvQixDQUFwQjtVQUNBaDhDLElBQUksQ0FBQ2hqQixLQUFMLENBQVcrZCxRQUFYLEdBQXNCLFVBQXRCOztVQUNBLElBQUksQ0FBQ3crQyxNQUFNLENBQUN5RSxTQUFaLEVBQXVCO1lBQUVoK0MsSUFBSSxDQUFDaGpCLEtBQUwsQ0FBV29oRSxVQUFYLEdBQXdCLENBQUM1QyxJQUFJLENBQUNvQixnQkFBTixHQUF5QixJQUFqRDs7Ozs7TUFJN0IsU0FBU3lCLFlBQVQsQ0FBc0I5RSxNQUF0QixFQUE4QjtRQUM1QixJQUFJQSxNQUFNLENBQUN0bkIsTUFBUCxJQUFpQixJQUFyQixFQUEyQjtVQUFFLE9BQU9zbkIsTUFBTSxDQUFDdG5CLE1BQWQ7OztRQUM3QixJQUFJK1QsRUFBRSxHQUFHdVQsTUFBTSxDQUFDck4sR0FBUCxDQUFXbEcsRUFBcEI7O1FBQ0EsSUFBSSxDQUFDQSxFQUFMLEVBQVM7VUFBRSxPQUFPLENBQVA7OztRQUNYLElBQUksQ0FBQy9HLFFBQVEsQ0FBQ3pyRCxRQUFRLENBQUNvOUMsSUFBVixFQUFnQjJvQixNQUFNLENBQUN2NUMsSUFBdkIsQ0FBYixFQUEyQztVQUN6QyxJQUFJcytDLFdBQVcsR0FBRyxxQkFBbEI7O1VBQ0EsSUFBSS9FLE1BQU0sQ0FBQzJFLFdBQVgsRUFDRTtZQUFFSSxXQUFXLElBQUksbUJBQW1CdFksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3NoRSxPQUFYLENBQW1CN1csV0FBdEMsR0FBb0QsS0FBbkU7OztVQUNKLElBQUk2UixNQUFNLENBQUN5RSxTQUFYLEVBQ0U7WUFBRU0sV0FBVyxJQUFJLFlBQVl0WSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVgsQ0FBbUI4NkMsV0FBL0IsR0FBNkMsS0FBNUQ7OztVQUNKbGdCLG9CQUFvQixDQUFDMEgsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VxRCxPQUFaLEVBQXFCakosR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDZ2IsTUFBTSxDQUFDdjVDLElBQVIsQ0FBUixFQUF1QixJQUF2QixFQUE2QnMrQyxXQUE3QixDQUF4QixDQUFwQjs7O1FBRUYsT0FBTy9FLE1BQU0sQ0FBQ3RuQixNQUFQLEdBQWdCc25CLE1BQU0sQ0FBQ3Y1QyxJQUFQLENBQVlpbEIsVUFBWixDQUF1QndpQixZQUE5QztPQXZ1RWlCOzs7TUEydUVuQixTQUFTZ1gsYUFBVCxDQUF1QnhoRSxPQUF2QixFQUFnQ3BLLENBQWhDLEVBQW1DO1FBQ2pDLEtBQUssSUFBSW9SLENBQUMsR0FBRytpRCxRQUFRLENBQUNuMEQsQ0FBRCxDQUFyQixFQUEwQm9SLENBQUMsSUFBSWhILE9BQU8sQ0FBQ3ltQixPQUF2QyxFQUFnRHpmLENBQUMsR0FBR0EsQ0FBQyxDQUFDZ2hDLFVBQXRELEVBQWtFO1VBQ2hFLElBQUksQ0FBQ2hoQyxDQUFELElBQU9BLENBQUMsQ0FBQzgrQixRQUFGLElBQWMsQ0FBZCxJQUFtQjkrQixDQUFDLENBQUNvL0IsWUFBRixDQUFlLGtCQUFmLEtBQXNDLE1BQWhFLElBQ0NwL0IsQ0FBQyxDQUFDZ2hDLFVBQUYsSUFBZ0Job0MsT0FBTyxDQUFDeWhFLEtBQXhCLElBQWlDejZELENBQUMsSUFBSWhILE9BQU8sQ0FBQzBoRSxLQURuRCxFQUVFO1lBQUUsT0FBTyxJQUFQOzs7T0EvdUVXOzs7TUFxdkVuQixTQUFTQyxVQUFULENBQW9CM2hFLE9BQXBCLEVBQTZCO1FBQUMsT0FBT0EsT0FBTyxDQUFDNGhFLFNBQVIsQ0FBa0JDLFNBQXpCOzs7TUFDOUIsU0FBU0MsV0FBVCxDQUFxQjloRSxPQUFyQixFQUE4QjtRQUFDLE9BQU9BLE9BQU8sQ0FBQzBoRSxLQUFSLENBQWNsWCxZQUFkLEdBQTZCeHFELE9BQU8sQ0FBQzRoRSxTQUFSLENBQWtCcFgsWUFBdEQ7OztNQUMvQixTQUFTdVgsUUFBVCxDQUFrQi9oRSxPQUFsQixFQUEyQjtRQUN6QixJQUFJQSxPQUFPLENBQUNnaUUsY0FBWixFQUE0QjtVQUFFLE9BQU9oaUUsT0FBTyxDQUFDZ2lFLGNBQWY7OztRQUM5QixJQUFJcHNFLENBQUMsR0FBR3lyRCxvQkFBb0IsQ0FBQ3JoRCxPQUFPLENBQUN1cUQsT0FBVCxFQUFrQmpKLEdBQUcsQ0FBQyxLQUFELEVBQVEsR0FBUixFQUFhLHNCQUFiLENBQXJCLENBQTVCO1FBQ0EsSUFBSXZoRCxLQUFLLEdBQUc3SyxNQUFNLENBQUMrc0UsZ0JBQVAsR0FBMEIvc0UsTUFBTSxDQUFDK3NFLGdCQUFQLENBQXdCcnNFLENBQXhCLENBQTFCLEdBQXVEQSxDQUFDLENBQUNzc0UsWUFBckU7UUFDQSxJQUFJdDNELElBQUksR0FBRztVQUFDOHRCLElBQUksRUFBRWp3QixRQUFRLENBQUMxSSxLQUFLLENBQUNtaEUsV0FBUCxDQUFmO1VBQW9DblcsS0FBSyxFQUFFdGlELFFBQVEsQ0FBQzFJLEtBQUssQ0FBQ29pRSxZQUFQO1NBQTlEOztRQUNBLElBQUksQ0FBQzNrRSxLQUFLLENBQUNvTixJQUFJLENBQUM4dEIsSUFBTixDQUFOLElBQXFCLENBQUNsN0IsS0FBSyxDQUFDb04sSUFBSSxDQUFDbWdELEtBQU4sQ0FBL0IsRUFBNkM7VUFBRS9xRCxPQUFPLENBQUNnaUUsY0FBUixHQUF5QnAzRCxJQUF6Qjs7O1FBQy9DLE9BQU9BLElBQVA7OztNQUdGLFNBQVN3M0QsU0FBVCxDQUFtQnJaLEVBQW5CLEVBQXVCO1FBQUUsT0FBT3RGLFdBQVcsR0FBR3NGLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdxaUUsY0FBaEM7OztNQUN6QixTQUFTQyxZQUFULENBQXNCdlosRUFBdEIsRUFBMEI7UUFDeEIsT0FBT0EsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CaEIsV0FBcEIsR0FBa0NhLFNBQVMsQ0FBQ3JaLEVBQUQsQ0FBM0MsR0FBa0RBLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd3aUUsUUFBcEU7OztNQUVGLFNBQVNDLGFBQVQsQ0FBdUIxWixFQUF2QixFQUEyQjtRQUN6QixPQUFPQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdWlFLFFBQVgsQ0FBb0JHLFlBQXBCLEdBQW1DTixTQUFTLENBQUNyWixFQUFELENBQTVDLEdBQW1EQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXMmlFLFNBQXJFO09BcndFaUI7Ozs7OztNQTR3RW5CLFNBQVNDLGlCQUFULENBQTJCN1osRUFBM0IsRUFBK0JzUixRQUEvQixFQUF5Q3BrQixJQUF6QyxFQUErQztRQUM3QyxJQUFJNHNCLFFBQVEsR0FBRzlaLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBMUI7UUFDQSxJQUFJQyxRQUFRLEdBQUdGLFFBQVEsSUFBSVAsWUFBWSxDQUFDdlosRUFBRCxDQUF2Qzs7UUFDQSxJQUFJLENBQUNzUixRQUFRLENBQUM5UCxPQUFULENBQWlCeVksT0FBbEIsSUFBNkJILFFBQVEsSUFBSXhJLFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUJ6VixLQUFqQixJQUEwQml1QixRQUF2RSxFQUFpRjtVQUMvRSxJQUFJQyxPQUFPLEdBQUczSSxRQUFRLENBQUM5UCxPQUFULENBQWlCeVksT0FBakIsR0FBMkIsRUFBekM7O1VBQ0EsSUFBSUgsUUFBSixFQUFjO1lBQ1p4SSxRQUFRLENBQUM5UCxPQUFULENBQWlCelYsS0FBakIsR0FBeUJpdUIsUUFBekI7WUFDQSxJQUFJRSxLQUFLLEdBQUc1SSxRQUFRLENBQUN6aUIsSUFBVCxDQUFjblMsVUFBZCxDQUF5Qnk5QixjQUF6QixFQUFaOztZQUNBLEtBQUssSUFBSXRuRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcW5FLEtBQUssQ0FBQ3pwRSxNQUFOLEdBQWUsQ0FBbkMsRUFBc0NvQyxDQUFDLEVBQXZDLEVBQTJDO2NBQ3pDLElBQUlvcUQsR0FBRyxHQUFHaWQsS0FBSyxDQUFDcm5FLENBQUQsQ0FBZjtrQkFBb0JpVSxJQUFJLEdBQUdvekQsS0FBSyxDQUFDcm5FLENBQUMsR0FBRyxDQUFMLENBQWhDOztjQUNBLElBQUl6RyxJQUFJLENBQUNrWCxHQUFMLENBQVMyNUMsR0FBRyxDQUFDbWQsTUFBSixHQUFhdHpELElBQUksQ0FBQ3N6RCxNQUEzQixJQUFxQyxDQUF6QyxFQUNFO2dCQUFFSCxPQUFPLENBQUN6cUUsSUFBUixDQUFhLENBQUN5dEQsR0FBRyxDQUFDbWQsTUFBSixHQUFhdHpELElBQUksQ0FBQ3ltQyxHQUFuQixJQUEwQixDQUExQixHQUE4QkwsSUFBSSxDQUFDSyxHQUFoRDs7Ozs7VUFHUjBzQixPQUFPLENBQUN6cUUsSUFBUixDQUFhMDlDLElBQUksQ0FBQ2t0QixNQUFMLEdBQWNsdEIsSUFBSSxDQUFDSyxHQUFoQzs7T0ExeEVlOzs7OztNQWl5RW5CLFNBQVM4c0IsZUFBVCxDQUF5Qi9JLFFBQXpCLEVBQW1DbFMsSUFBbkMsRUFBeUMwUSxLQUF6QyxFQUFnRDtRQUM5QyxJQUFJd0IsUUFBUSxDQUFDbFMsSUFBVCxJQUFpQkEsSUFBckIsRUFDRTtVQUFFLE9BQU87WUFBQ2p3QyxHQUFHLEVBQUVtaUQsUUFBUSxDQUFDOVAsT0FBVCxDQUFpQnJ5QyxHQUF2QjtZQUE0QmlpRCxLQUFLLEVBQUVFLFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUI0UDtXQUEzRDs7O1FBQ0osS0FBSyxJQUFJditELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5K0QsUUFBUSxDQUFDTSxJQUFULENBQWNuaEUsTUFBbEMsRUFBMENvQyxDQUFDLEVBQTNDLEVBQ0U7VUFBRSxJQUFJeStELFFBQVEsQ0FBQ00sSUFBVCxDQUFjLytELENBQWQsS0FBb0J1c0QsSUFBeEIsRUFDQTtZQUFFLE9BQU87Y0FBQ2p3QyxHQUFHLEVBQUVtaUQsUUFBUSxDQUFDOVAsT0FBVCxDQUFpQjJRLElBQWpCLENBQXNCdC9ELENBQXRCLENBQU47Y0FBZ0N1K0QsS0FBSyxFQUFFRSxRQUFRLENBQUM5UCxPQUFULENBQWlCNFEsTUFBakIsQ0FBd0J2L0QsQ0FBeEI7YUFBOUM7Ozs7UUFDTixLQUFLLElBQUlrckQsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3VULFFBQVEsQ0FBQ00sSUFBVCxDQUFjbmhFLE1BQXRDLEVBQThDc3RELEdBQUcsRUFBakQsRUFDRTtVQUFFLElBQUk2SSxNQUFNLENBQUMwSyxRQUFRLENBQUNNLElBQVQsQ0FBYzdULEdBQWQsQ0FBRCxDQUFOLEdBQTZCK1IsS0FBakMsRUFDQTtZQUFFLE9BQU87Y0FBQzNnRCxHQUFHLEVBQUVtaUQsUUFBUSxDQUFDOVAsT0FBVCxDQUFpQjJRLElBQWpCLENBQXNCcFUsR0FBdEIsQ0FBTjtjQUFrQ3FULEtBQUssRUFBRUUsUUFBUSxDQUFDOVAsT0FBVCxDQUFpQjRRLE1BQWpCLENBQXdCclUsR0FBeEIsQ0FBekM7Y0FBdUVhLE1BQU0sRUFBRTthQUF0Rjs7O09BenlFVzs7OztNQTh5RW5CLFNBQVMwYix5QkFBVCxDQUFtQ3RhLEVBQW5DLEVBQXVDWixJQUF2QyxFQUE2QztRQUMzQ0EsSUFBSSxHQUFHcVEsVUFBVSxDQUFDclEsSUFBRCxDQUFqQjtRQUNBLElBQUkwUSxLQUFLLEdBQUdsSixNQUFNLENBQUN4SCxJQUFELENBQWxCO1FBQ0EsSUFBSWo3QixJQUFJLEdBQUc2N0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2c3RCxnQkFBWCxHQUE4QixJQUFJbUMsUUFBSixDQUFhcFUsRUFBRSxDQUFDa0csR0FBaEIsRUFBcUI5RyxJQUFyQixFQUEyQjBRLEtBQTNCLENBQXpDO1FBQ0EzckMsSUFBSSxDQUFDMnJDLEtBQUwsR0FBYUEsS0FBYjtRQUNBLElBQUl1RyxLQUFLLEdBQUdseUMsSUFBSSxDQUFDa3lDLEtBQUwsR0FBYWhGLGdCQUFnQixDQUFDclIsRUFBRCxFQUFLNzdCLElBQUwsQ0FBekM7UUFDQUEsSUFBSSxDQUFDMHFCLElBQUwsR0FBWXduQixLQUFLLENBQUM3RSxHQUFsQjtRQUNBbFosb0JBQW9CLENBQUMwSCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXc2pFLFdBQVosRUFBeUJsRSxLQUFLLENBQUM3RSxHQUEvQixDQUFwQjtRQUNBLE9BQU9ydEMsSUFBUDtPQXR6RWlCOzs7O01BMnpFbkIsU0FBU3EyQyxXQUFULENBQXFCeGEsRUFBckIsRUFBeUJaLElBQXpCLEVBQStCOXBDLEVBQS9CLEVBQW1DbWxELElBQW5DLEVBQXlDO1FBQ3ZDLE9BQU9DLG1CQUFtQixDQUFDMWEsRUFBRCxFQUFLMmEscUJBQXFCLENBQUMzYSxFQUFELEVBQUtaLElBQUwsQ0FBMUIsRUFBc0M5cEMsRUFBdEMsRUFBMENtbEQsSUFBMUMsQ0FBMUI7T0E1ekVpQjs7O01BZzBFbkIsU0FBU0csZUFBVCxDQUF5QjVhLEVBQXpCLEVBQTZCOFAsS0FBN0IsRUFBb0M7UUFDbEMsSUFBSUEsS0FBSyxJQUFJOVAsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t6RCxRQUFwQixJQUFnQzJGLEtBQUssR0FBRzlQLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBdkQsRUFDRTtVQUFFLE9BQU9wSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3RCLElBQVgsQ0FBZ0IwMkMsYUFBYSxDQUFDN2EsRUFBRCxFQUFLOFAsS0FBTCxDQUE3QixDQUFQOzs7UUFDSixJQUFJc0csR0FBRyxHQUFHcFcsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2c3RCxnQkFBckI7O1FBQ0EsSUFBSW1FLEdBQUcsSUFBSXRHLEtBQUssSUFBSXNHLEdBQUcsQ0FBQ3RHLEtBQXBCLElBQTZCQSxLQUFLLEdBQUdzRyxHQUFHLENBQUN0RyxLQUFKLEdBQVlzRyxHQUFHLENBQUN6ckQsSUFBekQsRUFDRTtVQUFFLE9BQU95ckQsR0FBUDs7T0FyMEVhOzs7Ozs7O01BNjBFbkIsU0FBU3VFLHFCQUFULENBQStCM2EsRUFBL0IsRUFBbUNaLElBQW5DLEVBQXlDO1FBQ3ZDLElBQUkwUSxLQUFLLEdBQUdsSixNQUFNLENBQUN4SCxJQUFELENBQWxCO1FBQ0EsSUFBSWo3QixJQUFJLEdBQUd5MkMsZUFBZSxDQUFDNWEsRUFBRCxFQUFLOFAsS0FBTCxDQUExQjs7UUFDQSxJQUFJM3JDLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUMwcUIsSUFBbEIsRUFBd0I7VUFDdEIxcUIsSUFBSSxHQUFHLElBQVA7U0FERixNQUVPLElBQUlBLElBQUksSUFBSUEsSUFBSSxDQUFDc3hDLE9BQWpCLEVBQTBCO1VBQy9CRixvQkFBb0IsQ0FBQ3ZWLEVBQUQsRUFBSzc3QixJQUFMLEVBQVcyckMsS0FBWCxFQUFrQmdMLGFBQWEsQ0FBQzlhLEVBQUQsQ0FBL0IsQ0FBcEI7VUFDQUEsRUFBRSxDQUFDTyxLQUFILENBQVN3YSxXQUFULEdBQXVCLElBQXZCOzs7UUFFRixJQUFJLENBQUM1MkMsSUFBTCxFQUNFO1VBQUVBLElBQUksR0FBR20yQyx5QkFBeUIsQ0FBQ3RhLEVBQUQsRUFBS1osSUFBTCxDQUFoQzs7O1FBRUosSUFBSXhvQixJQUFJLEdBQUd5akMsZUFBZSxDQUFDbDJDLElBQUQsRUFBT2k3QixJQUFQLEVBQWEwUSxLQUFiLENBQTFCO1FBQ0EsT0FBTztVQUNMMVEsSUFBSSxFQUFFQSxJQUREO1VBQ09qN0IsSUFBSSxFQUFFQSxJQURiO1VBQ21CK29CLElBQUksRUFBRSxJQUR6QjtVQUVMLzlCLEdBQUcsRUFBRXluQixJQUFJLENBQUN6bkIsR0FGTDtVQUVVaWlELEtBQUssRUFBRXg2QixJQUFJLENBQUN3NkIsS0FGdEI7VUFFNkJ4UyxNQUFNLEVBQUVob0IsSUFBSSxDQUFDZ29CLE1BRjFDO1VBR0xvYyxVQUFVLEVBQUU7U0FIZDtPQTExRWlCOzs7O01BbTJFbkIsU0FBU04sbUJBQVQsQ0FBNkIxYSxFQUE3QixFQUFpQ2liLFFBQWpDLEVBQTJDM2xELEVBQTNDLEVBQStDbWxELElBQS9DLEVBQXFEUyxTQUFyRCxFQUFnRTtRQUM5RCxJQUFJRCxRQUFRLENBQUNyYyxNQUFiLEVBQXFCO1VBQUV0cEMsRUFBRSxHQUFHLENBQUMsQ0FBTjs7O1FBQ3ZCLElBQUk1b0IsR0FBRyxHQUFHNG9CLEVBQUUsSUFBSW1sRCxJQUFJLElBQUksRUFBWixDQUFaO1lBQTZCNWQsS0FBN0I7O1FBQ0EsSUFBSW9lLFFBQVEsQ0FBQzdKLEtBQVQsQ0FBZTVrRSxjQUFmLENBQThCRSxHQUE5QixDQUFKLEVBQXdDO1VBQ3RDbXdELEtBQUssR0FBR29lLFFBQVEsQ0FBQzdKLEtBQVQsQ0FBZTFrRSxHQUFmLENBQVI7U0FERixNQUVPO1VBQ0wsSUFBSSxDQUFDdXVFLFFBQVEsQ0FBQy90QixJQUFkLEVBQ0U7WUFBRSt0QixRQUFRLENBQUMvdEIsSUFBVCxHQUFnQit0QixRQUFRLENBQUM5MkMsSUFBVCxDQUFjMHFCLElBQWQsQ0FBbUIxQixxQkFBbkIsRUFBaEI7OztVQUNKLElBQUksQ0FBQzh0QixRQUFRLENBQUNELFVBQWQsRUFBMEI7WUFDeEJuQixpQkFBaUIsQ0FBQzdaLEVBQUQsRUFBS2liLFFBQVEsQ0FBQzkyQyxJQUFkLEVBQW9CODJDLFFBQVEsQ0FBQy90QixJQUE3QixDQUFqQjtZQUNBK3RCLFFBQVEsQ0FBQ0QsVUFBVCxHQUFzQixJQUF0Qjs7O1VBRUZuZSxLQUFLLEdBQUdzZSxnQkFBZ0IsQ0FBQ25iLEVBQUQsRUFBS2liLFFBQUwsRUFBZTNsRCxFQUFmLEVBQW1CbWxELElBQW5CLENBQXhCOztVQUNBLElBQUksQ0FBQzVkLEtBQUssQ0FBQ3VlLEtBQVgsRUFBa0I7WUFBRUgsUUFBUSxDQUFDN0osS0FBVCxDQUFlMWtFLEdBQWYsSUFBc0Jtd0QsS0FBdEI7Ozs7UUFFdEIsT0FBTztVQUFDbHRCLElBQUksRUFBRWt0QixLQUFLLENBQUNsdEIsSUFBYjtVQUFtQnF5QixLQUFLLEVBQUVuRixLQUFLLENBQUNtRixLQUFoQztVQUNDelUsR0FBRyxFQUFFMnRCLFNBQVMsR0FBR3JlLEtBQUssQ0FBQ3dlLElBQVQsR0FBZ0J4ZSxLQUFLLENBQUN0UCxHQURyQztVQUVDNnNCLE1BQU0sRUFBRWMsU0FBUyxHQUFHcmUsS0FBSyxDQUFDeWUsT0FBVCxHQUFtQnplLEtBQUssQ0FBQ3VkO1NBRmxEOzs7TUFLRixJQUFJbUIsUUFBUSxHQUFHO1FBQUM1ckMsSUFBSSxFQUFFLENBQVA7UUFBVXF5QixLQUFLLEVBQUUsQ0FBakI7UUFBb0J6VSxHQUFHLEVBQUUsQ0FBekI7UUFBNEI2c0IsTUFBTSxFQUFFO09BQW5EOztNQUVBLFNBQVNvQixzQkFBVCxDQUFnQ3JzRCxHQUFoQyxFQUFxQ21HLEVBQXJDLEVBQXlDbWxELElBQXpDLEVBQStDO1FBQzdDLElBQUl6Z0QsSUFBSixFQUFVak0sS0FBVixFQUFpQnpFLEdBQWpCLEVBQXNCd3ZDLFFBQXRCLEVBQWdDMmlCLE1BQWhDLEVBQXdDQyxJQUF4QyxDQUQ2Qzs7O1FBSTdDLEtBQUssSUFBSTdvRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc2MsR0FBRyxDQUFDMWUsTUFBeEIsRUFBZ0NvQyxDQUFDLElBQUksQ0FBckMsRUFBd0M7VUFDdEM0b0UsTUFBTSxHQUFHdHNELEdBQUcsQ0FBQ3RjLENBQUQsQ0FBWjtVQUNBNm9FLElBQUksR0FBR3ZzRCxHQUFHLENBQUN0YyxDQUFDLEdBQUcsQ0FBTCxDQUFWOztVQUNBLElBQUl5aUIsRUFBRSxHQUFHbW1ELE1BQVQsRUFBaUI7WUFDZjF0RCxLQUFLLEdBQUcsQ0FBUjtZQUFXekUsR0FBRyxHQUFHLENBQU47WUFDWHd2QyxRQUFRLEdBQUcsTUFBWDtXQUZGLE1BR08sSUFBSXhqQyxFQUFFLEdBQUdvbUQsSUFBVCxFQUFlO1lBQ3BCM3RELEtBQUssR0FBR3VILEVBQUUsR0FBR21tRCxNQUFiO1lBQ0FueUQsR0FBRyxHQUFHeUUsS0FBSyxHQUFHLENBQWQ7V0FGSyxNQUdBLElBQUlsYixDQUFDLElBQUlzYyxHQUFHLENBQUMxZSxNQUFKLEdBQWEsQ0FBbEIsSUFBdUI2a0IsRUFBRSxJQUFJb21ELElBQU4sSUFBY3ZzRCxHQUFHLENBQUN0YyxDQUFDLEdBQUcsQ0FBTCxDQUFILEdBQWF5aUIsRUFBdEQsRUFBMEQ7WUFDL0RoTSxHQUFHLEdBQUdveUQsSUFBSSxHQUFHRCxNQUFiO1lBQ0ExdEQsS0FBSyxHQUFHekUsR0FBRyxHQUFHLENBQWQ7O1lBQ0EsSUFBSWdNLEVBQUUsSUFBSW9tRCxJQUFWLEVBQWdCO2NBQUU1aUIsUUFBUSxHQUFHLE9BQVg7Ozs7VUFFcEIsSUFBSS9xQyxLQUFLLElBQUksSUFBYixFQUFtQjtZQUNqQmlNLElBQUksR0FBRzdLLEdBQUcsQ0FBQ3RjLENBQUMsR0FBRyxDQUFMLENBQVY7O1lBQ0EsSUFBSTRvRSxNQUFNLElBQUlDLElBQVYsSUFBa0JqQixJQUFJLEtBQUt6Z0QsSUFBSSxDQUFDOHlDLFVBQUwsR0FBa0IsTUFBbEIsR0FBMkIsT0FBaEMsQ0FBMUIsRUFDRTtjQUFFaFUsUUFBUSxHQUFHMmhCLElBQVg7OztZQUNKLElBQUlBLElBQUksSUFBSSxNQUFSLElBQWtCMXNELEtBQUssSUFBSSxDQUEvQixFQUNFO2NBQUUsT0FBT2xiLENBQUMsSUFBSXNjLEdBQUcsQ0FBQ3RjLENBQUMsR0FBRyxDQUFMLENBQUgsSUFBY3NjLEdBQUcsQ0FBQ3RjLENBQUMsR0FBRyxDQUFMLENBQXRCLElBQWlDc2MsR0FBRyxDQUFDdGMsQ0FBQyxHQUFHLENBQUwsQ0FBSCxDQUFXaTZELFVBQW5ELEVBQStEO2dCQUMvRDl5QyxJQUFJLEdBQUc3SyxHQUFHLENBQUMsQ0FBQ3RjLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBWixDQUFWO2dCQUNBaW1ELFFBQVEsR0FBRyxNQUFYOzs7O1lBRUosSUFBSTJoQixJQUFJLElBQUksT0FBUixJQUFtQjFzRCxLQUFLLElBQUkydEQsSUFBSSxHQUFHRCxNQUF2QyxFQUNFO2NBQUUsT0FBTzVvRSxDQUFDLEdBQUdzYyxHQUFHLENBQUMxZSxNQUFKLEdBQWEsQ0FBakIsSUFBc0IwZSxHQUFHLENBQUN0YyxDQUFDLEdBQUcsQ0FBTCxDQUFILElBQWNzYyxHQUFHLENBQUN0YyxDQUFDLEdBQUcsQ0FBTCxDQUF2QyxJQUFrRCxDQUFDc2MsR0FBRyxDQUFDdGMsQ0FBQyxHQUFHLENBQUwsQ0FBSCxDQUFXaTZELFVBQXJFLEVBQWlGO2dCQUNqRjl5QyxJQUFJLEdBQUc3SyxHQUFHLENBQUMsQ0FBQ3RjLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBWixDQUFWO2dCQUNBaW1ELFFBQVEsR0FBRyxPQUFYOzs7O1lBRUo7Ozs7UUFHSixPQUFPO1VBQUM5K0IsSUFBSSxFQUFFQSxJQUFQO1VBQWFqTSxLQUFLLEVBQUVBLEtBQXBCO1VBQTJCekUsR0FBRyxFQUFFQSxHQUFoQztVQUFxQ3d2QyxRQUFRLEVBQUVBLFFBQS9DO1VBQXlENmlCLFVBQVUsRUFBRUYsTUFBckU7VUFBNkVHLFFBQVEsRUFBRUY7U0FBOUY7OztNQUdGLFNBQVNHLGFBQVQsQ0FBdUIzQixLQUF2QixFQUE4Qk8sSUFBOUIsRUFBb0M7UUFDbEMsSUFBSXZ0QixJQUFJLEdBQUdxdUIsUUFBWDs7UUFDQSxJQUFJZCxJQUFJLElBQUksTUFBWixFQUFvQjtVQUFFLEtBQUssSUFBSTVuRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcW5FLEtBQUssQ0FBQ3pwRSxNQUExQixFQUFrQ29DLENBQUMsRUFBbkMsRUFBdUM7WUFDM0QsSUFBSSxDQUFDcTZDLElBQUksR0FBR2d0QixLQUFLLENBQUNybkUsQ0FBRCxDQUFiLEVBQWtCODhCLElBQWxCLElBQTBCdWQsSUFBSSxDQUFDOFUsS0FBbkMsRUFBMEM7Y0FBRTs7O1NBRDlDLE1BRVM7VUFBRSxLQUFLLElBQUlqRSxHQUFHLEdBQUdtYyxLQUFLLENBQUN6cEUsTUFBTixHQUFlLENBQTlCLEVBQWlDc3RELEdBQUcsSUFBSSxDQUF4QyxFQUEyQ0EsR0FBRyxFQUE5QyxFQUFrRDtZQUMzRCxJQUFJLENBQUM3USxJQUFJLEdBQUdndEIsS0FBSyxDQUFDbmMsR0FBRCxDQUFiLEVBQW9CcHVCLElBQXBCLElBQTRCdWQsSUFBSSxDQUFDOFUsS0FBckMsRUFBNEM7Y0FBRTs7Ozs7UUFFaEQsT0FBTzlVLElBQVA7OztNQUdGLFNBQVNpdUIsZ0JBQVQsQ0FBMEJuYixFQUExQixFQUE4QmliLFFBQTlCLEVBQXdDM2xELEVBQXhDLEVBQTRDbWxELElBQTVDLEVBQWtEO1FBQ2hELElBQUlxQixLQUFLLEdBQUdOLHNCQUFzQixDQUFDUCxRQUFRLENBQUM5ckQsR0FBVixFQUFlbUcsRUFBZixFQUFtQm1sRCxJQUFuQixDQUFsQztRQUNBLElBQUl6Z0QsSUFBSSxHQUFHOGhELEtBQUssQ0FBQzloRCxJQUFqQjtZQUF1QmpNLEtBQUssR0FBRyt0RCxLQUFLLENBQUMvdEQsS0FBckM7WUFBNEN6RSxHQUFHLEdBQUd3eUQsS0FBSyxDQUFDeHlELEdBQXhEO1lBQTZEd3ZDLFFBQVEsR0FBR2dqQixLQUFLLENBQUNoakIsUUFBOUU7UUFFQSxJQUFJNUwsSUFBSjs7UUFDQSxJQUFJbHpCLElBQUksQ0FBQytpQixRQUFMLElBQWlCLENBQXJCLEVBQXdCOztVQUN0QixLQUFLLElBQUlnaEIsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRyxDQUF4QixFQUEyQkEsR0FBRyxFQUE5QixFQUFrQzs7WUFDaEMsT0FBT2h3QyxLQUFLLElBQUlxdUMsZUFBZSxDQUFDNmUsUUFBUSxDQUFDN2IsSUFBVCxDQUFjdlEsSUFBZCxDQUFtQjc2QyxNQUFuQixDQUEwQjhuRSxLQUFLLENBQUNILFVBQU4sR0FBbUI1dEQsS0FBN0MsQ0FBRCxDQUEvQixFQUFzRjtjQUFFLEVBQUVBLEtBQUY7OztZQUN4RixPQUFPK3RELEtBQUssQ0FBQ0gsVUFBTixHQUFtQnJ5RCxHQUFuQixHQUF5Qnd5RCxLQUFLLENBQUNGLFFBQS9CLElBQTJDeGYsZUFBZSxDQUFDNmUsUUFBUSxDQUFDN2IsSUFBVCxDQUFjdlEsSUFBZCxDQUFtQjc2QyxNQUFuQixDQUEwQjhuRSxLQUFLLENBQUNILFVBQU4sR0FBbUJyeUQsR0FBN0MsQ0FBRCxDQUFqRSxFQUFzSDtjQUFFLEVBQUVBLEdBQUY7OztZQUN4SCxJQUFJb3RDLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQW5CLElBQXdCNW9DLEtBQUssSUFBSSxDQUFqQyxJQUFzQ3pFLEdBQUcsSUFBSXd5RCxLQUFLLENBQUNGLFFBQU4sR0FBaUJFLEtBQUssQ0FBQ0gsVUFBeEUsRUFDRTtjQUFFenVCLElBQUksR0FBR2x6QixJQUFJLENBQUNpbEIsVUFBTCxDQUFnQmtPLHFCQUFoQixFQUFQO2FBREosTUFHRTtjQUFFRCxJQUFJLEdBQUcydUIsYUFBYSxDQUFDanNCLEtBQUssQ0FBQzUxQixJQUFELEVBQU9qTSxLQUFQLEVBQWN6RSxHQUFkLENBQUwsQ0FBd0I2d0QsY0FBeEIsRUFBRCxFQUEyQ00sSUFBM0MsQ0FBcEI7OztZQUNKLElBQUl2dEIsSUFBSSxDQUFDdmQsSUFBTCxJQUFhdWQsSUFBSSxDQUFDOFUsS0FBbEIsSUFBMkJqMEMsS0FBSyxJQUFJLENBQXhDLEVBQTJDO2NBQUU7OztZQUM3Q3pFLEdBQUcsR0FBR3lFLEtBQU47WUFDQUEsS0FBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7WUFDQStxQyxRQUFRLEdBQUcsT0FBWDs7O1VBRUYsSUFBSXBDLEVBQUUsSUFBSUMsVUFBVSxHQUFHLEVBQXZCLEVBQTJCO1lBQUV6SixJQUFJLEdBQUc2dUIseUJBQXlCLENBQUMvYixFQUFFLENBQUMvb0QsT0FBSCxDQUFXdXFELE9BQVosRUFBcUJ0VSxJQUFyQixDQUFoQzs7U0FiL0IsTUFjTzs7VUFDTCxJQUFJbi9CLEtBQUssR0FBRyxDQUFaLEVBQWU7WUFBRStxQyxRQUFRLEdBQUcyaEIsSUFBSSxHQUFHLE9BQWxCOzs7VUFDakIsSUFBSVAsS0FBSjs7VUFDQSxJQUFJbGEsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUFYLElBQTJCLENBQUNHLEtBQUssR0FBR2xnRCxJQUFJLENBQUNtZ0QsY0FBTCxFQUFULEVBQWdDMXBFLE1BQWhDLEdBQXlDLENBQXhFLEVBQ0U7WUFBRXk4QyxJQUFJLEdBQUdndEIsS0FBSyxDQUFDTyxJQUFJLElBQUksT0FBUixHQUFrQlAsS0FBSyxDQUFDenBFLE1BQU4sR0FBZSxDQUFqQyxHQUFxQyxDQUF0QyxDQUFaO1dBREosTUFHRTtZQUFFeThDLElBQUksR0FBR2x6QixJQUFJLENBQUNtekIscUJBQUwsRUFBUDs7OztRQUVOLElBQUl1SixFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUFuQixJQUF3QixDQUFDNW9DLEtBQXpCLEtBQW1DLENBQUNtL0IsSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ3ZkLElBQU4sSUFBYyxDQUFDdWQsSUFBSSxDQUFDOFUsS0FBaEUsQ0FBSixFQUE0RTtVQUMxRSxJQUFJZ2EsS0FBSyxHQUFHaGlELElBQUksQ0FBQ2lsQixVQUFMLENBQWdCazdCLGNBQWhCLEdBQWlDLENBQWpDLENBQVo7O1VBQ0EsSUFBSTZCLEtBQUosRUFDRTtZQUFFOXVCLElBQUksR0FBRztjQUFDdmQsSUFBSSxFQUFFcXNDLEtBQUssQ0FBQ3JzQyxJQUFiO2NBQW1CcXlCLEtBQUssRUFBRWdhLEtBQUssQ0FBQ3JzQyxJQUFOLEdBQWFzc0MsU0FBUyxDQUFDamMsRUFBRSxDQUFDL29ELE9BQUosQ0FBaEQ7Y0FBOERzMkMsR0FBRyxFQUFFeXVCLEtBQUssQ0FBQ3p1QixHQUF6RTtjQUE4RTZzQixNQUFNLEVBQUU0QixLQUFLLENBQUM1QjthQUFuRztXQURKLE1BR0U7WUFBRWx0QixJQUFJLEdBQUdxdUIsUUFBUDs7OztRQUdOLElBQUlGLElBQUksR0FBR251QixJQUFJLENBQUNLLEdBQUwsR0FBVzB0QixRQUFRLENBQUMvdEIsSUFBVCxDQUFjSyxHQUFwQztZQUF5QzJ1QixJQUFJLEdBQUdodkIsSUFBSSxDQUFDa3RCLE1BQUwsR0FBY2EsUUFBUSxDQUFDL3RCLElBQVQsQ0FBY0ssR0FBNUU7UUFDQSxJQUFJbVAsR0FBRyxHQUFHLENBQUMyZSxJQUFJLEdBQUdhLElBQVIsSUFBZ0IsQ0FBMUI7UUFDQSxJQUFJakMsT0FBTyxHQUFHZ0IsUUFBUSxDQUFDOTJDLElBQVQsQ0FBY3E5QixPQUFkLENBQXNCeVksT0FBcEM7UUFDQSxJQUFJcG5FLENBQUMsR0FBRyxDQUFSOztRQUNBLE9BQU9BLENBQUMsR0FBR29uRSxPQUFPLENBQUN4cEUsTUFBUixHQUFpQixDQUE1QixFQUErQm9DLENBQUMsRUFBaEMsRUFDRTtVQUFFLElBQUk2cEQsR0FBRyxHQUFHdWQsT0FBTyxDQUFDcG5FLENBQUQsQ0FBakIsRUFBc0I7WUFBRTs7OztRQUM1QixJQUFJMDZDLEdBQUcsR0FBRzE2QyxDQUFDLEdBQUdvbkUsT0FBTyxDQUFDcG5FLENBQUMsR0FBRyxDQUFMLENBQVYsR0FBb0IsQ0FBL0I7WUFBa0NzcEUsR0FBRyxHQUFHbEMsT0FBTyxDQUFDcG5FLENBQUQsQ0FBL0M7UUFDQSxJQUFJNEMsTUFBTSxHQUFHO1VBQUNrNkIsSUFBSSxFQUFFLENBQUNtcEIsUUFBUSxJQUFJLE9BQVosR0FBc0I1TCxJQUFJLENBQUM4VSxLQUEzQixHQUFtQzlVLElBQUksQ0FBQ3ZkLElBQXpDLElBQWlEc3JDLFFBQVEsQ0FBQy90QixJQUFULENBQWN2ZCxJQUF0RTtVQUNDcXlCLEtBQUssRUFBRSxDQUFDbEosUUFBUSxJQUFJLE1BQVosR0FBcUI1TCxJQUFJLENBQUN2ZCxJQUExQixHQUFpQ3VkLElBQUksQ0FBQzhVLEtBQXZDLElBQWdEaVosUUFBUSxDQUFDL3RCLElBQVQsQ0FBY3ZkLElBRHRFO1VBRUM0ZCxHQUFHLEVBQUVBLEdBRk47VUFFVzZzQixNQUFNLEVBQUUrQjtTQUZoQzs7UUFHQSxJQUFJLENBQUNqdkIsSUFBSSxDQUFDdmQsSUFBTixJQUFjLENBQUN1ZCxJQUFJLENBQUM4VSxLQUF4QixFQUErQjtVQUFFdnNELE1BQU0sQ0FBQzJsRSxLQUFQLEdBQWUsSUFBZjs7O1FBQ2pDLElBQUksQ0FBQ3BiLEVBQUUsQ0FBQ2psQixPQUFILENBQVdxaEMseUJBQWhCLEVBQTJDO1VBQUUzbUUsTUFBTSxDQUFDNGxFLElBQVAsR0FBY0EsSUFBZDtVQUFvQjVsRSxNQUFNLENBQUM2bEUsT0FBUCxHQUFpQlksSUFBakI7OztRQUVqRSxPQUFPem1FLE1BQVA7T0F6OUVpQjs7OztNQTg5RW5CLFNBQVNzbUUseUJBQVQsQ0FBbUN2YSxPQUFuQyxFQUE0Q3RVLElBQTVDLEVBQWtEO1FBQ2hELElBQUksQ0FBQy9nRCxNQUFNLENBQUNrd0UsTUFBUixJQUFrQkEsTUFBTSxDQUFDQyxXQUFQLElBQXNCLElBQXhDLElBQ0FELE1BQU0sQ0FBQ0MsV0FBUCxJQUFzQkQsTUFBTSxDQUFDRSxVQUQ3QixJQUMyQyxDQUFDMVosaUJBQWlCLENBQUNyQixPQUFELENBRGpFLEVBRUU7VUFBRSxPQUFPdFUsSUFBUDs7O1FBQ0osSUFBSXN2QixNQUFNLEdBQUdILE1BQU0sQ0FBQ0MsV0FBUCxHQUFxQkQsTUFBTSxDQUFDRSxVQUF6QztRQUNBLElBQUlFLE1BQU0sR0FBR0osTUFBTSxDQUFDSyxXQUFQLEdBQXFCTCxNQUFNLENBQUNNLFVBQXpDO1FBQ0EsT0FBTztVQUFDaHRDLElBQUksRUFBRXVkLElBQUksQ0FBQ3ZkLElBQUwsR0FBWTZzQyxNQUFuQjtVQUEyQnhhLEtBQUssRUFBRTlVLElBQUksQ0FBQzhVLEtBQUwsR0FBYXdhLE1BQS9DO1VBQ0NqdkIsR0FBRyxFQUFFTCxJQUFJLENBQUNLLEdBQUwsR0FBV2t2QixNQURqQjtVQUN5QnJDLE1BQU0sRUFBRWx0QixJQUFJLENBQUNrdEIsTUFBTCxHQUFjcUM7U0FEdEQ7OztNQUlGLFNBQVNHLDRCQUFULENBQXNDdEwsUUFBdEMsRUFBZ0Q7UUFDOUMsSUFBSUEsUUFBUSxDQUFDOVAsT0FBYixFQUFzQjtVQUNwQjhQLFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUI0UCxLQUFqQixHQUF5QixFQUF6QjtVQUNBRSxRQUFRLENBQUM5UCxPQUFULENBQWlCeVksT0FBakIsR0FBMkIsSUFBM0I7O1VBQ0EsSUFBSTNJLFFBQVEsQ0FBQ00sSUFBYixFQUFtQjtZQUFFLEtBQUssSUFBSS8rRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeStELFFBQVEsQ0FBQ00sSUFBVCxDQUFjbmhFLE1BQWxDLEVBQTBDb0MsQ0FBQyxFQUEzQyxFQUNuQjtjQUFFeStELFFBQVEsQ0FBQzlQLE9BQVQsQ0FBaUI0USxNQUFqQixDQUF3QnYvRCxDQUF4QixJQUE2QixFQUE3Qjs7Ozs7O01BSVIsU0FBU2dxRSx5QkFBVCxDQUFtQzdjLEVBQW5DLEVBQXVDO1FBQ3JDQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXNmxFLGVBQVgsR0FBNkIsSUFBN0I7UUFDQXprQixjQUFjLENBQUMySCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXc2pFLFdBQVosQ0FBZDs7UUFDQSxLQUFLLElBQUkxbkUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR210RCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3RCLElBQVgsQ0FBZ0IxekIsTUFBcEMsRUFBNENvQyxDQUFDLEVBQTdDLEVBQ0U7VUFBRStwRSw0QkFBNEIsQ0FBQzVjLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdrdEIsSUFBWCxDQUFnQnR4QixDQUFoQixDQUFELENBQTVCOzs7O01BR04sU0FBU2txRSxXQUFULENBQXFCL2MsRUFBckIsRUFBeUI7UUFDdkI2Yyx5QkFBeUIsQ0FBQzdjLEVBQUQsQ0FBekI7UUFDQUEsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVytsRSxlQUFYLEdBQTZCaGQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2dtRSxnQkFBWCxHQUE4QmpkLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdnaUUsY0FBWCxHQUE0QixJQUF2Rjs7UUFDQSxJQUFJLENBQUNqWixFQUFFLENBQUNqbEIsT0FBSCxDQUFXZy9CLFlBQWhCLEVBQThCO1VBQUUvWixFQUFFLENBQUMvb0QsT0FBSCxDQUFXMDVELGNBQVgsR0FBNEIsSUFBNUI7OztRQUNoQzNRLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdpbUUsWUFBWCxHQUEwQixJQUExQjs7O01BR0YsU0FBU0MsV0FBVCxHQUF1Qjs7OztRQUlyQixJQUFJcG1CLE1BQU0sSUFBSVEsT0FBZCxFQUF1QjtVQUFFLE9BQU8sRUFBRS9wRCxRQUFRLENBQUNvOUMsSUFBVCxDQUFjdUMscUJBQWQsR0FBc0N4ZCxJQUF0QyxHQUE2Q2p3QixRQUFRLENBQUN3NUQsZ0JBQWdCLENBQUMxckUsUUFBUSxDQUFDbzlDLElBQVYsQ0FBaEIsQ0FBZ0N3dEIsVUFBakMsQ0FBdkQsQ0FBUDs7O1FBQ3pCLE9BQU9qc0UsTUFBTSxDQUFDaXhFLFdBQVAsSUFBc0IsQ0FBQzV2RSxRQUFRLENBQUNpSixlQUFULElBQTRCakosUUFBUSxDQUFDbzlDLElBQXRDLEVBQTRDeXlCLFVBQXpFOzs7TUFFRixTQUFTQyxXQUFULEdBQXVCO1FBQ3JCLElBQUl2bUIsTUFBTSxJQUFJUSxPQUFkLEVBQXVCO1VBQUUsT0FBTyxFQUFFL3BELFFBQVEsQ0FBQ285QyxJQUFULENBQWN1QyxxQkFBZCxHQUFzQ0ksR0FBdEMsR0FBNEM3dEMsUUFBUSxDQUFDdzVELGdCQUFnQixDQUFDMXJFLFFBQVEsQ0FBQ285QyxJQUFWLENBQWhCLENBQWdDMnlCLFNBQWpDLENBQXRELENBQVA7OztRQUN6QixPQUFPcHhFLE1BQU0sQ0FBQ3F4RSxXQUFQLElBQXNCLENBQUNod0UsUUFBUSxDQUFDaUosZUFBVCxJQUE0QmpKLFFBQVEsQ0FBQ285QyxJQUF0QyxFQUE0QzZ5QixTQUF6RTs7O01BR0YsU0FBU0MsZUFBVCxDQUF5QnBOLE9BQXpCLEVBQWtDO1FBQ2hDLElBQUlya0IsTUFBTSxHQUFHLENBQWI7O1FBQ0EsSUFBSXFrQixPQUFPLENBQUNzSCxPQUFaLEVBQXFCO1VBQUUsS0FBSyxJQUFJL2tFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5OUQsT0FBTyxDQUFDc0gsT0FBUixDQUFnQm5uRSxNQUFwQyxFQUE0QyxFQUFFb0MsQ0FBOUMsRUFBaUQ7WUFBRSxJQUFJeTlELE9BQU8sQ0FBQ3NILE9BQVIsQ0FBZ0Iva0UsQ0FBaEIsRUFBbUJrbEUsS0FBdkIsRUFDeEU7Y0FBRTlyQixNQUFNLElBQUlvc0IsWUFBWSxDQUFDL0gsT0FBTyxDQUFDc0gsT0FBUixDQUFnQi9rRSxDQUFoQixDQUFELENBQXRCOzs7OztRQUNKLE9BQU9vNUMsTUFBUDtPQS9nRmlCOzs7Ozs7TUFzaEZuQixTQUFTMHhCLGVBQVQsQ0FBeUIzZCxFQUF6QixFQUE2QnNRLE9BQTdCLEVBQXNDcGpCLElBQXRDLEVBQTRDOWpDLE9BQTVDLEVBQXFEdzBELGNBQXJELEVBQXFFO1FBQ25FLElBQUksQ0FBQ0EsY0FBTCxFQUFxQjtVQUNuQixJQUFJM3hCLE1BQU0sR0FBR3l4QixlQUFlLENBQUNwTixPQUFELENBQTVCO1VBQ0FwakIsSUFBSSxDQUFDSyxHQUFMLElBQVl0QixNQUFaO1VBQW9CaUIsSUFBSSxDQUFDa3RCLE1BQUwsSUFBZW51QixNQUFmOzs7UUFFdEIsSUFBSTdpQyxPQUFPLElBQUksTUFBZixFQUF1QjtVQUFFLE9BQU84akMsSUFBUDs7O1FBQ3pCLElBQUksQ0FBQzlqQyxPQUFMLEVBQWM7VUFBRUEsT0FBTyxHQUFHLE9BQVY7OztRQUNoQixJQUFJeTBELElBQUksR0FBR3hOLGFBQVksQ0FBQ0MsT0FBRCxDQUF2Qjs7UUFDQSxJQUFJbG5ELE9BQU8sSUFBSSxPQUFmLEVBQXdCO1VBQUV5MEQsSUFBSSxJQUFJakYsVUFBVSxDQUFDNVksRUFBRSxDQUFDL29ELE9BQUosQ0FBbEI7U0FBMUIsTUFDSztVQUFFNG1FLElBQUksSUFBSTdkLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc2bUUsVUFBbkI7OztRQUNQLElBQUkxMEQsT0FBTyxJQUFJLE1BQVgsSUFBcUJBLE9BQU8sSUFBSSxRQUFwQyxFQUE4QztVQUM1QyxJQUFJMjBELElBQUksR0FBRy9kLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc0aEUsU0FBWCxDQUFxQjFyQixxQkFBckIsRUFBWDtVQUNBMHdCLElBQUksSUFBSUUsSUFBSSxDQUFDeHdCLEdBQUwsSUFBWW5rQyxPQUFPLElBQUksUUFBWCxHQUFzQixDQUF0QixHQUEwQmswRCxXQUFXLEVBQWpELENBQVI7VUFDQSxJQUFJVSxJQUFJLEdBQUdELElBQUksQ0FBQ3B1QyxJQUFMLElBQWF2bUIsT0FBTyxJQUFJLFFBQVgsR0FBc0IsQ0FBdEIsR0FBMEIrekQsV0FBVyxFQUFsRCxDQUFYO1VBQ0Fqd0IsSUFBSSxDQUFDdmQsSUFBTCxJQUFhcXVDLElBQWI7VUFBbUI5d0IsSUFBSSxDQUFDOFUsS0FBTCxJQUFjZ2MsSUFBZDs7O1FBRXJCOXdCLElBQUksQ0FBQ0ssR0FBTCxJQUFZc3dCLElBQVo7UUFBa0Izd0IsSUFBSSxDQUFDa3RCLE1BQUwsSUFBZXlELElBQWY7UUFDbEIsT0FBTzN3QixJQUFQO09BdmlGaUI7Ozs7TUE0aUZuQixTQUFTK3dCLGVBQVQsQ0FBeUJqZSxFQUF6QixFQUE2QmtlLE1BQTdCLEVBQXFDOTBELE9BQXJDLEVBQThDO1FBQzVDLElBQUlBLE9BQU8sSUFBSSxLQUFmLEVBQXNCO1VBQUUsT0FBTzgwRCxNQUFQOzs7UUFDeEIsSUFBSXZ1QyxJQUFJLEdBQUd1dUMsTUFBTSxDQUFDdnVDLElBQWxCO1lBQXdCNGQsR0FBRyxHQUFHMndCLE1BQU0sQ0FBQzN3QixHQUFyQyxDQUY0Qzs7UUFJNUMsSUFBSW5rQyxPQUFPLElBQUksTUFBZixFQUF1QjtVQUNyQnVtQixJQUFJLElBQUl3dEMsV0FBVyxFQUFuQjtVQUNBNXZCLEdBQUcsSUFBSSt2QixXQUFXLEVBQWxCO1NBRkYsTUFHTyxJQUFJbDBELE9BQU8sSUFBSSxPQUFYLElBQXNCLENBQUNBLE9BQTNCLEVBQW9DO1VBQ3pDLElBQUkrMEQsUUFBUSxHQUFHbmUsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3loRSxLQUFYLENBQWlCdnJCLHFCQUFqQixFQUFmO1VBQ0F4ZCxJQUFJLElBQUl3dUMsUUFBUSxDQUFDeHVDLElBQWpCO1VBQ0E0ZCxHQUFHLElBQUk0d0IsUUFBUSxDQUFDNXdCLEdBQWhCOzs7UUFHRixJQUFJNndCLFlBQVksR0FBR3BlLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc0aEUsU0FBWCxDQUFxQjFyQixxQkFBckIsRUFBbkI7UUFDQSxPQUFPO1VBQUN4ZCxJQUFJLEVBQUVBLElBQUksR0FBR3l1QyxZQUFZLENBQUN6dUMsSUFBM0I7VUFBaUM0ZCxHQUFHLEVBQUVBLEdBQUcsR0FBRzZ3QixZQUFZLENBQUM3d0I7U0FBaEU7OztNQUdGLFNBQVM4d0IsV0FBVCxDQUFvQnJlLEVBQXBCLEVBQXdCcjVDLEdBQXhCLEVBQTZCeUMsT0FBN0IsRUFBc0NrbkQsT0FBdEMsRUFBK0NtSyxJQUEvQyxFQUFxRDtRQUNuRCxJQUFJLENBQUNuSyxPQUFMLEVBQWM7VUFBRUEsT0FBTyxHQUFHckssT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTdi9DLEdBQUcsQ0FBQ3k0QyxJQUFiLENBQWpCOzs7UUFDaEIsT0FBT3VlLGVBQWUsQ0FBQzNkLEVBQUQsRUFBS3NRLE9BQUwsRUFBY2tLLFdBQVcsQ0FBQ3hhLEVBQUQsRUFBS3NRLE9BQUwsRUFBYzNwRCxHQUFHLENBQUMyTyxFQUFsQixFQUFzQm1sRCxJQUF0QixDQUF6QixFQUFzRHJ4RCxPQUF0RCxDQUF0QjtPQS9qRmlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFrbEZuQixTQUFTazFELGFBQVQsQ0FBc0J0ZSxFQUF0QixFQUEwQnI1QyxHQUExQixFQUErQnlDLE9BQS9CLEVBQXdDa25ELE9BQXhDLEVBQWlEaU8sZUFBakQsRUFBa0VyRCxTQUFsRSxFQUE2RTtRQUMzRTVLLE9BQU8sR0FBR0EsT0FBTyxJQUFJckssT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTdi9DLEdBQUcsQ0FBQ3k0QyxJQUFiLENBQTVCOztRQUNBLElBQUksQ0FBQ21mLGVBQUwsRUFBc0I7VUFBRUEsZUFBZSxHQUFHNUQscUJBQXFCLENBQUMzYSxFQUFELEVBQUtzUSxPQUFMLENBQXZDOzs7UUFDeEIsU0FBU3JqRSxHQUFULENBQWFxb0IsRUFBYixFQUFpQjBzQyxLQUFqQixFQUF3QjtVQUN0QixJQUFJcC9DLENBQUMsR0FBRzgzRCxtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS3VlLGVBQUwsRUFBc0JqcEQsRUFBdEIsRUFBMEIwc0MsS0FBSyxHQUFHLE9BQUgsR0FBYSxNQUE1QyxFQUFvRGtaLFNBQXBELENBQTNCOztVQUNBLElBQUlsWixLQUFKLEVBQVc7WUFBRXAvQyxDQUFDLENBQUMrc0IsSUFBRixHQUFTL3NCLENBQUMsQ0FBQ28vQyxLQUFYO1dBQWIsTUFBc0M7WUFBRXAvQyxDQUFDLENBQUNvL0MsS0FBRixHQUFVcC9DLENBQUMsQ0FBQytzQixJQUFaOzs7VUFDeEMsT0FBT2d1QyxlQUFlLENBQUMzZCxFQUFELEVBQUtzUSxPQUFMLEVBQWMxdEQsQ0FBZCxFQUFpQndHLE9BQWpCLENBQXRCOzs7UUFFRixJQUFJd3pDLEtBQUssR0FBR3VDLFFBQVEsQ0FBQ21SLE9BQUQsRUFBVXRRLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3RJLFNBQWpCLENBQXBCO1lBQWlEdG9DLEVBQUUsR0FBRzNPLEdBQUcsQ0FBQzJPLEVBQTFEO1lBQThEcEUsTUFBTSxHQUFHdkssR0FBRyxDQUFDdUssTUFBM0U7O1FBQ0EsSUFBSW9FLEVBQUUsSUFBSWc3QyxPQUFPLENBQUN6aEIsSUFBUixDQUFhcCtDLE1BQXZCLEVBQStCO1VBQzdCNmtCLEVBQUUsR0FBR2c3QyxPQUFPLENBQUN6aEIsSUFBUixDQUFhcCtDLE1BQWxCO1VBQ0F5Z0IsTUFBTSxHQUFHLFFBQVQ7U0FGRixNQUdPLElBQUlvRSxFQUFFLElBQUksQ0FBVixFQUFhO1VBQ2xCQSxFQUFFLEdBQUcsQ0FBTDtVQUNBcEUsTUFBTSxHQUFHLE9BQVQ7OztRQUVGLElBQUksQ0FBQzByQyxLQUFMLEVBQVk7VUFBRSxPQUFPM3ZELEdBQUcsQ0FBQ2lrQixNQUFNLElBQUksUUFBVixHQUFxQm9FLEVBQUUsR0FBRyxDQUExQixHQUE4QkEsRUFBL0IsRUFBbUNwRSxNQUFNLElBQUksUUFBN0MsQ0FBVjs7O1FBRWQsU0FBU3N0RCxPQUFULENBQWlCbHBELEVBQWpCLEVBQXFCbXBELE9BQXJCLEVBQThCenVCLE1BQTlCLEVBQXNDO1VBQ3BDLElBQUk5VSxJQUFJLEdBQUcwaEIsS0FBSyxDQUFDNmhCLE9BQUQsQ0FBaEI7Y0FBMkJ6YyxLQUFLLEdBQUc5bUIsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUFqRDtVQUNBLE9BQU83dkQsR0FBRyxDQUFDK2lELE1BQU0sR0FBRzE2QixFQUFFLEdBQUcsQ0FBUixHQUFZQSxFQUFuQixFQUF1QjBzQyxLQUFLLElBQUloUyxNQUFoQyxDQUFWOzs7UUFFRixJQUFJeXVCLE9BQU8sR0FBR3poQixhQUFhLENBQUNKLEtBQUQsRUFBUXRuQyxFQUFSLEVBQVlwRSxNQUFaLENBQTNCO1FBQ0EsSUFBSXd0RCxLQUFLLEdBQUczaEIsU0FBWjtRQUNBLElBQUlodkQsR0FBRyxHQUFHeXdFLE9BQU8sQ0FBQ2xwRCxFQUFELEVBQUttcEQsT0FBTCxFQUFjdnRELE1BQU0sSUFBSSxRQUF4QixDQUFqQjs7UUFDQSxJQUFJd3RELEtBQUssSUFBSSxJQUFiLEVBQW1CO1VBQUUzd0UsR0FBRyxDQUFDMndFLEtBQUosR0FBWUYsT0FBTyxDQUFDbHBELEVBQUQsRUFBS29wRCxLQUFMLEVBQVl4dEQsTUFBTSxJQUFJLFFBQXRCLENBQW5COzs7UUFDckIsT0FBT25qQixHQUFQO09BNW1GaUI7Ozs7TUFpbkZuQixTQUFTNHdFLGNBQVQsQ0FBd0IzZSxFQUF4QixFQUE0QnI1QyxHQUE1QixFQUFpQztRQUMvQixJQUFJZ3BCLElBQUksR0FBRyxDQUFYO1FBQ0FocEIsR0FBRyxHQUFHaWhELFFBQU8sQ0FBQzVILEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3YvQyxHQUFULENBQWI7O1FBQ0EsSUFBSSxDQUFDcTVDLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBaEIsRUFBOEI7VUFBRXBxQyxJQUFJLEdBQUdzc0MsU0FBUyxDQUFDamMsRUFBRSxDQUFDL29ELE9BQUosQ0FBVCxHQUF3QjBQLEdBQUcsQ0FBQzJPLEVBQW5DOzs7UUFDaEMsSUFBSWc3QyxPQUFPLEdBQUdySyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVN2L0MsR0FBRyxDQUFDeTRDLElBQWIsQ0FBckI7UUFDQSxJQUFJN1IsR0FBRyxHQUFHOGlCLGFBQVksQ0FBQ0MsT0FBRCxDQUFaLEdBQXdCc0ksVUFBVSxDQUFDNVksRUFBRSxDQUFDL29ELE9BQUosQ0FBNUM7UUFDQSxPQUFPO1VBQUMwNEIsSUFBSSxFQUFFQSxJQUFQO1VBQWFxeUIsS0FBSyxFQUFFcnlCLElBQXBCO1VBQTBCNGQsR0FBRyxFQUFFQSxHQUEvQjtVQUFvQzZzQixNQUFNLEVBQUU3c0IsR0FBRyxHQUFHK2lCLE9BQU8sQ0FBQ3JrQjtTQUFqRTtPQXZuRmlCOzs7Ozs7OztNQWdvRm5CLFNBQVMyeUIsV0FBVCxDQUFxQnhmLElBQXJCLEVBQTJCOXBDLEVBQTNCLEVBQStCcEUsTUFBL0IsRUFBdUMydEQsT0FBdkMsRUFBZ0RDLElBQWhELEVBQXNEO1FBQ3BELElBQUluNEQsR0FBRyxHQUFHMGdELEdBQUcsQ0FBQ2pJLElBQUQsRUFBTzlwQyxFQUFQLEVBQVdwRSxNQUFYLENBQWI7UUFDQXZLLEdBQUcsQ0FBQ200RCxJQUFKLEdBQVdBLElBQVg7O1FBQ0EsSUFBSUQsT0FBSixFQUFhO1VBQUVsNEQsR0FBRyxDQUFDazRELE9BQUosR0FBY0EsT0FBZDs7O1FBQ2YsT0FBT2w0RCxHQUFQO09BcG9GaUI7Ozs7TUF5b0ZuQixTQUFTbzRELFdBQVQsQ0FBb0IvZSxFQUFwQixFQUF3QmhqRCxDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEI7UUFDNUIsSUFBSWlwRCxHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFiO1FBQ0FqcEQsQ0FBQyxJQUFJK2lELEVBQUUsQ0FBQy9vRCxPQUFILENBQVc2bUUsVUFBaEI7O1FBQ0EsSUFBSTdnRSxDQUFDLEdBQUcsQ0FBUixFQUFXO1VBQUUsT0FBTzJoRSxXQUFXLENBQUMxWSxHQUFHLENBQUN2bEQsS0FBTCxFQUFZLENBQVosRUFBZSxJQUFmLEVBQXFCLENBQUMsQ0FBdEIsRUFBeUIsQ0FBQyxDQUExQixDQUFsQjs7O1FBQ2IsSUFBSW12RCxLQUFLLEdBQUdoSixhQUFZLENBQUNaLEdBQUQsRUFBTWpwRCxDQUFOLENBQXhCO1lBQWtDcWMsSUFBSSxHQUFHNHNDLEdBQUcsQ0FBQ3ZsRCxLQUFKLEdBQVl1bEQsR0FBRyxDQUFDdjdDLElBQWhCLEdBQXVCLENBQWhFOztRQUNBLElBQUltbEQsS0FBSyxHQUFHeDJDLElBQVosRUFDRTtVQUFFLE9BQU9zbEQsV0FBVyxDQUFDMVksR0FBRyxDQUFDdmxELEtBQUosR0FBWXVsRCxHQUFHLENBQUN2N0MsSUFBaEIsR0FBdUIsQ0FBeEIsRUFBMkJzN0MsT0FBTyxDQUFDQyxHQUFELEVBQU01c0MsSUFBTixDQUFQLENBQW1CdTFCLElBQW5CLENBQXdCcCtDLE1BQW5ELEVBQTJELElBQTNELEVBQWlFLENBQWpFLEVBQW9FLENBQXBFLENBQWxCOzs7UUFDSixJQUFJdU0sQ0FBQyxHQUFHLENBQVIsRUFBVztVQUFFQSxDQUFDLEdBQUcsQ0FBSjs7O1FBRWIsSUFBSXN6RCxPQUFPLEdBQUdySyxPQUFPLENBQUNDLEdBQUQsRUFBTTRKLEtBQU4sQ0FBckI7O1FBQ0EsU0FBUztVQUNQLElBQUlqVCxLQUFLLEdBQUdtaUIsZUFBZSxDQUFDaGYsRUFBRCxFQUFLc1EsT0FBTCxFQUFjUixLQUFkLEVBQXFCOXlELENBQXJCLEVBQXdCQyxDQUF4QixDQUEzQjtVQUNBLElBQUlteUQsU0FBUyxHQUFHRyxtQkFBbUIsQ0FBQ2UsT0FBRCxFQUFVelQsS0FBSyxDQUFDdm5DLEVBQU4sSUFBWXVuQyxLQUFLLENBQUNpaUIsSUFBTixHQUFhLENBQWIsSUFBa0JqaUIsS0FBSyxDQUFDZ2lCLE9BQU4sR0FBZ0IsQ0FBbEMsR0FBc0MsQ0FBdEMsR0FBMEMsQ0FBdEQsQ0FBVixDQUFuQzs7VUFDQSxJQUFJLENBQUN6UCxTQUFMLEVBQWdCO1lBQUUsT0FBT3ZTLEtBQVA7OztVQUNsQixJQUFJb2lCLFFBQVEsR0FBRzdQLFNBQVMsQ0FBQ3orQyxJQUFWLENBQWUsQ0FBZixDQUFmOztVQUNBLElBQUlzdUQsUUFBUSxDQUFDN2YsSUFBVCxJQUFpQjBRLEtBQXJCLEVBQTRCO1lBQUUsT0FBT21QLFFBQVA7OztVQUM5QjNPLE9BQU8sR0FBR3JLLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNNEosS0FBSyxHQUFHbVAsUUFBUSxDQUFDN2YsSUFBdkIsQ0FBakI7Ozs7TUFJSixTQUFTOGYsaUJBQVQsQ0FBMkJsZixFQUEzQixFQUErQnNRLE9BQS9CLEVBQXdDaU8sZUFBeEMsRUFBeUR0aEUsQ0FBekQsRUFBNEQ7UUFDMURBLENBQUMsSUFBSXlnRSxlQUFlLENBQUNwTixPQUFELENBQXBCO1FBQ0EsSUFBSWhuRCxHQUFHLEdBQUdnbkQsT0FBTyxDQUFDemhCLElBQVIsQ0FBYXArQyxNQUF2QjtRQUNBLElBQUlvZCxLQUFLLEdBQUcwdUMsU0FBUyxDQUFDLFVBQVVqbkMsRUFBVixFQUFjO1VBQUUsT0FBT29sRCxtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS3VlLGVBQUwsRUFBc0JqcEQsRUFBRSxHQUFHLENBQTNCLENBQW5CLENBQWlEOGtELE1BQWpELElBQTJEbjlELENBQWxFO1NBQWpCLEVBQXlGcU0sR0FBekYsRUFBOEYsQ0FBOUYsQ0FBckI7UUFDQUEsR0FBRyxHQUFHaXpDLFNBQVMsQ0FBQyxVQUFVam5DLEVBQVYsRUFBYztVQUFFLE9BQU9vbEQsbUJBQW1CLENBQUMxYSxFQUFELEVBQUt1ZSxlQUFMLEVBQXNCanBELEVBQXRCLENBQW5CLENBQTZDaTRCLEdBQTdDLEdBQW1EdHdDLENBQTFEO1NBQWpCLEVBQWlGNFEsS0FBakYsRUFBd0Z2RSxHQUF4RixDQUFmO1FBQ0EsT0FBTztVQUFDdUUsS0FBSyxFQUFFQSxLQUFSO1VBQWV2RSxHQUFHLEVBQUVBO1NBQTNCOzs7TUFHRixTQUFTNjFELHFCQUFULENBQStCbmYsRUFBL0IsRUFBbUNzUSxPQUFuQyxFQUE0Q2lPLGVBQTVDLEVBQTZEM3NFLE1BQTdELEVBQXFFO1FBQ25FLElBQUksQ0FBQzJzRSxlQUFMLEVBQXNCO1VBQUVBLGVBQWUsR0FBRzVELHFCQUFxQixDQUFDM2EsRUFBRCxFQUFLc1EsT0FBTCxDQUF2Qzs7O1FBQ3hCLElBQUk4TyxTQUFTLEdBQUd6QixlQUFlLENBQUMzZCxFQUFELEVBQUtzUSxPQUFMLEVBQWNvSyxtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS3VlLGVBQUwsRUFBc0Izc0UsTUFBdEIsQ0FBakMsRUFBZ0UsTUFBaEUsQ0FBZixDQUF1RjI3QyxHQUF2RztRQUNBLE9BQU8yeEIsaUJBQWlCLENBQUNsZixFQUFELEVBQUtzUSxPQUFMLEVBQWNpTyxlQUFkLEVBQStCYSxTQUEvQixDQUF4QjtPQXhxRmlCOzs7O01BNnFGbkIsU0FBU0MsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUJ0aUUsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCMHlCLElBQS9CLEVBQXFDO1FBQ25DLE9BQU8ydkMsR0FBRyxDQUFDbEYsTUFBSixJQUFjbjlELENBQWQsR0FBa0IsS0FBbEIsR0FBMEJxaUUsR0FBRyxDQUFDL3hCLEdBQUosR0FBVXR3QyxDQUFWLEdBQWMsSUFBZCxHQUFxQixDQUFDMHlCLElBQUksR0FBRzJ2QyxHQUFHLENBQUMzdkMsSUFBUCxHQUFjMnZDLEdBQUcsQ0FBQ3RkLEtBQXZCLElBQWdDaGxELENBQXRGOzs7TUFHRixTQUFTZ2lFLGVBQVQsQ0FBeUJoZixFQUF6QixFQUE2QnNRLE9BQTdCLEVBQXNDMUosTUFBdEMsRUFBOEM1cEQsQ0FBOUMsRUFBaURDLENBQWpELEVBQW9EOztRQUVsREEsQ0FBQyxJQUFJb3pELGFBQVksQ0FBQ0MsT0FBRCxDQUFqQjtRQUNBLElBQUlpTyxlQUFlLEdBQUc1RCxxQkFBcUIsQ0FBQzNhLEVBQUQsRUFBS3NRLE9BQUwsQ0FBM0MsQ0FIa0Q7OztRQU1sRCxJQUFJK0gsWUFBWSxHQUFHcUYsZUFBZSxDQUFDcE4sT0FBRCxDQUFsQztRQUNBLElBQUl6aUQsS0FBSyxHQUFHLENBQVo7WUFBZXZFLEdBQUcsR0FBR2duRCxPQUFPLENBQUN6aEIsSUFBUixDQUFhcCtDLE1BQWxDO1lBQTBDOHVFLEdBQUcsR0FBRyxJQUFoRDtRQUVBLElBQUkzaUIsS0FBSyxHQUFHdUMsUUFBUSxDQUFDbVIsT0FBRCxFQUFVdFEsRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBakIsQ0FBcEIsQ0FUa0Q7OztRQVlsRCxJQUFJaEIsS0FBSixFQUFXO1VBQ1QsSUFBSTFoQixJQUFJLEdBQUcsQ0FBQzhrQixFQUFFLENBQUNqbEIsT0FBSCxDQUFXZy9CLFlBQVgsR0FBMEJ5RixxQkFBMUIsR0FBa0RDLGNBQW5ELEVBQ0d6ZixFQURILEVBQ09zUSxPQURQLEVBQ2dCMUosTUFEaEIsRUFDd0IyWCxlQUR4QixFQUN5QzNoQixLQUR6QyxFQUNnRDUvQyxDQURoRCxFQUNtREMsQ0FEbkQsQ0FBWDtVQUVBc2lFLEdBQUcsR0FBR3JrQyxJQUFJLENBQUM0aEIsS0FBTCxJQUFjLENBQXBCLENBSFM7Ozs7O1VBUVRqdkMsS0FBSyxHQUFHMHhELEdBQUcsR0FBR3JrQyxJQUFJLENBQUN0dUIsSUFBUixHQUFlc3VCLElBQUksQ0FBQzlxQixFQUFMLEdBQVUsQ0FBcEM7VUFDQTlHLEdBQUcsR0FBR2kyRCxHQUFHLEdBQUdya0MsSUFBSSxDQUFDOXFCLEVBQVIsR0FBYThxQixJQUFJLENBQUN0dUIsSUFBTCxHQUFZLENBQWxDO1NBckJnRDs7Ozs7UUEyQmxELElBQUk4eUQsUUFBUSxHQUFHLElBQWY7WUFBcUJDLFNBQVMsR0FBRyxJQUFqQztRQUNBLElBQUlycUQsRUFBRSxHQUFHaW5DLFNBQVMsQ0FBQyxVQUFVam5DLEVBQVYsRUFBYztVQUMvQixJQUFJZ3FELEdBQUcsR0FBRzVFLG1CQUFtQixDQUFDMWEsRUFBRCxFQUFLdWUsZUFBTCxFQUFzQmpwRCxFQUF0QixDQUE3QjtVQUNBZ3FELEdBQUcsQ0FBQy94QixHQUFKLElBQVc4cUIsWUFBWDtVQUF5QmlILEdBQUcsQ0FBQ2xGLE1BQUosSUFBYy9CLFlBQWQ7O1VBQ3pCLElBQUksQ0FBQ2dILFVBQVUsQ0FBQ0MsR0FBRCxFQUFNdGlFLENBQU4sRUFBU0MsQ0FBVCxFQUFZLEtBQVosQ0FBZixFQUFtQztZQUFFLE9BQU8sS0FBUDs7O1VBQ3JDLElBQUlxaUUsR0FBRyxDQUFDL3hCLEdBQUosSUFBV3R3QyxDQUFYLElBQWdCcWlFLEdBQUcsQ0FBQzN2QyxJQUFKLElBQVkzeUIsQ0FBaEMsRUFBbUM7WUFDakMwaUUsUUFBUSxHQUFHcHFELEVBQVg7WUFDQXFxRCxTQUFTLEdBQUdMLEdBQVo7OztVQUVGLE9BQU8sSUFBUDtTQVJnQixFQVNmenhELEtBVGUsRUFTUnZFLEdBVFEsQ0FBbEI7UUFXQSxJQUFJczJELEtBQUo7WUFBVzF1RCxNQUFYO1lBQW1CMnRELE9BQU8sR0FBRyxLQUE3QixDQXZDa0Q7O1FBeUNsRCxJQUFJYyxTQUFKLEVBQWU7O1VBRWIsSUFBSUUsTUFBTSxHQUFHN2lFLENBQUMsR0FBRzJpRSxTQUFTLENBQUNod0MsSUFBZCxHQUFxQmd3QyxTQUFTLENBQUMzZCxLQUFWLEdBQWtCaGxELENBQXBEO2NBQXVEOGlFLE9BQU8sR0FBR0QsTUFBTSxJQUFJTixHQUEzRTtVQUNBanFELEVBQUUsR0FBR29xRCxRQUFRLElBQUlJLE9BQU8sR0FBRyxDQUFILEdBQU8sQ0FBbEIsQ0FBYjtVQUNBNXVELE1BQU0sR0FBRzR1RCxPQUFPLEdBQUcsT0FBSCxHQUFhLFFBQTdCO1VBQ0FGLEtBQUssR0FBR0MsTUFBTSxHQUFHRixTQUFTLENBQUNod0MsSUFBYixHQUFvQmd3QyxTQUFTLENBQUMzZCxLQUE1QztTQUxGLE1BTU87O1VBRUwsSUFBSSxDQUFDdWQsR0FBRCxLQUFTanFELEVBQUUsSUFBSWhNLEdBQU4sSUFBYWdNLEVBQUUsSUFBSXpILEtBQTVCLENBQUosRUFBd0M7WUFBRXlILEVBQUU7V0FGdkM7Ozs7O1VBTUxwRSxNQUFNLEdBQUdvRSxFQUFFLElBQUksQ0FBTixHQUFVLE9BQVYsR0FBb0JBLEVBQUUsSUFBSWc3QyxPQUFPLENBQUN6aEIsSUFBUixDQUFhcCtDLE1BQW5CLEdBQTRCLFFBQTVCLEdBQzFCaXFFLG1CQUFtQixDQUFDMWEsRUFBRCxFQUFLdWUsZUFBTCxFQUFzQmpwRCxFQUFFLElBQUlpcUQsR0FBRyxHQUFHLENBQUgsR0FBTyxDQUFkLENBQXhCLENBQW5CLENBQTZEbkYsTUFBN0QsR0FBc0UvQixZQUF0RSxJQUFzRnA3RCxDQUF2RixJQUE2RnNpRSxHQUE3RixHQUNBLE9BREEsR0FDVSxRQUZaLENBTks7OztVQVdMLElBQUlyQixNQUFNLEdBQUdJLGFBQVksQ0FBQ3RlLEVBQUQsRUFBS3FILEdBQUcsQ0FBQ1QsTUFBRCxFQUFTdHhDLEVBQVQsRUFBYXBFLE1BQWIsQ0FBUixFQUE4QixNQUE5QixFQUFzQ28vQyxPQUF0QyxFQUErQ2lPLGVBQS9DLENBQXpCOztVQUNBcUIsS0FBSyxHQUFHMUIsTUFBTSxDQUFDdnVDLElBQWY7VUFDQWt2QyxPQUFPLEdBQUc1aEUsQ0FBQyxHQUFHaWhFLE1BQU0sQ0FBQzN3QixHQUFYLEdBQWlCLENBQUMsQ0FBbEIsR0FBc0J0d0MsQ0FBQyxJQUFJaWhFLE1BQU0sQ0FBQzlELE1BQVosR0FBcUIsQ0FBckIsR0FBeUIsQ0FBekQ7OztRQUdGOWtELEVBQUUsR0FBRyttQyxrQkFBa0IsQ0FBQ2lVLE9BQU8sQ0FBQ3poQixJQUFULEVBQWV2NUIsRUFBZixFQUFtQixDQUFuQixDQUF2QjtRQUNBLE9BQU9zcEQsV0FBVyxDQUFDaFksTUFBRCxFQUFTdHhDLEVBQVQsRUFBYXBFLE1BQWIsRUFBcUIydEQsT0FBckIsRUFBOEI3aEUsQ0FBQyxHQUFHNGlFLEtBQWxDLENBQWxCOzs7TUFHRixTQUFTSCxjQUFULENBQXdCemYsRUFBeEIsRUFBNEJzUSxPQUE1QixFQUFxQzFKLE1BQXJDLEVBQTZDMlgsZUFBN0MsRUFBOEQzaEIsS0FBOUQsRUFBcUU1L0MsQ0FBckUsRUFBd0VDLENBQXhFLEVBQTJFOzs7OztRQUt6RSxJQUFJcEksS0FBSyxHQUFHMG5ELFNBQVMsQ0FBQyxVQUFVMXBELENBQVYsRUFBYTtVQUNqQyxJQUFJcW9DLElBQUksR0FBRzBoQixLQUFLLENBQUMvcEQsQ0FBRCxDQUFoQjtjQUFxQjBzRSxHQUFHLEdBQUdya0MsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUF6QztVQUNBLE9BQU91aUIsVUFBVSxDQUFDZixhQUFZLENBQUN0ZSxFQUFELEVBQUtxSCxHQUFHLENBQUNULE1BQUQsRUFBUzJZLEdBQUcsR0FBR3JrQyxJQUFJLENBQUM5cUIsRUFBUixHQUFhOHFCLElBQUksQ0FBQ3R1QixJQUE5QixFQUFvQzJ5RCxHQUFHLEdBQUcsUUFBSCxHQUFjLE9BQXJELENBQVIsRUFDQyxNQURELEVBQ1NqUCxPQURULEVBQ2tCaU8sZUFEbEIsQ0FBYixFQUNpRHZoRSxDQURqRCxFQUNvREMsQ0FEcEQsRUFDdUQsSUFEdkQsQ0FBakI7U0FGbUIsRUFJbEIsQ0FKa0IsRUFJZjIvQyxLQUFLLENBQUNuc0QsTUFBTixHQUFlLENBSkEsQ0FBckI7UUFLQSxJQUFJeXFDLElBQUksR0FBRzBoQixLQUFLLENBQUMvbkQsS0FBRCxDQUFoQixDQVZ5RTs7OztRQWN6RSxJQUFJQSxLQUFLLEdBQUcsQ0FBWixFQUFlO1VBQ2IsSUFBSTBxRSxHQUFHLEdBQUdya0MsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUF4Qjs7VUFDQSxJQUFJL3VDLEtBQUssR0FBR3V3RCxhQUFZLENBQUN0ZSxFQUFELEVBQUtxSCxHQUFHLENBQUNULE1BQUQsRUFBUzJZLEdBQUcsR0FBR3JrQyxJQUFJLENBQUN0dUIsSUFBUixHQUFlc3VCLElBQUksQ0FBQzlxQixFQUFoQyxFQUFvQ212RCxHQUFHLEdBQUcsT0FBSCxHQUFhLFFBQXBELENBQVIsRUFDQyxNQURELEVBQ1NqUCxPQURULEVBQ2tCaU8sZUFEbEIsQ0FBeEI7O1VBRUEsSUFBSWMsVUFBVSxDQUFDdHhELEtBQUQsRUFBUS9RLENBQVIsRUFBV0MsQ0FBWCxFQUFjLElBQWQsQ0FBVixJQUFpQzhRLEtBQUssQ0FBQ3cvQixHQUFOLEdBQVl0d0MsQ0FBakQsRUFDRTtZQUFFaStCLElBQUksR0FBRzBoQixLQUFLLENBQUMvbkQsS0FBSyxHQUFHLENBQVQsQ0FBWjs7OztRQUVOLE9BQU9xbUMsSUFBUDs7O01BR0YsU0FBU3NrQyxxQkFBVCxDQUErQnhmLEVBQS9CLEVBQW1Dc1EsT0FBbkMsRUFBNEN5UCxPQUE1QyxFQUFxRHhCLGVBQXJELEVBQXNFM2hCLEtBQXRFLEVBQTZFNS9DLENBQTdFLEVBQWdGQyxDQUFoRixFQUFtRjs7Ozs7Ozs7UUFRakYsSUFBSXdqQyxHQUFHLEdBQUd5K0IsaUJBQWlCLENBQUNsZixFQUFELEVBQUtzUSxPQUFMLEVBQWNpTyxlQUFkLEVBQStCdGhFLENBQS9CLENBQTNCO1FBQ0EsSUFBSTRRLEtBQUssR0FBRzR5QixHQUFHLENBQUM1eUIsS0FBaEI7UUFDQSxJQUFJdkUsR0FBRyxHQUFHbTNCLEdBQUcsQ0FBQ24zQixHQUFkOztRQUNBLElBQUksS0FBS2pNLElBQUwsQ0FBVWl6RCxPQUFPLENBQUN6aEIsSUFBUixDQUFhNzZDLE1BQWIsQ0FBb0JzVixHQUFHLEdBQUcsQ0FBMUIsQ0FBVixDQUFKLEVBQTZDO1VBQUVBLEdBQUc7OztRQUNsRCxJQUFJNHhCLElBQUksR0FBRyxJQUFYO1lBQWlCOGtDLFdBQVcsR0FBRyxJQUEvQjs7UUFDQSxLQUFLLElBQUludEUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytwRCxLQUFLLENBQUNuc0QsTUFBMUIsRUFBa0NvQyxDQUFDLEVBQW5DLEVBQXVDO1VBQ3JDLElBQUkwZSxDQUFDLEdBQUdxckMsS0FBSyxDQUFDL3BELENBQUQsQ0FBYjs7VUFDQSxJQUFJMGUsQ0FBQyxDQUFDM0UsSUFBRixJQUFVdEQsR0FBVixJQUFpQmlJLENBQUMsQ0FBQ25CLEVBQUYsSUFBUXZDLEtBQTdCLEVBQW9DO1lBQUU7OztVQUN0QyxJQUFJMHhELEdBQUcsR0FBR2h1RCxDQUFDLENBQUN1ckMsS0FBRixJQUFXLENBQXJCO1VBQ0EsSUFBSW1qQixJQUFJLEdBQUd2RixtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS3VlLGVBQUwsRUFBc0JnQixHQUFHLEdBQUduekUsSUFBSSxDQUFDc0ksR0FBTCxDQUFTNFUsR0FBVCxFQUFjaUksQ0FBQyxDQUFDbkIsRUFBaEIsSUFBc0IsQ0FBekIsR0FBNkJoa0IsSUFBSSxDQUFDd0ksR0FBTCxDQUFTaVosS0FBVCxFQUFnQjBELENBQUMsQ0FBQzNFLElBQWxCLENBQXRELENBQW5CLENBQWtHbzFDLEtBQTdHLENBSnFDOzs7VUFPckMsSUFBSWtlLElBQUksR0FBR0QsSUFBSSxHQUFHampFLENBQVAsR0FBV0EsQ0FBQyxHQUFHaWpFLElBQUosR0FBVyxHQUF0QixHQUE0QkEsSUFBSSxHQUFHampFLENBQTlDOztVQUNBLElBQUksQ0FBQ2srQixJQUFELElBQVM4a0MsV0FBVyxHQUFHRSxJQUEzQixFQUFpQztZQUMvQmhsQyxJQUFJLEdBQUczcEIsQ0FBUDtZQUNBeXVELFdBQVcsR0FBR0UsSUFBZDs7OztRQUdKLElBQUksQ0FBQ2hsQyxJQUFMLEVBQVc7VUFBRUEsSUFBSSxHQUFHMGhCLEtBQUssQ0FBQ0EsS0FBSyxDQUFDbnNELE1BQU4sR0FBZSxDQUFoQixDQUFaO1NBMUJvRTs7O1FBNEJqRixJQUFJeXFDLElBQUksQ0FBQ3R1QixJQUFMLEdBQVlpQixLQUFoQixFQUF1QjtVQUFFcXRCLElBQUksR0FBRztZQUFDdHVCLElBQUksRUFBRWlCLEtBQVA7WUFBY3VDLEVBQUUsRUFBRThxQixJQUFJLENBQUM5cUIsRUFBdkI7WUFBMkIwc0MsS0FBSyxFQUFFNWhCLElBQUksQ0FBQzRoQjtXQUE5Qzs7O1FBQ3pCLElBQUk1aEIsSUFBSSxDQUFDOXFCLEVBQUwsR0FBVTlHLEdBQWQsRUFBbUI7VUFBRTR4QixJQUFJLEdBQUc7WUFBQ3R1QixJQUFJLEVBQUVzdUIsSUFBSSxDQUFDdHVCLElBQVo7WUFBa0J3RCxFQUFFLEVBQUU5RyxHQUF0QjtZQUEyQnd6QyxLQUFLLEVBQUU1aEIsSUFBSSxDQUFDNGhCO1dBQTlDOzs7UUFDckIsT0FBTzVoQixJQUFQOzs7TUFHRixJQUFJaWxDLFdBQUosQ0E3eUZtQjs7TUEreUZuQixTQUFTQyxVQUFULENBQW9CbnBFLE9BQXBCLEVBQTZCO1FBQzNCLElBQUlBLE9BQU8sQ0FBQ2dtRSxnQkFBUixJQUE0QixJQUFoQyxFQUFzQztVQUFFLE9BQU9obUUsT0FBTyxDQUFDZ21FLGdCQUFmOzs7UUFDeEMsSUFBSWtELFdBQVcsSUFBSSxJQUFuQixFQUF5QjtVQUN2QkEsV0FBVyxHQUFHNW5CLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLHNCQUFkLENBQWpCLENBRHVCOzs7VUFJdkIsS0FBSyxJQUFJMWxELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0IsRUFBRUEsQ0FBMUIsRUFBNkI7WUFDM0JzdEUsV0FBVyxDQUFDanBFLFdBQVosQ0FBd0IxSixRQUFRLENBQUN5c0IsY0FBVCxDQUF3QixHQUF4QixDQUF4QjtZQUNBa21ELFdBQVcsQ0FBQ2pwRSxXQUFaLENBQXdCcWhELEdBQUcsQ0FBQyxJQUFELENBQTNCOzs7VUFFRjRuQixXQUFXLENBQUNqcEUsV0FBWixDQUF3QjFKLFFBQVEsQ0FBQ3lzQixjQUFULENBQXdCLEdBQXhCLENBQXhCOzs7UUFFRnErQixvQkFBb0IsQ0FBQ3JoRCxPQUFPLENBQUN1cUQsT0FBVCxFQUFrQjJlLFdBQWxCLENBQXBCO1FBQ0EsSUFBSWwwQixNQUFNLEdBQUdrMEIsV0FBVyxDQUFDMWUsWUFBWixHQUEyQixFQUF4Qzs7UUFDQSxJQUFJeFYsTUFBTSxHQUFHLENBQWIsRUFBZ0I7VUFBRWgxQyxPQUFPLENBQUNnbUUsZ0JBQVIsR0FBMkJoeEIsTUFBM0I7OztRQUNsQm9NLGNBQWMsQ0FBQ3BoRCxPQUFPLENBQUN1cUQsT0FBVCxDQUFkO1FBQ0EsT0FBT3ZWLE1BQU0sSUFBSSxDQUFqQjtPQS96RmlCOzs7TUFtMEZuQixTQUFTZ3dCLFNBQVQsQ0FBbUJobEUsT0FBbkIsRUFBNEI7UUFDMUIsSUFBSUEsT0FBTyxDQUFDK2xFLGVBQVIsSUFBMkIsSUFBL0IsRUFBcUM7VUFBRSxPQUFPL2xFLE9BQU8sQ0FBQytsRSxlQUFmOzs7UUFDdkMsSUFBSTd5RCxNQUFNLEdBQUdvdUMsR0FBRyxDQUFDLE1BQUQsRUFBUyxZQUFULENBQWhCO1FBQ0EsSUFBSWlaLEdBQUcsR0FBR2paLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQ3B1QyxNQUFELENBQVIsRUFBa0Isc0JBQWxCLENBQWI7UUFDQW11QyxvQkFBb0IsQ0FBQ3JoRCxPQUFPLENBQUN1cUQsT0FBVCxFQUFrQmdRLEdBQWxCLENBQXBCO1FBQ0EsSUFBSXRrQixJQUFJLEdBQUcvaUMsTUFBTSxDQUFDZ2pDLHFCQUFQLEVBQVg7WUFBMkNwQixLQUFLLEdBQUcsQ0FBQ21CLElBQUksQ0FBQzhVLEtBQUwsR0FBYTlVLElBQUksQ0FBQ3ZkLElBQW5CLElBQTJCLEVBQTlFOztRQUNBLElBQUlvYyxLQUFLLEdBQUcsQ0FBWixFQUFlO1VBQUU5MEMsT0FBTyxDQUFDK2xFLGVBQVIsR0FBMEJqeEIsS0FBMUI7OztRQUNqQixPQUFPQSxLQUFLLElBQUksRUFBaEI7T0ExMEZpQjs7OztNQSswRm5CLFNBQVMrdUIsYUFBVCxDQUF1QjlhLEVBQXZCLEVBQTJCO1FBQ3pCLElBQUlwMEMsQ0FBQyxHQUFHbzBDLEVBQUUsQ0FBQy9vRCxPQUFYO1lBQW9CMDRCLElBQUksR0FBRyxFQUEzQjtZQUErQm9jLEtBQUssR0FBRyxFQUF2QztRQUNBLElBQUltckIsVUFBVSxHQUFHdHJELENBQUMsQ0FBQzJzRCxPQUFGLENBQVU4SCxVQUEzQjs7UUFDQSxLQUFLLElBQUlwaUUsQ0FBQyxHQUFHMk4sQ0FBQyxDQUFDMnNELE9BQUYsQ0FBVTc3QixVQUFsQixFQUE4QjdwQyxDQUFDLEdBQUcsQ0FBdkMsRUFBMENvTCxDQUExQyxFQUE2Q0EsQ0FBQyxHQUFHQSxDQUFDLENBQUN3aEMsV0FBTixFQUFtQixFQUFFNXNDLENBQWxFLEVBQXFFO1VBQ25FLElBQUk1RCxFQUFFLEdBQUcrd0QsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV21nRSxXQUFYLENBQXVCdmtFLENBQXZCLEVBQTBCc2xELFNBQW5DO1VBQ0F4b0IsSUFBSSxDQUFDMWdDLEVBQUQsQ0FBSixHQUFXZ1AsQ0FBQyxDQUFDcWlFLFVBQUYsR0FBZXJpRSxDQUFDLENBQUNvaUUsVUFBakIsR0FBOEJuSixVQUF6QztVQUNBbnJCLEtBQUssQ0FBQzk4QyxFQUFELENBQUwsR0FBWWdQLENBQUMsQ0FBQ3U2RCxXQUFkOzs7UUFFRixPQUFPO1VBQUM3QixRQUFRLEVBQUU0SixvQkFBb0IsQ0FBQzMwRCxDQUFELENBQS9CO1VBQ0NnckQsZ0JBQWdCLEVBQUVockQsQ0FBQyxDQUFDMnNELE9BQUYsQ0FBVTdXLFdBRDdCO1VBRUN3VixVQUFVLEVBQUV2bkMsSUFGYjtVQUdDMG5DLFdBQVcsRUFBRXRyQixLQUhkO1VBSUNrc0IsWUFBWSxFQUFFcnNELENBQUMsQ0FBQzhSLE9BQUYsQ0FBVTg2QztTQUpoQztPQXYxRmlCOzs7OztNQWkyRm5CLFNBQVMrSCxvQkFBVCxDQUE4QnRwRSxPQUE5QixFQUF1QztRQUNyQyxPQUFPQSxPQUFPLENBQUN1aUUsUUFBUixDQUFpQnJzQixxQkFBakIsR0FBeUN4ZCxJQUF6QyxHQUFnRDE0QixPQUFPLENBQUN5aEUsS0FBUixDQUFjdnJCLHFCQUFkLEdBQXNDeGQsSUFBN0Y7T0FsMkZpQjs7Ozs7TUF3MkZuQixTQUFTa2hDLGNBQVQsQ0FBd0I3USxFQUF4QixFQUE0QjtRQUMxQixJQUFJd2dCLEVBQUUsR0FBR0osVUFBVSxDQUFDcGdCLEVBQUUsQ0FBQy9vRCxPQUFKLENBQW5CO1lBQWlDNmlFLFFBQVEsR0FBRzlaLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBdkQ7UUFDQSxJQUFJMEcsT0FBTyxHQUFHM0csUUFBUSxJQUFJMXRFLElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVlvckQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CaEIsV0FBcEIsR0FBa0N5RCxTQUFTLENBQUNqYyxFQUFFLENBQUMvb0QsT0FBSixDQUEzQyxHQUEwRCxDQUF0RSxDQUExQjtRQUNBLE9BQU8sVUFBVW1vRCxJQUFWLEVBQWdCO1VBQ3JCLElBQUk4USxZQUFZLENBQUNsUSxFQUFFLENBQUNrRyxHQUFKLEVBQVM5RyxJQUFULENBQWhCLEVBQWdDO1lBQUUsT0FBTyxDQUFQOzs7VUFFbEMsSUFBSXNoQixhQUFhLEdBQUcsQ0FBcEI7O1VBQ0EsSUFBSXRoQixJQUFJLENBQUN3WSxPQUFULEVBQWtCO1lBQUUsS0FBSyxJQUFJL2tFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1c0QsSUFBSSxDQUFDd1ksT0FBTCxDQUFhbm5FLE1BQWpDLEVBQXlDb0MsQ0FBQyxFQUExQyxFQUE4QztjQUNoRSxJQUFJdXNELElBQUksQ0FBQ3dZLE9BQUwsQ0FBYS9rRSxDQUFiLEVBQWdCbzVDLE1BQXBCLEVBQTRCO2dCQUFFeTBCLGFBQWEsSUFBSXRoQixJQUFJLENBQUN3WSxPQUFMLENBQWEva0UsQ0FBYixFQUFnQm81QyxNQUFqQzs7Ozs7VUFHaEMsSUFBSTZ0QixRQUFKLEVBQ0U7WUFBRSxPQUFPNEcsYUFBYSxHQUFHLENBQUN0MEUsSUFBSSxDQUFDbUksSUFBTCxDQUFVNnFELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFWLEdBQW1CZ3dFLE9BQTdCLEtBQXlDLENBQTFDLElBQStDRCxFQUF0RTtXQURKLE1BR0U7WUFBRSxPQUFPRSxhQUFhLEdBQUdGLEVBQXZCOztTQVhOOzs7TUFlRixTQUFTRyxtQkFBVCxDQUE2QjNnQixFQUE3QixFQUFpQztRQUMvQixJQUFJa0csR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjtZQUFrQjBhLEdBQUcsR0FBRy9QLGNBQWMsQ0FBQzdRLEVBQUQsQ0FBdEM7UUFDQWtHLEdBQUcsQ0FBQ241QyxJQUFKLENBQVMsVUFBVXF5QyxJQUFWLEVBQWdCO1VBQ3ZCLElBQUkyUixTQUFTLEdBQUc2UCxHQUFHLENBQUN4aEIsSUFBRCxDQUFuQjs7VUFDQSxJQUFJMlIsU0FBUyxJQUFJM1IsSUFBSSxDQUFDblQsTUFBdEIsRUFBOEI7WUFBRXlhLGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPMlIsU0FBUCxDQUFoQjs7U0FGbEM7T0E1M0ZpQjs7Ozs7OztNQXU0Rm5CLFNBQVM4UCxZQUFULENBQXNCN2dCLEVBQXRCLEVBQTBCbnpELENBQTFCLEVBQTZCaTBFLE9BQTdCLEVBQXNDQyxPQUF0QyxFQUErQztRQUM3QyxJQUFJOXBFLE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBakI7O1FBQ0EsSUFBSSxDQUFDNnBFLE9BQUQsSUFBWTlmLFFBQVEsQ0FBQ24wRCxDQUFELENBQVIsQ0FBWXd3QyxZQUFaLENBQXlCLGdCQUF6QixLQUE4QyxNQUE5RCxFQUFzRTtVQUFFLE9BQU8sSUFBUDs7O1FBRXhFLElBQUlyZ0MsQ0FBSjtZQUFPQyxDQUFQO1lBQVUyQixLQUFLLEdBQUczSCxPQUFPLENBQUM0aEUsU0FBUixDQUFrQjFyQixxQkFBbEIsRUFBbEIsQ0FKNkM7O1FBTTdDLElBQUk7VUFBRW53QyxDQUFDLEdBQUduUSxDQUFDLENBQUN1Z0QsT0FBRixHQUFZeHVDLEtBQUssQ0FBQyt3QixJQUF0QjtVQUE0QjF5QixDQUFDLEdBQUdwUSxDQUFDLENBQUN5Z0QsT0FBRixHQUFZMXVDLEtBQUssQ0FBQzJ1QyxHQUF0QjtTQUFsQyxDQUNBLE9BQU95ekIsR0FBUCxFQUFZO1VBQUUsT0FBTyxJQUFQOzs7UUFDZCxJQUFJOUMsTUFBTSxHQUFHYSxXQUFVLENBQUMvZSxFQUFELEVBQUtoakQsQ0FBTCxFQUFRQyxDQUFSLENBQXZCO1lBQW1DbWlELElBQW5DOztRQUNBLElBQUkyaEIsT0FBTyxJQUFJN0MsTUFBTSxDQUFDWSxJQUFQLEdBQWMsQ0FBekIsSUFBOEIsQ0FBQzFmLElBQUksR0FBRzZHLE9BQU8sQ0FBQ2pHLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU2dZLE1BQU0sQ0FBQzllLElBQWhCLENBQVAsQ0FBNkJ2USxJQUFyQyxFQUEyQ3ArQyxNQUEzQyxJQUFxRHl0RSxNQUFNLENBQUM1b0QsRUFBOUYsRUFBa0c7VUFDaEcsSUFBSTJyRCxPQUFPLEdBQUdqbkIsV0FBVyxDQUFDb0YsSUFBRCxFQUFPQSxJQUFJLENBQUMzdUQsTUFBWixFQUFvQnV2RCxFQUFFLENBQUNqbEIsT0FBSCxDQUFXa2YsT0FBL0IsQ0FBWCxHQUFxRG1GLElBQUksQ0FBQzN1RCxNQUF4RTtVQUNBeXRFLE1BQU0sR0FBRzdXLEdBQUcsQ0FBQzZXLE1BQU0sQ0FBQzllLElBQVIsRUFBY2h6RCxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZeEksSUFBSSxDQUFDKy9CLEtBQUwsQ0FBVyxDQUFDbnZCLENBQUMsR0FBR2c4RCxRQUFRLENBQUNoWixFQUFFLENBQUMvb0QsT0FBSixDQUFSLENBQXFCMDRCLElBQTFCLElBQWtDc3NDLFNBQVMsQ0FBQ2pjLEVBQUUsQ0FBQy9vRCxPQUFKLENBQXRELElBQXNFZ3FFLE9BQWxGLENBQWQsQ0FBWjs7O1FBRUYsT0FBTy9DLE1BQVA7T0FwNUZpQjs7OztNQXk1Rm5CLFNBQVNyRCxhQUFULENBQXVCN2EsRUFBdkIsRUFBMkIvaEQsQ0FBM0IsRUFBOEI7UUFDNUIsSUFBSUEsQ0FBQyxJQUFJK2hELEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBcEIsRUFBNEI7VUFBRSxPQUFPLElBQVA7OztRQUM5Qm5zRCxDQUFDLElBQUkraEQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t6RCxRQUFoQjs7UUFDQSxJQUFJbHNELENBQUMsR0FBRyxDQUFSLEVBQVc7VUFBRSxPQUFPLElBQVA7OztRQUNiLElBQUlrbUIsSUFBSSxHQUFHNjdCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdrdEIsSUFBdEI7O1FBQ0EsS0FBSyxJQUFJdHhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzeEIsSUFBSSxDQUFDMXpCLE1BQXpCLEVBQWlDb0MsQ0FBQyxFQUFsQyxFQUFzQztVQUNwQ29MLENBQUMsSUFBSWttQixJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVE4WCxJQUFiOztVQUNBLElBQUkxTSxDQUFDLEdBQUcsQ0FBUixFQUFXO1lBQUUsT0FBT3BMLENBQVA7OztPQWg2RkU7Ozs7Ozs7O01BMDZGbkIsU0FBU3F1RSxTQUFULENBQW1CbGhCLEVBQW5CLEVBQXVCcHpDLElBQXZCLEVBQTZCd0QsRUFBN0IsRUFBaUMrd0QsT0FBakMsRUFBMEM7UUFDeEMsSUFBSXYwRCxJQUFJLElBQUksSUFBWixFQUFrQjtVQUFFQSxJQUFJLEdBQUdvekMsRUFBRSxDQUFDa0csR0FBSCxDQUFPdmxELEtBQWQ7OztRQUNwQixJQUFJeVAsRUFBRSxJQUFJLElBQVYsRUFBZ0I7VUFBRUEsRUFBRSxHQUFHNHZDLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3ZsRCxLQUFQLEdBQWVxL0MsRUFBRSxDQUFDa0csR0FBSCxDQUFPdjdDLElBQTNCOzs7UUFDbEIsSUFBSSxDQUFDdzJELE9BQUwsRUFBYztVQUFFQSxPQUFPLEdBQUcsQ0FBVjs7O1FBRWhCLElBQUlscUUsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjs7UUFDQSxJQUFJa3FFLE9BQU8sSUFBSS93RCxFQUFFLEdBQUduWixPQUFPLENBQUNtekQsTUFBeEIsS0FDQ256RCxPQUFPLENBQUNtcUUsaUJBQVIsSUFBNkIsSUFBN0IsSUFBcUNucUUsT0FBTyxDQUFDbXFFLGlCQUFSLEdBQTRCeDBELElBRGxFLENBQUosRUFFRTtVQUFFM1YsT0FBTyxDQUFDbXFFLGlCQUFSLEdBQTRCeDBELElBQTVCOzs7UUFFSm96QyxFQUFFLENBQUNPLEtBQUgsQ0FBUzhnQixXQUFULEdBQXVCLElBQXZCOztRQUVBLElBQUl6MEQsSUFBSSxJQUFJM1YsT0FBTyxDQUFDbXpELE1BQXBCLEVBQTRCOztVQUMxQixJQUFJdUIsaUJBQWlCLElBQUlrRSxZQUFZLENBQUM3UCxFQUFFLENBQUNrRyxHQUFKLEVBQVN0NUMsSUFBVCxDQUFaLEdBQTZCM1YsT0FBTyxDQUFDbXpELE1BQTlELEVBQ0U7WUFBRWtYLFNBQVMsQ0FBQ3RoQixFQUFELENBQVQ7O1NBRk4sTUFHTyxJQUFJNXZDLEVBQUUsSUFBSW5aLE9BQU8sQ0FBQ2t6RCxRQUFsQixFQUE0Qjs7VUFDakMsSUFBSXdCLGlCQUFpQixJQUFJcUUsZUFBZSxDQUFDaFEsRUFBRSxDQUFDa0csR0FBSixFQUFTOTFDLEVBQUUsR0FBRyt3RCxPQUFkLENBQWYsR0FBd0NscUUsT0FBTyxDQUFDa3pELFFBQXpFLEVBQW1GO1lBQ2pGbVgsU0FBUyxDQUFDdGhCLEVBQUQsQ0FBVDtXQURGLE1BRU87WUFDTC9vRCxPQUFPLENBQUNrekQsUUFBUixJQUFvQmdYLE9BQXBCO1lBQ0FscUUsT0FBTyxDQUFDbXpELE1BQVIsSUFBa0IrVyxPQUFsQjs7U0FMRyxNQU9BLElBQUl2MEQsSUFBSSxJQUFJM1YsT0FBTyxDQUFDa3pELFFBQWhCLElBQTRCLzVDLEVBQUUsSUFBSW5aLE9BQU8sQ0FBQ216RCxNQUE5QyxFQUFzRDs7VUFDM0RrWCxTQUFTLENBQUN0aEIsRUFBRCxDQUFUO1NBREssTUFFQSxJQUFJcHpDLElBQUksSUFBSTNWLE9BQU8sQ0FBQ2t6RCxRQUFwQixFQUE4Qjs7VUFDbkMsSUFBSW9YLEdBQUcsR0FBR0MsZ0JBQWdCLENBQUN4aEIsRUFBRCxFQUFLNXZDLEVBQUwsRUFBU0EsRUFBRSxHQUFHK3dELE9BQWQsRUFBdUIsQ0FBdkIsQ0FBMUI7O1VBQ0EsSUFBSUksR0FBSixFQUFTO1lBQ1B0cUUsT0FBTyxDQUFDa3RCLElBQVIsR0FBZWx0QixPQUFPLENBQUNrdEIsSUFBUixDQUFhandCLEtBQWIsQ0FBbUJxdEUsR0FBRyxDQUFDMXNFLEtBQXZCLENBQWY7WUFDQW9DLE9BQU8sQ0FBQ2t6RCxRQUFSLEdBQW1Cb1gsR0FBRyxDQUFDelIsS0FBdkI7WUFDQTc0RCxPQUFPLENBQUNtekQsTUFBUixJQUFrQitXLE9BQWxCO1dBSEYsTUFJTztZQUNMRyxTQUFTLENBQUN0aEIsRUFBRCxDQUFUOztTQVBHLE1BU0EsSUFBSTV2QyxFQUFFLElBQUluWixPQUFPLENBQUNtekQsTUFBbEIsRUFBMEI7O1VBQy9CLElBQUlxWCxLQUFLLEdBQUdELGdCQUFnQixDQUFDeGhCLEVBQUQsRUFBS3B6QyxJQUFMLEVBQVdBLElBQVgsRUFBaUIsQ0FBQyxDQUFsQixDQUE1Qjs7VUFDQSxJQUFJNjBELEtBQUosRUFBVztZQUNUeHFFLE9BQU8sQ0FBQ2t0QixJQUFSLEdBQWVsdEIsT0FBTyxDQUFDa3RCLElBQVIsQ0FBYWp3QixLQUFiLENBQW1CLENBQW5CLEVBQXNCdXRFLEtBQUssQ0FBQzVzRSxLQUE1QixDQUFmO1lBQ0FvQyxPQUFPLENBQUNtekQsTUFBUixHQUFpQnFYLEtBQUssQ0FBQzNSLEtBQXZCO1dBRkYsTUFHTztZQUNMd1IsU0FBUyxDQUFDdGhCLEVBQUQsQ0FBVDs7U0FORyxNQVFBOztVQUNMLElBQUkwaEIsTUFBTSxHQUFHRixnQkFBZ0IsQ0FBQ3hoQixFQUFELEVBQUtwekMsSUFBTCxFQUFXQSxJQUFYLEVBQWlCLENBQUMsQ0FBbEIsQ0FBN0I7VUFDQSxJQUFJKzBELE1BQU0sR0FBR0gsZ0JBQWdCLENBQUN4aEIsRUFBRCxFQUFLNXZDLEVBQUwsRUFBU0EsRUFBRSxHQUFHK3dELE9BQWQsRUFBdUIsQ0FBdkIsQ0FBN0I7O1VBQ0EsSUFBSU8sTUFBTSxJQUFJQyxNQUFkLEVBQXNCO1lBQ3BCMXFFLE9BQU8sQ0FBQ2t0QixJQUFSLEdBQWVsdEIsT0FBTyxDQUFDa3RCLElBQVIsQ0FBYWp3QixLQUFiLENBQW1CLENBQW5CLEVBQXNCd3RFLE1BQU0sQ0FBQzdzRSxLQUE3QixFQUNaekYsTUFEWSxDQUNMa2xFLGNBQWMsQ0FBQ3RVLEVBQUQsRUFBSzBoQixNQUFNLENBQUM1UixLQUFaLEVBQW1CNlIsTUFBTSxDQUFDN1IsS0FBMUIsQ0FEVCxFQUVaMWdFLE1BRlksQ0FFTDZILE9BQU8sQ0FBQ2t0QixJQUFSLENBQWFqd0IsS0FBYixDQUFtQnl0RSxNQUFNLENBQUM5c0UsS0FBMUIsQ0FGSyxDQUFmO1lBR0FvQyxPQUFPLENBQUNtekQsTUFBUixJQUFrQitXLE9BQWxCO1dBSkYsTUFLTztZQUNMRyxTQUFTLENBQUN0aEIsRUFBRCxDQUFUOzs7O1FBSUosSUFBSW9XLEdBQUcsR0FBR24vRCxPQUFPLENBQUNnN0QsZ0JBQWxCOztRQUNBLElBQUltRSxHQUFKLEVBQVM7VUFDUCxJQUFJaG1ELEVBQUUsR0FBR2dtRCxHQUFHLENBQUN0RyxLQUFiLEVBQ0U7WUFBRXNHLEdBQUcsQ0FBQ3RHLEtBQUosSUFBYXFSLE9BQWI7V0FESixNQUVLLElBQUl2MEQsSUFBSSxHQUFHd3BELEdBQUcsQ0FBQ3RHLEtBQUosR0FBWXNHLEdBQUcsQ0FBQ3pyRCxJQUEzQixFQUNIO1lBQUUxVCxPQUFPLENBQUNnN0QsZ0JBQVIsR0FBMkIsSUFBM0I7OztPQXIrRlc7Ozs7TUEyK0ZuQixTQUFTMlAsYUFBVCxDQUF1QjVoQixFQUF2QixFQUEyQlosSUFBM0IsRUFBaUNudUQsSUFBakMsRUFBdUM7UUFDckMrdUQsRUFBRSxDQUFDTyxLQUFILENBQVM4Z0IsV0FBVCxHQUF1QixJQUF2QjtRQUNBLElBQUlwcUUsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtZQUEwQm0vRCxHQUFHLEdBQUdwVyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXZzdELGdCQUEzQzs7UUFDQSxJQUFJbUUsR0FBRyxJQUFJaFgsSUFBSSxJQUFJZ1gsR0FBRyxDQUFDdEcsS0FBbkIsSUFBNEIxUSxJQUFJLEdBQUdnWCxHQUFHLENBQUN0RyxLQUFKLEdBQVlzRyxHQUFHLENBQUN6ckQsSUFBdkQsRUFDRTtVQUFFMVQsT0FBTyxDQUFDZzdELGdCQUFSLEdBQTJCLElBQTNCOzs7UUFFSixJQUFJN1MsSUFBSSxHQUFHbm9ELE9BQU8sQ0FBQ2t6RCxRQUFmLElBQTJCL0ssSUFBSSxJQUFJbm9ELE9BQU8sQ0FBQ216RCxNQUEvQyxFQUF1RDtVQUFFOzs7UUFDekQsSUFBSWtILFFBQVEsR0FBR3I2RCxPQUFPLENBQUNrdEIsSUFBUixDQUFhMDJDLGFBQWEsQ0FBQzdhLEVBQUQsRUFBS1osSUFBTCxDQUExQixDQUFmOztRQUNBLElBQUlrUyxRQUFRLENBQUN0M0MsSUFBVCxJQUFpQixJQUFyQixFQUEyQjtVQUFFOzs7UUFDN0IsSUFBSWxOLEdBQUcsR0FBR3drRCxRQUFRLENBQUNtRSxPQUFULEtBQXFCbkUsUUFBUSxDQUFDbUUsT0FBVCxHQUFtQixFQUF4QyxDQUFWOztRQUNBLElBQUkvckQsT0FBTyxDQUFDb0QsR0FBRCxFQUFNN2IsSUFBTixDQUFQLElBQXNCLENBQUMsQ0FBM0IsRUFBOEI7VUFBRTZiLEdBQUcsQ0FBQ3RkLElBQUosQ0FBU3lCLElBQVQ7O09Bci9GZjs7O01BeS9GbkIsU0FBU3F3RSxTQUFULENBQW1CdGhCLEVBQW5CLEVBQXVCO1FBQ3JCQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQVgsR0FBc0JuSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQVgsR0FBb0JwSyxFQUFFLENBQUNrRyxHQUFILENBQU92bEQsS0FBakQ7UUFDQXEvQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3RCLElBQVgsR0FBa0IsRUFBbEI7UUFDQTY3QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXNm1FLFVBQVgsR0FBd0IsQ0FBeEI7OztNQUdGLFNBQVMwRCxnQkFBVCxDQUEwQnhoQixFQUExQixFQUE4QjZoQixJQUE5QixFQUFvQ0MsSUFBcEMsRUFBMEN4bEIsR0FBMUMsRUFBK0M7UUFDN0MsSUFBSXpuRCxLQUFLLEdBQUdnbUUsYUFBYSxDQUFDN2EsRUFBRCxFQUFLNmhCLElBQUwsQ0FBekI7WUFBcUNsYixJQUFyQztZQUEyQ3hpQyxJQUFJLEdBQUc2N0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t0QixJQUE3RDs7UUFDQSxJQUFJLENBQUN3bkMsaUJBQUQsSUFBc0JtVyxJQUFJLElBQUk5aEIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdmxELEtBQVAsR0FBZXEvQyxFQUFFLENBQUNrRyxHQUFILENBQU92N0MsSUFBeEQsRUFDRTtVQUFFLE9BQU87WUFBQzlWLEtBQUssRUFBRUEsS0FBUjtZQUFlaTdELEtBQUssRUFBRWdTO1dBQTdCOzs7UUFDSixJQUFJN2pFLENBQUMsR0FBRytoRCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQW5COztRQUNBLEtBQUssSUFBSXQzRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ0MsS0FBcEIsRUFBMkJoQyxDQUFDLEVBQTVCLEVBQ0U7VUFBRW9MLENBQUMsSUFBSWttQixJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVE4WCxJQUFiOzs7UUFDSixJQUFJMU0sQ0FBQyxJQUFJNGpFLElBQVQsRUFBZTtVQUNiLElBQUl2bEIsR0FBRyxHQUFHLENBQVYsRUFBYTtZQUNYLElBQUl6bkQsS0FBSyxJQUFJc3ZCLElBQUksQ0FBQzF6QixNQUFMLEdBQWMsQ0FBM0IsRUFBOEI7Y0FBRSxPQUFPLElBQVA7OztZQUNoQ2syRCxJQUFJLEdBQUkxb0QsQ0FBQyxHQUFHa21CLElBQUksQ0FBQ3R2QixLQUFELENBQUosQ0FBWThWLElBQWpCLEdBQXlCazNELElBQWhDO1lBQ0FodEUsS0FBSztXQUhQLE1BSU87WUFDTDh4RCxJQUFJLEdBQUcxb0QsQ0FBQyxHQUFHNGpFLElBQVg7OztVQUVGQSxJQUFJLElBQUlsYixJQUFSO1VBQWNtYixJQUFJLElBQUluYixJQUFSOzs7UUFFaEIsT0FBT2tKLFlBQVksQ0FBQzdQLEVBQUUsQ0FBQ2tHLEdBQUosRUFBUzRiLElBQVQsQ0FBWixJQUE4QkEsSUFBckMsRUFBMkM7VUFDekMsSUFBSWp0RSxLQUFLLEtBQUt5bkQsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWNuNEIsSUFBSSxDQUFDMXpCLE1BQUwsR0FBYyxDQUFqQyxDQUFULEVBQThDO1lBQUUsT0FBTyxJQUFQOzs7VUFDaERxeEUsSUFBSSxJQUFJeGxCLEdBQUcsR0FBR240QixJQUFJLENBQUN0dkIsS0FBSyxJQUFJeW5ELEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBVixHQUFjLENBQWxCLENBQU4sQ0FBSixDQUFnQzN4QyxJQUE5QztVQUNBOVYsS0FBSyxJQUFJeW5ELEdBQVQ7OztRQUVGLE9BQU87VUFBQ3puRCxLQUFLLEVBQUVBLEtBQVI7VUFBZWk3RCxLQUFLLEVBQUVnUztTQUE3QjtPQXJoR2lCOzs7O01BMGhHbkIsU0FBU0MsVUFBVCxDQUFvQi9oQixFQUFwQixFQUF3QnB6QyxJQUF4QixFQUE4QndELEVBQTlCLEVBQWtDO1FBQ2hDLElBQUluWixPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1lBQTBCa3RCLElBQUksR0FBR2x0QixPQUFPLENBQUNrdEIsSUFBekM7O1FBQ0EsSUFBSUEsSUFBSSxDQUFDMXpCLE1BQUwsSUFBZSxDQUFmLElBQW9CbWMsSUFBSSxJQUFJM1YsT0FBTyxDQUFDbXpELE1BQXBDLElBQThDaDZDLEVBQUUsSUFBSW5aLE9BQU8sQ0FBQ2t6RCxRQUFoRSxFQUEwRTtVQUN4RWx6RCxPQUFPLENBQUNrdEIsSUFBUixHQUFlbXdDLGNBQWMsQ0FBQ3RVLEVBQUQsRUFBS3B6QyxJQUFMLEVBQVd3RCxFQUFYLENBQTdCO1VBQ0FuWixPQUFPLENBQUNrekQsUUFBUixHQUFtQnY5QyxJQUFuQjtTQUZGLE1BR087VUFDTCxJQUFJM1YsT0FBTyxDQUFDa3pELFFBQVIsR0FBbUJ2OUMsSUFBdkIsRUFDRTtZQUFFM1YsT0FBTyxDQUFDa3RCLElBQVIsR0FBZW13QyxjQUFjLENBQUN0VSxFQUFELEVBQUtwekMsSUFBTCxFQUFXM1YsT0FBTyxDQUFDa3pELFFBQW5CLENBQWQsQ0FBMkMvNkQsTUFBM0MsQ0FBa0Q2SCxPQUFPLENBQUNrdEIsSUFBMUQsQ0FBZjtXQURKLE1BRUssSUFBSWx0QixPQUFPLENBQUNrekQsUUFBUixHQUFtQnY5QyxJQUF2QixFQUNIO1lBQUUzVixPQUFPLENBQUNrdEIsSUFBUixHQUFlbHRCLE9BQU8sQ0FBQ2t0QixJQUFSLENBQWFqd0IsS0FBYixDQUFtQjJtRSxhQUFhLENBQUM3YSxFQUFELEVBQUtwekMsSUFBTCxDQUFoQyxDQUFmOzs7VUFDSjNWLE9BQU8sQ0FBQ2t6RCxRQUFSLEdBQW1CdjlDLElBQW5COztVQUNBLElBQUkzVixPQUFPLENBQUNtekQsTUFBUixHQUFpQmg2QyxFQUFyQixFQUNFO1lBQUVuWixPQUFPLENBQUNrdEIsSUFBUixHQUFlbHRCLE9BQU8sQ0FBQ2t0QixJQUFSLENBQWEvMEIsTUFBYixDQUFvQmtsRSxjQUFjLENBQUN0VSxFQUFELEVBQUsvb0QsT0FBTyxDQUFDbXpELE1BQWIsRUFBcUJoNkMsRUFBckIsQ0FBbEMsQ0FBZjtXQURKLE1BRUssSUFBSW5aLE9BQU8sQ0FBQ216RCxNQUFSLEdBQWlCaDZDLEVBQXJCLEVBQ0g7WUFBRW5aLE9BQU8sQ0FBQ2t0QixJQUFSLEdBQWVsdEIsT0FBTyxDQUFDa3RCLElBQVIsQ0FBYWp3QixLQUFiLENBQW1CLENBQW5CLEVBQXNCMm1FLGFBQWEsQ0FBQzdhLEVBQUQsRUFBSzV2QyxFQUFMLENBQW5DLENBQWY7Ozs7UUFFTm5aLE9BQU8sQ0FBQ216RCxNQUFSLEdBQWlCaDZDLEVBQWpCO09BMWlHaUI7Ozs7TUEraUduQixTQUFTNHhELGNBQVQsQ0FBd0JoaUIsRUFBeEIsRUFBNEI7UUFDMUIsSUFBSTc3QixJQUFJLEdBQUc2N0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t0QixJQUF0QjtZQUE0Qjg5QyxLQUFLLEdBQUcsQ0FBcEM7O1FBQ0EsS0FBSyxJQUFJcHZFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzeEIsSUFBSSxDQUFDMXpCLE1BQXpCLEVBQWlDb0MsQ0FBQyxFQUFsQyxFQUFzQztVQUNwQyxJQUFJeStELFFBQVEsR0FBR250QyxJQUFJLENBQUN0eEIsQ0FBRCxDQUFuQjs7VUFDQSxJQUFJLENBQUN5K0QsUUFBUSxDQUFDK0MsTUFBVixLQUFxQixDQUFDL0MsUUFBUSxDQUFDdDNDLElBQVYsSUFBa0JzM0MsUUFBUSxDQUFDbUUsT0FBaEQsQ0FBSixFQUE4RDtZQUFFLEVBQUV3TSxLQUFGOzs7O1FBRWxFLE9BQU9BLEtBQVA7OztNQUdGLFNBQVNDLGVBQVQsQ0FBeUJsaUIsRUFBekIsRUFBNkI7UUFDM0JBLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQjJPLGFBQWpCLENBQStCbmlCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQjRPLGdCQUFqQixFQUEvQjs7O01BR0YsU0FBU0EsZ0JBQVQsQ0FBMEJwaUIsRUFBMUIsRUFBOEJxaUIsT0FBOUIsRUFBdUM7UUFDckMsSUFBS0EsT0FBTyxLQUFLLEtBQUssQ0FBdEIsRUFBMEJBLE9BQU8sR0FBRyxJQUFWO1FBRTFCLElBQUluYyxHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFiO1lBQWtCendELE1BQU0sR0FBRyxFQUEzQjtRQUNBLElBQUk2c0UsV0FBVyxHQUFHN3NFLE1BQU0sQ0FBQzhzRSxPQUFQLEdBQWlCLzBFLFFBQVEsQ0FBQ3NsRSxzQkFBVCxFQUFuQztRQUNBLElBQUkwUCxXQUFXLEdBQUcvc0UsTUFBTSxDQUFDOHNELFNBQVAsR0FBbUIvMEQsUUFBUSxDQUFDc2xFLHNCQUFULEVBQXJDOztRQUVBLEtBQUssSUFBSWpnRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcXpELEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFlanlFLE1BQW5DLEVBQTJDb0MsQ0FBQyxFQUE1QyxFQUFnRDtVQUM5QyxJQUFJLENBQUN3dkUsT0FBRCxJQUFZeHZFLENBQUMsSUFBSXF6RCxHQUFHLENBQUN1YyxHQUFKLENBQVFFLFNBQTdCLEVBQXdDO1lBQUU7OztVQUMxQyxJQUFJL3lCLEtBQUssR0FBR3NXLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFlN3ZFLENBQWYsQ0FBWjs7VUFDQSxJQUFJKzhDLEtBQUssQ0FBQ2hqQyxJQUFOLEdBQWF3eUMsSUFBYixJQUFxQlksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV216RCxNQUFoQyxJQUEwQ3hhLEtBQUssQ0FBQ3gvQixFQUFOLEdBQVdndkMsSUFBWCxHQUFrQlksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t6RCxRQUEzRSxFQUFxRjtZQUFFOzs7VUFDdkYsSUFBSWlGLFNBQVMsR0FBR3hmLEtBQUssQ0FBQ3YwQixLQUFOLEVBQWhCOztVQUNBLElBQUkrekMsU0FBUyxJQUFJcFAsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzZuQyx1QkFBNUIsRUFDRTtZQUFFQyxtQkFBbUIsQ0FBQzdpQixFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBWCxFQUFpQmlwRCxXQUFqQixDQUFuQjs7O1VBQ0osSUFBSSxDQUFDbFQsU0FBTCxFQUNFO1lBQUUwVCxrQkFBa0IsQ0FBQzlpQixFQUFELEVBQUtwUSxLQUFMLEVBQVk0eUIsV0FBWixDQUFsQjs7OztRQUVOLE9BQU8vc0UsTUFBUDtPQTdrR2lCOzs7TUFpbEduQixTQUFTb3RFLG1CQUFULENBQTZCN2lCLEVBQTdCLEVBQWlDM21DLElBQWpDLEVBQXVDL0MsTUFBdkMsRUFBK0M7UUFDN0MsSUFBSTNQLEdBQUcsR0FBRzIzRCxhQUFZLENBQUN0ZSxFQUFELEVBQUszbUMsSUFBTCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEIsRUFBOEIsQ0FBQzJtQyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXcWhDLHlCQUExQyxDQUF0Qjs7UUFFQSxJQUFJMkcsTUFBTSxHQUFHenNELE1BQU0sQ0FBQ3BmLFdBQVAsQ0FBbUJxaEQsR0FBRyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLG1CQUFsQixDQUF0QixDQUFiO1FBQ0F3cUIsTUFBTSxDQUFDL3JFLEtBQVAsQ0FBYTI0QixJQUFiLEdBQW9CaHBCLEdBQUcsQ0FBQ2dwQixJQUFKLEdBQVcsSUFBL0I7UUFDQW96QyxNQUFNLENBQUMvckUsS0FBUCxDQUFhdTJDLEdBQWIsR0FBbUI1bUMsR0FBRyxDQUFDNG1DLEdBQUosR0FBVSxJQUE3QjtRQUNBdzFCLE1BQU0sQ0FBQy9yRSxLQUFQLENBQWFpMUMsTUFBYixHQUFzQjcvQyxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZK1IsR0FBRyxDQUFDeXpELE1BQUosR0FBYXp6RCxHQUFHLENBQUM0bUMsR0FBN0IsSUFBb0N5UyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXaW9DLFlBQS9DLEdBQThELElBQXBGOztRQUVBLElBQUksb0JBQW9CM2xFLElBQXBCLENBQXlCMmlELEVBQUUsQ0FBQ2lqQixpQkFBSCxHQUF1QjlxQixTQUFoRCxDQUFKLEVBQWdFO1VBQzlELElBQUkrcUIsT0FBTyxHQUFHN0UsV0FBVSxDQUFDcmUsRUFBRCxFQUFLM21DLElBQUwsRUFBVyxLQUFYLEVBQWtCLElBQWxCLEVBQXdCLElBQXhCLENBQXhCOztVQUNBLElBQUk2cEQsT0FBTyxDQUFDbGhCLEtBQVIsR0FBZ0JraEIsT0FBTyxDQUFDdnpDLElBQXhCLEdBQStCLENBQW5DLEVBQXNDO1lBQ3BDb3pDLE1BQU0sQ0FBQy9yRSxLQUFQLENBQWErMEMsS0FBYixHQUFzQm0zQixPQUFPLENBQUNsaEIsS0FBUixHQUFnQmtoQixPQUFPLENBQUN2ekMsSUFBekIsR0FBaUMsSUFBdEQ7Ozs7UUFJSixJQUFJaHBCLEdBQUcsQ0FBQyszRCxLQUFSLEVBQWU7O1VBRWIsSUFBSXlFLFdBQVcsR0FBRzdzRCxNQUFNLENBQUNwZixXQUFQLENBQW1CcWhELEdBQUcsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQiw4Q0FBbEIsQ0FBdEIsQ0FBbEI7VUFDQTRxQixXQUFXLENBQUNuc0UsS0FBWixDQUFrQkMsT0FBbEIsR0FBNEIsRUFBNUI7VUFDQWtzRSxXQUFXLENBQUNuc0UsS0FBWixDQUFrQjI0QixJQUFsQixHQUF5QmhwQixHQUFHLENBQUMrM0QsS0FBSixDQUFVL3VDLElBQVYsR0FBaUIsSUFBMUM7VUFDQXd6QyxXQUFXLENBQUNuc0UsS0FBWixDQUFrQnUyQyxHQUFsQixHQUF3QjVtQyxHQUFHLENBQUMrM0QsS0FBSixDQUFVbnhCLEdBQVYsR0FBZ0IsSUFBeEM7VUFDQTQxQixXQUFXLENBQUNuc0UsS0FBWixDQUFrQmkxQyxNQUFsQixHQUEyQixDQUFDdGxDLEdBQUcsQ0FBQyszRCxLQUFKLENBQVV0RSxNQUFWLEdBQW1CenpELEdBQUcsQ0FBQyszRCxLQUFKLENBQVVueEIsR0FBOUIsSUFBcUMsR0FBckMsR0FBMkMsSUFBdEU7Ozs7TUFJSixTQUFTNjFCLFNBQVQsQ0FBbUJsMkUsQ0FBbkIsRUFBc0J5RCxDQUF0QixFQUF5QjtRQUFFLE9BQU96RCxDQUFDLENBQUNxZ0QsR0FBRixHQUFRNThDLENBQUMsQ0FBQzQ4QyxHQUFWLElBQWlCcmdELENBQUMsQ0FBQ3lpQyxJQUFGLEdBQVNoL0IsQ0FBQyxDQUFDZy9CLElBQW5DO09BMW1HUjs7O01BNm1HbkIsU0FBU216QyxrQkFBVCxDQUE0QjlpQixFQUE1QixFQUFnQ3BRLEtBQWhDLEVBQXVDdDVCLE1BQXZDLEVBQStDO1FBQzdDLElBQUlyZixPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1lBQTBCaXZELEdBQUcsR0FBR2xHLEVBQUUsQ0FBQ2tHLEdBQW5DO1FBQ0EsSUFBSTltQixRQUFRLEdBQUc1eEMsUUFBUSxDQUFDc2xFLHNCQUFULEVBQWY7UUFDQSxJQUFJdmpCLE9BQU8sR0FBR3lwQixRQUFRLENBQUNoWixFQUFFLENBQUMvb0QsT0FBSixDQUF0QjtZQUFvQ29zRSxRQUFRLEdBQUc5ekIsT0FBTyxDQUFDNWYsSUFBdkQ7UUFDQSxJQUFJMnpDLFNBQVMsR0FBR2wzRSxJQUFJLENBQUN3SSxHQUFMLENBQVNxQyxPQUFPLENBQUNzc0UsVUFBakIsRUFBNkJoSyxZQUFZLENBQUN2WixFQUFELENBQVosR0FBbUIvb0QsT0FBTyxDQUFDeWhFLEtBQVIsQ0FBYzRILFVBQTlELElBQTRFL3dCLE9BQU8sQ0FBQ3lTLEtBQXBHO1FBQ0EsSUFBSXdoQixNQUFNLEdBQUd0ZCxHQUFHLENBQUN0SSxTQUFKLElBQWlCLEtBQTlCOztRQUVBLFNBQVNsK0IsR0FBVCxDQUFhaVEsSUFBYixFQUFtQjRkLEdBQW5CLEVBQXdCeEIsS0FBeEIsRUFBK0JxdUIsTUFBL0IsRUFBdUM7VUFDckMsSUFBSTdzQixHQUFHLEdBQUcsQ0FBVixFQUFhO1lBQUVBLEdBQUcsR0FBRyxDQUFOOzs7VUFDZkEsR0FBRyxHQUFHbmhELElBQUksQ0FBQysvQixLQUFMLENBQVdvaEIsR0FBWCxDQUFOO1VBQ0E2c0IsTUFBTSxHQUFHaHVFLElBQUksQ0FBQysvQixLQUFMLENBQVdpdUMsTUFBWCxDQUFUO1VBQ0FoN0IsUUFBUSxDQUFDbG9DLFdBQVQsQ0FBcUJxaEQsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMscUJBQWQsRUFBc0MsK0JBQStCNW9CLElBQS9CLEdBQXNDLHlDQUF0QyxHQUFrRjRkLEdBQWxGLEdBQXdGLGFBQXhGLElBQXlHeEIsS0FBSyxJQUFJLElBQVQsR0FBZ0J1M0IsU0FBUyxHQUFHM3pDLElBQTVCLEdBQW1Db2MsS0FBNUksSUFBcUosNENBQXJKLElBQXFNcXVCLE1BQU0sR0FBRzdzQixHQUE5TSxJQUFxTixJQUEzUCxDQUF4Qjs7O1FBR0YsU0FBU2syQixXQUFULENBQXFCcmtCLElBQXJCLEVBQTJCc2tCLE9BQTNCLEVBQW9DQyxLQUFwQyxFQUEyQztVQUN6QyxJQUFJclQsT0FBTyxHQUFHckssT0FBTyxDQUFDQyxHQUFELEVBQU05RyxJQUFOLENBQXJCO1VBQ0EsSUFBSXdrQixPQUFPLEdBQUd0VCxPQUFPLENBQUN6aEIsSUFBUixDQUFhcCtDLE1BQTNCO1VBQ0EsSUFBSXNkLEtBQUosRUFBV3pFLEdBQVg7O1VBQ0EsU0FBUzQwRCxNQUFULENBQWdCNW9ELEVBQWhCLEVBQW9CbWxELElBQXBCLEVBQTBCO1lBQ3hCLE9BQU80RCxXQUFVLENBQUNyZSxFQUFELEVBQUtxSCxHQUFHLENBQUNqSSxJQUFELEVBQU85cEMsRUFBUCxDQUFSLEVBQW9CLEtBQXBCLEVBQTJCZzdDLE9BQTNCLEVBQW9DbUssSUFBcEMsQ0FBakI7OztVQUdGLFNBQVNvSixLQUFULENBQWVsOUQsR0FBZixFQUFvQjIxQyxHQUFwQixFQUF5QnduQixJQUF6QixFQUErQjtZQUM3QixJQUFJQyxNQUFNLEdBQUc1RSxxQkFBcUIsQ0FBQ25mLEVBQUQsRUFBS3NRLE9BQUwsRUFBYyxJQUFkLEVBQW9CM3BELEdBQXBCLENBQWxDO1lBQ0EsSUFBSW96QyxJQUFJLEdBQUl1QyxHQUFHLElBQUksS0FBUixLQUFtQnduQixJQUFJLElBQUksT0FBM0IsSUFBc0MsTUFBdEMsR0FBK0MsT0FBMUQ7WUFDQSxJQUFJeHVELEVBQUUsR0FBR3d1RCxJQUFJLElBQUksT0FBUixHQUFrQkMsTUFBTSxDQUFDbDJELEtBQXpCLEdBQWlDazJELE1BQU0sQ0FBQ3o2RCxHQUFQLElBQWMsS0FBS2pNLElBQUwsQ0FBVWl6RCxPQUFPLENBQUN6aEIsSUFBUixDQUFhNzZDLE1BQWIsQ0FBb0IrdkUsTUFBTSxDQUFDejZELEdBQVAsR0FBYSxDQUFqQyxDQUFWLElBQWlELENBQWpELEdBQXFELENBQW5FLENBQTFDO1lBQ0EsT0FBTzQwRCxNQUFNLENBQUM1b0QsRUFBRCxFQUFLeWtDLElBQUwsQ0FBTixDQUFpQkEsSUFBakIsQ0FBUDs7O1VBR0YsSUFBSTZDLEtBQUssR0FBR3VDLFFBQVEsQ0FBQ21SLE9BQUQsRUFBVXBLLEdBQUcsQ0FBQ3RJLFNBQWQsQ0FBcEI7VUFDQWpCLG1CQUFtQixDQUFDQyxLQUFELEVBQVE4bUIsT0FBTyxJQUFJLENBQW5CLEVBQXNCQyxLQUFLLElBQUksSUFBVCxHQUFnQkMsT0FBaEIsR0FBMEJELEtBQWhELEVBQXVELFVBQVUvMkQsSUFBVixFQUFnQndELEVBQWhCLEVBQW9Ca3NDLEdBQXBCLEVBQXlCenBELENBQXpCLEVBQTRCO1lBQ3BHLElBQUkwc0UsR0FBRyxHQUFHampCLEdBQUcsSUFBSSxLQUFqQjtZQUNBLElBQUkwbkIsT0FBTyxHQUFHOUYsTUFBTSxDQUFDdHhELElBQUQsRUFBTzJ5RCxHQUFHLEdBQUcsTUFBSCxHQUFZLE9BQXRCLENBQXBCO1lBQ0EsSUFBSTBFLEtBQUssR0FBRy9GLE1BQU0sQ0FBQzl0RCxFQUFFLEdBQUcsQ0FBTixFQUFTbXZELEdBQUcsR0FBRyxPQUFILEdBQWEsTUFBekIsQ0FBbEI7WUFFQSxJQUFJMkUsU0FBUyxHQUFHUixPQUFPLElBQUksSUFBWCxJQUFtQjkyRCxJQUFJLElBQUksQ0FBM0M7Z0JBQThDdTNELE9BQU8sR0FBR1IsS0FBSyxJQUFJLElBQVQsSUFBaUJ2ekQsRUFBRSxJQUFJd3pELE9BQS9FO1lBQ0EsSUFBSWpqRSxLQUFLLEdBQUc5TixDQUFDLElBQUksQ0FBakI7Z0JBQW9CeW1CLElBQUksR0FBRyxDQUFDc2pDLEtBQUQsSUFBVS9wRCxDQUFDLElBQUkrcEQsS0FBSyxDQUFDbnNELE1BQU4sR0FBZSxDQUF6RDs7WUFDQSxJQUFJd3pFLEtBQUssQ0FBQzEyQixHQUFOLEdBQVl5MkIsT0FBTyxDQUFDejJCLEdBQXBCLElBQTJCLENBQS9CLEVBQWtDOztjQUNoQyxJQUFJNjJCLFFBQVEsR0FBRyxDQUFDWixNQUFNLEdBQUdVLFNBQUgsR0FBZUMsT0FBdEIsS0FBa0N4akUsS0FBakQ7Y0FDQSxJQUFJMGpFLFNBQVMsR0FBRyxDQUFDYixNQUFNLEdBQUdXLE9BQUgsR0FBYUQsU0FBcEIsS0FBa0M1cUQsSUFBbEQ7Y0FDQSxJQUFJcVcsSUFBSSxHQUFHeTBDLFFBQVEsR0FBR2YsUUFBSCxHQUFjLENBQUM5RCxHQUFHLEdBQUd5RSxPQUFILEdBQWFDLEtBQWpCLEVBQXdCdDBDLElBQXpEO2NBQ0EsSUFBSXF5QixLQUFLLEdBQUdxaUIsU0FBUyxHQUFHZixTQUFILEdBQWUsQ0FBQy9ELEdBQUcsR0FBRzBFLEtBQUgsR0FBV0QsT0FBZixFQUF3QmhpQixLQUE1RDtjQUNBdGlDLEdBQUcsQ0FBQ2lRLElBQUQsRUFBT3EwQyxPQUFPLENBQUN6MkIsR0FBZixFQUFvQnlVLEtBQUssR0FBR3J5QixJQUE1QixFQUFrQ3EwQyxPQUFPLENBQUM1SixNQUExQyxDQUFIO2FBTEYsTUFNTzs7Y0FDTCxJQUFJa0ssT0FBSixFQUFhQyxRQUFiLEVBQXVCQyxPQUF2QixFQUFnQ0MsUUFBaEM7O2NBQ0EsSUFBSWxGLEdBQUosRUFBUztnQkFDUCtFLE9BQU8sR0FBR2QsTUFBTSxJQUFJVSxTQUFWLElBQXVCdmpFLEtBQXZCLEdBQStCMGlFLFFBQS9CLEdBQTBDVyxPQUFPLENBQUNyMEMsSUFBNUQ7Z0JBQ0E0MEMsUUFBUSxHQUFHZixNQUFNLEdBQUdGLFNBQUgsR0FBZU8sS0FBSyxDQUFDajNELElBQUQsRUFBTzB2QyxHQUFQLEVBQVksUUFBWixDQUFyQztnQkFDQWtvQixPQUFPLEdBQUdoQixNQUFNLEdBQUdILFFBQUgsR0FBY1EsS0FBSyxDQUFDenpELEVBQUQsRUFBS2tzQyxHQUFMLEVBQVUsT0FBVixDQUFuQztnQkFDQW1vQixRQUFRLEdBQUdqQixNQUFNLElBQUlXLE9BQVYsSUFBcUI3cUQsSUFBckIsR0FBNEJncUQsU0FBNUIsR0FBd0NXLEtBQUssQ0FBQ2ppQixLQUF6RDtlQUpGLE1BS087Z0JBQ0xzaUIsT0FBTyxHQUFHLENBQUNkLE1BQUQsR0FBVUgsUUFBVixHQUFxQlEsS0FBSyxDQUFDajNELElBQUQsRUFBTzB2QyxHQUFQLEVBQVksUUFBWixDQUFwQztnQkFDQWlvQixRQUFRLEdBQUcsQ0FBQ2YsTUFBRCxJQUFXVSxTQUFYLElBQXdCdmpFLEtBQXhCLEdBQWdDMmlFLFNBQWhDLEdBQTRDVSxPQUFPLENBQUNoaUIsS0FBL0Q7Z0JBQ0F3aUIsT0FBTyxHQUFHLENBQUNoQixNQUFELElBQVdXLE9BQVgsSUFBc0I3cUQsSUFBdEIsR0FBNkIrcEQsUUFBN0IsR0FBd0NZLEtBQUssQ0FBQ3QwQyxJQUF4RDtnQkFDQTgwQyxRQUFRLEdBQUcsQ0FBQ2pCLE1BQUQsR0FBVUYsU0FBVixHQUFzQk8sS0FBSyxDQUFDenpELEVBQUQsRUFBS2tzQyxHQUFMLEVBQVUsT0FBVixDQUF0Qzs7O2NBRUY1OEIsR0FBRyxDQUFDNGtELE9BQUQsRUFBVU4sT0FBTyxDQUFDejJCLEdBQWxCLEVBQXVCZzNCLFFBQVEsR0FBR0QsT0FBbEMsRUFBMkNOLE9BQU8sQ0FBQzVKLE1BQW5ELENBQUg7O2NBQ0EsSUFBSTRKLE9BQU8sQ0FBQzVKLE1BQVIsR0FBaUI2SixLQUFLLENBQUMxMkIsR0FBM0IsRUFBZ0M7Z0JBQUU3dEIsR0FBRyxDQUFDMmpELFFBQUQsRUFBV1csT0FBTyxDQUFDNUosTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUM2SixLQUFLLENBQUMxMkIsR0FBdkMsQ0FBSDs7O2NBQ2xDN3RCLEdBQUcsQ0FBQzhrRCxPQUFELEVBQVVQLEtBQUssQ0FBQzEyQixHQUFoQixFQUFxQmszQixRQUFRLEdBQUdELE9BQWhDLEVBQXlDUCxLQUFLLENBQUM3SixNQUEvQyxDQUFIOzs7WUFHRixJQUFJLENBQUNyc0QsS0FBRCxJQUFVcTFELFNBQVMsQ0FBQ1ksT0FBRCxFQUFVajJELEtBQVYsQ0FBVCxHQUE0QixDQUExQyxFQUE2QztjQUFFQSxLQUFLLEdBQUdpMkQsT0FBUjs7O1lBQy9DLElBQUlaLFNBQVMsQ0FBQ2EsS0FBRCxFQUFRbDJELEtBQVIsQ0FBVCxHQUEwQixDQUE5QixFQUFpQztjQUFFQSxLQUFLLEdBQUdrMkQsS0FBUjs7O1lBQ25DLElBQUksQ0FBQzM2RCxHQUFELElBQVE4NUQsU0FBUyxDQUFDWSxPQUFELEVBQVUxNkQsR0FBVixDQUFULEdBQTBCLENBQXRDLEVBQXlDO2NBQUVBLEdBQUcsR0FBRzA2RCxPQUFOOzs7WUFDM0MsSUFBSVosU0FBUyxDQUFDYSxLQUFELEVBQVEzNkQsR0FBUixDQUFULEdBQXdCLENBQTVCLEVBQStCO2NBQUVBLEdBQUcsR0FBRzI2RCxLQUFOOztXQWxDaEIsQ0FBbkI7VUFvQ0EsT0FBTztZQUFDbDJELEtBQUssRUFBRUEsS0FBUjtZQUFlekUsR0FBRyxFQUFFQTtXQUEzQjs7O1FBR0YsSUFBSW83RCxLQUFLLEdBQUc5MEIsS0FBSyxDQUFDaGpDLElBQU4sRUFBWjtZQUEwQiszRCxHQUFHLEdBQUcvMEIsS0FBSyxDQUFDeC9CLEVBQU4sRUFBaEM7O1FBQ0EsSUFBSXMwRCxLQUFLLENBQUN0bEIsSUFBTixJQUFjdWxCLEdBQUcsQ0FBQ3ZsQixJQUF0QixFQUE0QjtVQUMxQnFrQixXQUFXLENBQUNpQixLQUFLLENBQUN0bEIsSUFBUCxFQUFhc2xCLEtBQUssQ0FBQ3B2RCxFQUFuQixFQUF1QnF2RCxHQUFHLENBQUNydkQsRUFBM0IsQ0FBWDtTQURGLE1BRU87VUFDTCxJQUFJc3ZELFFBQVEsR0FBRzNlLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNd2UsS0FBSyxDQUFDdGxCLElBQVosQ0FBdEI7Y0FBeUN5bEIsTUFBTSxHQUFHNWUsT0FBTyxDQUFDQyxHQUFELEVBQU15ZSxHQUFHLENBQUN2bEIsSUFBVixDQUF6RDtVQUNBLElBQUkwbEIsV0FBVyxHQUFHclYsVUFBVSxDQUFDbVYsUUFBRCxDQUFWLElBQXdCblYsVUFBVSxDQUFDb1YsTUFBRCxDQUFwRDtVQUNBLElBQUlFLE9BQU8sR0FBR3RCLFdBQVcsQ0FBQ2lCLEtBQUssQ0FBQ3RsQixJQUFQLEVBQWFzbEIsS0FBSyxDQUFDcHZELEVBQW5CLEVBQXVCd3ZELFdBQVcsR0FBR0YsUUFBUSxDQUFDLzFCLElBQVQsQ0FBY3ArQyxNQUFkLEdBQXVCLENBQTFCLEdBQThCLElBQWhFLENBQVgsQ0FBaUY2WSxHQUEvRjtVQUNBLElBQUkwN0QsVUFBVSxHQUFHdkIsV0FBVyxDQUFDa0IsR0FBRyxDQUFDdmxCLElBQUwsRUFBVzBsQixXQUFXLEdBQUcsQ0FBSCxHQUFPLElBQTdCLEVBQW1DSCxHQUFHLENBQUNydkQsRUFBdkMsQ0FBWCxDQUFzRHZILEtBQXZFOztVQUNBLElBQUkrMkQsV0FBSixFQUFpQjtZQUNmLElBQUlDLE9BQU8sQ0FBQ3gzQixHQUFSLEdBQWN5M0IsVUFBVSxDQUFDejNCLEdBQVgsR0FBaUIsQ0FBbkMsRUFBc0M7Y0FDcEM3dEIsR0FBRyxDQUFDcWxELE9BQU8sQ0FBQy9pQixLQUFULEVBQWdCK2lCLE9BQU8sQ0FBQ3gzQixHQUF4QixFQUE2QixJQUE3QixFQUFtQ3czQixPQUFPLENBQUMzSyxNQUEzQyxDQUFIO2NBQ0ExNkMsR0FBRyxDQUFDMmpELFFBQUQsRUFBVzJCLFVBQVUsQ0FBQ3ozQixHQUF0QixFQUEyQnkzQixVQUFVLENBQUNyMUMsSUFBdEMsRUFBNENxMUMsVUFBVSxDQUFDNUssTUFBdkQsQ0FBSDthQUZGLE1BR087Y0FDTDE2QyxHQUFHLENBQUNxbEQsT0FBTyxDQUFDL2lCLEtBQVQsRUFBZ0IraUIsT0FBTyxDQUFDeDNCLEdBQXhCLEVBQTZCeTNCLFVBQVUsQ0FBQ3IxQyxJQUFYLEdBQWtCbzFDLE9BQU8sQ0FBQy9pQixLQUF2RCxFQUE4RCtpQixPQUFPLENBQUMzSyxNQUF0RSxDQUFIOzs7O1VBR0osSUFBSTJLLE9BQU8sQ0FBQzNLLE1BQVIsR0FBaUI0SyxVQUFVLENBQUN6M0IsR0FBaEMsRUFDRTtZQUFFN3RCLEdBQUcsQ0FBQzJqRCxRQUFELEVBQVcwQixPQUFPLENBQUMzSyxNQUFuQixFQUEyQixJQUEzQixFQUFpQzRLLFVBQVUsQ0FBQ3ozQixHQUE1QyxDQUFIOzs7O1FBR05qM0IsTUFBTSxDQUFDcGYsV0FBUCxDQUFtQmtvQyxRQUFuQjtPQXRzR2lCOzs7TUEwc0duQixTQUFTNmxDLFlBQVQsQ0FBc0JqbEIsRUFBdEIsRUFBMEI7UUFDeEIsSUFBSSxDQUFDQSxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWQsRUFBdUI7VUFBRTs7O1FBQ3pCLElBQUlqdUUsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtRQUNBa3VFLGFBQWEsQ0FBQ2x1RSxPQUFPLENBQUNtdUUsT0FBVCxDQUFiO1FBQ0EsSUFBSTlsQixFQUFFLEdBQUcsSUFBVDtRQUNBcm9ELE9BQU8sQ0FBQ291RSxTQUFSLENBQWtCcnVFLEtBQWxCLENBQXdCc3VFLFVBQXhCLEdBQXFDLEVBQXJDOztRQUNBLElBQUl0bEIsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV3dxQyxlQUFYLEdBQTZCLENBQWpDLEVBQ0U7VUFBRXR1RSxPQUFPLENBQUNtdUUsT0FBUixHQUFrQnIwQyxXQUFXLENBQUMsWUFBWTtZQUMxQyxJQUFJLENBQUNpdkIsRUFBRSxDQUFDd2xCLFFBQUgsRUFBTCxFQUFvQjtjQUFFbHhCLE1BQU0sQ0FBQzBMLEVBQUQsQ0FBTjs7O1lBQ3RCL29ELE9BQU8sQ0FBQ291RSxTQUFSLENBQWtCcnVFLEtBQWxCLENBQXdCc3VFLFVBQXhCLEdBQXFDLENBQUNobUIsRUFBRSxHQUFHLENBQUNBLEVBQVAsSUFBYSxFQUFiLEdBQWtCLFFBQXZEO1dBRjZCLEVBRzVCVSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXd3FDLGVBSGlCLENBQTdCO1NBREosTUFLSyxJQUFJdmxCLEVBQUUsQ0FBQ2psQixPQUFILENBQVd3cUMsZUFBWCxHQUE2QixDQUFqQyxFQUNIO1VBQUV0dUUsT0FBTyxDQUFDb3VFLFNBQVIsQ0FBa0JydUUsS0FBbEIsQ0FBd0JzdUUsVUFBeEIsR0FBcUMsUUFBckM7Ozs7TUFHTixTQUFTRyxXQUFULENBQXFCemxCLEVBQXJCLEVBQXlCO1FBQ3ZCLElBQUksQ0FBQ0EsRUFBRSxDQUFDd2xCLFFBQUgsRUFBTCxFQUFvQjtVQUNsQnhsQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUI5ZSxLQUFqQjs7VUFDQSxJQUFJLENBQUNzTCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWQsRUFBdUI7WUFBRTd3QixPQUFPLENBQUMyTCxFQUFELENBQVA7Ozs7O01BSTdCLFNBQVMwbEIsY0FBVCxDQUF3QjFsQixFQUF4QixFQUE0QjtRQUMxQkEsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3l2QyxpQkFBVCxHQUE2QixJQUE3QjtRQUNBOXNELFVBQVUsQ0FBQyxZQUFZO1VBQUUsSUFBSW1uQyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeXZDLGlCQUFiLEVBQWdDO1lBQ3ZEM2xCLEVBQUUsQ0FBQzlwQixLQUFILENBQVN5dkMsaUJBQVQsR0FBNkIsS0FBN0I7O1lBQ0EsSUFBSTNsQixFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWIsRUFBc0I7Y0FBRTV3QixNQUFNLENBQUMwTCxFQUFELENBQU47OztTQUZoQixFQUdMLEdBSEssQ0FBVjs7O01BTUYsU0FBUzNMLE9BQVQsQ0FBaUIyTCxFQUFqQixFQUFxQm56RCxDQUFyQixFQUF3QjtRQUN0QixJQUFJbXpELEVBQUUsQ0FBQzlwQixLQUFILENBQVN5dkMsaUJBQVQsSUFBOEIsQ0FBQzNsQixFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHZDLFlBQTVDLEVBQTBEO1VBQUU1bEIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3l2QyxpQkFBVCxHQUE2QixLQUE3Qjs7O1FBRTVELElBQUkzbEIsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2t6QixRQUFYLElBQXVCLFVBQTNCLEVBQXVDO1VBQUU7OztRQUN6QyxJQUFJLENBQUNqTyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWQsRUFBdUI7VUFDckJybEIsTUFBTSxDQUFDRyxFQUFELEVBQUssT0FBTCxFQUFjQSxFQUFkLEVBQWtCbnpELENBQWxCLENBQU47VUFDQW16RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQVQsR0FBbUIsSUFBbkI7VUFDQTdyQixRQUFRLENBQUMyRyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVosRUFBcUIsb0JBQXJCLENBQVIsQ0FIcUI7Ozs7VUFPckIsSUFBSSxDQUFDc2lDLEVBQUUsQ0FBQ08sS0FBSixJQUFhUCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXNHVFLGlCQUFYLElBQWdDN2xCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VjLEdBQXhELEVBQTZEO1lBQzNEemlCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQmg4QixLQUFqQjs7WUFDQSxJQUFJcWYsTUFBSixFQUFZO2NBQUVoK0IsVUFBVSxDQUFDLFlBQVk7Z0JBQUUsT0FBT21uQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUJoOEIsS0FBakIsQ0FBdUIsSUFBdkIsQ0FBUDtlQUFmLEVBQXVELEVBQXZELENBQVY7YUFGNkM7Ozs7VUFJN0R3b0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCc1MsYUFBakI7OztRQUVGYixZQUFZLENBQUNqbEIsRUFBRCxDQUFaOzs7TUFFRixTQUFTMUwsTUFBVCxDQUFnQjBMLEVBQWhCLEVBQW9CbnpELENBQXBCLEVBQXVCO1FBQ3JCLElBQUltekQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3l2QyxpQkFBYixFQUFnQztVQUFFOzs7UUFFbEMsSUFBSTNsQixFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWIsRUFBc0I7VUFDcEJybEIsTUFBTSxDQUFDRyxFQUFELEVBQUssTUFBTCxFQUFhQSxFQUFiLEVBQWlCbnpELENBQWpCLENBQU47VUFDQW16RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQVQsR0FBbUIsS0FBbkI7VUFDQWp0QixPQUFPLENBQUMrSCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVosRUFBcUIsb0JBQXJCLENBQVA7OztRQUVGeW5ELGFBQWEsQ0FBQ25sQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXVFLE9BQVosQ0FBYjtRQUNBdnNELFVBQVUsQ0FBQyxZQUFZO1VBQUUsSUFBSSxDQUFDbW5DLEVBQUUsQ0FBQzlwQixLQUFILENBQVNndkMsT0FBZCxFQUF1QjtZQUFFbGxCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc4dUUsS0FBWCxHQUFtQixLQUFuQjs7U0FBeEMsRUFBdUUsR0FBdkUsQ0FBVjtPQXB3R2lCOzs7O01BeXdHbkIsU0FBU0MsdUJBQVQsQ0FBaUNobUIsRUFBakMsRUFBcUM7UUFDbkMsSUFBSS9vRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1FBQ0EsSUFBSWd2RSxVQUFVLEdBQUdodkUsT0FBTyxDQUFDaXZFLE9BQVIsQ0FBZ0JwTixTQUFqQztRQUNBLElBQUlxTixPQUFPLEdBQUcvNUUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLENBQVQsRUFBWXFDLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCcnNCLHFCQUFqQixHQUF5Q0ksR0FBckQsQ0FBZDtRQUNBLElBQUk2NEIsU0FBUyxHQUFHbnZFLE9BQU8sQ0FBQ2l2RSxPQUFSLENBQWdCLzRCLHFCQUFoQixHQUF3Q0ksR0FBeEQ7UUFDQSxJQUFJODRCLFVBQVUsR0FBRyxDQUFqQjs7UUFDQSxLQUFLLElBQUl4ekUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29FLE9BQU8sQ0FBQ2t0QixJQUFSLENBQWExekIsTUFBakMsRUFBeUNvQyxDQUFDLEVBQTFDLEVBQThDO1VBQzVDLElBQUlvcUQsR0FBRyxHQUFHaG1ELE9BQU8sQ0FBQ2t0QixJQUFSLENBQWF0eEIsQ0FBYixDQUFWO2NBQTJCaW5FLFFBQVEsR0FBRzlaLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBakQ7VUFDQSxJQUFJOXRCLE1BQU0sR0FBSSxLQUFLLENBQW5CO2NBQXVCRixLQUFLLEdBQUcsQ0FBL0I7O1VBQ0EsSUFBSWtSLEdBQUcsQ0FBQ29YLE1BQVIsRUFBZ0I7WUFBRTs7O1VBQ2xCK1IsU0FBUyxJQUFJbnBCLEdBQUcsQ0FBQ21DLElBQUosQ0FBU25ULE1BQXRCOztVQUNBLElBQUl5SyxFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtZQUN4QixJQUFJd2xCLEdBQUcsR0FBR2xmLEdBQUcsQ0FBQ2pqQyxJQUFKLENBQVM4K0MsU0FBVCxHQUFxQjdiLEdBQUcsQ0FBQ2pqQyxJQUFKLENBQVN5bkMsWUFBeEM7WUFDQXhWLE1BQU0sR0FBR2t3QixHQUFHLEdBQUc4SixVQUFmO1lBQ0FBLFVBQVUsR0FBRzlKLEdBQWI7V0FIRixNQUlPO1lBQ0wsSUFBSW1ELEdBQUcsR0FBR3JpQixHQUFHLENBQUNqakMsSUFBSixDQUFTbXpCLHFCQUFULEVBQVY7WUFDQWxCLE1BQU0sR0FBR3F6QixHQUFHLENBQUNsRixNQUFKLEdBQWFrRixHQUFHLENBQUMveEIsR0FBMUIsQ0FGSzs7O1lBS0wsSUFBSSxDQUFDdXNCLFFBQUQsSUFBYTdjLEdBQUcsQ0FBQ3BPLElBQUosQ0FBU25TLFVBQTFCLEVBQ0U7Y0FBRXFQLEtBQUssR0FBR2tSLEdBQUcsQ0FBQ3BPLElBQUosQ0FBU25TLFVBQVQsQ0FBb0J5USxxQkFBcEIsR0FBNEM2VSxLQUE1QyxHQUFvRHNkLEdBQUcsQ0FBQzN2QyxJQUF4RCxHQUErRCxDQUF2RTs7OztVQUVOLElBQUlnM0IsSUFBSSxHQUFHMUosR0FBRyxDQUFDbUMsSUFBSixDQUFTblQsTUFBVCxHQUFrQkEsTUFBN0I7O1VBQ0EsSUFBSTBhLElBQUksR0FBRyxJQUFQLElBQWVBLElBQUksR0FBRyxDQUFDLElBQTNCLEVBQWlDO1lBQy9CLElBQUl5ZixTQUFTLEdBQUdELE9BQWhCLEVBQXlCO2NBQUVFLFVBQVUsSUFBSTFmLElBQWQ7OztZQUMzQkQsZ0JBQWdCLENBQUN6SixHQUFHLENBQUNtQyxJQUFMLEVBQVduVCxNQUFYLENBQWhCO1lBQ0FxNkIsa0JBQWtCLENBQUNycEIsR0FBRyxDQUFDbUMsSUFBTCxDQUFsQjs7WUFDQSxJQUFJbkMsR0FBRyxDQUFDMlUsSUFBUixFQUFjO2NBQUUsS0FBSyxJQUFJLzJELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvaUQsR0FBRyxDQUFDMlUsSUFBSixDQUFTbmhFLE1BQTdCLEVBQXFDb0ssQ0FBQyxFQUF0QyxFQUNkO2dCQUFFeXJFLGtCQUFrQixDQUFDcnBCLEdBQUcsQ0FBQzJVLElBQUosQ0FBUy8yRCxDQUFULENBQUQsQ0FBbEI7Ozs7O1VBRU4sSUFBSWt4QyxLQUFLLEdBQUdpVSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXc3NFLFVBQXZCLEVBQW1DO1lBQ2pDLElBQUlnRCxPQUFPLEdBQUduNkUsSUFBSSxDQUFDbUksSUFBTCxDQUFVdzNDLEtBQUssR0FBR2t3QixTQUFTLENBQUNqYyxFQUFFLENBQUMvb0QsT0FBSixDQUEzQixDQUFkOztZQUNBLElBQUlzdkUsT0FBTyxHQUFHdm1CLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd5NUQsYUFBekIsRUFBd0M7Y0FDdEMxUSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeTVELGFBQVgsR0FBMkI2VixPQUEzQjtjQUNBdm1CLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd3NUQsT0FBWCxHQUFxQnhULEdBQUcsQ0FBQ21DLElBQXpCO2NBQ0FZLEVBQUUsQ0FBQy9vRCxPQUFILENBQVcwNUQsY0FBWCxHQUE0QixJQUE1Qjs7Ozs7UUFJTixJQUFJdmtFLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUytpRSxVQUFULElBQXVCLENBQTNCLEVBQThCO1VBQUVwdkUsT0FBTyxDQUFDdWlFLFFBQVIsQ0FBaUJpRSxTQUFqQixJQUE4QjRJLFVBQTlCOztPQWp6R2Y7Ozs7TUFzekduQixTQUFTQyxrQkFBVCxDQUE0QmxuQixJQUE1QixFQUFrQztRQUNoQyxJQUFJQSxJQUFJLENBQUN3WSxPQUFULEVBQWtCO1VBQUUsS0FBSyxJQUFJL2tFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1c0QsSUFBSSxDQUFDd1ksT0FBTCxDQUFhbm5FLE1BQWpDLEVBQXlDLEVBQUVvQyxDQUEzQyxFQUE4QztZQUNoRSxJQUFJQyxDQUFDLEdBQUdzc0QsSUFBSSxDQUFDd1ksT0FBTCxDQUFhL2tFLENBQWIsQ0FBUjtnQkFBeUI0bUIsTUFBTSxHQUFHM21CLENBQUMsQ0FBQ2tuQixJQUFGLENBQU9pbEIsVUFBekM7O1lBQ0EsSUFBSXhsQixNQUFKLEVBQVk7Y0FBRTNtQixDQUFDLENBQUNtNUMsTUFBRixHQUFXeHlCLE1BQU0sQ0FBQ2dvQyxZQUFsQjs7OztPQXp6R0M7Ozs7O01BZzBHbkIsU0FBUytrQixZQUFULENBQXNCdnZFLE9BQXRCLEVBQStCaXZELEdBQS9CLEVBQW9DdWdCLFFBQXBDLEVBQThDO1FBQzVDLElBQUlsNUIsR0FBRyxHQUFHazVCLFFBQVEsSUFBSUEsUUFBUSxDQUFDbDVCLEdBQVQsSUFBZ0IsSUFBNUIsR0FBbUNuaEQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLENBQVQsRUFBWTZ4RSxRQUFRLENBQUNsNUIsR0FBckIsQ0FBbkMsR0FBK0R0MkMsT0FBTyxDQUFDdWlFLFFBQVIsQ0FBaUJpRSxTQUExRjtRQUNBbHdCLEdBQUcsR0FBR25oRCxJQUFJLENBQUNvSSxLQUFMLENBQVcrNEMsR0FBRyxHQUFHcXJCLFVBQVUsQ0FBQzNoRSxPQUFELENBQTNCLENBQU47UUFDQSxJQUFJbWpFLE1BQU0sR0FBR3FNLFFBQVEsSUFBSUEsUUFBUSxDQUFDck0sTUFBVCxJQUFtQixJQUEvQixHQUFzQ3FNLFFBQVEsQ0FBQ3JNLE1BQS9DLEdBQXdEN3NCLEdBQUcsR0FBR3QyQyxPQUFPLENBQUN5bUIsT0FBUixDQUFnQmk4QyxZQUEzRjs7UUFFQSxJQUFJL3NELElBQUksR0FBR2s2QyxhQUFZLENBQUNaLEdBQUQsRUFBTTNZLEdBQU4sQ0FBdkI7WUFBbUNuOUIsRUFBRSxHQUFHMDJDLGFBQVksQ0FBQ1osR0FBRCxFQUFNa1UsTUFBTixDQUFwRCxDQUw0Qzs7OztRQVE1QyxJQUFJcU0sUUFBUSxJQUFJQSxRQUFRLENBQUNDLE1BQXpCLEVBQWlDO1VBQy9CLElBQUlDLFVBQVUsR0FBR0YsUUFBUSxDQUFDQyxNQUFULENBQWdCOTVELElBQWhCLENBQXFCd3lDLElBQXRDO2NBQTRDd25CLFFBQVEsR0FBR0gsUUFBUSxDQUFDQyxNQUFULENBQWdCdDJELEVBQWhCLENBQW1CZ3ZDLElBQTFFOztVQUNBLElBQUl1bkIsVUFBVSxHQUFHLzVELElBQWpCLEVBQXVCO1lBQ3JCQSxJQUFJLEdBQUcrNUQsVUFBUDtZQUNBdjJELEVBQUUsR0FBRzAyQyxhQUFZLENBQUNaLEdBQUQsRUFBTW1LLGFBQVksQ0FBQ3BLLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNeWdCLFVBQU4sQ0FBUixDQUFaLEdBQXlDMXZFLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCaThDLFlBQS9ELENBQWpCO1dBRkYsTUFHTyxJQUFJdnRFLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU2t5RSxRQUFULEVBQW1CMWdCLEdBQUcsQ0FBQytKLFFBQUosRUFBbkIsS0FBc0M3L0MsRUFBMUMsRUFBOEM7WUFDbkR4RCxJQUFJLEdBQUdrNkMsYUFBWSxDQUFDWixHQUFELEVBQU1tSyxhQUFZLENBQUNwSyxPQUFPLENBQUNDLEdBQUQsRUFBTTBnQixRQUFOLENBQVIsQ0FBWixHQUF1QzN2RSxPQUFPLENBQUN5bUIsT0FBUixDQUFnQmk4QyxZQUE3RCxDQUFuQjtZQUNBdnBELEVBQUUsR0FBR3cyRCxRQUFMOzs7O1FBR0osT0FBTztVQUFDaDZELElBQUksRUFBRUEsSUFBUDtVQUFhd0QsRUFBRSxFQUFFaGtCLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3diLEVBQVQsRUFBYXhELElBQUksR0FBRyxDQUFwQjtTQUF4QjtPQWwxR2lCOzs7OztNQXkxR25CLFNBQVNpNkQsaUJBQVQsQ0FBMkI3bUIsRUFBM0IsRUFBK0I5UyxJQUEvQixFQUFxQztRQUNuQyxJQUFJNlMsY0FBYyxDQUFDQyxFQUFELEVBQUssc0JBQUwsQ0FBbEIsRUFBZ0Q7VUFBRTs7O1FBRWxELElBQUkvb0QsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtZQUEwQnFvRSxHQUFHLEdBQUdyb0UsT0FBTyxDQUFDeWhFLEtBQVIsQ0FBY3ZyQixxQkFBZCxFQUFoQztZQUF1RTI1QixRQUFRLEdBQUcsSUFBbEY7O1FBQ0EsSUFBSTU1QixJQUFJLENBQUNLLEdBQUwsR0FBVyt4QixHQUFHLENBQUMveEIsR0FBZixHQUFxQixDQUF6QixFQUE0QjtVQUFFdTVCLFFBQVEsR0FBRyxJQUFYO1NBQTlCLE1BQ0ssSUFBSTU1QixJQUFJLENBQUNrdEIsTUFBTCxHQUFja0YsR0FBRyxDQUFDL3hCLEdBQWxCLElBQXlCcGhELE1BQU0sQ0FBQzQ2RSxXQUFQLElBQXNCdjVFLFFBQVEsQ0FBQ2lKLGVBQVQsQ0FBeUJrakUsWUFBeEUsQ0FBSixFQUEyRjtVQUFFbU4sUUFBUSxHQUFHLEtBQVg7OztRQUNsRyxJQUFJQSxRQUFRLElBQUksSUFBWixJQUFvQixDQUFDMXZCLE9BQXpCLEVBQWtDO1VBQ2hDLElBQUk0dkIsVUFBVSxHQUFHenVCLEdBQUcsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQixJQUFsQixFQUF5Qix5REFBeURyTCxJQUFJLENBQUNLLEdBQUwsR0FBV3QyQyxPQUFPLENBQUM2bUUsVUFBbkIsR0FBZ0NsRixVQUFVLENBQUM1WSxFQUFFLENBQUMvb0QsT0FBSixDQUFuRyxJQUFtSCx3Q0FBbkgsSUFBK0ppMkMsSUFBSSxDQUFDa3RCLE1BQUwsR0FBY2x0QixJQUFJLENBQUNLLEdBQW5CLEdBQXlCOHJCLFNBQVMsQ0FBQ3JaLEVBQUQsQ0FBbEMsR0FBeUMvb0QsT0FBTyxDQUFDMmlFLFNBQWhOLElBQTZOLHNDQUE3TixHQUF1UTFzQixJQUFJLENBQUN2ZCxJQUE1USxHQUFvUixhQUFwUixHQUFxU3ZqQyxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZczRDLElBQUksQ0FBQzhVLEtBQUwsR0FBYTlVLElBQUksQ0FBQ3ZkLElBQTlCLENBQXJTLEdBQTRVLEtBQXJXLENBQXBCO1VBQ0Fxd0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzRoRSxTQUFYLENBQXFCM2hFLFdBQXJCLENBQWlDOHZFLFVBQWpDO1VBQ0FBLFVBQVUsQ0FBQ0MsY0FBWCxDQUEwQkgsUUFBMUI7VUFDQTltQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXNGhFLFNBQVgsQ0FBcUJqZ0QsV0FBckIsQ0FBaUNvdUQsVUFBakM7O09BbjJHZTs7Ozs7TUEwMkduQixTQUFTRSxpQkFBVCxDQUEyQmxuQixFQUEzQixFQUErQnI1QyxHQUEvQixFQUFvQzJDLEdBQXBDLEVBQXlDNjlELE1BQXpDLEVBQWlEO1FBQy9DLElBQUlBLE1BQU0sSUFBSSxJQUFkLEVBQW9CO1VBQUVBLE1BQU0sR0FBRyxDQUFUOzs7UUFDdEIsSUFBSWo2QixJQUFKOztRQUNBLElBQUksQ0FBQzhTLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBWixJQUE0QnB6RCxHQUFHLElBQUkyQyxHQUF2QyxFQUE0Qzs7OztVQUkxQ0EsR0FBRyxHQUFHM0MsR0FBRyxDQUFDdUssTUFBSixJQUFjLFFBQWQsR0FBeUJtMkMsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFMLEVBQVd6NEMsR0FBRyxDQUFDMk8sRUFBSixHQUFTLENBQXBCLEVBQXVCLFFBQXZCLENBQTVCLEdBQStEM08sR0FBckU7VUFDQUEsR0FBRyxHQUFHQSxHQUFHLENBQUMyTyxFQUFKLEdBQVMreEMsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFMLEVBQVd6NEMsR0FBRyxDQUFDdUssTUFBSixJQUFjLFFBQWQsR0FBeUJ2SyxHQUFHLENBQUMyTyxFQUFKLEdBQVMsQ0FBbEMsR0FBc0MzTyxHQUFHLENBQUMyTyxFQUFyRCxFQUF5RCxPQUF6RCxDQUFaLEdBQWdGM08sR0FBdEY7OztRQUVGLEtBQUssSUFBSTBQLEtBQUssR0FBRyxDQUFqQixFQUFvQkEsS0FBSyxHQUFHLENBQTVCLEVBQStCQSxLQUFLLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUkrd0QsT0FBTyxHQUFHLEtBQWQ7O1VBQ0EsSUFBSWxKLE1BQU0sR0FBR0ksYUFBWSxDQUFDdGUsRUFBRCxFQUFLcjVDLEdBQUwsQ0FBekI7O1VBQ0EsSUFBSTBnRSxTQUFTLEdBQUcsQ0FBQy85RCxHQUFELElBQVFBLEdBQUcsSUFBSTNDLEdBQWYsR0FBcUJ1M0QsTUFBckIsR0FBOEJJLGFBQVksQ0FBQ3RlLEVBQUQsRUFBSzEyQyxHQUFMLENBQTFEO1VBQ0E0akMsSUFBSSxHQUFHO1lBQUN2ZCxJQUFJLEVBQUV2akMsSUFBSSxDQUFDc0ksR0FBTCxDQUFTd3BFLE1BQU0sQ0FBQ3Z1QyxJQUFoQixFQUFzQjAzQyxTQUFTLENBQUMxM0MsSUFBaEMsQ0FBUDtZQUNDNGQsR0FBRyxFQUFFbmhELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3dwRSxNQUFNLENBQUMzd0IsR0FBaEIsRUFBcUI4NUIsU0FBUyxDQUFDOTVCLEdBQS9CLElBQXNDNDVCLE1BRDVDO1lBRUNubEIsS0FBSyxFQUFFNTFELElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3NwRSxNQUFNLENBQUN2dUMsSUFBaEIsRUFBc0IwM0MsU0FBUyxDQUFDMTNDLElBQWhDLENBRlI7WUFHQ3lxQyxNQUFNLEVBQUVodUUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTc3BFLE1BQU0sQ0FBQzlELE1BQWhCLEVBQXdCaU4sU0FBUyxDQUFDak4sTUFBbEMsSUFBNEMrTTtXQUg1RDtVQUlBLElBQUlHLFNBQVMsR0FBR0Msa0JBQWtCLENBQUN2bkIsRUFBRCxFQUFLOVMsSUFBTCxDQUFsQztVQUNBLElBQUlzNkIsUUFBUSxHQUFHeG5CLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VYLFNBQXRCO2NBQWlDZ0ssU0FBUyxHQUFHem5CLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT21YLFVBQXBEOztVQUNBLElBQUlpSyxTQUFTLENBQUM3SixTQUFWLElBQXVCLElBQTNCLEVBQWlDO1lBQy9CaUssZUFBZSxDQUFDMW5CLEVBQUQsRUFBS3NuQixTQUFTLENBQUM3SixTQUFmLENBQWY7O1lBQ0EsSUFBSXJ4RSxJQUFJLENBQUNrWCxHQUFMLENBQVMwOEMsRUFBRSxDQUFDa0csR0FBSCxDQUFPdVgsU0FBUCxHQUFtQitKLFFBQTVCLElBQXdDLENBQTVDLEVBQStDO2NBQUVKLE9BQU8sR0FBRyxJQUFWOzs7O1VBRW5ELElBQUlFLFNBQVMsQ0FBQ2pLLFVBQVYsSUFBd0IsSUFBNUIsRUFBa0M7WUFDaENzSyxhQUFhLENBQUMzbkIsRUFBRCxFQUFLc25CLFNBQVMsQ0FBQ2pLLFVBQWYsQ0FBYjs7WUFDQSxJQUFJanhFLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzA4QyxFQUFFLENBQUNrRyxHQUFILENBQU9tWCxVQUFQLEdBQW9Cb0ssU0FBN0IsSUFBMEMsQ0FBOUMsRUFBaUQ7Y0FBRUwsT0FBTyxHQUFHLElBQVY7Ozs7VUFFckQsSUFBSSxDQUFDQSxPQUFMLEVBQWM7WUFBRTs7OztRQUVsQixPQUFPbDZCLElBQVA7T0F4NEdpQjs7O01BNDRHbkIsU0FBUys1QixjQUFULENBQXdCam5CLEVBQXhCLEVBQTRCOVMsSUFBNUIsRUFBa0M7UUFDaEMsSUFBSW82QixTQUFTLEdBQUdDLGtCQUFrQixDQUFDdm5CLEVBQUQsRUFBSzlTLElBQUwsQ0FBbEM7O1FBQ0EsSUFBSW82QixTQUFTLENBQUM3SixTQUFWLElBQXVCLElBQTNCLEVBQWlDO1VBQUVpSyxlQUFlLENBQUMxbkIsRUFBRCxFQUFLc25CLFNBQVMsQ0FBQzdKLFNBQWYsQ0FBZjs7O1FBQ25DLElBQUk2SixTQUFTLENBQUNqSyxVQUFWLElBQXdCLElBQTVCLEVBQWtDO1VBQUVzSyxhQUFhLENBQUMzbkIsRUFBRCxFQUFLc25CLFNBQVMsQ0FBQ2pLLFVBQWYsQ0FBYjs7T0EvNEduQjs7Ozs7O01BczVHbkIsU0FBU2tLLGtCQUFULENBQTRCdm5CLEVBQTVCLEVBQWdDOVMsSUFBaEMsRUFBc0M7UUFDcEMsSUFBSWoyQyxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1lBQTBCMndFLFVBQVUsR0FBR3hILFVBQVUsQ0FBQ3BnQixFQUFFLENBQUMvb0QsT0FBSixDQUFqRDs7UUFDQSxJQUFJaTJDLElBQUksQ0FBQ0ssR0FBTCxHQUFXLENBQWYsRUFBa0I7VUFBRUwsSUFBSSxDQUFDSyxHQUFMLEdBQVcsQ0FBWDs7O1FBQ3BCLElBQUlzNkIsU0FBUyxHQUFHN25CLEVBQUUsQ0FBQ08sS0FBSCxJQUFZUCxFQUFFLENBQUNPLEtBQUgsQ0FBU2tkLFNBQVQsSUFBc0IsSUFBbEMsR0FBeUN6ZCxFQUFFLENBQUNPLEtBQUgsQ0FBU2tkLFNBQWxELEdBQThEeG1FLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCaUUsU0FBL0Y7UUFDQSxJQUFJcEIsTUFBTSxHQUFHM0MsYUFBYSxDQUFDMVosRUFBRCxDQUExQjtZQUFnQ3ZxRCxNQUFNLEdBQUcsRUFBekM7O1FBQ0EsSUFBSXkzQyxJQUFJLENBQUNrdEIsTUFBTCxHQUFjbHRCLElBQUksQ0FBQ0ssR0FBbkIsR0FBeUI4dUIsTUFBN0IsRUFBcUM7VUFBRW52QixJQUFJLENBQUNrdEIsTUFBTCxHQUFjbHRCLElBQUksQ0FBQ0ssR0FBTCxHQUFXOHVCLE1BQXpCOzs7UUFDdkMsSUFBSXlMLFNBQVMsR0FBRzluQixFQUFFLENBQUNrRyxHQUFILENBQU9qYSxNQUFQLEdBQWdCOHNCLFdBQVcsQ0FBQzloRSxPQUFELENBQTNDO1FBQ0EsSUFBSTh3RSxLQUFLLEdBQUc3NkIsSUFBSSxDQUFDSyxHQUFMLEdBQVdxNkIsVUFBdkI7WUFBbUNJLFFBQVEsR0FBRzk2QixJQUFJLENBQUNrdEIsTUFBTCxHQUFjME4sU0FBUyxHQUFHRixVQUF4RTs7UUFDQSxJQUFJMTZCLElBQUksQ0FBQ0ssR0FBTCxHQUFXczZCLFNBQWYsRUFBMEI7VUFDeEJweUUsTUFBTSxDQUFDZ29FLFNBQVAsR0FBbUJzSyxLQUFLLEdBQUcsQ0FBSCxHQUFPNzZCLElBQUksQ0FBQ0ssR0FBcEM7U0FERixNQUVPLElBQUlMLElBQUksQ0FBQ2t0QixNQUFMLEdBQWN5TixTQUFTLEdBQUd4TCxNQUE5QixFQUFzQztVQUMzQyxJQUFJNEwsTUFBTSxHQUFHNzdFLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3c0QyxJQUFJLENBQUNLLEdBQWQsRUFBbUIsQ0FBQ3k2QixRQUFRLEdBQUdGLFNBQUgsR0FBZTU2QixJQUFJLENBQUNrdEIsTUFBN0IsSUFBdUNpQyxNQUExRCxDQUFiOztVQUNBLElBQUk0TCxNQUFNLElBQUlKLFNBQWQsRUFBeUI7WUFBRXB5RSxNQUFNLENBQUNnb0UsU0FBUCxHQUFtQndLLE1BQW5COzs7O1FBRzdCLElBQUlDLFdBQVcsR0FBR2xvQixFQUFFLENBQUNqbEIsT0FBSCxDQUFXMjdCLFdBQVgsR0FBeUIsQ0FBekIsR0FBNkJ6L0QsT0FBTyxDQUFDc2hFLE9BQVIsQ0FBZ0I3VyxXQUEvRDtRQUNBLElBQUl5bUIsVUFBVSxHQUFHbm9CLEVBQUUsQ0FBQ08sS0FBSCxJQUFZUCxFQUFFLENBQUNPLEtBQUgsQ0FBUzhjLFVBQVQsSUFBdUIsSUFBbkMsR0FBMENyZCxFQUFFLENBQUNPLEtBQUgsQ0FBUzhjLFVBQW5ELEdBQWdFcG1FLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCNkQsVUFBakIsR0FBOEI2SyxXQUEvRztRQUNBLElBQUlFLE9BQU8sR0FBRzdPLFlBQVksQ0FBQ3ZaLEVBQUQsQ0FBWixHQUFtQi9vRCxPQUFPLENBQUNzaEUsT0FBUixDQUFnQjdXLFdBQWpEO1FBQ0EsSUFBSTJtQixPQUFPLEdBQUduN0IsSUFBSSxDQUFDOFUsS0FBTCxHQUFhOVUsSUFBSSxDQUFDdmQsSUFBbEIsR0FBeUJ5NEMsT0FBdkM7O1FBQ0EsSUFBSUMsT0FBSixFQUFhO1VBQUVuN0IsSUFBSSxDQUFDOFUsS0FBTCxHQUFhOVUsSUFBSSxDQUFDdmQsSUFBTCxHQUFZeTRDLE9BQXpCOzs7UUFDZixJQUFJbDdCLElBQUksQ0FBQ3ZkLElBQUwsR0FBWSxFQUFoQixFQUNFO1VBQUVsNkIsTUFBTSxDQUFDNG5FLFVBQVAsR0FBb0IsQ0FBcEI7U0FESixNQUVLLElBQUlud0IsSUFBSSxDQUFDdmQsSUFBTCxHQUFZdzRDLFVBQWhCLEVBQ0g7VUFBRTF5RSxNQUFNLENBQUM0bkUsVUFBUCxHQUFvQmp4RSxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZczRDLElBQUksQ0FBQ3ZkLElBQUwsR0FBWXU0QyxXQUFaLElBQTJCRyxPQUFPLEdBQUcsQ0FBSCxHQUFPLEVBQXpDLENBQVosQ0FBcEI7U0FEQyxNQUVBLElBQUluN0IsSUFBSSxDQUFDOFUsS0FBTCxHQUFhb21CLE9BQU8sR0FBR0QsVUFBVixHQUF1QixDQUF4QyxFQUNIO1VBQUUxeUUsTUFBTSxDQUFDNG5FLFVBQVAsR0FBb0Jud0IsSUFBSSxDQUFDOFUsS0FBTCxJQUFjcW1CLE9BQU8sR0FBRyxDQUFILEdBQU8sRUFBNUIsSUFBa0NELE9BQXREOzs7UUFDSixPQUFPM3lFLE1BQVA7T0FoN0dpQjs7OztNQXE3R25CLFNBQVM2eUUsY0FBVCxDQUF3QnRvQixFQUF4QixFQUE0QnpTLEdBQTVCLEVBQWlDO1FBQy9CLElBQUlBLEdBQUcsSUFBSSxJQUFYLEVBQWlCO1VBQUU7OztRQUNuQmc3QixrQkFBa0IsQ0FBQ3ZvQixFQUFELENBQWxCO1FBQ0FBLEVBQUUsQ0FBQ08sS0FBSCxDQUFTa2QsU0FBVCxHQUFxQixDQUFDemQsRUFBRSxDQUFDTyxLQUFILENBQVNrZCxTQUFULElBQXNCLElBQXRCLEdBQTZCemQsRUFBRSxDQUFDa0csR0FBSCxDQUFPdVgsU0FBcEMsR0FBZ0R6ZCxFQUFFLENBQUNPLEtBQUgsQ0FBU2tkLFNBQTFELElBQXVFbHdCLEdBQTVGO09BeDdHaUI7Ozs7TUE2N0duQixTQUFTaTdCLG1CQUFULENBQTZCeG9CLEVBQTdCLEVBQWlDO1FBQy9CdW9CLGtCQUFrQixDQUFDdm9CLEVBQUQsQ0FBbEI7UUFDQSxJQUFJL0MsR0FBRyxHQUFHK0MsRUFBRSxDQUFDeW9CLFNBQUgsRUFBVjtRQUNBem9CLEVBQUUsQ0FBQ08sS0FBSCxDQUFTbW9CLFdBQVQsR0FBdUI7VUFBQzk3RCxJQUFJLEVBQUVxd0MsR0FBUDtVQUFZN3NDLEVBQUUsRUFBRTZzQyxHQUFoQjtVQUFxQmtxQixNQUFNLEVBQUVubkIsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzR0QztTQUEvRDs7O01BR0YsU0FBU0MsY0FBVCxDQUF3QjVvQixFQUF4QixFQUE0QmhqRCxDQUE1QixFQUErQkMsQ0FBL0IsRUFBa0M7UUFDaEMsSUFBSUQsQ0FBQyxJQUFJLElBQUwsSUFBYUMsQ0FBQyxJQUFJLElBQXRCLEVBQTRCO1VBQUVzckUsa0JBQWtCLENBQUN2b0IsRUFBRCxDQUFsQjs7O1FBQzlCLElBQUloakQsQ0FBQyxJQUFJLElBQVQsRUFBZTtVQUFFZ2pELEVBQUUsQ0FBQ08sS0FBSCxDQUFTOGMsVUFBVCxHQUFzQnJnRSxDQUF0Qjs7O1FBQ2pCLElBQUlDLENBQUMsSUFBSSxJQUFULEVBQWU7VUFBRStpRCxFQUFFLENBQUNPLEtBQUgsQ0FBU2tkLFNBQVQsR0FBcUJ4Z0UsQ0FBckI7Ozs7TUFHbkIsU0FBUzRyRSxhQUFULENBQXVCN29CLEVBQXZCLEVBQTJCcFEsS0FBM0IsRUFBa0M7UUFDaEMyNEIsa0JBQWtCLENBQUN2b0IsRUFBRCxDQUFsQjtRQUNBQSxFQUFFLENBQUNPLEtBQUgsQ0FBU21vQixXQUFULEdBQXVCOTRCLEtBQXZCO09BMzhHaUI7Ozs7OztNQWs5R25CLFNBQVMyNEIsa0JBQVQsQ0FBNEJ2b0IsRUFBNUIsRUFBZ0M7UUFDOUIsSUFBSXBRLEtBQUssR0FBR29RLEVBQUUsQ0FBQ08sS0FBSCxDQUFTbW9CLFdBQXJCOztRQUNBLElBQUk5NEIsS0FBSixFQUFXO1VBQ1RvUSxFQUFFLENBQUNPLEtBQUgsQ0FBU21vQixXQUFULEdBQXVCLElBQXZCO1VBQ0EsSUFBSTk3RCxJQUFJLEdBQUcreEQsY0FBYyxDQUFDM2UsRUFBRCxFQUFLcFEsS0FBSyxDQUFDaGpDLElBQVgsQ0FBekI7Y0FBMkN3RCxFQUFFLEdBQUd1dUQsY0FBYyxDQUFDM2UsRUFBRCxFQUFLcFEsS0FBSyxDQUFDeC9CLEVBQVgsQ0FBOUQ7VUFDQTA0RCxtQkFBbUIsQ0FBQzlvQixFQUFELEVBQUtwekMsSUFBTCxFQUFXd0QsRUFBWCxFQUFldy9CLEtBQUssQ0FBQ3UzQixNQUFyQixDQUFuQjs7OztNQUlKLFNBQVMyQixtQkFBVCxDQUE2QjlvQixFQUE3QixFQUFpQ3B6QyxJQUFqQyxFQUF1Q3dELEVBQXZDLEVBQTJDKzJELE1BQTNDLEVBQW1EO1FBQ2pELElBQUk0QixJQUFJLEdBQUd4QixrQkFBa0IsQ0FBQ3ZuQixFQUFELEVBQUs7VUFDaENyd0IsSUFBSSxFQUFFdmpDLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU2tZLElBQUksQ0FBQytpQixJQUFkLEVBQW9CdmYsRUFBRSxDQUFDdWYsSUFBdkIsQ0FEMEI7VUFFaEM0ZCxHQUFHLEVBQUVuaEQsSUFBSSxDQUFDc0ksR0FBTCxDQUFTa1ksSUFBSSxDQUFDMmdDLEdBQWQsRUFBbUJuOUIsRUFBRSxDQUFDbTlCLEdBQXRCLElBQTZCNDVCLE1BRkY7VUFHaENubEIsS0FBSyxFQUFFNTFELElBQUksQ0FBQ3dJLEdBQUwsQ0FBU2dZLElBQUksQ0FBQ28xQyxLQUFkLEVBQXFCNXhDLEVBQUUsQ0FBQzR4QyxLQUF4QixDQUh5QjtVQUloQ29ZLE1BQU0sRUFBRWh1RSxJQUFJLENBQUN3SSxHQUFMLENBQVNnWSxJQUFJLENBQUN3dEQsTUFBZCxFQUFzQmhxRCxFQUFFLENBQUNncUQsTUFBekIsSUFBbUMrTTtTQUpoQixDQUE3QjtRQU1BeUIsY0FBYyxDQUFDNW9CLEVBQUQsRUFBSytvQixJQUFJLENBQUMxTCxVQUFWLEVBQXNCMEwsSUFBSSxDQUFDdEwsU0FBM0IsQ0FBZDtPQWwrR2lCOzs7O01BdStHbkIsU0FBU2lLLGVBQVQsQ0FBeUIxbkIsRUFBekIsRUFBNkJqeUQsR0FBN0IsRUFBa0M7UUFDaEMsSUFBSTNCLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzA4QyxFQUFFLENBQUNrRyxHQUFILENBQU91WCxTQUFQLEdBQW1CMXZFLEdBQTVCLElBQW1DLENBQXZDLEVBQTBDO1VBQUU7OztRQUM1QyxJQUFJLENBQUN1b0QsS0FBTCxFQUFZO1VBQUUweUIsbUJBQW1CLENBQUNocEIsRUFBRCxFQUFLO1lBQUN6UyxHQUFHLEVBQUV4L0M7V0FBWCxDQUFuQjs7O1FBQ2RrN0UsWUFBWSxDQUFDanBCLEVBQUQsRUFBS2p5RCxHQUFMLEVBQVUsSUFBVixDQUFaOztRQUNBLElBQUl1b0QsS0FBSixFQUFXO1VBQUUweUIsbUJBQW1CLENBQUNocEIsRUFBRCxDQUFuQjs7O1FBQ2JrcEIsV0FBVyxDQUFDbHBCLEVBQUQsRUFBSyxHQUFMLENBQVg7OztNQUdGLFNBQVNpcEIsWUFBVCxDQUFzQmpwQixFQUF0QixFQUEwQmp5RCxHQUExQixFQUErQm83RSxXQUEvQixFQUE0QztRQUMxQ3A3RSxHQUFHLEdBQUczQixJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZeEksSUFBSSxDQUFDc0ksR0FBTCxDQUFTc3JELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQjRQLFlBQXBCLEdBQW1DcHBCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQkcsWUFBaEUsRUFBOEU1ckUsR0FBOUUsQ0FBWixDQUFOOztRQUNBLElBQUlpeUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CaUUsU0FBcEIsSUFBaUMxdkUsR0FBakMsSUFBd0MsQ0FBQ283RSxXQUE3QyxFQUEwRDtVQUFFOzs7UUFDNURucEIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdVgsU0FBUCxHQUFtQjF2RSxHQUFuQjtRQUNBaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVdveUUsVUFBWCxDQUFzQkosWUFBdEIsQ0FBbUNsN0UsR0FBbkM7O1FBQ0EsSUFBSWl5RCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdWlFLFFBQVgsQ0FBb0JpRSxTQUFwQixJQUFpQzF2RSxHQUFyQyxFQUEwQztVQUFFaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQmlFLFNBQXBCLEdBQWdDMXZFLEdBQWhDOztPQXAvRzNCOzs7O01BeS9HbkIsU0FBUzQ1RSxhQUFULENBQXVCM25CLEVBQXZCLEVBQTJCanlELEdBQTNCLEVBQWdDdTdFLFVBQWhDLEVBQTRDSCxXQUE1QyxFQUF5RDtRQUN2RHA3RSxHQUFHLEdBQUczQixJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZeEksSUFBSSxDQUFDc0ksR0FBTCxDQUFTM0csR0FBVCxFQUFjaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQitQLFdBQXBCLEdBQWtDdnBCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQmhCLFdBQXBFLENBQVosQ0FBTjs7UUFDQSxJQUFJLENBQUM4USxVQUFVLEdBQUd2N0UsR0FBRyxJQUFJaXlELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT21YLFVBQWpCLEdBQThCanhFLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzA4QyxFQUFFLENBQUNrRyxHQUFILENBQU9tWCxVQUFQLEdBQW9CdHZFLEdBQTdCLElBQW9DLENBQTdFLEtBQW1GLENBQUNvN0UsV0FBeEYsRUFBcUc7VUFBRTs7O1FBQ3ZHbnBCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT21YLFVBQVAsR0FBb0J0dkUsR0FBcEI7UUFDQXk3RSxpQkFBaUIsQ0FBQ3hwQixFQUFELENBQWpCOztRQUNBLElBQUlBLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWCxDQUFvQjZELFVBQXBCLElBQWtDdHZFLEdBQXRDLEVBQTJDO1VBQUVpeUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CNkQsVUFBcEIsR0FBaUN0dkUsR0FBakM7OztRQUM3Q2l5RCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXb3lFLFVBQVgsQ0FBc0IxQixhQUF0QixDQUFvQzU1RSxHQUFwQztPQS8vR2lCOzs7OztNQXNnSG5CLFNBQVMwN0Usb0JBQVQsQ0FBOEJ6cEIsRUFBOUIsRUFBa0M7UUFDaEMsSUFBSXAwQyxDQUFDLEdBQUdvMEMsRUFBRSxDQUFDL29ELE9BQVg7WUFBb0J5eUUsT0FBTyxHQUFHOTlELENBQUMsQ0FBQzJzRCxPQUFGLENBQVU3VyxXQUF4QztRQUNBLElBQUlpb0IsSUFBSSxHQUFHdjlFLElBQUksQ0FBQysvQixLQUFMLENBQVc2ekIsRUFBRSxDQUFDa0csR0FBSCxDQUFPamEsTUFBUCxHQUFnQjhzQixXQUFXLENBQUMvWSxFQUFFLENBQUMvb0QsT0FBSixDQUF0QyxDQUFYO1FBQ0EsT0FBTztVQUNMMGlFLFlBQVksRUFBRS90RCxDQUFDLENBQUM0dEQsUUFBRixDQUFXRyxZQURwQjtVQUVMaVEsVUFBVSxFQUFFaCtELENBQUMsQ0FBQzhSLE9BQUYsQ0FBVWk4QyxZQUZqQjtVQUdMNFAsV0FBVyxFQUFFMzlELENBQUMsQ0FBQzR0RCxRQUFGLENBQVcrUCxXQUhuQjtVQUdnQy9RLFdBQVcsRUFBRTVzRCxDQUFDLENBQUM0dEQsUUFBRixDQUFXaEIsV0FIeEQ7VUFJTHFSLFNBQVMsRUFBRWorRCxDQUFDLENBQUM4UixPQUFGLENBQVU4NkMsV0FKaEI7VUFLTHNSLE9BQU8sRUFBRTlwQixFQUFFLENBQUNqbEIsT0FBSCxDQUFXMjdCLFdBQVgsR0FBeUJnVCxPQUF6QixHQUFtQyxDQUx2QztVQU1MSyxTQUFTLEVBQUVKLElBTk47VUFPTFAsWUFBWSxFQUFFTyxJQUFJLEdBQUd0USxTQUFTLENBQUNyWixFQUFELENBQWhCLEdBQXVCcDBDLENBQUMsQ0FBQ2d1RCxTQVBsQztVQVFMTixjQUFjLEVBQUUxdEQsQ0FBQyxDQUFDMHRELGNBUmI7VUFTTGpDLFdBQVcsRUFBRXFTO1NBVGY7OztNQWFGLElBQUlNLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBU2xPLEtBQVQsRUFBZ0JqaEIsTUFBaEIsRUFBd0JtRixFQUF4QixFQUE0QjtRQUNqRCxLQUFLQSxFQUFMLEdBQVVBLEVBQVY7UUFDQSxJQUFJaXFCLElBQUksR0FBRyxLQUFLQSxJQUFMLEdBQVkxeEIsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDQSxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxJQUFkLEVBQW9CLGdCQUFwQixDQUFKLENBQVIsRUFBb0QsdUJBQXBELENBQTFCO1FBQ0EsSUFBSTJ4QixLQUFLLEdBQUcsS0FBS0EsS0FBTCxHQUFhM3hCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQ0EsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsSUFBZCxFQUFvQiwrQkFBcEIsQ0FBSixDQUFSLEVBQW1FLHVCQUFuRSxDQUE1QjtRQUNBMHhCLElBQUksQ0FBQ0UsUUFBTCxHQUFnQkQsS0FBSyxDQUFDQyxRQUFOLEdBQWlCLENBQUMsQ0FBbEM7UUFDQXJPLEtBQUssQ0FBQ21PLElBQUQsQ0FBTDtRQUFhbk8sS0FBSyxDQUFDb08sS0FBRCxDQUFMO1FBRWI1cUIsRUFBRSxDQUFDMnFCLElBQUQsRUFBTyxRQUFQLEVBQWlCLFlBQVk7VUFDN0IsSUFBSUEsSUFBSSxDQUFDdFEsWUFBVCxFQUF1QjtZQUFFOWUsTUFBTSxDQUFDb3ZCLElBQUksQ0FBQ3hNLFNBQU4sRUFBaUIsVUFBakIsQ0FBTjs7U0FEekIsQ0FBRjtRQUdBbmUsRUFBRSxDQUFDNHFCLEtBQUQsRUFBUSxRQUFSLEVBQWtCLFlBQVk7VUFDOUIsSUFBSUEsS0FBSyxDQUFDMVIsV0FBVixFQUF1QjtZQUFFM2QsTUFBTSxDQUFDcXZCLEtBQUssQ0FBQzdNLFVBQVAsRUFBbUIsWUFBbkIsQ0FBTjs7U0FEekIsQ0FBRjtRQUlBLEtBQUsrTSxnQkFBTCxHQUF3QixLQUF4QixDQWRpRDs7UUFnQmpELElBQUkxekIsRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBdkIsRUFBMEI7VUFBRSxLQUFLdXpCLEtBQUwsQ0FBV2x6RSxLQUFYLENBQWlCcXpFLFNBQWpCLEdBQTZCLEtBQUtKLElBQUwsQ0FBVWp6RSxLQUFWLENBQWdCc3pFLFFBQWhCLEdBQTJCLE1BQXhEOztPQWhCOUI7O01BbUJBTixnQkFBZ0IsQ0FBQ3o1RSxTQUFqQixDQUEyQm8zQyxNQUEzQixHQUFvQyxVQUFVNlosT0FBVixFQUFtQjtRQUNyRCxJQUFJK29CLE1BQU0sR0FBRy9vQixPQUFPLENBQUMrbkIsV0FBUixHQUFzQi9uQixPQUFPLENBQUNnWCxXQUFSLEdBQXNCLENBQXpEO1FBQ0EsSUFBSWdTLE1BQU0sR0FBR2hwQixPQUFPLENBQUM0bkIsWUFBUixHQUF1QjVuQixPQUFPLENBQUNtWSxZQUFSLEdBQXVCLENBQTNEO1FBQ0EsSUFBSThRLE1BQU0sR0FBR2pwQixPQUFPLENBQUM4WCxjQUFyQjs7UUFFQSxJQUFJa1IsTUFBSixFQUFZO1VBQ1YsS0FBS1AsSUFBTCxDQUFVanpFLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLE9BQTFCO1VBQ0EsS0FBS2d6RSxJQUFMLENBQVVqekUsS0FBVixDQUFnQm9qRSxNQUFoQixHQUF5Qm1RLE1BQU0sR0FBR0UsTUFBTSxHQUFHLElBQVosR0FBbUIsR0FBbEQ7VUFDQSxJQUFJQyxXQUFXLEdBQUdscEIsT0FBTyxDQUFDb29CLFVBQVIsSUFBc0JXLE1BQU0sR0FBR0UsTUFBSCxHQUFZLENBQXhDLENBQWxCLENBSFU7O1VBS1YsS0FBS1IsSUFBTCxDQUFVdnRDLFVBQVYsQ0FBcUIxbEMsS0FBckIsQ0FBMkJpMUMsTUFBM0IsR0FDRTcvQyxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZNHNELE9BQU8sQ0FBQzRuQixZQUFSLEdBQXVCNW5CLE9BQU8sQ0FBQ21ZLFlBQS9CLEdBQThDK1EsV0FBMUQsSUFBeUUsSUFEM0U7U0FMRixNQU9PO1VBQ0wsS0FBS1QsSUFBTCxDQUFVanpFLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLEVBQTFCO1VBQ0EsS0FBS2d6RSxJQUFMLENBQVV2dEMsVUFBVixDQUFxQjFsQyxLQUFyQixDQUEyQmkxQyxNQUEzQixHQUFvQyxHQUFwQzs7O1FBR0YsSUFBSXMrQixNQUFKLEVBQVk7VUFDVixLQUFLTCxLQUFMLENBQVdsekUsS0FBWCxDQUFpQkMsT0FBakIsR0FBMkIsT0FBM0I7VUFDQSxLQUFLaXpFLEtBQUwsQ0FBV2x6RSxLQUFYLENBQWlCZ3JELEtBQWpCLEdBQXlCd29CLE1BQU0sR0FBR0MsTUFBTSxHQUFHLElBQVosR0FBbUIsR0FBbEQ7VUFDQSxLQUFLUCxLQUFMLENBQVdsekUsS0FBWCxDQUFpQjI0QixJQUFqQixHQUF3QjZ4QixPQUFPLENBQUNzb0IsT0FBUixHQUFrQixJQUExQztVQUNBLElBQUlhLFVBQVUsR0FBR25wQixPQUFPLENBQUNxb0IsU0FBUixHQUFvQnJvQixPQUFPLENBQUNzb0IsT0FBNUIsSUFBdUNVLE1BQU0sR0FBR0MsTUFBSCxHQUFZLENBQXpELENBQWpCO1VBQ0EsS0FBS1AsS0FBTCxDQUFXeHRDLFVBQVgsQ0FBc0IxbEMsS0FBdEIsQ0FBNEIrMEMsS0FBNUIsR0FDRTMvQyxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZNHNELE9BQU8sQ0FBQytuQixXQUFSLEdBQXNCL25CLE9BQU8sQ0FBQ2dYLFdBQTlCLEdBQTRDbVMsVUFBeEQsSUFBc0UsSUFEeEU7U0FMRixNQU9PO1VBQ0wsS0FBS1QsS0FBTCxDQUFXbHpFLEtBQVgsQ0FBaUJDLE9BQWpCLEdBQTJCLEVBQTNCO1VBQ0EsS0FBS2l6RSxLQUFMLENBQVd4dEMsVUFBWCxDQUFzQjFsQyxLQUF0QixDQUE0QiswQyxLQUE1QixHQUFvQyxHQUFwQzs7O1FBR0YsSUFBSSxDQUFDLEtBQUtxK0IsZ0JBQU4sSUFBMEI1b0IsT0FBTyxDQUFDbVksWUFBUixHQUF1QixDQUFyRCxFQUF3RDtVQUN0RCxJQUFJOFEsTUFBTSxJQUFJLENBQWQsRUFBaUI7WUFBRSxLQUFLRyxhQUFMOzs7VUFDbkIsS0FBS1IsZ0JBQUwsR0FBd0IsSUFBeEI7OztRQUdGLE9BQU87VUFBQ3BvQixLQUFLLEVBQUV3b0IsTUFBTSxHQUFHQyxNQUFILEdBQVksQ0FBMUI7VUFBNkJyUSxNQUFNLEVBQUVtUSxNQUFNLEdBQUdFLE1BQUgsR0FBWTtTQUE5RDtPQWxDRjs7TUFxQ0FULGdCQUFnQixDQUFDejVFLFNBQWpCLENBQTJCbzNFLGFBQTNCLEdBQTJDLFVBQVVoaEUsR0FBVixFQUFlO1FBQ3hELElBQUksS0FBS3VqRSxLQUFMLENBQVc3TSxVQUFYLElBQXlCMTJELEdBQTdCLEVBQWtDO1VBQUUsS0FBS3VqRSxLQUFMLENBQVc3TSxVQUFYLEdBQXdCMTJELEdBQXhCOzs7UUFDcEMsSUFBSSxLQUFLa2tFLFlBQVQsRUFBdUI7VUFBRSxLQUFLQyxrQkFBTCxDQUF3QixLQUFLWixLQUE3QixFQUFvQyxLQUFLVyxZQUF6QyxFQUF1RCxPQUF2RDs7T0FGM0I7O01BS0FiLGdCQUFnQixDQUFDejVFLFNBQWpCLENBQTJCMDRFLFlBQTNCLEdBQTBDLFVBQVV0aUUsR0FBVixFQUFlO1FBQ3ZELElBQUksS0FBS3NqRSxJQUFMLENBQVV4TSxTQUFWLElBQXVCOTJELEdBQTNCLEVBQWdDO1VBQUUsS0FBS3NqRSxJQUFMLENBQVV4TSxTQUFWLEdBQXNCOTJELEdBQXRCOzs7UUFDbEMsSUFBSSxLQUFLb2tFLFdBQVQsRUFBc0I7VUFBRSxLQUFLRCxrQkFBTCxDQUF3QixLQUFLYixJQUE3QixFQUFtQyxLQUFLYyxXQUF4QyxFQUFxRCxNQUFyRDs7T0FGMUI7O01BS0FmLGdCQUFnQixDQUFDejVFLFNBQWpCLENBQTJCcTZFLGFBQTNCLEdBQTJDLFlBQVk7UUFDckQsSUFBSTkzRSxDQUFDLEdBQUcya0QsR0FBRyxJQUFJLENBQUNOLGtCQUFSLEdBQTZCLE1BQTdCLEdBQXNDLE1BQTlDO1FBQ0EsS0FBSyt5QixLQUFMLENBQVdsekUsS0FBWCxDQUFpQmkxQyxNQUFqQixHQUEwQixLQUFLZytCLElBQUwsQ0FBVWp6RSxLQUFWLENBQWdCKzBDLEtBQWhCLEdBQXdCajVDLENBQWxEO1FBQ0EsS0FBS28zRSxLQUFMLENBQVdsekUsS0FBWCxDQUFpQmcwRSxhQUFqQixHQUFpQyxLQUFLZixJQUFMLENBQVVqekUsS0FBVixDQUFnQmcwRSxhQUFoQixHQUFnQyxNQUFqRTtRQUNBLEtBQUtILFlBQUwsR0FBb0IsSUFBSXh3QixPQUFKLEVBQXBCO1FBQ0EsS0FBSzB3QixXQUFMLEdBQW1CLElBQUkxd0IsT0FBSixFQUFuQjtPQUxGOztNQVFBMnZCLGdCQUFnQixDQUFDejVFLFNBQWpCLENBQTJCdTZFLGtCQUEzQixHQUFnRCxVQUFVRyxHQUFWLEVBQWVDLEtBQWYsRUFBc0JqNkUsSUFBdEIsRUFBNEI7UUFDMUVnNkUsR0FBRyxDQUFDajBFLEtBQUosQ0FBVWcwRSxhQUFWLEdBQTBCLE1BQTFCOztRQUNBLFNBQVNHLFlBQVQsR0FBd0I7Ozs7Ozs7VUFPdEIsSUFBSTdMLEdBQUcsR0FBRzJMLEdBQUcsQ0FBQzk5QixxQkFBSixFQUFWO1VBQ0EsSUFBSW9MLEdBQUcsR0FBR3RuRCxJQUFJLElBQUksTUFBUixHQUFpQnpELFFBQVEsQ0FBQzQ5RSxnQkFBVCxDQUEwQjlMLEdBQUcsQ0FBQ3RkLEtBQUosR0FBWSxDQUF0QyxFQUF5QyxDQUFDc2QsR0FBRyxDQUFDL3hCLEdBQUosR0FBVSt4QixHQUFHLENBQUNsRixNQUFmLElBQXlCLENBQWxFLENBQWpCLEdBQ0o1c0UsUUFBUSxDQUFDNDlFLGdCQUFULENBQTBCLENBQUM5TCxHQUFHLENBQUN0ZCxLQUFKLEdBQVlzZCxHQUFHLENBQUMzdkMsSUFBakIsSUFBeUIsQ0FBbkQsRUFBc0QydkMsR0FBRyxDQUFDbEYsTUFBSixHQUFhLENBQW5FLENBRE47O1VBRUEsSUFBSTdoQixHQUFHLElBQUkweUIsR0FBWCxFQUFnQjtZQUFFQSxHQUFHLENBQUNqMEUsS0FBSixDQUFVZzBFLGFBQVYsR0FBMEIsTUFBMUI7V0FBbEIsTUFDSztZQUFFRSxLQUFLLENBQUN4d0UsR0FBTixDQUFVLElBQVYsRUFBZ0J5d0UsWUFBaEI7Ozs7UUFFVEQsS0FBSyxDQUFDeHdFLEdBQU4sQ0FBVSxJQUFWLEVBQWdCeXdFLFlBQWhCO09BZkY7O01Ba0JBbkIsZ0JBQWdCLENBQUN6NUUsU0FBakIsQ0FBMkJ1b0IsS0FBM0IsR0FBbUMsWUFBWTtRQUM3QyxJQUFJVyxNQUFNLEdBQUcsS0FBS3l3RCxLQUFMLENBQVdqckMsVUFBeEI7UUFDQXhsQixNQUFNLENBQUNiLFdBQVAsQ0FBbUIsS0FBS3N4RCxLQUF4QjtRQUNBendELE1BQU0sQ0FBQ2IsV0FBUCxDQUFtQixLQUFLcXhELElBQXhCO09BSEY7O01BTUEsSUFBSW9CLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsR0FBWSxFQUFqQzs7TUFFQUEsY0FBYyxDQUFDOTZFLFNBQWYsQ0FBeUJvM0MsTUFBekIsR0FBa0MsWUFBWTtRQUFFLE9BQU87VUFBQ3l5QixNQUFNLEVBQUUsQ0FBVDtVQUFZcFksS0FBSyxFQUFFO1NBQTFCO09BQWhEOztNQUNBcXBCLGNBQWMsQ0FBQzk2RSxTQUFmLENBQXlCbzNFLGFBQXpCLEdBQXlDLFlBQVksRUFBckQ7O01BQ0EwRCxjQUFjLENBQUM5NkUsU0FBZixDQUF5QjA0RSxZQUF6QixHQUF3QyxZQUFZLEVBQXBEOztNQUNBb0MsY0FBYyxDQUFDOTZFLFNBQWYsQ0FBeUJ1b0IsS0FBekIsR0FBaUMsWUFBWSxFQUE3Qzs7TUFFQSxTQUFTd3lELGdCQUFULENBQTBCdHJCLEVBQTFCLEVBQThCd0IsT0FBOUIsRUFBdUM7UUFDckMsSUFBSSxDQUFDQSxPQUFMLEVBQWM7VUFBRUEsT0FBTyxHQUFHaW9CLG9CQUFvQixDQUFDenBCLEVBQUQsQ0FBOUI7OztRQUNoQixJQUFJdXJCLFVBQVUsR0FBR3ZyQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXd2lFLFFBQTVCO1lBQXNDK1IsV0FBVyxHQUFHeHJCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVcyaUUsU0FBL0Q7UUFDQTZSLHFCQUFxQixDQUFDenJCLEVBQUQsRUFBS3dCLE9BQUwsQ0FBckI7O1FBQ0EsS0FBSyxJQUFJM3VELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBSixJQUFTMDRFLFVBQVUsSUFBSXZyQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXd2lFLFFBQWxDLElBQThDK1IsV0FBVyxJQUFJeHJCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVcyaUUsU0FBeEYsRUFBbUcvbUUsQ0FBQyxFQUFwRyxFQUF3RztVQUN0RyxJQUFJMDRFLFVBQVUsSUFBSXZyQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXd2lFLFFBQXpCLElBQXFDelosRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUFwRCxFQUNFO1lBQUVpTSx1QkFBdUIsQ0FBQ2htQixFQUFELENBQXZCOzs7VUFDSnlyQixxQkFBcUIsQ0FBQ3pyQixFQUFELEVBQUt5cEIsb0JBQW9CLENBQUN6cEIsRUFBRCxDQUF6QixDQUFyQjtVQUNBdXJCLFVBQVUsR0FBR3ZyQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXd2lFLFFBQXhCO1VBQWtDK1IsV0FBVyxHQUFHeHJCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVcyaUUsU0FBekI7O09Bdm9IbkI7Ozs7TUE2b0huQixTQUFTNlIscUJBQVQsQ0FBK0J6ckIsRUFBL0IsRUFBbUN3QixPQUFuQyxFQUE0QztRQUMxQyxJQUFJNTFDLENBQUMsR0FBR28wQyxFQUFFLENBQUMvb0QsT0FBWDtRQUNBLElBQUl5MEUsS0FBSyxHQUFHOS9ELENBQUMsQ0FBQ3k5RCxVQUFGLENBQWExaEMsTUFBYixDQUFvQjZaLE9BQXBCLENBQVo7UUFFQTUxQyxDQUFDLENBQUM4c0QsS0FBRixDQUFRMWhFLEtBQVIsQ0FBY29pRSxZQUFkLEdBQTZCLENBQUN4dEQsQ0FBQyxDQUFDNnRELFFBQUYsR0FBYWlTLEtBQUssQ0FBQzFwQixLQUFwQixJQUE2QixJQUExRDtRQUNBcDJDLENBQUMsQ0FBQzhzRCxLQUFGLENBQVExaEUsS0FBUixDQUFjMjBFLGFBQWQsR0FBOEIsQ0FBQy8vRCxDQUFDLENBQUNndUQsU0FBRixHQUFjOFIsS0FBSyxDQUFDdFIsTUFBckIsSUFBK0IsSUFBN0Q7UUFDQXh1RCxDQUFDLENBQUNnZ0UsWUFBRixDQUFlNTBFLEtBQWYsQ0FBcUI2MEUsWUFBckIsR0FBb0NILEtBQUssQ0FBQ3RSLE1BQU4sR0FBZSxzQkFBbkQ7O1FBRUEsSUFBSXNSLEtBQUssQ0FBQzFwQixLQUFOLElBQWUwcEIsS0FBSyxDQUFDdFIsTUFBekIsRUFBaUM7VUFDL0J4dUQsQ0FBQyxDQUFDa2dFLGVBQUYsQ0FBa0I5MEUsS0FBbEIsQ0FBd0JDLE9BQXhCLEdBQWtDLE9BQWxDO1VBQ0EyVSxDQUFDLENBQUNrZ0UsZUFBRixDQUFrQjkwRSxLQUFsQixDQUF3QmkxQyxNQUF4QixHQUFpQ3kvQixLQUFLLENBQUN0UixNQUFOLEdBQWUsSUFBaEQ7VUFDQXh1RCxDQUFDLENBQUNrZ0UsZUFBRixDQUFrQjkwRSxLQUFsQixDQUF3QiswQyxLQUF4QixHQUFnQzIvQixLQUFLLENBQUMxcEIsS0FBTixHQUFjLElBQTlDO1NBSEYsTUFJTztVQUFFcDJDLENBQUMsQ0FBQ2tnRSxlQUFGLENBQWtCOTBFLEtBQWxCLENBQXdCQyxPQUF4QixHQUFrQyxFQUFsQzs7O1FBQ1QsSUFBSXkwRSxLQUFLLENBQUN0UixNQUFOLElBQWdCcGEsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2d4QywwQkFBM0IsSUFBeUQvckIsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzI3QixXQUF4RSxFQUFxRjtVQUNuRjlxRCxDQUFDLENBQUNvZ0UsWUFBRixDQUFlaDFFLEtBQWYsQ0FBcUJDLE9BQXJCLEdBQStCLE9BQS9CO1VBQ0EyVSxDQUFDLENBQUNvZ0UsWUFBRixDQUFlaDFFLEtBQWYsQ0FBcUJpMUMsTUFBckIsR0FBOEJ5L0IsS0FBSyxDQUFDdFIsTUFBTixHQUFlLElBQTdDO1VBQ0F4dUQsQ0FBQyxDQUFDb2dFLFlBQUYsQ0FBZWgxRSxLQUFmLENBQXFCKzBDLEtBQXJCLEdBQTZCeVYsT0FBTyxDQUFDNlYsV0FBUixHQUFzQixJQUFuRDtTQUhGLE1BSU87VUFBRXpyRCxDQUFDLENBQUNvZ0UsWUFBRixDQUFlaDFFLEtBQWYsQ0FBcUJDLE9BQXJCLEdBQStCLEVBQS9COzs7O01BR1gsSUFBSWcxRSxjQUFjLEdBQUc7UUFBQyxVQUFVakMsZ0JBQVg7UUFBNkIsUUFBUXFCO09BQTFEOztNQUVBLFNBQVNhLGNBQVQsQ0FBd0Jsc0IsRUFBeEIsRUFBNEI7UUFDMUIsSUFBSUEsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV295RSxVQUFmLEVBQTJCO1VBQ3pCcnBCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdveUUsVUFBWCxDQUFzQnZ3RCxLQUF0Qjs7VUFDQSxJQUFJa25DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdveUUsVUFBWCxDQUFzQmh3QixRQUExQixFQUNFO1lBQUVwQixPQUFPLENBQUMrSCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVosRUFBcUJzaUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV295RSxVQUFYLENBQXNCaHdCLFFBQTNDLENBQVA7Ozs7UUFHTjJHLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdveUUsVUFBWCxHQUF3QixJQUFJNEMsY0FBYyxDQUFDanNCLEVBQUUsQ0FBQ2psQixPQUFILENBQVdveEMsY0FBWixDQUFsQixDQUE4QyxVQUFVbnlELElBQVYsRUFBZ0I7VUFDcEZnbUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3ltQixPQUFYLENBQW1CNGQsWUFBbkIsQ0FBZ0N0aEIsSUFBaEMsRUFBc0NnbUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzYwRSxlQUFqRCxFQURvRjs7VUFHcEZ4c0IsRUFBRSxDQUFDdGxDLElBQUQsRUFBTyxXQUFQLEVBQW9CLFlBQVk7WUFDaEMsSUFBSWdtQyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWIsRUFBc0I7Y0FBRXJzRCxVQUFVLENBQUMsWUFBWTtnQkFBRSxPQUFPbW5DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQjllLEtBQWpCLEVBQVA7ZUFBZixFQUFtRCxDQUFuRCxDQUFWOztXQUR4QixDQUFGO1VBR0ExNkIsSUFBSSxDQUFDcW5CLFlBQUwsQ0FBa0IsZ0JBQWxCLEVBQW9DLE1BQXBDO1NBTnNCLEVBT3JCLFVBQVUxNkIsR0FBVixFQUFleWxFLElBQWYsRUFBcUI7VUFDdEIsSUFBSUEsSUFBSSxJQUFJLFlBQVosRUFBMEI7WUFBRXpFLGFBQWEsQ0FBQzNuQixFQUFELEVBQUtyNUMsR0FBTCxDQUFiO1dBQTVCLE1BQ0s7WUFBRStnRSxlQUFlLENBQUMxbkIsRUFBRCxFQUFLcjVDLEdBQUwsQ0FBZjs7U0FUZSxFQVVyQnE1QyxFQVZxQixDQUF4Qjs7UUFXQSxJQUFJQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXb3lFLFVBQVgsQ0FBc0Jod0IsUUFBMUIsRUFDRTtVQUFFQSxRQUFRLENBQUMyRyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVosRUFBcUJzaUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV295RSxVQUFYLENBQXNCaHdCLFFBQTNDLENBQVI7O09BdHJIYTs7Ozs7OztNQStySG5CLElBQUlnekIsUUFBUSxHQUFHLENBQWYsQ0EvckhtQjs7TUFpc0huQixTQUFTQyxlQUFULENBQXdCdHNCLEVBQXhCLEVBQTRCO1FBQzFCQSxFQUFFLENBQUNPLEtBQUgsR0FBVztVQUNUUCxFQUFFLEVBQUVBLEVBREs7VUFFVHFoQixXQUFXLEVBQUUsS0FGSjs7VUFHVG1LLFdBQVcsRUFBRXhyQixFQUFFLENBQUNrRyxHQUFILENBQU9qYSxNQUhYOztVQUlUOHVCLFdBQVcsRUFBRSxLQUpKOztVQUtUd1IsV0FBVyxFQUFFLENBTEo7O1VBTVRDLE1BQU0sRUFBRSxLQU5DOztVQU9UQyxVQUFVLEVBQUUsSUFQSDs7VUFRVGpzQixzQkFBc0IsRUFBRSxJQVJmOztVQVNUd1Usb0JBQW9CLEVBQUUsQ0FUYjs7VUFVVDBYLGdCQUFnQixFQUFFLEtBVlQ7O1VBV1RDLGFBQWEsRUFBRSxLQVhOOztVQVlUdFAsVUFBVSxFQUFFLElBWkg7VUFZU0ksU0FBUyxFQUFFLElBWnBCOztVQWFUaUwsV0FBVyxFQUFFLElBYko7O1VBY1RoMEIsS0FBSyxFQUFFLEtBZEU7VUFlVHpsRCxFQUFFLEVBQUUsRUFBRW85RSxRQWZHOztVQWdCVE8sVUFBVSxFQUFFLElBaEJIOztTQUFYO1FBa0JBblksYUFBYSxDQUFDelUsRUFBRSxDQUFDTyxLQUFKLENBQWI7T0FwdEhpQjs7O01Bd3RIbkIsU0FBU3NzQixhQUFULENBQXNCN3NCLEVBQXRCLEVBQTBCO1FBQ3hCLElBQUlvTSxFQUFFLEdBQUdwTSxFQUFFLENBQUNPLEtBQVo7O1FBQ0EsSUFBSTZMLEVBQUosRUFBUTtVQUFFNkksZUFBZSxDQUFDN0ksRUFBRCxFQUFLLFVBQVUwSSxLQUFWLEVBQWlCO1lBQzdDLEtBQUssSUFBSWppRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaWlFLEtBQUssQ0FBQ0osR0FBTixDQUFVamtFLE1BQTlCLEVBQXNDb0MsQ0FBQyxFQUF2QyxFQUNFO2NBQUVpaUUsS0FBSyxDQUFDSixHQUFOLENBQVU3aEUsQ0FBVixFQUFhbXRELEVBQWIsQ0FBZ0JPLEtBQWhCLEdBQXdCLElBQXhCOzs7WUFDSnVzQixhQUFhLENBQUNoWSxLQUFELENBQWI7V0FIdUIsQ0FBZjs7T0ExdEhPOzs7O01BbXVIbkIsU0FBU2dZLGFBQVQsQ0FBdUJoWSxLQUF2QixFQUE4QjtRQUM1QixJQUFJSixHQUFHLEdBQUdJLEtBQUssQ0FBQ0osR0FBaEI7O1FBQ0EsS0FBSyxJQUFJN2hFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2aEUsR0FBRyxDQUFDamtFLE1BQXhCLEVBQWdDb0MsQ0FBQyxFQUFqQztRQUNFO1VBQUVrNkUsZUFBZSxDQUFDclksR0FBRyxDQUFDN2hFLENBQUQsQ0FBSixDQUFmOzs7UUFDSixLQUFLLElBQUlrckQsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzJXLEdBQUcsQ0FBQ2prRSxNQUE1QixFQUFvQ3N0RCxHQUFHLEVBQXZDO1FBQ0U7VUFBRWl2QixlQUFlLENBQUN0WSxHQUFHLENBQUMzVyxHQUFELENBQUosQ0FBZjs7O1FBQ0osS0FBSyxJQUFJQyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHMFcsR0FBRyxDQUFDamtFLE1BQTVCLEVBQW9DdXRELEdBQUcsRUFBdkM7UUFDRTtVQUFFaXZCLGVBQWUsQ0FBQ3ZZLEdBQUcsQ0FBQzFXLEdBQUQsQ0FBSixDQUFmOzs7UUFDSixLQUFLLElBQUlFLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd3VyxHQUFHLENBQUNqa0UsTUFBNUIsRUFBb0N5dEQsR0FBRyxFQUF2QztRQUNFO1VBQUVndkIsZUFBZSxDQUFDeFksR0FBRyxDQUFDeFcsR0FBRCxDQUFKLENBQWY7OztRQUNKLEtBQUssSUFBSUcsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3FXLEdBQUcsQ0FBQ2prRSxNQUE1QixFQUFvQzR0RCxHQUFHLEVBQXZDO1FBQ0U7VUFBRTh1QixtQkFBbUIsQ0FBQ3pZLEdBQUcsQ0FBQ3JXLEdBQUQsQ0FBSixDQUFuQjs7OztNQUdOLFNBQVMwdUIsZUFBVCxDQUF5QjNnQixFQUF6QixFQUE2QjtRQUMzQixJQUFJcE0sRUFBRSxHQUFHb00sRUFBRSxDQUFDcE0sRUFBWjtZQUFnQi9vRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQTdCO1FBQ0FtMkUsbUJBQW1CLENBQUNwdEIsRUFBRCxDQUFuQjs7UUFDQSxJQUFJb00sRUFBRSxDQUFDdWdCLGFBQVAsRUFBc0I7VUFBRW5jLFdBQVcsQ0FBQ3hRLEVBQUQsQ0FBWDs7O1FBRXhCb00sRUFBRSxDQUFDaWhCLFVBQUgsR0FBZ0JqaEIsRUFBRSxDQUFDaVYsV0FBSCxJQUFrQmpWLEVBQUUsQ0FBQzJPLFdBQXJCLElBQW9DM08sRUFBRSxDQUFDcVIsU0FBSCxJQUFnQixJQUFwRCxJQUNkclIsRUFBRSxDQUFDc2MsV0FBSCxLQUFtQnRjLEVBQUUsQ0FBQ3NjLFdBQUgsQ0FBZTk3RCxJQUFmLENBQW9Cd3lDLElBQXBCLEdBQTJCbm9ELE9BQU8sQ0FBQ2t6RCxRQUFuQyxJQUNBaUMsRUFBRSxDQUFDc2MsV0FBSCxDQUFldDRELEVBQWYsQ0FBa0JndkMsSUFBbEIsSUFBMEJub0QsT0FBTyxDQUFDbXpELE1BRHJELENBRGMsSUFHZG56RCxPQUFPLENBQUMwNUQsY0FBUixJQUEwQjNRLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFIdkM7UUFJQTNOLEVBQUUsQ0FBQ3prQixNQUFILEdBQVl5a0IsRUFBRSxDQUFDaWhCLFVBQUgsSUFDVixJQUFJQyxhQUFKLENBQWtCdHRCLEVBQWxCLEVBQXNCb00sRUFBRSxDQUFDaWhCLFVBQUgsSUFBaUI7VUFBQzkvQixHQUFHLEVBQUU2ZSxFQUFFLENBQUNxUixTQUFUO1VBQW9CaUosTUFBTSxFQUFFdGEsRUFBRSxDQUFDc2M7U0FBdEUsRUFBb0Z0YyxFQUFFLENBQUMyTyxXQUF2RixDQURGOzs7TUFJRixTQUFTaVMsZUFBVCxDQUF5QjVnQixFQUF6QixFQUE2QjtRQUMzQkEsRUFBRSxDQUFDbWhCLGNBQUgsR0FBb0JuaEIsRUFBRSxDQUFDaWhCLFVBQUgsSUFBaUJHLHFCQUFxQixDQUFDcGhCLEVBQUUsQ0FBQ3BNLEVBQUosRUFBUW9NLEVBQUUsQ0FBQ3prQixNQUFYLENBQTFEOzs7TUFHRixTQUFTc2xDLGVBQVQsQ0FBeUI3Z0IsRUFBekIsRUFBNkI7UUFDM0IsSUFBSXBNLEVBQUUsR0FBR29NLEVBQUUsQ0FBQ3BNLEVBQVo7WUFBZ0Ivb0QsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUE3Qjs7UUFDQSxJQUFJbTFELEVBQUUsQ0FBQ21oQixjQUFQLEVBQXVCO1VBQUV2SCx1QkFBdUIsQ0FBQ2htQixFQUFELENBQXZCOzs7UUFFekJvTSxFQUFFLENBQUNxaEIsVUFBSCxHQUFnQmhFLG9CQUFvQixDQUFDenBCLEVBQUQsQ0FBcEMsQ0FKMkI7Ozs7UUFTM0IsSUFBSS9vRCxPQUFPLENBQUMwNUQsY0FBUixJQUEwQixDQUFDM1EsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUExQyxFQUF3RDtVQUN0RDNOLEVBQUUsQ0FBQ3NoQixhQUFILEdBQW1CbFQsV0FBVyxDQUFDeGEsRUFBRCxFQUFLL29ELE9BQU8sQ0FBQ3c1RCxPQUFiLEVBQXNCeDVELE9BQU8sQ0FBQ3c1RCxPQUFSLENBQWdCNWhCLElBQWhCLENBQXFCcCtDLE1BQTNDLENBQVgsQ0FBOERrL0IsSUFBOUQsR0FBcUUsQ0FBeEY7VUFDQXF3QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXc3NFLFVBQVgsR0FBd0JuWCxFQUFFLENBQUNzaEIsYUFBM0I7VUFDQXRoQixFQUFFLENBQUNxaEIsVUFBSCxDQUFjbEUsV0FBZCxHQUNFbjlFLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3FDLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCaEIsV0FBMUIsRUFBdUN2aEUsT0FBTyxDQUFDeWhFLEtBQVIsQ0FBYzRILFVBQWQsR0FBMkJsVSxFQUFFLENBQUNzaEIsYUFBOUIsR0FBOENyVSxTQUFTLENBQUNyWixFQUFELENBQXZELEdBQThEQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXd2lFLFFBQWhILENBREY7VUFFQXJOLEVBQUUsQ0FBQ3VoQixhQUFILEdBQW1CdmhGLElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVlxQyxPQUFPLENBQUN5aEUsS0FBUixDQUFjNEgsVUFBZCxHQUEyQmxVLEVBQUUsQ0FBQ3NoQixhQUE5QixHQUE4Q25VLFlBQVksQ0FBQ3ZaLEVBQUQsQ0FBdEUsQ0FBbkI7OztRQUdGLElBQUlvTSxFQUFFLENBQUNtaEIsY0FBSCxJQUFxQm5oQixFQUFFLENBQUNzZ0IsZ0JBQTVCLEVBQ0U7VUFBRXRnQixFQUFFLENBQUN3aEIsaUJBQUgsR0FBdUIzMkUsT0FBTyxDQUFDdThELEtBQVIsQ0FBYzRPLGdCQUFkLEVBQXZCOzs7O01BR04sU0FBUzhLLGVBQVQsQ0FBeUI5Z0IsRUFBekIsRUFBNkI7UUFDM0IsSUFBSXBNLEVBQUUsR0FBR29NLEVBQUUsQ0FBQ3BNLEVBQVo7O1FBRUEsSUFBSW9NLEVBQUUsQ0FBQ3NoQixhQUFILElBQW9CLElBQXhCLEVBQThCO1VBQzVCMXRCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd5aEUsS0FBWCxDQUFpQjFoRSxLQUFqQixDQUF1QnN6RSxRQUF2QixHQUFrQ2xlLEVBQUUsQ0FBQ3NoQixhQUFILEdBQW1CLElBQXJEOztVQUNBLElBQUl0aEIsRUFBRSxDQUFDdWhCLGFBQUgsR0FBbUIzdEIsRUFBRSxDQUFDa0csR0FBSCxDQUFPbVgsVUFBOUIsRUFDRTtZQUFFc0ssYUFBYSxDQUFDM25CLEVBQUQsRUFBSzV6RCxJQUFJLENBQUNzSSxHQUFMLENBQVNzckQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CNkQsVUFBN0IsRUFBeUNqUixFQUFFLENBQUN1aEIsYUFBNUMsQ0FBTCxFQUFpRSxJQUFqRSxDQUFiOzs7VUFDSjN0QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXMDVELGNBQVgsR0FBNEIsS0FBNUI7OztRQUdGLElBQUlrZCxTQUFTLEdBQUd6aEIsRUFBRSxDQUFDMVgsS0FBSCxJQUFZMFgsRUFBRSxDQUFDMVgsS0FBSCxJQUFZeUUsU0FBUyxFQUFqRDs7UUFDQSxJQUFJaVQsRUFBRSxDQUFDd2hCLGlCQUFQLEVBQ0U7VUFBRTV0QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUIyTyxhQUFqQixDQUErQi9WLEVBQUUsQ0FBQ3doQixpQkFBbEMsRUFBcURDLFNBQXJEOzs7UUFDSixJQUFJemhCLEVBQUUsQ0FBQ21oQixjQUFILElBQXFCbmhCLEVBQUUsQ0FBQ29mLFdBQUgsSUFBa0J4ckIsRUFBRSxDQUFDa0csR0FBSCxDQUFPamEsTUFBbEQsRUFDRTtVQUFFcS9CLGdCQUFnQixDQUFDdHJCLEVBQUQsRUFBS29NLEVBQUUsQ0FBQ3FoQixVQUFSLENBQWhCOzs7UUFDSixJQUFJcmhCLEVBQUUsQ0FBQ21oQixjQUFQLEVBQ0U7VUFBRU8saUJBQWlCLENBQUM5dEIsRUFBRCxFQUFLb00sRUFBRSxDQUFDcWhCLFVBQVIsQ0FBakI7OztRQUVKLElBQUlyaEIsRUFBRSxDQUFDc2dCLGdCQUFQLEVBQXlCO1VBQUV6SCxZQUFZLENBQUNqbEIsRUFBRCxDQUFaOzs7UUFFM0IsSUFBSUEsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU2d2QyxPQUFULElBQW9COVksRUFBRSxDQUFDbWdCLFdBQTNCLEVBQ0U7VUFBRXZzQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUJoOEIsS0FBakIsQ0FBdUI0MEIsRUFBRSxDQUFDb2dCLE1BQTFCOzs7UUFDSixJQUFJcUIsU0FBSixFQUFlO1VBQUVwSSxXQUFXLENBQUNyWixFQUFFLENBQUNwTSxFQUFKLENBQVg7Ozs7TUFHbkIsU0FBU210QixtQkFBVCxDQUE2Qi9nQixFQUE3QixFQUFpQztRQUMvQixJQUFJcE0sRUFBRSxHQUFHb00sRUFBRSxDQUFDcE0sRUFBWjtZQUFnQi9vRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQTdCO1lBQXNDaXZELEdBQUcsR0FBR2xHLEVBQUUsQ0FBQ2tHLEdBQS9DOztRQUVBLElBQUlrRyxFQUFFLENBQUNtaEIsY0FBUCxFQUF1QjtVQUFFUSxpQkFBaUIsQ0FBQy90QixFQUFELEVBQUtvTSxFQUFFLENBQUN6a0IsTUFBUixDQUFqQjtTQUhNOzs7UUFNL0IsSUFBSTF3QyxPQUFPLENBQUMrMkUsV0FBUixJQUF1QixJQUF2QixLQUFnQzVoQixFQUFFLENBQUNxUixTQUFILElBQWdCLElBQWhCLElBQXdCclIsRUFBRSxDQUFDaVIsVUFBSCxJQUFpQixJQUF6QyxJQUFpRGpSLEVBQUUsQ0FBQ3NjLFdBQXBGLENBQUosRUFDRTtVQUFFenhFLE9BQU8sQ0FBQysyRSxXQUFSLEdBQXNCLzJFLE9BQU8sQ0FBQ2czRSxXQUFSLEdBQXNCLElBQTVDO1NBUDJCOzs7UUFVL0IsSUFBSTdoQixFQUFFLENBQUNxUixTQUFILElBQWdCLElBQXBCLEVBQTBCO1VBQUV3TCxZQUFZLENBQUNqcEIsRUFBRCxFQUFLb00sRUFBRSxDQUFDcVIsU0FBUixFQUFtQnJSLEVBQUUsQ0FBQytjLFdBQXRCLENBQVo7OztRQUU1QixJQUFJL2MsRUFBRSxDQUFDaVIsVUFBSCxJQUFpQixJQUFyQixFQUEyQjtVQUFFc0ssYUFBYSxDQUFDM25CLEVBQUQsRUFBS29NLEVBQUUsQ0FBQ2lSLFVBQVIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBYjtTQVpFOzs7UUFjL0IsSUFBSWpSLEVBQUUsQ0FBQ3NjLFdBQVAsRUFBb0I7VUFDbEIsSUFBSXg3QixJQUFJLEdBQUdnNkIsaUJBQWlCLENBQUNsbkIsRUFBRCxFQUFLNEgsUUFBTyxDQUFDMUIsR0FBRCxFQUFNa0csRUFBRSxDQUFDc2MsV0FBSCxDQUFlOTdELElBQXJCLENBQVosRUFDQ2c3QyxRQUFPLENBQUMxQixHQUFELEVBQU1rRyxFQUFFLENBQUNzYyxXQUFILENBQWV0NEQsRUFBckIsQ0FEUixFQUNrQ2c4QyxFQUFFLENBQUNzYyxXQUFILENBQWV2QixNQURqRCxDQUE1QjtVQUVBTixpQkFBaUIsQ0FBQzdtQixFQUFELEVBQUs5UyxJQUFMLENBQWpCO1NBakI2Qjs7OztRQXNCL0IsSUFBSW1uQixNQUFNLEdBQUdqSSxFQUFFLENBQUM4aEIsa0JBQWhCO1lBQW9DQyxRQUFRLEdBQUcvaEIsRUFBRSxDQUFDZ2lCLG9CQUFsRDs7UUFDQSxJQUFJL1osTUFBSixFQUFZO1VBQUUsS0FBSyxJQUFJeGhFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3aEUsTUFBTSxDQUFDNWpFLE1BQTNCLEVBQW1DLEVBQUVvQyxDQUFyQyxFQUNaO1lBQUUsSUFBSSxDQUFDd2hFLE1BQU0sQ0FBQ3hoRSxDQUFELENBQU4sQ0FBVXV6RCxLQUFWLENBQWdCMzFELE1BQXJCLEVBQTZCO2NBQUVvdkQsTUFBTSxDQUFDd1UsTUFBTSxDQUFDeGhFLENBQUQsQ0FBUCxFQUFZLE1BQVosQ0FBTjs7Ozs7UUFDbkMsSUFBSXM3RSxRQUFKLEVBQWM7VUFBRSxLQUFLLElBQUlwd0IsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR293QixRQUFRLENBQUMxOUUsTUFBakMsRUFBeUMsRUFBRXN0RCxHQUEzQyxFQUNkO1lBQUUsSUFBSW93QixRQUFRLENBQUNwd0IsR0FBRCxDQUFSLENBQWNxSSxLQUFkLENBQW9CMzFELE1BQXhCLEVBQWdDO2NBQUVvdkQsTUFBTSxDQUFDc3VCLFFBQVEsQ0FBQ3B3QixHQUFELENBQVQsRUFBZ0IsUUFBaEIsQ0FBTjs7Ozs7UUFFdEMsSUFBSTltRCxPQUFPLENBQUN5bUIsT0FBUixDQUFnQitqQyxZQUFwQixFQUNFO1VBQUV5RSxHQUFHLENBQUN1WCxTQUFKLEdBQWdCemQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFYLENBQW9CaUUsU0FBcEM7U0E3QjJCOzs7UUFnQy9CLElBQUlyUixFQUFFLENBQUNxZ0IsVUFBUCxFQUNFO1VBQUU1c0IsTUFBTSxDQUFDRyxFQUFELEVBQUssU0FBTCxFQUFnQkEsRUFBaEIsRUFBb0JvTSxFQUFFLENBQUNxZ0IsVUFBdkIsQ0FBTjs7O1FBQ0osSUFBSXJnQixFQUFFLENBQUN6a0IsTUFBUCxFQUNFO1VBQUV5a0IsRUFBRSxDQUFDemtCLE1BQUgsQ0FBVW5QLE1BQVY7O09BbjFIYTs7O01BdTFIbkIsU0FBUzYxQyxPQUFULENBQWlCcnVCLEVBQWpCLEVBQXFCanhELENBQXJCLEVBQXdCO1FBQ3RCLElBQUlpeEQsRUFBRSxDQUFDTyxLQUFQLEVBQWM7VUFBRSxPQUFPeHhELENBQUMsRUFBUjs7O1FBQ2hCdTlFLGVBQWMsQ0FBQ3RzQixFQUFELENBQWQ7O1FBQ0EsSUFBSTtVQUFFLE9BQU9qeEQsQ0FBQyxFQUFSO1NBQU4sU0FDUTtVQUFFODlFLGFBQVksQ0FBQzdzQixFQUFELENBQVo7O09BMzFITzs7O01BODFIbkIsU0FBU2pPLFNBQVQsQ0FBbUJpTyxFQUFuQixFQUF1Qmp4RCxDQUF2QixFQUEwQjtRQUN4QixPQUFPLFlBQVc7VUFDaEIsSUFBSWl4RCxFQUFFLENBQUNPLEtBQVAsRUFBYztZQUFFLE9BQU94eEQsQ0FBQyxDQUFDOEIsS0FBRixDQUFRbXZELEVBQVIsRUFBWWx2RCxTQUFaLENBQVA7OztVQUNoQnc3RSxlQUFjLENBQUN0c0IsRUFBRCxDQUFkOztVQUNBLElBQUk7WUFBRSxPQUFPanhELENBQUMsQ0FBQzhCLEtBQUYsQ0FBUW12RCxFQUFSLEVBQVlsdkQsU0FBWixDQUFQO1dBQU4sU0FDUTtZQUFFKzdFLGFBQVksQ0FBQzdzQixFQUFELENBQVo7O1NBSlo7T0EvMUhpQjs7OztNQXcySG5CLFNBQVNzdUIsUUFBVCxDQUFrQnYvRSxDQUFsQixFQUFxQjtRQUNuQixPQUFPLFlBQVc7VUFDaEIsSUFBSSxLQUFLd3hELEtBQVQsRUFBZ0I7WUFBRSxPQUFPeHhELENBQUMsQ0FBQzhCLEtBQUYsQ0FBUSxJQUFSLEVBQWNDLFNBQWQsQ0FBUDs7O1VBQ2xCdzdFLGVBQWMsQ0FBQyxJQUFELENBQWQ7O1VBQ0EsSUFBSTtZQUFFLE9BQU92OUUsQ0FBQyxDQUFDOEIsS0FBRixDQUFRLElBQVIsRUFBY0MsU0FBZCxDQUFQO1dBQU4sU0FDUTtZQUFFKzdFLGFBQVksQ0FBQyxJQUFELENBQVo7O1NBSlo7OztNQU9GLFNBQVMwQixXQUFULENBQXFCeC9FLENBQXJCLEVBQXdCO1FBQ3RCLE9BQU8sWUFBVztVQUNoQixJQUFJaXhELEVBQUUsR0FBRyxLQUFLQSxFQUFkOztVQUNBLElBQUksQ0FBQ0EsRUFBRCxJQUFPQSxFQUFFLENBQUNPLEtBQWQsRUFBcUI7WUFBRSxPQUFPeHhELENBQUMsQ0FBQzhCLEtBQUYsQ0FBUSxJQUFSLEVBQWNDLFNBQWQsQ0FBUDs7O1VBQ3ZCdzdFLGVBQWMsQ0FBQ3RzQixFQUFELENBQWQ7O1VBQ0EsSUFBSTtZQUFFLE9BQU9qeEQsQ0FBQyxDQUFDOEIsS0FBRixDQUFRLElBQVIsRUFBY0MsU0FBZCxDQUFQO1dBQU4sU0FDUTtZQUFFKzdFLGFBQVksQ0FBQzdzQixFQUFELENBQVo7O1NBTFo7T0FqM0hpQjs7O01BNDNIbkIsU0FBU2twQixXQUFULENBQXFCbHBCLEVBQXJCLEVBQXlCbnZCLElBQXpCLEVBQStCO1FBQzdCLElBQUltdkIsRUFBRSxDQUFDa0csR0FBSCxDQUFPNEQsaUJBQVAsR0FBMkI5SixFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQTFDLEVBQ0U7VUFBRXBLLEVBQUUsQ0FBQzlwQixLQUFILENBQVNzNEMsU0FBVCxDQUFtQjl6RSxHQUFuQixDQUF1Qm0yQixJQUF2QixFQUE2QjN5QixJQUFJLENBQUN1d0UsZUFBRCxFQUFrQnp1QixFQUFsQixDQUFqQzs7OztNQUdOLFNBQVN5dUIsZUFBVCxDQUF5Qnp1QixFQUF6QixFQUE2QjtRQUMzQixJQUFJa0csR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjs7UUFDQSxJQUFJQSxHQUFHLENBQUM0RCxpQkFBSixJQUF5QjlKLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBeEMsRUFBZ0Q7VUFBRTs7O1FBQ2xELElBQUk5Z0QsR0FBRyxHQUFHLENBQUMsSUFBSThCLElBQUosRUFBRCxHQUFZNDBDLEVBQUUsQ0FBQ2psQixPQUFILENBQVcyekMsUUFBakM7UUFDQSxJQUFJdGxFLE9BQU8sR0FBR3FnRCxnQkFBZ0IsQ0FBQ3pKLEVBQUQsRUFBS2tHLEdBQUcsQ0FBQzRELGlCQUFULENBQTlCO1FBQ0EsSUFBSTZrQixZQUFZLEdBQUcsRUFBbkI7UUFFQXpvQixHQUFHLENBQUNuNUMsSUFBSixDQUFTM0QsT0FBTyxDQUFDZzJDLElBQWpCLEVBQXVCaHpELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3d4RCxHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUF6QixFQUErQnExQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQVgsR0FBb0IsR0FBbkQsQ0FBdkIsRUFBZ0YsVUFBVWhMLElBQVYsRUFBZ0I7VUFDOUYsSUFBSWgyQyxPQUFPLENBQUNnMkMsSUFBUixJQUFnQlksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t6RCxRQUEvQixFQUF5Qzs7WUFDdkMsSUFBSXlrQixTQUFTLEdBQUd4dkIsSUFBSSxDQUFDN2IsTUFBckI7WUFDQSxJQUFJbW1CLFVBQVUsR0FBR3RLLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFWLEdBQW1CdXZELEVBQUUsQ0FBQ2psQixPQUFILENBQVc0dUIsa0JBQTlCLEdBQW1EMUYsU0FBUyxDQUFDaUMsR0FBRyxDQUFDejJELElBQUwsRUFBVzJaLE9BQU8sQ0FBQzhzQixLQUFuQixDQUE1RCxHQUF3RixJQUF6RztZQUNBLElBQUkyNEMsV0FBVyxHQUFHcG1CLGFBQWEsQ0FBQ3pJLEVBQUQsRUFBS1osSUFBTCxFQUFXaDJDLE9BQVgsRUFBb0IsSUFBcEIsQ0FBL0I7O1lBQ0EsSUFBSXNnRCxVQUFKLEVBQWdCO2NBQUV0Z0QsT0FBTyxDQUFDOHNCLEtBQVIsR0FBZ0J3ekIsVUFBaEI7OztZQUNsQnRLLElBQUksQ0FBQzdiLE1BQUwsR0FBY3NyQyxXQUFXLENBQUN0ckMsTUFBMUI7WUFDQSxJQUFJdXJDLE1BQU0sR0FBRzF2QixJQUFJLENBQUN5SyxZQUFsQjtnQkFBZ0NrbEIsTUFBTSxHQUFHRixXQUFXLENBQUN6bEIsT0FBckQ7O1lBQ0EsSUFBSTJsQixNQUFKLEVBQVk7Y0FBRTN2QixJQUFJLENBQUN5SyxZQUFMLEdBQW9Ca2xCLE1BQXBCO2FBQWQsTUFDSyxJQUFJRCxNQUFKLEVBQVk7Y0FBRTF2QixJQUFJLENBQUN5SyxZQUFMLEdBQW9CLElBQXBCOzs7WUFDbkIsSUFBSW1sQixRQUFRLEdBQUcsQ0FBQ0osU0FBRCxJQUFjQSxTQUFTLENBQUNuK0UsTUFBVixJQUFvQjJ1RCxJQUFJLENBQUM3YixNQUFMLENBQVk5eUMsTUFBOUMsSUFDYnErRSxNQUFNLElBQUlDLE1BQVYsS0FBcUIsQ0FBQ0QsTUFBRCxJQUFXLENBQUNDLE1BQVosSUFBc0JELE1BQU0sQ0FBQ3psQixPQUFQLElBQWtCMGxCLE1BQU0sQ0FBQzFsQixPQUEvQyxJQUEwRHlsQixNQUFNLENBQUN4bEIsU0FBUCxJQUFvQnlsQixNQUFNLENBQUN6bEIsU0FBMUcsQ0FERjs7WUFFQSxLQUFLLElBQUl6MkQsQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQ204RSxRQUFELElBQWFuOEUsQ0FBQyxHQUFHKzdFLFNBQVMsQ0FBQ24rRSxNQUEzQyxFQUFtRCxFQUFFb0MsQ0FBckQsRUFBd0Q7Y0FBRW04RSxRQUFRLEdBQUdKLFNBQVMsQ0FBQy83RSxDQUFELENBQVQsSUFBZ0J1c0QsSUFBSSxDQUFDN2IsTUFBTCxDQUFZMXdDLENBQVosQ0FBM0I7OztZQUMxRCxJQUFJbThFLFFBQUosRUFBYztjQUFFTCxZQUFZLENBQUNuL0UsSUFBYixDQUFrQjRaLE9BQU8sQ0FBQ2cyQyxJQUExQjs7O1lBQ2hCQSxJQUFJLENBQUN3SyxVQUFMLEdBQWtCeGdELE9BQU8sQ0FBQ20vQyxJQUFSLEVBQWxCO1lBQ0FuL0MsT0FBTyxDQUFDZy9DLFFBQVI7V0FkRixNQWVPO1lBQ0wsSUFBSWhKLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFWLElBQW9CdXZELEVBQUUsQ0FBQ2psQixPQUFILENBQVc0dUIsa0JBQW5DLEVBQ0U7Y0FBRU8sV0FBVyxDQUFDbEssRUFBRCxFQUFLWixJQUFJLENBQUN2USxJQUFWLEVBQWdCemxDLE9BQWhCLENBQVg7OztZQUNKZzJDLElBQUksQ0FBQ3dLLFVBQUwsR0FBa0J4Z0QsT0FBTyxDQUFDZzJDLElBQVIsR0FBZSxDQUFmLElBQW9CLENBQXBCLEdBQXdCaDJDLE9BQU8sQ0FBQ20vQyxJQUFSLEVBQXhCLEdBQXlDLElBQTNEO1lBQ0FuL0MsT0FBTyxDQUFDZy9DLFFBQVI7OztVQUVGLElBQUksQ0FBQyxJQUFJaDlDLElBQUosRUFBRCxHQUFZOUIsR0FBaEIsRUFBcUI7WUFDbkI0L0QsV0FBVyxDQUFDbHBCLEVBQUQsRUFBS0EsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2swQyxTQUFoQixDQUFYO1lBQ0EsT0FBTyxJQUFQOztTQXhCSjtRQTJCQS9vQixHQUFHLENBQUM0RCxpQkFBSixHQUF3QjFnRCxPQUFPLENBQUNnMkMsSUFBaEM7UUFDQThHLEdBQUcsQ0FBQzZELFlBQUosR0FBbUIzOUQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTc3hELEdBQUcsQ0FBQzZELFlBQWIsRUFBMkIzZ0QsT0FBTyxDQUFDZzJDLElBQW5DLENBQW5COztRQUNBLElBQUl1dkIsWUFBWSxDQUFDbCtFLE1BQWpCLEVBQXlCO1VBQUU0OUUsT0FBTyxDQUFDcnVCLEVBQUQsRUFBSyxZQUFZO1lBQ2pELEtBQUssSUFBSW50RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHODdFLFlBQVksQ0FBQ2wrRSxNQUFqQyxFQUF5Q29DLENBQUMsRUFBMUMsRUFDRTtjQUFFK3VFLGFBQWEsQ0FBQzVoQixFQUFELEVBQUsydUIsWUFBWSxDQUFDOTdFLENBQUQsQ0FBakIsRUFBc0IsTUFBdEIsQ0FBYjs7V0FGNEIsQ0FBUDs7T0FyNkhWOzs7TUE2NkhuQixJQUFJeTZFLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBU3R0QixFQUFULEVBQWF5bUIsUUFBYixFQUF1QnlJLEtBQXZCLEVBQThCO1FBQ2hELElBQUlqNEUsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtRQUVBLEtBQUt3dkUsUUFBTCxHQUFnQkEsUUFBaEIsQ0FIZ0Q7O1FBS2hELEtBQUswSSxPQUFMLEdBQWUzSSxZQUFZLENBQUN2dkUsT0FBRCxFQUFVK29ELEVBQUUsQ0FBQ2tHLEdBQWIsRUFBa0J1Z0IsUUFBbEIsQ0FBM0I7UUFDQSxLQUFLMkksY0FBTCxHQUFzQixDQUFDbjRFLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCZ2tDLFdBQXZDO1FBQ0EsS0FBSzJ0QixhQUFMLEdBQXFCcDRFLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCaThDLFlBQXJDO1FBQ0EsS0FBSzFCLFlBQUwsR0FBb0JoaEUsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0I4NkMsV0FBcEM7UUFDQSxLQUFLOFcsZUFBTCxHQUF1Qi9WLFlBQVksQ0FBQ3ZaLEVBQUQsQ0FBbkM7UUFDQSxLQUFLa3ZCLEtBQUwsR0FBYUEsS0FBYjtRQUNBLEtBQUsxWixJQUFMLEdBQVlzRixhQUFhLENBQUM5YSxFQUFELENBQXpCO1FBQ0EsS0FBS3V2QixNQUFMLEdBQWMsRUFBZDtPQVpGOztNQWVBakMsYUFBYSxDQUFDLzhFLFNBQWQsQ0FBd0JzdkQsTUFBeEIsR0FBaUMsVUFBVU4sT0FBVixFQUFtQnR1RCxJQUFuQixFQUF5QjtRQUN4RCxJQUFJd3ZELFVBQVUsQ0FBQ2xCLE9BQUQsRUFBVXR1RCxJQUFWLENBQWQsRUFDRTtVQUFFLEtBQUtzK0UsTUFBTCxDQUFZLy9FLElBQVosQ0FBaUJzQixTQUFqQjs7T0FGTjs7TUFJQXc4RSxhQUFhLENBQUMvOEUsU0FBZCxDQUF3QmlvQyxNQUF4QixHQUFpQyxZQUFZO1FBQzNDLEtBQUssSUFBSTNsQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUswOEUsTUFBTCxDQUFZOStFLE1BQWhDLEVBQXdDb0MsQ0FBQyxFQUF6QyxFQUNFO1VBQUVndEQsTUFBTSxDQUFDaHZELEtBQVAsQ0FBYSxJQUFiLEVBQW1CLEtBQUswK0UsTUFBTCxDQUFZMThFLENBQVosQ0FBbkI7O09BRk47O01BS0EsU0FBU3U2RSxtQkFBVCxDQUE2QnB0QixFQUE3QixFQUFpQztRQUMvQixJQUFJL29ELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBakI7O1FBQ0EsSUFBSSxDQUFDQSxPQUFPLENBQUN1NEUsaUJBQVQsSUFBOEJ2NEUsT0FBTyxDQUFDdWlFLFFBQVIsQ0FBaUI5WCxXQUFuRCxFQUFnRTtVQUM5RHpxRCxPQUFPLENBQUNxaUUsY0FBUixHQUF5QnJpRSxPQUFPLENBQUN1aUUsUUFBUixDQUFpQjlYLFdBQWpCLEdBQStCenFELE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCaEIsV0FBekU7VUFDQXZoRSxPQUFPLENBQUMyMEUsWUFBUixDQUFxQjUwRSxLQUFyQixDQUEyQmkxQyxNQUEzQixHQUFvQ290QixTQUFTLENBQUNyWixFQUFELENBQVQsR0FBZ0IsSUFBcEQ7VUFDQS9vRCxPQUFPLENBQUN5aEUsS0FBUixDQUFjMWhFLEtBQWQsQ0FBb0J5NEUsWUFBcEIsR0FBbUMsQ0FBQ3g0RSxPQUFPLENBQUNxaUUsY0FBVCxHQUEwQixJQUE3RDtVQUNBcmlFLE9BQU8sQ0FBQ3loRSxLQUFSLENBQWMxaEUsS0FBZCxDQUFvQjA0RSxnQkFBcEIsR0FBdUNyVyxTQUFTLENBQUNyWixFQUFELENBQVQsR0FBZ0IsSUFBdkQ7VUFDQS9vRCxPQUFPLENBQUN1NEUsaUJBQVIsR0FBNEIsSUFBNUI7Ozs7TUFJSixTQUFTRyxpQkFBVCxDQUEyQjN2QixFQUEzQixFQUErQjtRQUM3QixJQUFJQSxFQUFFLENBQUN3bEIsUUFBSCxFQUFKLEVBQW1CO1VBQUUsT0FBTyxJQUFQOzs7UUFDckIsSUFBSXAyQixNQUFNLEdBQUcrSixTQUFTLEVBQXRCOztRQUNBLElBQUksQ0FBQy9KLE1BQUQsSUFBVyxDQUFDNkosUUFBUSxDQUFDK0csRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2l2RSxPQUFaLEVBQXFCOTJCLE1BQXJCLENBQXhCLEVBQXNEO1VBQUUsT0FBTyxJQUFQOzs7UUFDeEQsSUFBSTM1QyxNQUFNLEdBQUc7VUFBQzBqRCxTQUFTLEVBQUUvSjtTQUF6Qjs7UUFDQSxJQUFJampELE1BQU0sQ0FBQ2kyRCxZQUFYLEVBQXlCO1VBQ3ZCLElBQUlxZ0IsR0FBRyxHQUFHdDJFLE1BQU0sQ0FBQ2kyRCxZQUFQLEVBQVY7O1VBQ0EsSUFBSXFnQixHQUFHLENBQUNtTixVQUFKLElBQWtCbk4sR0FBRyxDQUFDb04sTUFBdEIsSUFBZ0M1MkIsUUFBUSxDQUFDK0csRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2l2RSxPQUFaLEVBQXFCekQsR0FBRyxDQUFDbU4sVUFBekIsQ0FBNUMsRUFBa0Y7WUFDaEZuNkUsTUFBTSxDQUFDbTZFLFVBQVAsR0FBb0JuTixHQUFHLENBQUNtTixVQUF4QjtZQUNBbjZFLE1BQU0sQ0FBQ3E2RSxZQUFQLEdBQXNCck4sR0FBRyxDQUFDcU4sWUFBMUI7WUFDQXI2RSxNQUFNLENBQUNzNkUsU0FBUCxHQUFtQnROLEdBQUcsQ0FBQ3NOLFNBQXZCO1lBQ0F0NkUsTUFBTSxDQUFDdTZFLFdBQVAsR0FBcUJ2TixHQUFHLENBQUN1TixXQUF6Qjs7OztRQUdKLE9BQU92NkUsTUFBUDs7O01BR0YsU0FBU3c2RSxnQkFBVCxDQUEwQkMsUUFBMUIsRUFBb0M7UUFDbEMsSUFBSSxDQUFDQSxRQUFELElBQWEsQ0FBQ0EsUUFBUSxDQUFDLzJCLFNBQXZCLElBQW9DKzJCLFFBQVEsQ0FBQy8yQixTQUFULElBQXNCQSxTQUFTLEVBQXZFLEVBQTJFO1VBQUU7OztRQUM3RSsyQixRQUFRLENBQUMvMkIsU0FBVCxDQUFtQnpFLEtBQW5COztRQUNBLElBQUksQ0FBQyxxQkFBcUJyM0MsSUFBckIsQ0FBMEI2eUUsUUFBUSxDQUFDLzJCLFNBQVQsQ0FBbUJnM0IsUUFBN0MsQ0FBRCxJQUNBRCxRQUFRLENBQUNOLFVBRFQsSUFDdUIzMkIsUUFBUSxDQUFDenJELFFBQVEsQ0FBQ285QyxJQUFWLEVBQWdCc2xDLFFBQVEsQ0FBQ04sVUFBekIsQ0FEL0IsSUFDdUUzMkIsUUFBUSxDQUFDenJELFFBQVEsQ0FBQ285QyxJQUFWLEVBQWdCc2xDLFFBQVEsQ0FBQ0gsU0FBekIsQ0FEbkYsRUFDd0g7VUFDdEgsSUFBSXROLEdBQUcsR0FBR3QyRSxNQUFNLENBQUNpMkQsWUFBUCxFQUFWO2NBQWlDeFMsS0FBSyxHQUFHcGlELFFBQVEsQ0FBQ2lyRCxXQUFULEVBQXpDO1VBQ0E3SSxLQUFLLENBQUM4SSxNQUFOLENBQWF3M0IsUUFBUSxDQUFDTixVQUF0QixFQUFrQ00sUUFBUSxDQUFDSixZQUEzQztVQUNBbGdDLEtBQUssQ0FBQ2tKLFFBQU4sQ0FBZSxLQUFmO1VBQ0EycEIsR0FBRyxDQUFDMk4sZUFBSjtVQUNBM04sR0FBRyxDQUFDNE4sUUFBSixDQUFhemdDLEtBQWI7VUFDQTZ5QixHQUFHLENBQUNvTixNQUFKLENBQVdLLFFBQVEsQ0FBQ0gsU0FBcEIsRUFBK0JHLFFBQVEsQ0FBQ0YsV0FBeEM7O09BMytIZTs7Ozs7TUFrL0huQixTQUFTeEMscUJBQVQsQ0FBK0J4dEIsRUFBL0IsRUFBbUNyWSxNQUFuQyxFQUEyQztRQUN6QyxJQUFJMXdDLE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBakI7WUFBMEJpdkQsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBbkM7O1FBRUEsSUFBSXZlLE1BQU0sQ0FBQ3luQyxjQUFYLEVBQTJCO1VBQ3pCOU4sU0FBUyxDQUFDdGhCLEVBQUQsQ0FBVDtVQUNBLE9BQU8sS0FBUDtTQUx1Qzs7O1FBU3pDLElBQUksQ0FBQ3JZLE1BQU0sQ0FBQ3VuQyxLQUFSLElBQ0F2bkMsTUFBTSxDQUFDd25DLE9BQVAsQ0FBZXZpRSxJQUFmLElBQXVCM1YsT0FBTyxDQUFDa3pELFFBRC9CLElBQzJDeGlCLE1BQU0sQ0FBQ3duQyxPQUFQLENBQWUvK0QsRUFBZixJQUFxQm5aLE9BQU8sQ0FBQ216RCxNQUR4RSxLQUVDbnpELE9BQU8sQ0FBQ21xRSxpQkFBUixJQUE2QixJQUE3QixJQUFxQ25xRSxPQUFPLENBQUNtcUUsaUJBQVIsSUFBNkJucUUsT0FBTyxDQUFDbXpELE1BRjNFLEtBR0FuekQsT0FBTyxDQUFDcTVFLFlBQVIsSUFBd0JyNUUsT0FBTyxDQUFDa3RCLElBSGhDLElBR3dDNjlDLGNBQWMsQ0FBQ2hpQixFQUFELENBQWQsSUFBc0IsQ0FIbEUsRUFJRTtVQUFFLE9BQU8sS0FBUDs7O1FBRUosSUFBSXV3QiwwQkFBMEIsQ0FBQ3Z3QixFQUFELENBQTlCLEVBQW9DO1VBQ2xDc2hCLFNBQVMsQ0FBQ3RoQixFQUFELENBQVQ7VUFDQXJZLE1BQU0sQ0FBQzZ0QixJQUFQLEdBQWNzRixhQUFhLENBQUM5YSxFQUFELENBQTNCO1NBakJ1Qzs7O1FBcUJ6QyxJQUFJMTJDLEdBQUcsR0FBRzQ4QyxHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUExQjtRQUNBLElBQUlpQyxJQUFJLEdBQUd4Z0IsSUFBSSxDQUFDd0ksR0FBTCxDQUFTK3lDLE1BQU0sQ0FBQ3duQyxPQUFQLENBQWV2aUUsSUFBZixHQUFzQm96QyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXeTFDLGNBQTFDLEVBQTBEdHFCLEdBQUcsQ0FBQ3ZsRCxLQUE5RCxDQUFYO1FBQ0EsSUFBSXlQLEVBQUUsR0FBR2hrQixJQUFJLENBQUNzSSxHQUFMLENBQVM0VSxHQUFULEVBQWNxK0IsTUFBTSxDQUFDd25DLE9BQVAsQ0FBZS8rRCxFQUFmLEdBQW9CNHZDLEVBQUUsQ0FBQ2psQixPQUFILENBQVd5MUMsY0FBN0MsQ0FBVDs7UUFDQSxJQUFJdjVFLE9BQU8sQ0FBQ2t6RCxRQUFSLEdBQW1CdjlDLElBQW5CLElBQTJCQSxJQUFJLEdBQUczVixPQUFPLENBQUNrekQsUUFBZixHQUEwQixFQUF6RCxFQUE2RDtVQUFFdjlDLElBQUksR0FBR3hnQixJQUFJLENBQUN3SSxHQUFMLENBQVNzeEQsR0FBRyxDQUFDdmxELEtBQWIsRUFBb0IxSixPQUFPLENBQUNrekQsUUFBNUIsQ0FBUDs7O1FBQy9ELElBQUlsekQsT0FBTyxDQUFDbXpELE1BQVIsR0FBaUJoNkMsRUFBakIsSUFBdUJuWixPQUFPLENBQUNtekQsTUFBUixHQUFpQmg2QyxFQUFqQixHQUFzQixFQUFqRCxFQUFxRDtVQUFFQSxFQUFFLEdBQUdoa0IsSUFBSSxDQUFDc0ksR0FBTCxDQUFTNFUsR0FBVCxFQUFjclMsT0FBTyxDQUFDbXpELE1BQXRCLENBQUw7OztRQUN2RCxJQUFJdUIsaUJBQUosRUFBdUI7VUFDckIvK0MsSUFBSSxHQUFHaWpELFlBQVksQ0FBQzdQLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3Q1QyxJQUFULENBQW5CO1VBQ0F3RCxFQUFFLEdBQUc0L0MsZUFBZSxDQUFDaFEsRUFBRSxDQUFDa0csR0FBSixFQUFTOTFDLEVBQVQsQ0FBcEI7OztRQUdGLElBQUlxZ0UsU0FBUyxHQUFHN2pFLElBQUksSUFBSTNWLE9BQU8sQ0FBQ2t6RCxRQUFoQixJQUE0Qi81QyxFQUFFLElBQUluWixPQUFPLENBQUNtekQsTUFBMUMsSUFDZG56RCxPQUFPLENBQUN5NUUsY0FBUixJQUEwQi9vQyxNQUFNLENBQUMwbkMsYUFEbkIsSUFDb0NwNEUsT0FBTyxDQUFDMDVFLGFBQVIsSUFBeUJocEMsTUFBTSxDQUFDc3dCLFlBRHBGO1FBRUE4SixVQUFVLENBQUMvaEIsRUFBRCxFQUFLcHpDLElBQUwsRUFBV3dELEVBQVgsQ0FBVjtRQUVBblosT0FBTyxDQUFDNm1FLFVBQVIsR0FBcUJ6TixhQUFZLENBQUNwSyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVNqdkQsT0FBTyxDQUFDa3pELFFBQWpCLENBQVIsQ0FBakMsQ0FuQ3lDOztRQXFDekNuSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXMGhFLEtBQVgsQ0FBaUIzaEUsS0FBakIsQ0FBdUJ1MkMsR0FBdkIsR0FBNkJ0MkMsT0FBTyxDQUFDNm1FLFVBQVIsR0FBcUIsSUFBbEQ7UUFFQSxJQUFJOFMsUUFBUSxHQUFHNU8sY0FBYyxDQUFDaGlCLEVBQUQsQ0FBN0I7O1FBQ0EsSUFBSSxDQUFDeXdCLFNBQUQsSUFBY0csUUFBUSxJQUFJLENBQTFCLElBQStCLENBQUNqcEMsTUFBTSxDQUFDdW5DLEtBQXZDLElBQWdEajRFLE9BQU8sQ0FBQ3E1RSxZQUFSLElBQXdCcjVFLE9BQU8sQ0FBQ2t0QixJQUFoRixLQUNDbHRCLE9BQU8sQ0FBQ21xRSxpQkFBUixJQUE2QixJQUE3QixJQUFxQ25xRSxPQUFPLENBQUNtcUUsaUJBQVIsSUFBNkJucUUsT0FBTyxDQUFDbXpELE1BRDNFLENBQUosRUFFRTtVQUFFLE9BQU8sS0FBUDtTQTFDcUM7Ozs7UUE4Q3pDLElBQUl5bUIsV0FBVyxHQUFHbEIsaUJBQWlCLENBQUMzdkIsRUFBRCxDQUFuQzs7UUFDQSxJQUFJNHdCLFFBQVEsR0FBRyxDQUFmLEVBQWtCO1VBQUUzNUUsT0FBTyxDQUFDaXZFLE9BQVIsQ0FBZ0JsdkUsS0FBaEIsQ0FBc0JDLE9BQXRCLEdBQWdDLE1BQWhDOzs7UUFDcEI2NUUsWUFBWSxDQUFDOXdCLEVBQUQsRUFBSy9vRCxPQUFPLENBQUNtcUUsaUJBQWIsRUFBZ0N6NUIsTUFBTSxDQUFDNnRCLElBQXZDLENBQVo7O1FBQ0EsSUFBSW9iLFFBQVEsR0FBRyxDQUFmLEVBQWtCO1VBQUUzNUUsT0FBTyxDQUFDaXZFLE9BQVIsQ0FBZ0JsdkUsS0FBaEIsQ0FBc0JDLE9BQXRCLEdBQWdDLEVBQWhDOzs7UUFDcEJBLE9BQU8sQ0FBQ3E1RSxZQUFSLEdBQXVCcjVFLE9BQU8sQ0FBQ2t0QixJQUEvQixDQWxEeUM7OztRQXFEekM4ckQsZ0JBQWdCLENBQUNZLFdBQUQsQ0FBaEIsQ0FyRHlDOzs7UUF5RHpDeDRCLGNBQWMsQ0FBQ3BoRCxPQUFPLENBQUNvdUUsU0FBVCxDQUFkO1FBQ0FodEIsY0FBYyxDQUFDcGhELE9BQU8sQ0FBQzg1RSxZQUFULENBQWQ7UUFDQTk1RSxPQUFPLENBQUNzaEUsT0FBUixDQUFnQnZoRSxLQUFoQixDQUFzQmkxQyxNQUF0QixHQUErQmgxQyxPQUFPLENBQUN5aEUsS0FBUixDQUFjMWhFLEtBQWQsQ0FBb0JxekUsU0FBcEIsR0FBZ0MsQ0FBL0Q7O1FBRUEsSUFBSW9HLFNBQUosRUFBZTtVQUNieDVFLE9BQU8sQ0FBQ3k1RSxjQUFSLEdBQXlCL29DLE1BQU0sQ0FBQzBuQyxhQUFoQztVQUNBcDRFLE9BQU8sQ0FBQzA1RSxhQUFSLEdBQXdCaHBDLE1BQU0sQ0FBQ3N3QixZQUEvQjtVQUNBaVIsV0FBVyxDQUFDbHBCLEVBQUQsRUFBSyxHQUFMLENBQVg7OztRQUdGL29ELE9BQU8sQ0FBQ21xRSxpQkFBUixHQUE0QixJQUE1QjtRQUVBLE9BQU8sSUFBUDs7O01BR0YsU0FBUzJNLGlCQUFULENBQTJCL3RCLEVBQTNCLEVBQStCclksTUFBL0IsRUFBdUM7UUFDckMsSUFBSTgrQixRQUFRLEdBQUc5K0IsTUFBTSxDQUFDOCtCLFFBQXRCOztRQUVBLEtBQUssSUFBSTlsRSxLQUFLLEdBQUcsSUFBakIsR0FBd0JBLEtBQUssR0FBRyxLQUFoQyxFQUF1QztVQUNyQyxJQUFJLENBQUNBLEtBQUQsSUFBVSxDQUFDcS9DLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBdEIsSUFBc0NweUIsTUFBTSxDQUFDMm5DLGVBQVAsSUFBMEIvVixZQUFZLENBQUN2WixFQUFELENBQWhGLEVBQXNGOztZQUVwRixJQUFJeW1CLFFBQVEsSUFBSUEsUUFBUSxDQUFDbDVCLEdBQVQsSUFBZ0IsSUFBaEMsRUFDRTtjQUFFazVCLFFBQVEsR0FBRztnQkFBQ2w1QixHQUFHLEVBQUVuaEQsSUFBSSxDQUFDc0ksR0FBTCxDQUFTc3JELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT2phLE1BQVAsR0FBZ0I4c0IsV0FBVyxDQUFDL1ksRUFBRSxDQUFDL29ELE9BQUosQ0FBM0IsR0FBMEN5aUUsYUFBYSxDQUFDMVosRUFBRCxDQUFoRSxFQUFzRXltQixRQUFRLENBQUNsNUIsR0FBL0U7ZUFBakI7YUFIZ0Y7Ozs7WUFNcEY1RixNQUFNLENBQUN3bkMsT0FBUCxHQUFpQjNJLFlBQVksQ0FBQ3htQixFQUFFLENBQUMvb0QsT0FBSixFQUFhK29ELEVBQUUsQ0FBQ2tHLEdBQWhCLEVBQXFCdWdCLFFBQXJCLENBQTdCOztZQUNBLElBQUk5K0IsTUFBTSxDQUFDd25DLE9BQVAsQ0FBZXZpRSxJQUFmLElBQXVCb3pDLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdrekQsUUFBbEMsSUFBOEN4aUIsTUFBTSxDQUFDd25DLE9BQVAsQ0FBZS8rRCxFQUFmLElBQXFCNHZDLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBbEYsRUFDRTtjQUFFOztXQVJOLE1BU08sSUFBSXpwRCxLQUFKLEVBQVc7WUFDaEJnbkMsTUFBTSxDQUFDd25DLE9BQVAsR0FBaUIzSSxZQUFZLENBQUN4bUIsRUFBRSxDQUFDL29ELE9BQUosRUFBYStvRCxFQUFFLENBQUNrRyxHQUFoQixFQUFxQnVnQixRQUFyQixDQUE3Qjs7O1VBRUYsSUFBSSxDQUFDK0cscUJBQXFCLENBQUN4dEIsRUFBRCxFQUFLclksTUFBTCxDQUExQixFQUF3QztZQUFFOzs7VUFDMUNxK0IsdUJBQXVCLENBQUNobUIsRUFBRCxDQUF2QjtVQUNBLElBQUl5dEIsVUFBVSxHQUFHaEUsb0JBQW9CLENBQUN6cEIsRUFBRCxDQUFyQztVQUNBa2lCLGVBQWUsQ0FBQ2xpQixFQUFELENBQWY7VUFDQXNyQixnQkFBZ0IsQ0FBQ3RyQixFQUFELEVBQUt5dEIsVUFBTCxDQUFoQjtVQUNBSyxpQkFBaUIsQ0FBQzl0QixFQUFELEVBQUt5dEIsVUFBTCxDQUFqQjtVQUNBOWxDLE1BQU0sQ0FBQ3VuQyxLQUFQLEdBQWUsS0FBZjs7O1FBR0Z2bkMsTUFBTSxDQUFDa1ksTUFBUCxDQUFjRyxFQUFkLEVBQWtCLFFBQWxCLEVBQTRCQSxFQUE1Qjs7UUFDQSxJQUFJQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQVgsSUFBdUJuSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXKzVFLGdCQUFsQyxJQUFzRGh4QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQVgsSUFBcUJwSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXZzZFLGNBQTFGLEVBQTBHO1VBQ3hHdHBDLE1BQU0sQ0FBQ2tZLE1BQVAsQ0FBY0csRUFBZCxFQUFrQixnQkFBbEIsRUFBb0NBLEVBQXBDLEVBQXdDQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQW5ELEVBQTZEbkssRUFBRSxDQUFDL29ELE9BQUgsQ0FBV216RCxNQUF4RTtVQUNBcEssRUFBRSxDQUFDL29ELE9BQUgsQ0FBVys1RSxnQkFBWCxHQUE4Qmh4QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQXpDO1VBQW1EbkssRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2c2RSxjQUFYLEdBQTRCanhCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBdkM7Ozs7TUFJdkQsU0FBUzRlLG1CQUFULENBQTZCaHBCLEVBQTdCLEVBQWlDeW1CLFFBQWpDLEVBQTJDO1FBQ3pDLElBQUk5K0IsTUFBTSxHQUFHLElBQUkybEMsYUFBSixDQUFrQnR0QixFQUFsQixFQUFzQnltQixRQUF0QixDQUFiOztRQUNBLElBQUkrRyxxQkFBcUIsQ0FBQ3h0QixFQUFELEVBQUtyWSxNQUFMLENBQXpCLEVBQXVDO1VBQ3JDcStCLHVCQUF1QixDQUFDaG1CLEVBQUQsQ0FBdkI7VUFDQSt0QixpQkFBaUIsQ0FBQy90QixFQUFELEVBQUtyWSxNQUFMLENBQWpCO1VBQ0EsSUFBSThsQyxVQUFVLEdBQUdoRSxvQkFBb0IsQ0FBQ3pwQixFQUFELENBQXJDO1VBQ0FraUIsZUFBZSxDQUFDbGlCLEVBQUQsQ0FBZjtVQUNBc3JCLGdCQUFnQixDQUFDdHJCLEVBQUQsRUFBS3l0QixVQUFMLENBQWhCO1VBQ0FLLGlCQUFpQixDQUFDOXRCLEVBQUQsRUFBS3l0QixVQUFMLENBQWpCO1VBQ0E5bEMsTUFBTSxDQUFDblAsTUFBUDs7T0FubUllOzs7Ozs7TUEybUluQixTQUFTczRDLFlBQVQsQ0FBc0I5d0IsRUFBdEIsRUFBMEJreEIsaUJBQTFCLEVBQTZDMWIsSUFBN0MsRUFBbUQ7UUFDakQsSUFBSXYrRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1lBQTBCNi9ELFdBQVcsR0FBRzlXLEVBQUUsQ0FBQ2psQixPQUFILENBQVcrN0IsV0FBbkQ7UUFDQSxJQUFJaDhCLFNBQVMsR0FBRzdqQyxPQUFPLENBQUNpdkUsT0FBeEI7WUFBaUNqcEIsR0FBRyxHQUFHbmlCLFNBQVMsQ0FBQzRCLFVBQWpEOztRQUVBLFNBQVN5MEMsRUFBVCxDQUFZbjNELElBQVosRUFBa0I7VUFDaEIsSUFBSWxULElBQUksR0FBR2tULElBQUksQ0FBQ3lsQixXQUFoQixDQURnQjs7VUFHaEIsSUFBSW9YLE1BQU0sSUFBSVksR0FBVixJQUFpQnVJLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtNkUsa0JBQVgsSUFBaUNwM0QsSUFBdEQsRUFDRTtZQUFFQSxJQUFJLENBQUNoakIsS0FBTCxDQUFXQyxPQUFYLEdBQXFCLE1BQXJCO1dBREosTUFHRTtZQUFFK2lCLElBQUksQ0FBQ2lsQixVQUFMLENBQWdCcm1CLFdBQWhCLENBQTRCb0IsSUFBNUI7OztVQUNKLE9BQU9sVCxJQUFQOzs7UUFHRixJQUFJcWQsSUFBSSxHQUFHbHRCLE9BQU8sQ0FBQ2t0QixJQUFuQjtZQUF5QjJyQyxLQUFLLEdBQUc3NEQsT0FBTyxDQUFDa3pELFFBQXpDLENBZGlEOzs7UUFpQmpELEtBQUssSUFBSXQzRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc3hCLElBQUksQ0FBQzF6QixNQUF6QixFQUFpQ29DLENBQUMsRUFBbEMsRUFBc0M7VUFDcEMsSUFBSXkrRCxRQUFRLEdBQUdudEMsSUFBSSxDQUFDdHhCLENBQUQsQ0FBbkI7VUFDQSxJQUFJeStELFFBQVEsQ0FBQytDLE1BQWIsRUFBcUIsQ0FBckIsS0FBNEIsSUFBSSxDQUFDL0MsUUFBUSxDQUFDdDNDLElBQVYsSUFBa0JzM0MsUUFBUSxDQUFDdDNDLElBQVQsQ0FBY2lsQixVQUFkLElBQTRCbkUsU0FBbEQsRUFBNkQ7O1lBQ3ZGLElBQUk5Z0IsSUFBSSxHQUFHeTlDLGdCQUFnQixDQUFDelgsRUFBRCxFQUFLc1IsUUFBTCxFQUFleEIsS0FBZixFQUFzQjBGLElBQXRCLENBQTNCO1lBQ0ExNkIsU0FBUyxDQUFDUSxZQUFWLENBQXVCdGhCLElBQXZCLEVBQTZCaWpDLEdBQTdCO1dBRjBCLE1BR3JCOztZQUNMLE9BQU9BLEdBQUcsSUFBSXFVLFFBQVEsQ0FBQ3QzQyxJQUF2QixFQUE2QjtjQUFFaWpDLEdBQUcsR0FBR2swQixFQUFFLENBQUNsMEIsR0FBRCxDQUFSOzs7WUFDL0IsSUFBSW8wQixZQUFZLEdBQUd2YSxXQUFXLElBQUlvYSxpQkFBaUIsSUFBSSxJQUFwQyxJQUNqQkEsaUJBQWlCLElBQUlwaEIsS0FESixJQUNhd0IsUUFBUSxDQUFDMkYsVUFEekM7O1lBRUEsSUFBSTNGLFFBQVEsQ0FBQ21FLE9BQWIsRUFBc0I7Y0FDcEIsSUFBSS9yRCxPQUFPLENBQUM0bkQsUUFBUSxDQUFDbUUsT0FBVixFQUFtQixRQUFuQixDQUFQLEdBQXNDLENBQUMsQ0FBM0MsRUFBOEM7Z0JBQUU0YixZQUFZLEdBQUcsS0FBZjs7O2NBQ2hEOWIsb0JBQW9CLENBQUN2VixFQUFELEVBQUtzUixRQUFMLEVBQWV4QixLQUFmLEVBQXNCMEYsSUFBdEIsQ0FBcEI7OztZQUVGLElBQUk2YixZQUFKLEVBQWtCO2NBQ2hCaDVCLGNBQWMsQ0FBQ2laLFFBQVEsQ0FBQzJGLFVBQVYsQ0FBZDtjQUNBM0YsUUFBUSxDQUFDMkYsVUFBVCxDQUFvQi8vRCxXQUFwQixDQUFnQzFKLFFBQVEsQ0FBQ3lzQixjQUFULENBQXdCaXRDLGFBQWEsQ0FBQ2xILEVBQUUsQ0FBQ2psQixPQUFKLEVBQWErMEIsS0FBYixDQUFyQyxDQUFoQzs7O1lBRUY3UyxHQUFHLEdBQUdxVSxRQUFRLENBQUN0M0MsSUFBVCxDQUFjeWxCLFdBQXBCOztVQUVGcXdCLEtBQUssSUFBSXdCLFFBQVEsQ0FBQzNtRCxJQUFsQjs7O1FBRUYsT0FBT3N5QyxHQUFQLEVBQVk7VUFBRUEsR0FBRyxHQUFHazBCLEVBQUUsQ0FBQ2wwQixHQUFELENBQVI7Ozs7TUFHaEIsU0FBU3EwQixpQkFBVCxDQUEyQnI2RSxPQUEzQixFQUFvQztRQUNsQyxJQUFJODBDLEtBQUssR0FBRzkwQyxPQUFPLENBQUNzaEUsT0FBUixDQUFnQjdXLFdBQTVCO1FBQ0F6cUQsT0FBTyxDQUFDeWhFLEtBQVIsQ0FBYzFoRSxLQUFkLENBQW9Cb2hFLFVBQXBCLEdBQWlDcnNCLEtBQUssR0FBRyxJQUF6QyxDQUZrQzs7UUFJbENxcEIsV0FBVyxDQUFDbitELE9BQUQsRUFBVSxlQUFWLEVBQTJCQSxPQUEzQixDQUFYOzs7TUFHRixTQUFTNjJFLGlCQUFULENBQTJCOXRCLEVBQTNCLEVBQStCd0IsT0FBL0IsRUFBd0M7UUFDdEN4QixFQUFFLENBQUMvb0QsT0FBSCxDQUFXeWhFLEtBQVgsQ0FBaUIxaEUsS0FBakIsQ0FBdUJxekUsU0FBdkIsR0FBbUM3b0IsT0FBTyxDQUFDdW9CLFNBQVIsR0FBb0IsSUFBdkQ7UUFDQS9wQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXMjBFLFlBQVgsQ0FBd0I1MEUsS0FBeEIsQ0FBOEJ1MkMsR0FBOUIsR0FBb0NpVSxPQUFPLENBQUN1b0IsU0FBUixHQUFvQixJQUF4RDtRQUNBL3BCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdzaEUsT0FBWCxDQUFtQnZoRSxLQUFuQixDQUF5QmkxQyxNQUF6QixHQUFtQ3VWLE9BQU8sQ0FBQ3VvQixTQUFSLEdBQW9CL3BCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVcyaUUsU0FBL0IsR0FBMkNQLFNBQVMsQ0FBQ3JaLEVBQUQsQ0FBckQsR0FBNkQsSUFBL0Y7T0E5cElpQjs7OztNQW1xSW5CLFNBQVN3cEIsaUJBQVQsQ0FBMkJ4cEIsRUFBM0IsRUFBK0I7UUFDN0IsSUFBSS9vRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQWpCO1lBQTBCa3RCLElBQUksR0FBR2x0QixPQUFPLENBQUNrdEIsSUFBekM7O1FBQ0EsSUFBSSxDQUFDbHRCLE9BQU8sQ0FBQ3M2RSxZQUFULEtBQTBCLENBQUN0NkUsT0FBTyxDQUFDc2hFLE9BQVIsQ0FBZ0I3N0IsVUFBakIsSUFBK0IsQ0FBQ3NqQixFQUFFLENBQUNqbEIsT0FBSCxDQUFXMjdCLFdBQXJFLENBQUosRUFBdUY7VUFBRTs7O1FBQ3pGLElBQUk4YSxJQUFJLEdBQUdqUixvQkFBb0IsQ0FBQ3RwRSxPQUFELENBQXBCLEdBQWdDQSxPQUFPLENBQUN1aUUsUUFBUixDQUFpQjZELFVBQWpELEdBQThEcmQsRUFBRSxDQUFDa0csR0FBSCxDQUFPbVgsVUFBaEY7UUFDQSxJQUFJcU0sT0FBTyxHQUFHenlFLE9BQU8sQ0FBQ3NoRSxPQUFSLENBQWdCN1csV0FBOUI7WUFBMkMveEIsSUFBSSxHQUFHNmhELElBQUksR0FBRyxJQUF6RDs7UUFDQSxLQUFLLElBQUkzK0UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3N4QixJQUFJLENBQUMxekIsTUFBekIsRUFBaUNvQyxDQUFDLEVBQWxDLEVBQXNDO1VBQUUsSUFBSSxDQUFDc3hCLElBQUksQ0FBQ3R4QixDQUFELENBQUosQ0FBUXdoRSxNQUFiLEVBQXFCO1lBQzNELElBQUlyVSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXMjdCLFdBQWYsRUFBNEI7Y0FDMUIsSUFBSXZ5QyxJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVEwakUsTUFBWixFQUNFO2dCQUFFcHlDLElBQUksQ0FBQ3R4QixDQUFELENBQUosQ0FBUTBqRSxNQUFSLENBQWV2L0QsS0FBZixDQUFxQjI0QixJQUFyQixHQUE0QkEsSUFBNUI7OztjQUNKLElBQUl4TCxJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVEyakUsZ0JBQVosRUFDRTtnQkFBRXJ5QyxJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVEyakUsZ0JBQVIsQ0FBeUJ4L0QsS0FBekIsQ0FBK0IyNEIsSUFBL0IsR0FBc0NBLElBQXRDOzs7O1lBRU4sSUFBSThoRCxLQUFLLEdBQUd0dEQsSUFBSSxDQUFDdHhCLENBQUQsQ0FBSixDQUFReWtFLFNBQXBCOztZQUNBLElBQUltYSxLQUFKLEVBQVc7Y0FBRSxLQUFLLElBQUk1MkUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzQyRSxLQUFLLENBQUNoaEYsTUFBMUIsRUFBa0NvSyxDQUFDLEVBQW5DLEVBQ1g7Z0JBQUU0MkUsS0FBSyxDQUFDNTJFLENBQUQsQ0FBTCxDQUFTN0QsS0FBVCxDQUFlMjRCLElBQWYsR0FBc0JBLElBQXRCOzs7Ozs7UUFFTixJQUFJcXdCLEVBQUUsQ0FBQ2psQixPQUFILENBQVcyN0IsV0FBZixFQUNFO1VBQUV6L0QsT0FBTyxDQUFDc2hFLE9BQVIsQ0FBZ0J2aEUsS0FBaEIsQ0FBc0IyNEIsSUFBdEIsR0FBOEI2aEQsSUFBSSxHQUFHOUgsT0FBUixHQUFtQixJQUFoRDs7T0FwcklhOzs7OztNQTBySW5CLFNBQVM2RywwQkFBVCxDQUFvQ3Z3QixFQUFwQyxFQUF3QztRQUN0QyxJQUFJLENBQUNBLEVBQUUsQ0FBQ2psQixPQUFILENBQVcrN0IsV0FBaEIsRUFBNkI7VUFBRSxPQUFPLEtBQVA7OztRQUMvQixJQUFJNVEsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjtZQUFrQjVzQyxJQUFJLEdBQUc0dEMsYUFBYSxDQUFDbEgsRUFBRSxDQUFDamxCLE9BQUosRUFBYW1yQixHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUFoQixHQUF1QixDQUFwQyxDQUF0QztZQUE4RTFULE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBM0Y7O1FBQ0EsSUFBSXFpQixJQUFJLENBQUM3b0IsTUFBTCxJQUFld0csT0FBTyxDQUFDaW1FLFlBQTNCLEVBQXlDO1VBQ3ZDLElBQUk3L0QsSUFBSSxHQUFHcEcsT0FBTyxDQUFDdXFELE9BQVIsQ0FBZ0J0cUQsV0FBaEIsQ0FBNEJxaEQsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDQSxHQUFHLENBQUMsS0FBRCxFQUFRai9CLElBQVIsQ0FBSixDQUFSLEVBQ0MsNkNBREQsQ0FBL0IsQ0FBWDtVQUVBLElBQUlvNEQsTUFBTSxHQUFHcjBFLElBQUksQ0FBQ3EvQixVQUFMLENBQWdCZ2xCLFdBQTdCO2NBQTBDblMsT0FBTyxHQUFHbHlDLElBQUksQ0FBQ3FrRCxXQUFMLEdBQW1CZ3dCLE1BQXZFO1VBQ0F6NkUsT0FBTyxDQUFDMDZFLFVBQVIsQ0FBbUIzNkUsS0FBbkIsQ0FBeUIrMEMsS0FBekIsR0FBaUMsRUFBakM7VUFDQTkwQyxPQUFPLENBQUNrZ0UsaUJBQVIsR0FBNEIvcUUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTODhFLE1BQVQsRUFBaUJ6NkUsT0FBTyxDQUFDMDZFLFVBQVIsQ0FBbUJqd0IsV0FBbkIsR0FBaUNuUyxPQUFsRCxJQUE2RCxDQUF6RjtVQUNBdDRDLE9BQU8sQ0FBQzI2RSxZQUFSLEdBQXVCMzZFLE9BQU8sQ0FBQ2tnRSxpQkFBUixHQUE0QjVuQixPQUFuRDtVQUNBdDRDLE9BQU8sQ0FBQ2ltRSxZQUFSLEdBQXVCam1FLE9BQU8sQ0FBQ2tnRSxpQkFBUixHQUE0Qjc5QyxJQUFJLENBQUM3b0IsTUFBakMsR0FBMEMsQ0FBQyxDQUFsRTtVQUNBd0csT0FBTyxDQUFDMDZFLFVBQVIsQ0FBbUIzNkUsS0FBbkIsQ0FBeUIrMEMsS0FBekIsR0FBaUM5MEMsT0FBTyxDQUFDMjZFLFlBQVIsR0FBdUIsSUFBeEQ7VUFDQU4saUJBQWlCLENBQUN0eEIsRUFBRSxDQUFDL29ELE9BQUosQ0FBakI7VUFDQSxPQUFPLElBQVA7OztRQUVGLE9BQU8sS0FBUDs7O01BR0YsU0FBUzQ2RSxVQUFULENBQW9CdFosT0FBcEIsRUFBNkJ6QixXQUE3QixFQUEwQztRQUN4QyxJQUFJcmhFLE1BQU0sR0FBRyxFQUFiO1lBQWlCcThFLGNBQWMsR0FBRyxLQUFsQzs7UUFDQSxLQUFLLElBQUlqL0UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBsRSxPQUFPLENBQUM5bkUsTUFBNUIsRUFBb0NvQyxDQUFDLEVBQXJDLEVBQXlDO1VBQ3ZDLElBQUkzQixJQUFJLEdBQUdxbkUsT0FBTyxDQUFDMWxFLENBQUQsQ0FBbEI7Y0FBdUJtRSxLQUFLLEdBQUcsSUFBL0I7O1VBQ0EsSUFBSSxPQUFPOUYsSUFBUCxJQUFlLFFBQW5CLEVBQTZCO1lBQUU4RixLQUFLLEdBQUc5RixJQUFJLENBQUM4RixLQUFiO1lBQW9COUYsSUFBSSxHQUFHQSxJQUFJLENBQUNpbkQsU0FBWjs7O1VBQ25ELElBQUlqbkQsSUFBSSxJQUFJLHdCQUFaLEVBQXNDO1lBQ3BDLElBQUksQ0FBQzRsRSxXQUFMLEVBQWtCO2NBQUU7YUFBcEIsTUFDSztjQUFFZ2IsY0FBYyxHQUFHLElBQWpCOzs7O1VBRVRyOEUsTUFBTSxDQUFDakcsSUFBUCxDQUFZO1lBQUMyb0QsU0FBUyxFQUFFam5ELElBQVo7WUFBa0I4RixLQUFLLEVBQUVBO1dBQXJDOzs7UUFFRixJQUFJOC9ELFdBQVcsSUFBSSxDQUFDZ2IsY0FBcEIsRUFBb0M7VUFBRXI4RSxNQUFNLENBQUNqRyxJQUFQLENBQVk7WUFBQzJvRCxTQUFTLEVBQUUsd0JBQVo7WUFBc0NuaEQsS0FBSyxFQUFFO1dBQXpEOzs7UUFDdEMsT0FBT3ZCLE1BQVA7T0F4dElpQjs7OztNQTZ0SW5CLFNBQVNzOEUsYUFBVCxDQUF1Qjk2RSxPQUF2QixFQUFnQztRQUM5QixJQUFJc2hFLE9BQU8sR0FBR3RoRSxPQUFPLENBQUNzaEUsT0FBdEI7WUFBK0J5WixLQUFLLEdBQUcvNkUsT0FBTyxDQUFDbWdFLFdBQS9DO1FBQ0EvZSxjQUFjLENBQUNrZ0IsT0FBRCxDQUFkO1FBQ0F0aEUsT0FBTyxDQUFDMDZFLFVBQVIsR0FBcUIsSUFBckI7O1FBQ0EsS0FBSyxJQUFJOStFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtL0UsS0FBSyxDQUFDdmhGLE1BQTFCLEVBQWtDLEVBQUVvQyxDQUFwQyxFQUF1QztVQUNyQyxJQUFJNHRDLEdBQUcsR0FBR3V4QyxLQUFLLENBQUNuL0UsQ0FBRCxDQUFmO1VBQ0EsSUFBSXNsRCxTQUFTLEdBQUcxWCxHQUFHLENBQUMwWCxTQUFwQjtVQUNBLElBQUluaEQsS0FBSyxHQUFHeXBDLEdBQUcsQ0FBQ3pwQyxLQUFoQjtVQUNBLElBQUlpN0UsSUFBSSxHQUFHMVosT0FBTyxDQUFDcmhFLFdBQVIsQ0FBb0JxaEQsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsdUJBQXVCSixTQUFyQyxDQUF2QixDQUFYOztVQUNBLElBQUluaEQsS0FBSixFQUFXO1lBQUVpN0UsSUFBSSxDQUFDajdFLEtBQUwsQ0FBVzRyQyxPQUFYLEdBQXFCNXJDLEtBQXJCOzs7VUFDYixJQUFJbWhELFNBQVMsSUFBSSx3QkFBakIsRUFBMkM7WUFDekNsaEQsT0FBTyxDQUFDMDZFLFVBQVIsR0FBcUJNLElBQXJCO1lBQ0FBLElBQUksQ0FBQ2o3RSxLQUFMLENBQVcrMEMsS0FBWCxHQUFtQixDQUFDOTBDLE9BQU8sQ0FBQzI2RSxZQUFSLElBQXdCLENBQXpCLElBQThCLElBQWpEOzs7O1FBR0pyWixPQUFPLENBQUN2aEUsS0FBUixDQUFjQyxPQUFkLEdBQXdCKzZFLEtBQUssQ0FBQ3ZoRixNQUFOLEdBQWUsRUFBZixHQUFvQixNQUE1QztRQUNBNmdGLGlCQUFpQixDQUFDcjZFLE9BQUQsQ0FBakI7OztNQUdGLFNBQVNpN0UsYUFBVCxDQUF1Qmx5QixFQUF2QixFQUEyQjtRQUN6Qit4QixhQUFhLENBQUMveEIsRUFBRSxDQUFDL29ELE9BQUosQ0FBYjtRQUNBaXFFLFNBQVMsQ0FBQ2xoQixFQUFELENBQVQ7UUFDQXdwQixpQkFBaUIsQ0FBQ3hwQixFQUFELENBQWpCO09BbnZJaUI7Ozs7O01BMHZJbkIsU0FBU215QixPQUFULENBQWlCclcsS0FBakIsRUFBd0I1VixHQUF4QixFQUE2QnNOLEtBQTdCLEVBQW9DejRCLE9BQXBDLEVBQTZDO1FBQzNDLElBQUludkIsQ0FBQyxHQUFHLElBQVI7UUFDQSxLQUFLNG5ELEtBQUwsR0FBYUEsS0FBYixDQUYyQzs7UUFLM0M1bkQsQ0FBQyxDQUFDa2dFLGVBQUYsR0FBb0J2ekIsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsNkJBQWQsQ0FBdkI7UUFDQTNzQyxDQUFDLENBQUNrZ0UsZUFBRixDQUFrQnpxQyxZQUFsQixDQUErQixnQkFBL0IsRUFBaUQsTUFBakQsRUFOMkM7OztRQVMzQ3oxQixDQUFDLENBQUNvZ0UsWUFBRixHQUFpQnp6QixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYywwQkFBZCxDQUFwQjtRQUNBM3NDLENBQUMsQ0FBQ29nRSxZQUFGLENBQWUzcUMsWUFBZixDQUE0QixnQkFBNUIsRUFBOEMsTUFBOUMsRUFWMkM7O1FBWTNDejFCLENBQUMsQ0FBQ3M2RCxPQUFGLEdBQVkxdEIsSUFBSSxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsaUJBQWQsQ0FBaEIsQ0FaMkM7O1FBYzNDNXNDLENBQUMsQ0FBQ21sRSxZQUFGLEdBQWlCeDRCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsZ0NBQXBCLENBQXBCO1FBQ0Ezc0MsQ0FBQyxDQUFDeTVELFNBQUYsR0FBYzlzQixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxvQkFBZCxDQUFqQixDQWYyQzs7UUFpQjNDM3NDLENBQUMsQ0FBQzQxQyxPQUFGLEdBQVlqSixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxvQkFBZCxDQUFmLENBakIyQzs7UUFtQjNDM3NDLENBQUMsQ0FBQzJ1RCxXQUFGLEdBQWdCaGlCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLG9CQUFkLENBQW5CLENBbkIyQzs7UUFxQjNDM3NDLENBQUMsQ0FBQ2l0RCxTQUFGLEdBQWNyZ0IsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDNXNDLENBQUMsQ0FBQzQxQyxPQUFILEVBQVk1MUMsQ0FBQyxDQUFDMnVELFdBQWQsRUFBMkIzdUQsQ0FBQyxDQUFDbWxFLFlBQTdCLEVBQTJDbmxFLENBQUMsQ0FBQ3k1RCxTQUE3QyxFQUF3RHo1RCxDQUFDLENBQUNzNkQsT0FBMUQsQ0FBUixFQUNBLElBREEsRUFDTSxtQ0FETixDQUFsQjtRQUVBLElBQUk5ZixLQUFLLEdBQUc1TixJQUFJLENBQUMsS0FBRCxFQUFRLENBQUM1c0MsQ0FBQyxDQUFDaXRELFNBQUgsQ0FBUixFQUF1QixrQkFBdkIsQ0FBaEIsQ0F2QjJDOztRQXlCM0NqdEQsQ0FBQyxDQUFDK3NELEtBQUYsR0FBVXBnQixHQUFHLENBQUMsS0FBRCxFQUFRLENBQUM2TixLQUFELENBQVIsRUFBaUIsSUFBakIsRUFBdUIsb0JBQXZCLENBQWIsQ0F6QjJDOztRQTJCM0N4NkMsQ0FBQyxDQUFDOHNELEtBQUYsR0FBVW5nQixHQUFHLENBQUMsS0FBRCxFQUFRLENBQUMzc0MsQ0FBQyxDQUFDK3NELEtBQUgsQ0FBUixFQUFtQixrQkFBbkIsQ0FBYjtRQUNBL3NELENBQUMsQ0FBQzIzRCxVQUFGLEdBQWUsSUFBZixDQTVCMkM7Ozs7UUFnQzNDMzNELENBQUMsQ0FBQ2dnRSxZQUFGLEdBQWlCcnpCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsaUNBQWlDbUMsV0FBakMsR0FBK0MsaUJBQW5FLENBQXBCLENBaEMyQzs7UUFrQzNDOXVDLENBQUMsQ0FBQzJzRCxPQUFGLEdBQVloZ0IsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsb0JBQWQsQ0FBZjtRQUNBM3NDLENBQUMsQ0FBQytsRSxVQUFGLEdBQWUsSUFBZixDQW5DMkM7O1FBcUMzQy9sRSxDQUFDLENBQUM0dEQsUUFBRixHQUFhamhCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQzNzQyxDQUFDLENBQUM4c0QsS0FBSCxFQUFVOXNELENBQUMsQ0FBQ2dnRSxZQUFaLEVBQTBCaGdFLENBQUMsQ0FBQzJzRCxPQUE1QixDQUFSLEVBQThDLG1CQUE5QyxDQUFoQjtRQUNBM3NELENBQUMsQ0FBQzR0RCxRQUFGLENBQVduNEIsWUFBWCxDQUF3QixVQUF4QixFQUFvQyxJQUFwQyxFQXRDMkM7O1FBd0MzQ3oxQixDQUFDLENBQUM4UixPQUFGLEdBQVk2NkIsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDM3NDLENBQUMsQ0FBQ2tnRSxlQUFILEVBQW9CbGdFLENBQUMsQ0FBQ29nRSxZQUF0QixFQUFvQ3BnRSxDQUFDLENBQUM0dEQsUUFBdEMsQ0FBUixFQUF5RCxZQUF6RCxDQUFmLENBeEMyQzs7O1FBNEMzQzV0RCxDQUFDLENBQUM4UixPQUFGLENBQVUyakIsWUFBVixDQUF1QixXQUF2QixFQUFvQyxJQUFwQyxFQTVDMkM7O1FBK0MzQyxJQUFJcVYsRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBdkIsRUFBMEI7VUFBRS9xQyxDQUFDLENBQUMyc0QsT0FBRixDQUFVdmhFLEtBQVYsQ0FBZ0JnL0QsTUFBaEIsR0FBeUIsQ0FBQyxDQUExQjtVQUE2QnBxRCxDQUFDLENBQUM0dEQsUUFBRixDQUFXeGlFLEtBQVgsQ0FBaUJvaUUsWUFBakIsR0FBZ0MsQ0FBaEM7OztRQUN6RCxJQUFJLENBQUN2aUIsTUFBRCxJQUFXLEVBQUVQLEtBQUssSUFBSWtCLE1BQVgsQ0FBZixFQUFtQztVQUFFNXJDLENBQUMsQ0FBQzR0RCxRQUFGLENBQVc0WSxTQUFYLEdBQXVCLElBQXZCOzs7UUFFckMsSUFBSXRXLEtBQUosRUFBVztVQUNULElBQUlBLEtBQUssQ0FBQzVrRSxXQUFWLEVBQXVCO1lBQUU0a0UsS0FBSyxDQUFDNWtFLFdBQU4sQ0FBa0IwVSxDQUFDLENBQUM4UixPQUFwQjtXQUF6QixNQUNLO1lBQUVvK0MsS0FBSyxDQUFDbHdELENBQUMsQ0FBQzhSLE9BQUgsQ0FBTDs7U0FwRGtDOzs7UUF3RDNDOVIsQ0FBQyxDQUFDdStDLFFBQUYsR0FBYXYrQyxDQUFDLENBQUN3K0MsTUFBRixHQUFXbEUsR0FBRyxDQUFDdmxELEtBQTVCO1FBQ0FpTCxDQUFDLENBQUNvbEUsZ0JBQUYsR0FBcUJwbEUsQ0FBQyxDQUFDcWxFLGNBQUYsR0FBbUIvcUIsR0FBRyxDQUFDdmxELEtBQTVDLENBekQyQzs7UUEyRDNDaUwsQ0FBQyxDQUFDdVksSUFBRixHQUFTLEVBQVQ7UUFDQXZZLENBQUMsQ0FBQzBrRSxZQUFGLEdBQWlCLElBQWpCLENBNUQyQzs7O1FBK0QzQzFrRSxDQUFDLENBQUNxbUQsZ0JBQUYsR0FBcUIsSUFBckIsQ0EvRDJDOztRQWlFM0NybUQsQ0FBQyxDQUFDa3lELFVBQUYsR0FBZSxDQUFmO1FBQ0FseUQsQ0FBQyxDQUFDOGtFLGNBQUYsR0FBbUI5a0UsQ0FBQyxDQUFDK2tFLGFBQUYsR0FBa0IsQ0FBckM7UUFDQS9rRSxDQUFDLENBQUN3MUQsaUJBQUYsR0FBc0IsSUFBdEI7UUFFQXgxRCxDQUFDLENBQUMwdEQsY0FBRixHQUFtQjF0RCxDQUFDLENBQUNndUQsU0FBRixHQUFjaHVELENBQUMsQ0FBQzZ0RCxRQUFGLEdBQWEsQ0FBOUM7UUFDQTd0RCxDQUFDLENBQUM0akUsaUJBQUYsR0FBc0IsS0FBdEIsQ0F0RTJDOzs7UUEwRTNDNWpFLENBQUMsQ0FBQ2dtRSxZQUFGLEdBQWlCaG1FLENBQUMsQ0FBQ3VyRCxpQkFBRixHQUFzQnZyRCxDQUFDLENBQUNzeEQsWUFBRixHQUFpQixJQUF4RCxDQTFFMkM7Ozs7UUE4RTNDdHhELENBQUMsQ0FBQzJsRSxZQUFGLEdBQWlCLEtBQWpCO1FBRUEzbEUsQ0FBQyxDQUFDb3hELGVBQUYsR0FBb0JweEQsQ0FBQyxDQUFDcXhELGdCQUFGLEdBQXFCcnhELENBQUMsQ0FBQ3F0RCxjQUFGLEdBQW1CLElBQTVELENBaEYyQzs7O1FBb0YzQ3J0RCxDQUFDLENBQUM2a0QsT0FBRixHQUFZLElBQVo7UUFDQTdrRCxDQUFDLENBQUM4a0QsYUFBRixHQUFrQixDQUFsQjtRQUNBOWtELENBQUMsQ0FBQytrRCxjQUFGLEdBQW1CLEtBQW5CLENBdEYyQzs7UUF5RjNDL2tELENBQUMsQ0FBQ3ltRSxPQUFGLEdBQVl6bUUsQ0FBQyxDQUFDMG1FLE9BQUYsR0FBWTFtRSxDQUFDLENBQUNvaUUsV0FBRixHQUFnQnBpRSxDQUFDLENBQUNxaUUsV0FBRixHQUFnQixJQUF4RCxDQXpGMkM7O1FBNEYzQ3JpRSxDQUFDLENBQUNtNkQsS0FBRixHQUFVLEtBQVYsQ0E1RjJDOzs7UUFnRzNDbjZELENBQUMsQ0FBQ2k2RCxpQkFBRixHQUFzQixJQUF0QjtRQUVBajZELENBQUMsQ0FBQzJtRSxXQUFGLEdBQWdCLElBQWhCO1FBRUEzbUUsQ0FBQyxDQUFDd3JELFdBQUYsR0FBZ0J5YSxVQUFVLENBQUM5MkMsT0FBTyxDQUFDdzlCLE9BQVQsRUFBa0J4OUIsT0FBTyxDQUFDKzdCLFdBQTFCLENBQTFCO1FBQ0FpYixhQUFhLENBQUNubUUsQ0FBRCxDQUFiO1FBRUE0bkQsS0FBSyxDQUFDN21DLElBQU4sQ0FBVy9nQixDQUFYO09BajJJaUI7Ozs7Ozs7Ozs7OztNQSsySW5CLElBQUk0bUUsWUFBWSxHQUFHLENBQW5CO1VBQXNCQyxrQkFBa0IsR0FBRyxJQUEzQyxDQS8ySW1COzs7OztNQW8zSW5CLElBQUkvN0IsRUFBSixFQUFRO1FBQUUrN0Isa0JBQWtCLEdBQUcsQ0FBQyxHQUF0QjtPQUFWLE1BQ0ssSUFBSW44QixLQUFKLEVBQVc7UUFBRW04QixrQkFBa0IsR0FBRyxFQUFyQjtPQUFiLE1BQ0EsSUFBSTE3QixNQUFKLEVBQVk7UUFBRTA3QixrQkFBa0IsR0FBRyxDQUFDLEVBQXRCO09BQWQsTUFDQSxJQUFJeDdCLE1BQUosRUFBWTtRQUFFdzdCLGtCQUFrQixHQUFHLENBQUMsQ0FBRCxHQUFHLENBQXhCOzs7TUFFbkIsU0FBU0MsZUFBVCxDQUF5QjdsRixDQUF6QixFQUE0QjtRQUMxQixJQUFJdWhELEVBQUUsR0FBR3ZoRCxDQUFDLENBQUM4bEYsV0FBWDtZQUF3QnRrQyxFQUFFLEdBQUd4aEQsQ0FBQyxDQUFDK2xGLFdBQS9COztRQUNBLElBQUl4a0MsRUFBRSxJQUFJLElBQU4sSUFBY3ZoRCxDQUFDLENBQUM2L0MsTUFBaEIsSUFBMEI3L0MsQ0FBQyxDQUFDdS9FLElBQUYsSUFBVXYvRSxDQUFDLENBQUNnbUYsZUFBMUMsRUFBMkQ7VUFBRXprQyxFQUFFLEdBQUd2aEQsQ0FBQyxDQUFDNi9DLE1BQVA7OztRQUM3RCxJQUFJMkIsRUFBRSxJQUFJLElBQU4sSUFBY3hoRCxDQUFDLENBQUM2L0MsTUFBaEIsSUFBMEI3L0MsQ0FBQyxDQUFDdS9FLElBQUYsSUFBVXYvRSxDQUFDLENBQUNpbUYsYUFBMUMsRUFBeUQ7VUFBRXprQyxFQUFFLEdBQUd4aEQsQ0FBQyxDQUFDNi9DLE1BQVA7U0FBM0QsTUFDSyxJQUFJMkIsRUFBRSxJQUFJLElBQVYsRUFBZ0I7VUFBRUEsRUFBRSxHQUFHeGhELENBQUMsQ0FBQ2ttRixVQUFQOzs7UUFDdkIsT0FBTztVQUFDLzFFLENBQUMsRUFBRW94QyxFQUFKO1VBQVFueEMsQ0FBQyxFQUFFb3hDO1NBQWxCOzs7TUFFRixTQUFTMmtDLGdCQUFULENBQTBCbm1GLENBQTFCLEVBQTZCO1FBQzNCLElBQUlvbUYsS0FBSyxHQUFHUCxlQUFlLENBQUM3bEYsQ0FBRCxDQUEzQjtRQUNBb21GLEtBQUssQ0FBQ2oyRSxDQUFOLElBQVd5MUUsa0JBQVg7UUFDQVEsS0FBSyxDQUFDaDJFLENBQU4sSUFBV3cxRSxrQkFBWDtRQUNBLE9BQU9RLEtBQVA7OztNQUdGLFNBQVNDLGFBQVQsQ0FBdUJsekIsRUFBdkIsRUFBMkJuekQsQ0FBM0IsRUFBOEI7UUFDNUIsSUFBSW9tRixLQUFLLEdBQUdQLGVBQWUsQ0FBQzdsRixDQUFELENBQTNCO1lBQWdDdWhELEVBQUUsR0FBRzZrQyxLQUFLLENBQUNqMkUsQ0FBM0M7WUFBOENxeEMsRUFBRSxHQUFHNGtDLEtBQUssQ0FBQ2gyRSxDQUF6RDtRQUNBLElBQUlrMkUsYUFBYSxHQUFHVixrQkFBcEI7O1FBQ0EsSUFBSTVsRixDQUFDLENBQUN1bUYsU0FBRixLQUFnQixDQUFwQixFQUF1QjtVQUNyQmhsQyxFQUFFLEdBQUd2aEQsQ0FBQyxDQUFDd21GLE1BQVA7VUFDQWhsQyxFQUFFLEdBQUd4aEQsQ0FBQyxDQUFDeW1GLE1BQVA7VUFDQUgsYUFBYSxHQUFHLENBQWhCOzs7UUFHRixJQUFJbDhFLE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBakI7WUFBMEI0akQsTUFBTSxHQUFHNWpELE9BQU8sQ0FBQ3VpRSxRQUEzQyxDQVQ0Qjs7UUFXNUIsSUFBSStaLFVBQVUsR0FBRzE0QixNQUFNLENBQUMwdUIsV0FBUCxHQUFxQjF1QixNQUFNLENBQUMyZCxXQUE3QztRQUNBLElBQUlnYixVQUFVLEdBQUczNEIsTUFBTSxDQUFDdXVCLFlBQVAsR0FBc0J2dUIsTUFBTSxDQUFDOGUsWUFBOUM7O1FBQ0EsSUFBSSxFQUFFdnJCLEVBQUUsSUFBSW1sQyxVQUFOLElBQW9CbGxDLEVBQUUsSUFBSW1sQyxVQUE1QixDQUFKLEVBQTZDO1VBQUU7U0FibkI7Ozs7OztRQW1CNUIsSUFBSW5sQyxFQUFFLElBQUlvSixHQUFOLElBQWFaLE1BQWpCLEVBQXlCO1VBQ3ZCa1EsS0FBSyxFQUFFLEtBQUssSUFBSTlKLEdBQUcsR0FBR3B3RCxDQUFDLENBQUMrRSxNQUFaLEVBQW9CdXlCLElBQUksR0FBR2x0QixPQUFPLENBQUNrdEIsSUFBeEMsRUFBOEM4NEIsR0FBRyxJQUFJcEMsTUFBckQsRUFBNkRvQyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ2hlLFVBQXZFLEVBQW1GO1lBQ3hGLEtBQUssSUFBSXBzQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc3hCLElBQUksQ0FBQzF6QixNQUF6QixFQUFpQ29DLENBQUMsRUFBbEMsRUFBc0M7Y0FDcEMsSUFBSXN4QixJQUFJLENBQUN0eEIsQ0FBRCxDQUFKLENBQVFtbkIsSUFBUixJQUFnQmlqQyxHQUFwQixFQUF5QjtnQkFDdkIrQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXbTZFLGtCQUFYLEdBQWdDbjBCLEdBQWhDO2dCQUNBLE1BQU04SixLQUFOOzs7O1NBeEJvQjs7Ozs7Ozs7UUFvQzVCLElBQUkzWSxFQUFFLElBQUksQ0FBQ2tJLEtBQVAsSUFBZ0IsQ0FBQ1UsTUFBakIsSUFBMkJtOEIsYUFBYSxJQUFJLElBQWhELEVBQXNEO1VBQ3BELElBQUk5a0MsRUFBRSxJQUFJbWxDLFVBQVYsRUFDRTtZQUFFOUwsZUFBZSxDQUFDMW5CLEVBQUQsRUFBSzV6RCxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZaW1ELE1BQU0sQ0FBQzRpQixTQUFQLEdBQW1CcHZCLEVBQUUsR0FBRzhrQyxhQUFwQyxDQUFMLENBQWY7OztVQUNKeEwsYUFBYSxDQUFDM25CLEVBQUQsRUFBSzV6RCxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZaW1ELE1BQU0sQ0FBQ3dpQixVQUFQLEdBQW9CanZCLEVBQUUsR0FBRytrQyxhQUFyQyxDQUFMLENBQWIsQ0FIb0Q7Ozs7O1VBUXBELElBQUksQ0FBQzlrQyxFQUFELElBQVFBLEVBQUUsSUFBSW1sQyxVQUFsQixFQUNFO1lBQUU3eUIsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoQjs7O1VBQ0pvSyxPQUFPLENBQUMrMkUsV0FBUixHQUFzQixJQUF0QixDQVZvRDs7VUFXcEQ7U0EvQzBCOzs7O1FBb0Q1QixJQUFJMy9CLEVBQUUsSUFBSThrQyxhQUFhLElBQUksSUFBM0IsRUFBaUM7VUFDL0IsSUFBSU0sTUFBTSxHQUFHcGxDLEVBQUUsR0FBRzhrQyxhQUFsQjtVQUNBLElBQUk1bEMsR0FBRyxHQUFHeVMsRUFBRSxDQUFDa0csR0FBSCxDQUFPdVgsU0FBakI7Y0FBNEJ0QixHQUFHLEdBQUc1dUIsR0FBRyxHQUFHdDJDLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCaThDLFlBQXhEOztVQUNBLElBQUk4WixNQUFNLEdBQUcsQ0FBYixFQUFnQjtZQUFFbG1DLEdBQUcsR0FBR25oRCxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZMjRDLEdBQUcsR0FBR2ttQyxNQUFOLEdBQWUsRUFBM0IsQ0FBTjtXQUFsQixNQUNLO1lBQUV0WCxHQUFHLEdBQUcvdkUsSUFBSSxDQUFDc0ksR0FBTCxDQUFTc3JELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT2phLE1BQWhCLEVBQXdCa3dCLEdBQUcsR0FBR3NYLE1BQU4sR0FBZSxFQUF2QyxDQUFOOzs7VUFDUHpLLG1CQUFtQixDQUFDaHBCLEVBQUQsRUFBSztZQUFDelMsR0FBRyxFQUFFQSxHQUFOO1lBQVc2c0IsTUFBTSxFQUFFK0I7V0FBeEIsQ0FBbkI7OztRQUdGLElBQUlxVyxZQUFZLEdBQUcsRUFBZixJQUFxQjNsRixDQUFDLENBQUN1bUYsU0FBRixLQUFnQixDQUF6QyxFQUE0QztVQUMxQyxJQUFJbjhFLE9BQU8sQ0FBQysyRSxXQUFSLElBQXVCLElBQTNCLEVBQWlDO1lBQy9CLzJFLE9BQU8sQ0FBQysyRSxXQUFSLEdBQXNCbnpCLE1BQU0sQ0FBQ3dpQixVQUE3QjtZQUF5Q3BtRSxPQUFPLENBQUNnM0UsV0FBUixHQUFzQnB6QixNQUFNLENBQUM0aUIsU0FBN0I7WUFDekN4bUUsT0FBTyxDQUFDbzdFLE9BQVIsR0FBa0Jqa0MsRUFBbEI7WUFBc0JuM0MsT0FBTyxDQUFDcTdFLE9BQVIsR0FBa0Jqa0MsRUFBbEI7WUFDdEJ4MUIsVUFBVSxDQUFDLFlBQVk7Y0FDckIsSUFBSTVoQixPQUFPLENBQUMrMkUsV0FBUixJQUF1QixJQUEzQixFQUFpQztnQkFBRTs7O2NBQ25DLElBQUkwRixNQUFNLEdBQUc3NEIsTUFBTSxDQUFDd2lCLFVBQVAsR0FBb0JwbUUsT0FBTyxDQUFDKzJFLFdBQXpDO2NBQ0EsSUFBSTJGLE1BQU0sR0FBRzk0QixNQUFNLENBQUM0aUIsU0FBUCxHQUFtQnhtRSxPQUFPLENBQUNnM0UsV0FBeEM7Y0FDQSxJQUFJMkYsTUFBTSxHQUFJRCxNQUFNLElBQUkxOEUsT0FBTyxDQUFDcTdFLE9BQWxCLElBQTZCcUIsTUFBTSxHQUFHMThFLE9BQU8sQ0FBQ3E3RSxPQUEvQyxJQUNWb0IsTUFBTSxJQUFJejhFLE9BQU8sQ0FBQ283RSxPQUFsQixJQUE2QnFCLE1BQU0sR0FBR3o4RSxPQUFPLENBQUNvN0UsT0FEakQ7Y0FFQXA3RSxPQUFPLENBQUMrMkUsV0FBUixHQUFzQi8yRSxPQUFPLENBQUNnM0UsV0FBUixHQUFzQixJQUE1Qzs7Y0FDQSxJQUFJLENBQUMyRixNQUFMLEVBQWE7Z0JBQUU7OztjQUNmbkIsa0JBQWtCLEdBQUcsQ0FBQ0Esa0JBQWtCLEdBQUdELFlBQXJCLEdBQW9Db0IsTUFBckMsS0FBZ0RwQixZQUFZLEdBQUcsQ0FBL0QsQ0FBckI7Y0FDQSxFQUFFQSxZQUFGO2FBVFEsRUFVUCxHQVZPLENBQVY7V0FIRixNQWNPO1lBQ0x2N0UsT0FBTyxDQUFDbzdFLE9BQVIsSUFBbUJqa0MsRUFBbkI7WUFBdUJuM0MsT0FBTyxDQUFDcTdFLE9BQVIsSUFBbUJqa0MsRUFBbkI7OztPQW45SVY7Ozs7Ozs7TUE2OUluQixJQUFJd2xDLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVNuUixNQUFULEVBQWlCQyxTQUFqQixFQUE0QjtRQUMxQyxLQUFLRCxNQUFMLEdBQWNBLE1BQWQ7UUFDQSxLQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtPQUZGOztNQUtBa1IsU0FBUyxDQUFDdGpGLFNBQVYsQ0FBb0I4eEUsT0FBcEIsR0FBOEIsWUFBWTtRQUFFLE9BQU8sS0FBS0ssTUFBTCxDQUFZLEtBQUtDLFNBQWpCLENBQVA7T0FBNUM7O01BRUFrUixTQUFTLENBQUN0akYsU0FBVixDQUFvQnVqRixNQUFwQixHQUE2QixVQUFVcFYsS0FBVixFQUFpQjtRQUM1QyxJQUFJQSxLQUFLLElBQUksSUFBYixFQUFtQjtVQUFFLE9BQU8sSUFBUDs7O1FBQ3JCLElBQUlBLEtBQUssQ0FBQ2lFLFNBQU4sSUFBbUIsS0FBS0EsU0FBeEIsSUFBcUNqRSxLQUFLLENBQUNnRSxNQUFOLENBQWFqeUUsTUFBYixJQUF1QixLQUFLaXlFLE1BQUwsQ0FBWWp5RSxNQUE1RSxFQUFvRjtVQUFFLE9BQU8sS0FBUDs7O1FBQ3RGLEtBQUssSUFBSW9DLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBSzZ2RSxNQUFMLENBQVlqeUUsTUFBaEMsRUFBd0NvQyxDQUFDLEVBQXpDLEVBQTZDO1VBQzNDLElBQUlraEYsSUFBSSxHQUFHLEtBQUtyUixNQUFMLENBQVk3dkUsQ0FBWixDQUFYO2NBQTJCbWhGLEtBQUssR0FBR3RWLEtBQUssQ0FBQ2dFLE1BQU4sQ0FBYTd2RSxDQUFiLENBQW5DOztVQUNBLElBQUksQ0FBQzAwRCxjQUFjLENBQUN3c0IsSUFBSSxDQUFDNXBFLE1BQU4sRUFBYzZwRSxLQUFLLENBQUM3cEUsTUFBcEIsQ0FBZixJQUE4QyxDQUFDbzlDLGNBQWMsQ0FBQ3dzQixJQUFJLENBQUMxNkQsSUFBTixFQUFZMjZELEtBQUssQ0FBQzM2RCxJQUFsQixDQUFqRSxFQUEwRjtZQUFFLE9BQU8sS0FBUDs7OztRQUU5RixPQUFPLElBQVA7T0FQRjs7TUFVQXc2RCxTQUFTLENBQUN0akYsU0FBVixDQUFvQjBqRixRQUFwQixHQUErQixZQUFZO1FBQ3pDLElBQUlqaUYsR0FBRyxHQUFHLEVBQVY7O1FBQ0EsS0FBSyxJQUFJYSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUs2dkUsTUFBTCxDQUFZanlFLE1BQWhDLEVBQXdDb0MsQ0FBQyxFQUF6QyxFQUNFO1VBQUViLEdBQUcsQ0FBQ2EsQ0FBRCxDQUFILEdBQVMsSUFBSXFoRixLQUFKLENBQVUxc0IsT0FBTyxDQUFDLEtBQUtrYixNQUFMLENBQVk3dkUsQ0FBWixFQUFlc1gsTUFBaEIsQ0FBakIsRUFBMENxOUMsT0FBTyxDQUFDLEtBQUtrYixNQUFMLENBQVk3dkUsQ0FBWixFQUFld21CLElBQWhCLENBQWpELENBQVQ7OztRQUNKLE9BQU8sSUFBSXc2RCxTQUFKLENBQWM3aEYsR0FBZCxFQUFtQixLQUFLMndFLFNBQXhCLENBQVA7T0FKRjs7TUFPQWtSLFNBQVMsQ0FBQ3RqRixTQUFWLENBQW9CNGpGLGlCQUFwQixHQUF3QyxZQUFZO1FBQ2xELEtBQUssSUFBSXRoRixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUs2dkUsTUFBTCxDQUFZanlFLE1BQWhDLEVBQXdDb0MsQ0FBQyxFQUF6QyxFQUNFO1VBQUUsSUFBSSxDQUFDLEtBQUs2dkUsTUFBTCxDQUFZN3ZFLENBQVosRUFBZXdvQixLQUFmLEVBQUwsRUFBNkI7WUFBRSxPQUFPLElBQVA7Ozs7UUFDbkMsT0FBTyxLQUFQO09BSEY7O01BTUF3NEQsU0FBUyxDQUFDdGpGLFNBQVYsQ0FBb0Iwb0QsUUFBcEIsR0FBK0IsVUFBVXR5QyxHQUFWLEVBQWUyQyxHQUFmLEVBQW9CO1FBQ2pELElBQUksQ0FBQ0EsR0FBTCxFQUFVO1VBQUVBLEdBQUcsR0FBRzNDLEdBQU47OztRQUNaLEtBQUssSUFBSTlULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBSzZ2RSxNQUFMLENBQVlqeUUsTUFBaEMsRUFBd0NvQyxDQUFDLEVBQXpDLEVBQTZDO1VBQzNDLElBQUkrOEMsS0FBSyxHQUFHLEtBQUs4eUIsTUFBTCxDQUFZN3ZFLENBQVosQ0FBWjs7VUFDQSxJQUFJeTBELEdBQUcsQ0FBQ2grQyxHQUFELEVBQU1zbUMsS0FBSyxDQUFDaGpDLElBQU4sRUFBTixDQUFILElBQTBCLENBQTFCLElBQStCMDZDLEdBQUcsQ0FBQzNnRCxHQUFELEVBQU1pcEMsS0FBSyxDQUFDeC9CLEVBQU4sRUFBTixDQUFILElBQXdCLENBQTNELEVBQ0U7WUFBRSxPQUFPdmQsQ0FBUDs7OztRQUVOLE9BQU8sQ0FBQyxDQUFSO09BUEY7O01BVUEsSUFBSXFoRixLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFTL3BFLE1BQVQsRUFBaUJrUCxJQUFqQixFQUF1QjtRQUNqQyxLQUFLbFAsTUFBTCxHQUFjQSxNQUFkO1FBQXNCLEtBQUtrUCxJQUFMLEdBQVlBLElBQVo7T0FEeEI7O01BSUE2NkQsS0FBSyxDQUFDM2pGLFNBQU4sQ0FBZ0JxYyxJQUFoQixHQUF1QixZQUFZO1FBQUUsT0FBTzg2QyxNQUFNLENBQUMsS0FBS3Y5QyxNQUFOLEVBQWMsS0FBS2tQLElBQW5CLENBQWI7T0FBckM7O01BQ0E2NkQsS0FBSyxDQUFDM2pGLFNBQU4sQ0FBZ0I2ZixFQUFoQixHQUFxQixZQUFZO1FBQUUsT0FBT3EzQyxNQUFNLENBQUMsS0FBS3Q5QyxNQUFOLEVBQWMsS0FBS2tQLElBQW5CLENBQWI7T0FBbkM7O01BQ0E2NkQsS0FBSyxDQUFDM2pGLFNBQU4sQ0FBZ0I4cUIsS0FBaEIsR0FBd0IsWUFBWTtRQUFFLE9BQU8sS0FBS2hDLElBQUwsQ0FBVStsQyxJQUFWLElBQWtCLEtBQUtqMUMsTUFBTCxDQUFZaTFDLElBQTlCLElBQXNDLEtBQUsvbEMsSUFBTCxDQUFVL0QsRUFBVixJQUFnQixLQUFLbkwsTUFBTCxDQUFZbUwsRUFBekU7T0FBdEMsQ0EzZ0ptQjs7Ozs7TUFnaEpuQixTQUFTOCtELGtCQUFULENBQTRCcDBCLEVBQTVCLEVBQWdDMGlCLE1BQWhDLEVBQXdDQyxTQUF4QyxFQUFtRDtRQUNqRCxJQUFJMFIsUUFBUSxHQUFHcjBCLEVBQUUsSUFBSUEsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV3U1QyxrQkFBaEM7UUFDQSxJQUFJQyxJQUFJLEdBQUc3UixNQUFNLENBQUNDLFNBQUQsQ0FBakI7UUFDQUQsTUFBTSxDQUFDdjBELElBQVAsQ0FBWSxVQUFVamhCLENBQVYsRUFBYXlELENBQWIsRUFBZ0I7VUFBRSxPQUFPMjJELEdBQUcsQ0FBQ3A2RCxDQUFDLENBQUMwZixJQUFGLEVBQUQsRUFBV2pjLENBQUMsQ0FBQ2ljLElBQUYsRUFBWCxDQUFWO1NBQTlCO1FBQ0ErMUQsU0FBUyxHQUFHajVELE9BQU8sQ0FBQ2c1RCxNQUFELEVBQVM2UixJQUFULENBQW5COztRQUNBLEtBQUssSUFBSTFoRixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7VUFDdEMsSUFBSW9xRCxHQUFHLEdBQUd5bEIsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBaEI7Y0FBcUJzc0IsSUFBSSxHQUFHdWpELE1BQU0sQ0FBQzd2RSxDQUFDLEdBQUcsQ0FBTCxDQUFsQztVQUNBLElBQUk4ekQsSUFBSSxHQUFHVyxHQUFHLENBQUNub0MsSUFBSSxDQUFDL08sRUFBTCxFQUFELEVBQVk2c0MsR0FBRyxDQUFDcndDLElBQUosRUFBWixDQUFkOztVQUNBLElBQUl5bkUsUUFBUSxJQUFJLENBQUNwM0IsR0FBRyxDQUFDNWhDLEtBQUosRUFBYixHQUEyQnNyQyxJQUFJLEdBQUcsQ0FBbEMsR0FBc0NBLElBQUksSUFBSSxDQUFsRCxFQUFxRDtZQUNuRCxJQUFJLzVDLElBQUksR0FBRzg2QyxNQUFNLENBQUN2b0MsSUFBSSxDQUFDdlMsSUFBTCxFQUFELEVBQWNxd0MsR0FBRyxDQUFDcndDLElBQUosRUFBZCxDQUFqQjtnQkFBNEN3RCxFQUFFLEdBQUdxM0MsTUFBTSxDQUFDdG9DLElBQUksQ0FBQy9PLEVBQUwsRUFBRCxFQUFZNnNDLEdBQUcsQ0FBQzdzQyxFQUFKLEVBQVosQ0FBdkQ7WUFDQSxJQUFJb2tFLEdBQUcsR0FBR3IxRCxJQUFJLENBQUM5RCxLQUFMLEtBQWU0aEMsR0FBRyxDQUFDcndDLElBQUosTUFBY3F3QyxHQUFHLENBQUM1akMsSUFBakMsR0FBd0M4RixJQUFJLENBQUN2UyxJQUFMLE1BQWV1UyxJQUFJLENBQUM5RixJQUF0RTs7WUFDQSxJQUFJeG1CLENBQUMsSUFBSTh2RSxTQUFULEVBQW9CO2NBQUUsRUFBRUEsU0FBRjs7O1lBQ3RCRCxNQUFNLENBQUM3aEQsTUFBUCxDQUFjLEVBQUVodUIsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsSUFBSXFoRixLQUFKLENBQVVNLEdBQUcsR0FBR3BrRSxFQUFILEdBQVF4RCxJQUFyQixFQUEyQjRuRSxHQUFHLEdBQUc1bkUsSUFBSCxHQUFVd0QsRUFBeEMsQ0FBdEI7Ozs7UUFHSixPQUFPLElBQUl5akUsU0FBSixDQUFjblIsTUFBZCxFQUFzQkMsU0FBdEIsQ0FBUDs7O01BR0YsU0FBUzhSLGVBQVQsQ0FBeUJ0cUUsTUFBekIsRUFBaUNrUCxJQUFqQyxFQUF1QztRQUNyQyxPQUFPLElBQUl3NkQsU0FBSixDQUFjLENBQUMsSUFBSUssS0FBSixDQUFVL3BFLE1BQVYsRUFBa0JrUCxJQUFJLElBQUlsUCxNQUExQixDQUFELENBQWQsRUFBbUQsQ0FBbkQsQ0FBUDtPQW5pSmlCOzs7O01Bd2lKbkIsU0FBU3VxRSxTQUFULENBQW1CdnpDLE1BQW5CLEVBQTJCO1FBQ3pCLElBQUksQ0FBQ0EsTUFBTSxDQUFDME4sSUFBWixFQUFrQjtVQUFFLE9BQU8xTixNQUFNLENBQUMvd0IsRUFBZDs7O1FBQ3BCLE9BQU9pM0MsR0FBRyxDQUFDbG1CLE1BQU0sQ0FBQ3YwQixJQUFQLENBQVl3eUMsSUFBWixHQUFtQmplLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWXArQyxNQUEvQixHQUF3QyxDQUF6QyxFQUNDOHFELEdBQUcsQ0FBQ3BhLE1BQU0sQ0FBQzBOLElBQVIsQ0FBSCxDQUFpQnArQyxNQUFqQixJQUEyQjB3QyxNQUFNLENBQUMwTixJQUFQLENBQVlwK0MsTUFBWixJQUFzQixDQUF0QixHQUEwQjB3QyxNQUFNLENBQUN2MEIsSUFBUCxDQUFZMEksRUFBdEMsR0FBMkMsQ0FBdEUsQ0FERCxDQUFWO09BMWlKaUI7Ozs7TUFnakpuQixTQUFTcS9ELGVBQVQsQ0FBeUJodUUsR0FBekIsRUFBOEJ3NkIsTUFBOUIsRUFBc0M7UUFDcEMsSUFBSW1tQixHQUFHLENBQUMzZ0QsR0FBRCxFQUFNdzZCLE1BQU0sQ0FBQ3YwQixJQUFiLENBQUgsR0FBd0IsQ0FBNUIsRUFBK0I7VUFBRSxPQUFPakcsR0FBUDs7O1FBQ2pDLElBQUkyZ0QsR0FBRyxDQUFDM2dELEdBQUQsRUFBTXc2QixNQUFNLENBQUMvd0IsRUFBYixDQUFILElBQXVCLENBQTNCLEVBQThCO1VBQUUsT0FBT3NrRSxTQUFTLENBQUN2ekMsTUFBRCxDQUFoQjs7O1FBRWhDLElBQUlpZSxJQUFJLEdBQUd6NEMsR0FBRyxDQUFDeTRDLElBQUosR0FBV2plLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWXArQyxNQUF2QixJQUFpQzB3QyxNQUFNLENBQUMvd0IsRUFBUCxDQUFVZ3ZDLElBQVYsR0FBaUJqZSxNQUFNLENBQUN2MEIsSUFBUCxDQUFZd3lDLElBQTlELElBQXNFLENBQWpGO1lBQW9GOXBDLEVBQUUsR0FBRzNPLEdBQUcsQ0FBQzJPLEVBQTdGOztRQUNBLElBQUkzTyxHQUFHLENBQUN5NEMsSUFBSixJQUFZamUsTUFBTSxDQUFDL3dCLEVBQVAsQ0FBVWd2QyxJQUExQixFQUFnQztVQUFFOXBDLEVBQUUsSUFBSW8vRCxTQUFTLENBQUN2ekMsTUFBRCxDQUFULENBQWtCN3JCLEVBQWxCLEdBQXVCNnJCLE1BQU0sQ0FBQy93QixFQUFQLENBQVVrRixFQUF2Qzs7O1FBQ2xDLE9BQU8reEMsR0FBRyxDQUFDakksSUFBRCxFQUFPOXBDLEVBQVAsQ0FBVjs7O01BR0YsU0FBU3MvRCxxQkFBVCxDQUErQjF1QixHQUEvQixFQUFvQy9rQixNQUFwQyxFQUE0QztRQUMxQyxJQUFJbnZDLEdBQUcsR0FBRyxFQUFWOztRQUNBLEtBQUssSUFBSWEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3F6RCxHQUFHLENBQUN1YyxHQUFKLENBQVFDLE1BQVIsQ0FBZWp5RSxNQUFuQyxFQUEyQ29DLENBQUMsRUFBNUMsRUFBZ0Q7VUFDOUMsSUFBSSs4QyxLQUFLLEdBQUdzVyxHQUFHLENBQUN1YyxHQUFKLENBQVFDLE1BQVIsQ0FBZTd2RSxDQUFmLENBQVo7VUFDQWIsR0FBRyxDQUFDeEMsSUFBSixDQUFTLElBQUkwa0YsS0FBSixDQUFVUyxlQUFlLENBQUMva0MsS0FBSyxDQUFDemxDLE1BQVAsRUFBZWczQixNQUFmLENBQXpCLEVBQ1V3ekMsZUFBZSxDQUFDL2tDLEtBQUssQ0FBQ3YyQixJQUFQLEVBQWE4bkIsTUFBYixDQUR6QixDQUFUOzs7UUFHRixPQUFPaXpDLGtCQUFrQixDQUFDbHVCLEdBQUcsQ0FBQ2xHLEVBQUwsRUFBU2h1RCxHQUFULEVBQWNrMEQsR0FBRyxDQUFDdWMsR0FBSixDQUFRRSxTQUF0QixDQUF6Qjs7O01BR0YsU0FBU2tTLFNBQVQsQ0FBbUJsdUUsR0FBbkIsRUFBd0I0OUIsR0FBeEIsRUFBNkJvb0IsRUFBN0IsRUFBaUM7UUFDL0IsSUFBSWhtRCxHQUFHLENBQUN5NEMsSUFBSixJQUFZN2EsR0FBRyxDQUFDNmEsSUFBcEIsRUFDRTtVQUFFLE9BQU9pSSxHQUFHLENBQUNzRixFQUFFLENBQUN2TixJQUFKLEVBQVV6NEMsR0FBRyxDQUFDMk8sRUFBSixHQUFTaXZCLEdBQUcsQ0FBQ2p2QixFQUFiLEdBQWtCcTNDLEVBQUUsQ0FBQ3IzQyxFQUEvQixDQUFWO1NBREosTUFHRTtVQUFFLE9BQU8reEMsR0FBRyxDQUFDc0YsRUFBRSxDQUFDdk4sSUFBSCxJQUFXejRDLEdBQUcsQ0FBQ3k0QyxJQUFKLEdBQVc3YSxHQUFHLENBQUM2YSxJQUExQixDQUFELEVBQWtDejRDLEdBQUcsQ0FBQzJPLEVBQXRDLENBQVY7O09BdmtKYTs7OztNQTRrSm5CLFNBQVN3L0Qsa0JBQVQsQ0FBNEI1dUIsR0FBNUIsRUFBaUN1UCxPQUFqQyxFQUEwQ25wRCxJQUExQyxFQUFnRDtRQUM5QyxJQUFJdGEsR0FBRyxHQUFHLEVBQVY7UUFDQSxJQUFJK2lGLE9BQU8sR0FBRzF0QixHQUFHLENBQUNuQixHQUFHLENBQUN2bEQsS0FBTCxFQUFZLENBQVosQ0FBakI7WUFBaUNxMEUsT0FBTyxHQUFHRCxPQUEzQzs7UUFDQSxLQUFLLElBQUlsaUYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRpRSxPQUFPLENBQUNobEUsTUFBNUIsRUFBb0NvQyxDQUFDLEVBQXJDLEVBQXlDO1VBQ3ZDLElBQUlzdUMsTUFBTSxHQUFHczBCLE9BQU8sQ0FBQzVpRSxDQUFELENBQXBCO1VBQ0EsSUFBSStaLElBQUksR0FBR2lvRSxTQUFTLENBQUMxekMsTUFBTSxDQUFDdjBCLElBQVIsRUFBY21vRSxPQUFkLEVBQXVCQyxPQUF2QixDQUFwQjtVQUNBLElBQUk1a0UsRUFBRSxHQUFHeWtFLFNBQVMsQ0FBQ0gsU0FBUyxDQUFDdnpDLE1BQUQsQ0FBVixFQUFvQjR6QyxPQUFwQixFQUE2QkMsT0FBN0IsQ0FBbEI7VUFDQUQsT0FBTyxHQUFHNXpDLE1BQU0sQ0FBQy93QixFQUFqQjtVQUNBNGtFLE9BQU8sR0FBRzVrRSxFQUFWOztVQUNBLElBQUk5RCxJQUFJLElBQUksUUFBWixFQUFzQjtZQUNwQixJQUFJc2pDLEtBQUssR0FBR3NXLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFlN3ZFLENBQWYsQ0FBWjtnQkFBK0IyaEYsR0FBRyxHQUFHbHRCLEdBQUcsQ0FBQzFYLEtBQUssQ0FBQ3YyQixJQUFQLEVBQWF1MkIsS0FBSyxDQUFDemxDLE1BQW5CLENBQUgsR0FBZ0MsQ0FBckU7WUFDQW5ZLEdBQUcsQ0FBQ2EsQ0FBRCxDQUFILEdBQVMsSUFBSXFoRixLQUFKLENBQVVNLEdBQUcsR0FBR3BrRSxFQUFILEdBQVF4RCxJQUFyQixFQUEyQjRuRSxHQUFHLEdBQUc1bkUsSUFBSCxHQUFVd0QsRUFBeEMsQ0FBVDtXQUZGLE1BR087WUFDTHBlLEdBQUcsQ0FBQ2EsQ0FBRCxDQUFILEdBQVMsSUFBSXFoRixLQUFKLENBQVV0bkUsSUFBVixFQUFnQkEsSUFBaEIsQ0FBVDs7OztRQUdKLE9BQU8sSUFBSWluRSxTQUFKLENBQWM3aEYsR0FBZCxFQUFtQmswRCxHQUFHLENBQUN1YyxHQUFKLENBQVFFLFNBQTNCLENBQVA7T0E1bEppQjs7O01BaW1KbkIsU0FBU3NTLFFBQVQsQ0FBa0JqMUIsRUFBbEIsRUFBc0I7UUFDcEJBLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3oyRCxJQUFQLEdBQWMrekQsT0FBTyxDQUFDeEQsRUFBRSxDQUFDamxCLE9BQUosRUFBYWlsQixFQUFFLENBQUNrRyxHQUFILENBQU9ndkIsVUFBcEIsQ0FBckI7UUFDQUMsY0FBYyxDQUFDbjFCLEVBQUQsQ0FBZDs7O01BR0YsU0FBU20xQixjQUFULENBQXdCbjFCLEVBQXhCLEVBQTRCO1FBQzFCQSxFQUFFLENBQUNrRyxHQUFILENBQU9uNUMsSUFBUCxDQUFZLFVBQVVxeUMsSUFBVixFQUFnQjtVQUMxQixJQUFJQSxJQUFJLENBQUN3SyxVQUFULEVBQXFCO1lBQUV4SyxJQUFJLENBQUN3SyxVQUFMLEdBQWtCLElBQWxCOzs7VUFDdkIsSUFBSXhLLElBQUksQ0FBQzdiLE1BQVQsRUFBaUI7WUFBRTZiLElBQUksQ0FBQzdiLE1BQUwsR0FBYyxJQUFkOztTQUZyQjtRQUlBeWMsRUFBRSxDQUFDa0csR0FBSCxDQUFPNkQsWUFBUCxHQUFzQi9KLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzRELGlCQUFQLEdBQTJCOUosRUFBRSxDQUFDa0csR0FBSCxDQUFPdmxELEtBQXhEO1FBQ0F1b0UsV0FBVyxDQUFDbHBCLEVBQUQsRUFBSyxHQUFMLENBQVg7UUFDQUEsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzB5QixPQUFUOztRQUNBLElBQUk1SSxFQUFFLENBQUNPLEtBQVAsRUFBYztVQUFFMmdCLFNBQVMsQ0FBQ2xoQixFQUFELENBQVQ7O09BOW1KQzs7Ozs7O01Bc25KbkIsU0FBU28xQixpQkFBVCxDQUEyQmx2QixHQUEzQixFQUFnQy9rQixNQUFoQyxFQUF3QztRQUN0QyxPQUFPQSxNQUFNLENBQUN2MEIsSUFBUCxDQUFZMEksRUFBWixJQUFrQixDQUFsQixJQUF1QjZyQixNQUFNLENBQUMvd0IsRUFBUCxDQUFVa0YsRUFBVixJQUFnQixDQUF2QyxJQUE0Q2ltQyxHQUFHLENBQUNwYSxNQUFNLENBQUMwTixJQUFSLENBQUgsSUFBb0IsRUFBaEUsS0FDSixDQUFDcVgsR0FBRyxDQUFDbEcsRUFBTCxJQUFXa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPamxCLE9BQVAsQ0FBZXM2QyxxQkFEdEIsQ0FBUDtPQXZuSmlCOzs7TUE0bkpuQixTQUFTQyxTQUFULENBQW1CcHZCLEdBQW5CLEVBQXdCL2tCLE1BQXhCLEVBQWdDbXJCLFdBQWhDLEVBQTZDdUUsY0FBN0MsRUFBNkQ7UUFDM0QsU0FBUzBrQixRQUFULENBQWtCdDNFLENBQWxCLEVBQXFCO1VBQUMsT0FBT3F1RCxXQUFXLEdBQUdBLFdBQVcsQ0FBQ3J1RCxDQUFELENBQWQsR0FBb0IsSUFBdEM7OztRQUN0QixTQUFTMHBDLE1BQVQsQ0FBZ0J5WCxJQUFoQixFQUFzQnZRLElBQXRCLEVBQTRCbWQsS0FBNUIsRUFBbUM7VUFDakM4RSxVQUFVLENBQUMxUixJQUFELEVBQU92USxJQUFQLEVBQWFtZCxLQUFiLEVBQW9CNkUsY0FBcEIsQ0FBVjtVQUNBdUUsV0FBVyxDQUFDaFcsSUFBRCxFQUFPLFFBQVAsRUFBaUJBLElBQWpCLEVBQXVCamUsTUFBdkIsQ0FBWDs7O1FBRUYsU0FBU3EwQyxRQUFULENBQWtCem5FLEtBQWxCLEVBQXlCekUsR0FBekIsRUFBOEI7VUFDNUIsSUFBSTdULE1BQU0sR0FBRyxFQUFiOztVQUNBLEtBQUssSUFBSTVDLENBQUMsR0FBR2tiLEtBQWIsRUFBb0JsYixDQUFDLEdBQUd5VyxHQUF4QixFQUE2QixFQUFFelcsQ0FBL0IsRUFDRTtZQUFFNEMsTUFBTSxDQUFDakcsSUFBUCxDQUFZLElBQUlvaEUsSUFBSixDQUFTL2hCLElBQUksQ0FBQ2g4QyxDQUFELENBQWIsRUFBa0IwaUYsUUFBUSxDQUFDMWlGLENBQUQsQ0FBMUIsRUFBK0JnK0QsY0FBL0IsQ0FBWjs7O1VBQ0osT0FBT3A3RCxNQUFQOzs7UUFHRixJQUFJbVgsSUFBSSxHQUFHdTBCLE1BQU0sQ0FBQ3YwQixJQUFsQjtZQUF3QndELEVBQUUsR0FBRyt3QixNQUFNLENBQUMvd0IsRUFBcEM7WUFBd0N5K0IsSUFBSSxHQUFHMU4sTUFBTSxDQUFDME4sSUFBdEQ7UUFDQSxJQUFJNG1DLFNBQVMsR0FBR3h2QixPQUFPLENBQUNDLEdBQUQsRUFBTXQ1QyxJQUFJLENBQUN3eUMsSUFBWCxDQUF2QjtZQUF5QzZRLFFBQVEsR0FBR2hLLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNOTFDLEVBQUUsQ0FBQ2d2QyxJQUFULENBQTNEO1FBQ0EsSUFBSXMyQixRQUFRLEdBQUduNkIsR0FBRyxDQUFDMU0sSUFBRCxDQUFsQjtZQUEwQjhtQyxTQUFTLEdBQUdKLFFBQVEsQ0FBQzFtQyxJQUFJLENBQUNwK0MsTUFBTCxHQUFjLENBQWYsQ0FBOUM7WUFBaUVtbEYsTUFBTSxHQUFHeGxFLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVV4eUMsSUFBSSxDQUFDd3lDLElBQXpGLENBZjJEOztRQWtCM0QsSUFBSWplLE1BQU0sQ0FBQ2lzQixJQUFYLEVBQWlCO1VBQ2ZsSCxHQUFHLENBQUMydkIsTUFBSixDQUFXLENBQVgsRUFBY0wsUUFBUSxDQUFDLENBQUQsRUFBSTNtQyxJQUFJLENBQUNwK0MsTUFBVCxDQUF0QjtVQUNBeTFELEdBQUcsQ0FBQ3ZwQixNQUFKLENBQVdrUyxJQUFJLENBQUNwK0MsTUFBaEIsRUFBd0J5MUQsR0FBRyxDQUFDdjdDLElBQUosR0FBV2trQyxJQUFJLENBQUNwK0MsTUFBeEM7U0FGRixNQUdPLElBQUkya0YsaUJBQWlCLENBQUNsdkIsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBckIsRUFBb0M7OztVQUd6QyxJQUFJMjBDLEtBQUssR0FBR04sUUFBUSxDQUFDLENBQUQsRUFBSTNtQyxJQUFJLENBQUNwK0MsTUFBTCxHQUFjLENBQWxCLENBQXBCO1VBQ0FrM0MsTUFBTSxDQUFDc29CLFFBQUQsRUFBV0EsUUFBUSxDQUFDcGhCLElBQXBCLEVBQTBCOG1DLFNBQTFCLENBQU47O1VBQ0EsSUFBSUMsTUFBSixFQUFZO1lBQUUxdkIsR0FBRyxDQUFDdnBCLE1BQUosQ0FBVy92QixJQUFJLENBQUN3eUMsSUFBaEIsRUFBc0J3MkIsTUFBdEI7OztVQUNkLElBQUlFLEtBQUssQ0FBQ3JsRixNQUFWLEVBQWtCO1lBQUV5MUQsR0FBRyxDQUFDMnZCLE1BQUosQ0FBV2pwRSxJQUFJLENBQUN3eUMsSUFBaEIsRUFBc0IwMkIsS0FBdEI7O1NBTmYsTUFPQSxJQUFJTCxTQUFTLElBQUl4bEIsUUFBakIsRUFBMkI7VUFDaEMsSUFBSXBoQixJQUFJLENBQUNwK0MsTUFBTCxJQUFlLENBQW5CLEVBQXNCO1lBQ3BCazNDLE1BQU0sQ0FBQzh0QyxTQUFELEVBQVlBLFNBQVMsQ0FBQzVtQyxJQUFWLENBQWUzNkMsS0FBZixDQUFxQixDQUFyQixFQUF3QjBZLElBQUksQ0FBQzBJLEVBQTdCLElBQW1Db2dFLFFBQW5DLEdBQThDRCxTQUFTLENBQUM1bUMsSUFBVixDQUFlMzZDLEtBQWYsQ0FBcUJrYyxFQUFFLENBQUNrRixFQUF4QixDQUExRCxFQUF1RnFnRSxTQUF2RixDQUFOO1dBREYsTUFFTztZQUNMLElBQUlJLE9BQU8sR0FBR1AsUUFBUSxDQUFDLENBQUQsRUFBSTNtQyxJQUFJLENBQUNwK0MsTUFBTCxHQUFjLENBQWxCLENBQXRCO1lBQ0FzbEYsT0FBTyxDQUFDdm1GLElBQVIsQ0FBYSxJQUFJb2hFLElBQUosQ0FBUzhrQixRQUFRLEdBQUdELFNBQVMsQ0FBQzVtQyxJQUFWLENBQWUzNkMsS0FBZixDQUFxQmtjLEVBQUUsQ0FBQ2tGLEVBQXhCLENBQXBCLEVBQWlEcWdFLFNBQWpELEVBQTREOWtCLGNBQTVELENBQWI7WUFDQWxwQixNQUFNLENBQUM4dEMsU0FBRCxFQUFZQSxTQUFTLENBQUM1bUMsSUFBVixDQUFlMzZDLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0IwWSxJQUFJLENBQUMwSSxFQUE3QixJQUFtQ3U1QixJQUFJLENBQUMsQ0FBRCxDQUFuRCxFQUF3RDBtQyxRQUFRLENBQUMsQ0FBRCxDQUFoRSxDQUFOO1lBQ0FydkIsR0FBRyxDQUFDMnZCLE1BQUosQ0FBV2pwRSxJQUFJLENBQUN3eUMsSUFBTCxHQUFZLENBQXZCLEVBQTBCMjJCLE9BQTFCOztTQVBHLE1BU0EsSUFBSWxuQyxJQUFJLENBQUNwK0MsTUFBTCxJQUFlLENBQW5CLEVBQXNCO1VBQzNCazNDLE1BQU0sQ0FBQzh0QyxTQUFELEVBQVlBLFNBQVMsQ0FBQzVtQyxJQUFWLENBQWUzNkMsS0FBZixDQUFxQixDQUFyQixFQUF3QjBZLElBQUksQ0FBQzBJLEVBQTdCLElBQW1DdTVCLElBQUksQ0FBQyxDQUFELENBQXZDLEdBQTZDb2hCLFFBQVEsQ0FBQ3BoQixJQUFULENBQWMzNkMsS0FBZCxDQUFvQmtjLEVBQUUsQ0FBQ2tGLEVBQXZCLENBQXpELEVBQXFGaWdFLFFBQVEsQ0FBQyxDQUFELENBQTdGLENBQU47VUFDQXJ2QixHQUFHLENBQUN2cEIsTUFBSixDQUFXL3ZCLElBQUksQ0FBQ3d5QyxJQUFMLEdBQVksQ0FBdkIsRUFBMEJ3MkIsTUFBMUI7U0FGSyxNQUdBO1VBQ0xqdUMsTUFBTSxDQUFDOHRDLFNBQUQsRUFBWUEsU0FBUyxDQUFDNW1DLElBQVYsQ0FBZTM2QyxLQUFmLENBQXFCLENBQXJCLEVBQXdCMFksSUFBSSxDQUFDMEksRUFBN0IsSUFBbUN1NUIsSUFBSSxDQUFDLENBQUQsQ0FBbkQsRUFBd0QwbUMsUUFBUSxDQUFDLENBQUQsQ0FBaEUsQ0FBTjtVQUNBNXRDLE1BQU0sQ0FBQ3NvQixRQUFELEVBQVd5bEIsUUFBUSxHQUFHemxCLFFBQVEsQ0FBQ3BoQixJQUFULENBQWMzNkMsS0FBZCxDQUFvQmtjLEVBQUUsQ0FBQ2tGLEVBQXZCLENBQXRCLEVBQWtEcWdFLFNBQWxELENBQU47VUFDQSxJQUFJSyxPQUFPLEdBQUdSLFFBQVEsQ0FBQyxDQUFELEVBQUkzbUMsSUFBSSxDQUFDcCtDLE1BQUwsR0FBYyxDQUFsQixDQUF0Qjs7VUFDQSxJQUFJbWxGLE1BQU0sR0FBRyxDQUFiLEVBQWdCO1lBQUUxdkIsR0FBRyxDQUFDdnBCLE1BQUosQ0FBVy92QixJQUFJLENBQUN3eUMsSUFBTCxHQUFZLENBQXZCLEVBQTBCdzJCLE1BQU0sR0FBRyxDQUFuQzs7O1VBQ2xCMXZCLEdBQUcsQ0FBQzJ2QixNQUFKLENBQVdqcEUsSUFBSSxDQUFDd3lDLElBQUwsR0FBWSxDQUF2QixFQUEwQjQyQixPQUExQjs7O1FBR0Y1Z0IsV0FBVyxDQUFDbFAsR0FBRCxFQUFNLFFBQU4sRUFBZ0JBLEdBQWhCLEVBQXFCL2tCLE1BQXJCLENBQVg7T0E1cUppQjs7O01BZ3JKbkIsU0FBUzgwQyxVQUFULENBQW9CL3ZCLEdBQXBCLEVBQXlCbjNELENBQXpCLEVBQTRCbW5GLGNBQTVCLEVBQTRDO1FBQzFDLFNBQVNDLFNBQVQsQ0FBbUJqd0IsR0FBbkIsRUFBd0Jrd0IsSUFBeEIsRUFBOEJDLFVBQTlCLEVBQTBDO1VBQ3hDLElBQUlud0IsR0FBRyxDQUFDb3dCLE1BQVIsRUFBZ0I7WUFBRSxLQUFLLElBQUl6akYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3F6RCxHQUFHLENBQUNvd0IsTUFBSixDQUFXN2xGLE1BQS9CLEVBQXVDLEVBQUVvQyxDQUF6QyxFQUE0QztjQUM1RCxJQUFJMGpGLEdBQUcsR0FBR3J3QixHQUFHLENBQUNvd0IsTUFBSixDQUFXempGLENBQVgsQ0FBVjs7Y0FDQSxJQUFJMGpGLEdBQUcsQ0FBQ3J3QixHQUFKLElBQVdrd0IsSUFBZixFQUFxQjtnQkFBRTs7O2NBQ3ZCLElBQUkvZ0YsTUFBTSxHQUFHZ2hGLFVBQVUsSUFBSUUsR0FBRyxDQUFDRixVQUEvQjs7Y0FDQSxJQUFJSCxjQUFjLElBQUksQ0FBQzdnRixNQUF2QixFQUErQjtnQkFBRTs7O2NBQ2pDdEcsQ0FBQyxDQUFDd25GLEdBQUcsQ0FBQ3J3QixHQUFMLEVBQVU3d0QsTUFBVixDQUFEO2NBQ0E4Z0YsU0FBUyxDQUFDSSxHQUFHLENBQUNyd0IsR0FBTCxFQUFVQSxHQUFWLEVBQWU3d0QsTUFBZixDQUFUOzs7OztRQUdKOGdGLFNBQVMsQ0FBQ2p3QixHQUFELEVBQU0sSUFBTixFQUFZLElBQVosQ0FBVDtPQTNySmlCOzs7TUErckpuQixTQUFTc3dCLFNBQVQsQ0FBbUJ4MkIsRUFBbkIsRUFBdUJrRyxHQUF2QixFQUE0QjtRQUMxQixJQUFJQSxHQUFHLENBQUNsRyxFQUFSLEVBQVk7VUFBRSxNQUFNLElBQUk3cEIsS0FBSixDQUFVLGtDQUFWLENBQU47OztRQUNkNnBCLEVBQUUsQ0FBQ2tHLEdBQUgsR0FBU0EsR0FBVDtRQUNBQSxHQUFHLENBQUNsRyxFQUFKLEdBQVNBLEVBQVQ7UUFDQTJnQixtQkFBbUIsQ0FBQzNnQixFQUFELENBQW5CO1FBQ0FpMUIsUUFBUSxDQUFDajFCLEVBQUQsQ0FBUjtRQUNBeTJCLGlCQUFpQixDQUFDejJCLEVBQUQsQ0FBakI7UUFDQUEsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzZpQixTQUFYLEdBQXVCc0ksR0FBRyxDQUFDdEksU0FBM0I7O1FBQ0EsSUFBSSxDQUFDb0MsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUFoQixFQUE4QjtVQUFFdkosV0FBVyxDQUFDeFEsRUFBRCxDQUFYOzs7UUFDaENBLEVBQUUsQ0FBQ2psQixPQUFILENBQVd0ckMsSUFBWCxHQUFrQnkyRCxHQUFHLENBQUNndkIsVUFBdEI7UUFDQWhVLFNBQVMsQ0FBQ2xoQixFQUFELENBQVQ7OztNQUdGLFNBQVN5MkIsaUJBQVQsQ0FBMkJ6MkIsRUFBM0IsRUFBK0I7UUFDL0IsQ0FBQ0EsRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBUCxJQUFvQixLQUFwQixHQUE0QnZFLFFBQTVCLEdBQXVDcEIsT0FBeEMsRUFBaUQrSCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXaXZFLE9BQTVELEVBQXFFLGdCQUFyRTs7O01BR0EsU0FBU3dRLGdCQUFULENBQTBCMTJCLEVBQTFCLEVBQThCO1FBQzVCcXVCLE9BQU8sQ0FBQ3J1QixFQUFELEVBQUssWUFBWTtVQUN0QnkyQixpQkFBaUIsQ0FBQ3oyQixFQUFELENBQWpCO1VBQ0FraEIsU0FBUyxDQUFDbGhCLEVBQUQsQ0FBVDtTQUZLLENBQVA7OztNQU1GLFNBQVMyMkIsT0FBVCxDQUFpQngzRCxJQUFqQixFQUF1Qjs7OztRQUlyQixLQUFLeFcsSUFBTCxHQUFZLEVBQVo7UUFBZ0IsS0FBS2l1RSxNQUFMLEdBQWMsRUFBZDtRQUNoQixLQUFLQyxTQUFMLEdBQWlCMTNELElBQUksR0FBR0EsSUFBSSxDQUFDMDNELFNBQVIsR0FBb0IzMkUsUUFBekMsQ0FMcUI7OztRQVFyQixLQUFLNDJFLFdBQUwsR0FBbUIsS0FBS0MsV0FBTCxHQUFtQixDQUF0QztRQUNBLEtBQUtDLE1BQUwsR0FBYyxLQUFLQyxTQUFMLEdBQWlCLElBQS9CO1FBQ0EsS0FBS0MsVUFBTCxHQUFrQixLQUFLQyxhQUFMLEdBQXFCLElBQXZDLENBVnFCOztRQVlyQixLQUFLQyxVQUFMLEdBQWtCLEtBQUtDLGFBQUwsR0FBcUJsNEQsSUFBSSxHQUFHQSxJQUFJLENBQUNrNEQsYUFBUixHQUF3QixDQUFuRTtPQW51SmlCOzs7O01Bd3VKbkIsU0FBU0MsdUJBQVQsQ0FBaUNweEIsR0FBakMsRUFBc0Mva0IsTUFBdEMsRUFBOEM7UUFDNUMsSUFBSW8yQyxVQUFVLEdBQUc7VUFBQzNxRSxJQUFJLEVBQUU0NkMsT0FBTyxDQUFDcm1CLE1BQU0sQ0FBQ3YwQixJQUFSLENBQWQ7VUFBNkJ3RCxFQUFFLEVBQUVza0UsU0FBUyxDQUFDdnpDLE1BQUQsQ0FBMUM7VUFBb0QwTixJQUFJLEVBQUUyWCxVQUFVLENBQUNOLEdBQUQsRUFBTS9rQixNQUFNLENBQUN2MEIsSUFBYixFQUFtQnUwQixNQUFNLENBQUMvd0IsRUFBMUI7U0FBckY7UUFDQW9uRSxnQkFBZ0IsQ0FBQ3R4QixHQUFELEVBQU1xeEIsVUFBTixFQUFrQnAyQyxNQUFNLENBQUN2MEIsSUFBUCxDQUFZd3lDLElBQTlCLEVBQW9DamUsTUFBTSxDQUFDL3dCLEVBQVAsQ0FBVWd2QyxJQUFWLEdBQWlCLENBQXJELENBQWhCO1FBQ0E2MkIsVUFBVSxDQUFDL3ZCLEdBQUQsRUFBTSxVQUFVQSxHQUFWLEVBQWU7VUFBRSxPQUFPc3hCLGdCQUFnQixDQUFDdHhCLEdBQUQsRUFBTXF4QixVQUFOLEVBQWtCcDJDLE1BQU0sQ0FBQ3YwQixJQUFQLENBQVl3eUMsSUFBOUIsRUFBb0NqZSxNQUFNLENBQUMvd0IsRUFBUCxDQUFVZ3ZDLElBQVYsR0FBaUIsQ0FBckQsQ0FBdkI7U0FBdkIsRUFBMEcsSUFBMUcsQ0FBVjtRQUNBLE9BQU9tNEIsVUFBUDtPQTV1SmlCOzs7O01BaXZKbkIsU0FBU0Usb0JBQVQsQ0FBOEJoOUIsS0FBOUIsRUFBcUM7UUFDbkMsT0FBT0EsS0FBSyxDQUFDaHFELE1BQWIsRUFBcUI7VUFDbkIsSUFBSTZvQixJQUFJLEdBQUdpaUMsR0FBRyxDQUFDZCxLQUFELENBQWQ7O1VBQ0EsSUFBSW5oQyxJQUFJLENBQUNvcEQsTUFBVCxFQUFpQjtZQUFFam9CLEtBQUssQ0FBQ2hqQixHQUFOO1dBQW5CLE1BQ0s7WUFBRTs7O09BcnZKUTs7OztNQTJ2Sm5CLFNBQVNpZ0QsZUFBVCxDQUF5QkMsSUFBekIsRUFBK0J6SSxLQUEvQixFQUFzQztRQUNwQyxJQUFJQSxLQUFKLEVBQVc7VUFDVHVJLG9CQUFvQixDQUFDRSxJQUFJLENBQUNodkUsSUFBTixDQUFwQjtVQUNBLE9BQU80eUMsR0FBRyxDQUFDbzhCLElBQUksQ0FBQ2h2RSxJQUFOLENBQVY7U0FGRixNQUdPLElBQUlndkUsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVWxZLE1BQVYsSUFBb0IsQ0FBQzhxRCxHQUFHLENBQUNvOEIsSUFBSSxDQUFDaHZFLElBQU4sQ0FBSCxDQUFlKzVELE1BQXhDLEVBQWdEO1VBQ3JELE9BQU9ubkIsR0FBRyxDQUFDbzhCLElBQUksQ0FBQ2h2RSxJQUFOLENBQVY7U0FESyxNQUVBLElBQUlndkUsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVWxZLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0IsQ0FBQ2tuRixJQUFJLENBQUNodkUsSUFBTCxDQUFVZ3ZFLElBQUksQ0FBQ2h2RSxJQUFMLENBQVVsWSxNQUFWLEdBQW1CLENBQTdCLEVBQWdDaXlFLE1BQTdELEVBQXFFO1VBQzFFaVYsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVTh1QixHQUFWO1VBQ0EsT0FBTzhqQixHQUFHLENBQUNvOEIsSUFBSSxDQUFDaHZFLElBQU4sQ0FBVjs7T0Fud0plOzs7OztNQTB3Sm5CLFNBQVNpdkUsa0JBQVQsQ0FBNEIxeEIsR0FBNUIsRUFBaUMva0IsTUFBakMsRUFBeUMwMkMsUUFBekMsRUFBbURDLElBQW5ELEVBQXlEO1FBQ3ZELElBQUlILElBQUksR0FBR3p4QixHQUFHLENBQUM2eEIsT0FBZjtRQUNBSixJQUFJLENBQUNmLE1BQUwsQ0FBWW5tRixNQUFaLEdBQXFCLENBQXJCO1FBQ0EsSUFBSW9nQyxJQUFJLEdBQUcsQ0FBQyxJQUFJemxCLElBQUosRUFBWjtZQUFzQjZ4QyxHQUF0QjtRQUNBLElBQUkzakMsSUFBSjs7UUFFQSxJQUFJLENBQUNxK0QsSUFBSSxDQUFDWCxNQUFMLElBQWVjLElBQWYsSUFDQUgsSUFBSSxDQUFDVCxVQUFMLElBQW1CLzFDLE1BQU0sQ0FBQzRaLE1BQTFCLElBQW9DNVosTUFBTSxDQUFDNFosTUFBM0MsS0FDRTVaLE1BQU0sQ0FBQzRaLE1BQVAsQ0FBYy9tRCxNQUFkLENBQXFCLENBQXJCLEtBQTJCLEdBQTNCLElBQWtDMmpGLElBQUksQ0FBQ2IsV0FBTCxHQUFtQmptRCxJQUFJLElBQUlxMUIsR0FBRyxDQUFDbEcsRUFBSixHQUFTa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPamxCLE9BQVAsQ0FBZWk5QyxpQkFBeEIsR0FBNEMsR0FBaEQsQ0FBMUQsSUFDQTcyQyxNQUFNLENBQUM0WixNQUFQLENBQWMvbUQsTUFBZCxDQUFxQixDQUFyQixLQUEyQixHQUY1QixDQURELE1BSUNpcEQsR0FBRyxHQUFHeTZCLGVBQWUsQ0FBQ0MsSUFBRCxFQUFPQSxJQUFJLENBQUNYLE1BQUwsSUFBZWMsSUFBdEIsQ0FKdEIsQ0FBSixFQUl3RDs7VUFFdER4K0QsSUFBSSxHQUFHaWlDLEdBQUcsQ0FBQzBCLEdBQUcsQ0FBQ3dZLE9BQUwsQ0FBVjs7VUFDQSxJQUFJbk8sR0FBRyxDQUFDbm1CLE1BQU0sQ0FBQ3YwQixJQUFSLEVBQWN1MEIsTUFBTSxDQUFDL3dCLEVBQXJCLENBQUgsSUFBK0IsQ0FBL0IsSUFBb0NrM0MsR0FBRyxDQUFDbm1CLE1BQU0sQ0FBQ3YwQixJQUFSLEVBQWMwTSxJQUFJLENBQUNsSixFQUFuQixDQUFILElBQTZCLENBQXJFLEVBQXdFOzs7WUFHdEVrSixJQUFJLENBQUNsSixFQUFMLEdBQVVza0UsU0FBUyxDQUFDdnpDLE1BQUQsQ0FBbkI7V0FIRixNQUlPOztZQUVMOGIsR0FBRyxDQUFDd1ksT0FBSixDQUFZam1FLElBQVosQ0FBaUI4bkYsdUJBQXVCLENBQUNweEIsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBeEM7O1NBYkosTUFlTzs7VUFFTCxJQUFJeWQsTUFBTSxHQUFHckQsR0FBRyxDQUFDbzhCLElBQUksQ0FBQ2h2RSxJQUFOLENBQWhCOztVQUNBLElBQUksQ0FBQ2kyQyxNQUFELElBQVcsQ0FBQ0EsTUFBTSxDQUFDOGpCLE1BQXZCLEVBQ0U7WUFBRXVWLHNCQUFzQixDQUFDL3hCLEdBQUcsQ0FBQ3VjLEdBQUwsRUFBVWtWLElBQUksQ0FBQ2h2RSxJQUFmLENBQXRCOzs7VUFDSnMwQyxHQUFHLEdBQUc7WUFBQ3dZLE9BQU8sRUFBRSxDQUFDNmhCLHVCQUF1QixDQUFDcHhCLEdBQUQsRUFBTS9rQixNQUFOLENBQXhCLENBQVY7WUFDQ2kyQyxVQUFVLEVBQUVPLElBQUksQ0FBQ1A7V0FEeEI7VUFFQU8sSUFBSSxDQUFDaHZFLElBQUwsQ0FBVW5aLElBQVYsQ0FBZXl0RCxHQUFmOztVQUNBLE9BQU8wNkIsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVWxZLE1BQVYsR0FBbUJrbkYsSUFBSSxDQUFDZCxTQUEvQixFQUEwQztZQUN4Q2MsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVW85RCxLQUFWOztZQUNBLElBQUksQ0FBQzRSLElBQUksQ0FBQ2h2RSxJQUFMLENBQVUsQ0FBVixFQUFhKzVELE1BQWxCLEVBQTBCO2NBQUVpVixJQUFJLENBQUNodkUsSUFBTCxDQUFVbzlELEtBQVY7Ozs7O1FBR2hDNFIsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVW5aLElBQVYsQ0FBZXFvRixRQUFmO1FBQ0FGLElBQUksQ0FBQ1AsVUFBTCxHQUFrQixFQUFFTyxJQUFJLENBQUNOLGFBQXpCO1FBQ0FNLElBQUksQ0FBQ2IsV0FBTCxHQUFtQmEsSUFBSSxDQUFDWixXQUFMLEdBQW1CbG1ELElBQXRDO1FBQ0E4bUQsSUFBSSxDQUFDWCxNQUFMLEdBQWNXLElBQUksQ0FBQ1YsU0FBTCxHQUFpQmEsSUFBL0I7UUFDQUgsSUFBSSxDQUFDVCxVQUFMLEdBQWtCUyxJQUFJLENBQUNSLGFBQUwsR0FBcUJoMkMsTUFBTSxDQUFDNFosTUFBOUM7O1FBRUEsSUFBSSxDQUFDemhDLElBQUwsRUFBVztVQUFFdW1DLE1BQU0sQ0FBQ3FHLEdBQUQsRUFBTSxjQUFOLENBQU47Ozs7TUFHZixTQUFTZ3lCLHlCQUFULENBQW1DaHlCLEdBQW5DLEVBQXdDbkwsTUFBeEMsRUFBZ0Q1N0IsSUFBaEQsRUFBc0RzakQsR0FBdEQsRUFBMkQ7UUFDekQsSUFBSW50RCxFQUFFLEdBQUd5bEMsTUFBTSxDQUFDL21ELE1BQVAsQ0FBYyxDQUFkLENBQVQ7UUFDQSxPQUFPc2hCLEVBQUUsSUFBSSxHQUFOLElBQ0xBLEVBQUUsSUFBSSxHQUFOLElBQ0E2SixJQUFJLENBQUN1akQsTUFBTCxDQUFZanlFLE1BQVosSUFBc0JneUUsR0FBRyxDQUFDQyxNQUFKLENBQVdqeUUsTUFEakMsSUFFQTB1QixJQUFJLENBQUNnMUQsaUJBQUwsTUFBNEIxUixHQUFHLENBQUMwUixpQkFBSixFQUY1QixJQUdBLElBQUkvb0UsSUFBSixLQUFXODZDLEdBQUcsQ0FBQzZ4QixPQUFKLENBQVloQixXQUF2QixLQUF1Qzd3QixHQUFHLENBQUNsRyxFQUFKLEdBQVNrRyxHQUFHLENBQUNsRyxFQUFKLENBQU9qbEIsT0FBUCxDQUFlaTlDLGlCQUF4QixHQUE0QyxHQUFuRixDQUpGO09BdnpKaUI7Ozs7OztNQWswSm5CLFNBQVNHLHFCQUFULENBQStCanlCLEdBQS9CLEVBQW9DdWMsR0FBcEMsRUFBeUNxVixJQUF6QyxFQUErQy84QyxPQUEvQyxFQUF3RDtRQUN0RCxJQUFJNDhDLElBQUksR0FBR3p4QixHQUFHLENBQUM2eEIsT0FBZjtZQUF3Qmg5QixNQUFNLEdBQUdoZ0IsT0FBTyxJQUFJQSxPQUFPLENBQUNnZ0IsTUFBcEQsQ0FEc0Q7Ozs7O1FBT3RELElBQUkrOEIsSUFBSSxJQUFJSCxJQUFJLENBQUNWLFNBQWIsSUFDQ2w4QixNQUFNLElBQUk0OEIsSUFBSSxDQUFDUixhQUFMLElBQXNCcDhCLE1BQWhDLEtBQ0M0OEIsSUFBSSxDQUFDYixXQUFMLElBQW9CYSxJQUFJLENBQUNaLFdBQXpCLElBQXdDWSxJQUFJLENBQUNULFVBQUwsSUFBbUJuOEIsTUFBM0QsSUFDQW05Qix5QkFBeUIsQ0FBQ2h5QixHQUFELEVBQU1uTCxNQUFOLEVBQWNRLEdBQUcsQ0FBQ284QixJQUFJLENBQUNodkUsSUFBTixDQUFqQixFQUE4Qjg1RCxHQUE5QixDQUYxQixDQURMLEVBSUU7VUFBRWtWLElBQUksQ0FBQ2h2RSxJQUFMLENBQVVndkUsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVWxZLE1BQVYsR0FBbUIsQ0FBN0IsSUFBa0NneUUsR0FBbEM7U0FKSixNQU1FO1VBQUV3VixzQkFBc0IsQ0FBQ3hWLEdBQUQsRUFBTWtWLElBQUksQ0FBQ2h2RSxJQUFYLENBQXRCOzs7UUFFSmd2RSxJQUFJLENBQUNaLFdBQUwsR0FBbUIsQ0FBQyxJQUFJM3JFLElBQUosRUFBcEI7UUFDQXVzRSxJQUFJLENBQUNSLGFBQUwsR0FBcUJwOEIsTUFBckI7UUFDQTQ4QixJQUFJLENBQUNWLFNBQUwsR0FBaUJhLElBQWpCOztRQUNBLElBQUkvOEMsT0FBTyxJQUFJQSxPQUFPLENBQUNxOUMsU0FBUixLQUFzQixLQUFyQyxFQUNFO1VBQUVYLG9CQUFvQixDQUFDRSxJQUFJLENBQUNmLE1BQU4sQ0FBcEI7Ozs7TUFHTixTQUFTcUIsc0JBQVQsQ0FBZ0N4VixHQUFoQyxFQUFxQzRWLElBQXJDLEVBQTJDO1FBQ3pDLElBQUk5cUMsR0FBRyxHQUFHZ08sR0FBRyxDQUFDODhCLElBQUQsQ0FBYjs7UUFDQSxJQUFJLEVBQUU5cUMsR0FBRyxJQUFJQSxHQUFHLENBQUNtMUIsTUFBWCxJQUFxQm4xQixHQUFHLENBQUN1bUMsTUFBSixDQUFXclIsR0FBWCxDQUF2QixDQUFKLEVBQ0U7VUFBRTRWLElBQUksQ0FBQzdvRixJQUFMLENBQVVpekUsR0FBVjs7T0EzMUphOzs7TUErMUpuQixTQUFTK1UsZ0JBQVQsQ0FBMEJ0eEIsR0FBMUIsRUFBK0Iva0IsTUFBL0IsRUFBdUN2MEIsSUFBdkMsRUFBNkN3RCxFQUE3QyxFQUFpRDtRQUMvQyxJQUFJa29FLFFBQVEsR0FBR24zQyxNQUFNLENBQUMsV0FBVytrQixHQUFHLENBQUNqM0QsRUFBaEIsQ0FBckI7WUFBMENnUCxDQUFDLEdBQUcsQ0FBOUM7UUFDQWlvRCxHQUFHLENBQUNuNUMsSUFBSixDQUFTM2dCLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3N4RCxHQUFHLENBQUN2bEQsS0FBYixFQUFvQmlNLElBQXBCLENBQVQsRUFBb0N4Z0IsSUFBSSxDQUFDc0ksR0FBTCxDQUFTd3hELEdBQUcsQ0FBQ3ZsRCxLQUFKLEdBQVl1bEQsR0FBRyxDQUFDdjdDLElBQXpCLEVBQStCeUYsRUFBL0IsQ0FBcEMsRUFBd0UsVUFBVWd2QyxJQUFWLEVBQWdCO1VBQ3RGLElBQUlBLElBQUksQ0FBQ2tOLFdBQVQsRUFDRTtZQUFFLENBQUNnc0IsUUFBUSxLQUFLQSxRQUFRLEdBQUduM0MsTUFBTSxDQUFDLFdBQVcra0IsR0FBRyxDQUFDajNELEVBQWhCLENBQU4sR0FBNEIsRUFBNUMsQ0FBVCxFQUEwRGdQLENBQTFELElBQStEbWhELElBQUksQ0FBQ2tOLFdBQXBFOzs7VUFDSixFQUFFcnVELENBQUY7U0FIRjtPQWoySmlCOzs7O01BMDJKbkIsU0FBU3M2RSxrQkFBVCxDQUE0QnZzQixLQUE1QixFQUFtQztRQUNqQyxJQUFJLENBQUNBLEtBQUwsRUFBWTtVQUFFLE9BQU8sSUFBUDs7O1FBQ2QsSUFBSWg2RCxHQUFKOztRQUNBLEtBQUssSUFBSWEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR201RCxLQUFLLENBQUN2N0QsTUFBMUIsRUFBa0MsRUFBRW9DLENBQXBDLEVBQXVDO1VBQ3JDLElBQUltNUQsS0FBSyxDQUFDbjVELENBQUQsQ0FBTCxDQUFTMm1DLE1BQVQsQ0FBZ0JnL0MsaUJBQXBCLEVBQXVDO1lBQUUsSUFBSSxDQUFDeG1GLEdBQUwsRUFBVTtjQUFFQSxHQUFHLEdBQUdnNkQsS0FBSyxDQUFDOTNELEtBQU4sQ0FBWSxDQUFaLEVBQWVyQixDQUFmLENBQU47O1dBQXJELE1BQ0ssSUFBSWIsR0FBSixFQUFTO1lBQUVBLEdBQUcsQ0FBQ3hDLElBQUosQ0FBU3c4RCxLQUFLLENBQUNuNUQsQ0FBRCxDQUFkOzs7O1FBRWxCLE9BQU8sQ0FBQ2IsR0FBRCxHQUFPZzZELEtBQVAsR0FBZWg2RCxHQUFHLENBQUN2QixNQUFKLEdBQWF1QixHQUFiLEdBQW1CLElBQXpDO09BajNKaUI7OztNQXEzSm5CLFNBQVN5bUYsV0FBVCxDQUFxQnZ5QixHQUFyQixFQUEwQi9rQixNQUExQixFQUFrQztRQUNoQyxJQUFJMGIsS0FBSyxHQUFHMWIsTUFBTSxDQUFDLFdBQVcra0IsR0FBRyxDQUFDajNELEVBQWhCLENBQWxCOztRQUNBLElBQUksQ0FBQzR0RCxLQUFMLEVBQVk7VUFBRSxPQUFPLElBQVA7OztRQUNkLElBQUk4UCxFQUFFLEdBQUcsRUFBVDs7UUFDQSxLQUFLLElBQUk5NUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3N1QyxNQUFNLENBQUMwTixJQUFQLENBQVlwK0MsTUFBaEMsRUFBd0MsRUFBRW9DLENBQTFDLEVBQ0U7VUFBRTg1RCxFQUFFLENBQUNuOUQsSUFBSCxDQUFRK29GLGtCQUFrQixDQUFDMTdCLEtBQUssQ0FBQ2hxRCxDQUFELENBQU4sQ0FBMUI7OztRQUNKLE9BQU84NUQsRUFBUDtPQTMzSmlCOzs7Ozs7TUFrNEpuQixTQUFTK3JCLGFBQVQsQ0FBdUJ4eUIsR0FBdkIsRUFBNEIva0IsTUFBNUIsRUFBb0M7UUFDbEMsSUFBSW9ELEdBQUcsR0FBR2swQyxXQUFXLENBQUN2eUIsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBckI7UUFDQSxJQUFJdzNDLFNBQVMsR0FBR3hyQixzQkFBc0IsQ0FBQ2pILEdBQUQsRUFBTS9rQixNQUFOLENBQXRDOztRQUNBLElBQUksQ0FBQ29ELEdBQUwsRUFBVTtVQUFFLE9BQU9vMEMsU0FBUDs7O1FBQ1osSUFBSSxDQUFDQSxTQUFMLEVBQWdCO1VBQUUsT0FBT3AwQyxHQUFQOzs7UUFFbEIsS0FBSyxJQUFJMXhDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcweEMsR0FBRyxDQUFDOXpDLE1BQXhCLEVBQWdDLEVBQUVvQyxDQUFsQyxFQUFxQztVQUNuQyxJQUFJK2xGLE1BQU0sR0FBR3IwQyxHQUFHLENBQUMxeEMsQ0FBRCxDQUFoQjtjQUFxQmdtRixVQUFVLEdBQUdGLFNBQVMsQ0FBQzlsRixDQUFELENBQTNDOztVQUNBLElBQUkrbEYsTUFBTSxJQUFJQyxVQUFkLEVBQTBCO1lBQ3hCN3NCLEtBQUssRUFBRSxLQUFLLElBQUlueEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2crRSxVQUFVLENBQUNwb0YsTUFBL0IsRUFBdUMsRUFBRW9LLENBQXpDLEVBQTRDO2NBQ2pELElBQUlveEQsSUFBSSxHQUFHNHNCLFVBQVUsQ0FBQ2grRSxDQUFELENBQXJCOztjQUNBLEtBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzY5RSxNQUFNLENBQUNub0YsTUFBM0IsRUFBbUMsRUFBRXNLLENBQXJDLEVBQ0U7Z0JBQUUsSUFBSTY5RSxNQUFNLENBQUM3OUUsQ0FBRCxDQUFOLENBQVV5K0IsTUFBVixJQUFvQnl5QixJQUFJLENBQUN6eUIsTUFBN0IsRUFBcUM7a0JBQUUsU0FBU3d5QixLQUFUOzs7O2NBQzNDNHNCLE1BQU0sQ0FBQ3BwRixJQUFQLENBQVl5OEQsSUFBWjs7V0FMSixNQU9PLElBQUk0c0IsVUFBSixFQUFnQjtZQUNyQnQwQyxHQUFHLENBQUMxeEMsQ0FBRCxDQUFILEdBQVNnbUYsVUFBVDs7OztRQUdKLE9BQU90MEMsR0FBUDtPQXI1SmlCOzs7O01BMDVKbkIsU0FBU3UwQyxnQkFBVCxDQUEwQnZKLE1BQTFCLEVBQWtDd0osUUFBbEMsRUFBNENDLGNBQTVDLEVBQTREO1FBQzFELElBQUl4d0IsSUFBSSxHQUFHLEVBQVg7O1FBQ0EsS0FBSyxJQUFJMzFELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwOEUsTUFBTSxDQUFDOStFLE1BQTNCLEVBQW1DLEVBQUVvQyxDQUFyQyxFQUF3QztVQUN0QyxJQUFJc2xCLEtBQUssR0FBR28zRCxNQUFNLENBQUMxOEUsQ0FBRCxDQUFsQjs7VUFDQSxJQUFJc2xCLEtBQUssQ0FBQ3VxRCxNQUFWLEVBQWtCO1lBQ2hCbGEsSUFBSSxDQUFDaDVELElBQUwsQ0FBVXdwRixjQUFjLEdBQUduRixTQUFTLENBQUN0akYsU0FBVixDQUFvQjBqRixRQUFwQixDQUE2QnRuRixJQUE3QixDQUFrQ3dyQixLQUFsQyxDQUFILEdBQThDQSxLQUF0RTtZQUNBOzs7VUFFRixJQUFJczlDLE9BQU8sR0FBR3Q5QyxLQUFLLENBQUNzOUMsT0FBcEI7Y0FBNkJ3akIsVUFBVSxHQUFHLEVBQTFDO1VBQ0F6d0IsSUFBSSxDQUFDaDVELElBQUwsQ0FBVTtZQUFDaW1FLE9BQU8sRUFBRXdqQjtXQUFwQjs7VUFDQSxLQUFLLElBQUlwK0UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzQ2RCxPQUFPLENBQUNobEUsTUFBNUIsRUFBb0MsRUFBRW9LLENBQXRDLEVBQXlDO1lBQ3ZDLElBQUlzbUMsTUFBTSxHQUFHczBCLE9BQU8sQ0FBQzU2RCxDQUFELENBQXBCO2dCQUF5QitILENBQUMsR0FBSSxLQUFLLENBQW5DO1lBQ0FxMkUsVUFBVSxDQUFDenBGLElBQVgsQ0FBZ0I7Y0FBQ29kLElBQUksRUFBRXUwQixNQUFNLENBQUN2MEIsSUFBZDtjQUFvQndELEVBQUUsRUFBRSt3QixNQUFNLENBQUMvd0IsRUFBL0I7Y0FBbUN5K0IsSUFBSSxFQUFFMU4sTUFBTSxDQUFDME47YUFBaEU7O1lBQ0EsSUFBSWtxQyxRQUFKLEVBQWM7Y0FBRSxLQUFLLElBQUloL0IsSUFBVCxJQUFpQjVZLE1BQWpCLEVBQXlCO2dCQUFFLElBQUl2K0IsQ0FBQyxHQUFHbTNDLElBQUksQ0FBQ3Q3QyxLQUFMLENBQVcsZUFBWCxDQUFSLEVBQXFDO2tCQUM5RSxJQUFJaUwsT0FBTyxDQUFDcXZFLFFBQUQsRUFBVzczRSxNQUFNLENBQUMwQixDQUFDLENBQUMsQ0FBRCxDQUFGLENBQWpCLENBQVAsR0FBa0MsQ0FBQyxDQUF2QyxFQUEwQztvQkFDeEMyNEMsR0FBRyxDQUFDMDlCLFVBQUQsQ0FBSCxDQUFnQmwvQixJQUFoQixJQUF3QjVZLE1BQU0sQ0FBQzRZLElBQUQsQ0FBOUI7b0JBQ0EsT0FBTzVZLE1BQU0sQ0FBQzRZLElBQUQsQ0FBYjs7Ozs7Ozs7UUFLUixPQUFPeU8sSUFBUDtPQS82SmlCOzs7Ozs7Ozs7TUEwN0puQixTQUFTMHdCLFdBQVQsQ0FBcUJ0cEMsS0FBckIsRUFBNEJ2MkIsSUFBNUIsRUFBa0NxbEQsS0FBbEMsRUFBeUNtUixNQUF6QyxFQUFpRDtRQUMvQyxJQUFJQSxNQUFKLEVBQVk7VUFDVixJQUFJMWxFLE1BQU0sR0FBR3lsQyxLQUFLLENBQUN6bEMsTUFBbkI7O1VBQ0EsSUFBSXUwRCxLQUFKLEVBQVc7WUFDVCxJQUFJeWEsU0FBUyxHQUFHN3hCLEdBQUcsQ0FBQ2p1QyxJQUFELEVBQU9sUCxNQUFQLENBQUgsR0FBb0IsQ0FBcEM7O1lBQ0EsSUFBSWd2RSxTQUFTLElBQUs3eEIsR0FBRyxDQUFDb1gsS0FBRCxFQUFRdjBELE1BQVIsQ0FBSCxHQUFxQixDQUF2QyxFQUEyQztjQUN6Q0EsTUFBTSxHQUFHa1AsSUFBVDtjQUNBQSxJQUFJLEdBQUdxbEQsS0FBUDthQUZGLE1BR08sSUFBSXlhLFNBQVMsSUFBSzd4QixHQUFHLENBQUNqdUMsSUFBRCxFQUFPcWxELEtBQVAsQ0FBSCxHQUFtQixDQUFyQyxFQUF5QztjQUM5Q3JsRCxJQUFJLEdBQUdxbEQsS0FBUDs7OztVQUdKLE9BQU8sSUFBSXdWLEtBQUosQ0FBVS9wRSxNQUFWLEVBQWtCa1AsSUFBbEIsQ0FBUDtTQVhGLE1BWU87VUFDTCxPQUFPLElBQUk2NkQsS0FBSixDQUFVeFYsS0FBSyxJQUFJcmxELElBQW5CLEVBQXlCQSxJQUF6QixDQUFQOztPQXg4SmU7OztNQTY4Sm5CLFNBQVMrL0QsZUFBVCxDQUF5Qmx6QixHQUF6QixFQUE4QjdzQyxJQUE5QixFQUFvQ3FsRCxLQUFwQyxFQUEyQzNqQyxPQUEzQyxFQUFvRDgwQyxNQUFwRCxFQUE0RDtRQUMxRCxJQUFJQSxNQUFNLElBQUksSUFBZCxFQUFvQjtVQUFFQSxNQUFNLEdBQUczcEIsR0FBRyxDQUFDbEcsRUFBSixLQUFXa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPL29ELE9BQVAsQ0FBZTh1RSxLQUFmLElBQXdCN2YsR0FBRyxDQUFDMnBCLE1BQXZDLENBQVQ7OztRQUN0QndKLFlBQVksQ0FBQ256QixHQUFELEVBQU0sSUFBSTJ0QixTQUFKLENBQWMsQ0FBQ3FGLFdBQVcsQ0FBQ2h6QixHQUFHLENBQUN1YyxHQUFKLENBQVFKLE9BQVIsRUFBRCxFQUFvQmhwRCxJQUFwQixFQUEwQnFsRCxLQUExQixFQUFpQ21SLE1BQWpDLENBQVosQ0FBZCxFQUFxRSxDQUFyRSxDQUFOLEVBQStFOTBDLE9BQS9FLENBQVo7T0EvOEppQjs7OztNQW85Sm5CLFNBQVN1K0MsZ0JBQVQsQ0FBMEJwekIsR0FBMUIsRUFBK0JxekIsS0FBL0IsRUFBc0N4K0MsT0FBdEMsRUFBK0M7UUFDN0MsSUFBSS9vQyxHQUFHLEdBQUcsRUFBVjtRQUNBLElBQUk2OUUsTUFBTSxHQUFHM3BCLEdBQUcsQ0FBQ2xHLEVBQUosS0FBV2tHLEdBQUcsQ0FBQ2xHLEVBQUosQ0FBTy9vRCxPQUFQLENBQWU4dUUsS0FBZixJQUF3QjdmLEdBQUcsQ0FBQzJwQixNQUF2QyxDQUFiOztRQUNBLEtBQUssSUFBSWg5RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcXpELEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFlanlFLE1BQW5DLEVBQTJDb0MsQ0FBQyxFQUE1QyxFQUNFO1VBQUViLEdBQUcsQ0FBQ2EsQ0FBRCxDQUFILEdBQVNxbUYsV0FBVyxDQUFDaHpCLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFlN3ZFLENBQWYsQ0FBRCxFQUFvQjBtRixLQUFLLENBQUMxbUYsQ0FBRCxDQUF6QixFQUE4QixJQUE5QixFQUFvQ2c5RSxNQUFwQyxDQUFwQjs7O1FBQ0osSUFBSTJKLE1BQU0sR0FBR3BGLGtCQUFrQixDQUFDbHVCLEdBQUcsQ0FBQ2xHLEVBQUwsRUFBU2h1RCxHQUFULEVBQWNrMEQsR0FBRyxDQUFDdWMsR0FBSixDQUFRRSxTQUF0QixDQUEvQjtRQUNBMFcsWUFBWSxDQUFDbnpCLEdBQUQsRUFBTXN6QixNQUFOLEVBQWN6K0MsT0FBZCxDQUFaO09BMTlKaUI7OztNQTg5Sm5CLFNBQVMwK0MsbUJBQVQsQ0FBNkJ2ekIsR0FBN0IsRUFBa0NyekQsQ0FBbEMsRUFBcUMrOEMsS0FBckMsRUFBNEM3VSxPQUE1QyxFQUFxRDtRQUNuRCxJQUFJMm5DLE1BQU0sR0FBR3hjLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUMsTUFBUixDQUFleHVFLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBYjtRQUNBd3VFLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sR0FBWSs4QyxLQUFaO1FBQ0F5cEMsWUFBWSxDQUFDbnpCLEdBQUQsRUFBTWt1QixrQkFBa0IsQ0FBQ2x1QixHQUFHLENBQUNsRyxFQUFMLEVBQVMwaUIsTUFBVCxFQUFpQnhjLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUUsU0FBekIsQ0FBeEIsRUFBNkQ1bkMsT0FBN0QsQ0FBWjtPQWorSmlCOzs7TUFxK0puQixTQUFTMitDLGtCQUFULENBQTRCeHpCLEdBQTVCLEVBQWlDLzdDLE1BQWpDLEVBQXlDa1AsSUFBekMsRUFBK0MwaEIsT0FBL0MsRUFBd0Q7UUFDdERzK0MsWUFBWSxDQUFDbnpCLEdBQUQsRUFBTXV1QixlQUFlLENBQUN0cUUsTUFBRCxFQUFTa1AsSUFBVCxDQUFyQixFQUFxQzBoQixPQUFyQyxDQUFaO09BdCtKaUI7Ozs7TUEyK0puQixTQUFTNCtDLHFCQUFULENBQStCenpCLEdBQS9CLEVBQW9DdWMsR0FBcEMsRUFBeUMxbkMsT0FBekMsRUFBa0Q7UUFDaEQsSUFBSWpILEdBQUcsR0FBRztVQUNSNHVDLE1BQU0sRUFBRUQsR0FBRyxDQUFDQyxNQURKO1VBRVIvNkIsTUFBTSxFQUFFLGdCQUFTKzZCLE1BQVQsRUFBaUI7WUFDdkIsS0FBS0EsTUFBTCxHQUFjLEVBQWQ7O1lBQ0EsS0FBSyxJQUFJN3ZFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQTNCLEVBQW1Db0MsQ0FBQyxFQUFwQyxFQUNFO2NBQUUsS0FBSzZ2RSxNQUFMLENBQVk3dkUsQ0FBWixJQUFpQixJQUFJcWhGLEtBQUosQ0FBVXRzQixRQUFPLENBQUMxQixHQUFELEVBQU13YyxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVVzWCxNQUFoQixDQUFqQixFQUNReTlDLFFBQU8sQ0FBQzFCLEdBQUQsRUFBTXdjLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVXdtQixJQUFoQixDQURmLENBQWpCOztXQUxFO1VBUVIwaEMsTUFBTSxFQUFFaGdCLE9BQU8sSUFBSUEsT0FBTyxDQUFDZ2dCO1NBUjdCO1FBVUE4RSxNQUFNLENBQUNxRyxHQUFELEVBQU0sdUJBQU4sRUFBK0JBLEdBQS9CLEVBQW9DcHlCLEdBQXBDLENBQU47O1FBQ0EsSUFBSW95QixHQUFHLENBQUNsRyxFQUFSLEVBQVk7VUFBRUgsTUFBTSxDQUFDcUcsR0FBRyxDQUFDbEcsRUFBTCxFQUFTLHVCQUFULEVBQWtDa0csR0FBRyxDQUFDbEcsRUFBdEMsRUFBMENsc0IsR0FBMUMsQ0FBTjs7O1FBQ2QsSUFBSUEsR0FBRyxDQUFDNHVDLE1BQUosSUFBY0QsR0FBRyxDQUFDQyxNQUF0QixFQUE4QjtVQUFFLE9BQU8wUixrQkFBa0IsQ0FBQ2x1QixHQUFHLENBQUNsRyxFQUFMLEVBQVNsc0IsR0FBRyxDQUFDNHVDLE1BQWIsRUFBcUI1dUMsR0FBRyxDQUFDNHVDLE1BQUosQ0FBV2p5RSxNQUFYLEdBQW9CLENBQXpDLENBQXpCO1NBQWhDLE1BQ0s7VUFBRSxPQUFPZ3lFLEdBQVA7Ozs7TUFHVCxTQUFTbVgsMEJBQVQsQ0FBb0MxekIsR0FBcEMsRUFBeUN1YyxHQUF6QyxFQUE4QzFuQyxPQUE5QyxFQUF1RDtRQUNyRCxJQUFJcHlCLElBQUksR0FBR3U5QyxHQUFHLENBQUM2eEIsT0FBSixDQUFZcHZFLElBQXZCO1lBQTZCMlEsSUFBSSxHQUFHaWlDLEdBQUcsQ0FBQzV5QyxJQUFELENBQXZDOztRQUNBLElBQUkyUSxJQUFJLElBQUlBLElBQUksQ0FBQ29wRCxNQUFqQixFQUF5QjtVQUN2Qi81RCxJQUFJLENBQUNBLElBQUksQ0FBQ2xZLE1BQUwsR0FBYyxDQUFmLENBQUosR0FBd0JneUUsR0FBeEI7VUFDQW9YLGtCQUFrQixDQUFDM3pCLEdBQUQsRUFBTXVjLEdBQU4sRUFBVzFuQyxPQUFYLENBQWxCO1NBRkYsTUFHTztVQUNMcytDLFlBQVksQ0FBQ256QixHQUFELEVBQU11YyxHQUFOLEVBQVcxbkMsT0FBWCxDQUFaOztPQWxnS2U7OztNQXVnS25CLFNBQVNzK0MsWUFBVCxDQUFzQm56QixHQUF0QixFQUEyQnVjLEdBQTNCLEVBQWdDMW5DLE9BQWhDLEVBQXlDO1FBQ3ZDOCtDLGtCQUFrQixDQUFDM3pCLEdBQUQsRUFBTXVjLEdBQU4sRUFBVzFuQyxPQUFYLENBQWxCO1FBQ0FvOUMscUJBQXFCLENBQUNqeUIsR0FBRCxFQUFNQSxHQUFHLENBQUN1YyxHQUFWLEVBQWV2YyxHQUFHLENBQUNsRyxFQUFKLEdBQVNrRyxHQUFHLENBQUNsRyxFQUFKLENBQU9PLEtBQVAsQ0FBYXR4RCxFQUF0QixHQUEyQjhSLEdBQTFDLEVBQStDZzZCLE9BQS9DLENBQXJCOzs7TUFHRixTQUFTOCtDLGtCQUFULENBQTRCM3pCLEdBQTVCLEVBQWlDdWMsR0FBakMsRUFBc0MxbkMsT0FBdEMsRUFBK0M7UUFDN0MsSUFBSTBsQixVQUFVLENBQUN5RixHQUFELEVBQU0sdUJBQU4sQ0FBVixJQUE0Q0EsR0FBRyxDQUFDbEcsRUFBSixJQUFVUyxVQUFVLENBQUN5RixHQUFHLENBQUNsRyxFQUFMLEVBQVMsdUJBQVQsQ0FBcEUsRUFDRTtVQUFFeWlCLEdBQUcsR0FBR2tYLHFCQUFxQixDQUFDenpCLEdBQUQsRUFBTXVjLEdBQU4sRUFBVzFuQyxPQUFYLENBQTNCOzs7UUFFSixJQUFJMC9CLElBQUksR0FBRzEvQixPQUFPLElBQUlBLE9BQU8sQ0FBQzAvQixJQUFuQixLQUNSblQsR0FBRyxDQUFDbWIsR0FBRyxDQUFDSixPQUFKLEdBQWNocEQsSUFBZixFQUFxQjZzQyxHQUFHLENBQUN1YyxHQUFKLENBQVFKLE9BQVIsR0FBa0JocEQsSUFBdkMsQ0FBSCxHQUFrRCxDQUFsRCxHQUFzRCxDQUFDLENBQXZELEdBQTJELENBRG5ELENBQVg7UUFFQXlnRSxpQkFBaUIsQ0FBQzV6QixHQUFELEVBQU02ekIscUJBQXFCLENBQUM3ekIsR0FBRCxFQUFNdWMsR0FBTixFQUFXaEksSUFBWCxFQUFpQixJQUFqQixDQUEzQixDQUFqQjs7UUFFQSxJQUFJLEVBQUUxL0IsT0FBTyxJQUFJQSxPQUFPLENBQUM4ZixNQUFSLEtBQW1CLEtBQWhDLEtBQTBDcUwsR0FBRyxDQUFDbEcsRUFBOUMsSUFBb0RrRyxHQUFHLENBQUNsRyxFQUFKLENBQU8yUixTQUFQLENBQWlCLFVBQWpCLEtBQWdDLFVBQXhGLEVBQ0U7VUFBRTZXLG1CQUFtQixDQUFDdGlCLEdBQUcsQ0FBQ2xHLEVBQUwsQ0FBbkI7Ozs7TUFHTixTQUFTODVCLGlCQUFULENBQTJCNXpCLEdBQTNCLEVBQWdDdWMsR0FBaEMsRUFBcUM7UUFDbkMsSUFBSUEsR0FBRyxDQUFDcVIsTUFBSixDQUFXNXRCLEdBQUcsQ0FBQ3VjLEdBQWYsQ0FBSixFQUF5QjtVQUFFOzs7UUFFM0J2YyxHQUFHLENBQUN1YyxHQUFKLEdBQVVBLEdBQVY7O1FBRUEsSUFBSXZjLEdBQUcsQ0FBQ2xHLEVBQVIsRUFBWTtVQUNWa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPTyxLQUFQLENBQWFnc0IsV0FBYixHQUEyQixDQUEzQjtVQUNBcm1CLEdBQUcsQ0FBQ2xHLEVBQUosQ0FBT08sS0FBUCxDQUFhbXNCLGdCQUFiLEdBQWdDLElBQWhDO1VBQ0Fyc0Isb0JBQW9CLENBQUM2RixHQUFHLENBQUNsRyxFQUFMLENBQXBCOzs7UUFFRm9WLFdBQVcsQ0FBQ2xQLEdBQUQsRUFBTSxnQkFBTixFQUF3QkEsR0FBeEIsQ0FBWDtPQWxpS2lCOzs7O01BdWlLbkIsU0FBUzh6QixnQkFBVCxDQUEwQjl6QixHQUExQixFQUErQjtRQUM3QjR6QixpQkFBaUIsQ0FBQzV6QixHQUFELEVBQU02ekIscUJBQXFCLENBQUM3ekIsR0FBRCxFQUFNQSxHQUFHLENBQUN1YyxHQUFWLEVBQWUsSUFBZixFQUFxQixLQUFyQixDQUEzQixDQUFqQjtPQXhpS2lCOzs7O01BNmlLbkIsU0FBU3NYLHFCQUFULENBQStCN3pCLEdBQS9CLEVBQW9DdWMsR0FBcEMsRUFBeUNoSSxJQUF6QyxFQUErQ3dmLFFBQS9DLEVBQXlEO1FBQ3ZELElBQUlqb0YsR0FBSjs7UUFDQSxLQUFLLElBQUlhLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0dkUsR0FBRyxDQUFDQyxNQUFKLENBQVdqeUUsTUFBL0IsRUFBdUNvQyxDQUFDLEVBQXhDLEVBQTRDO1VBQzFDLElBQUkrOEMsS0FBSyxHQUFHNnlCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXN3ZFLENBQVgsQ0FBWjtVQUNBLElBQUkweEMsR0FBRyxHQUFHaytCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXanlFLE1BQVgsSUFBcUJ5MUQsR0FBRyxDQUFDdWMsR0FBSixDQUFRQyxNQUFSLENBQWVqeUUsTUFBcEMsSUFBOEN5MUQsR0FBRyxDQUFDdWMsR0FBSixDQUFRQyxNQUFSLENBQWU3dkUsQ0FBZixDQUF4RDtVQUNBLElBQUlxbkYsU0FBUyxHQUFHQyxVQUFVLENBQUNqMEIsR0FBRCxFQUFNdFcsS0FBSyxDQUFDemxDLE1BQVosRUFBb0JvNkIsR0FBRyxJQUFJQSxHQUFHLENBQUNwNkIsTUFBL0IsRUFBdUNzd0QsSUFBdkMsRUFBNkN3ZixRQUE3QyxDQUExQjtVQUNBLElBQUlHLE9BQU8sR0FBR0QsVUFBVSxDQUFDajBCLEdBQUQsRUFBTXRXLEtBQUssQ0FBQ3YyQixJQUFaLEVBQWtCa3JCLEdBQUcsSUFBSUEsR0FBRyxDQUFDbHJCLElBQTdCLEVBQW1Db2hELElBQW5DLEVBQXlDd2YsUUFBekMsQ0FBeEI7O1VBQ0EsSUFBSWpvRixHQUFHLElBQUlrb0YsU0FBUyxJQUFJdHFDLEtBQUssQ0FBQ3psQyxNQUExQixJQUFvQ2l3RSxPQUFPLElBQUl4cUMsS0FBSyxDQUFDdjJCLElBQXpELEVBQStEO1lBQzdELElBQUksQ0FBQ3JuQixHQUFMLEVBQVU7Y0FBRUEsR0FBRyxHQUFHeXdFLEdBQUcsQ0FBQ0MsTUFBSixDQUFXeHVFLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0JyQixDQUFwQixDQUFOOzs7WUFDWmIsR0FBRyxDQUFDYSxDQUFELENBQUgsR0FBUyxJQUFJcWhGLEtBQUosQ0FBVWdHLFNBQVYsRUFBcUJFLE9BQXJCLENBQVQ7Ozs7UUFHSixPQUFPcG9GLEdBQUcsR0FBR29pRixrQkFBa0IsQ0FBQ2x1QixHQUFHLENBQUNsRyxFQUFMLEVBQVNodUQsR0FBVCxFQUFjeXdFLEdBQUcsQ0FBQ0UsU0FBbEIsQ0FBckIsR0FBb0RGLEdBQTlEOzs7TUFHRixTQUFTNFgsZUFBVCxDQUF5Qm4wQixHQUF6QixFQUE4QnYvQyxHQUE5QixFQUFtQzJ6RSxNQUFuQyxFQUEyQ2grQixHQUEzQyxFQUFnRDI5QixRQUFoRCxFQUEwRDtRQUN4RCxJQUFJNzZCLElBQUksR0FBRzZHLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNdi9DLEdBQUcsQ0FBQ3k0QyxJQUFWLENBQWxCOztRQUNBLElBQUlBLElBQUksQ0FBQ2tOLFdBQVQsRUFBc0I7VUFBRSxLQUFLLElBQUl6NUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VzRCxJQUFJLENBQUNrTixXQUFMLENBQWlCNzdELE1BQXJDLEVBQTZDLEVBQUVvQyxDQUEvQyxFQUFrRDtZQUN4RSxJQUFJczhELEVBQUUsR0FBRy9QLElBQUksQ0FBQ2tOLFdBQUwsQ0FBaUJ6NUQsQ0FBakIsQ0FBVDtnQkFBOEIrUCxDQUFDLEdBQUd1c0QsRUFBRSxDQUFDMzFCLE1BQXJDLENBRHdFOzs7O1lBTXhFLElBQUkrZ0QsaUJBQWlCLEdBQUksZ0JBQWdCMzNFLENBQWpCLEdBQXNCLENBQUNBLENBQUMsQ0FBQzQzRSxVQUF6QixHQUFzQzUzRSxDQUFDLENBQUNpcUQsYUFBaEU7WUFDQSxJQUFJNHRCLGtCQUFrQixHQUFJLGlCQUFpQjczRSxDQUFsQixHQUF1QixDQUFDQSxDQUFDLENBQUM4M0UsV0FBMUIsR0FBd0M5M0UsQ0FBQyxDQUFDb3FELGNBQW5FOztZQUVBLElBQUksQ0FBQ21DLEVBQUUsQ0FBQ3ZpRCxJQUFILElBQVcsSUFBWCxLQUFvQjJ0RSxpQkFBaUIsR0FBR3ByQixFQUFFLENBQUN2aUQsSUFBSCxJQUFXakcsR0FBRyxDQUFDMk8sRUFBbEIsR0FBdUI2NUMsRUFBRSxDQUFDdmlELElBQUgsR0FBVWpHLEdBQUcsQ0FBQzJPLEVBQTFFLENBQUQsTUFDQzY1QyxFQUFFLENBQUMvK0MsRUFBSCxJQUFTLElBQVQsS0FBa0JxcUUsa0JBQWtCLEdBQUd0ckIsRUFBRSxDQUFDLytDLEVBQUgsSUFBU3pKLEdBQUcsQ0FBQzJPLEVBQWhCLEdBQXFCNjVDLEVBQUUsQ0FBQy8rQyxFQUFILEdBQVF6SixHQUFHLENBQUMyTyxFQUFyRSxDQURELENBQUosRUFDZ0Y7Y0FDOUUsSUFBSTJrRSxRQUFKLEVBQWM7Z0JBQ1pwNkIsTUFBTSxDQUFDajlDLENBQUQsRUFBSSxtQkFBSixDQUFOOztnQkFDQSxJQUFJQSxDQUFDLENBQUM0MUUsaUJBQU4sRUFBeUI7a0JBQ3ZCLElBQUksQ0FBQ3A1QixJQUFJLENBQUNrTixXQUFWLEVBQXVCO29CQUFFO21CQUF6QixNQUNLO29CQUFDLEVBQUV6NUQsQ0FBRjtvQkFBSzs7Ozs7Y0FHZixJQUFJLENBQUMrUCxDQUFDLENBQUMrM0UsTUFBUCxFQUFlO2dCQUFFOzs7Y0FFakIsSUFBSUwsTUFBSixFQUFZO2dCQUNWLElBQUlNLElBQUksR0FBR2g0RSxDQUFDLENBQUMrTixJQUFGLENBQU8yckMsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWMsQ0FBQyxDQUF0QixDQUFYO29CQUFxQ3FLLElBQUksR0FBSSxLQUFLLENBQWxEOztnQkFDQSxJQUFJckssR0FBRyxHQUFHLENBQU4sR0FBVW0rQixrQkFBVixHQUErQkYsaUJBQW5DLEVBQ0U7a0JBQUVLLElBQUksR0FBR0MsT0FBTyxDQUFDMzBCLEdBQUQsRUFBTTAwQixJQUFOLEVBQVksQ0FBQ3QrQixHQUFiLEVBQWtCcytCLElBQUksSUFBSUEsSUFBSSxDQUFDeDdCLElBQUwsSUFBYXo0QyxHQUFHLENBQUN5NEMsSUFBekIsR0FBZ0NBLElBQWhDLEdBQXVDLElBQXpELENBQWQ7OztnQkFDSixJQUFJdzdCLElBQUksSUFBSUEsSUFBSSxDQUFDeDdCLElBQUwsSUFBYXo0QyxHQUFHLENBQUN5NEMsSUFBekIsS0FBa0N1SCxJQUFJLEdBQUdXLEdBQUcsQ0FBQ3N6QixJQUFELEVBQU9OLE1BQVAsQ0FBNUMsTUFBZ0VoK0IsR0FBRyxHQUFHLENBQU4sR0FBVXFLLElBQUksR0FBRyxDQUFqQixHQUFxQkEsSUFBSSxHQUFHLENBQTVGLENBQUosRUFDRTtrQkFBRSxPQUFPMHpCLGVBQWUsQ0FBQ24wQixHQUFELEVBQU0wMEIsSUFBTixFQUFZajBFLEdBQVosRUFBaUIyMUMsR0FBakIsRUFBc0IyOUIsUUFBdEIsQ0FBdEI7Ozs7Y0FHTixJQUFJYSxHQUFHLEdBQUdsNEUsQ0FBQyxDQUFDK04sSUFBRixDQUFPMnJDLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBQyxDQUFYLEdBQWUsQ0FBdEIsQ0FBVjs7Y0FDQSxJQUFJQSxHQUFHLEdBQUcsQ0FBTixHQUFVaStCLGlCQUFWLEdBQThCRSxrQkFBbEMsRUFDRTtnQkFBRUssR0FBRyxHQUFHRCxPQUFPLENBQUMzMEIsR0FBRCxFQUFNNDBCLEdBQU4sRUFBV3grQixHQUFYLEVBQWdCdytCLEdBQUcsQ0FBQzE3QixJQUFKLElBQVl6NEMsR0FBRyxDQUFDeTRDLElBQWhCLEdBQXVCQSxJQUF2QixHQUE4QixJQUE5QyxDQUFiOzs7Y0FDSixPQUFPMDdCLEdBQUcsR0FBR1QsZUFBZSxDQUFDbjBCLEdBQUQsRUFBTTQwQixHQUFOLEVBQVduMEUsR0FBWCxFQUFnQjIxQyxHQUFoQixFQUFxQjI5QixRQUFyQixDQUFsQixHQUFtRCxJQUE3RDs7Ozs7UUFHSixPQUFPdHpFLEdBQVA7T0FobUtpQjs7O01Bb21LbkIsU0FBU3d6RSxVQUFULENBQW9CajBCLEdBQXBCLEVBQXlCdi9DLEdBQXpCLEVBQThCMnpFLE1BQTlCLEVBQXNDN2YsSUFBdEMsRUFBNEN3ZixRQUE1QyxFQUFzRDtRQUNwRCxJQUFJMzlCLEdBQUcsR0FBR21lLElBQUksSUFBSSxDQUFsQjtRQUNBLElBQUk1ZCxLQUFLLEdBQUd3OUIsZUFBZSxDQUFDbjBCLEdBQUQsRUFBTXYvQyxHQUFOLEVBQVcyekUsTUFBWCxFQUFtQmgrQixHQUFuQixFQUF3QjI5QixRQUF4QixDQUFmLElBQ1AsQ0FBQ0EsUUFBRCxJQUFhSSxlQUFlLENBQUNuMEIsR0FBRCxFQUFNdi9DLEdBQU4sRUFBVzJ6RSxNQUFYLEVBQW1CaCtCLEdBQW5CLEVBQXdCLElBQXhCLENBRHJCLElBRVIrOUIsZUFBZSxDQUFDbjBCLEdBQUQsRUFBTXYvQyxHQUFOLEVBQVcyekUsTUFBWCxFQUFtQixDQUFDaCtCLEdBQXBCLEVBQXlCMjlCLFFBQXpCLENBRlAsSUFHUCxDQUFDQSxRQUFELElBQWFJLGVBQWUsQ0FBQ24wQixHQUFELEVBQU12L0MsR0FBTixFQUFXMnpFLE1BQVgsRUFBbUIsQ0FBQ2grQixHQUFwQixFQUF5QixJQUF6QixDQUhqQzs7UUFJQSxJQUFJLENBQUNPLEtBQUwsRUFBWTtVQUNWcUosR0FBRyxDQUFDNjBCLFFBQUosR0FBZSxJQUFmO1VBQ0EsT0FBTzF6QixHQUFHLENBQUNuQixHQUFHLENBQUN2bEQsS0FBTCxFQUFZLENBQVosQ0FBVjs7O1FBRUYsT0FBT2s4QyxLQUFQOzs7TUFHRixTQUFTZytCLE9BQVQsQ0FBaUIzMEIsR0FBakIsRUFBc0J2L0MsR0FBdEIsRUFBMkIyMUMsR0FBM0IsRUFBZ0M4QyxJQUFoQyxFQUFzQztRQUNwQyxJQUFJOUMsR0FBRyxHQUFHLENBQU4sSUFBVzMxQyxHQUFHLENBQUMyTyxFQUFKLElBQVUsQ0FBekIsRUFBNEI7VUFDMUIsSUFBSTNPLEdBQUcsQ0FBQ3k0QyxJQUFKLEdBQVc4RyxHQUFHLENBQUN2bEQsS0FBbkIsRUFBMEI7WUFBRSxPQUFPaW5ELFFBQU8sQ0FBQzFCLEdBQUQsRUFBTW1CLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBSixHQUFXLENBQVosQ0FBVCxDQUFkO1dBQTVCLE1BQ0s7WUFBRSxPQUFPLElBQVA7O1NBRlQsTUFHTyxJQUFJOUMsR0FBRyxHQUFHLENBQU4sSUFBVzMxQyxHQUFHLENBQUMyTyxFQUFKLElBQVUsQ0FBQzhwQyxJQUFJLElBQUk2RyxPQUFPLENBQUNDLEdBQUQsRUFBTXYvQyxHQUFHLENBQUN5NEMsSUFBVixDQUFoQixFQUFpQ3ZRLElBQWpDLENBQXNDcCtDLE1BQS9ELEVBQXVFO1VBQzVFLElBQUlrVyxHQUFHLENBQUN5NEMsSUFBSixHQUFXOEcsR0FBRyxDQUFDdmxELEtBQUosR0FBWXVsRCxHQUFHLENBQUN2N0MsSUFBaEIsR0FBdUIsQ0FBdEMsRUFBeUM7WUFBRSxPQUFPMDhDLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBSixHQUFXLENBQVosRUFBZSxDQUFmLENBQVY7V0FBM0MsTUFDSztZQUFFLE9BQU8sSUFBUDs7U0FGRixNQUdBO1VBQ0wsT0FBTyxJQUFJaUksR0FBSixDQUFRMWdELEdBQUcsQ0FBQ3k0QyxJQUFaLEVBQWtCejRDLEdBQUcsQ0FBQzJPLEVBQUosR0FBU2duQyxHQUEzQixDQUFQOzs7O01BSUosU0FBUzArQixTQUFULENBQW1CaDdCLEVBQW5CLEVBQXVCO1FBQ3JCQSxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQmh5QixHQUFHLENBQUNySCxFQUFFLENBQUN5MUIsU0FBSCxFQUFELEVBQWlCLENBQWpCLENBQW5CLEVBQXdDcHVCLEdBQUcsQ0FBQ3JILEVBQUUsQ0FBQ2lRLFFBQUgsRUFBRCxDQUEzQyxFQUE0RHJWLGNBQTVEO09BOW5LaUI7Ozs7TUFvb0tuQixTQUFTcWdDLFlBQVQsQ0FBc0IvMEIsR0FBdEIsRUFBMkIva0IsTUFBM0IsRUFBbUN3RyxNQUFuQyxFQUEyQztRQUN6QyxJQUFJN1QsR0FBRyxHQUFHO1VBQ1JvbkQsUUFBUSxFQUFFLEtBREY7VUFFUnR1RSxJQUFJLEVBQUV1MEIsTUFBTSxDQUFDdjBCLElBRkw7VUFHUndELEVBQUUsRUFBRSt3QixNQUFNLENBQUMvd0IsRUFISDtVQUlSeStCLElBQUksRUFBRTFOLE1BQU0sQ0FBQzBOLElBSkw7VUFLUmtNLE1BQU0sRUFBRTVaLE1BQU0sQ0FBQzRaLE1BTFA7VUFNUm9nQyxNQUFNLEVBQUUsa0JBQVk7WUFBRSxPQUFPcm5ELEdBQUcsQ0FBQ29uRCxRQUFKLEdBQWUsSUFBdEI7O1NBTnhCOztRQVFBLElBQUl2ekMsTUFBSixFQUFZO1VBQUU3VCxHQUFHLENBQUM2VCxNQUFKLEdBQWEsVUFBVS82QixJQUFWLEVBQWdCd0QsRUFBaEIsRUFBb0J5K0IsSUFBcEIsRUFBMEJrTSxNQUExQixFQUFrQztZQUMzRCxJQUFJbnVDLElBQUosRUFBVTtjQUFFa25CLEdBQUcsQ0FBQ2xuQixJQUFKLEdBQVdnN0MsUUFBTyxDQUFDMUIsR0FBRCxFQUFNdDVDLElBQU4sQ0FBbEI7OztZQUNaLElBQUl3RCxFQUFKLEVBQVE7Y0FBRTBqQixHQUFHLENBQUMxakIsRUFBSixHQUFTdzNDLFFBQU8sQ0FBQzFCLEdBQUQsRUFBTTkxQyxFQUFOLENBQWhCOzs7WUFDVixJQUFJeStCLElBQUosRUFBVTtjQUFFL2EsR0FBRyxDQUFDK2EsSUFBSixHQUFXQSxJQUFYOzs7WUFDWixJQUFJa00sTUFBTSxLQUFLMXJELFNBQWYsRUFBMEI7Y0FBRXlrQyxHQUFHLENBQUNpbkIsTUFBSixHQUFhQSxNQUFiOztXQUpoQjs7O1FBTWQ4RSxNQUFNLENBQUNxRyxHQUFELEVBQU0sY0FBTixFQUFzQkEsR0FBdEIsRUFBMkJweUIsR0FBM0IsQ0FBTjs7UUFDQSxJQUFJb3lCLEdBQUcsQ0FBQ2xHLEVBQVIsRUFBWTtVQUFFSCxNQUFNLENBQUNxRyxHQUFHLENBQUNsRyxFQUFMLEVBQVMsY0FBVCxFQUF5QmtHLEdBQUcsQ0FBQ2xHLEVBQTdCLEVBQWlDbHNCLEdBQWpDLENBQU47OztRQUVkLElBQUlBLEdBQUcsQ0FBQ29uRCxRQUFSLEVBQWtCO1VBQ2hCLElBQUloMUIsR0FBRyxDQUFDbEcsRUFBUixFQUFZO1lBQUVrRyxHQUFHLENBQUNsRyxFQUFKLENBQU9PLEtBQVAsQ0FBYWdzQixXQUFiLEdBQTJCLENBQTNCOzs7VUFDZCxPQUFPLElBQVA7OztRQUVGLE9BQU87VUFBQzMvRCxJQUFJLEVBQUVrbkIsR0FBRyxDQUFDbG5CLElBQVg7VUFBaUJ3RCxFQUFFLEVBQUUwakIsR0FBRyxDQUFDMWpCLEVBQXpCO1VBQTZCeStCLElBQUksRUFBRS9hLEdBQUcsQ0FBQythLElBQXZDO1VBQTZDa00sTUFBTSxFQUFFam5CLEdBQUcsQ0FBQ2luQjtTQUFoRTtPQTFwS2lCOzs7O01BK3BLbkIsU0FBU3FnQyxVQUFULENBQW9CbDFCLEdBQXBCLEVBQXlCL2tCLE1BQXpCLEVBQWlDazZDLGNBQWpDLEVBQWlEO1FBQy9DLElBQUluMUIsR0FBRyxDQUFDbEcsRUFBUixFQUFZO1VBQ1YsSUFBSSxDQUFDa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPTyxLQUFaLEVBQW1CO1lBQUUsT0FBT3hPLFNBQVMsQ0FBQ21VLEdBQUcsQ0FBQ2xHLEVBQUwsRUFBU283QixVQUFULENBQVQsQ0FBOEJsMUIsR0FBOUIsRUFBbUMva0IsTUFBbkMsRUFBMkNrNkMsY0FBM0MsQ0FBUDs7O1VBQ3JCLElBQUluMUIsR0FBRyxDQUFDbEcsRUFBSixDQUFPOXBCLEtBQVAsQ0FBYW9sRCxhQUFqQixFQUFnQztZQUFFOzs7O1FBR3BDLElBQUk3NkIsVUFBVSxDQUFDeUYsR0FBRCxFQUFNLGNBQU4sQ0FBVixJQUFtQ0EsR0FBRyxDQUFDbEcsRUFBSixJQUFVUyxVQUFVLENBQUN5RixHQUFHLENBQUNsRyxFQUFMLEVBQVMsY0FBVCxDQUEzRCxFQUFxRjtVQUNuRjdlLE1BQU0sR0FBRzg1QyxZQUFZLENBQUMvMEIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBYyxJQUFkLENBQXJCOztVQUNBLElBQUksQ0FBQ0EsTUFBTCxFQUFhO1lBQUU7O1NBUjhCOzs7O1FBYS9DLElBQUlweEMsS0FBSyxHQUFHMjdELGdCQUFnQixJQUFJLENBQUMydkIsY0FBckIsSUFBdUN0dEIsb0JBQW9CLENBQUM3SCxHQUFELEVBQU0va0IsTUFBTSxDQUFDdjBCLElBQWIsRUFBbUJ1MEIsTUFBTSxDQUFDL3dCLEVBQTFCLENBQXZFOztRQUNBLElBQUlyZ0IsS0FBSixFQUFXO1VBQ1QsS0FBSyxJQUFJOEMsQ0FBQyxHQUFHOUMsS0FBSyxDQUFDVSxNQUFOLEdBQWUsQ0FBNUIsRUFBK0JvQyxDQUFDLElBQUksQ0FBcEMsRUFBdUMsRUFBRUEsQ0FBekMsRUFDRTtZQUFFMG9GLGVBQWUsQ0FBQ3IxQixHQUFELEVBQU07Y0FBQ3Q1QyxJQUFJLEVBQUU3YyxLQUFLLENBQUM4QyxDQUFELENBQUwsQ0FBUytaLElBQWhCO2NBQXNCd0QsRUFBRSxFQUFFcmdCLEtBQUssQ0FBQzhDLENBQUQsQ0FBTCxDQUFTdWQsRUFBbkM7Y0FBdUN5K0IsSUFBSSxFQUFFaDhDLENBQUMsR0FBRyxDQUFDLEVBQUQsQ0FBSCxHQUFVc3VDLE1BQU0sQ0FBQzBOLElBQS9EO2NBQXFFa00sTUFBTSxFQUFFNVosTUFBTSxDQUFDNFo7YUFBMUYsQ0FBZjs7U0FGTixNQUdPO1VBQ0x3Z0MsZUFBZSxDQUFDcjFCLEdBQUQsRUFBTS9rQixNQUFOLENBQWY7Ozs7TUFJSixTQUFTbzZDLGVBQVQsQ0FBeUJyMUIsR0FBekIsRUFBOEIva0IsTUFBOUIsRUFBc0M7UUFDcEMsSUFBSUEsTUFBTSxDQUFDME4sSUFBUCxDQUFZcCtDLE1BQVosSUFBc0IsQ0FBdEIsSUFBMkIwd0MsTUFBTSxDQUFDME4sSUFBUCxDQUFZLENBQVosS0FBa0IsRUFBN0MsSUFBbUR5WSxHQUFHLENBQUNubUIsTUFBTSxDQUFDdjBCLElBQVIsRUFBY3UwQixNQUFNLENBQUMvd0IsRUFBckIsQ0FBSCxJQUErQixDQUF0RixFQUF5RjtVQUFFOzs7UUFDM0YsSUFBSXluRSxRQUFRLEdBQUdqRCxxQkFBcUIsQ0FBQzF1QixHQUFELEVBQU0va0IsTUFBTixDQUFwQztRQUNBeTJDLGtCQUFrQixDQUFDMXhCLEdBQUQsRUFBTS9rQixNQUFOLEVBQWMwMkMsUUFBZCxFQUF3QjN4QixHQUFHLENBQUNsRyxFQUFKLEdBQVNrRyxHQUFHLENBQUNsRyxFQUFKLENBQU9PLEtBQVAsQ0FBYXR4RCxFQUF0QixHQUEyQjhSLEdBQW5ELENBQWxCO1FBRUF5NkUsbUJBQW1CLENBQUN0MUIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBYzAyQyxRQUFkLEVBQXdCMXFCLHNCQUFzQixDQUFDakgsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBOUMsQ0FBbkI7UUFDQSxJQUFJczZDLE9BQU8sR0FBRyxFQUFkO1FBRUF4RixVQUFVLENBQUMvdkIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZW13QixVQUFmLEVBQTJCO1VBQ3pDLElBQUksQ0FBQ0EsVUFBRCxJQUFlM3NFLE9BQU8sQ0FBQyt4RSxPQUFELEVBQVV2MUIsR0FBRyxDQUFDNnhCLE9BQWQsQ0FBUCxJQUFpQyxDQUFDLENBQXJELEVBQXdEO1lBQ3REMkQsVUFBVSxDQUFDeDFCLEdBQUcsQ0FBQzZ4QixPQUFMLEVBQWM1MkMsTUFBZCxDQUFWO1lBQ0FzNkMsT0FBTyxDQUFDanNGLElBQVIsQ0FBYTAyRCxHQUFHLENBQUM2eEIsT0FBakI7OztVQUVGeUQsbUJBQW1CLENBQUN0MUIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBYyxJQUFkLEVBQW9CZ3NCLHNCQUFzQixDQUFDakgsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBMUMsQ0FBbkI7U0FMUSxDQUFWO09BN3JLaUI7OztNQXVzS25CLFNBQVN3NkMscUJBQVQsQ0FBK0J6MUIsR0FBL0IsRUFBb0NqMUQsSUFBcEMsRUFBMEMycUYsa0JBQTFDLEVBQThEO1FBQzVELElBQUlDLFFBQVEsR0FBRzMxQixHQUFHLENBQUNsRyxFQUFKLElBQVVrRyxHQUFHLENBQUNsRyxFQUFKLENBQU85cEIsS0FBUCxDQUFhb2xELGFBQXRDOztRQUNBLElBQUlPLFFBQVEsSUFBSSxDQUFDRCxrQkFBakIsRUFBcUM7VUFBRTs7O1FBRXZDLElBQUlqRSxJQUFJLEdBQUd6eEIsR0FBRyxDQUFDNnhCLE9BQWY7WUFBd0I1L0QsS0FBeEI7WUFBK0IwL0QsUUFBUSxHQUFHM3hCLEdBQUcsQ0FBQ3VjLEdBQTlDO1FBQ0EsSUFBSXR4RSxNQUFNLEdBQUdGLElBQUksSUFBSSxNQUFSLEdBQWlCMG1GLElBQUksQ0FBQ2h2RSxJQUF0QixHQUE2Qmd2RSxJQUFJLENBQUNmLE1BQS9DO1lBQXVEeUIsSUFBSSxHQUFHcG5GLElBQUksSUFBSSxNQUFSLEdBQWlCMG1GLElBQUksQ0FBQ2YsTUFBdEIsR0FBK0JlLElBQUksQ0FBQ2h2RSxJQUFsRyxDQUw0RDs7O1FBUzVELElBQUk5VixDQUFDLEdBQUcsQ0FBUjs7UUFDQSxPQUFPQSxDQUFDLEdBQUcxQixNQUFNLENBQUNWLE1BQWxCLEVBQTBCb0MsQ0FBQyxFQUEzQixFQUErQjtVQUM3QnNsQixLQUFLLEdBQUdobkIsTUFBTSxDQUFDMEIsQ0FBRCxDQUFkOztVQUNBLElBQUkrb0Ysa0JBQWtCLEdBQUd6akUsS0FBSyxDQUFDdXFELE1BQU4sSUFBZ0IsQ0FBQ3ZxRCxLQUFLLENBQUMyN0QsTUFBTixDQUFhNXRCLEdBQUcsQ0FBQ3VjLEdBQWpCLENBQXBCLEdBQTRDLENBQUN0cUQsS0FBSyxDQUFDdXFELE1BQXpFLEVBQ0U7WUFBRTs7OztRQUVOLElBQUk3dkUsQ0FBQyxJQUFJMUIsTUFBTSxDQUFDVixNQUFoQixFQUF3QjtVQUFFOzs7UUFDMUJrbkYsSUFBSSxDQUFDVCxVQUFMLEdBQWtCUyxJQUFJLENBQUNSLGFBQUwsR0FBcUIsSUFBdkM7O1FBRUEsU0FBUztVQUNQaC9ELEtBQUssR0FBR2huQixNQUFNLENBQUNzbUMsR0FBUCxFQUFSOztVQUNBLElBQUl0ZixLQUFLLENBQUN1cUQsTUFBVixFQUFrQjtZQUNoQnVWLHNCQUFzQixDQUFDOS9ELEtBQUQsRUFBUWtnRSxJQUFSLENBQXRCOztZQUNBLElBQUl1RCxrQkFBa0IsSUFBSSxDQUFDempFLEtBQUssQ0FBQzI3RCxNQUFOLENBQWE1dEIsR0FBRyxDQUFDdWMsR0FBakIsQ0FBM0IsRUFBa0Q7Y0FDaEQ0VyxZQUFZLENBQUNuekIsR0FBRCxFQUFNL3RDLEtBQU4sRUFBYTtnQkFBQ2lnRSxTQUFTLEVBQUU7ZUFBekIsQ0FBWjtjQUNBOzs7WUFFRlAsUUFBUSxHQUFHMS9ELEtBQVg7V0FORixNQU9PLElBQUkwakUsUUFBSixFQUFjO1lBQ25CMXFGLE1BQU0sQ0FBQzNCLElBQVAsQ0FBWTJvQixLQUFaO1lBQ0E7V0FGSyxNQUdBO1lBQUU7O1NBOUJpRDs7OztRQW1DNUQsSUFBSTJqRSxXQUFXLEdBQUcsRUFBbEI7UUFDQTdELHNCQUFzQixDQUFDSixRQUFELEVBQVdRLElBQVgsQ0FBdEI7UUFDQUEsSUFBSSxDQUFDN29GLElBQUwsQ0FBVTtVQUFDaW1FLE9BQU8sRUFBRXFtQixXQUFWO1VBQXVCMUUsVUFBVSxFQUFFTyxJQUFJLENBQUNQO1NBQWxEO1FBQ0FPLElBQUksQ0FBQ1AsVUFBTCxHQUFrQmovRCxLQUFLLENBQUNpL0QsVUFBTixJQUFvQixFQUFFTyxJQUFJLENBQUNOLGFBQTdDO1FBRUEsSUFBSWhvRSxNQUFNLEdBQUdveEMsVUFBVSxDQUFDeUYsR0FBRCxFQUFNLGNBQU4sQ0FBVixJQUFtQ0EsR0FBRyxDQUFDbEcsRUFBSixJQUFVUyxVQUFVLENBQUN5RixHQUFHLENBQUNsRyxFQUFMLEVBQVMsY0FBVCxDQUFwRTs7UUFFQSxJQUFJK0ksSUFBSSxHQUFHLFNBQVBBLElBQU8sQ0FBV2wyRCxDQUFYLEVBQWU7VUFDeEIsSUFBSXN1QyxNQUFNLEdBQUdocEIsS0FBSyxDQUFDczlDLE9BQU4sQ0FBYzVpRSxDQUFkLENBQWI7VUFDQXN1QyxNQUFNLENBQUM0WixNQUFQLEdBQWdCOXBELElBQWhCOztVQUNBLElBQUlvZSxNQUFNLElBQUksQ0FBQzRyRSxZQUFZLENBQUMvMEIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBYyxLQUFkLENBQTNCLEVBQWlEO1lBQy9DaHdDLE1BQU0sQ0FBQ1YsTUFBUCxHQUFnQixDQUFoQjtZQUNBLE9BQU8sRUFBUDs7O1VBR0ZxckYsV0FBVyxDQUFDdHNGLElBQVosQ0FBaUI4bkYsdUJBQXVCLENBQUNweEIsR0FBRCxFQUFNL2tCLE1BQU4sQ0FBeEM7VUFFQSxJQUFJaVgsS0FBSyxHQUFHdmxELENBQUMsR0FBRytoRixxQkFBcUIsQ0FBQzF1QixHQUFELEVBQU0va0IsTUFBTixDQUF4QixHQUF3Q29hLEdBQUcsQ0FBQ3BxRCxNQUFELENBQXhEO1VBQ0FxcUYsbUJBQW1CLENBQUN0MUIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBY2lYLEtBQWQsRUFBcUJzZ0MsYUFBYSxDQUFDeHlCLEdBQUQsRUFBTS9rQixNQUFOLENBQWxDLENBQW5COztVQUNBLElBQUksQ0FBQ3R1QyxDQUFELElBQU1xekQsR0FBRyxDQUFDbEcsRUFBZCxFQUFrQjtZQUFFa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPaW5CLGNBQVAsQ0FBc0I7Y0FBQ3I2RCxJQUFJLEVBQUV1MEIsTUFBTSxDQUFDdjBCLElBQWQ7Y0FBb0J3RCxFQUFFLEVBQUVza0UsU0FBUyxDQUFDdnpDLE1BQUQ7YUFBdkQ7OztVQUNwQixJQUFJczZDLE9BQU8sR0FBRyxFQUFkLENBYndCOztVQWdCeEJ4RixVQUFVLENBQUMvdkIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZW13QixVQUFmLEVBQTJCO1lBQ3pDLElBQUksQ0FBQ0EsVUFBRCxJQUFlM3NFLE9BQU8sQ0FBQyt4RSxPQUFELEVBQVV2MUIsR0FBRyxDQUFDNnhCLE9BQWQsQ0FBUCxJQUFpQyxDQUFDLENBQXJELEVBQXdEO2NBQ3REMkQsVUFBVSxDQUFDeDFCLEdBQUcsQ0FBQzZ4QixPQUFMLEVBQWM1MkMsTUFBZCxDQUFWO2NBQ0FzNkMsT0FBTyxDQUFDanNGLElBQVIsQ0FBYTAyRCxHQUFHLENBQUM2eEIsT0FBakI7OztZQUVGeUQsbUJBQW1CLENBQUN0MUIsR0FBRCxFQUFNL2tCLE1BQU4sRUFBYyxJQUFkLEVBQW9CdTNDLGFBQWEsQ0FBQ3h5QixHQUFELEVBQU0va0IsTUFBTixDQUFqQyxDQUFuQjtXQUxRLENBQVY7U0FoQkY7O1FBeUJBLEtBQUssSUFBSTRjLEdBQUcsR0FBRzVsQyxLQUFLLENBQUNzOUMsT0FBTixDQUFjaGxFLE1BQWQsR0FBdUIsQ0FBdEMsRUFBeUNzdEQsR0FBRyxJQUFJLENBQWhELEVBQW1ELEVBQUVBLEdBQXJELEVBQTBEO1VBQ3hELElBQUlnK0IsUUFBUSxHQUFHaHpCLElBQUksQ0FBRWhMLEdBQUYsQ0FBbkI7VUFFQSxJQUFLZytCLFFBQUwsRUFBZ0IsT0FBT0EsUUFBUSxDQUFDbmhFLENBQWhCOztPQTd3S0Q7Ozs7TUFteEtuQixTQUFTb2hFLFFBQVQsQ0FBa0I5MUIsR0FBbEIsRUFBdUIrMUIsUUFBdkIsRUFBaUM7UUFDL0IsSUFBSUEsUUFBUSxJQUFJLENBQWhCLEVBQW1CO1VBQUU7OztRQUNyQi8xQixHQUFHLENBQUN2bEQsS0FBSixJQUFhczdFLFFBQWI7UUFDQS8xQixHQUFHLENBQUN1YyxHQUFKLEdBQVUsSUFBSW9SLFNBQUosQ0FBYzFrRSxHQUFHLENBQUMrMkMsR0FBRyxDQUFDdWMsR0FBSixDQUFRQyxNQUFULEVBQWlCLFVBQVU5eUIsS0FBVixFQUFpQjtVQUFFLE9BQU8sSUFBSXNrQyxLQUFKLENBQ3BFN3NCLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ3psQyxNQUFOLENBQWFpMUMsSUFBYixHQUFvQjY4QixRQUFyQixFQUErQnJzQyxLQUFLLENBQUN6bEMsTUFBTixDQUFhbUwsRUFBNUMsQ0FEaUUsRUFFcEUreEMsR0FBRyxDQUFDelgsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFYLEdBQWtCNjhCLFFBQW5CLEVBQTZCcnNDLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcvRCxFQUF4QyxDQUZpRSxDQUFQO1NBQXBDLENBQWpCLEVBR0g0d0MsR0FBRyxDQUFDdWMsR0FBSixDQUFRRSxTQUhMLENBQVY7O1FBSUEsSUFBSXpjLEdBQUcsQ0FBQ2xHLEVBQVIsRUFBWTtVQUNWa2hCLFNBQVMsQ0FBQ2hiLEdBQUcsQ0FBQ2xHLEVBQUwsRUFBU2tHLEdBQUcsQ0FBQ3ZsRCxLQUFiLEVBQW9CdWxELEdBQUcsQ0FBQ3ZsRCxLQUFKLEdBQVlzN0UsUUFBaEMsRUFBMENBLFFBQTFDLENBQVQ7O1VBQ0EsS0FBSyxJQUFJcndFLENBQUMsR0FBR3M2QyxHQUFHLENBQUNsRyxFQUFKLENBQU8vb0QsT0FBZixFQUF3QmdELENBQUMsR0FBRzJSLENBQUMsQ0FBQ3UrQyxRQUFuQyxFQUE2Q2x3RCxDQUFDLEdBQUcyUixDQUFDLENBQUN3K0MsTUFBbkQsRUFBMkRud0QsQ0FBQyxFQUE1RCxFQUNFO1lBQUUybkUsYUFBYSxDQUFDMWIsR0FBRyxDQUFDbEcsRUFBTCxFQUFTL2xELENBQVQsRUFBWSxRQUFaLENBQWI7OztPQTd4S1c7Ozs7TUFteUtuQixTQUFTdWhGLG1CQUFULENBQTZCdDFCLEdBQTdCLEVBQWtDL2tCLE1BQWxDLEVBQTBDMDJDLFFBQTFDLEVBQW9EN3JCLEtBQXBELEVBQTJEO1FBQ3pELElBQUk5RixHQUFHLENBQUNsRyxFQUFKLElBQVUsQ0FBQ2tHLEdBQUcsQ0FBQ2xHLEVBQUosQ0FBT08sS0FBdEIsRUFDRTtVQUFFLE9BQU94TyxTQUFTLENBQUNtVSxHQUFHLENBQUNsRyxFQUFMLEVBQVN3N0IsbUJBQVQsQ0FBVCxDQUF1Q3QxQixHQUF2QyxFQUE0Qy9rQixNQUE1QyxFQUFvRDAyQyxRQUFwRCxFQUE4RDdyQixLQUE5RCxDQUFQOzs7UUFFSixJQUFJN3FCLE1BQU0sQ0FBQy93QixFQUFQLENBQVVndkMsSUFBVixHQUFpQjhHLEdBQUcsQ0FBQ3ZsRCxLQUF6QixFQUFnQztVQUM5QnE3RSxRQUFRLENBQUM5MUIsR0FBRCxFQUFNL2tCLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWXArQyxNQUFaLEdBQXFCLENBQXJCLElBQTBCMHdDLE1BQU0sQ0FBQy93QixFQUFQLENBQVVndkMsSUFBVixHQUFpQmplLE1BQU0sQ0FBQ3YwQixJQUFQLENBQVl3eUMsSUFBdkQsQ0FBTixDQUFSO1VBQ0E7OztRQUVGLElBQUlqZSxNQUFNLENBQUN2MEIsSUFBUCxDQUFZd3lDLElBQVosR0FBbUI4RyxHQUFHLENBQUMrSixRQUFKLEVBQXZCLEVBQXVDO1VBQUU7U0FSZ0I7OztRQVd6RCxJQUFJOXVCLE1BQU0sQ0FBQ3YwQixJQUFQLENBQVl3eUMsSUFBWixHQUFtQjhHLEdBQUcsQ0FBQ3ZsRCxLQUEzQixFQUFrQztVQUNoQyxJQUFJb2xFLEtBQUssR0FBRzVrQyxNQUFNLENBQUMwTixJQUFQLENBQVlwK0MsTUFBWixHQUFxQixDQUFyQixJQUEwQnkxRCxHQUFHLENBQUN2bEQsS0FBSixHQUFZd2dDLE1BQU0sQ0FBQ3YwQixJQUFQLENBQVl3eUMsSUFBbEQsQ0FBWjtVQUNBNDhCLFFBQVEsQ0FBQzkxQixHQUFELEVBQU02ZixLQUFOLENBQVI7VUFDQTVrQyxNQUFNLEdBQUc7WUFBQ3YwQixJQUFJLEVBQUV5NkMsR0FBRyxDQUFDbkIsR0FBRyxDQUFDdmxELEtBQUwsRUFBWSxDQUFaLENBQVY7WUFBMEJ5UCxFQUFFLEVBQUVpM0MsR0FBRyxDQUFDbG1CLE1BQU0sQ0FBQy93QixFQUFQLENBQVVndkMsSUFBVixHQUFpQjJtQixLQUFsQixFQUF5QjVrQyxNQUFNLENBQUMvd0IsRUFBUCxDQUFVa0YsRUFBbkMsQ0FBakM7WUFDQ3U1QixJQUFJLEVBQUUsQ0FBQzBNLEdBQUcsQ0FBQ3BhLE1BQU0sQ0FBQzBOLElBQVIsQ0FBSixDQURQO1lBQzJCa00sTUFBTSxFQUFFNVosTUFBTSxDQUFDNFo7V0FEbkQ7OztRQUdGLElBQUl6aEMsSUFBSSxHQUFHNHNDLEdBQUcsQ0FBQytKLFFBQUosRUFBWDs7UUFDQSxJQUFJOXVCLE1BQU0sQ0FBQy93QixFQUFQLENBQVVndkMsSUFBVixHQUFpQjlsQyxJQUFyQixFQUEyQjtVQUN6QjZuQixNQUFNLEdBQUc7WUFBQ3YwQixJQUFJLEVBQUV1MEIsTUFBTSxDQUFDdjBCLElBQWQ7WUFBb0J3RCxFQUFFLEVBQUVpM0MsR0FBRyxDQUFDL3RDLElBQUQsRUFBTzJzQyxPQUFPLENBQUNDLEdBQUQsRUFBTTVzQyxJQUFOLENBQVAsQ0FBbUJ1MUIsSUFBbkIsQ0FBd0JwK0MsTUFBL0IsQ0FBM0I7WUFDQ28rQyxJQUFJLEVBQUUsQ0FBQzFOLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWSxDQUFaLENBQUQsQ0FEUDtZQUN5QmtNLE1BQU0sRUFBRTVaLE1BQU0sQ0FBQzRaO1dBRGpEOzs7UUFJRjVaLE1BQU0sQ0FBQys2QyxPQUFQLEdBQWlCMTFCLFVBQVUsQ0FBQ04sR0FBRCxFQUFNL2tCLE1BQU0sQ0FBQ3YwQixJQUFiLEVBQW1CdTBCLE1BQU0sQ0FBQy93QixFQUExQixDQUEzQjs7UUFFQSxJQUFJLENBQUN5bkUsUUFBTCxFQUFlO1VBQUVBLFFBQVEsR0FBR2pELHFCQUFxQixDQUFDMXVCLEdBQUQsRUFBTS9rQixNQUFOLENBQWhDOzs7UUFDakIsSUFBSStrQixHQUFHLENBQUNsRyxFQUFSLEVBQVk7VUFBRW04QiwyQkFBMkIsQ0FBQ2oyQixHQUFHLENBQUNsRyxFQUFMLEVBQVM3ZSxNQUFULEVBQWlCNnFCLEtBQWpCLENBQTNCO1NBQWQsTUFDSztVQUFFc3BCLFNBQVMsQ0FBQ3B2QixHQUFELEVBQU0va0IsTUFBTixFQUFjNnFCLEtBQWQsQ0FBVDs7O1FBQ1A2dEIsa0JBQWtCLENBQUMzekIsR0FBRCxFQUFNMnhCLFFBQU4sRUFBZ0JqOUIsY0FBaEIsQ0FBbEI7O1FBRUEsSUFBSXNMLEdBQUcsQ0FBQzYwQixRQUFKLElBQWdCWixVQUFVLENBQUNqMEIsR0FBRCxFQUFNbUIsR0FBRyxDQUFDbkIsR0FBRyxDQUFDdXZCLFNBQUosRUFBRCxFQUFrQixDQUFsQixDQUFULENBQTlCLEVBQ0U7VUFBRXZ2QixHQUFHLENBQUM2MEIsUUFBSixHQUFlLEtBQWY7O09BbDBLYTs7OztNQXUwS25CLFNBQVNvQiwyQkFBVCxDQUFxQ244QixFQUFyQyxFQUF5QzdlLE1BQXpDLEVBQWlENnFCLEtBQWpELEVBQXdEO1FBQ3RELElBQUk5RixHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFiO1lBQWtCanZELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBL0I7WUFBd0MyVixJQUFJLEdBQUd1MEIsTUFBTSxDQUFDdjBCLElBQXREO1lBQTREd0QsRUFBRSxHQUFHK3dCLE1BQU0sQ0FBQy93QixFQUF4RTtRQUVBLElBQUlnc0Usa0JBQWtCLEdBQUcsS0FBekI7WUFBZ0NDLGVBQWUsR0FBR3p2RSxJQUFJLENBQUN3eUMsSUFBdkQ7O1FBQ0EsSUFBSSxDQUFDWSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXZy9CLFlBQWhCLEVBQThCO1VBQzVCc2lCLGVBQWUsR0FBR3oxQixNQUFNLENBQUM2SSxVQUFVLENBQUN4SixPQUFPLENBQUNDLEdBQUQsRUFBTXQ1QyxJQUFJLENBQUN3eUMsSUFBWCxDQUFSLENBQVgsQ0FBeEI7VUFDQThHLEdBQUcsQ0FBQ241QyxJQUFKLENBQVNzdkUsZUFBVCxFQUEwQmpzRSxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQXBDLEVBQXVDLFVBQVVBLElBQVYsRUFBZ0I7WUFDckQsSUFBSUEsSUFBSSxJQUFJbm9ELE9BQU8sQ0FBQ3c1RCxPQUFwQixFQUE2QjtjQUMzQjJyQixrQkFBa0IsR0FBRyxJQUFyQjtjQUNBLE9BQU8sSUFBUDs7V0FISjs7O1FBUUYsSUFBSWwyQixHQUFHLENBQUN1YyxHQUFKLENBQVF4cEIsUUFBUixDQUFpQjlYLE1BQU0sQ0FBQ3YwQixJQUF4QixFQUE4QnUwQixNQUFNLENBQUMvd0IsRUFBckMsSUFBMkMsQ0FBQyxDQUFoRCxFQUNFO1VBQUVpd0Msb0JBQW9CLENBQUNMLEVBQUQsQ0FBcEI7OztRQUVKczFCLFNBQVMsQ0FBQ3B2QixHQUFELEVBQU0va0IsTUFBTixFQUFjNnFCLEtBQWQsRUFBcUI2RSxjQUFjLENBQUM3USxFQUFELENBQW5DLENBQVQ7O1FBRUEsSUFBSSxDQUFDQSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXZy9CLFlBQWhCLEVBQThCO1VBQzVCN1QsR0FBRyxDQUFDbjVDLElBQUosQ0FBU3N2RSxlQUFULEVBQTBCenZFLElBQUksQ0FBQ3d5QyxJQUFMLEdBQVlqZSxNQUFNLENBQUMwTixJQUFQLENBQVlwK0MsTUFBbEQsRUFBMEQsVUFBVTJ1RCxJQUFWLEVBQWdCO1lBQ3hFLElBQUlwaEQsR0FBRyxHQUFHdXlELFVBQVUsQ0FBQ25SLElBQUQsQ0FBcEI7O1lBQ0EsSUFBSXBoRCxHQUFHLEdBQUcvRyxPQUFPLENBQUN5NUQsYUFBbEIsRUFBaUM7Y0FDL0J6NUQsT0FBTyxDQUFDdzVELE9BQVIsR0FBa0JyUixJQUFsQjtjQUNBbm9ELE9BQU8sQ0FBQ3k1RCxhQUFSLEdBQXdCMXlELEdBQXhCO2NBQ0EvRyxPQUFPLENBQUMwNUQsY0FBUixHQUF5QixJQUF6QjtjQUNBeXJCLGtCQUFrQixHQUFHLEtBQXJCOztXQU5KOztVQVNBLElBQUlBLGtCQUFKLEVBQXdCO1lBQUVwOEIsRUFBRSxDQUFDTyxLQUFILENBQVNvc0IsYUFBVCxHQUF5QixJQUF6Qjs7OztRQUc1QmxoQixlQUFlLENBQUN2RixHQUFELEVBQU10NUMsSUFBSSxDQUFDd3lDLElBQVgsQ0FBZjtRQUNBOHBCLFdBQVcsQ0FBQ2xwQixFQUFELEVBQUssR0FBTCxDQUFYO1FBRUEsSUFBSW1oQixPQUFPLEdBQUdoZ0MsTUFBTSxDQUFDME4sSUFBUCxDQUFZcCtDLE1BQVosSUFBc0IyZixFQUFFLENBQUNndkMsSUFBSCxHQUFVeHlDLElBQUksQ0FBQ3d5QyxJQUFyQyxJQUE2QyxDQUEzRCxDQW5Dc0Q7O1FBcUN0RCxJQUFJamUsTUFBTSxDQUFDaXNCLElBQVgsRUFDRTtVQUFFOFQsU0FBUyxDQUFDbGhCLEVBQUQsQ0FBVDtTQURKLE1BRUssSUFBSXB6QyxJQUFJLENBQUN3eUMsSUFBTCxJQUFhaHZDLEVBQUUsQ0FBQ2d2QyxJQUFoQixJQUF3QmplLE1BQU0sQ0FBQzBOLElBQVAsQ0FBWXArQyxNQUFaLElBQXNCLENBQTlDLElBQW1ELENBQUMya0YsaUJBQWlCLENBQUNwMUIsRUFBRSxDQUFDa0csR0FBSixFQUFTL2tCLE1BQVQsQ0FBekUsRUFDSDtVQUFFeWdDLGFBQWEsQ0FBQzVoQixFQUFELEVBQUtwekMsSUFBSSxDQUFDd3lDLElBQVYsRUFBZ0IsTUFBaEIsQ0FBYjtTQURDLE1BR0g7VUFBRThoQixTQUFTLENBQUNsaEIsRUFBRCxFQUFLcHpDLElBQUksQ0FBQ3d5QyxJQUFWLEVBQWdCaHZDLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVUsQ0FBMUIsRUFBNkIraEIsT0FBN0IsQ0FBVDs7O1FBRUosSUFBSW1iLGNBQWMsR0FBRzc3QixVQUFVLENBQUNULEVBQUQsRUFBSyxTQUFMLENBQS9CO1lBQWdEdThCLGFBQWEsR0FBRzk3QixVQUFVLENBQUNULEVBQUQsRUFBSyxRQUFMLENBQTFFOztRQUNBLElBQUl1OEIsYUFBYSxJQUFJRCxjQUFyQixFQUFxQztVQUNuQyxJQUFJeG9ELEdBQUcsR0FBRztZQUNSbG5CLElBQUksRUFBRUEsSUFERTtZQUNJd0QsRUFBRSxFQUFFQSxFQURSO1lBRVJ5K0IsSUFBSSxFQUFFMU4sTUFBTSxDQUFDME4sSUFGTDtZQUdScXRDLE9BQU8sRUFBRS82QyxNQUFNLENBQUMrNkMsT0FIUjtZQUlSbmhDLE1BQU0sRUFBRTVaLE1BQU0sQ0FBQzRaO1dBSmpCOztVQU1BLElBQUl3aEMsYUFBSixFQUFtQjtZQUFFbm5CLFdBQVcsQ0FBQ3BWLEVBQUQsRUFBSyxRQUFMLEVBQWVBLEVBQWYsRUFBbUJsc0IsR0FBbkIsQ0FBWDs7O1VBQ3JCLElBQUl3b0QsY0FBSixFQUFvQjtZQUFFLENBQUN0OEIsRUFBRSxDQUFDTyxLQUFILENBQVNrc0IsVUFBVCxLQUF3QnpzQixFQUFFLENBQUNPLEtBQUgsQ0FBU2tzQixVQUFULEdBQXNCLEVBQTlDLENBQUQsRUFBb0RqOUUsSUFBcEQsQ0FBeURza0MsR0FBekQ7Ozs7UUFFeEJrc0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzR1RSxpQkFBWCxHQUErQixJQUEvQjs7O01BR0YsU0FBUzJXLGFBQVQsQ0FBc0J0MkIsR0FBdEIsRUFBMkJqbEQsSUFBM0IsRUFBaUMyTCxJQUFqQyxFQUF1Q3dELEVBQXZDLEVBQTJDMnFDLE1BQTNDLEVBQW1EO1FBQ2pELElBQUlyK0MsTUFBSjs7UUFFQSxJQUFJLENBQUMwVCxFQUFMLEVBQVM7VUFBRUEsRUFBRSxHQUFHeEQsSUFBTDs7O1FBQ1gsSUFBSTA2QyxHQUFHLENBQUNsM0MsRUFBRCxFQUFLeEQsSUFBTCxDQUFILEdBQWdCLENBQXBCLEVBQXVCO1VBQUdsUSxNQUFNLEdBQUcsQ0FBQzBULEVBQUQsRUFBS3hELElBQUwsQ0FBVCxFQUFxQkEsSUFBSSxHQUFHbFEsTUFBTSxDQUFDLENBQUQsQ0FBbEMsRUFBdUMwVCxFQUFFLEdBQUcxVCxNQUFNLENBQUMsQ0FBRCxDQUFuRDs7O1FBQ3pCLElBQUksT0FBT3VFLElBQVAsSUFBZSxRQUFuQixFQUE2QjtVQUFFQSxJQUFJLEdBQUdpbEQsR0FBRyxDQUFDdTJCLFVBQUosQ0FBZXg3RSxJQUFmLENBQVA7OztRQUMvQm02RSxVQUFVLENBQUNsMUIsR0FBRCxFQUFNO1VBQUN0NUMsSUFBSSxFQUFFQSxJQUFQO1VBQWF3RCxFQUFFLEVBQUVBLEVBQWpCO1VBQXFCeStCLElBQUksRUFBRTV0QyxJQUEzQjtVQUFpQzg1QyxNQUFNLEVBQUVBO1NBQS9DLENBQVY7T0F2NEtpQjs7O01BNDRLbkIsU0FBUzJoQyxtQkFBVCxDQUE2Qi8xRSxHQUE3QixFQUFrQ2lHLElBQWxDLEVBQXdDd0QsRUFBeEMsRUFBNEN1MkMsSUFBNUMsRUFBa0Q7UUFDaEQsSUFBSXYyQyxFQUFFLEdBQUd6SixHQUFHLENBQUN5NEMsSUFBYixFQUFtQjtVQUNqQno0QyxHQUFHLENBQUN5NEMsSUFBSixJQUFZdUgsSUFBWjtTQURGLE1BRU8sSUFBSS81QyxJQUFJLEdBQUdqRyxHQUFHLENBQUN5NEMsSUFBZixFQUFxQjtVQUMxQno0QyxHQUFHLENBQUN5NEMsSUFBSixHQUFXeHlDLElBQVg7VUFDQWpHLEdBQUcsQ0FBQzJPLEVBQUosR0FBUyxDQUFUOztPQWo1S2U7Ozs7Ozs7OztNQTQ1S25CLFNBQVNxbkUsZUFBVCxDQUF5QmxpQyxLQUF6QixFQUFnQzd0QyxJQUFoQyxFQUFzQ3dELEVBQXRDLEVBQTBDdTJDLElBQTFDLEVBQWdEO1FBQzlDLEtBQUssSUFBSTl6RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNG5ELEtBQUssQ0FBQ2hxRCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFBdUM7VUFDckMsSUFBSW9ZLEdBQUcsR0FBR3d2QyxLQUFLLENBQUM1bkQsQ0FBRCxDQUFmO2NBQW9Cc3BCLEVBQUUsR0FBRyxJQUF6Qjs7VUFDQSxJQUFJbFIsR0FBRyxDQUFDeTNELE1BQVIsRUFBZ0I7WUFDZCxJQUFJLENBQUN6M0QsR0FBRyxDQUFDMnhFLE1BQVQsRUFBaUI7Y0FBRTN4RSxHQUFHLEdBQUd3dkMsS0FBSyxDQUFDNW5ELENBQUQsQ0FBTCxHQUFXb1ksR0FBRyxDQUFDZ3BFLFFBQUosRUFBakI7Y0FBaUNocEUsR0FBRyxDQUFDMnhFLE1BQUosR0FBYSxJQUFiOzs7WUFDcEQsS0FBSyxJQUFJL2hGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvUSxHQUFHLENBQUN5M0QsTUFBSixDQUFXanlFLE1BQS9CLEVBQXVDb0ssQ0FBQyxFQUF4QyxFQUE0QztjQUMxQzZoRixtQkFBbUIsQ0FBQ3p4RSxHQUFHLENBQUN5M0QsTUFBSixDQUFXN25FLENBQVgsRUFBY3NQLE1BQWYsRUFBdUJ5QyxJQUF2QixFQUE2QndELEVBQTdCLEVBQWlDdTJDLElBQWpDLENBQW5CO2NBQ0ErMUIsbUJBQW1CLENBQUN6eEUsR0FBRyxDQUFDeTNELE1BQUosQ0FBVzduRSxDQUFYLEVBQWN3ZSxJQUFmLEVBQXFCek0sSUFBckIsRUFBMkJ3RCxFQUEzQixFQUErQnUyQyxJQUEvQixDQUFuQjs7O1lBRUY7OztVQUVGLEtBQUssSUFBSTdILEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUc3ekMsR0FBRyxDQUFDd3FELE9BQUosQ0FBWWhsRSxNQUFwQyxFQUE0QyxFQUFFcXVELEdBQTlDLEVBQW1EO1lBQ2pELElBQUk3QixHQUFHLEdBQUdoeUMsR0FBRyxDQUFDd3FELE9BQUosQ0FBWTNXLEdBQVosQ0FBVjs7WUFDQSxJQUFJMXVDLEVBQUUsR0FBRzZzQyxHQUFHLENBQUNyd0MsSUFBSixDQUFTd3lDLElBQWxCLEVBQXdCO2NBQ3RCbkMsR0FBRyxDQUFDcndDLElBQUosR0FBV3k2QyxHQUFHLENBQUNwSyxHQUFHLENBQUNyd0MsSUFBSixDQUFTd3lDLElBQVQsR0FBZ0J1SCxJQUFqQixFQUF1QjFKLEdBQUcsQ0FBQ3J3QyxJQUFKLENBQVMwSSxFQUFoQyxDQUFkO2NBQ0EybkMsR0FBRyxDQUFDN3NDLEVBQUosR0FBU2kzQyxHQUFHLENBQUNwSyxHQUFHLENBQUM3c0MsRUFBSixDQUFPZ3ZDLElBQVAsR0FBY3VILElBQWYsRUFBcUIxSixHQUFHLENBQUM3c0MsRUFBSixDQUFPa0YsRUFBNUIsQ0FBWjthQUZGLE1BR08sSUFBSTFJLElBQUksSUFBSXF3QyxHQUFHLENBQUM3c0MsRUFBSixDQUFPZ3ZDLElBQW5CLEVBQXlCO2NBQzlCampDLEVBQUUsR0FBRyxLQUFMO2NBQ0E7Ozs7VUFHSixJQUFJLENBQUNBLEVBQUwsRUFBUztZQUNQcytCLEtBQUssQ0FBQzU1QixNQUFOLENBQWEsQ0FBYixFQUFnQmh1QixDQUFDLEdBQUcsQ0FBcEI7WUFDQUEsQ0FBQyxHQUFHLENBQUo7Ozs7O01BS04sU0FBUzZvRixVQUFULENBQW9CL0QsSUFBcEIsRUFBMEJ4MkMsTUFBMUIsRUFBa0M7UUFDaEMsSUFBSXYwQixJQUFJLEdBQUd1MEIsTUFBTSxDQUFDdjBCLElBQVAsQ0FBWXd5QyxJQUF2QjtZQUE2Qmh2QyxFQUFFLEdBQUcrd0IsTUFBTSxDQUFDL3dCLEVBQVAsQ0FBVWd2QyxJQUE1QztZQUFrRHVILElBQUksR0FBR3hsQixNQUFNLENBQUMwTixJQUFQLENBQVlwK0MsTUFBWixJQUFzQjJmLEVBQUUsR0FBR3hELElBQTNCLElBQW1DLENBQTVGO1FBQ0ErdkUsZUFBZSxDQUFDaEYsSUFBSSxDQUFDaHZFLElBQU4sRUFBWWlFLElBQVosRUFBa0J3RCxFQUFsQixFQUFzQnUyQyxJQUF0QixDQUFmO1FBQ0FnMkIsZUFBZSxDQUFDaEYsSUFBSSxDQUFDZixNQUFOLEVBQWNocUUsSUFBZCxFQUFvQndELEVBQXBCLEVBQXdCdTJDLElBQXhCLENBQWY7T0EzN0tpQjs7Ozs7TUFpOEtuQixTQUFTazJCLFVBQVQsQ0FBb0IzMkIsR0FBcEIsRUFBeUJqdUIsTUFBekIsRUFBaUM2a0QsVUFBakMsRUFBNkMxd0IsRUFBN0MsRUFBaUQ7UUFDL0MsSUFBSXZGLEVBQUUsR0FBRzV1QixNQUFUO1lBQWlCbW5CLElBQUksR0FBR25uQixNQUF4Qjs7UUFDQSxJQUFJLE9BQU9BLE1BQVAsSUFBaUIsUUFBckIsRUFBK0I7VUFBRW1uQixJQUFJLEdBQUc2RyxPQUFPLENBQUNDLEdBQUQsRUFBTXlCLFFBQVEsQ0FBQ3pCLEdBQUQsRUFBTWp1QixNQUFOLENBQWQsQ0FBZDtTQUFqQyxNQUNLO1VBQUU0dUIsRUFBRSxHQUFHRCxNQUFNLENBQUMzdUIsTUFBRCxDQUFYOzs7UUFDUCxJQUFJNHVCLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQUUsT0FBTyxJQUFQOzs7UUFDbEIsSUFBSXVGLEVBQUUsQ0FBQ2hOLElBQUQsRUFBT3lILEVBQVAsQ0FBRixJQUFnQlgsR0FBRyxDQUFDbEcsRUFBeEIsRUFBNEI7VUFBRTRoQixhQUFhLENBQUMxYixHQUFHLENBQUNsRyxFQUFMLEVBQVM2RyxFQUFULEVBQWFpMkIsVUFBYixDQUFiOzs7UUFDOUIsT0FBTzE5QixJQUFQO09BdjhLaUI7Ozs7Ozs7Ozs7Ozs7O01BdTlLbkIsU0FBUzI5QixTQUFULENBQW1CMzJCLEtBQW5CLEVBQTBCO1FBQ3hCLEtBQUtBLEtBQUwsR0FBYUEsS0FBYjtRQUNBLEtBQUszc0MsTUFBTCxHQUFjLElBQWQ7UUFDQSxJQUFJd3lCLE1BQU0sR0FBRyxDQUFiOztRQUNBLEtBQUssSUFBSXA1QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdXpELEtBQUssQ0FBQzMxRCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFBdUM7VUFDckN1ekQsS0FBSyxDQUFDdnpELENBQUQsQ0FBTCxDQUFTNG1CLE1BQVQsR0FBa0IsSUFBbEI7VUFDQXd5QixNQUFNLElBQUltYSxLQUFLLENBQUN2ekQsQ0FBRCxDQUFMLENBQVNvNUMsTUFBbkI7OztRQUVGLEtBQUtBLE1BQUwsR0FBY0EsTUFBZDs7O01BR0Y4d0MsU0FBUyxDQUFDeHNGLFNBQVYsR0FBc0I7UUFDcEJnMkQsU0FBUyxFQUFFLHFCQUFXO1VBQUUsT0FBTyxLQUFLSCxLQUFMLENBQVczMUQsTUFBbEI7U0FESjs7UUFJcEJ1c0YsV0FBVyxFQUFFLHFCQUFTdHFFLEVBQVQsRUFBYXpVLENBQWIsRUFBZ0I7VUFDM0IsS0FBSyxJQUFJcEwsQ0FBQyxHQUFHNmYsRUFBUixFQUFZN2xCLENBQUMsR0FBRzZsQixFQUFFLEdBQUd6VSxDQUExQixFQUE2QnBMLENBQUMsR0FBR2hHLENBQWpDLEVBQW9DLEVBQUVnRyxDQUF0QyxFQUF5QztZQUN2QyxJQUFJdXNELElBQUksR0FBRyxLQUFLZ0gsS0FBTCxDQUFXdnpELENBQVgsQ0FBWDtZQUNBLEtBQUtvNUMsTUFBTCxJQUFlbVQsSUFBSSxDQUFDblQsTUFBcEI7WUFDQStrQixXQUFXLENBQUM1UixJQUFELENBQVg7WUFDQWdXLFdBQVcsQ0FBQ2hXLElBQUQsRUFBTyxRQUFQLENBQVg7OztVQUVGLEtBQUtnSCxLQUFMLENBQVd2bEMsTUFBWCxDQUFrQm5PLEVBQWxCLEVBQXNCelUsQ0FBdEI7U0FYa0I7O1FBZXBCNjZDLFFBQVEsRUFBRSxrQkFBU3NOLEtBQVQsRUFBZ0I7VUFDeEJBLEtBQUssQ0FBQzUyRCxJQUFOLENBQVdxQixLQUFYLENBQWlCdTFELEtBQWpCLEVBQXdCLEtBQUtBLEtBQTdCO1NBaEJrQjs7O1FBcUJwQjYyQixXQUFXLEVBQUUscUJBQVN2cUUsRUFBVCxFQUFhMHpDLEtBQWIsRUFBb0JuYSxNQUFwQixFQUE0QjtVQUN2QyxLQUFLQSxNQUFMLElBQWVBLE1BQWY7VUFDQSxLQUFLbWEsS0FBTCxHQUFhLEtBQUtBLEtBQUwsQ0FBV2x5RCxLQUFYLENBQWlCLENBQWpCLEVBQW9Cd2UsRUFBcEIsRUFBd0J0akIsTUFBeEIsQ0FBK0JnM0QsS0FBL0IsRUFBc0NoM0QsTUFBdEMsQ0FBNkMsS0FBS2czRCxLQUFMLENBQVdseUQsS0FBWCxDQUFpQndlLEVBQWpCLENBQTdDLENBQWI7O1VBQ0EsS0FBSyxJQUFJN2YsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3V6RCxLQUFLLENBQUMzMUQsTUFBMUIsRUFBa0MsRUFBRW9DLENBQXBDLEVBQXVDO1lBQUV1ekQsS0FBSyxDQUFDdnpELENBQUQsQ0FBTCxDQUFTNG1CLE1BQVQsR0FBa0IsSUFBbEI7O1NBeEJ2Qjs7UUE0QnBCeWpFLEtBQUssRUFBRSxlQUFTeHFFLEVBQVQsRUFBYXpVLENBQWIsRUFBZ0JtdUQsRUFBaEIsRUFBb0I7VUFDekIsS0FBSyxJQUFJdi9ELENBQUMsR0FBRzZsQixFQUFFLEdBQUd6VSxDQUFsQixFQUFxQnlVLEVBQUUsR0FBRzdsQixDQUExQixFQUE2QixFQUFFNmxCLEVBQS9CLEVBQ0U7WUFBRSxJQUFJMDVDLEVBQUUsQ0FBQyxLQUFLaEcsS0FBTCxDQUFXMXpDLEVBQVgsQ0FBRCxDQUFOLEVBQXdCO2NBQUUsT0FBTyxJQUFQOzs7O09BOUJsQzs7TUFrQ0EsU0FBU3lxRSxXQUFULENBQXFCOTJCLFFBQXJCLEVBQStCO1FBQzdCLEtBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO1FBQ0EsSUFBSTE3QyxJQUFJLEdBQUcsQ0FBWDtZQUFjc2hDLE1BQU0sR0FBRyxDQUF2Qjs7UUFDQSxLQUFLLElBQUlwNUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3d6RCxRQUFRLENBQUM1MUQsTUFBN0IsRUFBcUMsRUFBRW9DLENBQXZDLEVBQTBDO1VBQ3hDLElBQUl5aUIsRUFBRSxHQUFHK3dDLFFBQVEsQ0FBQ3h6RCxDQUFELENBQWpCO1VBQ0E4WCxJQUFJLElBQUkySyxFQUFFLENBQUNpeEMsU0FBSCxFQUFSO1VBQXdCdGEsTUFBTSxJQUFJMzJCLEVBQUUsQ0FBQzIyQixNQUFiO1VBQ3hCMzJCLEVBQUUsQ0FBQ21FLE1BQUgsR0FBWSxJQUFaOzs7UUFFRixLQUFLOU8sSUFBTCxHQUFZQSxJQUFaO1FBQ0EsS0FBS3NoQyxNQUFMLEdBQWNBLE1BQWQ7UUFDQSxLQUFLeHlCLE1BQUwsR0FBYyxJQUFkOzs7TUFHRjBqRSxXQUFXLENBQUM1c0YsU0FBWixHQUF3QjtRQUN0QmcyRCxTQUFTLEVBQUUscUJBQVc7VUFBRSxPQUFPLEtBQUs1N0MsSUFBWjtTQURGO1FBR3RCcXlFLFdBQVcsRUFBRSxxQkFBU3RxRSxFQUFULEVBQWF6VSxDQUFiLEVBQWdCO1VBQzNCLEtBQUswTSxJQUFMLElBQWExTSxDQUFiOztVQUNBLEtBQUssSUFBSXBMLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3d6RCxRQUFMLENBQWM1MUQsTUFBbEMsRUFBMEMsRUFBRW9DLENBQTVDLEVBQStDO1lBQzdDLElBQUlxbUQsS0FBSyxHQUFHLEtBQUttTixRQUFMLENBQWN4ekQsQ0FBZCxDQUFaO2dCQUE4Qnl6RCxFQUFFLEdBQUdwTixLQUFLLENBQUNxTixTQUFOLEVBQW5DOztZQUNBLElBQUk3ekMsRUFBRSxHQUFHNHpDLEVBQVQsRUFBYTtjQUNYLElBQUk2cUIsRUFBRSxHQUFHL2tGLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3VKLENBQVQsRUFBWXFvRCxFQUFFLEdBQUc1ekMsRUFBakIsQ0FBVDtrQkFBK0IwekQsU0FBUyxHQUFHbHRCLEtBQUssQ0FBQ2pOLE1BQWpEO2NBQ0FpTixLQUFLLENBQUM4akMsV0FBTixDQUFrQnRxRSxFQUFsQixFQUFzQnkrRCxFQUF0QjtjQUNBLEtBQUtsbEMsTUFBTCxJQUFlbTZCLFNBQVMsR0FBR2x0QixLQUFLLENBQUNqTixNQUFqQzs7Y0FDQSxJQUFJcWEsRUFBRSxJQUFJNnFCLEVBQVYsRUFBYztnQkFBRSxLQUFLOXFCLFFBQUwsQ0FBY3hsQyxNQUFkLENBQXFCaHVCLENBQUMsRUFBdEIsRUFBMEIsQ0FBMUI7Z0JBQThCcW1ELEtBQUssQ0FBQ3ovQixNQUFOLEdBQWUsSUFBZjs7O2NBQzlDLElBQUksQ0FBQ3hiLENBQUMsSUFBSWt6RSxFQUFOLEtBQWEsQ0FBakIsRUFBb0I7Z0JBQUU7OztjQUN0QnorRCxFQUFFLEdBQUcsQ0FBTDthQU5GLE1BT087Y0FBRUEsRUFBRSxJQUFJNHpDLEVBQU47O1dBWGdCOzs7O1VBZTNCLElBQUksS0FBSzM3QyxJQUFMLEdBQVkxTSxDQUFaLEdBQWdCLEVBQWhCLEtBQ0MsS0FBS29vRCxRQUFMLENBQWM1MUQsTUFBZCxHQUF1QixDQUF2QixJQUE0QixFQUFFLEtBQUs0MUQsUUFBTCxDQUFjLENBQWQsYUFBNEIwMkIsU0FBOUIsQ0FEN0IsQ0FBSixFQUM0RTtZQUMxRSxJQUFJMzJCLEtBQUssR0FBRyxFQUFaO1lBQ0EsS0FBS3ROLFFBQUwsQ0FBY3NOLEtBQWQ7WUFDQSxLQUFLQyxRQUFMLEdBQWdCLENBQUMsSUFBSTAyQixTQUFKLENBQWMzMkIsS0FBZCxDQUFELENBQWhCO1lBQ0EsS0FBS0MsUUFBTCxDQUFjLENBQWQsRUFBaUI1c0MsTUFBakIsR0FBMEIsSUFBMUI7O1NBdkJrQjtRQTJCdEJxL0IsUUFBUSxFQUFFLGtCQUFTc04sS0FBVCxFQUFnQjtVQUN4QixLQUFLLElBQUl2ekQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLd3pELFFBQUwsQ0FBYzUxRCxNQUFsQyxFQUEwQyxFQUFFb0MsQ0FBNUMsRUFBK0M7WUFBRSxLQUFLd3pELFFBQUwsQ0FBY3h6RCxDQUFkLEVBQWlCaW1ELFFBQWpCLENBQTBCc04sS0FBMUI7O1NBNUI3QjtRQStCdEI2MkIsV0FBVyxFQUFFLHFCQUFTdnFFLEVBQVQsRUFBYTB6QyxLQUFiLEVBQW9CbmEsTUFBcEIsRUFBNEI7VUFDdkMsS0FBS3RoQyxJQUFMLElBQWF5N0MsS0FBSyxDQUFDMzFELE1BQW5CO1VBQ0EsS0FBS3c3QyxNQUFMLElBQWVBLE1BQWY7O1VBQ0EsS0FBSyxJQUFJcDVDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3d6RCxRQUFMLENBQWM1MUQsTUFBbEMsRUFBMEMsRUFBRW9DLENBQTVDLEVBQStDO1lBQzdDLElBQUlxbUQsS0FBSyxHQUFHLEtBQUttTixRQUFMLENBQWN4ekQsQ0FBZCxDQUFaO2dCQUE4Qnl6RCxFQUFFLEdBQUdwTixLQUFLLENBQUNxTixTQUFOLEVBQW5DOztZQUNBLElBQUk3ekMsRUFBRSxJQUFJNHpDLEVBQVYsRUFBYztjQUNacE4sS0FBSyxDQUFDK2pDLFdBQU4sQ0FBa0J2cUUsRUFBbEIsRUFBc0IwekMsS0FBdEIsRUFBNkJuYSxNQUE3Qjs7Y0FDQSxJQUFJaU4sS0FBSyxDQUFDa04sS0FBTixJQUFlbE4sS0FBSyxDQUFDa04sS0FBTixDQUFZMzFELE1BQVosR0FBcUIsRUFBeEMsRUFBNEM7OztnQkFHMUMsSUFBSTR0QixTQUFTLEdBQUc2NkIsS0FBSyxDQUFDa04sS0FBTixDQUFZMzFELE1BQVosR0FBcUIsRUFBckIsR0FBMEIsRUFBMUM7O2dCQUNBLEtBQUssSUFBSWtXLEdBQUcsR0FBRzBYLFNBQWYsRUFBMEIxWCxHQUFHLEdBQUd1eUMsS0FBSyxDQUFDa04sS0FBTixDQUFZMzFELE1BQTVDLEdBQXFEO2tCQUNuRCxJQUFJMnNGLElBQUksR0FBRyxJQUFJTCxTQUFKLENBQWM3akMsS0FBSyxDQUFDa04sS0FBTixDQUFZbHlELEtBQVosQ0FBa0J5UyxHQUFsQixFQUF1QkEsR0FBRyxJQUFJLEVBQTlCLENBQWQsQ0FBWDtrQkFDQXV5QyxLQUFLLENBQUNqTixNQUFOLElBQWdCbXhDLElBQUksQ0FBQ254QyxNQUFyQjtrQkFDQSxLQUFLb2EsUUFBTCxDQUFjeGxDLE1BQWQsQ0FBcUIsRUFBRWh1QixDQUF2QixFQUEwQixDQUExQixFQUE2QnVxRixJQUE3QjtrQkFDQUEsSUFBSSxDQUFDM2pFLE1BQUwsR0FBYyxJQUFkOzs7Z0JBRUZ5L0IsS0FBSyxDQUFDa04sS0FBTixHQUFjbE4sS0FBSyxDQUFDa04sS0FBTixDQUFZbHlELEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUJtcUIsU0FBckIsQ0FBZDtnQkFDQSxLQUFLZy9ELFVBQUw7OztjQUVGOzs7WUFFRjNxRSxFQUFFLElBQUk0ekMsRUFBTjs7U0FyRGtCOztRQTBEdEIrMkIsVUFBVSxFQUFFLHNCQUFXO1VBQ3JCLElBQUksS0FBS2gzQixRQUFMLENBQWM1MUQsTUFBZCxJQUF3QixFQUE1QixFQUFnQztZQUFFOzs7VUFDbEMsSUFBSTZzRixFQUFFLEdBQUcsSUFBVDs7VUFDQSxHQUFHO1lBQ0QsSUFBSUMsT0FBTyxHQUFHRCxFQUFFLENBQUNqM0IsUUFBSCxDQUFZeGxDLE1BQVosQ0FBbUJ5OEQsRUFBRSxDQUFDajNCLFFBQUgsQ0FBWTUxRCxNQUFaLEdBQXFCLENBQXhDLEVBQTJDLENBQTNDLENBQWQ7WUFDQSxJQUFJK3NGLE9BQU8sR0FBRyxJQUFJTCxXQUFKLENBQWdCSSxPQUFoQixDQUFkOztZQUNBLElBQUksQ0FBQ0QsRUFBRSxDQUFDN2pFLE1BQVIsRUFBZ0I7O2NBQ2QsSUFBSSt1QyxJQUFJLEdBQUcsSUFBSTIwQixXQUFKLENBQWdCRyxFQUFFLENBQUNqM0IsUUFBbkIsQ0FBWDtjQUNBbUMsSUFBSSxDQUFDL3VDLE1BQUwsR0FBYzZqRSxFQUFkO2NBQ0FBLEVBQUUsQ0FBQ2ozQixRQUFILEdBQWMsQ0FBQ21DLElBQUQsRUFBT2cxQixPQUFQLENBQWQ7Y0FDQUYsRUFBRSxHQUFHOTBCLElBQUw7YUFKRixNQUtNO2NBQ0o4MEIsRUFBRSxDQUFDM3lFLElBQUgsSUFBVzZ5RSxPQUFPLENBQUM3eUUsSUFBbkI7Y0FDQTJ5RSxFQUFFLENBQUNyeEMsTUFBSCxJQUFhdXhDLE9BQU8sQ0FBQ3Z4QyxNQUFyQjtjQUNBLElBQUl3eEMsT0FBTyxHQUFHL3pFLE9BQU8sQ0FBQzR6RSxFQUFFLENBQUM3akUsTUFBSCxDQUFVNHNDLFFBQVgsRUFBcUJpM0IsRUFBckIsQ0FBckI7Y0FDQUEsRUFBRSxDQUFDN2pFLE1BQUgsQ0FBVTRzQyxRQUFWLENBQW1CeGxDLE1BQW5CLENBQTBCNDhELE9BQU8sR0FBRyxDQUFwQyxFQUF1QyxDQUF2QyxFQUEwQ0QsT0FBMUM7OztZQUVGQSxPQUFPLENBQUMvakUsTUFBUixHQUFpQjZqRSxFQUFFLENBQUM3akUsTUFBcEI7V0FkRixRQWVTNmpFLEVBQUUsQ0FBQ2ozQixRQUFILENBQVk1MUQsTUFBWixHQUFxQixFQWY5Qjs7VUFnQkE2c0YsRUFBRSxDQUFDN2pFLE1BQUgsQ0FBVTRqRSxVQUFWO1NBN0VvQjtRQWdGdEJILEtBQUssRUFBRSxlQUFTeHFFLEVBQVQsRUFBYXpVLENBQWIsRUFBZ0JtdUQsRUFBaEIsRUFBb0I7VUFDekIsS0FBSyxJQUFJdjVELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3d6RCxRQUFMLENBQWM1MUQsTUFBbEMsRUFBMEMsRUFBRW9DLENBQTVDLEVBQStDO1lBQzdDLElBQUlxbUQsS0FBSyxHQUFHLEtBQUttTixRQUFMLENBQWN4ekQsQ0FBZCxDQUFaO2dCQUE4Qnl6RCxFQUFFLEdBQUdwTixLQUFLLENBQUNxTixTQUFOLEVBQW5DOztZQUNBLElBQUk3ekMsRUFBRSxHQUFHNHpDLEVBQVQsRUFBYTtjQUNYLElBQUlvM0IsSUFBSSxHQUFHdHhGLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3VKLENBQVQsRUFBWXFvRCxFQUFFLEdBQUc1ekMsRUFBakIsQ0FBWDs7Y0FDQSxJQUFJd21DLEtBQUssQ0FBQ2drQyxLQUFOLENBQVl4cUUsRUFBWixFQUFnQmdyRSxJQUFoQixFQUFzQnR4QixFQUF0QixDQUFKLEVBQStCO2dCQUFFLE9BQU8sSUFBUDs7O2NBQ2pDLElBQUksQ0FBQ251RCxDQUFDLElBQUl5L0UsSUFBTixLQUFlLENBQW5CLEVBQXNCO2dCQUFFOzs7Y0FDeEJockUsRUFBRSxHQUFHLENBQUw7YUFKRixNQUtPO2NBQUVBLEVBQUUsSUFBSTR6QyxFQUFOOzs7O09BeEZmLENBamhMbUI7O01BZ25MbkIsSUFBSXEzQixVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFTejNCLEdBQVQsRUFBY2xzQyxJQUFkLEVBQW9CK2dCLE9BQXBCLEVBQTZCO1FBQzVDLElBQUlBLE9BQUosRUFBYTtVQUFFLEtBQUssSUFBSTZpRCxHQUFULElBQWdCN2lELE9BQWhCLEVBQXlCO1lBQUUsSUFBSUEsT0FBTyxDQUFDdnVDLGNBQVIsQ0FBdUJveEYsR0FBdkIsQ0FBSixFQUN4QztjQUFFLEtBQUtBLEdBQUwsSUFBWTdpRCxPQUFPLENBQUM2aUQsR0FBRCxDQUFuQjs7Ozs7UUFDSixLQUFLMTNCLEdBQUwsR0FBV0EsR0FBWDtRQUNBLEtBQUtsc0MsSUFBTCxHQUFZQSxJQUFaO09BSkY7O01BT0EyakUsVUFBVSxDQUFDcHRGLFNBQVgsQ0FBcUJ1b0IsS0FBckIsR0FBNkIsWUFBWTtRQUN2QyxJQUFJa25DLEVBQUUsR0FBRyxLQUFLa0csR0FBTCxDQUFTbEcsRUFBbEI7WUFBc0JuZ0QsRUFBRSxHQUFHLEtBQUt1L0MsSUFBTCxDQUFVd1ksT0FBckM7WUFBOEN4WSxJQUFJLEdBQUcsS0FBS0EsSUFBMUQ7WUFBZ0V5SCxFQUFFLEdBQUdELE1BQU0sQ0FBQ3hILElBQUQsQ0FBM0U7O1FBQ0EsSUFBSXlILEVBQUUsSUFBSSxJQUFOLElBQWMsQ0FBQ2huRCxFQUFuQixFQUF1QjtVQUFFOzs7UUFDekIsS0FBSyxJQUFJaE4sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dOLEVBQUUsQ0FBQ3BQLE1BQXZCLEVBQStCLEVBQUVvQyxDQUFqQyxFQUFvQztVQUFFLElBQUlnTixFQUFFLENBQUNoTixDQUFELENBQUYsSUFBUyxJQUFiLEVBQW1CO1lBQUVnTixFQUFFLENBQUNnaEIsTUFBSCxDQUFVaHVCLENBQUMsRUFBWCxFQUFlLENBQWY7Ozs7UUFDM0QsSUFBSSxDQUFDZ04sRUFBRSxDQUFDcFAsTUFBUixFQUFnQjtVQUFFMnVELElBQUksQ0FBQ3dZLE9BQUwsR0FBZSxJQUFmOzs7UUFDbEIsSUFBSTNyQixNQUFNLEdBQUdvc0IsWUFBWSxDQUFDLElBQUQsQ0FBekI7UUFDQTNSLGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPaHpELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVl3cUQsSUFBSSxDQUFDblQsTUFBTCxHQUFjQSxNQUExQixDQUFQLENBQWhCOztRQUNBLElBQUkrVCxFQUFKLEVBQVE7VUFDTnF1QixPQUFPLENBQUNydUIsRUFBRCxFQUFLLFlBQVk7WUFDdEI2OUIsNEJBQTRCLENBQUM3OUIsRUFBRCxFQUFLWixJQUFMLEVBQVcsQ0FBQ25ULE1BQVosQ0FBNUI7WUFDQTIxQixhQUFhLENBQUM1aEIsRUFBRCxFQUFLNkcsRUFBTCxFQUFTLFFBQVQsQ0FBYjtXQUZLLENBQVA7VUFJQXVPLFdBQVcsQ0FBQ3BWLEVBQUQsRUFBSyxtQkFBTCxFQUEwQkEsRUFBMUIsRUFBOEIsSUFBOUIsRUFBb0M2RyxFQUFwQyxDQUFYOztPQVpKOztNQWdCQTgyQixVQUFVLENBQUNwdEYsU0FBWCxDQUFxQjYyRSxPQUFyQixHQUErQixZQUFZO1FBQ3ZDLElBQUkwVyxNQUFNLEdBQUcsSUFBYjtRQUVGLElBQUlDLElBQUksR0FBRyxLQUFLOXhDLE1BQWhCO1lBQXdCK1QsRUFBRSxHQUFHLEtBQUtrRyxHQUFMLENBQVNsRyxFQUF0QztZQUEwQ1osSUFBSSxHQUFHLEtBQUtBLElBQXREO1FBQ0EsS0FBS25ULE1BQUwsR0FBYyxJQUFkO1FBQ0EsSUFBSTBhLElBQUksR0FBRzBSLFlBQVksQ0FBQyxJQUFELENBQVosR0FBcUIwbEIsSUFBaEM7O1FBQ0EsSUFBSSxDQUFDcDNCLElBQUwsRUFBVztVQUFFOzs7UUFDYixJQUFJLENBQUN1SixZQUFZLENBQUMsS0FBS2hLLEdBQU4sRUFBVzlHLElBQVgsQ0FBakIsRUFBbUM7VUFBRXNILGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPQSxJQUFJLENBQUNuVCxNQUFMLEdBQWMwYSxJQUFyQixDQUFoQjs7O1FBQ3JDLElBQUkzRyxFQUFKLEVBQVE7VUFDTnF1QixPQUFPLENBQUNydUIsRUFBRCxFQUFLLFlBQVk7WUFDdEJBLEVBQUUsQ0FBQ08sS0FBSCxDQUFTd2EsV0FBVCxHQUF1QixJQUF2QjtZQUNBOGlCLDRCQUE0QixDQUFDNzlCLEVBQUQsRUFBS1osSUFBTCxFQUFXdUgsSUFBWCxDQUE1QjtZQUNBeU8sV0FBVyxDQUFDcFYsRUFBRCxFQUFLLG1CQUFMLEVBQTBCQSxFQUExQixFQUE4Qjg5QixNQUE5QixFQUFzQ2wzQixNQUFNLENBQUN4SCxJQUFELENBQTVDLENBQVg7V0FISyxDQUFQOztPQVRKOztNQWdCQXNCLFVBQVUsQ0FBQ2k5QixVQUFELENBQVY7O01BRUEsU0FBU0UsNEJBQVQsQ0FBc0M3OUIsRUFBdEMsRUFBMENaLElBQTFDLEVBQWdEdUgsSUFBaEQsRUFBc0Q7UUFDcEQsSUFBSTBKLGFBQVksQ0FBQ2pSLElBQUQsQ0FBWixJQUF1QlksRUFBRSxDQUFDTyxLQUFILElBQVlQLEVBQUUsQ0FBQ08sS0FBSCxDQUFTa2QsU0FBdEIsSUFBb0N6ZCxFQUFFLENBQUNrRyxHQUFILENBQU91WCxTQUFqRSxDQUFKLEVBQ0U7VUFBRTZLLGNBQWMsQ0FBQ3RvQixFQUFELEVBQUsyRyxJQUFMLENBQWQ7Ozs7TUFHTixTQUFTcTNCLGFBQVQsQ0FBdUI5M0IsR0FBdkIsRUFBNEJqdUIsTUFBNUIsRUFBb0NqZSxJQUFwQyxFQUEwQytnQixPQUExQyxFQUFtRDtRQUNqRCxJQUFJdzRCLE1BQU0sR0FBRyxJQUFJb3FCLFVBQUosQ0FBZXozQixHQUFmLEVBQW9CbHNDLElBQXBCLEVBQTBCK2dCLE9BQTFCLENBQWI7UUFDQSxJQUFJaWxCLEVBQUUsR0FBR2tHLEdBQUcsQ0FBQ2xHLEVBQWI7O1FBQ0EsSUFBSUEsRUFBRSxJQUFJdVQsTUFBTSxDQUFDeUUsU0FBakIsRUFBNEI7VUFBRWhZLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdzNkUsWUFBWCxHQUEwQixJQUExQjs7O1FBQzlCc0wsVUFBVSxDQUFDMzJCLEdBQUQsRUFBTWp1QixNQUFOLEVBQWMsUUFBZCxFQUF3QixVQUFVbW5CLElBQVYsRUFBZ0I7VUFDaEQsSUFBSXdZLE9BQU8sR0FBR3hZLElBQUksQ0FBQ3dZLE9BQUwsS0FBaUJ4WSxJQUFJLENBQUN3WSxPQUFMLEdBQWUsRUFBaEMsQ0FBZDs7VUFDQSxJQUFJckUsTUFBTSxDQUFDMHFCLFFBQVAsSUFBbUIsSUFBdkIsRUFBNkI7WUFBRXJtQixPQUFPLENBQUNwb0UsSUFBUixDQUFhK2pFLE1BQWI7V0FBL0IsTUFDSztZQUFFcUUsT0FBTyxDQUFDLzJDLE1BQVIsQ0FBZXowQixJQUFJLENBQUNzSSxHQUFMLENBQVNrakUsT0FBTyxDQUFDbm5FLE1BQWpCLEVBQXlCckUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLENBQVQsRUFBWTIrRCxNQUFNLENBQUMwcUIsUUFBbkIsQ0FBekIsQ0FBZixFQUF1RSxDQUF2RSxFQUEwRTFxQixNQUExRTs7O1VBQ1BBLE1BQU0sQ0FBQ25VLElBQVAsR0FBY0EsSUFBZDs7VUFDQSxJQUFJWSxFQUFFLElBQUksQ0FBQ2tRLFlBQVksQ0FBQ2hLLEdBQUQsRUFBTTlHLElBQU4sQ0FBdkIsRUFBb0M7WUFDbEMsSUFBSTgrQixZQUFZLEdBQUc3dEIsYUFBWSxDQUFDalIsSUFBRCxDQUFaLEdBQXFCOEcsR0FBRyxDQUFDdVgsU0FBNUM7WUFDQS9XLGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPQSxJQUFJLENBQUNuVCxNQUFMLEdBQWNvc0IsWUFBWSxDQUFDOUUsTUFBRCxDQUFqQyxDQUFoQjs7WUFDQSxJQUFJMnFCLFlBQUosRUFBa0I7Y0FBRTVWLGNBQWMsQ0FBQ3RvQixFQUFELEVBQUt1VCxNQUFNLENBQUN0bkIsTUFBWixDQUFkOzs7WUFDcEIrVCxFQUFFLENBQUNPLEtBQUgsQ0FBU3dhLFdBQVQsR0FBdUIsSUFBdkI7OztVQUVGLE9BQU8sSUFBUDtTQVhRLENBQVY7O1FBYUEsSUFBSS9hLEVBQUosRUFBUTtVQUFFb1YsV0FBVyxDQUFDcFYsRUFBRCxFQUFLLGlCQUFMLEVBQXdCQSxFQUF4QixFQUE0QnVULE1BQTVCLEVBQW9DLE9BQU90N0IsTUFBUCxJQUFpQixRQUFqQixHQUE0QkEsTUFBNUIsR0FBcUMydUIsTUFBTSxDQUFDM3VCLE1BQUQsQ0FBL0UsQ0FBWDs7O1FBQ1YsT0FBT3M3QixNQUFQO09BaHJMaUI7Ozs7Ozs7Ozs7Ozs7OztNQWtzTG5CLElBQUk0cUIsWUFBWSxHQUFHLENBQW5COztNQUVBLElBQUlDLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVNsNEIsR0FBVCxFQUFjajFELElBQWQsRUFBb0I7UUFDbkMsS0FBS20xRCxLQUFMLEdBQWEsRUFBYjtRQUNBLEtBQUtuMUQsSUFBTCxHQUFZQSxJQUFaO1FBQ0EsS0FBS2kxRCxHQUFMLEdBQVdBLEdBQVg7UUFDQSxLQUFLajNELEVBQUwsR0FBVSxFQUFFa3ZGLFlBQVo7T0FKRixDQXBzTG1COzs7TUE0c0xuQkMsVUFBVSxDQUFDN3RGLFNBQVgsQ0FBcUJ1b0IsS0FBckIsR0FBNkIsWUFBWTtRQUN2QyxJQUFJLEtBQUswL0QsaUJBQVQsRUFBNEI7VUFBRTs7O1FBQzlCLElBQUl4NEIsRUFBRSxHQUFHLEtBQUtrRyxHQUFMLENBQVNsRyxFQUFsQjtZQUFzQnErQixNQUFNLEdBQUdyK0IsRUFBRSxJQUFJLENBQUNBLEVBQUUsQ0FBQ08sS0FBekM7O1FBQ0EsSUFBSTg5QixNQUFKLEVBQVk7VUFBRS9SLGVBQWMsQ0FBQ3RzQixFQUFELENBQWQ7OztRQUNkLElBQUlTLFVBQVUsQ0FBQyxJQUFELEVBQU8sT0FBUCxDQUFkLEVBQStCO1VBQzdCLElBQUk1RCxLQUFLLEdBQUcsS0FBS2xzQyxJQUFMLEVBQVo7O1VBQ0EsSUFBSWtzQyxLQUFKLEVBQVc7WUFBRXVZLFdBQVcsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQnZZLEtBQUssQ0FBQ2p3QyxJQUF0QixFQUE0Qml3QyxLQUFLLENBQUN6c0MsRUFBbEMsQ0FBWDs7OztRQUVmLElBQUkxYixHQUFHLEdBQUcsSUFBVjtZQUFnQkUsR0FBRyxHQUFHLElBQXRCOztRQUNBLEtBQUssSUFBSS9CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3V6RCxLQUFMLENBQVczMUQsTUFBL0IsRUFBdUMsRUFBRW9DLENBQXpDLEVBQTRDO1VBQzFDLElBQUl1c0QsSUFBSSxHQUFHLEtBQUtnSCxLQUFMLENBQVd2ekQsQ0FBWCxDQUFYO1VBQ0EsSUFBSW81RCxJQUFJLEdBQUdGLGdCQUFnQixDQUFDM00sSUFBSSxDQUFDa04sV0FBTixFQUFtQixJQUFuQixDQUEzQjs7VUFDQSxJQUFJdE0sRUFBRSxJQUFJLENBQUMsS0FBS29QLFNBQWhCLEVBQTJCO1lBQUV3UyxhQUFhLENBQUM1aEIsRUFBRCxFQUFLNEcsTUFBTSxDQUFDeEgsSUFBRCxDQUFYLEVBQW1CLE1BQW5CLENBQWI7V0FBN0IsTUFDSyxJQUFJWSxFQUFKLEVBQVE7WUFDWCxJQUFJaU0sSUFBSSxDQUFDNzdDLEVBQUwsSUFBVyxJQUFmLEVBQXFCO2NBQUV4YixHQUFHLEdBQUdneUQsTUFBTSxDQUFDeEgsSUFBRCxDQUFaOzs7WUFDdkIsSUFBSTZNLElBQUksQ0FBQ3IvQyxJQUFMLElBQWEsSUFBakIsRUFBdUI7Y0FBRWxZLEdBQUcsR0FBR2t5RCxNQUFNLENBQUN4SCxJQUFELENBQVo7Ozs7VUFFM0JBLElBQUksQ0FBQ2tOLFdBQUwsR0FBbUJKLGdCQUFnQixDQUFDOU0sSUFBSSxDQUFDa04sV0FBTixFQUFtQkwsSUFBbkIsQ0FBbkM7O1VBQ0EsSUFBSUEsSUFBSSxDQUFDci9DLElBQUwsSUFBYSxJQUFiLElBQXFCLEtBQUt3aUQsU0FBMUIsSUFBdUMsQ0FBQ2MsWUFBWSxDQUFDLEtBQUtoSyxHQUFOLEVBQVc5RyxJQUFYLENBQXBELElBQXdFWSxFQUE1RSxFQUNFO1lBQUUwRyxnQkFBZ0IsQ0FBQ3RILElBQUQsRUFBT2doQixVQUFVLENBQUNwZ0IsRUFBRSxDQUFDL29ELE9BQUosQ0FBakIsQ0FBaEI7Ozs7UUFFTixJQUFJK29ELEVBQUUsSUFBSSxLQUFLb1AsU0FBWCxJQUF3QixDQUFDcFAsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUF4QyxFQUFzRDtVQUFFLEtBQUssSUFBSWhjLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUcsS0FBS3FJLEtBQUwsQ0FBVzMxRCxNQUFuQyxFQUEyQyxFQUFFc3RELEdBQTdDLEVBQWtEO1lBQ3hHLElBQUl1Z0MsTUFBTSxHQUFHN3VCLFVBQVUsQ0FBQyxLQUFLckosS0FBTCxDQUFXckksR0FBWCxDQUFELENBQXZCO2dCQUEwQy8vQyxHQUFHLEdBQUd1eUQsVUFBVSxDQUFDK3RCLE1BQUQsQ0FBMUQ7O1lBQ0EsSUFBSXRnRixHQUFHLEdBQUdnaUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3k1RCxhQUFyQixFQUFvQztjQUNsQzFRLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd3NUQsT0FBWCxHQUFxQjZ0QixNQUFyQjtjQUNBdCtCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd5NUQsYUFBWCxHQUEyQjF5RCxHQUEzQjtjQUNBZ2lELEVBQUUsQ0FBQy9vRCxPQUFILENBQVcwNUQsY0FBWCxHQUE0QixJQUE1Qjs7Ozs7UUFJSixJQUFJajhELEdBQUcsSUFBSSxJQUFQLElBQWVzckQsRUFBZixJQUFxQixLQUFLb1AsU0FBOUIsRUFBeUM7VUFBRThSLFNBQVMsQ0FBQ2xoQixFQUFELEVBQUt0ckQsR0FBTCxFQUFVRSxHQUFHLEdBQUcsQ0FBaEIsQ0FBVDs7O1FBQzNDLEtBQUt3eEQsS0FBTCxDQUFXMzFELE1BQVgsR0FBb0IsQ0FBcEI7UUFDQSxLQUFLK25GLGlCQUFMLEdBQXlCLElBQXpCOztRQUNBLElBQUksS0FBS21DLE1BQUwsSUFBZSxLQUFLejBCLEdBQUwsQ0FBUzYwQixRQUE1QixFQUFzQztVQUNwQyxLQUFLNzBCLEdBQUwsQ0FBUzYwQixRQUFULEdBQW9CLEtBQXBCOztVQUNBLElBQUkvNkIsRUFBSixFQUFRO1lBQUVnNkIsZ0JBQWdCLENBQUNoNkIsRUFBRSxDQUFDa0csR0FBSixDQUFoQjs7OztRQUVaLElBQUlsRyxFQUFKLEVBQVE7VUFBRW9WLFdBQVcsQ0FBQ3BWLEVBQUQsRUFBSyxlQUFMLEVBQXNCQSxFQUF0QixFQUEwQixJQUExQixFQUFnQ3RyRCxHQUFoQyxFQUFxQ0UsR0FBckMsQ0FBWDs7O1FBQ1YsSUFBSXlwRixNQUFKLEVBQVk7VUFBRXhSLGFBQVksQ0FBQzdzQixFQUFELENBQVo7OztRQUNkLElBQUksS0FBS3ZtQyxNQUFULEVBQWlCO1VBQUUsS0FBS0EsTUFBTCxDQUFZWCxLQUFaOztPQXZDckIsQ0E1c0xtQjs7Ozs7OztNQTJ2TG5Cc2xFLFVBQVUsQ0FBQzd0RixTQUFYLENBQXFCb2dCLElBQXJCLEdBQTRCLFVBQVVtekQsSUFBVixFQUFnQnhULE9BQWhCLEVBQXlCO1FBQ25ELElBQUl3VCxJQUFJLElBQUksSUFBUixJQUFnQixLQUFLN3lFLElBQUwsSUFBYSxVQUFqQyxFQUE2QztVQUFFNnlFLElBQUksR0FBRyxDQUFQOzs7UUFDL0MsSUFBSWwzRCxJQUFKLEVBQVV3RCxFQUFWOztRQUNBLEtBQUssSUFBSXZkLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3V6RCxLQUFMLENBQVczMUQsTUFBL0IsRUFBdUMsRUFBRW9DLENBQXpDLEVBQTRDO1VBQzFDLElBQUl1c0QsSUFBSSxHQUFHLEtBQUtnSCxLQUFMLENBQVd2ekQsQ0FBWCxDQUFYO1VBQ0EsSUFBSW81RCxJQUFJLEdBQUdGLGdCQUFnQixDQUFDM00sSUFBSSxDQUFDa04sV0FBTixFQUFtQixJQUFuQixDQUEzQjs7VUFDQSxJQUFJTCxJQUFJLENBQUNyL0MsSUFBTCxJQUFhLElBQWpCLEVBQXVCO1lBQ3JCQSxJQUFJLEdBQUd5NkMsR0FBRyxDQUFDaUosT0FBTyxHQUFHbFIsSUFBSCxHQUFVd0gsTUFBTSxDQUFDeEgsSUFBRCxDQUF4QixFQUFnQzZNLElBQUksQ0FBQ3IvQyxJQUFyQyxDQUFWOztZQUNBLElBQUlrM0QsSUFBSSxJQUFJLENBQUMsQ0FBYixFQUFnQjtjQUFFLE9BQU9sM0QsSUFBUDs7OztVQUVwQixJQUFJcS9DLElBQUksQ0FBQzc3QyxFQUFMLElBQVcsSUFBZixFQUFxQjtZQUNuQkEsRUFBRSxHQUFHaTNDLEdBQUcsQ0FBQ2lKLE9BQU8sR0FBR2xSLElBQUgsR0FBVXdILE1BQU0sQ0FBQ3hILElBQUQsQ0FBeEIsRUFBZ0M2TSxJQUFJLENBQUM3N0MsRUFBckMsQ0FBUjs7WUFDQSxJQUFJMHpELElBQUksSUFBSSxDQUFaLEVBQWU7Y0FBRSxPQUFPMXpELEVBQVA7Ozs7O1FBR3JCLE9BQU94RCxJQUFJLElBQUk7VUFBQ0EsSUFBSSxFQUFFQSxJQUFQO1VBQWF3RCxFQUFFLEVBQUVBO1NBQWhDO09BZkYsQ0EzdkxtQjs7OztNQSt3TG5CZ3VFLFVBQVUsQ0FBQzd0RixTQUFYLENBQXFCNjJFLE9BQXJCLEdBQStCLFlBQVk7UUFDdkMsSUFBSTBXLE1BQU0sR0FBRyxJQUFiO1FBRUYsSUFBSW4zRSxHQUFHLEdBQUcsS0FBS2dLLElBQUwsQ0FBVSxDQUFDLENBQVgsRUFBYyxJQUFkLENBQVY7WUFBK0I0aUQsTUFBTSxHQUFHLElBQXhDO1lBQThDdlQsRUFBRSxHQUFHLEtBQUtrRyxHQUFMLENBQVNsRyxFQUE1RDs7UUFDQSxJQUFJLENBQUNyNUMsR0FBRCxJQUFRLENBQUNxNUMsRUFBYixFQUFpQjtVQUFFOzs7UUFDbkJxdUIsT0FBTyxDQUFDcnVCLEVBQUQsRUFBSyxZQUFZO1VBQ3RCLElBQUlaLElBQUksR0FBR3o0QyxHQUFHLENBQUN5NEMsSUFBZjtjQUFxQjBRLEtBQUssR0FBR2xKLE1BQU0sQ0FBQ2pnRCxHQUFHLENBQUN5NEMsSUFBTCxDQUFuQztVQUNBLElBQUlqN0IsSUFBSSxHQUFHeTJDLGVBQWUsQ0FBQzVhLEVBQUQsRUFBSzhQLEtBQUwsQ0FBMUI7O1VBQ0EsSUFBSTNyQyxJQUFKLEVBQVU7WUFDUnk0Qyw0QkFBNEIsQ0FBQ3o0QyxJQUFELENBQTVCO1lBQ0E2N0IsRUFBRSxDQUFDTyxLQUFILENBQVNtc0IsZ0JBQVQsR0FBNEIxc0IsRUFBRSxDQUFDTyxLQUFILENBQVN3YSxXQUFULEdBQXVCLElBQW5EOzs7VUFFRi9hLEVBQUUsQ0FBQ08sS0FBSCxDQUFTb3NCLGFBQVQsR0FBeUIsSUFBekI7O1VBQ0EsSUFBSSxDQUFDemMsWUFBWSxDQUFDcUQsTUFBTSxDQUFDck4sR0FBUixFQUFhOUcsSUFBYixDQUFiLElBQW1DbVUsTUFBTSxDQUFDdG5CLE1BQVAsSUFBaUIsSUFBeEQsRUFBOEQ7WUFDNUQsSUFBSW02QixTQUFTLEdBQUc3UyxNQUFNLENBQUN0bkIsTUFBdkI7WUFDQXNuQixNQUFNLENBQUN0bkIsTUFBUCxHQUFnQixJQUFoQjtZQUNBLElBQUlzeUMsT0FBTyxHQUFHbG1CLFlBQVksQ0FBQzlFLE1BQUQsQ0FBWixHQUF1QjZTLFNBQXJDOztZQUNBLElBQUltWSxPQUFKLEVBQ0U7Y0FBRTczQixnQkFBZ0IsQ0FBQ3RILElBQUQsRUFBT0EsSUFBSSxDQUFDblQsTUFBTCxHQUFjc3lDLE9BQXJCLENBQWhCOzs7O1VBRU5ucEIsV0FBVyxDQUFDcFYsRUFBRCxFQUFLLGVBQUwsRUFBc0JBLEVBQXRCLEVBQTBCODlCLE1BQTFCLENBQVg7U0FmSyxDQUFQO09BTEY7O01Bd0JBTSxVQUFVLENBQUM3dEYsU0FBWCxDQUFxQmc4RCxVQUFyQixHQUFrQyxVQUFVbk4sSUFBVixFQUFnQjtRQUNoRCxJQUFJLENBQUMsS0FBS2dILEtBQUwsQ0FBVzMxRCxNQUFaLElBQXNCLEtBQUt5MUQsR0FBTCxDQUFTbEcsRUFBbkMsRUFBdUM7VUFDckMsSUFBSW9NLEVBQUUsR0FBRyxLQUFLbEcsR0FBTCxDQUFTbEcsRUFBVCxDQUFZTyxLQUFyQjs7VUFDQSxJQUFJLENBQUM2TCxFQUFFLENBQUM4aEIsa0JBQUosSUFBMEJ4a0UsT0FBTyxDQUFDMGlELEVBQUUsQ0FBQzhoQixrQkFBSixFQUF3QixJQUF4QixDQUFQLElBQXdDLENBQUMsQ0FBdkUsRUFDRTtZQUFFLENBQUM5aEIsRUFBRSxDQUFDZ2lCLG9CQUFILEtBQTRCaGlCLEVBQUUsQ0FBQ2dpQixvQkFBSCxHQUEwQixFQUF0RCxDQUFELEVBQTRENStFLElBQTVELENBQWlFLElBQWpFOzs7O1FBRU4sS0FBSzQyRCxLQUFMLENBQVc1MkQsSUFBWCxDQUFnQjR2RCxJQUFoQjtPQU5GOztNQVNBZy9CLFVBQVUsQ0FBQzd0RixTQUFYLENBQXFCZytELFVBQXJCLEdBQWtDLFVBQVVuUCxJQUFWLEVBQWdCO1FBQ2hELEtBQUtnSCxLQUFMLENBQVd2bEMsTUFBWCxDQUFrQm5YLE9BQU8sQ0FBQyxLQUFLMDhDLEtBQU4sRUFBYWhILElBQWIsQ0FBekIsRUFBNkMsQ0FBN0M7O1FBQ0EsSUFBSSxDQUFDLEtBQUtnSCxLQUFMLENBQVczMUQsTUFBWixJQUFzQixLQUFLeTFELEdBQUwsQ0FBU2xHLEVBQW5DLEVBQXVDO1VBQ3JDLElBQUlvTSxFQUFFLEdBQUcsS0FBS2xHLEdBQUwsQ0FBU2xHLEVBQVQsQ0FBWU8sS0FBckI7VUFDQyxDQUFDNkwsRUFBRSxDQUFDOGhCLGtCQUFILEtBQTBCOWhCLEVBQUUsQ0FBQzhoQixrQkFBSCxHQUF3QixFQUFsRCxDQUFELEVBQXdEMStFLElBQXhELENBQTZELElBQTdEOztPQUpMOztNQU9Ba3hELFVBQVUsQ0FBQzA5QixVQUFELENBQVYsQ0F2ekxtQjs7TUEwekxuQixTQUFTSSxTQUFULENBQWtCdDRCLEdBQWxCLEVBQXVCdDVDLElBQXZCLEVBQTZCd0QsRUFBN0IsRUFBaUMycUIsT0FBakMsRUFBMEM5cEMsSUFBMUMsRUFBZ0Q7Ozs7UUFJOUMsSUFBSThwQyxPQUFPLElBQUlBLE9BQU8sQ0FBQzFsQyxNQUF2QixFQUErQjtVQUFFLE9BQU9vcEYsY0FBYyxDQUFDdjRCLEdBQUQsRUFBTXQ1QyxJQUFOLEVBQVl3RCxFQUFaLEVBQWdCMnFCLE9BQWhCLEVBQXlCOXBDLElBQXpCLENBQXJCO1NBSmE7OztRQU05QyxJQUFJaTFELEdBQUcsQ0FBQ2xHLEVBQUosSUFBVSxDQUFDa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPTyxLQUF0QixFQUE2QjtVQUFFLE9BQU94TyxTQUFTLENBQUNtVSxHQUFHLENBQUNsRyxFQUFMLEVBQVN3K0IsU0FBVCxDQUFULENBQTRCdDRCLEdBQTVCLEVBQWlDdDVDLElBQWpDLEVBQXVDd0QsRUFBdkMsRUFBMkMycUIsT0FBM0MsRUFBb0Q5cEMsSUFBcEQsQ0FBUDs7O1FBRS9CLElBQUl1b0MsTUFBTSxHQUFHLElBQUk0a0QsVUFBSixDQUFlbDRCLEdBQWYsRUFBb0JqMUQsSUFBcEIsQ0FBYjtZQUF3QzAxRCxJQUFJLEdBQUdXLEdBQUcsQ0FBQzE2QyxJQUFELEVBQU93RCxFQUFQLENBQWxEOztRQUNBLElBQUkycUIsT0FBSixFQUFhO1VBQUU4ZSxPQUFPLENBQUM5ZSxPQUFELEVBQVV2QixNQUFWLEVBQWtCLEtBQWxCLENBQVA7U0FUK0I7OztRQVc5QyxJQUFJbXRCLElBQUksR0FBRyxDQUFQLElBQVlBLElBQUksSUFBSSxDQUFSLElBQWFudEIsTUFBTSxDQUFDczBCLGNBQVAsS0FBMEIsS0FBdkQsRUFDRTtVQUFFLE9BQU90MEIsTUFBUDs7O1FBQ0osSUFBSUEsTUFBTSxDQUFDa2xELFlBQVgsRUFBeUI7O1VBRXZCbGxELE1BQU0sQ0FBQzQxQixTQUFQLEdBQW1CLElBQW5CO1VBQ0E1MUIsTUFBTSxDQUFDMjJCLFVBQVAsR0FBb0IzWCxJQUFJLENBQUMsTUFBRCxFQUFTLENBQUNoZixNQUFNLENBQUNrbEQsWUFBUixDQUFULEVBQWdDLG1CQUFoQyxDQUF4Qjs7VUFDQSxJQUFJLENBQUMzakQsT0FBTyxDQUFDODhCLGlCQUFiLEVBQWdDO1lBQUVyK0IsTUFBTSxDQUFDMjJCLFVBQVAsQ0FBa0I5dUIsWUFBbEIsQ0FBK0Isa0JBQS9CLEVBQW1ELE1BQW5EOzs7VUFDbEMsSUFBSXRHLE9BQU8sQ0FBQyt4QixVQUFaLEVBQXdCO1lBQUV0ekIsTUFBTSxDQUFDMjJCLFVBQVAsQ0FBa0JyRCxVQUFsQixHQUErQixJQUEvQjs7OztRQUU1QixJQUFJdHpCLE1BQU0sQ0FBQzQxQixTQUFYLEVBQXNCO1VBQ3BCLElBQUlJLHlCQUF5QixDQUFDdEosR0FBRCxFQUFNdDVDLElBQUksQ0FBQ3d5QyxJQUFYLEVBQWlCeHlDLElBQWpCLEVBQXVCd0QsRUFBdkIsRUFBMkJvcEIsTUFBM0IsQ0FBekIsSUFDQTVzQixJQUFJLENBQUN3eUMsSUFBTCxJQUFhaHZDLEVBQUUsQ0FBQ2d2QyxJQUFoQixJQUF3Qm9RLHlCQUF5QixDQUFDdEosR0FBRCxFQUFNOTFDLEVBQUUsQ0FBQ2d2QyxJQUFULEVBQWV4eUMsSUFBZixFQUFxQndELEVBQXJCLEVBQXlCb3BCLE1BQXpCLENBRHJELEVBRUU7WUFBRSxNQUFNLElBQUlyRCxLQUFKLENBQVUsa0VBQVYsQ0FBTjs7O1VBQ0owMUIsaUJBQWlCOzs7UUFHbkIsSUFBSXJ5QixNQUFNLENBQUNtbEQsWUFBWCxFQUNFO1VBQUUvRyxrQkFBa0IsQ0FBQzF4QixHQUFELEVBQU07WUFBQ3Q1QyxJQUFJLEVBQUVBLElBQVA7WUFBYXdELEVBQUUsRUFBRUEsRUFBakI7WUFBcUIycUMsTUFBTSxFQUFFO1dBQW5DLEVBQWdEbUwsR0FBRyxDQUFDdWMsR0FBcEQsRUFBeUQxaEUsR0FBekQsQ0FBbEI7OztRQUVKLElBQUk2OUUsT0FBTyxHQUFHaHlFLElBQUksQ0FBQ3d5QyxJQUFuQjtZQUF5QlksRUFBRSxHQUFHa0csR0FBRyxDQUFDbEcsRUFBbEM7WUFBc0Myc0IsYUFBdEM7UUFDQXptQixHQUFHLENBQUNuNUMsSUFBSixDQUFTNnhFLE9BQVQsRUFBa0J4dUUsRUFBRSxDQUFDZ3ZDLElBQUgsR0FBVSxDQUE1QixFQUErQixVQUFVQSxJQUFWLEVBQWdCO1VBQzdDLElBQUlZLEVBQUUsSUFBSXhtQixNQUFNLENBQUM0MUIsU0FBYixJQUEwQixDQUFDcFAsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2cvQixZQUF0QyxJQUFzRHRLLFVBQVUsQ0FBQ3JRLElBQUQsQ0FBVixJQUFvQlksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3c1RCxPQUF6RixFQUNFO1lBQUVrYyxhQUFhLEdBQUcsSUFBaEI7OztVQUNKLElBQUluekMsTUFBTSxDQUFDNDFCLFNBQVAsSUFBb0J3dkIsT0FBTyxJQUFJaHlFLElBQUksQ0FBQ3d5QyxJQUF4QyxFQUE4QztZQUFFc0gsZ0JBQWdCLENBQUN0SCxJQUFELEVBQU8sQ0FBUCxDQUFoQjs7O1VBQ2hEK00sYUFBYSxDQUFDL00sSUFBRCxFQUFPLElBQUkwTSxVQUFKLENBQWV0eUIsTUFBZixFQUNlb2xELE9BQU8sSUFBSWh5RSxJQUFJLENBQUN3eUMsSUFBaEIsR0FBdUJ4eUMsSUFBSSxDQUFDMEksRUFBNUIsR0FBaUMsSUFEaEQsRUFFZXNwRSxPQUFPLElBQUl4dUUsRUFBRSxDQUFDZ3ZDLElBQWQsR0FBcUJodkMsRUFBRSxDQUFDa0YsRUFBeEIsR0FBNkIsSUFGNUMsQ0FBUCxFQUUwRDR3QyxHQUFHLENBQUNsRyxFQUFKLElBQVVrRyxHQUFHLENBQUNsRyxFQUFKLENBQU9PLEtBRjNFLENBQWI7VUFHQSxFQUFFcStCLE9BQUY7U0FQRixFQS9COEM7O1FBeUM5QyxJQUFJcGxELE1BQU0sQ0FBQzQxQixTQUFYLEVBQXNCO1VBQUVsSixHQUFHLENBQUNuNUMsSUFBSixDQUFTSCxJQUFJLENBQUN3eUMsSUFBZCxFQUFvQmh2QyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQTlCLEVBQWlDLFVBQVVBLElBQVYsRUFBZ0I7WUFDdkUsSUFBSThRLFlBQVksQ0FBQ2hLLEdBQUQsRUFBTTlHLElBQU4sQ0FBaEIsRUFBNkI7Y0FBRXNILGdCQUFnQixDQUFDdEgsSUFBRCxFQUFPLENBQVAsQ0FBaEI7O1dBRFQ7OztRQUl4QixJQUFJNWxCLE1BQU0sQ0FBQ3FsRCxZQUFYLEVBQXlCO1VBQUV2L0IsRUFBRSxDQUFDOWxCLE1BQUQsRUFBUyxtQkFBVCxFQUE4QixZQUFZO1lBQUUsT0FBT0EsTUFBTSxDQUFDMWdCLEtBQVAsRUFBUDtXQUE1QyxDQUFGOzs7UUFFM0IsSUFBSTBnQixNQUFNLENBQUN5MEIsUUFBWCxFQUFxQjtVQUNuQnJDLGdCQUFnQjs7VUFDaEIsSUFBSTFGLEdBQUcsQ0FBQzZ4QixPQUFKLENBQVlwdkUsSUFBWixDQUFpQmxZLE1BQWpCLElBQTJCeTFELEdBQUcsQ0FBQzZ4QixPQUFKLENBQVluQixNQUFaLENBQW1Cbm1GLE1BQWxELEVBQ0U7WUFBRXkxRCxHQUFHLENBQUM0NEIsWUFBSjs7OztRQUVOLElBQUl0bEQsTUFBTSxDQUFDNDFCLFNBQVgsRUFBc0I7VUFDcEI1MUIsTUFBTSxDQUFDdnFDLEVBQVAsR0FBWSxFQUFFa3ZGLFlBQWQ7VUFDQTNrRCxNQUFNLENBQUNtaEQsTUFBUCxHQUFnQixJQUFoQjs7O1FBRUYsSUFBSTM2QixFQUFKLEVBQVE7O1VBRU4sSUFBSTJzQixhQUFKLEVBQW1CO1lBQUUzc0IsRUFBRSxDQUFDTyxLQUFILENBQVNvc0IsYUFBVCxHQUF5QixJQUF6Qjs7O1VBQ3JCLElBQUluekMsTUFBTSxDQUFDNDFCLFNBQVgsRUFDRTtZQUFFOFIsU0FBUyxDQUFDbGhCLEVBQUQsRUFBS3B6QyxJQUFJLENBQUN3eUMsSUFBVixFQUFnQmh2QyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQTFCLENBQVQ7V0FESixNQUVLLElBQUk1bEIsTUFBTSxDQUFDMmUsU0FBUCxJQUFvQjNlLE1BQU0sQ0FBQ2c1QixVQUEzQixJQUF5Q2g1QixNQUFNLENBQUNpNUIsUUFBaEQsSUFBNERqNUIsTUFBTSxDQUFDMkosR0FBbkUsSUFDQTNKLE1BQU0sQ0FBQ3hMLFVBRFAsSUFDcUJ3TCxNQUFNLENBQUMrNEIsS0FEaEMsRUFFSDtZQUFFLEtBQUssSUFBSTEvRCxDQUFDLEdBQUcrWixJQUFJLENBQUN3eUMsSUFBbEIsRUFBd0J2c0QsQ0FBQyxJQUFJdWQsRUFBRSxDQUFDZ3ZDLElBQWhDLEVBQXNDdnNELENBQUMsRUFBdkMsRUFBMkM7Y0FBRSt1RSxhQUFhLENBQUM1aEIsRUFBRCxFQUFLbnRELENBQUwsRUFBUSxNQUFSLENBQWI7Ozs7VUFDakQsSUFBSTJtQyxNQUFNLENBQUNtaEQsTUFBWCxFQUFtQjtZQUFFWCxnQkFBZ0IsQ0FBQ2g2QixFQUFFLENBQUNrRyxHQUFKLENBQWhCOzs7VUFDckJrUCxXQUFXLENBQUNwVixFQUFELEVBQUssYUFBTCxFQUFvQkEsRUFBcEIsRUFBd0J4bUIsTUFBeEIsQ0FBWDs7O1FBRUYsT0FBT0EsTUFBUDtPQTczTGlCOzs7Ozs7TUFxNExuQixJQUFJdWxELGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBUy93QixPQUFULEVBQWtCcVUsT0FBbEIsRUFBMkI7UUFDaEQsS0FBS3JVLE9BQUwsR0FBZUEsT0FBZjtRQUNBLEtBQUtxVSxPQUFMLEdBQWVBLE9BQWY7O1FBQ0EsS0FBSyxJQUFJeHZFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtN0QsT0FBTyxDQUFDdjlELE1BQTVCLEVBQW9DLEVBQUVvQyxDQUF0QyxFQUNFO1VBQUVtN0QsT0FBTyxDQUFDbjdELENBQUQsQ0FBUCxDQUFXNG1CLE1BQVgsR0FBb0IsSUFBcEI7O09BSk47O01BT0FzbEUsZ0JBQWdCLENBQUN4dUYsU0FBakIsQ0FBMkJ1b0IsS0FBM0IsR0FBbUMsWUFBWTtRQUM3QyxJQUFJLEtBQUswL0QsaUJBQVQsRUFBNEI7VUFBRTs7O1FBQzlCLEtBQUtBLGlCQUFMLEdBQXlCLElBQXpCOztRQUNBLEtBQUssSUFBSTNsRixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUttN0QsT0FBTCxDQUFhdjlELE1BQWpDLEVBQXlDLEVBQUVvQyxDQUEzQyxFQUNFO1VBQUUsS0FBS203RCxPQUFMLENBQWFuN0QsQ0FBYixFQUFnQmltQixLQUFoQjs7O1FBQ0pzOEMsV0FBVyxDQUFDLElBQUQsRUFBTyxPQUFQLENBQVg7T0FMRjs7TUFRQTJwQixnQkFBZ0IsQ0FBQ3h1RixTQUFqQixDQUEyQm9nQixJQUEzQixHQUFrQyxVQUFVbXpELElBQVYsRUFBZ0J4VCxPQUFoQixFQUF5QjtRQUN6RCxPQUFPLEtBQUsrUixPQUFMLENBQWExeEQsSUFBYixDQUFrQm16RCxJQUFsQixFQUF3QnhULE9BQXhCLENBQVA7T0FERjs7TUFHQTVQLFVBQVUsQ0FBQ3ErQixnQkFBRCxDQUFWOztNQUVBLFNBQVNOLGNBQVQsQ0FBd0J2NEIsR0FBeEIsRUFBNkJ0NUMsSUFBN0IsRUFBbUN3RCxFQUFuQyxFQUF1QzJxQixPQUF2QyxFQUFnRDlwQyxJQUFoRCxFQUFzRDtRQUNwRDhwQyxPQUFPLEdBQUc4ZSxPQUFPLENBQUM5ZSxPQUFELENBQWpCO1FBQ0FBLE9BQU8sQ0FBQzFsQyxNQUFSLEdBQWlCLEtBQWpCO1FBQ0EsSUFBSTI0RCxPQUFPLEdBQUcsQ0FBQ3d3QixTQUFRLENBQUN0NEIsR0FBRCxFQUFNdDVDLElBQU4sRUFBWXdELEVBQVosRUFBZ0IycUIsT0FBaEIsRUFBeUI5cEMsSUFBekIsQ0FBVCxDQUFkO1lBQXdEb3hFLE9BQU8sR0FBR3JVLE9BQU8sQ0FBQyxDQUFELENBQXpFO1FBQ0EsSUFBSXVGLE1BQU0sR0FBR3g0QixPQUFPLENBQUNvMUIsVUFBckI7UUFDQThsQixVQUFVLENBQUMvdkIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZTtVQUM3QixJQUFJcU4sTUFBSixFQUFZO1lBQUV4NEIsT0FBTyxDQUFDbzFCLFVBQVIsR0FBcUJvRCxNQUFNLENBQUN5ckIsU0FBUCxDQUFpQixJQUFqQixDQUFyQjs7O1VBQ2RoeEIsT0FBTyxDQUFDeCtELElBQVIsQ0FBYWd2RixTQUFRLENBQUN0NEIsR0FBRCxFQUFNMEIsUUFBTyxDQUFDMUIsR0FBRCxFQUFNdDVDLElBQU4sQ0FBYixFQUEwQmc3QyxRQUFPLENBQUMxQixHQUFELEVBQU05MUMsRUFBTixDQUFqQyxFQUE0QzJxQixPQUE1QyxFQUFxRDlwQyxJQUFyRCxDQUFyQjs7VUFDQSxLQUFLLElBQUk0QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcXpELEdBQUcsQ0FBQ293QixNQUFKLENBQVc3bEYsTUFBL0IsRUFBdUMsRUFBRW9DLENBQXpDLEVBQ0U7WUFBRSxJQUFJcXpELEdBQUcsQ0FBQ293QixNQUFKLENBQVd6akYsQ0FBWCxFQUFjb3NGLFFBQWxCLEVBQTRCO2NBQUU7Ozs7VUFDbEM1YyxPQUFPLEdBQUc5bUIsR0FBRyxDQUFDeVMsT0FBRCxDQUFiO1NBTFEsQ0FBVjtRQU9BLE9BQU8sSUFBSSt3QixnQkFBSixDQUFxQi93QixPQUFyQixFQUE4QnFVLE9BQTlCLENBQVA7OztNQUdGLFNBQVM2YyxpQkFBVCxDQUEyQmg1QixHQUEzQixFQUFnQztRQUM5QixPQUFPQSxHQUFHLENBQUNpNUIsU0FBSixDQUFjOTNCLEdBQUcsQ0FBQ25CLEdBQUcsQ0FBQ3ZsRCxLQUFMLEVBQVksQ0FBWixDQUFqQixFQUFpQ3VsRCxHQUFHLENBQUMwQixPQUFKLENBQVlQLEdBQUcsQ0FBQ25CLEdBQUcsQ0FBQytKLFFBQUosRUFBRCxDQUFmLENBQWpDLEVBQW1FLFVBQVVydEQsQ0FBVixFQUFhO1VBQUUsT0FBT0EsQ0FBQyxDQUFDNlcsTUFBVDtTQUFsRixDQUFQOzs7TUFHRixTQUFTMmxFLGlCQUFULENBQTJCbDVCLEdBQTNCLEVBQWdDOEgsT0FBaEMsRUFBeUM7UUFDdkMsS0FBSyxJQUFJbjdELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtN0QsT0FBTyxDQUFDdjlELE1BQTVCLEVBQW9Db0MsQ0FBQyxFQUFyQyxFQUF5QztVQUN2QyxJQUFJMm1DLE1BQU0sR0FBR3cwQixPQUFPLENBQUNuN0QsQ0FBRCxDQUFwQjtjQUF5QjhULEdBQUcsR0FBRzZ5QixNQUFNLENBQUM3b0IsSUFBUCxFQUEvQjtVQUNBLElBQUkwdUUsS0FBSyxHQUFHbjVCLEdBQUcsQ0FBQzBCLE9BQUosQ0FBWWpoRCxHQUFHLENBQUNpRyxJQUFoQixDQUFaO2NBQW1DMHlFLEdBQUcsR0FBR3A1QixHQUFHLENBQUMwQixPQUFKLENBQVlqaEQsR0FBRyxDQUFDeUosRUFBaEIsQ0FBekM7O1VBQ0EsSUFBSWszQyxHQUFHLENBQUMrM0IsS0FBRCxFQUFRQyxHQUFSLENBQVAsRUFBcUI7WUFDbkIsSUFBSUMsT0FBTyxHQUFHZixTQUFRLENBQUN0NEIsR0FBRCxFQUFNbTVCLEtBQU4sRUFBYUMsR0FBYixFQUFrQjlsRCxNQUFNLENBQUM2b0MsT0FBekIsRUFBa0M3b0MsTUFBTSxDQUFDNm9DLE9BQVAsQ0FBZXB4RSxJQUFqRCxDQUF0Qjs7WUFDQXVvQyxNQUFNLENBQUN3MEIsT0FBUCxDQUFleCtELElBQWYsQ0FBb0IrdkYsT0FBcEI7WUFDQUEsT0FBTyxDQUFDOWxFLE1BQVIsR0FBaUIrZixNQUFqQjs7Ozs7TUFLTixTQUFTZ21ELG1CQUFULENBQTZCeHhCLE9BQTdCLEVBQXNDO1FBQ3BDLElBQUlqRixJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFXbDJELENBQVgsRUFBZTtVQUN4QixJQUFJMm1DLE1BQU0sR0FBR3cwQixPQUFPLENBQUNuN0QsQ0FBRCxDQUFwQjtjQUF5QnlqRixNQUFNLEdBQUcsQ0FBQzk4QyxNQUFNLENBQUM2b0MsT0FBUCxDQUFlbmMsR0FBaEIsQ0FBbEM7VUFDQSt2QixVQUFVLENBQUN6OEMsTUFBTSxDQUFDNm9DLE9BQVAsQ0FBZW5jLEdBQWhCLEVBQXFCLFVBQVV0NkMsQ0FBVixFQUFhO1lBQUUsT0FBTzBxRSxNQUFNLENBQUM5bUYsSUFBUCxDQUFZb2MsQ0FBWixDQUFQO1dBQXBDLENBQVY7O1VBQ0EsS0FBSyxJQUFJL1EsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzIrQixNQUFNLENBQUN3MEIsT0FBUCxDQUFldjlELE1BQW5DLEVBQTJDb0ssQ0FBQyxFQUE1QyxFQUFnRDtZQUM5QyxJQUFJNGtGLFNBQVMsR0FBR2ptRCxNQUFNLENBQUN3MEIsT0FBUCxDQUFlbnpELENBQWYsQ0FBaEI7O1lBQ0EsSUFBSTZPLE9BQU8sQ0FBQzRzRSxNQUFELEVBQVNtSixTQUFTLENBQUN2NUIsR0FBbkIsQ0FBUCxJQUFrQyxDQUFDLENBQXZDLEVBQTBDO2NBQ3hDdTVCLFNBQVMsQ0FBQ2htRSxNQUFWLEdBQW1CLElBQW5CO2NBQ0ErZixNQUFNLENBQUN3MEIsT0FBUCxDQUFlbnRDLE1BQWYsQ0FBc0JobUIsQ0FBQyxFQUF2QixFQUEyQixDQUEzQjs7O1NBUE47O1FBWUEsS0FBSyxJQUFJaEksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR203RCxPQUFPLENBQUN2OUQsTUFBNUIsRUFBb0NvQyxDQUFDLEVBQXJDO1VBQXlDazJELElBQUksQ0FBRWwyRCxDQUFGLENBQUo7Ozs7TUFHM0MsSUFBSTZzRixTQUFTLEdBQUcsQ0FBaEI7O01BQ0EsSUFBSUMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBUzl3QyxJQUFULEVBQWVwL0MsSUFBZixFQUFxQmdtRixTQUFyQixFQUFnQ21LLE9BQWhDLEVBQXlDaGlDLFNBQXpDLEVBQW9EO1FBQzVELElBQUksRUFBRSxnQkFBZ0IraEMsR0FBbEIsQ0FBSixFQUE0QjtVQUFFLE9BQU8sSUFBSUEsR0FBSixDQUFROXdDLElBQVIsRUFBY3AvQyxJQUFkLEVBQW9CZ21GLFNBQXBCLEVBQStCbUssT0FBL0IsRUFBd0NoaUMsU0FBeEMsQ0FBUDs7O1FBQzlCLElBQUk2M0IsU0FBUyxJQUFJLElBQWpCLEVBQXVCO1VBQUVBLFNBQVMsR0FBRyxDQUFaOzs7UUFFekIwSCxXQUFXLENBQUN4d0YsSUFBWixDQUFpQixJQUFqQixFQUF1QixDQUFDLElBQUlvd0YsU0FBSixDQUFjLENBQUMsSUFBSW5zQixJQUFKLENBQVMsRUFBVCxFQUFhLElBQWIsQ0FBRCxDQUFkLENBQUQsQ0FBdkI7UUFDQSxLQUFLandELEtBQUwsR0FBYTgwRSxTQUFiO1FBQ0EsS0FBS2hZLFNBQUwsR0FBaUIsS0FBS0osVUFBTCxHQUFrQixDQUFuQztRQUNBLEtBQUswZCxRQUFMLEdBQWdCLEtBQWhCO1FBQ0EsS0FBSzhFLGVBQUwsR0FBdUIsQ0FBdkI7UUFDQSxLQUFLOTFCLFlBQUwsR0FBb0IsS0FBS0QsaUJBQUwsR0FBeUIyckIsU0FBN0M7UUFDQSxJQUFJMW5FLEtBQUssR0FBR3M1QyxHQUFHLENBQUNvdUIsU0FBRCxFQUFZLENBQVosQ0FBZjtRQUNBLEtBQUtoVCxHQUFMLEdBQVdnUyxlQUFlLENBQUMxbUUsS0FBRCxDQUExQjtRQUNBLEtBQUtncUUsT0FBTCxHQUFlLElBQUlwQixPQUFKLENBQVksSUFBWixDQUFmO1FBQ0EsS0FBSzFuRixFQUFMLEdBQVUsRUFBRXl3RixTQUFaO1FBQ0EsS0FBS3hLLFVBQUwsR0FBa0J6bEYsSUFBbEI7UUFDQSxLQUFLbXdGLE9BQUwsR0FBZUEsT0FBZjtRQUNBLEtBQUtoaUMsU0FBTCxHQUFrQkEsU0FBUyxJQUFJLEtBQWQsR0FBdUIsS0FBdkIsR0FBK0IsS0FBaEQ7UUFDQSxLQUFLaXlCLE1BQUwsR0FBYyxLQUFkOztRQUVBLElBQUksT0FBT2hoQyxJQUFQLElBQWUsUUFBbkIsRUFBNkI7VUFBRUEsSUFBSSxHQUFHLEtBQUs0dEMsVUFBTCxDQUFnQjV0QyxJQUFoQixDQUFQOzs7UUFDL0J5bUMsU0FBUyxDQUFDLElBQUQsRUFBTztVQUFDMW9FLElBQUksRUFBRW1CLEtBQVA7VUFBY3FDLEVBQUUsRUFBRXJDLEtBQWxCO1VBQXlCOGdDLElBQUksRUFBRUE7U0FBdEMsQ0FBVDtRQUNBd3FDLFlBQVksQ0FBQyxJQUFELEVBQU81RSxlQUFlLENBQUMxbUUsS0FBRCxDQUF0QixFQUErQjZzQyxjQUEvQixDQUFaO09BckJGOztNQXdCQStrQyxHQUFHLENBQUNwdkYsU0FBSixHQUFnQm9yRCxTQUFTLENBQUN3aEMsV0FBVyxDQUFDNXNGLFNBQWIsRUFBd0I7UUFDL0NzTCxXQUFXLEVBQUU4akYsR0FEa0M7Ozs7O1FBTS9DNXlFLElBQUksRUFBRSxjQUFTSCxJQUFULEVBQWV3RCxFQUFmLEVBQW1CZzhDLEVBQW5CLEVBQXVCO1VBQzNCLElBQUlBLEVBQUosRUFBUTtZQUFFLEtBQUs4d0IsS0FBTCxDQUFXdHdFLElBQUksR0FBRyxLQUFLak0sS0FBdkIsRUFBOEJ5UCxFQUFFLEdBQUd4RCxJQUFuQyxFQUF5Q3cvQyxFQUF6QztXQUFWLE1BQ0s7WUFBRSxLQUFLOHdCLEtBQUwsQ0FBVyxLQUFLdjhFLEtBQWhCLEVBQXVCLEtBQUtBLEtBQUwsR0FBYSxLQUFLZ0ssSUFBekMsRUFBK0NpQyxJQUEvQzs7U0FSc0M7O1FBWS9DaXBFLE1BQU0sRUFBRSxnQkFBU25qRSxFQUFULEVBQWEwekMsS0FBYixFQUFvQjtVQUMxQixJQUFJbmEsTUFBTSxHQUFHLENBQWI7O1VBQ0EsS0FBSyxJQUFJcDVDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1ekQsS0FBSyxDQUFDMzFELE1BQTFCLEVBQWtDLEVBQUVvQyxDQUFwQyxFQUF1QztZQUFFbzVDLE1BQU0sSUFBSW1hLEtBQUssQ0FBQ3Z6RCxDQUFELENBQUwsQ0FBU281QyxNQUFuQjs7O1VBQ3pDLEtBQUtneEMsV0FBTCxDQUFpQnZxRSxFQUFFLEdBQUcsS0FBSy9SLEtBQTNCLEVBQWtDeWxELEtBQWxDLEVBQXlDbmEsTUFBekM7U0FmNkM7UUFpQi9DdFAsTUFBTSxFQUFFLGdCQUFTanFCLEVBQVQsRUFBYXpVLENBQWIsRUFBZ0I7VUFBRSxLQUFLKytFLFdBQUwsQ0FBaUJ0cUUsRUFBRSxHQUFHLEtBQUsvUixLQUEzQixFQUFrQzFDLENBQWxDO1NBakJxQjs7O1FBc0IvQzZoRixRQUFRLEVBQUUsa0JBQVNGLE9BQVQsRUFBa0I7VUFDMUIsSUFBSXg1QixLQUFLLEdBQUdLLFFBQVEsQ0FBQyxJQUFELEVBQU8sS0FBSzlsRCxLQUFaLEVBQW1CLEtBQUtBLEtBQUwsR0FBYSxLQUFLZ0ssSUFBckMsQ0FBcEI7O1VBQ0EsSUFBSWkxRSxPQUFPLEtBQUssS0FBaEIsRUFBdUI7WUFBRSxPQUFPeDVCLEtBQVA7OztVQUN6QixPQUFPQSxLQUFLLENBQUMvMUQsSUFBTixDQUFXdXZGLE9BQU8sSUFBSSxLQUFLRyxhQUFMLEVBQXRCLENBQVA7U0F6QjZDO1FBMkIvQ0MsUUFBUSxFQUFFelIsV0FBVyxDQUFDLFVBQVN0dEUsSUFBVCxFQUFlO1VBQ25DLElBQUlzc0MsR0FBRyxHQUFHOFosR0FBRyxDQUFDLEtBQUsxbUQsS0FBTixFQUFhLENBQWIsQ0FBYjtjQUE4QjJZLElBQUksR0FBRyxLQUFLM1ksS0FBTCxHQUFhLEtBQUtnSyxJQUFsQixHQUF5QixDQUE5RDtVQUNBeXdFLFVBQVUsQ0FBQyxJQUFELEVBQU87WUFBQ3h1RSxJQUFJLEVBQUUyZ0MsR0FBUDtZQUFZbjlCLEVBQUUsRUFBRWkzQyxHQUFHLENBQUMvdEMsSUFBRCxFQUFPMnNDLE9BQU8sQ0FBQyxJQUFELEVBQU8zc0MsSUFBUCxDQUFQLENBQW9CdTFCLElBQXBCLENBQXlCcCtDLE1BQWhDLENBQW5CO1lBQ0NvK0MsSUFBSSxFQUFFLEtBQUs0dEMsVUFBTCxDQUFnQng3RSxJQUFoQixDQURQO1lBQzhCODVDLE1BQU0sRUFBRSxVQUR0QztZQUNrRHFTLElBQUksRUFBRTtXQUQvRCxFQUNzRSxJQUR0RSxDQUFWOztVQUVBLElBQUksS0FBS3BOLEVBQVQsRUFBYTtZQUFFNG9CLGNBQWMsQ0FBQyxLQUFLNW9CLEVBQU4sRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUFkOzs7VUFDZnE1QixZQUFZLENBQUMsSUFBRCxFQUFPNUUsZUFBZSxDQUFDbG5DLEdBQUQsQ0FBdEIsRUFBNkJxTixjQUE3QixDQUFaO1NBTG1CLENBM0IwQjtRQWtDL0M0aEMsWUFBWSxFQUFFLHNCQUFTdjdFLElBQVQsRUFBZTJMLElBQWYsRUFBcUJ3RCxFQUFyQixFQUF5QjJxQyxNQUF6QixFQUFpQztVQUM3Q251QyxJQUFJLEdBQUdnN0MsUUFBTyxDQUFDLElBQUQsRUFBT2g3QyxJQUFQLENBQWQ7VUFDQXdELEVBQUUsR0FBR0EsRUFBRSxHQUFHdzNDLFFBQU8sQ0FBQyxJQUFELEVBQU94M0MsRUFBUCxDQUFWLEdBQXVCeEQsSUFBOUI7O1VBQ0E0dkUsYUFBWSxDQUFDLElBQUQsRUFBT3Y3RSxJQUFQLEVBQWEyTCxJQUFiLEVBQW1Cd0QsRUFBbkIsRUFBdUIycUMsTUFBdkIsQ0FBWjtTQXJDNkM7UUF1Qy9Da2xDLFFBQVEsRUFBRSxrQkFBU3J6RSxJQUFULEVBQWV3RCxFQUFmLEVBQW1Cd3ZFLE9BQW5CLEVBQTRCO1VBQ3BDLElBQUl4NUIsS0FBSyxHQUFHSSxVQUFVLENBQUMsSUFBRCxFQUFPb0IsUUFBTyxDQUFDLElBQUQsRUFBT2g3QyxJQUFQLENBQWQsRUFBNEJnN0MsUUFBTyxDQUFDLElBQUQsRUFBT3gzQyxFQUFQLENBQW5DLENBQXRCOztVQUNBLElBQUl3dkUsT0FBTyxLQUFLLEtBQWhCLEVBQXVCO1lBQUUsT0FBT3g1QixLQUFQOzs7VUFDekIsSUFBSXc1QixPQUFPLEtBQUssRUFBaEIsRUFBb0I7WUFBRSxPQUFPeDVCLEtBQUssQ0FBQy8xRCxJQUFOLENBQVcsRUFBWCxDQUFQOzs7VUFDdEIsT0FBTysxRCxLQUFLLENBQUMvMUQsSUFBTixDQUFXdXZGLE9BQU8sSUFBSSxLQUFLRyxhQUFMLEVBQXRCLENBQVA7U0EzQzZDO1FBOEMvQzk1QixPQUFPLEVBQUUsaUJBQVM3RyxJQUFULEVBQWU7VUFBQyxJQUFJbmxELENBQUMsR0FBRyxLQUFLaW1GLGFBQUwsQ0FBbUI5Z0MsSUFBbkIsQ0FBUjtVQUFrQyxPQUFPbmxELENBQUMsSUFBSUEsQ0FBQyxDQUFDNDBDLElBQWQ7U0E5Q1o7UUFnRC9DcXhDLGFBQWEsRUFBRSx1QkFBUzlnQyxJQUFULEVBQWU7VUFBQyxJQUFJNkgsTUFBTSxDQUFDLElBQUQsRUFBTzdILElBQVAsQ0FBVixFQUF3QjtZQUFFLE9BQU82RyxPQUFPLENBQUMsSUFBRCxFQUFPN0csSUFBUCxDQUFkOztTQWhEVjtRQWlEL0MrZ0MsYUFBYSxFQUFFLHVCQUFTL2dDLElBQVQsRUFBZTtVQUFDLE9BQU93SCxNQUFNLENBQUN4SCxJQUFELENBQWI7U0FqRGdCO1FBbUQvQ2doQyx3QkFBd0IsRUFBRSxrQ0FBU2hoQyxJQUFULEVBQWU7VUFDdkMsSUFBSSxPQUFPQSxJQUFQLElBQWUsUUFBbkIsRUFBNkI7WUFBRUEsSUFBSSxHQUFHNkcsT0FBTyxDQUFDLElBQUQsRUFBTzdHLElBQVAsQ0FBZDs7O1VBQy9CLE9BQU9xUSxVQUFVLENBQUNyUSxJQUFELENBQWpCO1NBckQ2QztRQXdEL0NpaEMsU0FBUyxFQUFFLHFCQUFXO1VBQUMsT0FBTyxLQUFLMTFFLElBQVo7U0F4RHdCO1FBeUQvQzhxRSxTQUFTLEVBQUUscUJBQVc7VUFBQyxPQUFPLEtBQUs5MEUsS0FBWjtTQXpEd0I7UUEwRC9Dc3ZELFFBQVEsRUFBRSxvQkFBVztVQUFDLE9BQU8sS0FBS3R2RCxLQUFMLEdBQWEsS0FBS2dLLElBQWxCLEdBQXlCLENBQWhDO1NBMUR5QjtRQTREL0NpOUMsT0FBTyxFQUFFLGlCQUFTamhELEdBQVQsRUFBYztVQUFDLE9BQU9paEQsUUFBTyxDQUFDLElBQUQsRUFBT2poRCxHQUFQLENBQWQ7U0E1RHVCO1FBOEQvQzhoRSxTQUFTLEVBQUUsbUJBQVMxNkQsS0FBVCxFQUFnQjtVQUN6QixJQUFJNmhDLEtBQUssR0FBRyxLQUFLNnlCLEdBQUwsQ0FBU0osT0FBVCxFQUFaO2NBQWdDMTdELEdBQWhDOztVQUNBLElBQUlvSCxLQUFLLElBQUksSUFBVCxJQUFpQkEsS0FBSyxJQUFJLE1BQTlCLEVBQXNDO1lBQUVwSCxHQUFHLEdBQUdpcEMsS0FBSyxDQUFDdjJCLElBQVo7V0FBeEMsTUFDSyxJQUFJdEwsS0FBSyxJQUFJLFFBQWIsRUFBdUI7WUFBRXBILEdBQUcsR0FBR2lwQyxLQUFLLENBQUN6bEMsTUFBWjtXQUF6QixNQUNBLElBQUk0RCxLQUFLLElBQUksS0FBVCxJQUFrQkEsS0FBSyxJQUFJLElBQTNCLElBQW1DQSxLQUFLLEtBQUssS0FBakQsRUFBd0Q7WUFBRXBILEdBQUcsR0FBR2lwQyxLQUFLLENBQUN4L0IsRUFBTixFQUFOO1dBQTFELE1BQ0E7WUFBRXpKLEdBQUcsR0FBR2lwQyxLQUFLLENBQUNoakMsSUFBTixFQUFOOzs7VUFDUCxPQUFPakcsR0FBUDtTQXBFNkM7UUFzRS9DMjVFLGNBQWMsRUFBRSwwQkFBVztVQUFFLE9BQU8sS0FBSzdkLEdBQUwsQ0FBU0MsTUFBaEI7U0F0RWtCO1FBdUUvQ3lSLGlCQUFpQixFQUFFLDZCQUFXO1VBQUMsT0FBTyxLQUFLMVIsR0FBTCxDQUFTMFIsaUJBQVQsRUFBUDtTQXZFZ0I7UUF5RS9Db00sU0FBUyxFQUFFaFMsV0FBVyxDQUFDLFVBQVNudkIsSUFBVCxFQUFlOXBDLEVBQWYsRUFBbUJ5bEIsT0FBbkIsRUFBNEI7VUFDakQyK0Msa0JBQWtCLENBQUMsSUFBRCxFQUFPOXhCLFFBQU8sQ0FBQyxJQUFELEVBQU8sT0FBT3hJLElBQVAsSUFBZSxRQUFmLEdBQTBCaUksR0FBRyxDQUFDakksSUFBRCxFQUFPOXBDLEVBQUUsSUFBSSxDQUFiLENBQTdCLEdBQStDOHBDLElBQXRELENBQWQsRUFBMkUsSUFBM0UsRUFBaUZya0IsT0FBakYsQ0FBbEI7U0FEb0IsQ0F6RXlCO1FBNEUvQ3MrQyxZQUFZLEVBQUU5SyxXQUFXLENBQUMsVUFBU3BrRSxNQUFULEVBQWlCa1AsSUFBakIsRUFBdUIwaEIsT0FBdkIsRUFBZ0M7VUFDeEQyK0Msa0JBQWtCLENBQUMsSUFBRCxFQUFPOXhCLFFBQU8sQ0FBQyxJQUFELEVBQU96OUMsTUFBUCxDQUFkLEVBQThCeTlDLFFBQU8sQ0FBQyxJQUFELEVBQU92dUMsSUFBSSxJQUFJbFAsTUFBZixDQUFyQyxFQUE2RDR3QixPQUE3RCxDQUFsQjtTQUR1QixDQTVFc0I7UUErRS9DcStDLGVBQWUsRUFBRTdLLFdBQVcsQ0FBQyxVQUFTbDFELElBQVQsRUFBZXFsRCxLQUFmLEVBQXNCM2pDLE9BQXRCLEVBQStCO1VBQzFEcStDLGVBQWUsQ0FBQyxJQUFELEVBQU94eEIsUUFBTyxDQUFDLElBQUQsRUFBT3Z1QyxJQUFQLENBQWQsRUFBNEJxbEQsS0FBSyxJQUFJOVcsUUFBTyxDQUFDLElBQUQsRUFBTzhXLEtBQVAsQ0FBNUMsRUFBMkQzakMsT0FBM0QsQ0FBZjtTQUQwQixDQS9FbUI7UUFrRi9DdStDLGdCQUFnQixFQUFFL0ssV0FBVyxDQUFDLFVBQVNnTCxLQUFULEVBQWdCeCtDLE9BQWhCLEVBQXlCO1VBQ3JEdStDLGdCQUFnQixDQUFDLElBQUQsRUFBT3Z4QixZQUFZLENBQUMsSUFBRCxFQUFPd3hCLEtBQVAsQ0FBbkIsRUFBa0N4K0MsT0FBbEMsQ0FBaEI7U0FEMkIsQ0FsRmtCO1FBcUYvQ3lsRCxrQkFBa0IsRUFBRWpTLFdBQVcsQ0FBQyxVQUFTeC9FLENBQVQsRUFBWWdzQyxPQUFaLEVBQXFCO1VBQ25ELElBQUl3K0MsS0FBSyxHQUFHcHFFLEdBQUcsQ0FBQyxLQUFLc3pELEdBQUwsQ0FBU0MsTUFBVixFQUFrQjN6RSxDQUFsQixDQUFmO1VBQ0F1cUYsZ0JBQWdCLENBQUMsSUFBRCxFQUFPdnhCLFlBQVksQ0FBQyxJQUFELEVBQU93eEIsS0FBUCxDQUFuQixFQUFrQ3grQyxPQUFsQyxDQUFoQjtTQUY2QixDQXJGZ0I7UUF5Ri9DMGxELGFBQWEsRUFBRWxTLFdBQVcsQ0FBQyxVQUFTN0wsTUFBVCxFQUFpQkwsT0FBakIsRUFBMEJ0bkMsT0FBMUIsRUFBbUM7VUFDNUQsSUFBSSxDQUFDMm5DLE1BQU0sQ0FBQ2p5RSxNQUFaLEVBQW9CO1lBQUU7OztVQUN0QixJQUFJdUIsR0FBRyxHQUFHLEVBQVY7O1VBQ0EsS0FBSyxJQUFJYSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFDRTtZQUFFYixHQUFHLENBQUNhLENBQUQsQ0FBSCxHQUFTLElBQUlxaEYsS0FBSixDQUFVdHNCLFFBQU8sQ0FBQyxJQUFELEVBQU84YSxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVVzWCxNQUFqQixDQUFqQixFQUNReTlDLFFBQU8sQ0FBQyxJQUFELEVBQU84YSxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVV3bUIsSUFBVixJQUFrQnFwRCxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVVzWCxNQUFuQyxDQURmLENBQVQ7OztVQUVKLElBQUlrNEQsT0FBTyxJQUFJLElBQWYsRUFBcUI7WUFBRUEsT0FBTyxHQUFHajJFLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU2d1RSxNQUFNLENBQUNqeUUsTUFBUCxHQUFnQixDQUF6QixFQUE0QixLQUFLZ3lFLEdBQUwsQ0FBU0UsU0FBckMsQ0FBVjs7O1VBQ3ZCMFcsWUFBWSxDQUFDLElBQUQsRUFBT2pGLGtCQUFrQixDQUFDLEtBQUtwMEIsRUFBTixFQUFVaHVELEdBQVYsRUFBZXF3RSxPQUFmLENBQXpCLEVBQWtEdG5DLE9BQWxELENBQVo7U0FQd0IsQ0F6RnFCO1FBa0cvQzJsRCxZQUFZLEVBQUVuUyxXQUFXLENBQUMsVUFBU3BrRSxNQUFULEVBQWlCa1AsSUFBakIsRUFBdUIwaEIsT0FBdkIsRUFBZ0M7VUFDeEQsSUFBSTJuQyxNQUFNLEdBQUcsS0FBS0QsR0FBTCxDQUFTQyxNQUFULENBQWdCeHVFLEtBQWhCLENBQXNCLENBQXRCLENBQWI7VUFDQXd1RSxNQUFNLENBQUNsekUsSUFBUCxDQUFZLElBQUkwa0YsS0FBSixDQUFVdHNCLFFBQU8sQ0FBQyxJQUFELEVBQU96OUMsTUFBUCxDQUFqQixFQUFpQ3k5QyxRQUFPLENBQUMsSUFBRCxFQUFPdnVDLElBQUksSUFBSWxQLE1BQWYsQ0FBeEMsQ0FBWjtVQUNBa3ZFLFlBQVksQ0FBQyxJQUFELEVBQU9qRixrQkFBa0IsQ0FBQyxLQUFLcDBCLEVBQU4sRUFBVTBpQixNQUFWLEVBQWtCQSxNQUFNLENBQUNqeUUsTUFBUCxHQUFnQixDQUFsQyxDQUF6QixFQUErRHNxQyxPQUEvRCxDQUFaO1NBSHVCLENBbEdzQjtRQXdHL0NxbkIsWUFBWSxFQUFFLHNCQUFTdzlCLE9BQVQsRUFBa0I7VUFDOUIsSUFBSWxkLE1BQU0sR0FBRyxLQUFLRCxHQUFMLENBQVNDLE1BQXRCO2NBQThCdGMsS0FBOUI7O1VBQ0EsS0FBSyxJQUFJdnpELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQTNCLEVBQW1Db0MsQ0FBQyxFQUFwQyxFQUF3QztZQUN0QyxJQUFJNHZFLEdBQUcsR0FBR2pjLFVBQVUsQ0FBQyxJQUFELEVBQU9rYyxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVUrWixJQUFWLEVBQVAsRUFBeUI4MUQsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVdWQsRUFBVixFQUF6QixDQUFwQjtZQUNBZzJDLEtBQUssR0FBR0EsS0FBSyxHQUFHQSxLQUFLLENBQUNoM0QsTUFBTixDQUFhcXpFLEdBQWIsQ0FBSCxHQUF1QkEsR0FBcEM7OztVQUVGLElBQUltZCxPQUFPLEtBQUssS0FBaEIsRUFBdUI7WUFBRSxPQUFPeDVCLEtBQVA7V0FBekIsTUFDSztZQUFFLE9BQU9BLEtBQUssQ0FBQy8xRCxJQUFOLENBQVd1dkYsT0FBTyxJQUFJLEtBQUtHLGFBQUwsRUFBdEIsQ0FBUDs7U0EvR3NDO1FBaUgvQ1ksYUFBYSxFQUFFLHVCQUFTZixPQUFULEVBQWtCO1VBQy9CLElBQUl6akQsS0FBSyxHQUFHLEVBQVo7Y0FBZ0J1bUMsTUFBTSxHQUFHLEtBQUtELEdBQUwsQ0FBU0MsTUFBbEM7O1VBQ0EsS0FBSyxJQUFJN3ZFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQTNCLEVBQW1Db0MsQ0FBQyxFQUFwQyxFQUF3QztZQUN0QyxJQUFJNHZFLEdBQUcsR0FBR2pjLFVBQVUsQ0FBQyxJQUFELEVBQU9rYyxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVUrWixJQUFWLEVBQVAsRUFBeUI4MUQsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVdWQsRUFBVixFQUF6QixDQUFwQjs7WUFDQSxJQUFJd3ZFLE9BQU8sS0FBSyxLQUFoQixFQUF1QjtjQUFFbmQsR0FBRyxHQUFHQSxHQUFHLENBQUNweUUsSUFBSixDQUFTdXZGLE9BQU8sSUFBSSxLQUFLRyxhQUFMLEVBQXBCLENBQU47OztZQUN6QjVqRCxLQUFLLENBQUN0cEMsQ0FBRCxDQUFMLEdBQVc0dkUsR0FBWDs7O1VBRUYsT0FBT3RtQyxLQUFQO1NBeEg2QztRQTBIL0N5a0QsZ0JBQWdCLEVBQUUsMEJBQVMzL0UsSUFBVCxFQUFlNjNDLFFBQWYsRUFBeUJpQyxNQUF6QixFQUFpQztVQUNqRCxJQUFJOGxDLEdBQUcsR0FBRyxFQUFWOztVQUNBLEtBQUssSUFBSWh1RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUs0dkUsR0FBTCxDQUFTQyxNQUFULENBQWdCanlFLE1BQXBDLEVBQTRDb0MsQ0FBQyxFQUE3QyxFQUNFO1lBQUVndUYsR0FBRyxDQUFDaHVGLENBQUQsQ0FBSCxHQUFTb08sSUFBVDs7O1VBQ0osS0FBSzYvRSxpQkFBTCxDQUF1QkQsR0FBdkIsRUFBNEIvbkMsUUFBNUIsRUFBc0NpQyxNQUFNLElBQUksUUFBaEQ7U0E5SDZDO1FBZ0kvQytsQyxpQkFBaUIsRUFBRXZTLFdBQVcsQ0FBQyxVQUFTdHRFLElBQVQsRUFBZTYzQyxRQUFmLEVBQXlCaUMsTUFBekIsRUFBaUM7VUFDOUQsSUFBSTBhLE9BQU8sR0FBRyxFQUFkO2NBQWtCZ04sR0FBRyxHQUFHLEtBQUtBLEdBQTdCOztVQUNBLEtBQUssSUFBSTV2RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNHZFLEdBQUcsQ0FBQ0MsTUFBSixDQUFXanlFLE1BQS9CLEVBQXVDb0MsQ0FBQyxFQUF4QyxFQUE0QztZQUMxQyxJQUFJKzhDLEtBQUssR0FBRzZ5QixHQUFHLENBQUNDLE1BQUosQ0FBVzd2RSxDQUFYLENBQVo7WUFDQTRpRSxPQUFPLENBQUM1aUUsQ0FBRCxDQUFQLEdBQWE7Y0FBQytaLElBQUksRUFBRWdqQyxLQUFLLENBQUNoakMsSUFBTixFQUFQO2NBQXFCd0QsRUFBRSxFQUFFdy9CLEtBQUssQ0FBQ3gvQixFQUFOLEVBQXpCO2NBQXFDeStCLElBQUksRUFBRSxLQUFLNHRDLFVBQUwsQ0FBZ0J4N0UsSUFBSSxDQUFDcE8sQ0FBRCxDQUFwQixDQUEzQztjQUFxRWtvRCxNQUFNLEVBQUVBO2FBQTFGOzs7VUFFRixJQUFJeStCLE1BQU0sR0FBRzFnQyxRQUFRLElBQUlBLFFBQVEsSUFBSSxLQUF4QixJQUFpQ2c4QixrQkFBa0IsQ0FBQyxJQUFELEVBQU9yZixPQUFQLEVBQWdCM2MsUUFBaEIsQ0FBaEU7O1VBQ0EsS0FBSyxJQUFJaUYsR0FBRyxHQUFHMFgsT0FBTyxDQUFDaGxFLE1BQVIsR0FBaUIsQ0FBaEMsRUFBbUNzdEQsR0FBRyxJQUFJLENBQTFDLEVBQTZDQSxHQUFHLEVBQWhELEVBQ0U7WUFBRXE5QixVQUFVLENBQUMsSUFBRCxFQUFPM2xCLE9BQU8sQ0FBQzFYLEdBQUQsQ0FBZCxDQUFWOzs7VUFDSixJQUFJeTdCLE1BQUosRUFBWTtZQUFFSSwwQkFBMEIsQ0FBQyxJQUFELEVBQU9KLE1BQVAsQ0FBMUI7V0FBZCxNQUNLLElBQUksS0FBS3g1QixFQUFULEVBQWE7WUFBRXdvQixtQkFBbUIsQ0FBQyxLQUFLeG9CLEVBQU4sQ0FBbkI7O1NBVlEsQ0FoSWlCO1FBNEkvQytnQyxJQUFJLEVBQUV4UyxXQUFXLENBQUMsWUFBVztVQUFDb04scUJBQXFCLENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBckI7U0FBYixDQTVJOEI7UUE2SS9DcUYsSUFBSSxFQUFFelMsV0FBVyxDQUFDLFlBQVc7VUFBQ29OLHFCQUFxQixDQUFDLElBQUQsRUFBTyxNQUFQLENBQXJCO1NBQWIsQ0E3SThCO1FBOEkvQ3NGLGFBQWEsRUFBRTFTLFdBQVcsQ0FBQyxZQUFXO1VBQUNvTixxQkFBcUIsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLElBQWYsQ0FBckI7U0FBYixDQTlJcUI7UUErSS9DdUYsYUFBYSxFQUFFM1MsV0FBVyxDQUFDLFlBQVc7VUFBQ29OLHFCQUFxQixDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsSUFBZixDQUFyQjtTQUFiLENBL0lxQjtRQWlKL0N3RixZQUFZLEVBQUUsc0JBQVNwekYsR0FBVCxFQUFjO1VBQUMsS0FBSzhoRixNQUFMLEdBQWM5aEYsR0FBZDtTQWpKa0I7UUFrSi9DcXpGLFlBQVksRUFBRSx3QkFBVztVQUFDLE9BQU8sS0FBS3ZSLE1BQVo7U0FsSnFCO1FBb0ovQ3dSLFdBQVcsRUFBRSx1QkFBVztVQUN0QixJQUFJMUosSUFBSSxHQUFHLEtBQUtJLE9BQWhCO2NBQXlCcHZFLElBQUksR0FBRyxDQUFoQztjQUFtQ2l1RSxNQUFNLEdBQUcsQ0FBNUM7O1VBQ0EsS0FBSyxJQUFJL2pGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4a0YsSUFBSSxDQUFDaHZFLElBQUwsQ0FBVWxZLE1BQTlCLEVBQXNDb0MsQ0FBQyxFQUF2QyxFQUEyQztZQUFFLElBQUksQ0FBQzhrRixJQUFJLENBQUNodkUsSUFBTCxDQUFVOVYsQ0FBVixFQUFhNnZFLE1BQWxCLEVBQTBCO2NBQUUsRUFBRS81RCxJQUFGOzs7O1VBQ3pFLEtBQUssSUFBSW8xQyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHNDVCLElBQUksQ0FBQ2YsTUFBTCxDQUFZbm1GLE1BQXBDLEVBQTRDc3RELEdBQUcsRUFBL0MsRUFBbUQ7WUFBRSxJQUFJLENBQUM0NUIsSUFBSSxDQUFDZixNQUFMLENBQVk3NEIsR0FBWixFQUFpQjJrQixNQUF0QixFQUE4QjtjQUFFLEVBQUVrVSxNQUFGOzs7O1VBQ3JGLE9BQU87WUFBQ21LLElBQUksRUFBRXA0RSxJQUFQO1lBQWFxNEUsSUFBSSxFQUFFcEs7V0FBMUI7U0F4SjZDO1FBMEovQ2tJLFlBQVksRUFBRSx3QkFBVztVQUN2QixJQUFJaEIsTUFBTSxHQUFHLElBQWI7VUFFQSxLQUFLL0YsT0FBTCxHQUFlLElBQUlwQixPQUFKLENBQVksS0FBS29CLE9BQWpCLENBQWY7VUFDQTlCLFVBQVUsQ0FBQyxJQUFELEVBQU8sVUFBVS92QixHQUFWLEVBQWU7WUFBRSxPQUFPQSxHQUFHLENBQUM2eEIsT0FBSixHQUFjK0YsTUFBTSxDQUFDL0YsT0FBNUI7V0FBeEIsRUFBZ0UsSUFBaEUsQ0FBVjtTQTlKNkM7UUFpSy9DdUosU0FBUyxFQUFFLHFCQUFXO1VBQ3BCLEtBQUt6QixlQUFMLEdBQXVCLEtBQUswQixnQkFBTCxDQUFzQixJQUF0QixDQUF2QjtTQWxLNkM7UUFvSy9DQSxnQkFBZ0IsRUFBRSwwQkFBU0MsVUFBVCxFQUFxQjtVQUNyQyxJQUFJQSxVQUFKLEVBQ0U7WUFBRSxLQUFLekosT0FBTCxDQUFhZixNQUFiLEdBQXNCLEtBQUtlLE9BQUwsQ0FBYWQsU0FBYixHQUF5QixLQUFLYyxPQUFMLENBQWFiLFVBQWIsR0FBMEIsSUFBekU7OztVQUNKLE9BQU8sS0FBS2EsT0FBTCxDQUFhWCxVQUFwQjtTQXZLNkM7UUF5Sy9DcUssT0FBTyxFQUFFLGlCQUFVQyxHQUFWLEVBQWU7VUFDdEIsT0FBTyxLQUFLM0osT0FBTCxDQUFhWCxVQUFiLEtBQTRCc0ssR0FBRyxJQUFJLEtBQUs3QixlQUF4QyxDQUFQO1NBMUs2QztRQTZLL0M4QixVQUFVLEVBQUUsc0JBQVc7VUFDckIsT0FBTztZQUFDaDVFLElBQUksRUFBRW13RSxnQkFBZ0IsQ0FBQyxLQUFLZixPQUFMLENBQWFwdkUsSUFBZCxDQUF2QjtZQUNDaXVFLE1BQU0sRUFBRWtDLGdCQUFnQixDQUFDLEtBQUtmLE9BQUwsQ0FBYW5CLE1BQWQ7V0FEaEM7U0E5SzZDO1FBaUwvQ2dMLFVBQVUsRUFBRSxvQkFBU0MsUUFBVCxFQUFtQjtVQUM3QixJQUFJbEssSUFBSSxHQUFHLEtBQUtJLE9BQUwsR0FBZSxJQUFJcEIsT0FBSixDQUFZLEtBQUtvQixPQUFqQixDQUExQjtVQUNBSixJQUFJLENBQUNodkUsSUFBTCxHQUFZbXdFLGdCQUFnQixDQUFDK0ksUUFBUSxDQUFDbDVFLElBQVQsQ0FBY3pVLEtBQWQsQ0FBb0IsQ0FBcEIsQ0FBRCxFQUF5QixJQUF6QixFQUErQixJQUEvQixDQUE1QjtVQUNBeWpGLElBQUksQ0FBQ2YsTUFBTCxHQUFja0MsZ0JBQWdCLENBQUMrSSxRQUFRLENBQUNqTCxNQUFULENBQWdCMWlGLEtBQWhCLENBQXNCLENBQXRCLENBQUQsRUFBMkIsSUFBM0IsRUFBaUMsSUFBakMsQ0FBOUI7U0FwTDZDO1FBdUwvQzR0RixlQUFlLEVBQUV2VCxXQUFXLENBQUMsVUFBU252QixJQUFULEVBQWUyaUMsUUFBZixFQUF5QnR6RixLQUF6QixFQUFnQztVQUMzRCxPQUFPb3VGLFVBQVUsQ0FBQyxJQUFELEVBQU96OUIsSUFBUCxFQUFhLFFBQWIsRUFBdUIsVUFBVUEsSUFBVixFQUFnQjtZQUN0RCxJQUFJNE8sT0FBTyxHQUFHNU8sSUFBSSxDQUFDeVgsYUFBTCxLQUF1QnpYLElBQUksQ0FBQ3lYLGFBQUwsR0FBcUIsRUFBNUMsQ0FBZDtZQUNBN0ksT0FBTyxDQUFDK3pCLFFBQUQsQ0FBUCxHQUFvQnR6RixLQUFwQjs7WUFDQSxJQUFJLENBQUNBLEtBQUQsSUFBVXl0RCxPQUFPLENBQUM4UixPQUFELENBQXJCLEVBQWdDO2NBQUU1TyxJQUFJLENBQUN5WCxhQUFMLEdBQXFCLElBQXJCOzs7WUFDbEMsT0FBTyxJQUFQO1dBSmUsQ0FBakI7U0FEMEIsQ0F2TG1CO1FBZ00vQ21yQixXQUFXLEVBQUV6VCxXQUFXLENBQUMsVUFBU3dULFFBQVQsRUFBbUI7VUFDMUMsSUFBSWpFLE1BQU0sR0FBRyxJQUFiO1VBRUEsS0FBSy93RSxJQUFMLENBQVUsVUFBVXF5QyxJQUFWLEVBQWdCO1lBQ3hCLElBQUlBLElBQUksQ0FBQ3lYLGFBQUwsSUFBc0J6WCxJQUFJLENBQUN5WCxhQUFMLENBQW1Ca3JCLFFBQW5CLENBQTFCLEVBQXdEO2NBQ3REbEYsVUFBVSxDQUFDaUIsTUFBRCxFQUFTMStCLElBQVQsRUFBZSxRQUFmLEVBQXlCLFlBQVk7Z0JBQzdDQSxJQUFJLENBQUN5WCxhQUFMLENBQW1Ca3JCLFFBQW5CLElBQStCLElBQS9COztnQkFDQSxJQUFJN2xDLE9BQU8sQ0FBQ2tELElBQUksQ0FBQ3lYLGFBQU4sQ0FBWCxFQUFpQztrQkFBRXpYLElBQUksQ0FBQ3lYLGFBQUwsR0FBcUIsSUFBckI7OztnQkFDbkMsT0FBTyxJQUFQO2VBSFEsQ0FBVjs7V0FGSjtTQUhzQixDQWhNdUI7UUE4TS9Db3JCLFFBQVEsRUFBRSxrQkFBUzdpQyxJQUFULEVBQWU7VUFDdkIsSUFBSW5oRCxDQUFKOztVQUNBLElBQUksT0FBT21oRCxJQUFQLElBQWUsUUFBbkIsRUFBNkI7WUFDM0IsSUFBSSxDQUFDNkgsTUFBTSxDQUFDLElBQUQsRUFBTzdILElBQVAsQ0FBWCxFQUF5QjtjQUFFLE9BQU8sSUFBUDs7O1lBQzNCbmhELENBQUMsR0FBR21oRCxJQUFKO1lBQ0FBLElBQUksR0FBRzZHLE9BQU8sQ0FBQyxJQUFELEVBQU83RyxJQUFQLENBQWQ7O1lBQ0EsSUFBSSxDQUFDQSxJQUFMLEVBQVc7Y0FBRSxPQUFPLElBQVA7O1dBSmYsTUFLTztZQUNMbmhELENBQUMsR0FBRzJvRCxNQUFNLENBQUN4SCxJQUFELENBQVY7O1lBQ0EsSUFBSW5oRCxDQUFDLElBQUksSUFBVCxFQUFlO2NBQUUsT0FBTyxJQUFQOzs7O1VBRW5CLE9BQU87WUFBQ21oRCxJQUFJLEVBQUVuaEQsQ0FBUDtZQUFVZzZCLE1BQU0sRUFBRW1uQixJQUFsQjtZQUF3QnZRLElBQUksRUFBRXVRLElBQUksQ0FBQ3ZRLElBQW5DO1lBQXlDZ29CLGFBQWEsRUFBRXpYLElBQUksQ0FBQ3lYLGFBQTdEO1lBQ0N2TixTQUFTLEVBQUVsSyxJQUFJLENBQUNrSyxTQURqQjtZQUM0QkQsT0FBTyxFQUFFakssSUFBSSxDQUFDaUssT0FEMUM7WUFDbURpTixTQUFTLEVBQUVsWCxJQUFJLENBQUNrWCxTQURuRTtZQUVDc0IsT0FBTyxFQUFFeFksSUFBSSxDQUFDd1k7V0FGdEI7U0F6TjZDO1FBOE4vQ3NxQixZQUFZLEVBQUUzVCxXQUFXLENBQUMsVUFBU3QyQyxNQUFULEVBQWlCa3FELEtBQWpCLEVBQXdCbnFDLEdBQXhCLEVBQTZCO1VBQ3JELE9BQU82a0MsVUFBVSxDQUFDLElBQUQsRUFBTzVrRCxNQUFQLEVBQWVrcUQsS0FBSyxJQUFJLFFBQVQsR0FBb0IsUUFBcEIsR0FBK0IsT0FBOUMsRUFBdUQsVUFBVS9pQyxJQUFWLEVBQWdCO1lBQ3RGLElBQUlyRixJQUFJLEdBQUdvb0MsS0FBSyxJQUFJLE1BQVQsR0FBa0IsV0FBbEIsR0FDQUEsS0FBSyxJQUFJLFlBQVQsR0FBd0IsU0FBeEIsR0FDQUEsS0FBSyxJQUFJLFFBQVQsR0FBb0IsYUFBcEIsR0FBb0MsV0FGL0M7O1lBR0EsSUFBSSxDQUFDL2lDLElBQUksQ0FBQ3JGLElBQUQsQ0FBVCxFQUFpQjtjQUFFcUYsSUFBSSxDQUFDckYsSUFBRCxDQUFKLEdBQWEvQixHQUFiO2FBQW5CLE1BQ0ssSUFBSUQsU0FBUyxDQUFDQyxHQUFELENBQVQsQ0FBZTM2QyxJQUFmLENBQW9CK2hELElBQUksQ0FBQ3JGLElBQUQsQ0FBeEIsQ0FBSixFQUFxQztjQUFFLE9BQU8sS0FBUDthQUF2QyxNQUNBO2NBQUVxRixJQUFJLENBQUNyRixJQUFELENBQUosSUFBYyxNQUFNL0IsR0FBcEI7OztZQUNQLE9BQU8sSUFBUDtXQVBlLENBQWpCO1NBRHVCLENBOU5zQjtRQXlPL0NvcUMsZUFBZSxFQUFFN1QsV0FBVyxDQUFDLFVBQVN0MkMsTUFBVCxFQUFpQmtxRCxLQUFqQixFQUF3Qm5xQyxHQUF4QixFQUE2QjtVQUN4RCxPQUFPNmtDLFVBQVUsQ0FBQyxJQUFELEVBQU81a0QsTUFBUCxFQUFla3FELEtBQUssSUFBSSxRQUFULEdBQW9CLFFBQXBCLEdBQStCLE9BQTlDLEVBQXVELFVBQVUvaUMsSUFBVixFQUFnQjtZQUN0RixJQUFJckYsSUFBSSxHQUFHb29DLEtBQUssSUFBSSxNQUFULEdBQWtCLFdBQWxCLEdBQ0FBLEtBQUssSUFBSSxZQUFULEdBQXdCLFNBQXhCLEdBQ0FBLEtBQUssSUFBSSxRQUFULEdBQW9CLGFBQXBCLEdBQW9DLFdBRi9DO1lBR0EsSUFBSWxsQyxHQUFHLEdBQUdtQyxJQUFJLENBQUNyRixJQUFELENBQWQ7O1lBQ0EsSUFBSSxDQUFDa0QsR0FBTCxFQUFVO2NBQUUsT0FBTyxLQUFQO2FBQVosTUFDSyxJQUFJakYsR0FBRyxJQUFJLElBQVgsRUFBaUI7Y0FBRW9ILElBQUksQ0FBQ3JGLElBQUQsQ0FBSixHQUFhLElBQWI7YUFBbkIsTUFDQTtjQUNILElBQUk4QyxLQUFLLEdBQUdJLEdBQUcsQ0FBQ3grQyxLQUFKLENBQVVzNUMsU0FBUyxDQUFDQyxHQUFELENBQW5CLENBQVo7O2NBQ0EsSUFBSSxDQUFDNkUsS0FBTCxFQUFZO2dCQUFFLE9BQU8sS0FBUDs7O2NBQ2QsSUFBSXZ6QyxHQUFHLEdBQUd1ekMsS0FBSyxDQUFDaG9ELEtBQU4sR0FBY2dvRCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNwc0QsTUFBakM7Y0FDQTJ1RCxJQUFJLENBQUNyRixJQUFELENBQUosR0FBYWtELEdBQUcsQ0FBQy9vRCxLQUFKLENBQVUsQ0FBVixFQUFhMm9ELEtBQUssQ0FBQ2hvRCxLQUFuQixLQUE2QixDQUFDZ29ELEtBQUssQ0FBQ2hvRCxLQUFQLElBQWdCeVUsR0FBRyxJQUFJMnpDLEdBQUcsQ0FBQ3hzRCxNQUEzQixHQUFvQyxFQUFwQyxHQUF5QyxHQUF0RSxJQUE2RXdzRCxHQUFHLENBQUMvb0QsS0FBSixDQUFVb1YsR0FBVixDQUE3RSxJQUErRixJQUE1Rzs7O1lBRUYsT0FBTyxJQUFQO1dBYmUsQ0FBakI7U0FEMEIsQ0F6T21CO1FBMlAvQzAwRSxhQUFhLEVBQUV6UCxXQUFXLENBQUMsVUFBU3QyQyxNQUFULEVBQWlCamUsSUFBakIsRUFBdUIrZ0IsT0FBdkIsRUFBZ0M7VUFDekQsT0FBT2lqRCxhQUFhLENBQUMsSUFBRCxFQUFPL2xELE1BQVAsRUFBZWplLElBQWYsRUFBcUIrZ0IsT0FBckIsQ0FBcEI7U0FEd0IsQ0EzUHFCO1FBOFAvQ3NuRCxnQkFBZ0IsRUFBRSwwQkFBUzl1QixNQUFULEVBQWlCO1VBQUVBLE1BQU0sQ0FBQ3o2QyxLQUFQO1NBOVBVO1FBZ1EvQzBsRSxRQUFRLEVBQUUsa0JBQVM1eEUsSUFBVCxFQUFld0QsRUFBZixFQUFtQjJxQixPQUFuQixFQUE0QjtVQUNwQyxPQUFPeWpELFNBQVEsQ0FBQyxJQUFELEVBQU81MkIsUUFBTyxDQUFDLElBQUQsRUFBT2g3QyxJQUFQLENBQWQsRUFBNEJnN0MsUUFBTyxDQUFDLElBQUQsRUFBT3gzQyxFQUFQLENBQW5DLEVBQStDMnFCLE9BQS9DLEVBQXdEQSxPQUFPLElBQUlBLE9BQU8sQ0FBQzlwQyxJQUFuQixJQUEyQixPQUFuRixDQUFmO1NBalE2QztRQW1RL0NxeEYsV0FBVyxFQUFFLHFCQUFTMzdFLEdBQVQsRUFBY28wQixPQUFkLEVBQXVCO1VBQ2xDLElBQUl3bkQsUUFBUSxHQUFHO1lBQUM3RCxZQUFZLEVBQUUzakQsT0FBTyxLQUFLQSxPQUFPLENBQUNnQyxRQUFSLElBQW9CLElBQXBCLEdBQTJCaEMsT0FBTyxDQUFDdzRCLE1BQW5DLEdBQTRDeDRCLE9BQWpELENBQXRCO1lBQ0MreEIsVUFBVSxFQUFFL3hCLE9BQU8sSUFBSUEsT0FBTyxDQUFDK3hCLFVBRGhDO1lBRUNnQixjQUFjLEVBQUUsS0FGakI7WUFFd0J6NEQsTUFBTSxFQUFFMGxDLE9BQU8sSUFBSUEsT0FBTyxDQUFDMWxDLE1BRm5EO1lBR0N3aUUsaUJBQWlCLEVBQUU5OEIsT0FBTyxJQUFJQSxPQUFPLENBQUM4OEI7V0FIdEQ7VUFJQWx4RCxHQUFHLEdBQUdpaEQsUUFBTyxDQUFDLElBQUQsRUFBT2poRCxHQUFQLENBQWI7VUFDQSxPQUFPNjNFLFNBQVEsQ0FBQyxJQUFELEVBQU83M0UsR0FBUCxFQUFZQSxHQUFaLEVBQWlCNDdFLFFBQWpCLEVBQTJCLFVBQTNCLENBQWY7U0F6UTZDO1FBMlEvQ0MsV0FBVyxFQUFFLHFCQUFTNzdFLEdBQVQsRUFBYztVQUN6QkEsR0FBRyxHQUFHaWhELFFBQU8sQ0FBQyxJQUFELEVBQU9qaEQsR0FBUCxDQUFiO1VBQ0EsSUFBSXFuRCxPQUFPLEdBQUcsRUFBZDtjQUFrQmhDLEtBQUssR0FBRy9GLE9BQU8sQ0FBQyxJQUFELEVBQU90L0MsR0FBRyxDQUFDeTRDLElBQVgsQ0FBUCxDQUF3QmtOLFdBQWxEOztVQUNBLElBQUlOLEtBQUosRUFBVztZQUFFLEtBQUssSUFBSW41RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbTVELEtBQUssQ0FBQ3Y3RCxNQUExQixFQUFrQyxFQUFFb0MsQ0FBcEMsRUFBdUM7Y0FDbEQsSUFBSW81RCxJQUFJLEdBQUdELEtBQUssQ0FBQ241RCxDQUFELENBQWhCOztjQUNBLElBQUksQ0FBQ281RCxJQUFJLENBQUNyL0MsSUFBTCxJQUFhLElBQWIsSUFBcUJxL0MsSUFBSSxDQUFDci9DLElBQUwsSUFBYWpHLEdBQUcsQ0FBQzJPLEVBQXZDLE1BQ0MyMkMsSUFBSSxDQUFDNzdDLEVBQUwsSUFBVyxJQUFYLElBQW1CNjdDLElBQUksQ0FBQzc3QyxFQUFMLElBQVd6SixHQUFHLENBQUMyTyxFQURuQyxDQUFKLEVBRUU7Z0JBQUUwNEMsT0FBTyxDQUFDeCtELElBQVIsQ0FBYXk4RCxJQUFJLENBQUN6eUIsTUFBTCxDQUFZL2YsTUFBWixJQUFzQnd5QyxJQUFJLENBQUN6eUIsTUFBeEM7Ozs7O1VBRU4sT0FBT3cwQixPQUFQO1NBcFI2QztRQXNSL0NteEIsU0FBUyxFQUFFLG1CQUFTdnlFLElBQVQsRUFBZXdELEVBQWYsRUFBbUJmLE1BQW5CLEVBQTJCO1VBQ3BDekMsSUFBSSxHQUFHZzdDLFFBQU8sQ0FBQyxJQUFELEVBQU9oN0MsSUFBUCxDQUFkO1VBQTRCd0QsRUFBRSxHQUFHdzNDLFFBQU8sQ0FBQyxJQUFELEVBQU94M0MsRUFBUCxDQUFaO1VBQzVCLElBQUl5c0MsS0FBSyxHQUFHLEVBQVo7Y0FBZ0IrSixNQUFNLEdBQUdoNkMsSUFBSSxDQUFDd3lDLElBQTlCO1VBQ0EsS0FBS3J5QyxJQUFMLENBQVVILElBQUksQ0FBQ3d5QyxJQUFmLEVBQXFCaHZDLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVUsQ0FBL0IsRUFBa0MsVUFBVUEsSUFBVixFQUFnQjtZQUNoRCxJQUFJNE0sS0FBSyxHQUFHNU0sSUFBSSxDQUFDa04sV0FBakI7O1lBQ0EsSUFBSU4sS0FBSixFQUFXO2NBQUUsS0FBSyxJQUFJbjVELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtNUQsS0FBSyxDQUFDdjdELE1BQTFCLEVBQWtDb0MsQ0FBQyxFQUFuQyxFQUF1QztnQkFDbEQsSUFBSW81RCxJQUFJLEdBQUdELEtBQUssQ0FBQ241RCxDQUFELENBQWhCOztnQkFDQSxJQUFJLEVBQUVvNUQsSUFBSSxDQUFDNzdDLEVBQUwsSUFBVyxJQUFYLElBQW1CdzJDLE1BQU0sSUFBSWg2QyxJQUFJLENBQUN3eUMsSUFBbEMsSUFBMEN4eUMsSUFBSSxDQUFDMEksRUFBTCxJQUFXMjJDLElBQUksQ0FBQzc3QyxFQUExRCxJQUNBNjdDLElBQUksQ0FBQ3IvQyxJQUFMLElBQWEsSUFBYixJQUFxQmc2QyxNQUFNLElBQUloNkMsSUFBSSxDQUFDd3lDLElBRHBDLElBRUE2TSxJQUFJLENBQUNyL0MsSUFBTCxJQUFhLElBQWIsSUFBcUJnNkMsTUFBTSxJQUFJeDJDLEVBQUUsQ0FBQ2d2QyxJQUFsQyxJQUEwQzZNLElBQUksQ0FBQ3IvQyxJQUFMLElBQWF3RCxFQUFFLENBQUNrRixFQUY1RCxNQUdDLENBQUNqRyxNQUFELElBQVdBLE1BQU0sQ0FBQzQ4QyxJQUFJLENBQUN6eUIsTUFBTixDQUhsQixDQUFKLEVBSUU7a0JBQUVxakIsS0FBSyxDQUFDcnRELElBQU4sQ0FBV3k4RCxJQUFJLENBQUN6eUIsTUFBTCxDQUFZL2YsTUFBWixJQUFzQnd5QyxJQUFJLENBQUN6eUIsTUFBdEM7Ozs7O1lBRU4sRUFBRW90QixNQUFGO1dBVkY7VUFZQSxPQUFPL0osS0FBUDtTQXJTNkM7UUF1Uy9DNGxDLFdBQVcsRUFBRSx1QkFBVztVQUN0QixJQUFJejBCLE9BQU8sR0FBRyxFQUFkO1VBQ0EsS0FBS2poRCxJQUFMLENBQVUsVUFBVXF5QyxJQUFWLEVBQWdCO1lBQ3hCLElBQUk4UCxHQUFHLEdBQUc5UCxJQUFJLENBQUNrTixXQUFmOztZQUNBLElBQUk0QyxHQUFKLEVBQVM7Y0FBRSxLQUFLLElBQUlyOEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3E4RCxHQUFHLENBQUN6K0QsTUFBeEIsRUFBZ0MsRUFBRW9DLENBQWxDLEVBQ1Q7Z0JBQUUsSUFBSXE4RCxHQUFHLENBQUNyOEQsQ0FBRCxDQUFILENBQU8rWixJQUFQLElBQWUsSUFBbkIsRUFBeUI7a0JBQUVvaEQsT0FBTyxDQUFDeCtELElBQVIsQ0FBYTAvRCxHQUFHLENBQUNyOEQsQ0FBRCxDQUFILENBQU8ybUMsTUFBcEI7Ozs7V0FIakM7VUFLQSxPQUFPdzBCLE9BQVA7U0E5UzZDO1FBaVQvQzAwQixZQUFZLEVBQUUsc0JBQVMvaUMsR0FBVCxFQUFjO1VBQzFCLElBQUlycUMsRUFBSjtjQUFRc3hDLE1BQU0sR0FBRyxLQUFLam1ELEtBQXRCO2NBQTZCZ2lGLE9BQU8sR0FBRyxLQUFLNUMsYUFBTCxHQUFxQnR2RixNQUE1RDtVQUNBLEtBQUtzYyxJQUFMLENBQVUsVUFBVXF5QyxJQUFWLEVBQWdCO1lBQ3hCLElBQUlrSCxFQUFFLEdBQUdsSCxJQUFJLENBQUN2USxJQUFMLENBQVVwK0MsTUFBVixHQUFtQmt5RixPQUE1Qjs7WUFDQSxJQUFJcjhCLEVBQUUsR0FBRzNHLEdBQVQsRUFBYztjQUFFcnFDLEVBQUUsR0FBR3FxQyxHQUFMO2NBQVUsT0FBTyxJQUFQOzs7WUFDMUJBLEdBQUcsSUFBSTJHLEVBQVA7WUFDQSxFQUFFTSxNQUFGO1dBSkY7VUFNQSxPQUFPZ0IsUUFBTyxDQUFDLElBQUQsRUFBT1AsR0FBRyxDQUFDVCxNQUFELEVBQVN0eEMsRUFBVCxDQUFWLENBQWQ7U0F6VDZDO1FBMlQvQ3N0RSxZQUFZLEVBQUUsc0JBQVUxa0IsTUFBVixFQUFrQjtVQUM5QkEsTUFBTSxHQUFHdFcsUUFBTyxDQUFDLElBQUQsRUFBT3NXLE1BQVAsQ0FBaEI7VUFDQSxJQUFJcnBFLEtBQUssR0FBR3FwRSxNQUFNLENBQUM1b0QsRUFBbkI7O1VBQ0EsSUFBSTRvRCxNQUFNLENBQUM5ZSxJQUFQLEdBQWMsS0FBS3orQyxLQUFuQixJQUE0QnU5RCxNQUFNLENBQUM1b0QsRUFBUCxHQUFZLENBQTVDLEVBQStDO1lBQUUsT0FBTyxDQUFQOzs7VUFDakQsSUFBSXF0RSxPQUFPLEdBQUcsS0FBSzVDLGFBQUwsR0FBcUJ0dkYsTUFBbkM7VUFDQSxLQUFLc2MsSUFBTCxDQUFVLEtBQUtwTSxLQUFmLEVBQXNCdTlELE1BQU0sQ0FBQzllLElBQTdCLEVBQW1DLFVBQVVBLElBQVYsRUFBZ0I7O1lBQ2pEdnFELEtBQUssSUFBSXVxRCxJQUFJLENBQUN2USxJQUFMLENBQVVwK0MsTUFBVixHQUFtQmt5RixPQUE1QjtXQURGO1VBR0EsT0FBTzl0RixLQUFQO1NBblU2QztRQXNVL0MyekQsSUFBSSxFQUFFLGNBQVNxNkIsV0FBVCxFQUFzQjtVQUMxQixJQUFJMzhCLEdBQUcsR0FBRyxJQUFJeTVCLEdBQUosQ0FBUWw1QixRQUFRLENBQUMsSUFBRCxFQUFPLEtBQUs5bEQsS0FBWixFQUFtQixLQUFLQSxLQUFMLEdBQWEsS0FBS2dLLElBQXJDLENBQWhCLEVBQ1EsS0FBS3VxRSxVQURiLEVBQ3lCLEtBQUt2MEUsS0FEOUIsRUFDcUMsS0FBS2kvRSxPQUQxQyxFQUNtRCxLQUFLaGlDLFNBRHhELENBQVY7VUFFQXNJLEdBQUcsQ0FBQ3VYLFNBQUosR0FBZ0IsS0FBS0EsU0FBckI7VUFBZ0N2WCxHQUFHLENBQUNtWCxVQUFKLEdBQWlCLEtBQUtBLFVBQXRCO1VBQ2hDblgsR0FBRyxDQUFDdWMsR0FBSixHQUFVLEtBQUtBLEdBQWY7VUFDQXZjLEdBQUcsQ0FBQzJwQixNQUFKLEdBQWEsS0FBYjs7VUFDQSxJQUFJZ1QsV0FBSixFQUFpQjtZQUNmMzhCLEdBQUcsQ0FBQzZ4QixPQUFKLENBQVlsQixTQUFaLEdBQXdCLEtBQUtrQixPQUFMLENBQWFsQixTQUFyQztZQUNBM3dCLEdBQUcsQ0FBQzA3QixVQUFKLENBQWUsS0FBS0QsVUFBTCxFQUFmOzs7VUFFRixPQUFPejdCLEdBQVA7U0FoVjZDO1FBbVYvQzQ4QixTQUFTLEVBQUUsbUJBQVMvbkQsT0FBVCxFQUFrQjtVQUMzQixJQUFJLENBQUNBLE9BQUwsRUFBYztZQUFFQSxPQUFPLEdBQUcsRUFBVjs7O1VBQ2hCLElBQUludUIsSUFBSSxHQUFHLEtBQUtqTSxLQUFoQjtjQUF1QnlQLEVBQUUsR0FBRyxLQUFLelAsS0FBTCxHQUFhLEtBQUtnSyxJQUE5Qzs7VUFDQSxJQUFJb3dCLE9BQU8sQ0FBQ251QixJQUFSLElBQWdCLElBQWhCLElBQXdCbXVCLE9BQU8sQ0FBQ251QixJQUFSLEdBQWVBLElBQTNDLEVBQWlEO1lBQUVBLElBQUksR0FBR211QixPQUFPLENBQUNudUIsSUFBZjs7O1VBQ25ELElBQUltdUIsT0FBTyxDQUFDM3FCLEVBQVIsSUFBYyxJQUFkLElBQXNCMnFCLE9BQU8sQ0FBQzNxQixFQUFSLEdBQWFBLEVBQXZDLEVBQTJDO1lBQUVBLEVBQUUsR0FBRzJxQixPQUFPLENBQUMzcUIsRUFBYjs7O1VBQzdDLElBQUlvNEMsSUFBSSxHQUFHLElBQUltM0IsR0FBSixDQUFRbDVCLFFBQVEsQ0FBQyxJQUFELEVBQU83NUMsSUFBUCxFQUFhd0QsRUFBYixDQUFoQixFQUFrQzJxQixPQUFPLENBQUN0ckMsSUFBUixJQUFnQixLQUFLeWxGLFVBQXZELEVBQW1FdG9FLElBQW5FLEVBQXlFLEtBQUtnekUsT0FBOUUsRUFBdUYsS0FBS2hpQyxTQUE1RixDQUFYOztVQUNBLElBQUk3aUIsT0FBTyxDQUFDczdDLFVBQVosRUFBd0I7WUFBRTd0QixJQUFJLENBQUN1dkIsT0FBTCxHQUFlLEtBQUtBLE9BQXBCOzs7VUFDdkIsQ0FBQyxLQUFLekIsTUFBTCxLQUFnQixLQUFLQSxNQUFMLEdBQWMsRUFBOUIsQ0FBRCxFQUFvQzltRixJQUFwQyxDQUF5QztZQUFDMDJELEdBQUcsRUFBRXNDLElBQU47WUFBWTZ0QixVQUFVLEVBQUV0N0MsT0FBTyxDQUFDczdDO1dBQXpFO1VBQ0g3dEIsSUFBSSxDQUFDOHRCLE1BQUwsR0FBYyxDQUFDO1lBQUNwd0IsR0FBRyxFQUFFLElBQU47WUFBWSs0QixRQUFRLEVBQUUsSUFBdEI7WUFBNEI1SSxVQUFVLEVBQUV0N0MsT0FBTyxDQUFDczdDO1dBQWpELENBQWQ7VUFDQStJLGlCQUFpQixDQUFDNTJCLElBQUQsRUFBTzAyQixpQkFBaUIsQ0FBQyxJQUFELENBQXhCLENBQWpCO1VBQ0EsT0FBTzEyQixJQUFQO1NBN1Y2QztRQStWL0N1NkIsU0FBUyxFQUFFLG1CQUFTcmtCLEtBQVQsRUFBZ0I7VUFDekIsSUFBSUEsS0FBSyxZQUFZc2tCLFVBQXJCLEVBQWlDO1lBQUV0a0IsS0FBSyxHQUFHQSxLQUFLLENBQUN4WSxHQUFkOzs7VUFDbkMsSUFBSSxLQUFLb3dCLE1BQVQsRUFBaUI7WUFBRSxLQUFLLElBQUl6akYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLeWpGLE1BQUwsQ0FBWTdsRixNQUFoQyxFQUF3QyxFQUFFb0MsQ0FBMUMsRUFBNkM7Y0FDOUQsSUFBSWdZLElBQUksR0FBRyxLQUFLeXJFLE1BQUwsQ0FBWXpqRixDQUFaLENBQVg7O2NBQ0EsSUFBSWdZLElBQUksQ0FBQ3E3QyxHQUFMLElBQVl3WSxLQUFoQixFQUF1QjtnQkFBRTs7O2NBQ3pCLEtBQUs0WCxNQUFMLENBQVl6MUQsTUFBWixDQUFtQmh1QixDQUFuQixFQUFzQixDQUF0QjtjQUNBNnJFLEtBQUssQ0FBQ3FrQixTQUFOLENBQWdCLElBQWhCO2NBQ0F2RCxtQkFBbUIsQ0FBQ04saUJBQWlCLENBQUMsSUFBRCxDQUFsQixDQUFuQjtjQUNBOztXQVJ1Qjs7O1VBV3pCLElBQUl4Z0IsS0FBSyxDQUFDcVosT0FBTixJQUFpQixLQUFLQSxPQUExQixFQUFtQztZQUNqQyxJQUFJa0wsUUFBUSxHQUFHLENBQUN2a0IsS0FBSyxDQUFDenZFLEVBQVAsQ0FBZjtZQUNBZ25GLFVBQVUsQ0FBQ3ZYLEtBQUQsRUFBUSxVQUFVeFksR0FBVixFQUFlO2NBQUUsT0FBTys4QixRQUFRLENBQUN6ekYsSUFBVCxDQUFjMDJELEdBQUcsQ0FBQ2ozRCxFQUFsQixDQUFQO2FBQXpCLEVBQTBELElBQTFELENBQVY7WUFDQXl2RSxLQUFLLENBQUNxWixPQUFOLEdBQWdCLElBQUlwQixPQUFKLENBQVksSUFBWixDQUFoQjtZQUNBalksS0FBSyxDQUFDcVosT0FBTixDQUFjcHZFLElBQWQsR0FBcUJtd0UsZ0JBQWdCLENBQUMsS0FBS2YsT0FBTCxDQUFhcHZFLElBQWQsRUFBb0JzNkUsUUFBcEIsQ0FBckM7WUFDQXZrQixLQUFLLENBQUNxWixPQUFOLENBQWNuQixNQUFkLEdBQXVCa0MsZ0JBQWdCLENBQUMsS0FBS2YsT0FBTCxDQUFhbkIsTUFBZCxFQUFzQnFNLFFBQXRCLENBQXZDOztTQS9XMkM7UUFrWC9DQyxjQUFjLEVBQUUsd0JBQVNuMEYsQ0FBVCxFQUFZO1VBQUNrbkYsVUFBVSxDQUFDLElBQUQsRUFBT2xuRixDQUFQLENBQVY7U0FsWGtCO1FBb1gvQ3kwRCxPQUFPLEVBQUUsbUJBQVc7VUFBQyxPQUFPLEtBQUsvekQsSUFBWjtTQXBYMEI7UUFxWC9DMHpGLFNBQVMsRUFBRSxxQkFBVztVQUFDLE9BQU8sS0FBS25qQyxFQUFaO1NBclh3QjtRQXVYL0N5OEIsVUFBVSxFQUFFLG9CQUFTMzhFLEdBQVQsRUFBYztVQUN4QixJQUFJLEtBQUs4L0UsT0FBVCxFQUFrQjtZQUFFLE9BQU85L0UsR0FBRyxDQUFDL1AsS0FBSixDQUFVLEtBQUs2dkYsT0FBZixDQUFQOzs7VUFDcEIsT0FBTzM5QixjQUFjLENBQUNuaUQsR0FBRCxDQUFyQjtTQXpYNkM7UUEyWC9DaWdGLGFBQWEsRUFBRSx5QkFBVztVQUFFLE9BQU8sS0FBS0gsT0FBTCxJQUFnQixJQUF2QjtTQTNYbUI7UUE2WC9Dd0QsWUFBWSxFQUFFN1UsV0FBVyxDQUFDLFVBQVVqeUIsR0FBVixFQUFlO1VBQ3ZDLElBQUlBLEdBQUcsSUFBSSxLQUFYLEVBQWtCO1lBQUVBLEdBQUcsR0FBRyxLQUFOOzs7VUFDcEIsSUFBSUEsR0FBRyxJQUFJLEtBQUtzQixTQUFoQixFQUEyQjtZQUFFOzs7VUFDN0IsS0FBS0EsU0FBTCxHQUFpQnRCLEdBQWpCO1VBQ0EsS0FBS3Z2QyxJQUFMLENBQVUsVUFBVXF5QyxJQUFWLEVBQWdCO1lBQUUsT0FBT0EsSUFBSSxDQUFDeEMsS0FBTCxHQUFhLElBQXBCO1dBQTVCOztVQUNBLElBQUksS0FBS29ELEVBQVQsRUFBYTtZQUFFMDJCLGdCQUFnQixDQUFDLEtBQUsxMkIsRUFBTixDQUFoQjs7U0FMUTtPQTdYRixDQUF6QixDQWorTG1COztNQXcyTW5CMi9CLEdBQUcsQ0FBQ3B2RixTQUFKLENBQWM4eUYsUUFBZCxHQUF5QjFELEdBQUcsQ0FBQ3B2RixTQUFKLENBQWN3YyxJQUF2QyxDQXgyTW1COzs7TUE0Mk1uQixJQUFJdTJFLFFBQVEsR0FBRyxDQUFmOztNQUVBLFNBQVNDLE1BQVQsQ0FBZ0IxMkYsQ0FBaEIsRUFBbUI7UUFDakIsSUFBSW16RCxFQUFFLEdBQUcsSUFBVDtRQUNBd2pDLGVBQWUsQ0FBQ3hqQyxFQUFELENBQWY7O1FBQ0EsSUFBSUQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFkLElBQXlCNHJFLGFBQWEsQ0FBQ3pZLEVBQUUsQ0FBQy9vRCxPQUFKLEVBQWFwSyxDQUFiLENBQTFDLEVBQ0U7VUFBRTs7O1FBQ0o4ekQsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoQjs7UUFDQSxJQUFJNnBELEVBQUosRUFBUTtVQUFFNHNDLFFBQVEsR0FBRyxDQUFDLElBQUlsNEUsSUFBSixFQUFaOzs7UUFDVixJQUFJekUsR0FBRyxHQUFHazZELFlBQVksQ0FBQzdnQixFQUFELEVBQUtuekQsQ0FBTCxFQUFRLElBQVIsQ0FBdEI7WUFBcUM0MkYsS0FBSyxHQUFHNTJGLENBQUMsQ0FBQzYyRixZQUFGLENBQWVELEtBQTVEOztRQUNBLElBQUksQ0FBQzk4RSxHQUFELElBQVFxNUMsRUFBRSxDQUFDMmpDLFVBQUgsRUFBWixFQUE2QjtVQUFFO1NBUmQ7Ozs7UUFXakIsSUFBSUYsS0FBSyxJQUFJQSxLQUFLLENBQUNoekYsTUFBZixJQUF5QnRFLE1BQU0sQ0FBQ3kzRixVQUFoQyxJQUE4Q3ozRixNQUFNLENBQUMwM0YsSUFBekQsRUFBK0Q7VUFDN0QsSUFBSTVsRixDQUFDLEdBQUd3bEYsS0FBSyxDQUFDaHpGLE1BQWQ7Y0FBc0JvK0MsSUFBSSxHQUFHejRDLEtBQUssQ0FBQzZILENBQUQsQ0FBbEM7Y0FBdUM2bEYsSUFBSSxHQUFHLENBQTlDOztVQUNBLElBQUlDLG1DQUFtQyxHQUFHLFNBQXRDQSxtQ0FBc0MsR0FBWTtZQUNwRCxJQUFJLEVBQUVELElBQUYsSUFBVTdsRixDQUFkLEVBQWlCO2NBQ2Y4ekMsU0FBUyxDQUFDaU8sRUFBRCxFQUFLLFlBQVk7Z0JBQ3hCcjVDLEdBQUcsR0FBR2loRCxRQUFPLENBQUM1SCxFQUFFLENBQUNrRyxHQUFKLEVBQVN2L0MsR0FBVCxDQUFiO2dCQUNBLElBQUl3NkIsTUFBTSxHQUFHO2tCQUFDdjBCLElBQUksRUFBRWpHLEdBQVA7a0JBQVl5SixFQUFFLEVBQUV6SixHQUFoQjtrQkFDQ2tvQyxJQUFJLEVBQUVtUixFQUFFLENBQUNrRyxHQUFILENBQU91MkIsVUFBUCxDQUNGNXRDLElBQUksQ0FBQ3gvQixNQUFMLENBQVksVUFBVWhOLENBQVYsRUFBYTtvQkFBRSxPQUFPQSxDQUFDLElBQUksSUFBWjttQkFBM0IsRUFBZ0RoUyxJQUFoRCxDQUFxRDJ2RCxFQUFFLENBQUNrRyxHQUFILENBQU82NUIsYUFBUCxFQUFyRCxDQURFLENBRFA7a0JBR0NobEMsTUFBTSxFQUFFO2lCQUh0QjtnQkFJQXFnQyxVQUFVLENBQUNwN0IsRUFBRSxDQUFDa0csR0FBSixFQUFTL2tCLE1BQVQsQ0FBVjtnQkFDQXk0QywwQkFBMEIsQ0FBQzU1QixFQUFFLENBQUNrRyxHQUFKLEVBQVN1dUIsZUFBZSxDQUFDN3NCLFFBQU8sQ0FBQzVILEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3YvQyxHQUFULENBQVIsRUFBdUJpaEQsUUFBTyxDQUFDNUgsRUFBRSxDQUFDa0csR0FBSixFQUFTd3VCLFNBQVMsQ0FBQ3Z6QyxNQUFELENBQWxCLENBQTlCLENBQXhCLENBQTFCO2VBUE8sQ0FBVDs7V0FGSjs7VUFhQSxJQUFJNmlELGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBVUMsSUFBVixFQUFnQnB4RixDQUFoQixFQUFtQjtZQUN4QyxJQUFJbXRELEVBQUUsQ0FBQ2psQixPQUFILENBQVdtcEQsa0JBQVgsSUFDQXg2RSxPQUFPLENBQUNzMkMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV21wRCxrQkFBWixFQUFnQ0QsSUFBSSxDQUFDaHpGLElBQXJDLENBQVAsSUFBcUQsQ0FBQyxDQUQxRCxFQUM2RDtjQUMzRDh5RixtQ0FBbUM7Y0FDbkM7OztZQUVGLElBQUlJLE1BQU0sR0FBRyxJQUFJUCxVQUFKLEVBQWI7O1lBQ0FPLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixZQUFZO2NBQUUsT0FBT0wsbUNBQW1DLEVBQTFDO2FBQS9COztZQUNBSSxNQUFNLENBQUNFLE1BQVAsR0FBZ0IsWUFBWTtjQUMxQixJQUFJN25ELE9BQU8sR0FBRzJuRCxNQUFNLENBQUMxdUYsTUFBckI7O2NBQ0EsSUFBSSwwQkFBMEI0SCxJQUExQixDQUErQm0vQixPQUEvQixDQUFKLEVBQTZDO2dCQUMzQ3VuRCxtQ0FBbUM7Z0JBQ25DOzs7Y0FFRmwxQyxJQUFJLENBQUNoOEMsQ0FBRCxDQUFKLEdBQVUycEMsT0FBVjtjQUNBdW5ELG1DQUFtQzthQVByQzs7WUFTQUksTUFBTSxDQUFDRyxVQUFQLENBQWtCTCxJQUFsQjtXQWpCRjs7VUFtQkEsS0FBSyxJQUFJcHhGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0d0YsS0FBSyxDQUFDaHpGLE1BQTFCLEVBQWtDb0MsQ0FBQyxFQUFuQyxFQUF1QztZQUFFbXhGLGdCQUFnQixDQUFDUCxLQUFLLENBQUM1d0YsQ0FBRCxDQUFOLEVBQVdBLENBQVgsQ0FBaEI7O1NBbEMzQyxNQW1DTzs7O1VBRUwsSUFBSW10RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHZDLFlBQVQsSUFBeUI1bEIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdWMsR0FBUCxDQUFXeHBCLFFBQVgsQ0FBb0J0eUMsR0FBcEIsSUFBMkIsQ0FBQyxDQUF6RCxFQUE0RDtZQUMxRHE1QyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHZDLFlBQVQsQ0FBc0IvNEUsQ0FBdEIsRUFEMEQ7O1lBRzFEZ3NCLFVBQVUsQ0FBQyxZQUFZO2NBQUUsT0FBT21uQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUI5ZSxLQUFqQixFQUFQO2FBQWYsRUFBbUQsRUFBbkQsQ0FBVjtZQUNBOzs7VUFFRixJQUFJO1lBQ0YsSUFBSTZ2QyxNQUFNLEdBQUcxM0YsQ0FBQyxDQUFDNjJGLFlBQUYsQ0FBZWMsT0FBZixDQUF1QixNQUF2QixDQUFiOztZQUNBLElBQUlELE1BQUosRUFBWTtjQUNWLElBQUl6MUMsUUFBSjs7Y0FDQSxJQUFJa1IsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzB2QyxZQUFULElBQXlCLENBQUM1bEIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzB2QyxZQUFULENBQXNCcGQsSUFBcEQsRUFDRTtnQkFBRTFaLFFBQVEsR0FBR2tSLEVBQUUsQ0FBQ3NnQyxjQUFILEVBQVg7OztjQUNKekcsa0JBQWtCLENBQUM3NUIsRUFBRSxDQUFDa0csR0FBSixFQUFTdXVCLGVBQWUsQ0FBQzl0RSxHQUFELEVBQU1BLEdBQU4sQ0FBeEIsQ0FBbEI7O2NBQ0EsSUFBSW1vQyxRQUFKLEVBQWM7Z0JBQUUsS0FBSyxJQUFJaVAsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR2pQLFFBQVEsQ0FBQ3IrQyxNQUFqQyxFQUF5QyxFQUFFc3RELEdBQTNDLEVBQ2Q7a0JBQUV5K0IsYUFBWSxDQUFDeDhCLEVBQUUsQ0FBQ2tHLEdBQUosRUFBUyxFQUFULEVBQWFwWCxRQUFRLENBQUNpUCxHQUFELENBQVIsQ0FBYzV6QyxNQUEzQixFQUFtQzJrQyxRQUFRLENBQUNpUCxHQUFELENBQVIsQ0FBYzFrQyxJQUFqRCxFQUF1RCxNQUF2RCxDQUFaOzs7O2NBQ0oybUMsRUFBRSxDQUFDNGdDLGdCQUFILENBQW9CMkQsTUFBcEIsRUFBNEIsUUFBNUIsRUFBc0MsT0FBdEM7Y0FDQXZrQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUI5ZSxLQUFqQjs7V0FWSixDQWFBLE9BQU1zc0IsR0FBTixFQUFVOzs7O01BSWQsU0FBU3lqQixXQUFULENBQXFCemtDLEVBQXJCLEVBQXlCbnpELENBQXpCLEVBQTRCO1FBQzFCLElBQUk2cEQsRUFBRSxLQUFLLENBQUNzSixFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHZDLFlBQVYsSUFBMEIsQ0FBQyxJQUFJeDZELElBQUosRUFBRCxHQUFZazRFLFFBQVosR0FBdUIsR0FBdEQsQ0FBTixFQUFrRTtVQUFFdmlDLE1BQU0sQ0FBQ2wwRCxDQUFELENBQU47VUFBVzs7O1FBQy9FLElBQUlrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFkLElBQXlCNHJFLGFBQWEsQ0FBQ3pZLEVBQUUsQ0FBQy9vRCxPQUFKLEVBQWFwSyxDQUFiLENBQTFDLEVBQTJEO1VBQUU7OztRQUU3REEsQ0FBQyxDQUFDNjJGLFlBQUYsQ0FBZWdCLE9BQWYsQ0FBdUIsTUFBdkIsRUFBK0Ixa0MsRUFBRSxDQUFDb0MsWUFBSCxFQUEvQjtRQUNBdjFELENBQUMsQ0FBQzYyRixZQUFGLENBQWVpQixhQUFmLEdBQStCLFVBQS9CLENBTDBCOzs7UUFTMUIsSUFBSTkzRixDQUFDLENBQUM2MkYsWUFBRixDQUFla0IsWUFBZixJQUErQixDQUFDM3RDLE1BQXBDLEVBQTRDO1VBQzFDLElBQUk0dEMsR0FBRyxHQUFHdHNDLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsbUNBQXBCLENBQWI7VUFDQXNzQyxHQUFHLENBQUMxdEYsR0FBSixHQUFVLDRFQUFWOztVQUNBLElBQUk2L0MsTUFBSixFQUFZO1lBQ1Y2dEMsR0FBRyxDQUFDOTRDLEtBQUosR0FBWTg0QyxHQUFHLENBQUM1NEMsTUFBSixHQUFhLENBQXpCO1lBQ0ErVCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVgsQ0FBbUJ4bUIsV0FBbkIsQ0FBK0IydEYsR0FBL0IsRUFGVTs7WUFJVkEsR0FBRyxDQUFDQyxJQUFKLEdBQVdELEdBQUcsQ0FBQy9yQixTQUFmOzs7VUFFRmpzRSxDQUFDLENBQUM2MkYsWUFBRixDQUFla0IsWUFBZixDQUE0QkMsR0FBNUIsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEM7O1VBQ0EsSUFBSTd0QyxNQUFKLEVBQVk7WUFBRTZ0QyxHQUFHLENBQUM1bEQsVUFBSixDQUFlcm1CLFdBQWYsQ0FBMkJpc0UsR0FBM0I7Ozs7O01BSWxCLFNBQVNFLFVBQVQsQ0FBb0Iva0MsRUFBcEIsRUFBd0JuekQsQ0FBeEIsRUFBMkI7UUFDekIsSUFBSThaLEdBQUcsR0FBR2s2RCxZQUFZLENBQUM3Z0IsRUFBRCxFQUFLbnpELENBQUwsQ0FBdEI7O1FBQ0EsSUFBSSxDQUFDOFosR0FBTCxFQUFVO1VBQUU7OztRQUNaLElBQUlxK0UsSUFBSSxHQUFHeDNGLFFBQVEsQ0FBQ3NsRSxzQkFBVCxFQUFYO1FBQ0ErUCxtQkFBbUIsQ0FBQzdpQixFQUFELEVBQUtyNUMsR0FBTCxFQUFVcStFLElBQVYsQ0FBbkI7O1FBQ0EsSUFBSSxDQUFDaGxDLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdndUYsVUFBaEIsRUFBNEI7VUFDMUJqbEMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2d1RixVQUFYLEdBQXdCMXNDLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLDJDQUFkLENBQTNCO1VBQ0F5SCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXNGhFLFNBQVgsQ0FBcUJ2OUIsWUFBckIsQ0FBa0Mwa0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2d1RixVQUE3QyxFQUF5RGpsQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXb3VFLFNBQXBFOzs7UUFFRi9zQixvQkFBb0IsQ0FBQzBILEVBQUUsQ0FBQy9vRCxPQUFILENBQVdndUYsVUFBWixFQUF3QkQsSUFBeEIsQ0FBcEI7OztNQUdGLFNBQVN4QixlQUFULENBQXlCeGpDLEVBQXpCLEVBQTZCO1FBQzNCLElBQUlBLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdndUYsVUFBZixFQUEyQjtVQUN6QmpsQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXNGhFLFNBQVgsQ0FBcUJqZ0QsV0FBckIsQ0FBaUNvbkMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2d1RixVQUE1QztVQUNBamxDLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdndUYsVUFBWCxHQUF3QixJQUF4Qjs7T0EzOU1lOzs7OztNQW0rTW5CLFNBQVNDLGlCQUFULENBQTJCbjJGLENBQTNCLEVBQThCO1FBQzVCLElBQUksQ0FBQ3ZCLFFBQVEsQ0FBQzIzRixzQkFBZCxFQUFzQztVQUFFOzs7UUFDeEMsSUFBSUMsT0FBTyxHQUFHNTNGLFFBQVEsQ0FBQzIzRixzQkFBVCxDQUFnQyxZQUFoQyxDQUFkO1lBQTZERSxPQUFPLEdBQUcsRUFBdkU7O1FBQ0EsS0FBSyxJQUFJeHlGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1eUYsT0FBTyxDQUFDMzBGLE1BQTVCLEVBQW9Db0MsQ0FBQyxFQUFyQyxFQUF5QztVQUN2QyxJQUFJbXRELEVBQUUsR0FBR29sQyxPQUFPLENBQUN2eUYsQ0FBRCxDQUFQLENBQVdtd0YsVUFBcEI7O1VBQ0EsSUFBSWhqQyxFQUFKLEVBQVE7WUFBRXFsQyxPQUFPLENBQUM3MUYsSUFBUixDQUFhd3dELEVBQWI7Ozs7UUFFWixJQUFJcWxDLE9BQU8sQ0FBQzUwRixNQUFaLEVBQW9CO1VBQUU0MEYsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXdHpDLFNBQVgsQ0FBcUIsWUFBWTtZQUNyRCxLQUFLLElBQUlsL0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3d5RixPQUFPLENBQUM1MEYsTUFBNUIsRUFBb0NvQyxDQUFDLEVBQXJDLEVBQXlDO2NBQUU5RCxDQUFDLENBQUNzMkYsT0FBTyxDQUFDeHlGLENBQUQsQ0FBUixDQUFEOztXQUR2Qjs7OztNQUt4QixJQUFJeXlGLGlCQUFpQixHQUFHLEtBQXhCOztNQUNBLFNBQVNDLG9CQUFULEdBQWdDO1FBQzlCLElBQUlELGlCQUFKLEVBQXVCO1VBQUU7OztRQUN6QkUsc0JBQXNCO1FBQ3RCRixpQkFBaUIsR0FBRyxJQUFwQjs7O01BRUYsU0FBU0Usc0JBQVQsR0FBa0M7O1FBRWhDLElBQUlDLFdBQUo7UUFDQW5tQyxFQUFFLENBQUNuekQsTUFBRCxFQUFTLFFBQVQsRUFBbUIsWUFBWTtVQUMvQixJQUFJczVGLFdBQVcsSUFBSSxJQUFuQixFQUF5QjtZQUFFQSxXQUFXLEdBQUc1c0UsVUFBVSxDQUFDLFlBQVk7Y0FDOUQ0c0UsV0FBVyxHQUFHLElBQWQ7Y0FDQVAsaUJBQWlCLENBQUNRLFFBQUQsQ0FBakI7YUFGaUQsRUFHaEQsR0FIZ0QsQ0FBeEI7O1NBRDNCLENBQUYsQ0FIZ0M7O1FBVWhDcG1DLEVBQUUsQ0FBQ256RCxNQUFELEVBQVMsTUFBVCxFQUFpQixZQUFZO1VBQUUsT0FBTys0RixpQkFBaUIsQ0FBQzV3QyxNQUFELENBQXhCO1NBQS9CLENBQUY7T0EvL01pQjs7O01Ba2dObkIsU0FBU294QyxRQUFULENBQWtCMWxDLEVBQWxCLEVBQXNCO1FBQ3BCLElBQUlwMEMsQ0FBQyxHQUFHbzBDLEVBQUUsQ0FBQy9vRCxPQUFYLENBRG9COztRQUdwQjJVLENBQUMsQ0FBQ294RCxlQUFGLEdBQW9CcHhELENBQUMsQ0FBQ3F4RCxnQkFBRixHQUFxQnJ4RCxDQUFDLENBQUNxdEQsY0FBRixHQUFtQixJQUE1RDtRQUNBcnRELENBQUMsQ0FBQzRqRSxpQkFBRixHQUFzQixLQUF0QjtRQUNBeHZCLEVBQUUsQ0FBQzJsQyxPQUFIOzs7TUFHRixJQUFJQyxRQUFRLEdBQUc7UUFDYixHQUFHLE9BRFU7UUFDRCxHQUFHLFdBREY7UUFDZSxHQUFHLEtBRGxCO1FBQ3lCLElBQUksT0FEN0I7UUFDc0MsSUFBSSxPQUQxQztRQUNtRCxJQUFJLE1BRHZEO1FBQytELElBQUksS0FEbkU7UUFFYixJQUFJLE9BRlM7UUFFQSxJQUFJLFVBRko7UUFFZ0IsSUFBSSxLQUZwQjtRQUUyQixJQUFJLE9BRi9CO1FBRXdDLElBQUksUUFGNUM7UUFFc0QsSUFBSSxVQUYxRDtRQUVzRSxJQUFJLEtBRjFFO1FBR2IsSUFBSSxNQUhTO1FBR0QsSUFBSSxNQUhIO1FBR1csSUFBSSxJQUhmO1FBR3FCLElBQUksT0FIekI7UUFHa0MsSUFBSSxNQUh0QztRQUc4QyxJQUFJLFdBSGxEO1FBRytELElBQUksUUFIbkU7UUFJYixJQUFJLFFBSlM7UUFJQyxJQUFJLEdBSkw7UUFJVSxJQUFJLEdBSmQ7UUFJbUIsSUFBSSxLQUp2QjtRQUk4QixJQUFJLEtBSmxDO1FBSXlDLElBQUksS0FKN0M7UUFLYixLQUFLLEdBTFE7UUFLSCxLQUFLLEdBTEY7UUFLTyxLQUFLLEdBTFo7UUFLaUIsS0FBSyxHQUx0QjtRQUsyQixLQUFLLEdBTGhDO1FBS3FDLEtBQUssWUFMMUM7UUFNYixLQUFLLEdBTlE7UUFNSCxLQUFLLEdBTkY7UUFNTyxLQUFLLEdBTlo7UUFNaUIsS0FBSyxHQU50QjtRQU0yQixLQUFLLEdBTmhDO1FBTXFDLEtBQUssR0FOMUM7UUFNK0MsS0FBSyxHQU5wRDtRQU15RCxLQUFLLEdBTjlEO1FBTW1FLEtBQUssR0FOeEU7UUFNNkUsS0FBSyxJQU5sRjtRQU9iLEtBQUssR0FQUTtRQU9ILEtBQUssR0FQRjtRQU9PLEtBQUssS0FQWjtRQU9tQixPQUFPLElBUDFCO1FBT2dDLE9BQU8sTUFQdkM7UUFPK0MsT0FBTyxNQVB0RDtRQU84RCxPQUFPLE9BUHJFO1FBTzhFLE9BQU8sUUFQckY7UUFRYixPQUFPLE1BUk07UUFRRSxPQUFPLEtBUlQ7UUFRZ0IsT0FBTyxRQVJ2QjtRQVFpQyxPQUFPLFVBUnhDO1FBUW9ELE9BQU87T0FSMUUsQ0ExZ05tQjs7TUFzaE5uQixLQUFLLElBQUkveUYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QixFQUE2QjtRQUFFK3lGLFFBQVEsQ0FBQy95RixDQUFDLEdBQUcsRUFBTCxDQUFSLEdBQW1CK3lGLFFBQVEsQ0FBQy95RixDQUFDLEdBQUcsRUFBTCxDQUFSLEdBQW1CdkMsTUFBTSxDQUFDdUMsQ0FBRCxDQUE1QztPQXRoTlo7OztNQXdoTm5CLEtBQUssSUFBSWtyRCxHQUFHLEdBQUcsRUFBZixFQUFtQkEsR0FBRyxJQUFJLEVBQTFCLEVBQThCQSxHQUFHLEVBQWpDLEVBQXFDO1FBQUU2bkMsUUFBUSxDQUFDN25DLEdBQUQsQ0FBUixHQUFnQnp0RCxNQUFNLENBQUMrVixZQUFQLENBQW9CMDNDLEdBQXBCLENBQWhCO09BeGhOcEI7OztNQTBoTm5CLEtBQUssSUFBSUMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsSUFBSSxFQUF6QixFQUE2QkEsR0FBRyxFQUFoQyxFQUFvQztRQUFFNG5DLFFBQVEsQ0FBQzVuQyxHQUFHLEdBQUcsR0FBUCxDQUFSLEdBQXNCNG5DLFFBQVEsQ0FBQzVuQyxHQUFHLEdBQUcsS0FBUCxDQUFSLEdBQXdCLE1BQU1BLEdBQXBEOzs7TUFFdEMsSUFBSTZuQyxNQUFNLEdBQUcsRUFBYjtNQUVBQSxNQUFNLENBQUNDLEtBQVAsR0FBZTtRQUNiLFFBQVEsWUFESztRQUNTLFNBQVMsYUFEbEI7UUFDaUMsTUFBTSxVQUR2QztRQUNtRCxRQUFRLFlBRDNEO1FBRWIsT0FBTyxXQUZNO1FBRU8sUUFBUSxrQkFGZjtRQUVtQyxVQUFVLFVBRjdDO1FBRXlELFlBQVksWUFGckU7UUFHYixVQUFVLGNBSEc7UUFHYSxhQUFhLGVBSDFCO1FBRzJDLG1CQUFtQixlQUg5RDtRQUliLE9BQU8sWUFKTTtRQUlRLGFBQWEsWUFKckI7UUFLYixTQUFTLGtCQUxJO1FBS2dCLFVBQVUsaUJBTDFCO1FBTWIsT0FBTztPQU5ULENBOWhObUI7Ozs7TUF5aU5uQkQsTUFBTSxDQUFDRSxTQUFQLEdBQW1CO1FBQ2pCLFVBQVUsV0FETztRQUNNLFVBQVUsWUFEaEI7UUFDOEIsVUFBVSxNQUR4QztRQUNnRCxnQkFBZ0IsTUFEaEU7UUFDd0UsVUFBVSxNQURsRjtRQUVqQixhQUFhLFlBRkk7UUFFVSxZQUFZLFVBRnRCO1FBRWtDLFdBQVcsVUFGN0M7UUFFeUQsYUFBYSxZQUZ0RTtRQUdqQixhQUFhLGFBSEk7UUFHVyxjQUFjLGNBSHpCO1FBR3lDLFlBQVksYUFIckQ7UUFHb0UsYUFBYSxXQUhqRjtRQUlqQixrQkFBa0IsZ0JBSkQ7UUFJbUIsZUFBZSxlQUpsQztRQUltRCxVQUFVLE1BSjdEO1FBSXFFLFVBQVUsTUFKL0U7UUFLakIsVUFBVSxVQUxPO1FBS0ssZ0JBQWdCLFVBTHJCO1FBS2lDLGdCQUFnQixTQUxqRDtRQUs0RCxnQkFBZ0IsWUFMNUU7UUFNakIsVUFBVSxZQU5PO1FBTU8sVUFBVSxZQU5qQjtRQU9qQixVQUFVLGVBUE87UUFPVSxnQkFBZ0IsZUFQMUI7UUFPMkMsU0FBUyxlQVBwRDtRQVFqQixlQUFlO09BUmpCLENBemlObUI7O01Bb2pObkJGLE1BQU0sQ0FBQ0csTUFBUCxHQUFnQjtRQUNkLFVBQVUsYUFESTtRQUNXLFVBQVUsWUFEckI7UUFDbUMsVUFBVSxVQUQ3QztRQUN5RCxVQUFVLFlBRG5FO1FBRWQsVUFBVSxhQUZJO1FBRVcsVUFBVSxXQUZyQjtRQUVrQyxVQUFVLFlBRjVDO1FBRTBELGdCQUFnQixVQUYxRTtRQUdkLFVBQVUsY0FISTtRQUdZLFVBQVUsZUFIdEI7UUFHdUMsaUJBQWlCLGVBSHhEO1FBR3lFLFVBQVUsVUFIbkY7UUFJZCxVQUFVLGdCQUpJO1FBSWMsVUFBVTtPQUp4QztNQU1BSCxNQUFNLENBQUNJLFVBQVAsR0FBb0I7UUFDbEIsU0FBUyxXQURTO1FBQ0ksU0FBUyxZQURiO1FBQzJCLFNBQVMsTUFEcEM7UUFDNEMsZUFBZSxNQUQzRDtRQUNtRSxTQUFTLE1BRDVFO1FBRWxCLFlBQVksWUFGTTtRQUVRLFVBQVUsWUFGbEI7UUFFZ0MsV0FBVyxVQUYzQztRQUV1RCxZQUFZLFVBRm5FO1FBRStFLFlBQVksYUFGM0Y7UUFHbEIsYUFBYSxjQUhLO1FBR1csWUFBWSxZQUh2QjtRQUdxQyxhQUFhLGFBSGxEO1FBR2lFLGlCQUFpQixnQkFIbEY7UUFJbEIsc0JBQXNCLGVBSko7UUFJcUIsY0FBYyxlQUpuQztRQUlvRCxTQUFTLE1BSjdEO1FBSXFFLFNBQVMsTUFKOUU7UUFLbEIsU0FBUyxVQUxTO1FBS0csZUFBZSxVQUxsQjtRQUs4QixhQUFhLFNBTDNDO1FBS3NELG1CQUFtQixZQUx6RTtRQU1sQixTQUFTLFlBTlM7UUFNSyxTQUFTLFlBTmQ7UUFNNEIsaUJBQWlCLG9CQU43QztRQU1tRSxjQUFjLHFCQU5qRjtRQU9sQixTQUFTLGVBUFM7UUFPUSxlQUFlLGVBUHZCO1FBT3dDLFdBQVcsWUFQbkQ7UUFPaUUsYUFBYSxVQVA5RTtRQVFsQixlQUFlLENBQUMsT0FBRCxFQUFVLFFBQVY7T0FSakI7TUFVQUosTUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQnB1QyxHQUFHLEdBQUdvdUMsTUFBTSxDQUFDSSxVQUFWLEdBQXVCSixNQUFNLENBQUNFLFNBQXJELENBcGtObUI7O01Bd2tObkIsU0FBU0csZ0JBQVQsQ0FBMEJoMUYsSUFBMUIsRUFBZ0M7UUFDOUIsSUFBSWlyQyxLQUFLLEdBQUdqckMsSUFBSSxDQUFDbkIsS0FBTCxDQUFXLFFBQVgsQ0FBWjtRQUNBbUIsSUFBSSxHQUFHaXJDLEtBQUssQ0FBQ0EsS0FBSyxDQUFDMXJDLE1BQU4sR0FBZSxDQUFoQixDQUFaO1FBQ0EsSUFBSTAxRixHQUFKLEVBQVNDLElBQVQsRUFBZXJnQixLQUFmLEVBQXNCc2dCLEdBQXRCOztRQUNBLEtBQUssSUFBSXh6RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc3BDLEtBQUssQ0FBQzFyQyxNQUFOLEdBQWUsQ0FBbkMsRUFBc0NvQyxDQUFDLEVBQXZDLEVBQTJDO1VBQ3pDLElBQUl5ekYsR0FBRyxHQUFHbnFELEtBQUssQ0FBQ3RwQyxDQUFELENBQWY7O1VBQ0EsSUFBSSxrQkFBa0J3SyxJQUFsQixDQUF1QmlwRixHQUF2QixDQUFKLEVBQWlDO1lBQUVELEdBQUcsR0FBRyxJQUFOO1dBQW5DLE1BQ0ssSUFBSSxZQUFZaHBGLElBQVosQ0FBaUJpcEYsR0FBakIsQ0FBSixFQUEyQjtZQUFFSCxHQUFHLEdBQUcsSUFBTjtXQUE3QixNQUNBLElBQUksc0JBQXNCOW9GLElBQXRCLENBQTJCaXBGLEdBQTNCLENBQUosRUFBcUM7WUFBRUYsSUFBSSxHQUFHLElBQVA7V0FBdkMsTUFDQSxJQUFJLGNBQWMvb0YsSUFBZCxDQUFtQmlwRixHQUFuQixDQUFKLEVBQTZCO1lBQUV2Z0IsS0FBSyxHQUFHLElBQVI7V0FBL0IsTUFDQTtZQUFFLE1BQU0sSUFBSTV2QyxLQUFKLENBQVUsaUNBQWlDbXdELEdBQTNDLENBQU47Ozs7UUFFVCxJQUFJSCxHQUFKLEVBQVM7VUFBRWoxRixJQUFJLEdBQUcsU0FBU0EsSUFBaEI7OztRQUNYLElBQUlrMUYsSUFBSixFQUFVO1VBQUVsMUYsSUFBSSxHQUFHLFVBQVVBLElBQWpCOzs7UUFDWixJQUFJbTFGLEdBQUosRUFBUztVQUFFbjFGLElBQUksR0FBRyxTQUFTQSxJQUFoQjs7O1FBQ1gsSUFBSTYwRSxLQUFKLEVBQVc7VUFBRTcwRSxJQUFJLEdBQUcsV0FBV0EsSUFBbEI7OztRQUNiLE9BQU9BLElBQVA7T0F4bE5pQjs7Ozs7OztNQWdtTm5CLFNBQVNxMUYsZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7UUFDL0IsSUFBSWgrQixJQUFJLEdBQUcsRUFBWDs7UUFDQSxLQUFLLElBQUlpK0IsT0FBVCxJQUFvQkQsTUFBcEIsRUFBNEI7VUFBRSxJQUFJQSxNQUFNLENBQUNoNkYsY0FBUCxDQUFzQmk2RixPQUF0QixDQUFKLEVBQW9DO1lBQ2hFLElBQUloNEYsS0FBSyxHQUFHKzNGLE1BQU0sQ0FBQ0MsT0FBRCxDQUFsQjs7WUFDQSxJQUFJLG1DQUFtQ3BwRixJQUFuQyxDQUF3Q29wRixPQUF4QyxDQUFKLEVBQXNEO2NBQUU7OztZQUN4RCxJQUFJaDRGLEtBQUssSUFBSSxLQUFiLEVBQW9CO2NBQUUsT0FBTyszRixNQUFNLENBQUNDLE9BQUQsQ0FBYjtjQUF3Qjs7O1lBRTlDLElBQUkvd0YsSUFBSSxHQUFHeVosR0FBRyxDQUFDczNFLE9BQU8sQ0FBQzEyRixLQUFSLENBQWMsR0FBZCxDQUFELEVBQXFCbTJGLGdCQUFyQixDQUFkOztZQUNBLEtBQUssSUFBSXJ6RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNkMsSUFBSSxDQUFDakYsTUFBekIsRUFBaUNvQyxDQUFDLEVBQWxDLEVBQXNDO2NBQ3BDLElBQUk5RSxHQUFHLEdBQUksS0FBSyxDQUFoQjtrQkFBb0JtRCxJQUFJLEdBQUksS0FBSyxDQUFqQzs7Y0FDQSxJQUFJMkIsQ0FBQyxJQUFJNkMsSUFBSSxDQUFDakYsTUFBTCxHQUFjLENBQXZCLEVBQTBCO2dCQUN4QlMsSUFBSSxHQUFHd0UsSUFBSSxDQUFDckYsSUFBTCxDQUFVLEdBQVYsQ0FBUDtnQkFDQXRDLEdBQUcsR0FBR1UsS0FBTjtlQUZGLE1BR087Z0JBQ0x5QyxJQUFJLEdBQUd3RSxJQUFJLENBQUN4QixLQUFMLENBQVcsQ0FBWCxFQUFjckIsQ0FBQyxHQUFHLENBQWxCLEVBQXFCeEMsSUFBckIsQ0FBMEIsR0FBMUIsQ0FBUDtnQkFDQXRDLEdBQUcsR0FBRyxLQUFOOzs7Y0FFRixJQUFJb3hCLElBQUksR0FBR3FwQyxJQUFJLENBQUN0M0QsSUFBRCxDQUFmOztjQUNBLElBQUksQ0FBQ2l1QixJQUFMLEVBQVc7Z0JBQUVxcEMsSUFBSSxDQUFDdDNELElBQUQsQ0FBSixHQUFhbkQsR0FBYjtlQUFiLE1BQ0ssSUFBSW94QixJQUFJLElBQUlweEIsR0FBWixFQUFpQjtnQkFBRSxNQUFNLElBQUlvb0MsS0FBSixDQUFVLCtCQUErQmpsQyxJQUF6QyxDQUFOOzs7O1lBRTFCLE9BQU9zMUYsTUFBTSxDQUFDQyxPQUFELENBQWI7Ozs7UUFFRixLQUFLLElBQUkxc0MsSUFBVCxJQUFpQnlPLElBQWpCLEVBQXVCO1VBQUVnK0IsTUFBTSxDQUFDenNDLElBQUQsQ0FBTixHQUFleU8sSUFBSSxDQUFDek8sSUFBRCxDQUFuQjs7O1FBQ3pCLE9BQU95c0MsTUFBUDs7O01BR0YsU0FBU0UsU0FBVCxDQUFtQmg2RixHQUFuQixFQUF3QnlpQixHQUF4QixFQUE2QjhvQixNQUE3QixFQUFxQzd1QixPQUFyQyxFQUE4QztRQUM1QytGLEdBQUcsR0FBR3czRSxTQUFTLENBQUN4M0UsR0FBRCxDQUFmO1FBQ0EsSUFBSTB0QyxLQUFLLEdBQUcxdEMsR0FBRyxDQUFDeGlCLElBQUosR0FBV3dpQixHQUFHLENBQUN4aUIsSUFBSixDQUFTRCxHQUFULEVBQWMwYyxPQUFkLENBQVgsR0FBb0MrRixHQUFHLENBQUN6aUIsR0FBRCxDQUFuRDs7UUFDQSxJQUFJbXdELEtBQUssS0FBSyxLQUFkLEVBQXFCO1VBQUUsT0FBTyxTQUFQOzs7UUFDdkIsSUFBSUEsS0FBSyxLQUFLLEtBQWQsRUFBcUI7VUFBRSxPQUFPLE9BQVA7OztRQUN2QixJQUFJQSxLQUFLLElBQUksSUFBVCxJQUFpQjVrQixNQUFNLENBQUM0a0IsS0FBRCxDQUEzQixFQUFvQztVQUFFLE9BQU8sU0FBUDs7O1FBRXRDLElBQUkxdEMsR0FBRyxDQUFDeTNFLFdBQVIsRUFBcUI7VUFDbkIsSUFBSTc1RixNQUFNLENBQUN3RCxTQUFQLENBQWlCdkMsUUFBakIsQ0FBMEJyQixJQUExQixDQUErQndpQixHQUFHLENBQUN5M0UsV0FBbkMsS0FBbUQsZ0JBQXZELEVBQ0U7WUFBRSxPQUFPRixTQUFTLENBQUNoNkYsR0FBRCxFQUFNeWlCLEdBQUcsQ0FBQ3kzRSxXQUFWLEVBQXVCM3VELE1BQXZCLEVBQStCN3VCLE9BQS9CLENBQWhCOzs7VUFDSixLQUFLLElBQUl2VyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc2MsR0FBRyxDQUFDeTNFLFdBQUosQ0FBZ0JuMkYsTUFBcEMsRUFBNENvQyxDQUFDLEVBQTdDLEVBQWlEO1lBQy9DLElBQUk0QyxNQUFNLEdBQUdpeEYsU0FBUyxDQUFDaDZGLEdBQUQsRUFBTXlpQixHQUFHLENBQUN5M0UsV0FBSixDQUFnQi96RixDQUFoQixDQUFOLEVBQTBCb2xDLE1BQTFCLEVBQWtDN3VCLE9BQWxDLENBQXRCOztZQUNBLElBQUkzVCxNQUFKLEVBQVk7Y0FBRSxPQUFPQSxNQUFQOzs7O09Bdm9ORDs7OztNQThvTm5CLFNBQVNveEYsYUFBVCxDQUF1QnA0RixLQUF2QixFQUE4QjtRQUM1QixJQUFJeUMsSUFBSSxHQUFHLE9BQU96QyxLQUFQLElBQWdCLFFBQWhCLEdBQTJCQSxLQUEzQixHQUFtQ20zRixRQUFRLENBQUNuM0YsS0FBSyxDQUFDcTRGLE9BQVAsQ0FBdEQ7UUFDQSxPQUFPNTFGLElBQUksSUFBSSxNQUFSLElBQWtCQSxJQUFJLElBQUksS0FBMUIsSUFBbUNBLElBQUksSUFBSSxPQUEzQyxJQUFzREEsSUFBSSxJQUFJLEtBQXJFOzs7TUFHRixTQUFTNjFGLGdCQUFULENBQTBCNzFGLElBQTFCLEVBQWdDaW5CLEtBQWhDLEVBQXVDNnVFLE9BQXZDLEVBQWdEO1FBQzlDLElBQUlwMEMsSUFBSSxHQUFHMWhELElBQVg7O1FBQ0EsSUFBSWluQixLQUFLLENBQUM4dUUsTUFBTixJQUFnQnIwQyxJQUFJLElBQUksS0FBNUIsRUFBbUM7VUFBRTFoRCxJQUFJLEdBQUcsU0FBU0EsSUFBaEI7OztRQUNyQyxJQUFJLENBQUMybUQsV0FBVyxHQUFHMS9CLEtBQUssQ0FBQyt1RSxPQUFULEdBQW1CL3VFLEtBQUssQ0FBQ2lwQyxPQUFyQyxLQUFpRHhPLElBQUksSUFBSSxNQUE3RCxFQUFxRTtVQUFFMWhELElBQUksR0FBRyxVQUFVQSxJQUFqQjs7O1FBQ3ZFLElBQUksQ0FBQzJtRCxXQUFXLEdBQUcxL0IsS0FBSyxDQUFDaXBDLE9BQVQsR0FBbUJqcEMsS0FBSyxDQUFDK3VFLE9BQXJDLEtBQWlEdDBDLElBQUksSUFBSSxLQUE3RCxFQUFvRTtVQUFFMWhELElBQUksR0FBRyxTQUFTQSxJQUFoQjs7O1FBQ3RFLElBQUksQ0FBQzgxRixPQUFELElBQVk3dUUsS0FBSyxDQUFDZ3ZFLFFBQWxCLElBQThCdjBDLElBQUksSUFBSSxPQUExQyxFQUFtRDtVQUFFMWhELElBQUksR0FBRyxXQUFXQSxJQUFsQjs7O1FBQ3JELE9BQU9BLElBQVA7T0F6cE5pQjs7O01BNnBObkIsU0FBU2syRixPQUFULENBQWlCanZFLEtBQWpCLEVBQXdCNnVFLE9BQXhCLEVBQWlDO1FBQy9CLElBQUlod0MsTUFBTSxJQUFJNytCLEtBQUssQ0FBQzJ1RSxPQUFOLElBQWlCLEVBQTNCLElBQWlDM3VFLEtBQUssQ0FBQyxNQUFELENBQTFDLEVBQW9EO1VBQUUsT0FBTyxLQUFQOzs7UUFDdEQsSUFBSWpuQixJQUFJLEdBQUcwMEYsUUFBUSxDQUFDenRFLEtBQUssQ0FBQzJ1RSxPQUFQLENBQW5COztRQUNBLElBQUk1MUYsSUFBSSxJQUFJLElBQVIsSUFBZ0JpbkIsS0FBSyxDQUFDa3ZFLFdBQTFCLEVBQXVDO1VBQUUsT0FBTyxLQUFQO1NBSFY7Ozs7UUFNL0IsSUFBSWx2RSxLQUFLLENBQUMydUUsT0FBTixJQUFpQixDQUFqQixJQUFzQjN1RSxLQUFLLENBQUNsWCxJQUFoQyxFQUFzQztVQUFFL1AsSUFBSSxHQUFHaW5CLEtBQUssQ0FBQ2xYLElBQWI7OztRQUN4QyxPQUFPOGxGLGdCQUFnQixDQUFDNzFGLElBQUQsRUFBT2luQixLQUFQLEVBQWM2dUUsT0FBZCxDQUF2Qjs7O01BR0YsU0FBU0wsU0FBVCxDQUFtQjU0RixHQUFuQixFQUF3QjtRQUN0QixPQUFPLE9BQU9BLEdBQVAsSUFBYyxRQUFkLEdBQXlCODNGLE1BQU0sQ0FBQzkzRixHQUFELENBQS9CLEdBQXVDQSxHQUE5QztPQXhxTmlCOzs7O01BNnFObkIsU0FBU3U1RixtQkFBVCxDQUE2QnRuQyxFQUE3QixFQUFpQ3VuQyxPQUFqQyxFQUEwQztRQUN4QyxJQUFJN2tCLE1BQU0sR0FBRzFpQixFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFQLENBQVdDLE1BQXhCO1lBQWdDOGtCLElBQUksR0FBRyxFQUF2QyxDQUR3Qzs7O1FBSXhDLEtBQUssSUFBSTMwRixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7VUFDdEMsSUFBSTQwRixNQUFNLEdBQUdGLE9BQU8sQ0FBQzdrQixNQUFNLENBQUM3dkUsQ0FBRCxDQUFQLENBQXBCOztVQUNBLE9BQU8yMEYsSUFBSSxDQUFDLzJGLE1BQUwsSUFBZTYyRCxHQUFHLENBQUNtZ0MsTUFBTSxDQUFDNzZFLElBQVIsRUFBYzJ1QyxHQUFHLENBQUNpc0MsSUFBRCxDQUFILENBQVVwM0UsRUFBeEIsQ0FBSCxJQUFrQyxDQUF4RCxFQUEyRDtZQUN6RCxJQUFJczNFLFFBQVEsR0FBR0YsSUFBSSxDQUFDL3ZELEdBQUwsRUFBZjs7WUFDQSxJQUFJNnZCLEdBQUcsQ0FBQ29nQyxRQUFRLENBQUM5NkUsSUFBVixFQUFnQjY2RSxNQUFNLENBQUM3NkUsSUFBdkIsQ0FBSCxHQUFrQyxDQUF0QyxFQUF5QztjQUN2QzY2RSxNQUFNLENBQUM3NkUsSUFBUCxHQUFjODZFLFFBQVEsQ0FBQzk2RSxJQUF2QjtjQUNBOzs7O1VBR0o0NkUsSUFBSSxDQUFDaDRGLElBQUwsQ0FBVWk0RixNQUFWO1NBYnNDOzs7UUFnQnhDcFosT0FBTyxDQUFDcnVCLEVBQUQsRUFBSyxZQUFZO1VBQ3RCLEtBQUssSUFBSW50RCxDQUFDLEdBQUcyMEYsSUFBSSxDQUFDLzJGLE1BQUwsR0FBYyxDQUEzQixFQUE4Qm9DLENBQUMsSUFBSSxDQUFuQyxFQUFzQ0EsQ0FBQyxFQUF2QyxFQUNFO1lBQUUycEYsYUFBWSxDQUFDeDhCLEVBQUUsQ0FBQ2tHLEdBQUosRUFBUyxFQUFULEVBQWFzaEMsSUFBSSxDQUFDMzBGLENBQUQsQ0FBSixDQUFRK1osSUFBckIsRUFBMkI0NkUsSUFBSSxDQUFDMzBGLENBQUQsQ0FBSixDQUFRdWQsRUFBbkMsRUFBdUMsU0FBdkMsQ0FBWjs7O1VBQ0pvNEQsbUJBQW1CLENBQUN4b0IsRUFBRCxDQUFuQjtTQUhLLENBQVA7OztNQU9GLFNBQVMybkMsaUJBQVQsQ0FBMkJ2b0MsSUFBM0IsRUFBaUM5cEMsRUFBakMsRUFBcUNnbkMsR0FBckMsRUFBMEM7UUFDeEMsSUFBSTFxRCxNQUFNLEdBQUd5cUQsa0JBQWtCLENBQUMrQyxJQUFJLENBQUN2USxJQUFOLEVBQVl2NUIsRUFBRSxHQUFHZ25DLEdBQWpCLEVBQXNCQSxHQUF0QixDQUEvQjtRQUNBLE9BQU8xcUQsTUFBTSxHQUFHLENBQVQsSUFBY0EsTUFBTSxHQUFHd3RELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFqQyxHQUEwQyxJQUExQyxHQUFpRG1CLE1BQXhEOzs7TUFHRixTQUFTZzJGLGFBQVQsQ0FBdUJ4b0MsSUFBdkIsRUFBNkJyeEMsS0FBN0IsRUFBb0N1dUMsR0FBcEMsRUFBeUM7UUFDdkMsSUFBSWhuQyxFQUFFLEdBQUdxeUUsaUJBQWlCLENBQUN2b0MsSUFBRCxFQUFPcnhDLEtBQUssQ0FBQ3VILEVBQWIsRUFBaUJnbkMsR0FBakIsQ0FBMUI7UUFDQSxPQUFPaG5DLEVBQUUsSUFBSSxJQUFOLEdBQWEsSUFBYixHQUFvQixJQUFJK3hDLEdBQUosQ0FBUXQ1QyxLQUFLLENBQUNxeEMsSUFBZCxFQUFvQjlwQyxFQUFwQixFQUF3QmduQyxHQUFHLEdBQUcsQ0FBTixHQUFVLE9BQVYsR0FBb0IsUUFBNUMsQ0FBM0I7OztNQUdGLFNBQVN1ckMsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkI5bkMsRUFBN0IsRUFBaUNzUSxPQUFqQyxFQUEwQzFKLE1BQTFDLEVBQWtEdEssR0FBbEQsRUFBdUQ7UUFDckQsSUFBSXdyQyxRQUFKLEVBQWM7VUFDWixJQUFJOW5DLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3RJLFNBQVAsSUFBb0IsS0FBeEIsRUFBK0I7WUFBRXRCLEdBQUcsR0FBRyxDQUFDQSxHQUFQOzs7VUFDakMsSUFBSU0sS0FBSyxHQUFHdUMsUUFBUSxDQUFDbVIsT0FBRCxFQUFVdFEsRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBakIsQ0FBcEI7O1VBQ0EsSUFBSWhCLEtBQUosRUFBVztZQUNULElBQUkxaEIsSUFBSSxHQUFHb2hCLEdBQUcsR0FBRyxDQUFOLEdBQVVmLEdBQUcsQ0FBQ3FCLEtBQUQsQ0FBYixHQUF1QkEsS0FBSyxDQUFDLENBQUQsQ0FBdkM7WUFDQSxJQUFJbXJDLGtCQUFrQixHQUFJenJDLEdBQUcsR0FBRyxDQUFQLEtBQWNwaEIsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUE1QixDQUF6QjtZQUNBLElBQUk1ckMsTUFBTSxHQUFHNjJFLGtCQUFrQixHQUFHLE9BQUgsR0FBYSxRQUE1QztZQUNBLElBQUl6eUUsRUFBSixDQUpTOzs7Ozs7O1lBV1QsSUFBSTRsQixJQUFJLENBQUM0aEIsS0FBTCxHQUFhLENBQWIsSUFBa0JrRCxFQUFFLENBQUNrRyxHQUFILENBQU90SSxTQUFQLElBQW9CLEtBQTFDLEVBQWlEO2NBQy9DLElBQUlvcUMsSUFBSSxHQUFHcnRCLHFCQUFxQixDQUFDM2EsRUFBRCxFQUFLc1EsT0FBTCxDQUFoQztjQUNBaDdDLEVBQUUsR0FBR2duQyxHQUFHLEdBQUcsQ0FBTixHQUFVZ1UsT0FBTyxDQUFDemhCLElBQVIsQ0FBYXArQyxNQUFiLEdBQXNCLENBQWhDLEdBQW9DLENBQXpDO2NBQ0EsSUFBSTJ1RSxTQUFTLEdBQUcxRSxtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS2dvQyxJQUFMLEVBQVcxeUUsRUFBWCxDQUFuQixDQUFrQ2k0QixHQUFsRDtjQUNBajRCLEVBQUUsR0FBR2luQyxTQUFTLENBQUMsVUFBVWpuQyxFQUFWLEVBQWM7Z0JBQUUsT0FBT29sRCxtQkFBbUIsQ0FBQzFhLEVBQUQsRUFBS2dvQyxJQUFMLEVBQVcxeUUsRUFBWCxDQUFuQixDQUFrQ2k0QixHQUFsQyxJQUF5QzZ4QixTQUFoRDtlQUFqQixFQUFnRjlpQixHQUFHLEdBQUcsQ0FBUCxLQUFjcGhCLElBQUksQ0FBQzRoQixLQUFMLElBQWMsQ0FBNUIsSUFBaUM1aEIsSUFBSSxDQUFDdHVCLElBQXRDLEdBQTZDc3VCLElBQUksQ0FBQzlxQixFQUFMLEdBQVUsQ0FBdEksRUFBeUlrRixFQUF6SSxDQUFkOztjQUNBLElBQUlwRSxNQUFNLElBQUksUUFBZCxFQUF3QjtnQkFBRW9FLEVBQUUsR0FBR3F5RSxpQkFBaUIsQ0FBQ3IzQixPQUFELEVBQVVoN0MsRUFBVixFQUFjLENBQWQsQ0FBdEI7O2FBTDVCLE1BTU87Y0FBRUEsRUFBRSxHQUFHZ25DLEdBQUcsR0FBRyxDQUFOLEdBQVVwaEIsSUFBSSxDQUFDOXFCLEVBQWYsR0FBb0I4cUIsSUFBSSxDQUFDdHVCLElBQTlCOzs7WUFDVCxPQUFPLElBQUl5NkMsR0FBSixDQUFRVCxNQUFSLEVBQWdCdHhDLEVBQWhCLEVBQW9CcEUsTUFBcEIsQ0FBUDs7OztRQUdKLE9BQU8sSUFBSW0yQyxHQUFKLENBQVFULE1BQVIsRUFBZ0J0SyxHQUFHLEdBQUcsQ0FBTixHQUFVZ1UsT0FBTyxDQUFDemhCLElBQVIsQ0FBYXArQyxNQUF2QixHQUFnQyxDQUFoRCxFQUFtRDZyRCxHQUFHLEdBQUcsQ0FBTixHQUFVLFFBQVYsR0FBcUIsT0FBeEUsQ0FBUDs7O01BR0YsU0FBUzJyQyxZQUFULENBQXNCam9DLEVBQXRCLEVBQTBCWixJQUExQixFQUFnQ3J4QyxLQUFoQyxFQUF1Q3V1QyxHQUF2QyxFQUE0QztRQUMxQyxJQUFJNHJDLElBQUksR0FBRy9vQyxRQUFRLENBQUNDLElBQUQsRUFBT1ksRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBZCxDQUFuQjs7UUFDQSxJQUFJLENBQUNzcUMsSUFBTCxFQUFXO1VBQUUsT0FBT04sYUFBYSxDQUFDeG9DLElBQUQsRUFBT3J4QyxLQUFQLEVBQWN1dUMsR0FBZCxDQUFwQjs7O1FBQ2IsSUFBSXZ1QyxLQUFLLENBQUN1SCxFQUFOLElBQVk4cEMsSUFBSSxDQUFDdlEsSUFBTCxDQUFVcCtDLE1BQTFCLEVBQWtDO1VBQ2hDc2QsS0FBSyxDQUFDdUgsRUFBTixHQUFXOHBDLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVXArQyxNQUFyQjtVQUNBc2QsS0FBSyxDQUFDbUQsTUFBTixHQUFlLFFBQWY7U0FGRixNQUdPLElBQUluRCxLQUFLLENBQUN1SCxFQUFOLElBQVksQ0FBaEIsRUFBbUI7VUFDeEJ2SCxLQUFLLENBQUN1SCxFQUFOLEdBQVcsQ0FBWDtVQUNBdkgsS0FBSyxDQUFDbUQsTUFBTixHQUFlLE9BQWY7OztRQUVGLElBQUl1dEQsT0FBTyxHQUFHemhCLGFBQWEsQ0FBQ2tyQyxJQUFELEVBQU9uNkUsS0FBSyxDQUFDdUgsRUFBYixFQUFpQnZILEtBQUssQ0FBQ21ELE1BQXZCLENBQTNCO1lBQTJEZ3FCLElBQUksR0FBR2d0RCxJQUFJLENBQUN6cEIsT0FBRCxDQUF0RTs7UUFDQSxJQUFJemUsRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBUCxJQUFvQixLQUFwQixJQUE2QjFpQixJQUFJLENBQUM0aEIsS0FBTCxHQUFhLENBQWIsSUFBa0IsQ0FBL0MsS0FBcURSLEdBQUcsR0FBRyxDQUFOLEdBQVVwaEIsSUFBSSxDQUFDOXFCLEVBQUwsR0FBVXJDLEtBQUssQ0FBQ3VILEVBQTFCLEdBQStCNGxCLElBQUksQ0FBQ3R1QixJQUFMLEdBQVltQixLQUFLLENBQUN1SCxFQUF0RyxDQUFKLEVBQStHOzs7VUFHN0csT0FBT3N5RSxhQUFhLENBQUN4b0MsSUFBRCxFQUFPcnhDLEtBQVAsRUFBY3V1QyxHQUFkLENBQXBCOzs7UUFHRixJQUFJNnJDLEVBQUUsR0FBRyxTQUFMQSxFQUFLLENBQVV4aEYsR0FBVixFQUFlMjFDLEdBQWYsRUFBb0I7VUFBRSxPQUFPcXJDLGlCQUFpQixDQUFDdm9DLElBQUQsRUFBT3o0QyxHQUFHLFlBQVkwZ0QsR0FBZixHQUFxQjFnRCxHQUFHLENBQUMyTyxFQUF6QixHQUE4QjNPLEdBQXJDLEVBQTBDMjFDLEdBQTFDLENBQXhCO1NBQS9COztRQUNBLElBQUkwckMsSUFBSjs7UUFDQSxJQUFJSSxvQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLENBQVU5eUUsRUFBVixFQUFjO1VBQ3ZDLElBQUksQ0FBQzBxQyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXZy9CLFlBQWhCLEVBQThCO1lBQUUsT0FBTztjQUFDbHNELEtBQUssRUFBRSxDQUFSO2NBQVd2RSxHQUFHLEVBQUU4MUMsSUFBSSxDQUFDdlEsSUFBTCxDQUFVcCtDO2FBQWpDOzs7VUFDaEN1M0YsSUFBSSxHQUFHQSxJQUFJLElBQUlydEIscUJBQXFCLENBQUMzYSxFQUFELEVBQUtaLElBQUwsQ0FBcEM7VUFDQSxPQUFPK2YscUJBQXFCLENBQUNuZixFQUFELEVBQUtaLElBQUwsRUFBVzRvQyxJQUFYLEVBQWlCMXlFLEVBQWpCLENBQTVCO1NBSEY7O1FBS0EsSUFBSTRwRCxpQkFBaUIsR0FBR2twQixvQkFBb0IsQ0FBQ3I2RSxLQUFLLENBQUNtRCxNQUFOLElBQWdCLFFBQWhCLEdBQTJCaTNFLEVBQUUsQ0FBQ3A2RSxLQUFELEVBQVEsQ0FBQyxDQUFULENBQTdCLEdBQTJDQSxLQUFLLENBQUN1SCxFQUFsRCxDQUE1Qzs7UUFFQSxJQUFJMHFDLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3RJLFNBQVAsSUFBb0IsS0FBcEIsSUFBNkIxaUIsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUEvQyxFQUFrRDtVQUNoRCxJQUFJaXJDLGtCQUFrQixHQUFJN3NELElBQUksQ0FBQzRoQixLQUFMLElBQWMsQ0FBZixJQUFzQlIsR0FBRyxHQUFHLENBQXJEO1VBQ0EsSUFBSWhuQyxFQUFFLEdBQUc2eUUsRUFBRSxDQUFDcDZFLEtBQUQsRUFBUWc2RSxrQkFBa0IsR0FBRyxDQUFILEdBQU8sQ0FBQyxDQUFsQyxDQUFYOztVQUNBLElBQUl6eUUsRUFBRSxJQUFJLElBQU4sS0FBZSxDQUFDeXlFLGtCQUFELEdBQXNCenlFLEVBQUUsSUFBSTRsQixJQUFJLENBQUN0dUIsSUFBWCxJQUFtQjBJLEVBQUUsSUFBSTRwRCxpQkFBaUIsQ0FBQ3J4RCxLQUFqRSxHQUF5RXlILEVBQUUsSUFBSTRsQixJQUFJLENBQUM5cUIsRUFBWCxJQUFpQmtGLEVBQUUsSUFBSTRwRCxpQkFBaUIsQ0FBQzUxRCxHQUFqSSxDQUFKLEVBQTJJOztZQUV6SSxJQUFJNEgsTUFBTSxHQUFHNjJFLGtCQUFrQixHQUFHLFFBQUgsR0FBYyxPQUE3QztZQUNBLE9BQU8sSUFBSTFnQyxHQUFKLENBQVF0NUMsS0FBSyxDQUFDcXhDLElBQWQsRUFBb0I5cEMsRUFBcEIsRUFBd0JwRSxNQUF4QixDQUFQOztTQWhDc0M7Ozs7UUF1QzFDLElBQUltM0Usa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFVNXBCLE9BQVYsRUFBbUJuaUIsR0FBbkIsRUFBd0I0aUIsaUJBQXhCLEVBQTJDO1VBQ2xFLElBQUlvcEIsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVWh6RSxFQUFWLEVBQWN5eUUsa0JBQWQsRUFBa0M7WUFBRSxPQUFPQSxrQkFBa0IsR0FDdEUsSUFBSTFnQyxHQUFKLENBQVF0NUMsS0FBSyxDQUFDcXhDLElBQWQsRUFBb0Irb0MsRUFBRSxDQUFDN3lFLEVBQUQsRUFBSyxDQUFMLENBQXRCLEVBQStCLFFBQS9CLENBRHNFLEdBRXRFLElBQUkreEMsR0FBSixDQUFRdDVDLEtBQUssQ0FBQ3F4QyxJQUFkLEVBQW9COXBDLEVBQXBCLEVBQXdCLE9BQXhCLENBRjZDO1dBQWpEOztVQUlBLE9BQU9tcEQsT0FBTyxJQUFJLENBQVgsSUFBZ0JBLE9BQU8sR0FBR3lwQixJQUFJLENBQUN6M0YsTUFBdEMsRUFBOENndUUsT0FBTyxJQUFJbmlCLEdBQXpELEVBQThEO1lBQzVELElBQUlwaEIsSUFBSSxHQUFHZ3RELElBQUksQ0FBQ3pwQixPQUFELENBQWY7WUFDQSxJQUFJc3BCLGtCQUFrQixHQUFJenJDLEdBQUcsR0FBRyxDQUFQLEtBQWNwaEIsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUE1QixDQUF6QjtZQUNBLElBQUl4bkMsRUFBRSxHQUFHeXlFLGtCQUFrQixHQUFHN29CLGlCQUFpQixDQUFDcnhELEtBQXJCLEdBQTZCczZFLEVBQUUsQ0FBQ2pwQixpQkFBaUIsQ0FBQzUxRCxHQUFuQixFQUF3QixDQUFDLENBQXpCLENBQTFEOztZQUNBLElBQUk0eEIsSUFBSSxDQUFDdHVCLElBQUwsSUFBYTBJLEVBQWIsSUFBbUJBLEVBQUUsR0FBRzRsQixJQUFJLENBQUM5cUIsRUFBakMsRUFBcUM7Y0FBRSxPQUFPazRFLE1BQU0sQ0FBQ2h6RSxFQUFELEVBQUt5eUUsa0JBQUwsQ0FBYjs7O1lBQ3ZDenlFLEVBQUUsR0FBR3l5RSxrQkFBa0IsR0FBRzdzRCxJQUFJLENBQUN0dUIsSUFBUixHQUFldTdFLEVBQUUsQ0FBQ2p0RCxJQUFJLENBQUM5cUIsRUFBTixFQUFVLENBQUMsQ0FBWCxDQUF4Qzs7WUFDQSxJQUFJOHVELGlCQUFpQixDQUFDcnhELEtBQWxCLElBQTJCeUgsRUFBM0IsSUFBaUNBLEVBQUUsR0FBRzRwRCxpQkFBaUIsQ0FBQzUxRCxHQUE1RCxFQUFpRTtjQUFFLE9BQU9nL0UsTUFBTSxDQUFDaHpFLEVBQUQsRUFBS3l5RSxrQkFBTCxDQUFiOzs7U0FYdkUsQ0F2QzBDOzs7UUF1RDFDLElBQUl0bUYsR0FBRyxHQUFHNG1GLGtCQUFrQixDQUFDNXBCLE9BQU8sR0FBR25pQixHQUFYLEVBQWdCQSxHQUFoQixFQUFxQjRpQixpQkFBckIsQ0FBNUI7O1FBQ0EsSUFBSXo5RCxHQUFKLEVBQVM7VUFBRSxPQUFPQSxHQUFQO1NBeEQrQjs7O1FBMkQxQyxJQUFJOG1GLE1BQU0sR0FBR2pzQyxHQUFHLEdBQUcsQ0FBTixHQUFVNGlCLGlCQUFpQixDQUFDNTFELEdBQTVCLEdBQWtDNitFLEVBQUUsQ0FBQ2pwQixpQkFBaUIsQ0FBQ3J4RCxLQUFuQixFQUEwQixDQUFDLENBQTNCLENBQWpEOztRQUNBLElBQUkwNkUsTUFBTSxJQUFJLElBQVYsSUFBa0IsRUFBRWpzQyxHQUFHLEdBQUcsQ0FBTixJQUFXaXNDLE1BQU0sSUFBSW5wQyxJQUFJLENBQUN2USxJQUFMLENBQVVwK0MsTUFBakMsQ0FBdEIsRUFBZ0U7VUFDOURnUixHQUFHLEdBQUc0bUYsa0JBQWtCLENBQUMvckMsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWM0ckMsSUFBSSxDQUFDejNGLE1BQUwsR0FBYyxDQUE3QixFQUFnQzZyRCxHQUFoQyxFQUFxQzhyQyxvQkFBb0IsQ0FBQ0csTUFBRCxDQUF6RCxDQUF4Qjs7VUFDQSxJQUFJOW1GLEdBQUosRUFBUztZQUFFLE9BQU9BLEdBQVA7O1NBOUQ2Qjs7O1FBa0UxQyxPQUFPLElBQVA7T0E1eU5pQjs7OztNQWl6Tm5CLElBQUkrbUYsUUFBUSxHQUFHO1FBQ2J4TixTQUFTLEVBQUVBLFNBREU7UUFFYnlOLGVBQWUsRUFBRSx5QkFBVXpvQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQnI1QixFQUFFLENBQUN5b0IsU0FBSCxDQUFhLFFBQWIsQ0FBaEIsRUFBd0N6b0IsRUFBRSxDQUFDeW9CLFNBQUgsQ0FBYSxNQUFiLENBQXhDLEVBQThEN3RCLGNBQTlELENBQVA7U0FGcEI7UUFHYjh0QyxRQUFRLEVBQUUsa0JBQVUxb0MsRUFBVixFQUFjO1VBQUUsT0FBT3NuQyxtQkFBbUIsQ0FBQ3RuQyxFQUFELEVBQUssVUFBVXBRLEtBQVYsRUFBaUI7WUFDeEUsSUFBSUEsS0FBSyxDQUFDdjBCLEtBQU4sRUFBSixFQUFtQjtjQUNqQixJQUFJcmQsR0FBRyxHQUFHaW9ELE9BQU8sQ0FBQ2pHLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3RXLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBcEIsQ0FBUCxDQUFpQ3ZRLElBQWpDLENBQXNDcCtDLE1BQWhEOztjQUNBLElBQUltL0MsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVy9ELEVBQVgsSUFBaUJ0WCxHQUFqQixJQUF3QjR4QyxLQUFLLENBQUN2MkIsSUFBTixDQUFXK2xDLElBQVgsR0FBa0JZLEVBQUUsQ0FBQ2lRLFFBQUgsRUFBOUMsRUFDRTtnQkFBRSxPQUFPO2tCQUFDcmpELElBQUksRUFBRWdqQyxLQUFLLENBQUN2MkIsSUFBYjtrQkFBbUJqSixFQUFFLEVBQUVpM0MsR0FBRyxDQUFDelgsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFYLEdBQWtCLENBQW5CLEVBQXNCLENBQXRCO2lCQUFqQztlQURKLE1BR0U7Z0JBQUUsT0FBTztrQkFBQ3h5QyxJQUFJLEVBQUVnakMsS0FBSyxDQUFDdjJCLElBQWI7a0JBQW1CakosRUFBRSxFQUFFaTNDLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBWixFQUFrQnBoRCxHQUFsQjtpQkFBakM7O2FBTE4sTUFNTztjQUNMLE9BQU87Z0JBQUM0TyxJQUFJLEVBQUVnakMsS0FBSyxDQUFDaGpDLElBQU4sRUFBUDtnQkFBcUJ3RCxFQUFFLEVBQUV3L0IsS0FBSyxDQUFDeC9CLEVBQU47ZUFBaEM7O1dBUmdELENBQTFCO1NBSGI7UUFjYnU0RSxVQUFVLEVBQUUsb0JBQVUzb0MsRUFBVixFQUFjO1VBQUUsT0FBT3NuQyxtQkFBbUIsQ0FBQ3RuQyxFQUFELEVBQUssVUFBVXBRLEtBQVYsRUFBaUI7WUFBRSxPQUFRO2NBQ3BGaGpDLElBQUksRUFBRXk2QyxHQUFHLENBQUN6WCxLQUFLLENBQUNoakMsSUFBTixHQUFhd3lDLElBQWQsRUFBb0IsQ0FBcEIsQ0FEMkU7Y0FFcEZodkMsRUFBRSxFQUFFdzNDLFFBQU8sQ0FBQzVILEVBQUUsQ0FBQ2tHLEdBQUosRUFBU21CLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ3gvQixFQUFOLEdBQVdndkMsSUFBWCxHQUFrQixDQUFuQixFQUFzQixDQUF0QixDQUFaO2FBRmlFO1dBQXhCLENBQTFCO1NBZGY7UUFrQmJ3cEMsV0FBVyxFQUFFLHFCQUFVNW9DLEVBQVYsRUFBYztVQUFFLE9BQU9zbkMsbUJBQW1CLENBQUN0bkMsRUFBRCxFQUFLLFVBQVVwUSxLQUFWLEVBQWlCO1lBQUUsT0FBUTtjQUNyRmhqQyxJQUFJLEVBQUV5NkMsR0FBRyxDQUFDelgsS0FBSyxDQUFDaGpDLElBQU4sR0FBYXd5QyxJQUFkLEVBQW9CLENBQXBCLENBRDRFO2NBQ3BEaHZDLEVBQUUsRUFBRXcvQixLQUFLLENBQUNoakMsSUFBTjthQUR3QztXQUF4QixDQUExQjtTQWxCaEI7UUFxQmJpOEUsa0JBQWtCLEVBQUUsNEJBQVU3b0MsRUFBVixFQUFjO1VBQUUsT0FBT3NuQyxtQkFBbUIsQ0FBQ3RuQyxFQUFELEVBQUssVUFBVXBRLEtBQVYsRUFBaUI7WUFDbEYsSUFBSXJDLEdBQUcsR0FBR3lTLEVBQUUsQ0FBQ3FlLFVBQUgsQ0FBY3p1QixLQUFLLENBQUN2MkIsSUFBcEIsRUFBMEIsS0FBMUIsRUFBaUNrMEIsR0FBakMsR0FBdUMsQ0FBakQ7WUFDQSxJQUFJdTdDLE9BQU8sR0FBRzlvQyxFQUFFLENBQUMrZSxVQUFILENBQWM7Y0FBQ3B2QyxJQUFJLEVBQUUsQ0FBUDtjQUFVNGQsR0FBRyxFQUFFQTthQUE3QixFQUFtQyxLQUFuQyxDQUFkO1lBQ0EsT0FBTztjQUFDM2dDLElBQUksRUFBRWs4RSxPQUFQO2NBQWdCMTRFLEVBQUUsRUFBRXcvQixLQUFLLENBQUNoakMsSUFBTjthQUEzQjtXQUg0RCxDQUExQjtTQXJCdkI7UUEwQmJtOEUsbUJBQW1CLEVBQUUsNkJBQVUvb0MsRUFBVixFQUFjO1VBQUUsT0FBT3NuQyxtQkFBbUIsQ0FBQ3RuQyxFQUFELEVBQUssVUFBVXBRLEtBQVYsRUFBaUI7WUFDbkYsSUFBSXJDLEdBQUcsR0FBR3lTLEVBQUUsQ0FBQ3FlLFVBQUgsQ0FBY3p1QixLQUFLLENBQUN2MkIsSUFBcEIsRUFBMEIsS0FBMUIsRUFBaUNrMEIsR0FBakMsR0FBdUMsQ0FBakQ7WUFDQSxJQUFJeTdDLFFBQVEsR0FBR2hwQyxFQUFFLENBQUMrZSxVQUFILENBQWM7Y0FBQ3B2QyxJQUFJLEVBQUVxd0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2l2RSxPQUFYLENBQW1CeGtCLFdBQW5CLEdBQWlDLEdBQXhDO2NBQTZDblUsR0FBRyxFQUFFQTthQUFoRSxFQUFzRSxLQUF0RSxDQUFmO1lBQ0EsT0FBTztjQUFDM2dDLElBQUksRUFBRWdqQyxLQUFLLENBQUNoakMsSUFBTixFQUFQO2NBQXFCd0QsRUFBRSxFQUFFNDRFO2FBQWhDO1dBSDZELENBQTFCO1NBMUJ4QjtRQStCYmpJLElBQUksRUFBRSxjQUFVL2dDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQytnQyxJQUFILEVBQVA7U0EvQlQ7UUFnQ2JDLElBQUksRUFBRSxjQUFVaGhDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2doQyxJQUFILEVBQVA7U0FoQ1Q7UUFpQ2JDLGFBQWEsRUFBRSx1QkFBVWpoQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUNpaEMsYUFBSCxFQUFQO1NBakNsQjtRQWtDYkMsYUFBYSxFQUFFLHVCQUFVbGhDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2toQyxhQUFILEVBQVA7U0FsQ2xCO1FBbUNiK0gsVUFBVSxFQUFFLG9CQUFVanBDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ281QixlQUFILENBQW1CL3hCLEdBQUcsQ0FBQ3JILEVBQUUsQ0FBQ3kxQixTQUFILEVBQUQsRUFBaUIsQ0FBakIsQ0FBdEIsQ0FBUDtTQW5DZjtRQW9DYnlULFFBQVEsRUFBRSxrQkFBVWxwQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUNvNUIsZUFBSCxDQUFtQi94QixHQUFHLENBQUNySCxFQUFFLENBQUNpUSxRQUFILEVBQUQsQ0FBdEIsQ0FBUDtTQXBDYjtRQXFDYms1QixXQUFXLEVBQUUscUJBQVVucEMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDd2dDLGtCQUFILENBQXNCLFVBQVU1d0MsS0FBVixFQUFpQjtZQUFFLE9BQU8rVSxTQUFTLENBQUMzRSxFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBTixDQUFXK2xDLElBQWhCLENBQWhCO1dBQXpDLEVBQ2xDO1lBQUNyRSxNQUFNLEVBQUUsT0FBVDtZQUFrQjBmLElBQUksRUFBRTtXQURVLENBQVA7U0FyQ2hCO1FBd0NiMnVCLGdCQUFnQixFQUFFLDBCQUFVcHBDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ3dnQyxrQkFBSCxDQUFzQixVQUFVNXdDLEtBQVYsRUFBaUI7WUFBRSxPQUFPeTVDLGNBQWMsQ0FBQ3JwQyxFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBWCxDQUFyQjtXQUF6QyxFQUN2QztZQUFDMGhDLE1BQU0sRUFBRSxPQUFUO1lBQWtCMGYsSUFBSSxFQUFFO1dBRGUsQ0FBUDtTQXhDckI7UUEyQ2I2dUIsU0FBUyxFQUFFLG1CQUFVdHBDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ3dnQyxrQkFBSCxDQUFzQixVQUFVNXdDLEtBQVYsRUFBaUI7WUFBRSxPQUFPMjVDLE9BQU8sQ0FBQ3ZwQyxFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBTixDQUFXK2xDLElBQWhCLENBQWQ7V0FBekMsRUFDaEM7WUFBQ3JFLE1BQU0sRUFBRSxPQUFUO1lBQWtCMGYsSUFBSSxFQUFFLENBQUM7V0FETyxDQUFQO1NBM0NkO1FBOENiK3VCLFdBQVcsRUFBRSxxQkFBVXhwQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUN3Z0Msa0JBQUgsQ0FBc0IsVUFBVTV3QyxLQUFWLEVBQWlCO1lBQ3pFLElBQUlyQyxHQUFHLEdBQUd5UyxFQUFFLENBQUNzZSxZQUFILENBQWdCMXVCLEtBQUssQ0FBQ3YyQixJQUF0QixFQUE0QixLQUE1QixFQUFtQ2swQixHQUFuQyxHQUF5QyxDQUFuRDtZQUNBLE9BQU95UyxFQUFFLENBQUMrZSxVQUFILENBQWM7Y0FBQ3B2QyxJQUFJLEVBQUVxd0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2l2RSxPQUFYLENBQW1CeGtCLFdBQW5CLEdBQWlDLEdBQXhDO2NBQTZDblUsR0FBRyxFQUFFQTthQUFoRSxFQUFzRSxLQUF0RSxDQUFQO1dBRmtDLEVBR2pDeU4sUUFIaUMsQ0FBUDtTQTlDaEI7UUFrRGJ5dUMsVUFBVSxFQUFFLG9CQUFVenBDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ3dnQyxrQkFBSCxDQUFzQixVQUFVNXdDLEtBQVYsRUFBaUI7WUFDeEUsSUFBSXJDLEdBQUcsR0FBR3lTLEVBQUUsQ0FBQ3NlLFlBQUgsQ0FBZ0IxdUIsS0FBSyxDQUFDdjJCLElBQXRCLEVBQTRCLEtBQTVCLEVBQW1DazBCLEdBQW5DLEdBQXlDLENBQW5EO1lBQ0EsT0FBT3lTLEVBQUUsQ0FBQytlLFVBQUgsQ0FBYztjQUFDcHZDLElBQUksRUFBRSxDQUFQO2NBQVU0ZCxHQUFHLEVBQUVBO2FBQTdCLEVBQW1DLEtBQW5DLENBQVA7V0FGaUMsRUFHaEN5TixRQUhnQyxDQUFQO1NBbERmO1FBc0RiMHVDLGVBQWUsRUFBRSx5QkFBVTFwQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUN3Z0Msa0JBQUgsQ0FBc0IsVUFBVTV3QyxLQUFWLEVBQWlCO1lBQzdFLElBQUlyQyxHQUFHLEdBQUd5UyxFQUFFLENBQUNzZSxZQUFILENBQWdCMXVCLEtBQUssQ0FBQ3YyQixJQUF0QixFQUE0QixLQUE1QixFQUFtQ2swQixHQUFuQyxHQUF5QyxDQUFuRDtZQUNBLElBQUk1bUMsR0FBRyxHQUFHcTVDLEVBQUUsQ0FBQytlLFVBQUgsQ0FBYztjQUFDcHZDLElBQUksRUFBRSxDQUFQO2NBQVU0ZCxHQUFHLEVBQUVBO2FBQTdCLEVBQW1DLEtBQW5DLENBQVY7O1lBQ0EsSUFBSTVtQyxHQUFHLENBQUMyTyxFQUFKLEdBQVMwcUMsRUFBRSxDQUFDaUcsT0FBSCxDQUFXdC9DLEdBQUcsQ0FBQ3k0QyxJQUFmLEVBQXFCNzFDLE1BQXJCLENBQTRCLElBQTVCLENBQWIsRUFBZ0Q7Y0FBRSxPQUFPOC9FLGNBQWMsQ0FBQ3JwQyxFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBWCxDQUFyQjs7O1lBQ2xELE9BQU8xUyxHQUFQO1dBSnNDLEVBS3JDcTBDLFFBTHFDLENBQVA7U0F0RHBCO1FBNERiMnVDLFFBQVEsRUFBRSxrQkFBVTNwQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUM0cEMsS0FBSCxDQUFTLENBQUMsQ0FBVixFQUFhLE1BQWIsQ0FBUDtTQTVEYjtRQTZEYkMsVUFBVSxFQUFFLG9CQUFVN3BDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQzRwQyxLQUFILENBQVMsQ0FBVCxFQUFZLE1BQVosQ0FBUDtTQTdEZjtRQThEYkUsUUFBUSxFQUFFLGtCQUFVOXBDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQzRwQyxLQUFILENBQVMsQ0FBQyxDQUFWLEVBQWEsTUFBYixDQUFQO1NBOURiO1FBK0RiRyxVQUFVLEVBQUUsb0JBQVUvcEMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDNHBDLEtBQUgsQ0FBUyxDQUFULEVBQVksTUFBWixDQUFQO1NBL0RmO1FBZ0ViSSxVQUFVLEVBQUUsb0JBQVVocUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDaXFDLEtBQUgsQ0FBUyxDQUFDLENBQVYsRUFBYSxNQUFiLENBQVA7U0FoRWY7UUFpRWJDLFdBQVcsRUFBRSxxQkFBVWxxQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUNpcUMsS0FBSCxDQUFTLENBQVQsRUFBWSxNQUFaLENBQVA7U0FqRWhCO1FBa0ViRSxZQUFZLEVBQUUsc0JBQVVucUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDaXFDLEtBQUgsQ0FBUyxDQUFDLENBQVYsRUFBYSxRQUFiLENBQVA7U0FsRWpCO1FBbUViRyxhQUFhLEVBQUUsdUJBQVVwcUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDaXFDLEtBQUgsQ0FBUyxDQUFULEVBQVksUUFBWixDQUFQO1NBbkVsQjtRQW9FYkksVUFBVSxFQUFFLG9CQUFVcnFDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2lxQyxLQUFILENBQVMsQ0FBQyxDQUFWLEVBQWEsTUFBYixDQUFQO1NBcEVmO1FBcUViSyxZQUFZLEVBQUUsc0JBQVV0cUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDaXFDLEtBQUgsQ0FBUyxDQUFULEVBQVksT0FBWixDQUFQO1NBckVqQjtRQXNFYk0sV0FBVyxFQUFFLHFCQUFVdnFDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2lxQyxLQUFILENBQVMsQ0FBQyxDQUFWLEVBQWEsT0FBYixDQUFQO1NBdEVoQjtRQXVFYk8sV0FBVyxFQUFFLHFCQUFVeHFDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2lxQyxLQUFILENBQVMsQ0FBVCxFQUFZLE1BQVosQ0FBUDtTQXZFaEI7UUF3RWJRLGFBQWEsRUFBRSx1QkFBVXpxQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUMwcUMsT0FBSCxDQUFXLENBQUMsQ0FBWixFQUFlLFdBQWYsQ0FBUDtTQXhFbEI7UUF5RWJDLFlBQVksRUFBRSxzQkFBVTNxQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUMwcUMsT0FBSCxDQUFXLENBQVgsRUFBYyxNQUFkLENBQVA7U0F6RWpCO1FBMEViRSxhQUFhLEVBQUUsdUJBQVU1cUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDMHFDLE9BQUgsQ0FBVyxDQUFDLENBQVosRUFBZSxNQUFmLENBQVA7U0ExRWxCO1FBMkViRyxZQUFZLEVBQUUsc0JBQVU3cUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDMHFDLE9BQUgsQ0FBVyxDQUFYLEVBQWMsTUFBZCxDQUFQO1NBM0VqQjtRQTRFYkksY0FBYyxFQUFFLHdCQUFVOXFDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQzBxQyxPQUFILENBQVcsQ0FBQyxDQUFaLEVBQWUsT0FBZixDQUFQO1NBNUVuQjtRQTZFYkssYUFBYSxFQUFFLHVCQUFVL3FDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQzBxQyxPQUFILENBQVcsQ0FBWCxFQUFjLE9BQWQsQ0FBUDtTQTdFbEI7UUE4RWJNLFVBQVUsRUFBRSxvQkFBVWhyQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUNpckMsZUFBSCxDQUFtQixPQUFuQixDQUFQO1NBOUVmO1FBK0ViQyxVQUFVLEVBQUUsb0JBQVVsckMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDaXJDLGVBQUgsQ0FBbUIsS0FBbkIsQ0FBUDtTQS9FZjtRQWdGYkUsVUFBVSxFQUFFLG9CQUFVbnJDLEVBQVYsRUFBYztVQUFFLE9BQU9BLEVBQUUsQ0FBQ2lyQyxlQUFILENBQW1CLFVBQW5CLENBQVA7U0FoRmY7UUFpRmJHLFNBQVMsRUFBRSxtQkFBVXByQyxFQUFWLEVBQWM7VUFBRSxPQUFPQSxFQUFFLENBQUM0Z0MsZ0JBQUgsQ0FBb0IsSUFBcEIsQ0FBUDtTQWpGZDtRQWtGYnlLLGFBQWEsRUFBRSx1QkFBVXJyQyxFQUFWLEVBQWM7VUFDM0IsSUFBSW5oRCxNQUFNLEdBQUcsRUFBYjtjQUFpQjZqRSxNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBMUI7Y0FBK0NybUMsT0FBTyxHQUFHK0YsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2tmLE9BQXBFOztVQUNBLEtBQUssSUFBSXBuRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7WUFDdEMsSUFBSThULEdBQUcsR0FBRys3RCxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVUrWixJQUFWLEVBQVY7WUFDQSxJQUFJdXVDLEdBQUcsR0FBR25CLFdBQVcsQ0FBQ2dHLEVBQUUsQ0FBQ2lHLE9BQUgsQ0FBV3QvQyxHQUFHLENBQUN5NEMsSUFBZixDQUFELEVBQXVCejRDLEdBQUcsQ0FBQzJPLEVBQTNCLEVBQStCMmtDLE9BQS9CLENBQXJCO1lBQ0FwN0MsTUFBTSxDQUFDclAsSUFBUCxDQUFZOHJELFFBQVEsQ0FBQ3JCLE9BQU8sR0FBR2tCLEdBQUcsR0FBR2xCLE9BQWpCLENBQXBCOzs7VUFFRitGLEVBQUUsQ0FBQzhnQyxpQkFBSCxDQUFxQmppRixNQUFyQjtTQXpGVztRQTJGYnlzRixVQUFVLEVBQUUsb0JBQVV0ckMsRUFBVixFQUFjO1VBQ3hCLElBQUlBLEVBQUUsQ0FBQ20wQixpQkFBSCxFQUFKLEVBQTRCO1lBQUVuMEIsRUFBRSxDQUFDaXJDLGVBQUgsQ0FBbUIsS0FBbkI7V0FBOUIsTUFDSztZQUFFanJDLEVBQUUsQ0FBQ3VyQyxXQUFILENBQWUsV0FBZjs7U0E3Rkk7Ozs7Ozs7O1FBc0diQyxjQUFjLEVBQUUsd0JBQVV4ckMsRUFBVixFQUFjO1VBQUUsT0FBT3F1QixPQUFPLENBQUNydUIsRUFBRCxFQUFLLFlBQVk7WUFDN0QsSUFBSTBpQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtnQkFBa0M5RyxNQUFNLEdBQUcsRUFBM0M7O1lBQ0EsS0FBSyxJQUFJM21GLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQTNCLEVBQW1Db0MsQ0FBQyxFQUFwQyxFQUF3QztjQUN0QyxJQUFJLENBQUM2dkUsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVd29CLEtBQVYsRUFBTCxFQUF3QjtnQkFBRTs7O2NBQzFCLElBQUk0aEMsR0FBRyxHQUFHeWxCLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVXdtQixJQUFwQjtrQkFBMEIrbEMsSUFBSSxHQUFHNkcsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTakosR0FBRyxDQUFDbUMsSUFBYixDQUFQLENBQTBCdlEsSUFBM0Q7O2NBQ0EsSUFBSXVRLElBQUosRUFBVTtnQkFDUixJQUFJbkMsR0FBRyxDQUFDM25DLEVBQUosSUFBVThwQyxJQUFJLENBQUMzdUQsTUFBbkIsRUFBMkI7a0JBQUV3c0QsR0FBRyxHQUFHLElBQUlvSyxHQUFKLENBQVFwSyxHQUFHLENBQUNtQyxJQUFaLEVBQWtCbkMsR0FBRyxDQUFDM25DLEVBQUosR0FBUyxDQUEzQixDQUFOOzs7Z0JBQzdCLElBQUkybkMsR0FBRyxDQUFDM25DLEVBQUosR0FBUyxDQUFiLEVBQWdCO2tCQUNkMm5DLEdBQUcsR0FBRyxJQUFJb0ssR0FBSixDQUFRcEssR0FBRyxDQUFDbUMsSUFBWixFQUFrQm5DLEdBQUcsQ0FBQzNuQyxFQUFKLEdBQVMsQ0FBM0IsQ0FBTjtrQkFDQTBxQyxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQnA5QixJQUFJLENBQUNwckQsTUFBTCxDQUFZaXBELEdBQUcsQ0FBQzNuQyxFQUFKLEdBQVMsQ0FBckIsSUFBMEI4cEMsSUFBSSxDQUFDcHJELE1BQUwsQ0FBWWlwRCxHQUFHLENBQUMzbkMsRUFBSixHQUFTLENBQXJCLENBQTFDLEVBQ2dCK3hDLEdBQUcsQ0FBQ3BLLEdBQUcsQ0FBQ21DLElBQUwsRUFBV25DLEdBQUcsQ0FBQzNuQyxFQUFKLEdBQVMsQ0FBcEIsQ0FEbkIsRUFDMkMybkMsR0FEM0MsRUFDZ0QsWUFEaEQ7aUJBRkYsTUFJTyxJQUFJQSxHQUFHLENBQUNtQyxJQUFKLEdBQVdZLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3ZsRCxLQUF0QixFQUE2QjtrQkFDbEMsSUFBSXdlLElBQUksR0FBRzhtQyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVNqSixHQUFHLENBQUNtQyxJQUFKLEdBQVcsQ0FBcEIsQ0FBUCxDQUE4QnZRLElBQXpDOztrQkFDQSxJQUFJMXZCLElBQUosRUFBVTtvQkFDUjg5QixHQUFHLEdBQUcsSUFBSW9LLEdBQUosQ0FBUXBLLEdBQUcsQ0FBQ21DLElBQVosRUFBa0IsQ0FBbEIsQ0FBTjtvQkFDQVksRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0JwOUIsSUFBSSxDQUFDcHJELE1BQUwsQ0FBWSxDQUFaLElBQWlCZ3NELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzY1QixhQUFQLEVBQWpCLEdBQ0E1Z0UsSUFBSSxDQUFDbnJCLE1BQUwsQ0FBWW1yQixJQUFJLENBQUMxdUIsTUFBTCxHQUFjLENBQTFCLENBRGhCLEVBRWdCNDJELEdBQUcsQ0FBQ3BLLEdBQUcsQ0FBQ21DLElBQUosR0FBVyxDQUFaLEVBQWVqZ0MsSUFBSSxDQUFDMXVCLE1BQUwsR0FBYyxDQUE3QixDQUZuQixFQUVvRHdzRCxHQUZwRCxFQUV5RCxZQUZ6RDs7Ozs7Y0FNTnU4QixNQUFNLENBQUNocUYsSUFBUCxDQUFZLElBQUkwa0YsS0FBSixDQUFVajNCLEdBQVYsRUFBZUEsR0FBZixDQUFaOzs7WUFFRitDLEVBQUUsQ0FBQ3lnQyxhQUFILENBQWlCakgsTUFBakI7V0F2QjRDLENBQWQ7U0F0R25CO1FBK0hiaVMsZ0JBQWdCLEVBQUUsMEJBQVV6ckMsRUFBVixFQUFjO1VBQUUsT0FBT3F1QixPQUFPLENBQUNydUIsRUFBRCxFQUFLLFlBQVk7WUFDL0QsSUFBSTByQyxJQUFJLEdBQUcxckMsRUFBRSxDQUFDc2dDLGNBQUgsRUFBWDs7WUFDQSxLQUFLLElBQUl6dEYsQ0FBQyxHQUFHNjRGLElBQUksQ0FBQ2o3RixNQUFMLEdBQWMsQ0FBM0IsRUFBOEJvQyxDQUFDLElBQUksQ0FBbkMsRUFBc0NBLENBQUMsRUFBdkMsRUFDRTtjQUFFbXRELEVBQUUsQ0FBQ3c4QixZQUFILENBQWdCeDhCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzY1QixhQUFQLEVBQWhCLEVBQXdDMkwsSUFBSSxDQUFDNzRGLENBQUQsQ0FBSixDQUFRc1gsTUFBaEQsRUFBd0R1aEYsSUFBSSxDQUFDNzRGLENBQUQsQ0FBSixDQUFRd21CLElBQWhFLEVBQXNFLFFBQXRFOzs7WUFDSnF5RSxJQUFJLEdBQUcxckMsRUFBRSxDQUFDc2dDLGNBQUgsRUFBUDs7WUFDQSxLQUFLLElBQUl2aUMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzJ0QyxJQUFJLENBQUNqN0YsTUFBN0IsRUFBcUNzdEQsR0FBRyxFQUF4QyxFQUNFO2NBQUVpQyxFQUFFLENBQUMyckMsVUFBSCxDQUFjRCxJQUFJLENBQUMzdEMsR0FBRCxDQUFKLENBQVVueEMsSUFBVixHQUFpQnd5QyxJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQzs7O1lBQ0pvcEIsbUJBQW1CLENBQUN4b0IsRUFBRCxDQUFuQjtXQVA4QyxDQUFkO1NBL0hyQjtRQXdJYjRyQyxRQUFRLEVBQUUsa0JBQVU1ckMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDNGdDLGdCQUFILENBQW9CLElBQXBCLEVBQTBCLE9BQTFCLENBQVA7U0F4SWI7UUF5SWJpTCxlQUFlLEVBQUUseUJBQVU3ckMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDNnJDLGVBQUgsRUFBUDs7T0F6SW5DOztNQTZJQSxTQUFTbG5DLFNBQVQsQ0FBbUIzRSxFQUFuQixFQUF1QjhQLEtBQXZCLEVBQThCO1FBQzVCLElBQUkxUSxJQUFJLEdBQUc2RyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVM0SixLQUFULENBQWxCO1FBQ0EsSUFBSXd1QixNQUFNLEdBQUc3dUIsVUFBVSxDQUFDclEsSUFBRCxDQUF2Qjs7UUFDQSxJQUFJay9CLE1BQU0sSUFBSWwvQixJQUFkLEVBQW9CO1VBQUUwUSxLQUFLLEdBQUdsSixNQUFNLENBQUMwM0IsTUFBRCxDQUFkOzs7UUFDdEIsT0FBT3VKLFNBQVMsQ0FBQyxJQUFELEVBQU83bkMsRUFBUCxFQUFXcytCLE1BQVgsRUFBbUJ4dUIsS0FBbkIsRUFBMEIsQ0FBMUIsQ0FBaEI7OztNQUVGLFNBQVN5NUIsT0FBVCxDQUFpQnZwQyxFQUFqQixFQUFxQjhQLEtBQXJCLEVBQTRCO1FBQzFCLElBQUkxUSxJQUFJLEdBQUc2RyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVM0SixLQUFULENBQWxCO1FBQ0EsSUFBSXd1QixNQUFNLEdBQUczdUIsYUFBYSxDQUFDdlEsSUFBRCxDQUExQjs7UUFDQSxJQUFJay9CLE1BQU0sSUFBSWwvQixJQUFkLEVBQW9CO1VBQUUwUSxLQUFLLEdBQUdsSixNQUFNLENBQUMwM0IsTUFBRCxDQUFkOzs7UUFDdEIsT0FBT3VKLFNBQVMsQ0FBQyxJQUFELEVBQU83bkMsRUFBUCxFQUFXWixJQUFYLEVBQWlCMFEsS0FBakIsRUFBd0IsQ0FBQyxDQUF6QixDQUFoQjs7O01BRUYsU0FBU3U1QixjQUFULENBQXdCcnBDLEVBQXhCLEVBQTRCcjVDLEdBQTVCLEVBQWlDO1FBQy9CLElBQUlvSCxLQUFLLEdBQUc0MkMsU0FBUyxDQUFDM0UsRUFBRCxFQUFLcjVDLEdBQUcsQ0FBQ3k0QyxJQUFULENBQXJCO1FBQ0EsSUFBSUEsSUFBSSxHQUFHNkcsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTbjRDLEtBQUssQ0FBQ3F4QyxJQUFmLENBQWxCO1FBQ0EsSUFBSXhDLEtBQUssR0FBR3VDLFFBQVEsQ0FBQ0MsSUFBRCxFQUFPWSxFQUFFLENBQUNrRyxHQUFILENBQU90SSxTQUFkLENBQXBCOztRQUNBLElBQUksQ0FBQ2hCLEtBQUQsSUFBVUEsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTRSxLQUFULElBQWtCLENBQWhDLEVBQW1DO1VBQ2pDLElBQUlndkMsVUFBVSxHQUFHMS9GLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU21aLEtBQUssQ0FBQ3VILEVBQWYsRUFBbUI4cEMsSUFBSSxDQUFDdlEsSUFBTCxDQUFVdGxDLE1BQVYsQ0FBaUIsSUFBakIsQ0FBbkIsQ0FBakI7VUFDQSxJQUFJd2lGLElBQUksR0FBR3BsRixHQUFHLENBQUN5NEMsSUFBSixJQUFZcnhDLEtBQUssQ0FBQ3F4QyxJQUFsQixJQUEwQno0QyxHQUFHLENBQUMyTyxFQUFKLElBQVV3MkUsVUFBcEMsSUFBa0RubEYsR0FBRyxDQUFDMk8sRUFBakU7VUFDQSxPQUFPK3hDLEdBQUcsQ0FBQ3Q1QyxLQUFLLENBQUNxeEMsSUFBUCxFQUFhMnNDLElBQUksR0FBRyxDQUFILEdBQU9ELFVBQXhCLEVBQW9DLzlFLEtBQUssQ0FBQ21ELE1BQTFDLENBQVY7OztRQUVGLE9BQU9uRCxLQUFQO09BbjlOaUI7OztNQXU5Tm5CLFNBQVNpK0UsZUFBVCxDQUF5QmhzQyxFQUF6QixFQUE2QjVoRCxLQUE3QixFQUFvQzZ0RixTQUFwQyxFQUErQztRQUM3QyxJQUFJLE9BQU83dEYsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtVQUM1QkEsS0FBSyxHQUFHb3FGLFFBQVEsQ0FBQ3BxRixLQUFELENBQWhCOztVQUNBLElBQUksQ0FBQ0EsS0FBTCxFQUFZO1lBQUUsT0FBTyxLQUFQOztTQUg2Qjs7OztRQU83QzRoRCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUIwNEIsWUFBakI7UUFDQSxJQUFJQyxTQUFTLEdBQUduc0MsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzh1RSxLQUEzQjtZQUFrQ3A5RCxJQUFJLEdBQUcsS0FBekM7O1FBQ0EsSUFBSTtVQUNGLElBQUlxM0MsRUFBRSxDQUFDMmpDLFVBQUgsRUFBSixFQUFxQjtZQUFFM2pDLEVBQUUsQ0FBQzlwQixLQUFILENBQVNvbEQsYUFBVCxHQUF5QixJQUF6Qjs7O1VBQ3ZCLElBQUkyUSxTQUFKLEVBQWU7WUFBRWpzQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXOHVFLEtBQVgsR0FBbUIsS0FBbkI7OztVQUNqQnA5RCxJQUFJLEdBQUd2SyxLQUFLLENBQUM0aEQsRUFBRCxDQUFMLElBQWFyRixJQUFwQjtTQUhGLFNBSVU7VUFDUnFGLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc4dUUsS0FBWCxHQUFtQm9tQixTQUFuQjtVQUNBbnNDLEVBQUUsQ0FBQzlwQixLQUFILENBQVNvbEQsYUFBVCxHQUF5QixLQUF6Qjs7O1FBRUYsT0FBTzN5RSxJQUFQOzs7TUFHRixTQUFTeWpGLGtCQUFULENBQTRCcHNDLEVBQTVCLEVBQWdDOXVELElBQWhDLEVBQXNDK21DLE1BQXRDLEVBQThDO1FBQzVDLEtBQUssSUFBSXBsQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVNtMkQsT0FBVCxDQUFpQjU3RixNQUFyQyxFQUE2Q29DLENBQUMsRUFBOUMsRUFBa0Q7VUFDaEQsSUFBSTRDLE1BQU0sR0FBR2l4RixTQUFTLENBQUN4MUYsSUFBRCxFQUFPOHVELEVBQUUsQ0FBQzlwQixLQUFILENBQVNtMkQsT0FBVCxDQUFpQng1RixDQUFqQixDQUFQLEVBQTRCb2xDLE1BQTVCLEVBQW9DK25CLEVBQXBDLENBQXRCOztVQUNBLElBQUl2cUQsTUFBSixFQUFZO1lBQUUsT0FBT0EsTUFBUDs7OztRQUVoQixPQUFRdXFELEVBQUUsQ0FBQ2psQixPQUFILENBQVd1eEQsU0FBWCxJQUF3QjVGLFNBQVMsQ0FBQ3gxRixJQUFELEVBQU84dUQsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV3V4RCxTQUFsQixFQUE2QnIwRCxNQUE3QixFQUFxQytuQixFQUFyQyxDQUFsQyxJQUNGMG1DLFNBQVMsQ0FBQ3gxRixJQUFELEVBQU84dUQsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzhxRCxNQUFsQixFQUEwQjV0RCxNQUExQixFQUFrQytuQixFQUFsQyxDQURkO09BaC9OaUI7Ozs7TUF1L05uQixJQUFJdXNDLE9BQU8sR0FBRyxJQUFJbHlDLE9BQUosRUFBZDs7TUFFQSxTQUFTbXlDLFdBQVQsQ0FBcUJ4c0MsRUFBckIsRUFBeUI5dUQsSUFBekIsRUFBK0JyRSxDQUEvQixFQUFrQ29yQyxNQUFsQyxFQUEwQztRQUN4QyxJQUFJdzBELEdBQUcsR0FBR3pzQyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTdzJELE1BQW5COztRQUNBLElBQUlELEdBQUosRUFBUztVQUNQLElBQUk1RixhQUFhLENBQUMzMUYsSUFBRCxDQUFqQixFQUF5QjtZQUFFLE9BQU8sU0FBUDs7O1VBQzNCLElBQUksTUFBTW1NLElBQU4sQ0FBV25NLElBQVgsQ0FBSixFQUNFO1lBQUU4dUQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3cyRCxNQUFULEdBQWtCLElBQWxCO1dBREosTUFHRTtZQUFFSCxPQUFPLENBQUM3eEYsR0FBUixDQUFZLEVBQVosRUFBZ0IsWUFBWTtjQUM1QixJQUFJc2xELEVBQUUsQ0FBQzlwQixLQUFILENBQVN3MkQsTUFBVCxJQUFtQkQsR0FBdkIsRUFBNEI7Z0JBQzFCenNDLEVBQUUsQ0FBQzlwQixLQUFILENBQVN3MkQsTUFBVCxHQUFrQixJQUFsQjtnQkFDQTFzQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUJoOEIsS0FBakI7O2FBSEY7OztVQU1KLElBQUltMUQsZ0JBQWdCLENBQUMzc0MsRUFBRCxFQUFLeXNDLEdBQUcsR0FBRyxHQUFOLEdBQVl2N0YsSUFBakIsRUFBdUJyRSxDQUF2QixFQUEwQm9yQyxNQUExQixDQUFwQixFQUF1RDtZQUFFLE9BQU8sSUFBUDs7OztRQUUzRCxPQUFPMDBELGdCQUFnQixDQUFDM3NDLEVBQUQsRUFBSzl1RCxJQUFMLEVBQVdyRSxDQUFYLEVBQWNvckMsTUFBZCxDQUF2Qjs7O01BR0YsU0FBUzAwRCxnQkFBVCxDQUEwQjNzQyxFQUExQixFQUE4Qjl1RCxJQUE5QixFQUFvQ3JFLENBQXBDLEVBQXVDb3JDLE1BQXZDLEVBQStDO1FBQzdDLElBQUl4aUMsTUFBTSxHQUFHMjJGLGtCQUFrQixDQUFDcHNDLEVBQUQsRUFBSzl1RCxJQUFMLEVBQVcrbUMsTUFBWCxDQUEvQjs7UUFFQSxJQUFJeGlDLE1BQU0sSUFBSSxPQUFkLEVBQ0U7VUFBRXVxRCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTdzJELE1BQVQsR0FBa0J4N0YsSUFBbEI7OztRQUNKLElBQUl1RSxNQUFNLElBQUksU0FBZCxFQUNFO1VBQUUyL0QsV0FBVyxDQUFDcFYsRUFBRCxFQUFLLFlBQUwsRUFBbUJBLEVBQW5CLEVBQXVCOXVELElBQXZCLEVBQTZCckUsQ0FBN0IsQ0FBWDs7O1FBRUosSUFBSTRJLE1BQU0sSUFBSSxTQUFWLElBQXVCQSxNQUFNLElBQUksT0FBckMsRUFBOEM7VUFDNUNrckQsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoQjtVQUNBbzRFLFlBQVksQ0FBQ2psQixFQUFELENBQVo7OztRQUdGLE9BQU8sQ0FBQyxDQUFDdnFELE1BQVQ7T0F4aE9pQjs7O01BNGhPbkIsU0FBU20zRixnQkFBVCxDQUEwQjVzQyxFQUExQixFQUE4Qm56RCxDQUE5QixFQUFpQztRQUMvQixJQUFJcUUsSUFBSSxHQUFHazJGLE9BQU8sQ0FBQ3Y2RixDQUFELEVBQUksSUFBSixDQUFsQjs7UUFDQSxJQUFJLENBQUNxRSxJQUFMLEVBQVc7VUFBRSxPQUFPLEtBQVA7OztRQUViLElBQUlyRSxDQUFDLENBQUNzNkYsUUFBRixJQUFjLENBQUNubkMsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3cyRCxNQUE1QixFQUFvQzs7OztVQUlsQyxPQUFPRixXQUFXLENBQUN4c0MsRUFBRCxFQUFLLFdBQVc5dUQsSUFBaEIsRUFBc0JyRSxDQUF0QixFQUF5QixVQUFVOEQsQ0FBVixFQUFhO1lBQUUsT0FBT3E3RixlQUFlLENBQUNoc0MsRUFBRCxFQUFLcnZELENBQUwsRUFBUSxJQUFSLENBQXRCO1dBQXhDLENBQVgsSUFDQTY3RixXQUFXLENBQUN4c0MsRUFBRCxFQUFLOXVELElBQUwsRUFBV3JFLENBQVgsRUFBYyxVQUFVOEQsQ0FBVixFQUFhO1lBQ3BDLElBQUksT0FBT0EsQ0FBUCxJQUFZLFFBQVosR0FBdUIsV0FBVzBNLElBQVgsQ0FBZ0IxTSxDQUFoQixDQUF2QixHQUE0Q0EsQ0FBQyxDQUFDazhGLE1BQWxELEVBQ0U7Y0FBRSxPQUFPYixlQUFlLENBQUNoc0MsRUFBRCxFQUFLcnZELENBQUwsQ0FBdEI7O1dBRkssQ0FEbEI7U0FKRixNQVNPO1VBQ0wsT0FBTzY3RixXQUFXLENBQUN4c0MsRUFBRCxFQUFLOXVELElBQUwsRUFBV3JFLENBQVgsRUFBYyxVQUFVOEQsQ0FBVixFQUFhO1lBQUUsT0FBT3E3RixlQUFlLENBQUNoc0MsRUFBRCxFQUFLcnZELENBQUwsQ0FBdEI7V0FBN0IsQ0FBbEI7O09BMWlPZTs7O01BK2lPbkIsU0FBU204RixpQkFBVCxDQUEyQjlzQyxFQUEzQixFQUErQm56RCxDQUEvQixFQUFrQ3lvQixFQUFsQyxFQUFzQztRQUNwQyxPQUFPazNFLFdBQVcsQ0FBQ3hzQyxFQUFELEVBQUssTUFBTTFxQyxFQUFOLEdBQVcsR0FBaEIsRUFBcUJ6b0IsQ0FBckIsRUFBd0IsVUFBVThELENBQVYsRUFBYTtVQUFFLE9BQU9xN0YsZUFBZSxDQUFDaHNDLEVBQUQsRUFBS3J2RCxDQUFMLEVBQVEsSUFBUixDQUF0QjtTQUF2QyxDQUFsQjs7O01BR0YsSUFBSW84RixjQUFjLEdBQUcsSUFBckI7O01BQ0EsU0FBU2g1QyxTQUFULENBQW1CbG5ELENBQW5CLEVBQXNCO1FBQ3BCLElBQUltekQsRUFBRSxHQUFHLElBQVQ7O1FBQ0EsSUFBSW56RCxDQUFDLENBQUMrRSxNQUFGLElBQVkvRSxDQUFDLENBQUMrRSxNQUFGLElBQVlvdUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCdzVCLFFBQWpCLEVBQTVCLEVBQXlEO1VBQUU7OztRQUMzRGh0QyxFQUFFLENBQUNPLEtBQUgsQ0FBUzdMLEtBQVQsR0FBaUJ5RSxTQUFTLEVBQTFCOztRQUNBLElBQUk0RyxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQWxCLEVBQTJCO1VBQUU7U0FKVDs7O1FBTXBCLElBQUk2cEQsRUFBRSxJQUFJQyxVQUFVLEdBQUcsRUFBbkIsSUFBeUI5cEQsQ0FBQyxDQUFDaTZGLE9BQUYsSUFBYSxFQUExQyxFQUE4QztVQUFFajZGLENBQUMsQ0FBQyt6RCxXQUFGLEdBQWdCLEtBQWhCOzs7UUFDaEQsSUFBSTMvQyxJQUFJLEdBQUdwVSxDQUFDLENBQUNpNkYsT0FBYjtRQUNBOW1DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc4dUUsS0FBWCxHQUFtQjlrRSxJQUFJLElBQUksRUFBUixJQUFjcFUsQ0FBQyxDQUFDczZGLFFBQW5DO1FBQ0EsSUFBSThGLE9BQU8sR0FBR0wsZ0JBQWdCLENBQUM1c0MsRUFBRCxFQUFLbnpELENBQUwsQ0FBOUI7O1FBQ0EsSUFBSW1xRCxNQUFKLEVBQVk7VUFDVisxQyxjQUFjLEdBQUdFLE9BQU8sR0FBR2hzRixJQUFILEdBQVUsSUFBbEMsQ0FEVTs7VUFHVixJQUFJLENBQUNnc0YsT0FBRCxJQUFZaHNGLElBQUksSUFBSSxFQUFwQixJQUEwQixDQUFDeWhELFlBQTNCLEtBQTRDakwsR0FBRyxHQUFHNXFELENBQUMsQ0FBQ3E2RixPQUFMLEdBQWVyNkYsQ0FBQyxDQUFDdTBELE9BQWhFLENBQUosRUFDRTtZQUFFcEIsRUFBRSxDQUFDNGdDLGdCQUFILENBQW9CLEVBQXBCLEVBQXdCLElBQXhCLEVBQThCLEtBQTlCOzs7O1FBRU4sSUFBSXRxQyxLQUFLLElBQUksQ0FBQ21CLEdBQVYsSUFBaUIsQ0FBQ3cxQyxPQUFsQixJQUE2QmhzRixJQUFJLElBQUksRUFBckMsSUFBMkNwVSxDQUFDLENBQUNzNkYsUUFBN0MsSUFBeUQsQ0FBQ3Q2RixDQUFDLENBQUN1MEQsT0FBNUQsSUFBdUU1ekQsUUFBUSxDQUFDKzlGLFdBQXBGLEVBQ0U7VUFBRS85RixRQUFRLENBQUMrOUYsV0FBVCxDQUFxQixLQUFyQjtTQWpCZ0I7OztRQW9CcEIsSUFBSXRxRixJQUFJLElBQUksRUFBUixJQUFjLENBQUMsMkJBQTJCNUQsSUFBM0IsQ0FBZ0MyaUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2l2RSxPQUFYLENBQW1CL3RCLFNBQW5ELENBQW5CLEVBQ0U7VUFBRSswQyxhQUFhLENBQUNsdEMsRUFBRCxDQUFiOzs7O01BR04sU0FBU2t0QyxhQUFULENBQXVCbHRDLEVBQXZCLEVBQTJCO1FBQ3pCLElBQUlrbUIsT0FBTyxHQUFHbG1CLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdpdkUsT0FBekI7UUFDQTdzQixRQUFRLENBQUM2c0IsT0FBRCxFQUFVLHNCQUFWLENBQVI7O1FBRUEsU0FBU2luQixFQUFULENBQVl0Z0csQ0FBWixFQUFlO1VBQ2IsSUFBSUEsQ0FBQyxDQUFDaTZGLE9BQUYsSUFBYSxFQUFiLElBQW1CLENBQUNqNkYsQ0FBQyxDQUFDbzZGLE1BQTFCLEVBQWtDO1lBQ2hDaHZDLE9BQU8sQ0FBQ2l1QixPQUFELEVBQVUsc0JBQVYsQ0FBUDtZQUNBdm1CLEdBQUcsQ0FBQ255RCxRQUFELEVBQVcsT0FBWCxFQUFvQjIvRixFQUFwQixDQUFIO1lBQ0F4dEMsR0FBRyxDQUFDbnlELFFBQUQsRUFBVyxXQUFYLEVBQXdCMi9GLEVBQXhCLENBQUg7Ozs7UUFHSjd0QyxFQUFFLENBQUM5eEQsUUFBRCxFQUFXLE9BQVgsRUFBb0IyL0YsRUFBcEIsQ0FBRjtRQUNBN3RDLEVBQUUsQ0FBQzl4RCxRQUFELEVBQVcsV0FBWCxFQUF3QjIvRixFQUF4QixDQUFGOzs7TUFHRixTQUFTQyxPQUFULENBQWlCdmdHLENBQWpCLEVBQW9CO1FBQ2xCLElBQUlBLENBQUMsQ0FBQ2k2RixPQUFGLElBQWEsRUFBakIsRUFBcUI7VUFBRSxLQUFLNWdDLEdBQUwsQ0FBU3VjLEdBQVQsQ0FBYXNELEtBQWIsR0FBcUIsS0FBckI7OztRQUN2QmhtQixjQUFjLENBQUMsSUFBRCxFQUFPbHpELENBQVAsQ0FBZDs7O01BR0YsU0FBU3dnRyxVQUFULENBQW9CeGdHLENBQXBCLEVBQXVCO1FBQ3JCLElBQUltekQsRUFBRSxHQUFHLElBQVQ7O1FBQ0EsSUFBSW56RCxDQUFDLENBQUMrRSxNQUFGLElBQVkvRSxDQUFDLENBQUMrRSxNQUFGLElBQVlvdUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCdzVCLFFBQWpCLEVBQTVCLEVBQXlEO1VBQUU7OztRQUMzRCxJQUFJdjBCLGFBQWEsQ0FBQ3pZLEVBQUUsQ0FBQy9vRCxPQUFKLEVBQWFwSyxDQUFiLENBQWIsSUFBZ0NrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUE5QyxJQUF5REEsQ0FBQyxDQUFDdTBELE9BQUYsSUFBYSxDQUFDdjBELENBQUMsQ0FBQ282RixNQUF6RSxJQUFtRnh2QyxHQUFHLElBQUk1cUQsQ0FBQyxDQUFDcTZGLE9BQWhHLEVBQXlHO1VBQUU7OztRQUMzRyxJQUFJSixPQUFPLEdBQUdqNkYsQ0FBQyxDQUFDaTZGLE9BQWhCO1lBQXlCd0csUUFBUSxHQUFHemdHLENBQUMsQ0FBQ3lnRyxRQUF0Qzs7UUFDQSxJQUFJdDJDLE1BQU0sSUFBSTh2QyxPQUFPLElBQUlpRyxjQUF6QixFQUF5QztVQUFDQSxjQUFjLEdBQUcsSUFBakI7VUFBdUJwc0MsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoQjtVQUFxQjs7O1FBQ3RGLElBQUttcUQsTUFBTSxLQUFLLENBQUNucUQsQ0FBQyxDQUFDaW9ELEtBQUgsSUFBWWpvRCxDQUFDLENBQUNpb0QsS0FBRixHQUFVLEVBQTNCLENBQVAsSUFBMEM4M0MsZ0JBQWdCLENBQUM1c0MsRUFBRCxFQUFLbnpELENBQUwsQ0FBOUQsRUFBdUU7VUFBRTs7O1FBQ3pFLElBQUl5b0IsRUFBRSxHQUFHaGxCLE1BQU0sQ0FBQytWLFlBQVAsQ0FBb0JpbkYsUUFBUSxJQUFJLElBQVosR0FBbUJ4RyxPQUFuQixHQUE2QndHLFFBQWpELENBQVQsQ0FQcUI7O1FBU3JCLElBQUloNEUsRUFBRSxJQUFJLE1BQVYsRUFBa0I7VUFBRTs7O1FBQ3BCLElBQUl3M0UsaUJBQWlCLENBQUM5c0MsRUFBRCxFQUFLbnpELENBQUwsRUFBUXlvQixFQUFSLENBQXJCLEVBQWtDO1VBQUU7OztRQUNwQzBxQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUI2NUIsVUFBakIsQ0FBNEJ4Z0csQ0FBNUI7OztNQUdGLElBQUkwZ0csaUJBQWlCLEdBQUcsR0FBeEI7O01BRUEsSUFBSUMsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBUzM4RCxJQUFULEVBQWVscUIsR0FBZixFQUFvQnc2QyxNQUFwQixFQUE0QjtRQUMxQyxLQUFLdHdCLElBQUwsR0FBWUEsSUFBWjtRQUNBLEtBQUtscUIsR0FBTCxHQUFXQSxHQUFYO1FBQ0EsS0FBS3c2QyxNQUFMLEdBQWNBLE1BQWQ7T0FIRjs7TUFNQXFzQyxTQUFTLENBQUNqOUYsU0FBVixDQUFvQms5RixPQUFwQixHQUE4QixVQUFVNThELElBQVYsRUFBZ0JscUIsR0FBaEIsRUFBcUJ3NkMsTUFBckIsRUFBNkI7UUFDekQsT0FBTyxLQUFLdHdCLElBQUwsR0FBWTA4RCxpQkFBWixHQUFnQzE4RCxJQUFoQyxJQUNMeTJCLEdBQUcsQ0FBQzNnRCxHQUFELEVBQU0sS0FBS0EsR0FBWCxDQUFILElBQXNCLENBRGpCLElBQ3NCdzZDLE1BQU0sSUFBSSxLQUFLQSxNQUQ1QztPQURGOztNQUtBLElBQUl1c0MsU0FBSixFQUFlQyxlQUFmOztNQUNBLFNBQVNDLFdBQVQsQ0FBcUJqbkYsR0FBckIsRUFBMEJ3NkMsTUFBMUIsRUFBa0M7UUFDaEMsSUFBSWgyQyxHQUFHLEdBQUcsQ0FBQyxJQUFJQyxJQUFKLEVBQVg7O1FBQ0EsSUFBSXVpRixlQUFlLElBQUlBLGVBQWUsQ0FBQ0YsT0FBaEIsQ0FBd0J0aUYsR0FBeEIsRUFBNkJ4RSxHQUE3QixFQUFrQ3c2QyxNQUFsQyxDQUF2QixFQUFrRTtVQUNoRXVzQyxTQUFTLEdBQUdDLGVBQWUsR0FBRyxJQUE5QjtVQUNBLE9BQU8sUUFBUDtTQUZGLE1BR08sSUFBSUQsU0FBUyxJQUFJQSxTQUFTLENBQUNELE9BQVYsQ0FBa0J0aUYsR0FBbEIsRUFBdUJ4RSxHQUF2QixFQUE0Qnc2QyxNQUE1QixDQUFqQixFQUFzRDtVQUMzRHdzQyxlQUFlLEdBQUcsSUFBSUgsU0FBSixDQUFjcmlGLEdBQWQsRUFBbUJ4RSxHQUFuQixFQUF3Qnc2QyxNQUF4QixDQUFsQjtVQUNBdXNDLFNBQVMsR0FBRyxJQUFaO1VBQ0EsT0FBTyxRQUFQO1NBSEssTUFJQTtVQUNMQSxTQUFTLEdBQUcsSUFBSUYsU0FBSixDQUFjcmlGLEdBQWQsRUFBbUJ4RSxHQUFuQixFQUF3Qnc2QyxNQUF4QixDQUFaO1VBQ0F3c0MsZUFBZSxHQUFHLElBQWxCO1VBQ0EsT0FBTyxRQUFQOztPQXhvT2U7Ozs7Ozs7TUFpcE9uQixTQUFTRSxXQUFULENBQXFCaGhHLENBQXJCLEVBQXdCO1FBQ3RCLElBQUltekQsRUFBRSxHQUFHLElBQVQ7WUFBZS9vRCxPQUFPLEdBQUcrb0QsRUFBRSxDQUFDL29ELE9BQTVCOztRQUNBLElBQUk4b0QsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFkLElBQXlCb0ssT0FBTyxDQUFDczdFLFdBQVIsSUFBdUJ0N0UsT0FBTyxDQUFDdThELEtBQVIsQ0FBY3M2QixhQUFkLEVBQXBELEVBQW1GO1VBQUU7OztRQUNyRjcyRixPQUFPLENBQUN1OEQsS0FBUixDQUFjMDRCLFlBQWQ7UUFDQWoxRixPQUFPLENBQUM4dUUsS0FBUixHQUFnQmw1RSxDQUFDLENBQUNzNkYsUUFBbEI7O1FBRUEsSUFBSTF1QixhQUFhLENBQUN4aEUsT0FBRCxFQUFVcEssQ0FBVixDQUFqQixFQUErQjtVQUM3QixJQUFJLENBQUNncUQsTUFBTCxFQUFhOzs7WUFHWDUvQyxPQUFPLENBQUN1aUUsUUFBUixDQUFpQjRZLFNBQWpCLEdBQTZCLEtBQTdCO1lBQ0F2NUQsVUFBVSxDQUFDLFlBQVk7Y0FBRSxPQUFPNWhCLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCNFksU0FBakIsR0FBNkIsSUFBcEM7YUFBZixFQUE0RCxHQUE1RCxDQUFWOzs7VUFFRjs7O1FBRUYsSUFBSTJiLGFBQWEsQ0FBQy90QyxFQUFELEVBQUtuekQsQ0FBTCxDQUFqQixFQUEwQjtVQUFFOzs7UUFDNUIsSUFBSThaLEdBQUcsR0FBR2s2RCxZQUFZLENBQUM3Z0IsRUFBRCxFQUFLbnpELENBQUwsQ0FBdEI7WUFBK0JzMEQsTUFBTSxHQUFHRCxRQUFRLENBQUNyMEQsQ0FBRCxDQUFoRDtZQUFxRDBVLE1BQU0sR0FBR29GLEdBQUcsR0FBR2luRixXQUFXLENBQUNqbkYsR0FBRCxFQUFNdzZDLE1BQU4sQ0FBZCxHQUE4QixRQUEvRjtRQUNBaDFELE1BQU0sQ0FBQ3VvRCxLQUFQLEdBakJzQjs7UUFvQnRCLElBQUl5TSxNQUFNLElBQUksQ0FBVixJQUFlbkIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzgzRCxhQUE1QixFQUNFO1VBQUVodUMsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzgzRCxhQUFULENBQXVCbmhHLENBQXZCOzs7UUFFSixJQUFJOFosR0FBRyxJQUFJc25GLGtCQUFrQixDQUFDanVDLEVBQUQsRUFBS21CLE1BQUwsRUFBYXg2QyxHQUFiLEVBQWtCcEYsTUFBbEIsRUFBMEIxVSxDQUExQixDQUE3QixFQUEyRDtVQUFFOzs7UUFFN0QsSUFBSXMwRCxNQUFNLElBQUksQ0FBZCxFQUFpQjtVQUNmLElBQUl4NkMsR0FBSixFQUFTO1lBQUV1bkYsY0FBYyxDQUFDbHVDLEVBQUQsRUFBS3I1QyxHQUFMLEVBQVVwRixNQUFWLEVBQWtCMVUsQ0FBbEIsQ0FBZDtXQUFYLE1BQ0ssSUFBSW0wRCxRQUFRLENBQUNuMEQsQ0FBRCxDQUFSLElBQWVvSyxPQUFPLENBQUN1aUUsUUFBM0IsRUFBcUM7WUFBRTdZLGdCQUFnQixDQUFDOXpELENBQUQsQ0FBaEI7O1NBRjlDLE1BR08sSUFBSXMwRCxNQUFNLElBQUksQ0FBZCxFQUFpQjtVQUN0QixJQUFJeDZDLEdBQUosRUFBUztZQUFFeXlFLGVBQWUsQ0FBQ3A1QixFQUFFLENBQUNrRyxHQUFKLEVBQVN2L0MsR0FBVCxDQUFmOzs7VUFDWGtTLFVBQVUsQ0FBQyxZQUFZO1lBQUUsT0FBTzVoQixPQUFPLENBQUN1OEQsS0FBUixDQUFjOWUsS0FBZCxFQUFQO1dBQWYsRUFBZ0QsRUFBaEQsQ0FBVjtTQUZLLE1BR0EsSUFBSXlNLE1BQU0sSUFBSSxDQUFkLEVBQWlCO1VBQ3RCLElBQUlySixpQkFBSixFQUF1QjtZQUFFa0ksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCMjZCLGFBQWpCLENBQStCdGhHLENBQS9CO1dBQXpCLE1BQ0s7WUFBRTY0RSxjQUFjLENBQUMxbEIsRUFBRCxDQUFkOzs7OztNQUlYLFNBQVNpdUMsa0JBQVQsQ0FBNEJqdUMsRUFBNUIsRUFBZ0NtQixNQUFoQyxFQUF3Q3g2QyxHQUF4QyxFQUE2Q3BGLE1BQTdDLEVBQXFENFcsS0FBckQsRUFBNEQ7UUFDMUQsSUFBSWpuQixJQUFJLEdBQUcsT0FBWDs7UUFDQSxJQUFJcVEsTUFBTSxJQUFJLFFBQWQsRUFBd0I7VUFBRXJRLElBQUksR0FBRyxXQUFXQSxJQUFsQjtTQUExQixNQUNLLElBQUlxUSxNQUFNLElBQUksUUFBZCxFQUF3QjtVQUFFclEsSUFBSSxHQUFHLFdBQVdBLElBQWxCOzs7UUFDL0JBLElBQUksR0FBRyxDQUFDaXdELE1BQU0sSUFBSSxDQUFWLEdBQWMsTUFBZCxHQUF1QkEsTUFBTSxJQUFJLENBQVYsR0FBYyxRQUFkLEdBQXlCLE9BQWpELElBQTREandELElBQW5FO1FBRUEsT0FBT3M3RixXQUFXLENBQUN4c0MsRUFBRCxFQUFNK21DLGdCQUFnQixDQUFDNzFGLElBQUQsRUFBT2luQixLQUFQLENBQXRCLEVBQXFDQSxLQUFyQyxFQUE0QyxVQUFVL1osS0FBVixFQUFpQjtVQUM3RSxJQUFJLE9BQU9BLEtBQVAsSUFBZ0IsUUFBcEIsRUFBOEI7WUFBRUEsS0FBSyxHQUFHb3FGLFFBQVEsQ0FBQ3BxRixLQUFELENBQWhCOzs7VUFDaEMsSUFBSSxDQUFDQSxLQUFMLEVBQVk7WUFBRSxPQUFPLEtBQVA7OztVQUNkLElBQUl1SyxJQUFJLEdBQUcsS0FBWDs7VUFDQSxJQUFJO1lBQ0YsSUFBSXEzQyxFQUFFLENBQUMyakMsVUFBSCxFQUFKLEVBQXFCO2NBQUUzakMsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU29sRCxhQUFULEdBQXlCLElBQXpCOzs7WUFDdkIzeUUsSUFBSSxHQUFHdkssS0FBSyxDQUFDNGhELEVBQUQsRUFBS3I1QyxHQUFMLENBQUwsSUFBa0JnMEMsSUFBekI7V0FGRixTQUdVO1lBQ1JxRixFQUFFLENBQUM5cEIsS0FBSCxDQUFTb2xELGFBQVQsR0FBeUIsS0FBekI7OztVQUVGLE9BQU8zeUUsSUFBUDtTQVZnQixDQUFsQjs7O01BY0YsU0FBU3lsRixjQUFULENBQXdCcHVDLEVBQXhCLEVBQTRCeitDLE1BQTVCLEVBQW9DNFcsS0FBcEMsRUFBMkM7UUFDekMsSUFBSWsyRSxNQUFNLEdBQUdydUMsRUFBRSxDQUFDMlIsU0FBSCxDQUFhLGdCQUFiLENBQWI7UUFDQSxJQUFJbGpFLEtBQUssR0FBRzQvRixNQUFNLEdBQUdBLE1BQU0sQ0FBQ3J1QyxFQUFELEVBQUt6K0MsTUFBTCxFQUFhNFcsS0FBYixDQUFULEdBQStCLEVBQWpEOztRQUNBLElBQUkxcEIsS0FBSyxDQUFDNi9GLElBQU4sSUFBYyxJQUFsQixFQUF3QjtVQUN0QixJQUFJcGhELElBQUksR0FBR3dLLFFBQVEsR0FBR3YvQixLQUFLLENBQUNndkUsUUFBTixJQUFrQmh2RSxLQUFLLENBQUMrdUUsT0FBM0IsR0FBcUMvdUUsS0FBSyxDQUFDOHVFLE1BQTlEO1VBQ0F4NEYsS0FBSyxDQUFDNi9GLElBQU4sR0FBYXBoRCxJQUFJLEdBQUcsV0FBSCxHQUFpQjNyQyxNQUFNLElBQUksUUFBVixHQUFxQixNQUFyQixHQUE4QkEsTUFBTSxJQUFJLFFBQVYsR0FBcUIsTUFBckIsR0FBOEIsTUFBOUY7OztRQUVGLElBQUk5UyxLQUFLLENBQUNvaEYsTUFBTixJQUFnQixJQUFoQixJQUF3Qjd2QixFQUFFLENBQUNrRyxHQUFILENBQU8ycEIsTUFBbkMsRUFBMkM7VUFBRXBoRixLQUFLLENBQUNvaEYsTUFBTixHQUFlN3ZCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBTzJwQixNQUFQLElBQWlCMTNELEtBQUssQ0FBQ2d2RSxRQUF0Qzs7O1FBQzdDLElBQUkxNEYsS0FBSyxDQUFDOC9GLE1BQU4sSUFBZ0IsSUFBcEIsRUFBMEI7VUFBRTkvRixLQUFLLENBQUM4L0YsTUFBTixHQUFlOTJDLEdBQUcsR0FBR3QvQixLQUFLLENBQUMrdUUsT0FBVCxHQUFtQi91RSxLQUFLLENBQUNpcEMsT0FBM0M7OztRQUM1QixJQUFJM3lELEtBQUssQ0FBQysvRixVQUFOLElBQW9CLElBQXhCLEVBQThCO1VBQUUvL0YsS0FBSyxDQUFDKy9GLFVBQU4sR0FBbUIsRUFBRS8yQyxHQUFHLEdBQUd0L0IsS0FBSyxDQUFDOHVFLE1BQVQsR0FBa0I5dUUsS0FBSyxDQUFDaXBDLE9BQTdCLENBQW5COzs7UUFDaEMsT0FBTzN5RCxLQUFQOzs7TUFHRixTQUFTeS9GLGNBQVQsQ0FBd0JsdUMsRUFBeEIsRUFBNEJyNUMsR0FBNUIsRUFBaUNwRixNQUFqQyxFQUF5QzRXLEtBQXpDLEVBQWdEO1FBQzlDLElBQUl1K0IsRUFBSixFQUFRO1VBQUU3OUIsVUFBVSxDQUFDM2EsSUFBSSxDQUFDdW5FLFdBQUQsRUFBY3psQixFQUFkLENBQUwsRUFBd0IsQ0FBeEIsQ0FBVjtTQUFWLE1BQ0s7VUFBRUEsRUFBRSxDQUFDTyxLQUFILENBQVM3TCxLQUFULEdBQWlCeUUsU0FBUyxFQUExQjs7O1FBRVAsSUFBSXMxQyxRQUFRLEdBQUdMLGNBQWMsQ0FBQ3B1QyxFQUFELEVBQUt6K0MsTUFBTCxFQUFhNFcsS0FBYixDQUE3QjtRQUVBLElBQUlzcUQsR0FBRyxHQUFHemlCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VjLEdBQWpCO1lBQXNCaXNCLFNBQXRCOztRQUNBLElBQUkxdUMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzR6RCxRQUFYLElBQXVCdHRDLFdBQXZCLElBQXNDLENBQUNyQixFQUFFLENBQUMyakMsVUFBSCxFQUF2QyxJQUNBcGlGLE1BQU0sSUFBSSxRQURWLElBQ3NCLENBQUNtdEYsU0FBUyxHQUFHanNCLEdBQUcsQ0FBQ3hwQixRQUFKLENBQWF0eUMsR0FBYixDQUFiLElBQWtDLENBQUMsQ0FEekQsS0FFQzJnRCxHQUFHLENBQUMsQ0FBQ29uQyxTQUFTLEdBQUdqc0IsR0FBRyxDQUFDQyxNQUFKLENBQVdnc0IsU0FBWCxDQUFiLEVBQW9DOWhGLElBQXBDLEVBQUQsRUFBNkNqRyxHQUE3QyxDQUFILEdBQXVELENBQXZELElBQTREQSxHQUFHLENBQUNtNEQsSUFBSixHQUFXLENBRnhFLE1BR0N4WCxHQUFHLENBQUNvbkMsU0FBUyxDQUFDdCtFLEVBQVYsRUFBRCxFQUFpQnpKLEdBQWpCLENBQUgsR0FBMkIsQ0FBM0IsSUFBZ0NBLEdBQUcsQ0FBQ200RCxJQUFKLEdBQVcsQ0FINUMsQ0FBSixFQUlFO1VBQUU4dkIsbUJBQW1CLENBQUM1dUMsRUFBRCxFQUFLN25DLEtBQUwsRUFBWXhSLEdBQVosRUFBaUI4bkYsUUFBakIsQ0FBbkI7U0FKSixNQU1FO1VBQUVJLGdCQUFnQixDQUFDN3VDLEVBQUQsRUFBSzduQyxLQUFMLEVBQVl4UixHQUFaLEVBQWlCOG5GLFFBQWpCLENBQWhCOztPQXB1T2E7Ozs7TUF5dU9uQixTQUFTRyxtQkFBVCxDQUE2QjV1QyxFQUE3QixFQUFpQzduQyxLQUFqQyxFQUF3Q3hSLEdBQXhDLEVBQTZDOG5GLFFBQTdDLEVBQXVEO1FBQ3JELElBQUl4M0YsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtZQUEwQjYzRixLQUFLLEdBQUcsS0FBbEM7UUFDQSxJQUFJQyxPQUFPLEdBQUdoOUMsU0FBUyxDQUFDaU8sRUFBRCxFQUFLLFVBQVVuekQsQ0FBVixFQUFhO1VBQ3ZDLElBQUlncUQsTUFBSixFQUFZO1lBQUU1L0MsT0FBTyxDQUFDdWlFLFFBQVIsQ0FBaUI0WSxTQUFqQixHQUE2QixLQUE3Qjs7O1VBQ2RweUIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzB2QyxZQUFULEdBQXdCLEtBQXhCOztVQUNBLElBQUk1bEIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3l2QyxpQkFBYixFQUFnQztZQUM5QixJQUFJM2xCLEVBQUUsQ0FBQ3dsQixRQUFILEVBQUosRUFBbUI7Y0FBRXhsQixFQUFFLENBQUM5cEIsS0FBSCxDQUFTeXZDLGlCQUFULEdBQTZCLEtBQTdCO2FBQXJCLE1BQ0s7Y0FBRUQsY0FBYyxDQUFDMWxCLEVBQUQsQ0FBZDs7OztVQUVUTCxHQUFHLENBQUMxb0QsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0I0a0MsYUFBakIsRUFBZ0MsU0FBaEMsRUFBMkN5c0MsT0FBM0MsQ0FBSDtVQUNBcHZDLEdBQUcsQ0FBQzFvRCxPQUFPLENBQUN5bUIsT0FBUixDQUFnQjRrQyxhQUFqQixFQUFnQyxXQUFoQyxFQUE2Q2pYLFNBQTdDLENBQUg7VUFDQXNVLEdBQUcsQ0FBQzFvRCxPQUFPLENBQUN1aUUsUUFBVCxFQUFtQixXQUFuQixFQUFnQ3cxQixTQUFoQyxDQUFIO1VBQ0FydkMsR0FBRyxDQUFDMW9ELE9BQU8sQ0FBQ3VpRSxRQUFULEVBQW1CLE1BQW5CLEVBQTJCdTFCLE9BQTNCLENBQUg7O1VBQ0EsSUFBSSxDQUFDRCxLQUFMLEVBQVk7WUFDVm51QyxnQkFBZ0IsQ0FBQzl6RCxDQUFELENBQWhCOztZQUNBLElBQUksQ0FBQzRoRyxRQUFRLENBQUNGLE1BQWQsRUFDRTtjQUFFblYsZUFBZSxDQUFDcDVCLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3YvQyxHQUFULEVBQWMsSUFBZCxFQUFvQixJQUFwQixFQUEwQjhuRixRQUFRLENBQUM1ZSxNQUFuQyxDQUFmO2FBSE07OztZQUtWLElBQUtoNUIsTUFBTSxJQUFJLENBQUNJLE1BQVosSUFBdUJQLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQS9DLEVBQ0U7Y0FBRTk5QixVQUFVLENBQUMsWUFBWTtnQkFBQzVoQixPQUFPLENBQUN5bUIsT0FBUixDQUFnQjRrQyxhQUFoQixDQUE4QjFYLElBQTlCLENBQW1DOEosS0FBbkMsQ0FBeUM7a0JBQUN1NkMsYUFBYSxFQUFFO2lCQUF6RDtnQkFBaUVoNEYsT0FBTyxDQUFDdThELEtBQVIsQ0FBYzllLEtBQWQ7ZUFBL0UsRUFBd0csRUFBeEcsQ0FBVjthQURKLE1BR0U7Y0FBRXo5QyxPQUFPLENBQUN1OEQsS0FBUixDQUFjOWUsS0FBZDs7O1NBbkJlLENBQXZCOztRQXNCQSxJQUFJckosU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBUzZqRCxFQUFULEVBQWE7VUFDM0JKLEtBQUssR0FBR0EsS0FBSyxJQUFJMWlHLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzZVLEtBQUssQ0FBQ2kxQixPQUFOLEdBQWdCOGhELEVBQUUsQ0FBQzloRCxPQUE1QixJQUF1Q2hoRCxJQUFJLENBQUNrWCxHQUFMLENBQVM2VSxLQUFLLENBQUNtMUIsT0FBTixHQUFnQjRoRCxFQUFFLENBQUM1aEQsT0FBNUIsQ0FBdkMsSUFBK0UsRUFBaEc7U0FERjs7UUFHQSxJQUFJMGhELFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQVk7VUFBRSxPQUFPRixLQUFLLEdBQUcsSUFBZjtTQUE5QixDQTNCcUQ7OztRQTZCckQsSUFBSWo0QyxNQUFKLEVBQVk7VUFBRTUvQyxPQUFPLENBQUN1aUUsUUFBUixDQUFpQjRZLFNBQWpCLEdBQTZCLElBQTdCOzs7UUFDZHB5QixFQUFFLENBQUM5cEIsS0FBSCxDQUFTMHZDLFlBQVQsR0FBd0JtcEIsT0FBeEI7UUFDQUEsT0FBTyxDQUFDdm1DLElBQVIsR0FBZSxDQUFDaW1DLFFBQVEsQ0FBQ0QsVUFBekI7UUFDQWx2QyxFQUFFLENBQUNyb0QsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0I0a0MsYUFBakIsRUFBZ0MsU0FBaEMsRUFBMkN5c0MsT0FBM0MsQ0FBRjtRQUNBenZDLEVBQUUsQ0FBQ3JvRCxPQUFPLENBQUN5bUIsT0FBUixDQUFnQjRrQyxhQUFqQixFQUFnQyxXQUFoQyxFQUE2Q2pYLFNBQTdDLENBQUY7UUFDQWlVLEVBQUUsQ0FBQ3JvRCxPQUFPLENBQUN1aUUsUUFBVCxFQUFtQixXQUFuQixFQUFnQ3cxQixTQUFoQyxDQUFGO1FBQ0ExdkMsRUFBRSxDQUFDcm9ELE9BQU8sQ0FBQ3VpRSxRQUFULEVBQW1CLE1BQW5CLEVBQTJCdTFCLE9BQTNCLENBQUY7UUFFQS91QyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeXZDLGlCQUFULEdBQTZCLElBQTdCO1FBQ0E5c0QsVUFBVSxDQUFDLFlBQVk7VUFBRSxPQUFPNWhCLE9BQU8sQ0FBQ3U4RCxLQUFSLENBQWM5ZSxLQUFkLEVBQVA7U0FBZixFQUFnRCxFQUFoRCxDQUFWLENBdENxRDs7UUF3Q3JELElBQUl6OUMsT0FBTyxDQUFDdWlFLFFBQVIsQ0FBaUJtMUIsUUFBckIsRUFBK0I7VUFBRTEzRixPQUFPLENBQUN1aUUsUUFBUixDQUFpQm0xQixRQUFqQjs7OztNQUduQyxTQUFTUSxZQUFULENBQXNCbnZDLEVBQXRCLEVBQTBCcjVDLEdBQTFCLEVBQStCMm5GLElBQS9CLEVBQXFDO1FBQ25DLElBQUlBLElBQUksSUFBSSxNQUFaLEVBQW9CO1VBQUUsT0FBTyxJQUFJcGEsS0FBSixDQUFVdnRFLEdBQVYsRUFBZUEsR0FBZixDQUFQOzs7UUFDdEIsSUFBSTJuRixJQUFJLElBQUksTUFBWixFQUFvQjtVQUFFLE9BQU90dUMsRUFBRSxDQUFDb3ZDLFVBQUgsQ0FBY3pvRixHQUFkLENBQVA7OztRQUN0QixJQUFJMm5GLElBQUksSUFBSSxNQUFaLEVBQW9CO1VBQUUsT0FBTyxJQUFJcGEsS0FBSixDQUFVN3NCLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBTCxFQUFXLENBQVgsQ0FBYixFQUE0QndJLFFBQU8sQ0FBQzVILEVBQUUsQ0FBQ2tHLEdBQUosRUFBU21CLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBSixHQUFXLENBQVosRUFBZSxDQUFmLENBQVosQ0FBbkMsQ0FBUDs7O1FBQ3RCLElBQUkzcEQsTUFBTSxHQUFHNjRGLElBQUksQ0FBQ3R1QyxFQUFELEVBQUtyNUMsR0FBTCxDQUFqQjtRQUNBLE9BQU8sSUFBSXV0RSxLQUFKLENBQVV6K0UsTUFBTSxDQUFDbVgsSUFBakIsRUFBdUJuWCxNQUFNLENBQUMyYSxFQUE5QixDQUFQO09BenhPaUI7OztNQTZ4T25CLFNBQVN5K0UsZ0JBQVQsQ0FBMEI3dUMsRUFBMUIsRUFBOEI3bkMsS0FBOUIsRUFBcUNwSyxLQUFyQyxFQUE0QzBnRixRQUE1QyxFQUFzRDtRQUNwRCxJQUFJLzNDLEVBQUosRUFBUTtVQUFFZ3ZCLGNBQWMsQ0FBQzFsQixFQUFELENBQWQ7OztRQUNWLElBQUkvb0QsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUFqQjtZQUEwQml2RCxHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFuQztRQUNBdkYsZ0JBQWdCLENBQUN4b0MsS0FBRCxDQUFoQjtRQUVBLElBQUlrM0UsUUFBSjtZQUFjQyxRQUFkO1lBQXdCQyxRQUFRLEdBQUdycEMsR0FBRyxDQUFDdWMsR0FBdkM7WUFBNENDLE1BQU0sR0FBRzZzQixRQUFRLENBQUM3c0IsTUFBOUQ7O1FBQ0EsSUFBSStyQixRQUFRLENBQUNGLE1BQVQsSUFBbUIsQ0FBQ0UsUUFBUSxDQUFDNWUsTUFBakMsRUFBeUM7VUFDdkN5ZixRQUFRLEdBQUdwcEMsR0FBRyxDQUFDdWMsR0FBSixDQUFReHBCLFFBQVIsQ0FBaUJsckMsS0FBakIsQ0FBWDs7VUFDQSxJQUFJdWhGLFFBQVEsR0FBRyxDQUFDLENBQWhCLEVBQ0U7WUFBRUQsUUFBUSxHQUFHM3NCLE1BQU0sQ0FBQzRzQixRQUFELENBQWpCO1dBREosTUFHRTtZQUFFRCxRQUFRLEdBQUcsSUFBSW5iLEtBQUosQ0FBVW5tRSxLQUFWLEVBQWlCQSxLQUFqQixDQUFYOztTQUxOLE1BTU87VUFDTHNoRixRQUFRLEdBQUducEMsR0FBRyxDQUFDdWMsR0FBSixDQUFRSixPQUFSLEVBQVg7VUFDQWl0QixRQUFRLEdBQUdwcEMsR0FBRyxDQUFDdWMsR0FBSixDQUFRRSxTQUFuQjs7O1FBR0YsSUFBSThyQixRQUFRLENBQUNILElBQVQsSUFBaUIsV0FBckIsRUFBa0M7VUFDaEMsSUFBSSxDQUFDRyxRQUFRLENBQUNGLE1BQWQsRUFBc0I7WUFBRWMsUUFBUSxHQUFHLElBQUluYixLQUFKLENBQVVubUUsS0FBVixFQUFpQkEsS0FBakIsQ0FBWDs7O1VBQ3hCQSxLQUFLLEdBQUc4eUQsWUFBWSxDQUFDN2dCLEVBQUQsRUFBSzduQyxLQUFMLEVBQVksSUFBWixFQUFrQixJQUFsQixDQUFwQjtVQUNBbTNFLFFBQVEsR0FBRyxDQUFDLENBQVo7U0FIRixNQUlPO1VBQ0wsSUFBSTEvQyxLQUFLLEdBQUd1L0MsWUFBWSxDQUFDbnZDLEVBQUQsRUFBS2p5QyxLQUFMLEVBQVkwZ0YsUUFBUSxDQUFDSCxJQUFyQixDQUF4Qjs7VUFDQSxJQUFJRyxRQUFRLENBQUM1ZSxNQUFiLEVBQ0U7WUFBRXdmLFFBQVEsR0FBR25XLFdBQVcsQ0FBQ21XLFFBQUQsRUFBV3ovQyxLQUFLLENBQUN6bEMsTUFBakIsRUFBeUJ5bEMsS0FBSyxDQUFDdjJCLElBQS9CLEVBQXFDbzFFLFFBQVEsQ0FBQzVlLE1BQTlDLENBQXRCO1dBREosTUFHRTtZQUFFd2YsUUFBUSxHQUFHei9DLEtBQVg7Ozs7UUFHTixJQUFJLENBQUM2K0MsUUFBUSxDQUFDRixNQUFkLEVBQXNCO1VBQ3BCZSxRQUFRLEdBQUcsQ0FBWDtVQUNBalcsWUFBWSxDQUFDbnpCLEdBQUQsRUFBTSxJQUFJMnRCLFNBQUosQ0FBYyxDQUFDd2IsUUFBRCxDQUFkLEVBQTBCLENBQTFCLENBQU4sRUFBb0N2MEMsU0FBcEMsQ0FBWjtVQUNBeTBDLFFBQVEsR0FBR3JwQyxHQUFHLENBQUN1YyxHQUFmO1NBSEYsTUFJTyxJQUFJNnNCLFFBQVEsSUFBSSxDQUFDLENBQWpCLEVBQW9CO1VBQ3pCQSxRQUFRLEdBQUc1c0IsTUFBTSxDQUFDanlFLE1BQWxCO1VBQ0E0b0YsWUFBWSxDQUFDbnpCLEdBQUQsRUFBTWt1QixrQkFBa0IsQ0FBQ3AwQixFQUFELEVBQUswaUIsTUFBTSxDQUFDdHpFLE1BQVAsQ0FBYyxDQUFDaWdHLFFBQUQsQ0FBZCxDQUFMLEVBQWdDQyxRQUFoQyxDQUF4QixFQUNDO1lBQUN6MEMsTUFBTSxFQUFFLEtBQVQ7WUFBZ0JFLE1BQU0sRUFBRTtXQUR6QixDQUFaO1NBRkssTUFJQSxJQUFJMm5CLE1BQU0sQ0FBQ2p5RSxNQUFQLEdBQWdCLENBQWhCLElBQXFCaXlFLE1BQU0sQ0FBQzRzQixRQUFELENBQU4sQ0FBaUJqMEUsS0FBakIsRUFBckIsSUFBaURvekUsUUFBUSxDQUFDSCxJQUFULElBQWlCLE1BQWxFLElBQTRFLENBQUNHLFFBQVEsQ0FBQzVlLE1BQTFGLEVBQWtHO1VBQ3ZHd0osWUFBWSxDQUFDbnpCLEdBQUQsRUFBTWt1QixrQkFBa0IsQ0FBQ3AwQixFQUFELEVBQUswaUIsTUFBTSxDQUFDeHVFLEtBQVAsQ0FBYSxDQUFiLEVBQWdCbzdGLFFBQWhCLEVBQTBCbGdHLE1BQTFCLENBQWlDc3pFLE1BQU0sQ0FBQ3h1RSxLQUFQLENBQWFvN0YsUUFBUSxHQUFHLENBQXhCLENBQWpDLENBQUwsRUFBbUUsQ0FBbkUsQ0FBeEIsRUFDQztZQUFDejBDLE1BQU0sRUFBRSxLQUFUO1lBQWdCRSxNQUFNLEVBQUU7V0FEekIsQ0FBWjtVQUVBdzBDLFFBQVEsR0FBR3JwQyxHQUFHLENBQUN1YyxHQUFmO1NBSEssTUFJQTtVQUNMZ1gsbUJBQW1CLENBQUN2ekIsR0FBRCxFQUFNb3BDLFFBQU4sRUFBZ0JELFFBQWhCLEVBQTBCdjBDLFNBQTFCLENBQW5COzs7UUFHRixJQUFJMDBDLE9BQU8sR0FBR3poRixLQUFkOztRQUNBLFNBQVMwaEYsUUFBVCxDQUFrQjlvRixHQUFsQixFQUF1QjtVQUNyQixJQUFJMmdELEdBQUcsQ0FBQ2tvQyxPQUFELEVBQVU3b0YsR0FBVixDQUFILElBQXFCLENBQXpCLEVBQTRCO1lBQUU7OztVQUM5QjZvRixPQUFPLEdBQUc3b0YsR0FBVjs7VUFFQSxJQUFJOG5GLFFBQVEsQ0FBQ0gsSUFBVCxJQUFpQixXQUFyQixFQUFrQztZQUNoQyxJQUFJNXJCLE1BQU0sR0FBRyxFQUFiO2dCQUFpQnpvQixPQUFPLEdBQUcrRixFQUFFLENBQUNqbEIsT0FBSCxDQUFXa2YsT0FBdEM7WUFDQSxJQUFJeTFDLFFBQVEsR0FBRzExQyxXQUFXLENBQUNpTSxPQUFPLENBQUNDLEdBQUQsRUFBTW40QyxLQUFLLENBQUNxeEMsSUFBWixDQUFQLENBQXlCdlEsSUFBMUIsRUFBZ0M5Z0MsS0FBSyxDQUFDdUgsRUFBdEMsRUFBMEMya0MsT0FBMUMsQ0FBMUI7WUFDQSxJQUFJMDFDLE1BQU0sR0FBRzMxQyxXQUFXLENBQUNpTSxPQUFPLENBQUNDLEdBQUQsRUFBTXYvQyxHQUFHLENBQUN5NEMsSUFBVixDQUFQLENBQXVCdlEsSUFBeEIsRUFBOEJsb0MsR0FBRyxDQUFDMk8sRUFBbEMsRUFBc0Mya0MsT0FBdEMsQ0FBeEI7WUFDQSxJQUFJdHFCLElBQUksR0FBR3ZqQyxJQUFJLENBQUNzSSxHQUFMLENBQVNnN0YsUUFBVCxFQUFtQkMsTUFBbkIsQ0FBWDtnQkFBdUMzdEMsS0FBSyxHQUFHNTFELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUzg2RixRQUFULEVBQW1CQyxNQUFuQixDQUEvQzs7WUFDQSxLQUFLLElBQUl2d0MsSUFBSSxHQUFHaHpELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3FaLEtBQUssQ0FBQ3F4QyxJQUFmLEVBQXFCejRDLEdBQUcsQ0FBQ3k0QyxJQUF6QixDQUFYLEVBQTJDOTFDLEdBQUcsR0FBR2xkLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3NyRCxFQUFFLENBQUNpUSxRQUFILEVBQVQsRUFBd0I3akUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTbVosS0FBSyxDQUFDcXhDLElBQWYsRUFBcUJ6NEMsR0FBRyxDQUFDeTRDLElBQXpCLENBQXhCLENBQXRELEVBQ0tBLElBQUksSUFBSTkxQyxHQURiLEVBQ2tCODFDLElBQUksRUFEdEIsRUFDMEI7Y0FDeEIsSUFBSXZRLElBQUksR0FBR29YLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNOUcsSUFBTixDQUFQLENBQW1CdlEsSUFBOUI7a0JBQW9DaTZDLE9BQU8sR0FBRzd0QyxVQUFVLENBQUNwTSxJQUFELEVBQU9sZixJQUFQLEVBQWFzcUIsT0FBYixDQUF4RDs7Y0FDQSxJQUFJdHFCLElBQUksSUFBSXF5QixLQUFaLEVBQ0U7Z0JBQUUwZ0IsTUFBTSxDQUFDbHpFLElBQVAsQ0FBWSxJQUFJMGtGLEtBQUosQ0FBVTdzQixHQUFHLENBQUNqSSxJQUFELEVBQU8wcEMsT0FBUCxDQUFiLEVBQThCemhDLEdBQUcsQ0FBQ2pJLElBQUQsRUFBTzBwQyxPQUFQLENBQWpDLENBQVo7ZUFESixNQUVLLElBQUlqNkMsSUFBSSxDQUFDcCtDLE1BQUwsR0FBY3E0RixPQUFsQixFQUNIO2dCQUFFcG1CLE1BQU0sQ0FBQ2x6RSxJQUFQLENBQVksSUFBSTBrRixLQUFKLENBQVU3c0IsR0FBRyxDQUFDakksSUFBRCxFQUFPMHBDLE9BQVAsQ0FBYixFQUE4QnpoQyxHQUFHLENBQUNqSSxJQUFELEVBQU9uRSxVQUFVLENBQUNwTSxJQUFELEVBQU9tVCxLQUFQLEVBQWMvSCxPQUFkLENBQWpCLENBQWpDLENBQVo7Ozs7WUFFTixJQUFJLENBQUN5b0IsTUFBTSxDQUFDanlFLE1BQVosRUFBb0I7Y0FBRWl5RSxNQUFNLENBQUNsekUsSUFBUCxDQUFZLElBQUkwa0YsS0FBSixDQUFVbm1FLEtBQVYsRUFBaUJBLEtBQWpCLENBQVo7OztZQUN0QnNyRSxZQUFZLENBQUNuekIsR0FBRCxFQUFNa3VCLGtCQUFrQixDQUFDcDBCLEVBQUQsRUFBS3V2QyxRQUFRLENBQUM3c0IsTUFBVCxDQUFnQnh1RSxLQUFoQixDQUFzQixDQUF0QixFQUF5Qm83RixRQUF6QixFQUFtQ2xnRyxNQUFuQyxDQUEwQ3N6RSxNQUExQyxDQUFMLEVBQXdENHNCLFFBQXhELENBQXhCLEVBQ0M7Y0FBQ3YwQyxNQUFNLEVBQUUsUUFBVDtjQUFtQkYsTUFBTSxFQUFFO2FBRDVCLENBQVo7WUFFQW1GLEVBQUUsQ0FBQ2luQixjQUFILENBQWtCdGdFLEdBQWxCO1dBaEJGLE1BaUJPO1lBQ0wsSUFBSWlwRixRQUFRLEdBQUdQLFFBQWY7WUFDQSxJQUFJei9DLEtBQUssR0FBR3UvQyxZQUFZLENBQUNudkMsRUFBRCxFQUFLcjVDLEdBQUwsRUFBVThuRixRQUFRLENBQUNILElBQW5CLENBQXhCO1lBQ0EsSUFBSW5rRixNQUFNLEdBQUd5bEYsUUFBUSxDQUFDemxGLE1BQXRCO2dCQUE4QmtQLElBQTlCOztZQUNBLElBQUlpdUMsR0FBRyxDQUFDMVgsS0FBSyxDQUFDemxDLE1BQVAsRUFBZUEsTUFBZixDQUFILEdBQTRCLENBQWhDLEVBQW1DO2NBQ2pDa1AsSUFBSSxHQUFHdTJCLEtBQUssQ0FBQ3YyQixJQUFiO2NBQ0FsUCxNQUFNLEdBQUd1OUMsTUFBTSxDQUFDa29DLFFBQVEsQ0FBQ2hqRixJQUFULEVBQUQsRUFBa0JnakMsS0FBSyxDQUFDemxDLE1BQXhCLENBQWY7YUFGRixNQUdPO2NBQ0xrUCxJQUFJLEdBQUd1MkIsS0FBSyxDQUFDemxDLE1BQWI7Y0FDQUEsTUFBTSxHQUFHczlDLE1BQU0sQ0FBQ21vQyxRQUFRLENBQUN4L0UsRUFBVCxFQUFELEVBQWdCdy9CLEtBQUssQ0FBQ3YyQixJQUF0QixDQUFmOzs7WUFFRixJQUFJdzJFLFFBQVEsR0FBR04sUUFBUSxDQUFDN3NCLE1BQVQsQ0FBZ0J4dUUsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBZjtZQUNBMjdGLFFBQVEsQ0FBQ1AsUUFBRCxDQUFSLEdBQXFCUSxZQUFZLENBQUM5dkMsRUFBRCxFQUFLLElBQUlrMEIsS0FBSixDQUFVdHNCLFFBQU8sQ0FBQzFCLEdBQUQsRUFBTS83QyxNQUFOLENBQWpCLEVBQWdDa1AsSUFBaEMsQ0FBTCxDQUFqQztZQUNBZ2dFLFlBQVksQ0FBQ256QixHQUFELEVBQU1rdUIsa0JBQWtCLENBQUNwMEIsRUFBRCxFQUFLNnZDLFFBQUwsRUFBZVAsUUFBZixDQUF4QixFQUFrRHgwQyxTQUFsRCxDQUFaOzs7O1FBSUosSUFBSWkxQyxVQUFVLEdBQUc5NEYsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0J5dkIscUJBQWhCLEVBQWpCLENBcEZvRDs7Ozs7UUF5RnBELElBQUl4MUIsT0FBTyxHQUFHLENBQWQ7O1FBRUEsU0FBU2s0RCxNQUFULENBQWdCaGpGLENBQWhCLEVBQW1CO1VBQ2pCLElBQUltakcsUUFBUSxHQUFHLEVBQUVyNEUsT0FBakI7VUFDQSxJQUFJc2xDLEdBQUcsR0FBRzRqQixZQUFZLENBQUM3Z0IsRUFBRCxFQUFLbnpELENBQUwsRUFBUSxJQUFSLEVBQWM0aEcsUUFBUSxDQUFDSCxJQUFULElBQWlCLFdBQS9CLENBQXRCOztVQUNBLElBQUksQ0FBQ3J4QyxHQUFMLEVBQVU7WUFBRTs7O1VBQ1osSUFBSXFLLEdBQUcsQ0FBQ3JLLEdBQUQsRUFBTXV5QyxPQUFOLENBQUgsSUFBcUIsQ0FBekIsRUFBNEI7WUFDMUJ4dkMsRUFBRSxDQUFDTyxLQUFILENBQVM3TCxLQUFULEdBQWlCeUUsU0FBUyxFQUExQjtZQUNBczJDLFFBQVEsQ0FBQ3h5QyxHQUFELENBQVI7WUFDQSxJQUFJa3lCLE9BQU8sR0FBRzNJLFlBQVksQ0FBQ3Z2RSxPQUFELEVBQVVpdkQsR0FBVixDQUExQjs7WUFDQSxJQUFJakosR0FBRyxDQUFDbUMsSUFBSixJQUFZK3ZCLE9BQU8sQ0FBQy8rRCxFQUFwQixJQUEwQjZzQyxHQUFHLENBQUNtQyxJQUFKLEdBQVcrdkIsT0FBTyxDQUFDdmlFLElBQWpELEVBQ0U7Y0FBRWlNLFVBQVUsQ0FBQ2s1QixTQUFTLENBQUNpTyxFQUFELEVBQUssWUFBWTtnQkFBQyxJQUFJcm9DLE9BQU8sSUFBSXE0RSxRQUFmLEVBQXlCO2tCQUFFbmdCLE1BQU0sQ0FBQ2hqRixDQUFELENBQU47O2VBQTdDLENBQVYsRUFBdUUsR0FBdkUsQ0FBVjs7V0FMTixNQU1PO1lBQ0wsSUFBSWd5RSxPQUFPLEdBQUdoeUUsQ0FBQyxDQUFDeWdELE9BQUYsR0FBWXlpRCxVQUFVLENBQUN4aUQsR0FBdkIsR0FBNkIsQ0FBQyxFQUE5QixHQUFtQzFnRCxDQUFDLENBQUN5Z0QsT0FBRixHQUFZeWlELFVBQVUsQ0FBQzMxQixNQUF2QixHQUFnQyxFQUFoQyxHQUFxQyxDQUF0Rjs7WUFDQSxJQUFJeUUsT0FBSixFQUFhO2NBQUVobUQsVUFBVSxDQUFDazVCLFNBQVMsQ0FBQ2lPLEVBQUQsRUFBSyxZQUFZO2dCQUNsRCxJQUFJcm9DLE9BQU8sSUFBSXE0RSxRQUFmLEVBQXlCO2tCQUFFOzs7Z0JBQzNCLzRGLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCaUUsU0FBakIsSUFBOEJvQixPQUE5QjtnQkFDQWdSLE1BQU0sQ0FBQ2hqRixDQUFELENBQU47ZUFIaUMsQ0FBVixFQUlyQixFQUpxQixDQUFWOzs7OztRQVFuQixTQUFTOGIsSUFBVCxDQUFjOWIsQ0FBZCxFQUFpQjtVQUNmbXpELEVBQUUsQ0FBQzlwQixLQUFILENBQVM4M0QsYUFBVCxHQUF5QixLQUF6QjtVQUNBcjJFLE9BQU8sR0FBR3pYLFFBQVYsQ0FGZTs7OztVQU1mLElBQUlyVCxDQUFKLEVBQU87WUFDTDh6RCxnQkFBZ0IsQ0FBQzl6RCxDQUFELENBQWhCO1lBQ0FvSyxPQUFPLENBQUN1OEQsS0FBUixDQUFjOWUsS0FBZDs7O1VBRUZpTCxHQUFHLENBQUMxb0QsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0I0a0MsYUFBakIsRUFBZ0MsV0FBaEMsRUFBNkMydEMsSUFBN0MsQ0FBSDtVQUNBdHdDLEdBQUcsQ0FBQzFvRCxPQUFPLENBQUN5bUIsT0FBUixDQUFnQjRrQyxhQUFqQixFQUFnQyxTQUFoQyxFQUEyQzZxQyxFQUEzQyxDQUFIO1VBQ0FqbkMsR0FBRyxDQUFDNnhCLE9BQUosQ0FBWVosYUFBWixHQUE0QixJQUE1Qjs7O1FBR0YsSUFBSThZLElBQUksR0FBR2wrQyxTQUFTLENBQUNpTyxFQUFELEVBQUssVUFBVW56RCxDQUFWLEVBQWE7VUFDcEMsSUFBSUEsQ0FBQyxDQUFDcWpHLE9BQUYsS0FBYyxDQUFkLElBQW1CLENBQUNodkMsUUFBUSxDQUFDcjBELENBQUQsQ0FBaEMsRUFBcUM7WUFBRThiLElBQUksQ0FBQzliLENBQUQsQ0FBSjtXQUF2QyxNQUNLO1lBQUVnakYsTUFBTSxDQUFDaGpGLENBQUQsQ0FBTjs7U0FGVyxDQUFwQjtRQUlBLElBQUlzZ0csRUFBRSxHQUFHcDdDLFNBQVMsQ0FBQ2lPLEVBQUQsRUFBS3IzQyxJQUFMLENBQWxCO1FBQ0FxM0MsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzgzRCxhQUFULEdBQXlCYixFQUF6QjtRQUNBN3RDLEVBQUUsQ0FBQ3JvRCxPQUFPLENBQUN5bUIsT0FBUixDQUFnQjRrQyxhQUFqQixFQUFnQyxXQUFoQyxFQUE2QzJ0QyxJQUE3QyxDQUFGO1FBQ0Ezd0MsRUFBRSxDQUFDcm9ELE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCNGtDLGFBQWpCLEVBQWdDLFNBQWhDLEVBQTJDNnFDLEVBQTNDLENBQUY7T0FsNk9pQjs7OztNQXU2T25CLFNBQVMyQyxZQUFULENBQXNCOXZDLEVBQXRCLEVBQTBCcFEsS0FBMUIsRUFBaUM7UUFDL0IsSUFBSXpsQyxNQUFNLEdBQUd5bEMsS0FBSyxDQUFDemxDLE1BQW5CO1FBQ0EsSUFBSWtQLElBQUksR0FBR3UyQixLQUFLLENBQUN2MkIsSUFBakI7UUFDQSxJQUFJODJFLFVBQVUsR0FBR2xxQyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVMvN0MsTUFBTSxDQUFDaTFDLElBQWhCLENBQXhCOztRQUNBLElBQUlrSSxHQUFHLENBQUNuOUMsTUFBRCxFQUFTa1AsSUFBVCxDQUFILElBQXFCLENBQXJCLElBQTBCbFAsTUFBTSxDQUFDK0csTUFBUCxJQUFpQm1JLElBQUksQ0FBQ25JLE1BQXBELEVBQTREO1VBQUUsT0FBTzArQixLQUFQOzs7UUFDOUQsSUFBSWdOLEtBQUssR0FBR3VDLFFBQVEsQ0FBQ2d4QyxVQUFELENBQXBCOztRQUNBLElBQUksQ0FBQ3Z6QyxLQUFMLEVBQVk7VUFBRSxPQUFPaE4sS0FBUDs7O1FBQ2QsSUFBSS82QyxLQUFLLEdBQUdtb0QsYUFBYSxDQUFDSixLQUFELEVBQVF6eUMsTUFBTSxDQUFDbUwsRUFBZixFQUFtQm5MLE1BQU0sQ0FBQytHLE1BQTFCLENBQXpCO1lBQTREZ3FCLElBQUksR0FBRzBoQixLQUFLLENBQUMvbkQsS0FBRCxDQUF4RTs7UUFDQSxJQUFJcW1DLElBQUksQ0FBQ3R1QixJQUFMLElBQWF6QyxNQUFNLENBQUNtTCxFQUFwQixJQUEwQjRsQixJQUFJLENBQUM5cUIsRUFBTCxJQUFXakcsTUFBTSxDQUFDbUwsRUFBaEQsRUFBb0Q7VUFBRSxPQUFPczZCLEtBQVA7OztRQUN0RCxJQUFJd2dELFFBQVEsR0FBR3Y3RixLQUFLLElBQUtxbUMsSUFBSSxDQUFDdHVCLElBQUwsSUFBYXpDLE1BQU0sQ0FBQ21MLEVBQXJCLEtBQTZCNGxCLElBQUksQ0FBQzRoQixLQUFMLElBQWMsQ0FBM0MsSUFBZ0QsQ0FBaEQsR0FBb0QsQ0FBeEQsQ0FBcEI7O1FBQ0EsSUFBSXN6QyxRQUFRLElBQUksQ0FBWixJQUFpQkEsUUFBUSxJQUFJeHpDLEtBQUssQ0FBQ25zRCxNQUF2QyxFQUErQztVQUFFLE9BQU9tL0MsS0FBUDtTQVZsQjs7OztRQWMvQixJQUFJeXpCLFFBQUo7O1FBQ0EsSUFBSWhxRCxJQUFJLENBQUMrbEMsSUFBTCxJQUFhajFDLE1BQU0sQ0FBQ2kxQyxJQUF4QixFQUE4QjtVQUM1QmlrQixRQUFRLEdBQUcsQ0FBQ2hxRCxJQUFJLENBQUMrbEMsSUFBTCxHQUFZajFDLE1BQU0sQ0FBQ2kxQyxJQUFwQixLQUE2QlksRUFBRSxDQUFDa0csR0FBSCxDQUFPdEksU0FBUCxJQUFvQixLQUFwQixHQUE0QixDQUE1QixHQUFnQyxDQUFDLENBQTlELElBQW1FLENBQTlFO1NBREYsTUFFTztVQUNMLElBQUl5eUMsU0FBUyxHQUFHcnpDLGFBQWEsQ0FBQ0osS0FBRCxFQUFRdmpDLElBQUksQ0FBQy9ELEVBQWIsRUFBaUIrRCxJQUFJLENBQUNuSSxNQUF0QixDQUE3QjtVQUNBLElBQUlvckMsR0FBRyxHQUFHK3pDLFNBQVMsR0FBR3g3RixLQUFaLElBQXFCLENBQUN3a0IsSUFBSSxDQUFDL0QsRUFBTCxHQUFVbkwsTUFBTSxDQUFDbUwsRUFBbEIsS0FBeUI0bEIsSUFBSSxDQUFDNGhCLEtBQUwsSUFBYyxDQUFkLEdBQWtCLENBQUMsQ0FBbkIsR0FBdUIsQ0FBaEQsQ0FBL0I7O1VBQ0EsSUFBSXV6QyxTQUFTLElBQUlELFFBQVEsR0FBRyxDQUF4QixJQUE2QkMsU0FBUyxJQUFJRCxRQUE5QyxFQUNFO1lBQUUvc0IsUUFBUSxHQUFHL21CLEdBQUcsR0FBRyxDQUFqQjtXQURKLE1BR0U7WUFBRSttQixRQUFRLEdBQUcvbUIsR0FBRyxHQUFHLENBQWpCOzs7O1FBR04sSUFBSWcwQyxPQUFPLEdBQUcxekMsS0FBSyxDQUFDd3pDLFFBQVEsSUFBSS9zQixRQUFRLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBcEIsQ0FBVCxDQUFuQjtRQUNBLElBQUl6MkQsSUFBSSxHQUFHeTJELFFBQVEsS0FBS2l0QixPQUFPLENBQUN4ekMsS0FBUixJQUFpQixDQUF0QixDQUFuQjtRQUNBLElBQUl4bkMsRUFBRSxHQUFHMUksSUFBSSxHQUFHMGpGLE9BQU8sQ0FBQzFqRixJQUFYLEdBQWtCMGpGLE9BQU8sQ0FBQ2xnRixFQUF2QztZQUEyQ2MsTUFBTSxHQUFHdEUsSUFBSSxHQUFHLE9BQUgsR0FBYSxRQUFyRTtRQUNBLE9BQU96QyxNQUFNLENBQUNtTCxFQUFQLElBQWFBLEVBQWIsSUFBbUJuTCxNQUFNLENBQUMrRyxNQUFQLElBQWlCQSxNQUFwQyxHQUE2QzArQixLQUE3QyxHQUFxRCxJQUFJc2tDLEtBQUosQ0FBVSxJQUFJN3NCLEdBQUosQ0FBUWw5QyxNQUFNLENBQUNpMUMsSUFBZixFQUFxQjlwQyxFQUFyQixFQUF5QnBFLE1BQXpCLENBQVYsRUFBNENtSSxJQUE1QyxDQUE1RDtPQXA4T2lCOzs7O01BMDhPbkIsU0FBU2szRSxXQUFULENBQXFCdndDLEVBQXJCLEVBQXlCbnpELENBQXpCLEVBQTRCb0UsSUFBNUIsRUFBa0N1L0YsT0FBbEMsRUFBMkM7UUFDekMsSUFBSUMsRUFBSixFQUFRQyxFQUFSOztRQUNBLElBQUk3akcsQ0FBQyxDQUFDOGpHLE9BQU4sRUFBZTtVQUNiRixFQUFFLEdBQUc1akcsQ0FBQyxDQUFDOGpHLE9BQUYsQ0FBVSxDQUFWLEVBQWF2akQsT0FBbEI7VUFDQXNqRCxFQUFFLEdBQUc3akcsQ0FBQyxDQUFDOGpHLE9BQUYsQ0FBVSxDQUFWLEVBQWFyakQsT0FBbEI7U0FGRixNQUdPO1VBQ0wsSUFBSTtZQUFFbWpELEVBQUUsR0FBRzVqRyxDQUFDLENBQUN1Z0QsT0FBUDtZQUFnQnNqRCxFQUFFLEdBQUc3akcsQ0FBQyxDQUFDeWdELE9BQVA7V0FBdEIsQ0FDQSxPQUFNMHpCLEdBQU4sRUFBVztZQUFFLE9BQU8sS0FBUDs7OztRQUVmLElBQUl5dkIsRUFBRSxJQUFJcmtHLElBQUksQ0FBQ29JLEtBQUwsQ0FBV3dyRCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXc2hFLE9BQVgsQ0FBbUJwckIscUJBQW5CLEdBQTJDNlUsS0FBdEQsQ0FBVixFQUF3RTtVQUFFLE9BQU8sS0FBUDs7O1FBQzFFLElBQUl3dUMsT0FBSixFQUFhO1VBQUU3dkMsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoQjs7O1FBRWYsSUFBSW9LLE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBakI7UUFDQSxJQUFJMjVGLE9BQU8sR0FBRzM1RixPQUFPLENBQUNpdkUsT0FBUixDQUFnQi80QixxQkFBaEIsRUFBZDs7UUFFQSxJQUFJdWpELEVBQUUsR0FBR0UsT0FBTyxDQUFDeDJCLE1BQWIsSUFBdUIsQ0FBQzNaLFVBQVUsQ0FBQ1QsRUFBRCxFQUFLL3VELElBQUwsQ0FBdEMsRUFBa0Q7VUFBRSxPQUFPa3ZELGtCQUFrQixDQUFDdHpELENBQUQsQ0FBekI7OztRQUNwRDZqRyxFQUFFLElBQUlFLE9BQU8sQ0FBQ3JqRCxHQUFSLEdBQWN0MkMsT0FBTyxDQUFDNm1FLFVBQTVCOztRQUVBLEtBQUssSUFBSWpyRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbXRELEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtZ0UsV0FBWCxDQUF1QjNtRSxNQUEzQyxFQUFtRCxFQUFFb0MsQ0FBckQsRUFBd0Q7VUFDdEQsSUFBSWcrRixDQUFDLEdBQUc1NUYsT0FBTyxDQUFDc2hFLE9BQVIsQ0FBZ0IxN0IsVUFBaEIsQ0FBMkJocUMsQ0FBM0IsQ0FBUjs7VUFDQSxJQUFJZytGLENBQUMsSUFBSUEsQ0FBQyxDQUFDMWpELHFCQUFGLEdBQTBCNlUsS0FBMUIsSUFBbUN5dUMsRUFBNUMsRUFBZ0Q7WUFDOUMsSUFBSXJ4QyxJQUFJLEdBQUcwSCxhQUFZLENBQUM5RyxFQUFFLENBQUNrRyxHQUFKLEVBQVN3cUMsRUFBVCxDQUF2Qjs7WUFDQSxJQUFJbjZCLE1BQU0sR0FBR3ZXLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtZ0UsV0FBWCxDQUF1QnZrRSxDQUF2QixDQUFiO1lBQ0FndEQsTUFBTSxDQUFDRyxFQUFELEVBQUsvdUQsSUFBTCxFQUFXK3VELEVBQVgsRUFBZVosSUFBZixFQUFxQm1YLE1BQU0sQ0FBQ3BlLFNBQTVCLEVBQXVDdHJELENBQXZDLENBQU47WUFDQSxPQUFPc3pELGtCQUFrQixDQUFDdHpELENBQUQsQ0FBekI7Ozs7O01BS04sU0FBU2toRyxhQUFULENBQXVCL3RDLEVBQXZCLEVBQTJCbnpELENBQTNCLEVBQThCO1FBQzVCLE9BQU8wakcsV0FBVyxDQUFDdndDLEVBQUQsRUFBS256RCxDQUFMLEVBQVEsYUFBUixFQUF1QixJQUF2QixDQUFsQjtPQXgrT2lCOzs7Ozs7TUFnL09uQixTQUFTc2hHLGFBQVQsQ0FBdUJudUMsRUFBdkIsRUFBMkJuekQsQ0FBM0IsRUFBOEI7UUFDNUIsSUFBSTRyRSxhQUFhLENBQUN6WSxFQUFFLENBQUMvb0QsT0FBSixFQUFhcEssQ0FBYixDQUFiLElBQWdDaWtHLG1CQUFtQixDQUFDOXdDLEVBQUQsRUFBS256RCxDQUFMLENBQXZELEVBQWdFO1VBQUU7OztRQUNsRSxJQUFJa3pELGNBQWMsQ0FBQ0MsRUFBRCxFQUFLbnpELENBQUwsRUFBUSxhQUFSLENBQWxCLEVBQTBDO1VBQUU7OztRQUM1QyxJQUFJLENBQUNpckQsaUJBQUwsRUFBd0I7VUFBRWtJLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQjI2QixhQUFqQixDQUErQnRoRyxDQUEvQjs7OztNQUc1QixTQUFTaWtHLG1CQUFULENBQTZCOXdDLEVBQTdCLEVBQWlDbnpELENBQWpDLEVBQW9DO1FBQ2xDLElBQUksQ0FBQzR6RCxVQUFVLENBQUNULEVBQUQsRUFBSyxtQkFBTCxDQUFmLEVBQTBDO1VBQUUsT0FBTyxLQUFQOzs7UUFDNUMsT0FBT3V3QyxXQUFXLENBQUN2d0MsRUFBRCxFQUFLbnpELENBQUwsRUFBUSxtQkFBUixFQUE2QixLQUE3QixDQUFsQjs7O01BR0YsU0FBU2trRyxZQUFULENBQXNCL3dDLEVBQXRCLEVBQTBCO1FBQ3hCQSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVgsQ0FBbUJ5NkIsU0FBbkIsR0FBK0I2SCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVgsQ0FBbUJ5NkIsU0FBbkIsQ0FBNkIzNEMsT0FBN0IsQ0FBcUMsY0FBckMsRUFBcUQsRUFBckQsSUFDN0J3Z0QsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV3lULEtBQVgsQ0FBaUJodkMsT0FBakIsQ0FBeUIsWUFBekIsRUFBdUMsUUFBdkMsQ0FERjtRQUVBdTlELFdBQVcsQ0FBQy9jLEVBQUQsQ0FBWDs7O01BR0YsSUFBSWd4QyxJQUFJLEdBQUc7UUFBQ2hqRyxRQUFRLEVBQUUsb0JBQVU7VUFBQyxPQUFPLGlCQUFQOztPQUFqQztNQUVBLElBQUlpakcsUUFBUSxHQUFHLEVBQWY7TUFDQSxJQUFJQyxjQUFjLEdBQUcsRUFBckI7O01BRUEsU0FBU0MsYUFBVCxDQUF1Qm5PLFVBQXZCLEVBQW1DO1FBQ2pDLElBQUlrTyxjQUFjLEdBQUdsTyxVQUFVLENBQUNrTyxjQUFoQzs7UUFFQSxTQUFTN0MsTUFBVCxDQUFnQm45RixJQUFoQixFQUFzQmtnRyxLQUF0QixFQUE2Qm41RCxNQUE3QixFQUFxQ281RCxTQUFyQyxFQUFnRDtVQUM5Q3JPLFVBQVUsQ0FBQ2lPLFFBQVgsQ0FBb0IvL0YsSUFBcEIsSUFBNEJrZ0csS0FBNUI7O1VBQ0EsSUFBSW41RCxNQUFKLEVBQVk7WUFBRWk1RCxjQUFjLENBQUNoZ0csSUFBRCxDQUFkLEdBQ1ptZ0csU0FBUyxHQUFHLFVBQVVyeEMsRUFBVixFQUFjanlELEdBQWQsRUFBbUJ3MkMsR0FBbkIsRUFBd0I7Y0FBQyxJQUFJQSxHQUFHLElBQUl5c0QsSUFBWCxFQUFpQjtnQkFBRS80RCxNQUFNLENBQUMrbkIsRUFBRCxFQUFLanlELEdBQUwsRUFBVXcyQyxHQUFWLENBQU47O2FBQS9DLEdBQTBFdE0sTUFEdkU7Ozs7UUFJaEIrcUQsVUFBVSxDQUFDc08sWUFBWCxHQUEwQmpELE1BQTFCLENBVGlDOztRQVlqQ3JMLFVBQVUsQ0FBQ2dPLElBQVgsR0FBa0JBLElBQWxCLENBWmlDOzs7UUFnQmpDM0MsTUFBTSxDQUFDLE9BQUQsRUFBVSxFQUFWLEVBQWMsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUFFLE9BQU9peUQsRUFBRSxDQUFDZ2dDLFFBQUgsQ0FBWWp5RixHQUFaLENBQVA7U0FBbkMsRUFBK0QsSUFBL0QsQ0FBTjtRQUNBc2dHLE1BQU0sQ0FBQyxNQUFELEVBQVMsSUFBVCxFQUFlLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFDdENpeUQsRUFBRSxDQUFDa0csR0FBSCxDQUFPZ3ZCLFVBQVAsR0FBb0JubkYsR0FBcEI7VUFDQWtuRixRQUFRLENBQUNqMUIsRUFBRCxDQUFSO1NBRkksRUFHSCxJQUhHLENBQU47UUFLQXF1QyxNQUFNLENBQUMsWUFBRCxFQUFlLENBQWYsRUFBa0JwWixRQUFsQixFQUE0QixJQUE1QixDQUFOO1FBQ0FvWixNQUFNLENBQUMsZ0JBQUQsRUFBbUIsS0FBbkIsQ0FBTjtRQUNBQSxNQUFNLENBQUMsYUFBRCxFQUFnQixJQUFoQixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxTQUFELEVBQVksQ0FBWixFQUFlLFVBQVVydUMsRUFBVixFQUFjO1VBQ2pDbTFCLGNBQWMsQ0FBQ24xQixFQUFELENBQWQ7VUFDQStjLFdBQVcsQ0FBQy9jLEVBQUQsQ0FBWDtVQUNBa2hCLFNBQVMsQ0FBQ2xoQixFQUFELENBQVQ7U0FISSxFQUlILElBSkcsQ0FBTjtRQU1BcXVDLE1BQU0sQ0FBQyxlQUFELEVBQWtCLElBQWxCLEVBQXdCLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFDL0NpeUQsRUFBRSxDQUFDa0csR0FBSCxDQUFPMDVCLE9BQVAsR0FBaUI3eEYsR0FBakI7O1VBQ0EsSUFBSSxDQUFDQSxHQUFMLEVBQVU7WUFBRTs7O1VBQ1osSUFBSXdqRyxTQUFTLEdBQUcsRUFBaEI7Y0FBb0IzcUMsTUFBTSxHQUFHNUcsRUFBRSxDQUFDa0csR0FBSCxDQUFPdmxELEtBQXBDO1VBQ0FxL0MsRUFBRSxDQUFDa0csR0FBSCxDQUFPbjVDLElBQVAsQ0FBWSxVQUFVcXlDLElBQVYsRUFBZ0I7WUFDMUIsS0FBSyxJQUFJejRDLEdBQUcsR0FBRyxDQUFmLElBQW9CO2NBQ2xCLElBQUlrMkMsS0FBSyxHQUFHdUMsSUFBSSxDQUFDdlEsSUFBTCxDQUFVbmxDLE9BQVYsQ0FBa0IzYixHQUFsQixFQUF1QjRZLEdBQXZCLENBQVo7O2NBQ0EsSUFBSWsyQyxLQUFLLElBQUksQ0FBQyxDQUFkLEVBQWlCO2dCQUFFOzs7Y0FDbkJsMkMsR0FBRyxHQUFHazJDLEtBQUssR0FBRzl1RCxHQUFHLENBQUMwQyxNQUFsQjtjQUNBOGdHLFNBQVMsQ0FBQy9oRyxJQUFWLENBQWU2M0QsR0FBRyxDQUFDVCxNQUFELEVBQVMvSixLQUFULENBQWxCOzs7WUFFRitKLE1BQU07V0FQUjs7VUFTQSxLQUFLLElBQUkvekQsQ0FBQyxHQUFHMCtGLFNBQVMsQ0FBQzlnRyxNQUFWLEdBQW1CLENBQWhDLEVBQW1Db0MsQ0FBQyxJQUFJLENBQXhDLEVBQTJDQSxDQUFDLEVBQTVDLEVBQ0U7WUFBRTJwRixhQUFZLENBQUN4OEIsRUFBRSxDQUFDa0csR0FBSixFQUFTbjRELEdBQVQsRUFBY3dqRyxTQUFTLENBQUMxK0YsQ0FBRCxDQUF2QixFQUE0QncwRCxHQUFHLENBQUNrcUMsU0FBUyxDQUFDMStGLENBQUQsQ0FBVCxDQUFhdXNELElBQWQsRUFBb0JteUMsU0FBUyxDQUFDMStGLENBQUQsQ0FBVCxDQUFheWlCLEVBQWIsR0FBa0J2bkIsR0FBRyxDQUFDMEMsTUFBMUMsQ0FBL0IsQ0FBWjs7U0FkQSxDQUFOO1FBZ0JBNDlGLE1BQU0sQ0FBQyxjQUFELEVBQWlCLDRGQUFqQixFQUErRyxVQUFVcnVDLEVBQVYsRUFBY2p5RCxHQUFkLEVBQW1CdzJDLEdBQW5CLEVBQXdCO1VBQzNJeWIsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzA4QixZQUFULEdBQXdCLElBQUk1ekQsTUFBSixDQUFXalIsR0FBRyxDQUFDb0QsTUFBSixJQUFjcEQsR0FBRyxDQUFDc1AsSUFBSixDQUFTLElBQVQsSUFBaUIsRUFBakIsR0FBc0IsS0FBcEMsQ0FBWCxFQUF1RCxHQUF2RCxDQUF4Qjs7VUFDQSxJQUFJa25DLEdBQUcsSUFBSXlzRCxJQUFYLEVBQWlCO1lBQUVoeEMsRUFBRSxDQUFDd3hDLE9BQUg7O1NBRmYsQ0FBTjtRQUlBbkQsTUFBTSxDQUFDLHdCQUFELEVBQTJCLzdCLDZCQUEzQixFQUEwRCxVQUFVdFMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDd3hDLE9BQUgsRUFBUDtTQUExRSxFQUFrRyxJQUFsRyxDQUFOO1FBQ0FuRCxNQUFNLENBQUMsZUFBRCxFQUFrQixJQUFsQixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxZQUFELEVBQWU3MkMsTUFBTSxHQUFHLGlCQUFILEdBQXVCLFVBQTVDLEVBQXdELFlBQVk7VUFDeEUsTUFBTSxJQUFJcmhCLEtBQUosQ0FBVSx5REFBVixDQUFOLENBRHdFO1NBQXBFLEVBRUgsSUFGRyxDQUFOO1FBR0FrNEQsTUFBTSxDQUFDLFlBQUQsRUFBZSxLQUFmLEVBQXNCLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFBRSxPQUFPaXlELEVBQUUsQ0FBQ3l4QyxhQUFILEdBQW1CQyxVQUFuQixHQUFnQzNqRyxHQUF2QztTQUEzQyxFQUEwRixJQUExRixDQUFOO1FBQ0FzZ0csTUFBTSxDQUFDLGFBQUQsRUFBZ0IsS0FBaEIsRUFBdUIsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUFFLE9BQU9peUQsRUFBRSxDQUFDeXhDLGFBQUgsR0FBbUJFLFdBQW5CLEdBQWlDNWpHLEdBQXhDO1NBQTVDLEVBQTRGLElBQTVGLENBQU47UUFDQXNnRyxNQUFNLENBQUMsZ0JBQUQsRUFBbUIsS0FBbkIsRUFBMEIsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUFFLE9BQU9peUQsRUFBRSxDQUFDeXhDLGFBQUgsR0FBbUJHLGNBQW5CLEdBQW9DN2pHLEdBQTNDO1NBQS9DLEVBQWtHLElBQWxHLENBQU47UUFDQXNnRyxNQUFNLENBQUMsaUJBQUQsRUFBb0IsQ0FBQzEyQyxPQUFyQixDQUFOO1FBQ0EwMkMsTUFBTSxDQUFDLHVCQUFELEVBQTBCLElBQTFCLENBQU47UUFFQUEsTUFBTSxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLFVBQVVydUMsRUFBVixFQUFjO1VBQ3ZDK3dDLFlBQVksQ0FBQy93QyxFQUFELENBQVo7VUFDQWt5QixhQUFhLENBQUNseUIsRUFBRCxDQUFiO1NBRkksRUFHSCxJQUhHLENBQU47UUFJQXF1QyxNQUFNLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQncyQyxHQUFuQixFQUF3QjtVQUNsRCxJQUFJejlCLElBQUksR0FBRzYvRSxTQUFTLENBQUM1NEYsR0FBRCxDQUFwQjtVQUNBLElBQUlveEIsSUFBSSxHQUFHb2xCLEdBQUcsSUFBSXlzRCxJQUFQLElBQWVySyxTQUFTLENBQUNwaUQsR0FBRCxDQUFuQzs7VUFDQSxJQUFJcGxCLElBQUksSUFBSUEsSUFBSSxDQUFDMHlFLE1BQWpCLEVBQXlCO1lBQUUxeUUsSUFBSSxDQUFDMHlFLE1BQUwsQ0FBWTd4QyxFQUFaLEVBQWdCbDVDLElBQWhCOzs7VUFDM0IsSUFBSUEsSUFBSSxDQUFDZ3JGLE1BQVQsRUFBaUI7WUFBRWhyRixJQUFJLENBQUNnckYsTUFBTCxDQUFZOXhDLEVBQVosRUFBZ0I3Z0MsSUFBSSxJQUFJLElBQXhCOztTQUpmLENBQU47UUFNQWt2RSxNQUFNLENBQUMsV0FBRCxFQUFjLElBQWQsQ0FBTjtRQUNBQSxNQUFNLENBQUMsZ0JBQUQsRUFBbUIsSUFBbkIsQ0FBTjtRQUVBQSxNQUFNLENBQUMsY0FBRCxFQUFpQixLQUFqQixFQUF3QjBELGVBQXhCLEVBQXlDLElBQXpDLENBQU47UUFDQTFELE1BQU0sQ0FBQyxTQUFELEVBQVksRUFBWixFQUFnQixVQUFVcnVDLEVBQVYsRUFBY2p5RCxHQUFkLEVBQW1CO1VBQ3ZDaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtZ0UsV0FBWCxHQUF5QnlhLFVBQVUsQ0FBQzlqRixHQUFELEVBQU1peUQsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVys3QixXQUFqQixDQUFuQztVQUNBb2IsYUFBYSxDQUFDbHlCLEVBQUQsQ0FBYjtTQUZJLEVBR0gsSUFIRyxDQUFOO1FBSUFxdUMsTUFBTSxDQUFDLGFBQUQsRUFBZ0IsSUFBaEIsRUFBc0IsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUM3Q2l5RCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXc2hFLE9BQVgsQ0FBbUJ2aEUsS0FBbkIsQ0FBeUIyNEIsSUFBekIsR0FBZ0M1aEMsR0FBRyxHQUFHd3lFLG9CQUFvQixDQUFDdmdCLEVBQUUsQ0FBQy9vRCxPQUFKLENBQXBCLEdBQW1DLElBQXRDLEdBQTZDLEdBQWhGO1VBQ0Erb0QsRUFBRSxDQUFDd3hDLE9BQUg7U0FGSSxFQUdILElBSEcsQ0FBTjtRQUlBbkQsTUFBTSxDQUFDLDRCQUFELEVBQStCLEtBQS9CLEVBQXNDLFVBQVVydUMsRUFBVixFQUFjO1VBQUUsT0FBT3NyQixnQkFBZ0IsQ0FBQ3RyQixFQUFELENBQXZCO1NBQXRELEVBQXNGLElBQXRGLENBQU47UUFDQXF1QyxNQUFNLENBQUMsZ0JBQUQsRUFBbUIsUUFBbkIsRUFBNkIsVUFBVXJ1QyxFQUFWLEVBQWM7VUFDL0Nrc0IsY0FBYyxDQUFDbHNCLEVBQUQsQ0FBZDtVQUNBc3JCLGdCQUFnQixDQUFDdHJCLEVBQUQsQ0FBaEI7VUFDQUEsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV295RSxVQUFYLENBQXNCSixZQUF0QixDQUFtQ2pwQixFQUFFLENBQUNrRyxHQUFILENBQU91WCxTQUExQztVQUNBemQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV295RSxVQUFYLENBQXNCMUIsYUFBdEIsQ0FBb0MzbkIsRUFBRSxDQUFDa0csR0FBSCxDQUFPbVgsVUFBM0M7U0FKSSxFQUtILElBTEcsQ0FBTjtRQU1BZ3hCLE1BQU0sQ0FBQyxhQUFELEVBQWdCLEtBQWhCLEVBQXVCLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFDOUNpeUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV21nRSxXQUFYLEdBQXlCeWEsVUFBVSxDQUFDN3hCLEVBQUUsQ0FBQ2psQixPQUFILENBQVd3OUIsT0FBWixFQUFxQnhxRSxHQUFyQixDQUFuQztVQUNBbWtGLGFBQWEsQ0FBQ2x5QixFQUFELENBQWI7U0FGSSxFQUdILElBSEcsQ0FBTjtRQUlBcXVDLE1BQU0sQ0FBQyxpQkFBRCxFQUFvQixDQUFwQixFQUF1Qm5jLGFBQXZCLEVBQXNDLElBQXRDLENBQU47UUFDQW1jLE1BQU0sQ0FBQyxxQkFBRCxFQUF3QixVQUFVcjdDLE9BQVYsRUFBbUI7VUFBRSxPQUFPQSxPQUFQO1NBQTdDLEVBQWdFay9CLGFBQWhFLEVBQStFLElBQS9FLENBQU47UUFDQW1jLE1BQU0sQ0FBQyx5QkFBRCxFQUE0QixLQUE1QixFQUFtQ25zQixlQUFuQyxFQUFvRCxJQUFwRCxDQUFOO1FBRUFtc0IsTUFBTSxDQUFDLDZCQUFELEVBQWdDLElBQWhDLENBQU47UUFDQUEsTUFBTSxDQUFDLGlCQUFELEVBQW9CLElBQXBCLENBQU47UUFDQUEsTUFBTSxDQUFDLHdCQUFELEVBQTJCLElBQTNCLENBQU47UUFDQUEsTUFBTSxDQUFDLG9CQUFELEVBQXVCLEtBQXZCLENBQU47UUFFQUEsTUFBTSxDQUFDLFVBQUQsRUFBYSxLQUFiLEVBQW9CLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFDM0MsSUFBSUEsR0FBRyxJQUFJLFVBQVgsRUFBdUI7WUFDckJ1bUQsTUFBTSxDQUFDMEwsRUFBRCxDQUFOO1lBQ0FBLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQncrQixJQUFqQjs7O1VBRUZoeUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCeStCLGVBQWpCLENBQWlDbGtHLEdBQWpDO1NBTEksQ0FBTjtRQVFBc2dHLE1BQU0sQ0FBQyxtQkFBRCxFQUFzQixJQUF0QixFQUE0QixVQUFVcnVDLEVBQVYsRUFBY2p5RCxHQUFkLEVBQW1CO1VBQ25EQSxHQUFHLEdBQUlBLEdBQUcsS0FBSyxFQUFULEdBQWUsSUFBZixHQUFzQkEsR0FBNUI7VUFDQWl5RCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdThELEtBQVgsQ0FBaUIwK0Isd0JBQWpCLENBQTBDbmtHLEdBQTFDO1NBRkksQ0FBTjtRQUtBc2dHLE1BQU0sQ0FBQyxjQUFELEVBQWlCLEtBQWpCLEVBQXdCLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFBQyxJQUFJLENBQUNBLEdBQUwsRUFBVTtZQUFFaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQmg4QixLQUFqQjs7U0FBeEQsRUFBc0YsSUFBdEYsQ0FBTjtRQUNBNjJELE1BQU0sQ0FBQyxVQUFELEVBQWEsSUFBYixFQUFtQjhELGVBQW5CLENBQU47UUFDQTlELE1BQU0sQ0FBQyxvQkFBRCxFQUF1QixJQUF2QixDQUFOO1FBRUFBLE1BQU0sQ0FBQyxpQkFBRCxFQUFvQixHQUFwQixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxvQkFBRCxFQUF1QixDQUF2QixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxjQUFELEVBQWlCLENBQWpCLEVBQW9CbnNCLGVBQXBCLEVBQXFDLElBQXJDLENBQU47UUFDQW1zQixNQUFNLENBQUMsMkJBQUQsRUFBOEIsSUFBOUIsRUFBb0Nuc0IsZUFBcEMsRUFBcUQsSUFBckQsQ0FBTjtRQUNBbXNCLE1BQU0sQ0FBQyxVQUFELEVBQWEsR0FBYixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxXQUFELEVBQWMsR0FBZCxDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxjQUFELEVBQWlCLElBQWpCLEVBQXVCbFosY0FBdkIsRUFBdUMsSUFBdkMsQ0FBTjtRQUNBa1osTUFBTSxDQUFDLGNBQUQsRUFBaUIsS0FBakIsRUFBd0JsWixjQUF4QixFQUF3QyxJQUF4QyxDQUFOO1FBQ0FrWixNQUFNLENBQUMsY0FBRCxFQUFpQixHQUFqQixDQUFOO1FBQ0FBLE1BQU0sQ0FBQyxXQUFELEVBQWMsR0FBZCxFQUFtQixVQUFVcnVDLEVBQVYsRUFBY2p5RCxHQUFkLEVBQW1CO1VBQUUsT0FBT2l5RCxFQUFFLENBQUNrRyxHQUFILENBQU82eEIsT0FBUCxDQUFlbEIsU0FBZixHQUEyQjlvRixHQUFsQztTQUF4QyxDQUFOO1FBQ0FzZ0csTUFBTSxDQUFDLG1CQUFELEVBQXNCLElBQXRCLENBQU47UUFDQUEsTUFBTSxDQUFDLGdCQUFELEVBQW1CLEVBQW5CLEVBQXVCLFVBQVVydUMsRUFBVixFQUFjO1VBQUUsT0FBT0EsRUFBRSxDQUFDd3hDLE9BQUgsRUFBUDtTQUF2QyxFQUErRCxJQUEvRCxDQUFOO1FBQ0FuRCxNQUFNLENBQUMsb0JBQUQsRUFBdUIsS0FBdkIsRUFBOEJsWixjQUE5QixFQUE4QyxJQUE5QyxDQUFOO1FBQ0FrWixNQUFNLENBQUMscUJBQUQsRUFBd0IsSUFBeEIsRUFBOEIsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUNyRCxJQUFJLENBQUNBLEdBQUwsRUFBVTtZQUFFaXlELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQjQrQixhQUFqQjs7U0FEUixDQUFOO1FBSUEvRCxNQUFNLENBQUMsVUFBRCxFQUFhLElBQWIsRUFBbUIsVUFBVXJ1QyxFQUFWLEVBQWNqeUQsR0FBZCxFQUFtQjtVQUFFLE9BQU9peUQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3U4RCxLQUFYLENBQWlCdzVCLFFBQWpCLEdBQTRCN2lCLFFBQTVCLEdBQXVDcDhFLEdBQUcsSUFBSSxFQUFyRDtTQUF4QyxDQUFOO1FBQ0FzZ0csTUFBTSxDQUFDLFdBQUQsRUFBYyxJQUFkLENBQU47UUFDQUEsTUFBTSxDQUFDLFdBQUQsRUFBYyxLQUFkLEVBQXFCLFVBQVVydUMsRUFBVixFQUFjanlELEdBQWQsRUFBbUI7VUFBRSxPQUFPaXlELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT2s5QixZQUFQLENBQW9CcjFGLEdBQXBCLENBQVA7U0FBMUMsRUFBOEUsSUFBOUUsQ0FBTjtRQUNBc2dHLE1BQU0sQ0FBQyxTQUFELEVBQVksSUFBWixDQUFOOzs7TUFHRixTQUFTOEQsZUFBVCxDQUF5Qm55QyxFQUF6QixFQUE2QnZ4RCxLQUE3QixFQUFvQzgxQyxHQUFwQyxFQUF5QztRQUN2QyxJQUFJOHRELEtBQUssR0FBRzl0RCxHQUFHLElBQUlBLEdBQUcsSUFBSXlzRCxJQUExQjs7UUFDQSxJQUFJLENBQUN2aUcsS0FBRCxJQUFVLENBQUM0akcsS0FBZixFQUFzQjtVQUNwQixJQUFJQyxLQUFLLEdBQUd0eUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3M3RixhQUF2QjtVQUNBLElBQUl4NEUsTUFBTSxHQUFHdHJCLEtBQUssR0FBRzZ3RCxFQUFILEdBQVFLLEdBQTFCO1VBQ0E1bEMsTUFBTSxDQUFDaW1DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWixFQUFzQixXQUF0QixFQUFtQzg0QixLQUFLLENBQUN2a0YsS0FBekMsQ0FBTjtVQUNBZ00sTUFBTSxDQUFDaW1DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWixFQUFzQixXQUF0QixFQUFtQzg0QixLQUFLLENBQUMxNEUsS0FBekMsQ0FBTjtVQUNBRyxNQUFNLENBQUNpbUMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3VpRSxRQUFaLEVBQXNCLFVBQXRCLEVBQWtDODRCLEtBQUssQ0FBQ0UsSUFBeEMsQ0FBTjtVQUNBejRFLE1BQU0sQ0FBQ2ltQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXdWlFLFFBQVosRUFBc0IsV0FBdEIsRUFBbUM4NEIsS0FBSyxDQUFDRyxLQUF6QyxDQUFOO1VBQ0ExNEUsTUFBTSxDQUFDaW1DLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1aUUsUUFBWixFQUFzQixNQUF0QixFQUE4Qjg0QixLQUFLLENBQUNJLElBQXBDLENBQU47Ozs7TUFJSixTQUFTWCxlQUFULENBQXlCL3hDLEVBQXpCLEVBQTZCO1FBQzNCLElBQUlBLEVBQUUsQ0FBQ2psQixPQUFILENBQVdnL0IsWUFBZixFQUE2QjtVQUMzQjFnQixRQUFRLENBQUMyRyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeW1CLE9BQVosRUFBcUIsaUJBQXJCLENBQVI7VUFDQXNpQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXeWhFLEtBQVgsQ0FBaUIxaEUsS0FBakIsQ0FBdUJzekUsUUFBdkIsR0FBa0MsRUFBbEM7VUFDQXRxQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXc3NFLFVBQVgsR0FBd0IsSUFBeEI7U0FIRixNQUlPO1VBQ0x0ckIsT0FBTyxDQUFDK0gsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3ltQixPQUFaLEVBQXFCLGlCQUFyQixDQUFQO1VBQ0E4eUMsV0FBVyxDQUFDeFEsRUFBRCxDQUFYOzs7UUFFRjJnQixtQkFBbUIsQ0FBQzNnQixFQUFELENBQW5CO1FBQ0FraEIsU0FBUyxDQUFDbGhCLEVBQUQsQ0FBVDtRQUNBK2MsV0FBVyxDQUFDL2MsRUFBRCxDQUFYO1FBQ0FubkMsVUFBVSxDQUFDLFlBQVk7VUFBRSxPQUFPeXlELGdCQUFnQixDQUFDdHJCLEVBQUQsQ0FBdkI7U0FBZixFQUErQyxHQUEvQyxDQUFWO09BL3FQaUI7Ozs7TUFxclBuQixTQUFTZ2pDLFVBQVQsQ0FBb0JsbkIsS0FBcEIsRUFBMkIvZ0MsT0FBM0IsRUFBb0M7UUFDbEMsSUFBSStpRCxNQUFNLEdBQUcsSUFBYjs7UUFFQSxJQUFJLEVBQUUsZ0JBQWdCa0YsVUFBbEIsQ0FBSixFQUFtQztVQUFFLE9BQU8sSUFBSUEsVUFBSixDQUFlbG5CLEtBQWYsRUFBc0IvZ0MsT0FBdEIsQ0FBUDs7O1FBRXJDLEtBQUtBLE9BQUwsR0FBZUEsT0FBTyxHQUFHQSxPQUFPLEdBQUc4ZSxPQUFPLENBQUM5ZSxPQUFELENBQVYsR0FBc0IsRUFBdEQsQ0FMa0M7O1FBT2xDOGUsT0FBTyxDQUFDbzNDLFFBQUQsRUFBV2wyRCxPQUFYLEVBQW9CLEtBQXBCLENBQVA7UUFFQSxJQUFJbXJCLEdBQUcsR0FBR25yQixPQUFPLENBQUN0c0MsS0FBbEI7O1FBQ0EsSUFBSSxPQUFPeTNELEdBQVAsSUFBYyxRQUFsQixFQUE0QjtVQUFFQSxHQUFHLEdBQUcsSUFBSXk1QixHQUFKLENBQVF6NUIsR0FBUixFQUFhbnJCLE9BQU8sQ0FBQ3RyQyxJQUFyQixFQUEyQixJQUEzQixFQUFpQ3NyQyxPQUFPLENBQUNnbEQsYUFBekMsRUFBd0RobEQsT0FBTyxDQUFDNmlCLFNBQWhFLENBQU47U0FBOUIsTUFDSyxJQUFJN2lCLE9BQU8sQ0FBQ3RyQyxJQUFaLEVBQWtCO1VBQUV5MkQsR0FBRyxDQUFDZ3ZCLFVBQUosR0FBaUJuNkMsT0FBTyxDQUFDdHJDLElBQXpCOzs7UUFDekIsS0FBS3kyRCxHQUFMLEdBQVdBLEdBQVg7UUFFQSxJQUFJc04sS0FBSyxHQUFHLElBQUl3dkIsVUFBVSxDQUFDMlAsV0FBWCxDQUF1QjUzRCxPQUFPLENBQUM2M0QsVUFBL0IsQ0FBSixDQUErQyxJQUEvQyxDQUFaO1FBQ0EsSUFBSTM3RixPQUFPLEdBQUcsS0FBS0EsT0FBTCxHQUFlLElBQUlrN0UsT0FBSixDQUFZclcsS0FBWixFQUFtQjVWLEdBQW5CLEVBQXdCc04sS0FBeEIsRUFBK0J6NEIsT0FBL0IsQ0FBN0I7UUFDQTlqQyxPQUFPLENBQUN5bUIsT0FBUixDQUFnQnNsRSxVQUFoQixHQUE2QixJQUE3QjtRQUNBK04sWUFBWSxDQUFDLElBQUQsQ0FBWjs7UUFDQSxJQUFJaDJELE9BQU8sQ0FBQ2cvQixZQUFaLEVBQ0U7VUFBRSxLQUFLOWlFLE9BQUwsQ0FBYXltQixPQUFiLENBQXFCeTZCLFNBQXJCLElBQWtDLGtCQUFsQzs7O1FBQ0orekIsY0FBYyxDQUFDLElBQUQsQ0FBZDtRQUVBLEtBQUtoMkMsS0FBTCxHQUFhO1VBQ1htMkQsT0FBTyxFQUFFLEVBREU7O1VBRVhwakMsUUFBUSxFQUFFLEVBRkM7O1VBR1hMLE9BQU8sRUFBRSxDQUhFOztVQUlYOU8sU0FBUyxFQUFFLEtBSkE7VUFLWDZyQixpQkFBaUIsRUFBRSxLQUxSO1VBTVhULE9BQU8sRUFBRSxLQU5FO1VBT1hvVyxhQUFhLEVBQUUsS0FQSjs7VUFRWHVYLGFBQWEsRUFBRSxDQUFDLENBUkw7VUFRUUMsV0FBVyxFQUFFLENBQUMsQ0FSdEI7O1VBU1g5RSxhQUFhLEVBQUUsS0FUSjtVQVVYcG9CLFlBQVksRUFBRSxLQVZIO1VBV1g0SSxTQUFTLEVBQUUsSUFBSW4wQixPQUFKLEVBWEE7O1VBWVhxeUMsTUFBTSxFQUFFLElBWkc7O1VBYVg5NUIsWUFBWSxFQUFFO1NBYmhCOztRQWdCQSxJQUFJNzNCLE9BQU8sQ0FBQ2c0RCxTQUFSLElBQXFCLENBQUN2N0MsTUFBMUIsRUFBa0M7VUFBRXZnRCxPQUFPLENBQUN1OEQsS0FBUixDQUFjOWUsS0FBZDtTQXRDRjs7OztRQTBDbEMsSUFBSWdDLEVBQUUsSUFBSUMsVUFBVSxHQUFHLEVBQXZCLEVBQTJCO1VBQUU5OUIsVUFBVSxDQUFDLFlBQVk7WUFBRSxPQUFPaWxFLE1BQU0sQ0FBQzdtRixPQUFQLENBQWV1OEQsS0FBZixDQUFxQmg4QixLQUFyQixDQUEyQixJQUEzQixDQUFQO1dBQWYsRUFBMkQsRUFBM0QsQ0FBVjs7O1FBRTdCdzdELHFCQUFxQixDQUFDLElBQUQsQ0FBckI7UUFDQXpOLG9CQUFvQjs7UUFFcEJqWixlQUFjLENBQUMsSUFBRCxDQUFkOztRQUNBLEtBQUsvckIsS0FBTCxDQUFXd2EsV0FBWCxHQUF5QixJQUF6QjtRQUNBeWIsU0FBUyxDQUFDLElBQUQsRUFBT3R3QixHQUFQLENBQVQ7O1FBRUEsSUFBS25yQixPQUFPLENBQUNnNEQsU0FBUixJQUFxQixDQUFDdjdDLE1BQXZCLElBQWtDLEtBQUtndUIsUUFBTCxFQUF0QyxFQUNFO1VBQUUzc0QsVUFBVSxDQUFDLFlBQVk7WUFDdkIsSUFBSWlsRSxNQUFNLENBQUN0WSxRQUFQLE1BQXFCLENBQUNzWSxNQUFNLENBQUM1bkQsS0FBUCxDQUFhZ3ZDLE9BQXZDLEVBQWdEO2NBQUU3d0IsT0FBTyxDQUFDeXBDLE1BQUQsQ0FBUDs7V0FEeEMsRUFFVCxFQUZTLENBQVY7U0FESixNQUtFO1VBQUV4cEMsTUFBTSxDQUFDLElBQUQsQ0FBTjs7O1FBRUosS0FBSyxJQUFJc3BDLEdBQVQsSUFBZ0JzVCxjQUFoQixFQUFnQztVQUFFLElBQUlBLGNBQWMsQ0FBQzFrRyxjQUFmLENBQThCb3hGLEdBQTlCLENBQUosRUFDaEM7WUFBRXNULGNBQWMsQ0FBQ3RULEdBQUQsQ0FBZCxDQUFvQixJQUFwQixFQUEwQjdpRCxPQUFPLENBQUM2aUQsR0FBRCxDQUFqQyxFQUF3Q29ULElBQXhDOzs7O1FBQ0p6Z0IsMEJBQTBCLENBQUMsSUFBRCxDQUExQjs7UUFDQSxJQUFJeDFDLE9BQU8sQ0FBQ2s0RCxVQUFaLEVBQXdCO1VBQUVsNEQsT0FBTyxDQUFDazRELFVBQVIsQ0FBbUIsSUFBbkI7OztRQUMxQixLQUFLLElBQUlwZ0csQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FnRyxTQUFTLENBQUN6aUcsTUFBOUIsRUFBc0MsRUFBRW9DLENBQXhDLEVBQTJDO1VBQUVxZ0csU0FBUyxDQUFDcmdHLENBQUQsQ0FBVCxDQUFhLElBQWI7OztRQUM3Q2c2RSxhQUFZLENBQUMsSUFBRCxDQUFaLENBL0RrQzs7OztRQWtFbEMsSUFBSWgyQixNQUFNLElBQUk5YixPQUFPLENBQUNnL0IsWUFBbEIsSUFDQWIsZ0JBQWdCLENBQUNqaUUsT0FBTyxDQUFDaXZFLE9BQVQsQ0FBaEIsQ0FBa0NpdEIsYUFBbEMsSUFBbUQsb0JBRHZELEVBRUU7VUFBRWw4RixPQUFPLENBQUNpdkUsT0FBUixDQUFnQmx2RSxLQUFoQixDQUFzQm04RixhQUF0QixHQUFzQyxNQUF0Qzs7T0F6dlBhOzs7TUE2dlBuQm5RLFVBQVUsQ0FBQ2lPLFFBQVgsR0FBc0JBLFFBQXRCLENBN3ZQbUI7O01BK3ZQbkJqTyxVQUFVLENBQUNrTyxjQUFYLEdBQTRCQSxjQUE1QixDQS92UG1COztNQWt3UG5CLFNBQVM4QixxQkFBVCxDQUErQmh6QyxFQUEvQixFQUFtQztRQUNqQyxJQUFJcDBDLENBQUMsR0FBR28wQyxFQUFFLENBQUMvb0QsT0FBWDtRQUNBcW9ELEVBQUUsQ0FBQzF6QyxDQUFDLENBQUM0dEQsUUFBSCxFQUFhLFdBQWIsRUFBMEJ6bkIsU0FBUyxDQUFDaU8sRUFBRCxFQUFLNnRDLFdBQUwsQ0FBbkMsQ0FBRixDQUZpQzs7UUFJakMsSUFBSW4zQyxFQUFFLElBQUlDLFVBQVUsR0FBRyxFQUF2QixFQUNFO1VBQUUySSxFQUFFLENBQUMxekMsQ0FBQyxDQUFDNHRELFFBQUgsRUFBYSxVQUFiLEVBQXlCem5CLFNBQVMsQ0FBQ2lPLEVBQUQsRUFBSyxVQUFVbnpELENBQVYsRUFBYTtZQUN0RCxJQUFJa3pELGNBQWMsQ0FBQ0MsRUFBRCxFQUFLbnpELENBQUwsQ0FBbEIsRUFBMkI7Y0FBRTs7O1lBQzdCLElBQUk4WixHQUFHLEdBQUdrNkQsWUFBWSxDQUFDN2dCLEVBQUQsRUFBS256RCxDQUFMLENBQXRCOztZQUNBLElBQUksQ0FBQzhaLEdBQUQsSUFBUW9uRixhQUFhLENBQUMvdEMsRUFBRCxFQUFLbnpELENBQUwsQ0FBckIsSUFBZ0M0ckUsYUFBYSxDQUFDelksRUFBRSxDQUFDL29ELE9BQUosRUFBYXBLLENBQWIsQ0FBakQsRUFBa0U7Y0FBRTs7O1lBQ3BFOHpELGdCQUFnQixDQUFDOXpELENBQUQsQ0FBaEI7WUFDQSxJQUFJdW1HLElBQUksR0FBR3B6QyxFQUFFLENBQUNvdkMsVUFBSCxDQUFjem9GLEdBQWQsQ0FBWDtZQUNBeXlFLGVBQWUsQ0FBQ3A1QixFQUFFLENBQUNrRyxHQUFKLEVBQVNrdEMsSUFBSSxDQUFDanBGLE1BQWQsRUFBc0JpcEYsSUFBSSxDQUFDLzVFLElBQTNCLENBQWY7V0FOb0MsQ0FBbEMsQ0FBRjtTQURKLE1BVUU7VUFBRWltQyxFQUFFLENBQUMxekMsQ0FBQyxDQUFDNHRELFFBQUgsRUFBYSxVQUFiLEVBQXlCLFVBQVUzc0UsQ0FBVixFQUFhO1lBQUUsT0FBT2t6RCxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQWQsSUFBeUI4ekQsZ0JBQWdCLENBQUM5ekQsQ0FBRCxDQUFoRDtXQUF4QyxDQUFGO1NBZDZCOzs7OztRQWtCakN5eUQsRUFBRSxDQUFDMXpDLENBQUMsQ0FBQzR0RCxRQUFILEVBQWEsYUFBYixFQUE0QixVQUFVM3NFLENBQVYsRUFBYTtVQUFFLE9BQU9zaEcsYUFBYSxDQUFDbnVDLEVBQUQsRUFBS256RCxDQUFMLENBQXBCO1NBQTNDLENBQUY7UUFDQXl5RCxFQUFFLENBQUMxekMsQ0FBQyxDQUFDNG5ELEtBQUYsQ0FBUXc1QixRQUFSLEVBQUQsRUFBcUIsYUFBckIsRUFBb0MsVUFBVW5nRyxDQUFWLEVBQWE7VUFDakQsSUFBSSxDQUFDK2UsQ0FBQyxDQUFDNHRELFFBQUYsQ0FBV3ZnQixRQUFYLENBQW9CcHNELENBQUMsQ0FBQytFLE1BQXRCLENBQUwsRUFBb0M7WUFBRXU4RixhQUFhLENBQUNudUMsRUFBRCxFQUFLbnpELENBQUwsQ0FBYjs7U0FEdEMsQ0FBRixDQW5CaUM7O1FBd0JqQyxJQUFJd21HLGFBQUo7WUFBbUJDLFNBQVMsR0FBRztVQUFDaHFGLEdBQUcsRUFBRTtTQUFyQzs7UUFDQSxTQUFTaXFGLFdBQVQsR0FBdUI7VUFDckIsSUFBSTNuRixDQUFDLENBQUMybUUsV0FBTixFQUFtQjtZQUNqQjhnQixhQUFhLEdBQUd4NkUsVUFBVSxDQUFDLFlBQVk7Y0FBRSxPQUFPak4sQ0FBQyxDQUFDMm1FLFdBQUYsR0FBZ0IsSUFBdkI7YUFBZixFQUErQyxJQUEvQyxDQUExQjtZQUNBK2dCLFNBQVMsR0FBRzFuRixDQUFDLENBQUMybUUsV0FBZDtZQUNBK2dCLFNBQVMsQ0FBQ2hxRixHQUFWLEdBQWdCLENBQUMsSUFBSThCLElBQUosRUFBakI7Ozs7UUFHSixTQUFTb29GLHFCQUFULENBQStCM21HLENBQS9CLEVBQWtDO1VBQ2hDLElBQUlBLENBQUMsQ0FBQzhqRyxPQUFGLENBQVVsZ0csTUFBVixJQUFvQixDQUF4QixFQUEyQjtZQUFFLE9BQU8sS0FBUDs7O1VBQzdCLElBQUlxOEMsS0FBSyxHQUFHamdELENBQUMsQ0FBQzhqRyxPQUFGLENBQVUsQ0FBVixDQUFaO1VBQ0EsT0FBTzdqRCxLQUFLLENBQUMybUQsT0FBTixJQUFpQixDQUFqQixJQUFzQjNtRCxLQUFLLENBQUM0bUQsT0FBTixJQUFpQixDQUE5Qzs7O1FBRUYsU0FBU0MsT0FBVCxDQUFpQjdtRCxLQUFqQixFQUF3QjR4QixLQUF4QixFQUErQjtVQUM3QixJQUFJQSxLQUFLLENBQUMvdUMsSUFBTixJQUFjLElBQWxCLEVBQXdCO1lBQUUsT0FBTyxJQUFQOzs7VUFDMUIsSUFBSXllLEVBQUUsR0FBR3N3QixLQUFLLENBQUMvdUMsSUFBTixHQUFhbWQsS0FBSyxDQUFDbmQsSUFBNUI7Y0FBa0MwZSxFQUFFLEdBQUdxd0IsS0FBSyxDQUFDbnhCLEdBQU4sR0FBWVQsS0FBSyxDQUFDUyxHQUF6RDtVQUNBLE9BQU9hLEVBQUUsR0FBR0EsRUFBTCxHQUFVQyxFQUFFLEdBQUdBLEVBQWYsR0FBb0IsS0FBSyxFQUFoQzs7O1FBRUZpUixFQUFFLENBQUMxekMsQ0FBQyxDQUFDNHRELFFBQUgsRUFBYSxZQUFiLEVBQTJCLFVBQVUzc0UsQ0FBVixFQUFhO1VBQ3hDLElBQUksQ0FBQ2t6RCxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQWYsSUFBMEIsQ0FBQzJtRyxxQkFBcUIsQ0FBQzNtRyxDQUFELENBQWhELElBQXVELENBQUNraEcsYUFBYSxDQUFDL3RDLEVBQUQsRUFBS256RCxDQUFMLENBQXpFLEVBQWtGO1lBQ2hGK2UsQ0FBQyxDQUFDNG5ELEtBQUYsQ0FBUTA0QixZQUFSO1lBQ0ExeEMsWUFBWSxDQUFDNjRDLGFBQUQsQ0FBWjtZQUNBLElBQUlsb0YsR0FBRyxHQUFHLENBQUMsSUFBSUMsSUFBSixFQUFYO1lBQ0FRLENBQUMsQ0FBQzJtRSxXQUFGLEdBQWdCO2NBQUN4a0UsS0FBSyxFQUFFNUMsR0FBUjtjQUFhMmpGLEtBQUssRUFBRSxLQUFwQjtjQUNDM3ZFLElBQUksRUFBRWhVLEdBQUcsR0FBR21vRixTQUFTLENBQUNocUYsR0FBaEIsSUFBdUIsR0FBdkIsR0FBNkJncUYsU0FBN0IsR0FBeUM7YUFEaEU7O1lBRUEsSUFBSXptRyxDQUFDLENBQUM4akcsT0FBRixDQUFVbGdHLE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7Y0FDekJtYixDQUFDLENBQUMybUUsV0FBRixDQUFjNWlELElBQWQsR0FBcUI5aUMsQ0FBQyxDQUFDOGpHLE9BQUYsQ0FBVSxDQUFWLEVBQWFpRCxLQUFsQztjQUNBaG9GLENBQUMsQ0FBQzJtRSxXQUFGLENBQWNobEMsR0FBZCxHQUFvQjFnRCxDQUFDLENBQUM4akcsT0FBRixDQUFVLENBQVYsRUFBYWtELEtBQWpDOzs7U0FUSixDQUFGO1FBYUF2MEMsRUFBRSxDQUFDMXpDLENBQUMsQ0FBQzR0RCxRQUFILEVBQWEsV0FBYixFQUEwQixZQUFZO1VBQ3RDLElBQUk1dEQsQ0FBQyxDQUFDMm1FLFdBQU4sRUFBbUI7WUFBRTNtRSxDQUFDLENBQUMybUUsV0FBRixDQUFjdWMsS0FBZCxHQUFzQixJQUF0Qjs7U0FEckIsQ0FBRjtRQUdBeHZDLEVBQUUsQ0FBQzF6QyxDQUFDLENBQUM0dEQsUUFBSCxFQUFhLFVBQWIsRUFBeUIsVUFBVTNzRSxDQUFWLEVBQWE7VUFDdEMsSUFBSWlnRCxLQUFLLEdBQUdsaEMsQ0FBQyxDQUFDMm1FLFdBQWQ7O1VBQ0EsSUFBSXpsQyxLQUFLLElBQUksQ0FBQzJyQixhQUFhLENBQUM3c0QsQ0FBRCxFQUFJL2UsQ0FBSixDQUF2QixJQUFpQ2lnRCxLQUFLLENBQUNuZCxJQUFOLElBQWMsSUFBL0MsSUFDQSxDQUFDbWQsS0FBSyxDQUFDZ2lELEtBRFAsSUFDZ0IsSUFBSTFqRixJQUFKLEtBQVcwaEMsS0FBSyxDQUFDLytCLEtBQWpCLEdBQXlCLEdBRDdDLEVBQ2tEO1lBQ2hELElBQUlwSCxHQUFHLEdBQUdxNUMsRUFBRSxDQUFDK2UsVUFBSCxDQUFjbnpELENBQUMsQ0FBQzJtRSxXQUFoQixFQUE2QixNQUE3QixDQUFWO2dCQUFnRDNpQyxLQUFoRDs7WUFDQSxJQUFJLENBQUM5QyxLQUFLLENBQUMzdEIsSUFBUCxJQUFldzBFLE9BQU8sQ0FBQzdtRCxLQUFELEVBQVFBLEtBQUssQ0FBQzN0QixJQUFkLENBQTFCO2NBQ0U7Z0JBQUV5d0IsS0FBSyxHQUFHLElBQUlza0MsS0FBSixDQUFVdnRFLEdBQVYsRUFBZUEsR0FBZixDQUFSO2VBREosTUFFSyxJQUFJLENBQUNtbUMsS0FBSyxDQUFDM3RCLElBQU4sQ0FBV0EsSUFBWixJQUFvQncwRSxPQUFPLENBQUM3bUQsS0FBRCxFQUFRQSxLQUFLLENBQUMzdEIsSUFBTixDQUFXQSxJQUFuQixDQUEvQjtjQUNIO2dCQUFFeXdCLEtBQUssR0FBR29RLEVBQUUsQ0FBQ292QyxVQUFILENBQWN6b0YsR0FBZCxDQUFSO2VBREM7Y0FHSDtnQkFBRWlwQyxLQUFLLEdBQUcsSUFBSXNrQyxLQUFKLENBQVU3c0IsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFMLEVBQVcsQ0FBWCxDQUFiLEVBQTRCd0ksUUFBTyxDQUFDNUgsRUFBRSxDQUFDa0csR0FBSixFQUFTbUIsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFKLEdBQVcsQ0FBWixFQUFlLENBQWYsQ0FBWixDQUFuQyxDQUFSOzs7WUFDSlksRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0J6cEMsS0FBSyxDQUFDemxDLE1BQXRCLEVBQThCeWxDLEtBQUssQ0FBQ3YyQixJQUFwQztZQUNBMm1DLEVBQUUsQ0FBQ3RMLEtBQUg7WUFDQWlNLGdCQUFnQixDQUFDOXpELENBQUQsQ0FBaEI7OztVQUVGMG1HLFdBQVc7U0FmWCxDQUFGO1FBaUJBajBDLEVBQUUsQ0FBQzF6QyxDQUFDLENBQUM0dEQsUUFBSCxFQUFhLGFBQWIsRUFBNEIrNUIsV0FBNUIsQ0FBRixDQTNFaUM7OztRQStFakNqMEMsRUFBRSxDQUFDMXpDLENBQUMsQ0FBQzR0RCxRQUFILEVBQWEsUUFBYixFQUF1QixZQUFZO1VBQ25DLElBQUk1dEQsQ0FBQyxDQUFDNHRELFFBQUYsQ0FBV0csWUFBZixFQUE2QjtZQUMzQitOLGVBQWUsQ0FBQzFuQixFQUFELEVBQUtwMEMsQ0FBQyxDQUFDNHRELFFBQUYsQ0FBV2lFLFNBQWhCLENBQWY7WUFDQWtLLGFBQWEsQ0FBQzNuQixFQUFELEVBQUtwMEMsQ0FBQyxDQUFDNHRELFFBQUYsQ0FBVzZELFVBQWhCLEVBQTRCLElBQTVCLENBQWI7WUFDQXhkLE1BQU0sQ0FBQ0csRUFBRCxFQUFLLFFBQUwsRUFBZUEsRUFBZixDQUFOOztTQUpGLENBQUYsQ0EvRWlDOztRQXdGakNWLEVBQUUsQ0FBQzF6QyxDQUFDLENBQUM0dEQsUUFBSCxFQUFhLFlBQWIsRUFBMkIsVUFBVTNzRSxDQUFWLEVBQWE7VUFBRSxPQUFPcW1GLGFBQWEsQ0FBQ2x6QixFQUFELEVBQUtuekQsQ0FBTCxDQUFwQjtTQUExQyxDQUFGO1FBQ0F5eUQsRUFBRSxDQUFDMXpDLENBQUMsQ0FBQzR0RCxRQUFILEVBQWEsZ0JBQWIsRUFBK0IsVUFBVTNzRSxDQUFWLEVBQWE7VUFBRSxPQUFPcW1GLGFBQWEsQ0FBQ2x6QixFQUFELEVBQUtuekQsQ0FBTCxDQUFwQjtTQUE5QyxDQUFGLENBekZpQzs7UUE0RmpDeXlELEVBQUUsQ0FBQzF6QyxDQUFDLENBQUM4UixPQUFILEVBQVksUUFBWixFQUFzQixZQUFZO1VBQUUsT0FBTzlSLENBQUMsQ0FBQzhSLE9BQUYsQ0FBVSsvQyxTQUFWLEdBQXNCN3hELENBQUMsQ0FBQzhSLE9BQUYsQ0FBVTIvQyxVQUFWLEdBQXVCLENBQXBEO1NBQXBDLENBQUY7UUFFQXp4RCxDQUFDLENBQUMybUYsYUFBRixHQUFrQjtVQUNoQjM0RSxLQUFLLEVBQUUsZUFBVS9zQixDQUFWLEVBQWE7WUFBQyxJQUFJLENBQUNrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFuQixFQUE0QjtjQUFFazBELE1BQU0sQ0FBQ2wwRCxDQUFELENBQU47O1dBRG5DO1VBRWhCMmxHLElBQUksRUFBRSxjQUFVM2xHLENBQVYsRUFBYTtZQUFDLElBQUksQ0FBQ2t6RCxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQW5CLEVBQTRCO2NBQUVrNEYsVUFBVSxDQUFDL2tDLEVBQUQsRUFBS256RCxDQUFMLENBQVY7Y0FBbUJrMEQsTUFBTSxDQUFDbDBELENBQUQsQ0FBTjs7V0FGckQ7VUFHaEJraEIsS0FBSyxFQUFFLGVBQVVsaEIsQ0FBVixFQUFhO1lBQUUsT0FBTzQzRixXQUFXLENBQUN6a0MsRUFBRCxFQUFLbnpELENBQUwsQ0FBbEI7V0FITjtVQUloQjZsRyxJQUFJLEVBQUUzZ0QsU0FBUyxDQUFDaU8sRUFBRCxFQUFLdWpDLE1BQUwsQ0FKQztVQUtoQmtQLEtBQUssRUFBRSxlQUFVNWxHLENBQVYsRUFBYTtZQUFDLElBQUksQ0FBQ2t6RCxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQW5CLEVBQTRCO2NBQUUyMkYsZUFBZSxDQUFDeGpDLEVBQUQsQ0FBZjs7O1NBTHJEO1FBUUEsSUFBSTh6QyxHQUFHLEdBQUdsb0YsQ0FBQyxDQUFDNG5ELEtBQUYsQ0FBUXc1QixRQUFSLEVBQVY7UUFDQTF0QyxFQUFFLENBQUN3MEMsR0FBRCxFQUFNLE9BQU4sRUFBZSxVQUFVam5HLENBQVYsRUFBYTtVQUFFLE9BQU91Z0csT0FBTyxDQUFDemdHLElBQVIsQ0FBYXF6RCxFQUFiLEVBQWlCbnpELENBQWpCLENBQVA7U0FBOUIsQ0FBRjtRQUNBeXlELEVBQUUsQ0FBQ3cwQyxHQUFELEVBQU0sU0FBTixFQUFpQi9oRCxTQUFTLENBQUNpTyxFQUFELEVBQUtqTSxTQUFMLENBQTFCLENBQUY7UUFDQXVMLEVBQUUsQ0FBQ3cwQyxHQUFELEVBQU0sVUFBTixFQUFrQi9oRCxTQUFTLENBQUNpTyxFQUFELEVBQUtxdEMsVUFBTCxDQUEzQixDQUFGO1FBQ0EvdEMsRUFBRSxDQUFDdzBDLEdBQUQsRUFBTSxPQUFOLEVBQWUsVUFBVWpuRyxDQUFWLEVBQWE7VUFBRSxPQUFPd25ELE9BQU8sQ0FBQzJMLEVBQUQsRUFBS256RCxDQUFMLENBQWQ7U0FBOUIsQ0FBRjtRQUNBeXlELEVBQUUsQ0FBQ3cwQyxHQUFELEVBQU0sTUFBTixFQUFjLFVBQVVqbkcsQ0FBVixFQUFhO1VBQUUsT0FBT3luRCxNQUFNLENBQUMwTCxFQUFELEVBQUtuekQsQ0FBTCxDQUFiO1NBQTdCLENBQUY7OztNQUdGLElBQUlxbUcsU0FBUyxHQUFHLEVBQWhCOztNQUNBbFEsVUFBVSxDQUFDK1EsY0FBWCxHQUE0QixVQUFVaGxHLENBQVYsRUFBYTtRQUFFLE9BQU9ta0csU0FBUyxDQUFDMWpHLElBQVYsQ0FBZVQsQ0FBZixDQUFQO09BQTNDLENBajNQbUI7Ozs7Ozs7TUF3M1BuQixTQUFTNDhGLFVBQVQsQ0FBb0IzckMsRUFBcEIsRUFBd0IvaEQsQ0FBeEIsRUFBMkIrMUYsR0FBM0IsRUFBZ0NDLFVBQWhDLEVBQTRDO1FBQzFDLElBQUkvdEMsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjtZQUFrQmh3QixLQUFsQjs7UUFDQSxJQUFJODlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO1VBQUVBLEdBQUcsR0FBRyxLQUFOOzs7UUFDbkIsSUFBSUEsR0FBRyxJQUFJLE9BQVgsRUFBb0I7OztVQUdsQixJQUFJLENBQUM5dEMsR0FBRyxDQUFDejJELElBQUosQ0FBU3lrRyxNQUFkLEVBQXNCO1lBQUVGLEdBQUcsR0FBRyxNQUFOO1dBQXhCLE1BQ0s7WUFBRTk5RCxLQUFLLEdBQUd1ekIsZ0JBQWdCLENBQUN6SixFQUFELEVBQUsvaEQsQ0FBTCxDQUFoQixDQUF3Qmk0QixLQUFoQzs7OztRQUdULElBQUkrakIsT0FBTyxHQUFHK0YsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV2tmLE9BQXpCO1FBQ0EsSUFBSW1GLElBQUksR0FBRzZHLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNam9ELENBQU4sQ0FBbEI7WUFBNEJrMkYsUUFBUSxHQUFHbjZDLFdBQVcsQ0FBQ29GLElBQUksQ0FBQ3ZRLElBQU4sRUFBWSxJQUFaLEVBQWtCb0wsT0FBbEIsQ0FBbEQ7O1FBQ0EsSUFBSW1GLElBQUksQ0FBQ3dLLFVBQVQsRUFBcUI7VUFBRXhLLElBQUksQ0FBQ3dLLFVBQUwsR0FBa0IsSUFBbEI7OztRQUN2QixJQUFJd3FDLGNBQWMsR0FBR2gxQyxJQUFJLENBQUN2USxJQUFMLENBQVVwd0MsS0FBVixDQUFnQixNQUFoQixFQUF3QixDQUF4QixDQUFyQjtZQUFpRDZtRCxXQUFqRDs7UUFDQSxJQUFJLENBQUMydUMsVUFBRCxJQUFlLENBQUMsS0FBSzUyRixJQUFMLENBQVUraEQsSUFBSSxDQUFDdlEsSUFBZixDQUFwQixFQUEwQztVQUN4Q3lXLFdBQVcsR0FBRyxDQUFkO1VBQ0EwdUMsR0FBRyxHQUFHLEtBQU47U0FGRixNQUdPLElBQUlBLEdBQUcsSUFBSSxPQUFYLEVBQW9CO1VBQ3pCMXVDLFdBQVcsR0FBR1ksR0FBRyxDQUFDejJELElBQUosQ0FBU3lrRyxNQUFULENBQWdCaCtELEtBQWhCLEVBQXVCa3BCLElBQUksQ0FBQ3ZRLElBQUwsQ0FBVTM2QyxLQUFWLENBQWdCa2dHLGNBQWMsQ0FBQzNqRyxNQUEvQixDQUF2QixFQUErRDJ1RCxJQUFJLENBQUN2USxJQUFwRSxDQUFkOztVQUNBLElBQUl5VyxXQUFXLElBQUkzSyxJQUFmLElBQXVCMkssV0FBVyxHQUFHLEdBQXpDLEVBQThDO1lBQzVDLElBQUksQ0FBQzJ1QyxVQUFMLEVBQWlCO2NBQUU7OztZQUNuQkQsR0FBRyxHQUFHLE1BQU47Ozs7UUFHSixJQUFJQSxHQUFHLElBQUksTUFBWCxFQUFtQjtVQUNqQixJQUFJLzFGLENBQUMsR0FBR2lvRCxHQUFHLENBQUN2bEQsS0FBWixFQUFtQjtZQUFFMmtELFdBQVcsR0FBR3RMLFdBQVcsQ0FBQ2lNLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNam9ELENBQUMsR0FBQyxDQUFSLENBQVAsQ0FBa0I0d0MsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0JvTCxPQUEvQixDQUF6QjtXQUFyQixNQUNLO1lBQUVxTCxXQUFXLEdBQUcsQ0FBZDs7U0FGVCxNQUdPLElBQUkwdUMsR0FBRyxJQUFJLEtBQVgsRUFBa0I7VUFDdkIxdUMsV0FBVyxHQUFHNnVDLFFBQVEsR0FBR24wQyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXczVELFVBQXBDO1NBREssTUFFQSxJQUFJTCxHQUFHLElBQUksVUFBWCxFQUF1QjtVQUM1QjF1QyxXQUFXLEdBQUc2dUMsUUFBUSxHQUFHbjBDLEVBQUUsQ0FBQ2psQixPQUFILENBQVdzNUQsVUFBcEM7U0FESyxNQUVBLElBQUksT0FBT0wsR0FBUCxJQUFjLFFBQWxCLEVBQTRCO1VBQ2pDMXVDLFdBQVcsR0FBRzZ1QyxRQUFRLEdBQUdILEdBQXpCOzs7UUFFRjF1QyxXQUFXLEdBQUdsNUQsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLENBQVQsRUFBWTB3RCxXQUFaLENBQWQ7UUFFQSxJQUFJZ3ZDLFlBQVksR0FBRyxFQUFuQjtZQUF1QjN0RixHQUFHLEdBQUcsQ0FBN0I7O1FBQ0EsSUFBSXE1QyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXdzVELGNBQWYsRUFDRTtVQUFFLEtBQUssSUFBSTFoRyxDQUFDLEdBQUd6RyxJQUFJLENBQUNvSSxLQUFMLENBQVc4d0QsV0FBVyxHQUFHckwsT0FBekIsQ0FBYixFQUFnRHBuRCxDQUFoRCxFQUFtRCxFQUFFQSxDQUFyRCxFQUF3RDtZQUFDOFQsR0FBRyxJQUFJc3pDLE9BQVA7WUFBZ0JxNkMsWUFBWSxJQUFJLElBQWhCOzs7O1FBQzdFLElBQUkzdEYsR0FBRyxHQUFHMitDLFdBQVYsRUFBdUI7VUFBRWd2QyxZQUFZLElBQUloNUMsUUFBUSxDQUFDZ0ssV0FBVyxHQUFHMytDLEdBQWYsQ0FBeEI7OztRQUV6QixJQUFJMnRGLFlBQVksSUFBSUYsY0FBcEIsRUFBb0M7VUFDbEM1WCxhQUFZLENBQUN0MkIsR0FBRCxFQUFNb3VDLFlBQU4sRUFBb0JqdEMsR0FBRyxDQUFDcHBELENBQUQsRUFBSSxDQUFKLENBQXZCLEVBQStCb3BELEdBQUcsQ0FBQ3BwRCxDQUFELEVBQUltMkYsY0FBYyxDQUFDM2pHLE1BQW5CLENBQWxDLEVBQThELFFBQTlELENBQVo7O1VBQ0EydUQsSUFBSSxDQUFDd0ssVUFBTCxHQUFrQixJQUFsQjtVQUNBLE9BQU8sSUFBUDtTQUhGLE1BSU87OztVQUdMLEtBQUssSUFBSTdMLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdtSSxHQUFHLENBQUN1YyxHQUFKLENBQVFDLE1BQVIsQ0FBZWp5RSxNQUF2QyxFQUErQ3N0RCxHQUFHLEVBQWxELEVBQXNEO1lBQ3BELElBQUluTyxLQUFLLEdBQUdzVyxHQUFHLENBQUN1YyxHQUFKLENBQVFDLE1BQVIsQ0FBZTNrQixHQUFmLENBQVo7O1lBQ0EsSUFBSW5PLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBWCxJQUFtQm5oRCxDQUFuQixJQUF3QjJ4QyxLQUFLLENBQUN2MkIsSUFBTixDQUFXL0QsRUFBWCxHQUFnQjgrRSxjQUFjLENBQUMzakcsTUFBM0QsRUFBbUU7Y0FDakUsSUFBSStqRyxLQUFLLEdBQUdudEMsR0FBRyxDQUFDcHBELENBQUQsRUFBSW0yRixjQUFjLENBQUMzakcsTUFBbkIsQ0FBZjtjQUNBZ3BGLG1CQUFtQixDQUFDdnpCLEdBQUQsRUFBTW5JLEdBQU4sRUFBVyxJQUFJbTJCLEtBQUosQ0FBVXNnQixLQUFWLEVBQWlCQSxLQUFqQixDQUFYLENBQW5CO2NBQ0E7Ozs7T0E3NlBXOzs7OztNQXM3UG5CLElBQUlDLFVBQVUsR0FBRyxJQUFqQjs7TUFFQSxTQUFTQyxhQUFULENBQXVCQyxhQUF2QixFQUFzQztRQUNwQ0YsVUFBVSxHQUFHRSxhQUFiOzs7TUFHRixTQUFTQyxjQUFULENBQXdCNTBDLEVBQXhCLEVBQTRCNjBDLFFBQTVCLEVBQXNDQyxPQUF0QyxFQUErQ3J5QixHQUEvQyxFQUFvRDFuQixNQUFwRCxFQUE0RDtRQUMxRCxJQUFJbUwsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBYjtRQUNBbEcsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzh1RSxLQUFYLEdBQW1CLEtBQW5COztRQUNBLElBQUksQ0FBQ3RELEdBQUwsRUFBVTtVQUFFQSxHQUFHLEdBQUd2YyxHQUFHLENBQUN1YyxHQUFWOzs7UUFFWixJQUFJc3lCLE1BQU0sR0FBRyxDQUFDLElBQUkzcEYsSUFBSixFQUFELEdBQVksR0FBekI7UUFDQSxJQUFJNHBGLEtBQUssR0FBR2o2QyxNQUFNLElBQUksT0FBVixJQUFxQmlGLEVBQUUsQ0FBQzlwQixLQUFILENBQVMyOEQsYUFBVCxHQUF5QmtDLE1BQTFEO1FBQ0EsSUFBSUUsU0FBUyxHQUFHaHpDLGNBQWMsQ0FBQzR5QyxRQUFELENBQTlCO1lBQTBDSyxVQUFVLEdBQUcsSUFBdkQsQ0FQMEQ7O1FBUzFELElBQUlGLEtBQUssSUFBSXZ5QixHQUFHLENBQUNDLE1BQUosQ0FBV2p5RSxNQUFYLEdBQW9CLENBQWpDLEVBQW9DO1VBQ2xDLElBQUlna0csVUFBVSxJQUFJQSxVQUFVLENBQUM1bEQsSUFBWCxDQUFnQngrQyxJQUFoQixDQUFxQixJQUFyQixLQUE4QndrRyxRQUFoRCxFQUEwRDtZQUN4RCxJQUFJcHlCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXanlFLE1BQVgsR0FBb0Jna0csVUFBVSxDQUFDNWxELElBQVgsQ0FBZ0JwK0MsTUFBcEMsSUFBOEMsQ0FBbEQsRUFBcUQ7Y0FDbkR5a0csVUFBVSxHQUFHLEVBQWI7O2NBQ0EsS0FBSyxJQUFJcmlHLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0aEcsVUFBVSxDQUFDNWxELElBQVgsQ0FBZ0JwK0MsTUFBcEMsRUFBNENvQyxDQUFDLEVBQTdDLEVBQ0U7Z0JBQUVxaUcsVUFBVSxDQUFDMWxHLElBQVgsQ0FBZ0IwMkQsR0FBRyxDQUFDdTJCLFVBQUosQ0FBZWdZLFVBQVUsQ0FBQzVsRCxJQUFYLENBQWdCaDhDLENBQWhCLENBQWYsQ0FBaEI7OztXQUpSLE1BTU8sSUFBSW9pRyxTQUFTLENBQUN4a0csTUFBVixJQUFvQmd5RSxHQUFHLENBQUNDLE1BQUosQ0FBV2p5RSxNQUEvQixJQUF5Q3V2RCxFQUFFLENBQUNqbEIsT0FBSCxDQUFXbzZELHNCQUF4RCxFQUFnRjtZQUNyRkQsVUFBVSxHQUFHL2xGLEdBQUcsQ0FBQzhsRixTQUFELEVBQVksVUFBVWg3RixDQUFWLEVBQWE7Y0FBRSxPQUFPLENBQUNBLENBQUQsQ0FBUDthQUEzQixDQUFoQjs7OztRQUlKLElBQUlzeUUsV0FBVyxHQUFHdnNCLEVBQUUsQ0FBQ08sS0FBSCxDQUFTZ3NCLFdBQTNCLENBckIwRDs7UUF1QjFELEtBQUssSUFBSXh1QixHQUFHLEdBQUcwa0IsR0FBRyxDQUFDQyxNQUFKLENBQVdqeUUsTUFBWCxHQUFvQixDQUFuQyxFQUFzQ3N0RCxHQUFHLElBQUksQ0FBN0MsRUFBZ0RBLEdBQUcsRUFBbkQsRUFBdUQ7VUFDckQsSUFBSW5PLEtBQUssR0FBRzZ5QixHQUFHLENBQUNDLE1BQUosQ0FBVzNrQixHQUFYLENBQVo7VUFDQSxJQUFJbnhDLElBQUksR0FBR2dqQyxLQUFLLENBQUNoakMsSUFBTixFQUFYO2NBQXlCd0QsRUFBRSxHQUFHdy9CLEtBQUssQ0FBQ3gvQixFQUFOLEVBQTlCOztVQUNBLElBQUl3L0IsS0FBSyxDQUFDdjBCLEtBQU4sRUFBSixFQUFtQjtZQUNqQixJQUFJeTVFLE9BQU8sSUFBSUEsT0FBTyxHQUFHLENBQXpCO2NBQ0U7Z0JBQUVsb0YsSUFBSSxHQUFHeTZDLEdBQUcsQ0FBQ3o2QyxJQUFJLENBQUN3eUMsSUFBTixFQUFZeHlDLElBQUksQ0FBQzBJLEVBQUwsR0FBVXcvRSxPQUF0QixDQUFWO2VBREosTUFFSyxJQUFJOTBDLEVBQUUsQ0FBQzlwQixLQUFILENBQVM0akIsU0FBVCxJQUFzQixDQUFDazdDLEtBQTNCO2NBQ0g7Z0JBQUU1a0YsRUFBRSxHQUFHaTNDLEdBQUcsQ0FBQ2ozQyxFQUFFLENBQUNndkMsSUFBSixFQUFVaHpELElBQUksQ0FBQ3NJLEdBQUwsQ0FBU3V4RCxPQUFPLENBQUNDLEdBQUQsRUFBTTkxQyxFQUFFLENBQUNndkMsSUFBVCxDQUFQLENBQXNCdlEsSUFBdEIsQ0FBMkJwK0MsTUFBcEMsRUFBNEMyZixFQUFFLENBQUNrRixFQUFILEdBQVFpbUMsR0FBRyxDQUFDMDVDLFNBQUQsQ0FBSCxDQUFleGtHLE1BQW5FLENBQVYsQ0FBUjtlQURDLE1BRUEsSUFBSXVrRyxLQUFLLElBQUlQLFVBQVQsSUFBdUJBLFVBQVUsQ0FBQ1csUUFBbEMsSUFBOENYLFVBQVUsQ0FBQzVsRCxJQUFYLENBQWdCeCtDLElBQWhCLENBQXFCLElBQXJCLEtBQThCNGtHLFNBQVMsQ0FBQzVrRyxJQUFWLENBQWUsSUFBZixDQUFoRixFQUNIO2NBQUV1YyxJQUFJLEdBQUd3RCxFQUFFLEdBQUdpM0MsR0FBRyxDQUFDejZDLElBQUksQ0FBQ3d5QyxJQUFOLEVBQVksQ0FBWixDQUFmOzs7O1VBRU4sSUFBSTFQLFdBQVcsR0FBRztZQUFDOWlDLElBQUksRUFBRUEsSUFBUDtZQUFhd0QsRUFBRSxFQUFFQSxFQUFqQjtZQUFxQnkrQixJQUFJLEVBQUVxbUQsVUFBVSxHQUFHQSxVQUFVLENBQUNuM0MsR0FBRyxHQUFHbTNDLFVBQVUsQ0FBQ3prRyxNQUFsQixDQUFiLEdBQXlDd2tHLFNBQTlFO1lBQ0NsNkMsTUFBTSxFQUFFQSxNQUFNLEtBQUtpNkMsS0FBSyxHQUFHLE9BQUgsR0FBYWgxQyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTNDhELFdBQVQsR0FBdUJpQyxNQUF2QixHQUFnQyxLQUFoQyxHQUF3QyxRQUEvRDtXQURqQztVQUVBM1osVUFBVSxDQUFDcDdCLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU3hXLFdBQVQsQ0FBVjtVQUNBMGxCLFdBQVcsQ0FBQ3BWLEVBQUQsRUFBSyxXQUFMLEVBQWtCQSxFQUFsQixFQUFzQnRRLFdBQXRCLENBQVg7OztRQUVGLElBQUltbEQsUUFBUSxJQUFJLENBQUNHLEtBQWpCLEVBQ0U7VUFBRUssZUFBZSxDQUFDcjFDLEVBQUQsRUFBSzYwQyxRQUFMLENBQWY7OztRQUVKcnNCLG1CQUFtQixDQUFDeG9CLEVBQUQsQ0FBbkI7O1FBQ0EsSUFBSUEsRUFBRSxDQUFDTyxLQUFILENBQVNnc0IsV0FBVCxHQUF1QixDQUEzQixFQUE4QjtVQUFFdnNCLEVBQUUsQ0FBQ08sS0FBSCxDQUFTZ3NCLFdBQVQsR0FBdUJBLFdBQXZCOzs7UUFDaEN2c0IsRUFBRSxDQUFDTyxLQUFILENBQVNpc0IsTUFBVCxHQUFrQixJQUFsQjtRQUNBeHNCLEVBQUUsQ0FBQzlwQixLQUFILENBQVMyOEQsYUFBVCxHQUF5Qjd5QyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTNDhELFdBQVQsR0FBdUIsQ0FBQyxDQUFqRDs7O01BR0YsU0FBU3dDLFdBQVQsQ0FBcUJ6b0csQ0FBckIsRUFBd0JtekQsRUFBeEIsRUFBNEI7UUFDMUIsSUFBSXUxQyxNQUFNLEdBQUcxb0csQ0FBQyxDQUFDMm9HLGFBQUYsSUFBbUIzb0csQ0FBQyxDQUFDMm9HLGFBQUYsQ0FBZ0JoUixPQUFoQixDQUF3QixNQUF4QixDQUFoQzs7UUFDQSxJQUFJK1EsTUFBSixFQUFZO1VBQ1Yxb0csQ0FBQyxDQUFDODlDLGNBQUY7O1VBQ0EsSUFBSSxDQUFDcVYsRUFBRSxDQUFDMmpDLFVBQUgsRUFBRCxJQUFvQixDQUFDM2pDLEVBQUUsQ0FBQ2psQixPQUFILENBQVcwNkQsWUFBcEMsRUFDRTtZQUFFcG5CLE9BQU8sQ0FBQ3J1QixFQUFELEVBQUssWUFBWTtjQUFFLE9BQU80MEMsY0FBYyxDQUFDNTBDLEVBQUQsRUFBS3UxQyxNQUFMLEVBQWEsQ0FBYixFQUFnQixJQUFoQixFQUFzQixPQUF0QixDQUFyQjthQUFuQixDQUFQOzs7VUFDSixPQUFPLElBQVA7Ozs7TUFJSixTQUFTRixlQUFULENBQXlCcjFDLEVBQXpCLEVBQTZCNjBDLFFBQTdCLEVBQXVDOztRQUVyQyxJQUFJLENBQUM3MEMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzI2RCxhQUFaLElBQTZCLENBQUMxMUMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzQ2RCxXQUE3QyxFQUEwRDtVQUFFOzs7UUFDNUQsSUFBSWx6QixHQUFHLEdBQUd6aUIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdWMsR0FBakI7O1FBRUEsS0FBSyxJQUFJNXZFLENBQUMsR0FBRzR2RSxHQUFHLENBQUNDLE1BQUosQ0FBV2p5RSxNQUFYLEdBQW9CLENBQWpDLEVBQW9Db0MsQ0FBQyxJQUFJLENBQXpDLEVBQTRDQSxDQUFDLEVBQTdDLEVBQWlEO1VBQy9DLElBQUkrOEMsS0FBSyxHQUFHNnlCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXN3ZFLENBQVgsQ0FBWjs7VUFDQSxJQUFJKzhDLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcvRCxFQUFYLEdBQWdCLEdBQWhCLElBQXdCemlCLENBQUMsSUFBSTR2RSxHQUFHLENBQUNDLE1BQUosQ0FBVzd2RSxDQUFDLEdBQUcsQ0FBZixFQUFrQndtQixJQUFsQixDQUF1QitsQyxJQUF2QixJQUErQnhQLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBM0UsRUFBa0Y7WUFBRTs7O1VBQ3BGLElBQUkzdkQsSUFBSSxHQUFHdXdELEVBQUUsQ0FBQzQxQyxTQUFILENBQWFobUQsS0FBSyxDQUFDdjJCLElBQW5CLENBQVg7VUFDQSxJQUFJbXlDLFFBQVEsR0FBRyxLQUFmOztVQUNBLElBQUkvN0QsSUFBSSxDQUFDaW1HLGFBQVQsRUFBd0I7WUFDdEIsS0FBSyxJQUFJNzZGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdwTCxJQUFJLENBQUNpbUcsYUFBTCxDQUFtQmpsRyxNQUF2QyxFQUErQ29LLENBQUMsRUFBaEQsRUFDRTtjQUFFLElBQUlnNkYsUUFBUSxDQUFDbnJGLE9BQVQsQ0FBaUJqYSxJQUFJLENBQUNpbUcsYUFBTCxDQUFtQjFoRyxNQUFuQixDQUEwQjZHLENBQTFCLENBQWpCLElBQWlELENBQUMsQ0FBdEQsRUFBeUQ7Z0JBQ3pEMndELFFBQVEsR0FBR21nQyxVQUFVLENBQUMzckMsRUFBRCxFQUFLcFEsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFoQixFQUFzQixPQUF0QixDQUFyQjtnQkFDQTs7O1dBSk4sTUFNTyxJQUFJM3ZELElBQUksQ0FBQ29tRyxhQUFULEVBQXdCO1lBQzdCLElBQUlwbUcsSUFBSSxDQUFDb21HLGFBQUwsQ0FBbUJ4NEYsSUFBbkIsQ0FBd0I0b0QsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTdFcsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFwQixDQUFQLENBQWlDdlEsSUFBakMsQ0FBc0MzNkMsS0FBdEMsQ0FBNEMsQ0FBNUMsRUFBK0MwN0MsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVy9ELEVBQTFELENBQXhCLENBQUosRUFDRTtjQUFFazJDLFFBQVEsR0FBR21nQyxVQUFVLENBQUMzckMsRUFBRCxFQUFLcFEsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFoQixFQUFzQixPQUF0QixDQUFyQjs7OztVQUVOLElBQUlvTSxRQUFKLEVBQWM7WUFBRTRKLFdBQVcsQ0FBQ3BWLEVBQUQsRUFBSyxlQUFMLEVBQXNCQSxFQUF0QixFQUEwQnBRLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBckMsQ0FBWDs7Ozs7TUFJcEIsU0FBUzAyQyxjQUFULENBQXdCOTFDLEVBQXhCLEVBQTRCO1FBQzFCLElBQUluUixJQUFJLEdBQUcsRUFBWDtZQUFlNnpCLE1BQU0sR0FBRyxFQUF4Qjs7UUFDQSxLQUFLLElBQUk3dkUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR210RCxFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFQLENBQVdDLE1BQVgsQ0FBa0JqeUUsTUFBdEMsRUFBOENvQyxDQUFDLEVBQS9DLEVBQW1EO1VBQ2pELElBQUl1c0QsSUFBSSxHQUFHWSxFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFQLENBQVdDLE1BQVgsQ0FBa0I3dkUsQ0FBbEIsRUFBcUJ3bUIsSUFBckIsQ0FBMEIrbEMsSUFBckM7VUFDQSxJQUFJMjJDLFNBQVMsR0FBRztZQUFDNXJGLE1BQU0sRUFBRWs5QyxHQUFHLENBQUNqSSxJQUFELEVBQU8sQ0FBUCxDQUFaO1lBQXVCL2xDLElBQUksRUFBRWd1QyxHQUFHLENBQUNqSSxJQUFJLEdBQUcsQ0FBUixFQUFXLENBQVg7V0FBaEQ7VUFDQXNqQixNQUFNLENBQUNsekUsSUFBUCxDQUFZdW1HLFNBQVo7VUFDQWxuRCxJQUFJLENBQUNyL0MsSUFBTCxDQUFVd3dELEVBQUUsQ0FBQ2lnQyxRQUFILENBQVk4VixTQUFTLENBQUM1ckYsTUFBdEIsRUFBOEI0ckYsU0FBUyxDQUFDMThFLElBQXhDLENBQVY7OztRQUVGLE9BQU87VUFBQ3cxQixJQUFJLEVBQUVBLElBQVA7VUFBYTZ6QixNQUFNLEVBQUVBO1NBQTVCOzs7TUFHRixTQUFTc3pCLG1CQUFULENBQTZCQyxLQUE3QixFQUFvQ3ZFLFVBQXBDLEVBQWdEQyxXQUFoRCxFQUE2REMsY0FBN0QsRUFBNkU7UUFDM0VxRSxLQUFLLENBQUM1MEQsWUFBTixDQUFtQixhQUFuQixFQUFrQ3N3RCxXQUFXLEdBQUcsRUFBSCxHQUFRLEtBQXJEO1FBQ0FzRSxLQUFLLENBQUM1MEQsWUFBTixDQUFtQixnQkFBbkIsRUFBcUN1d0QsY0FBYyxHQUFHLEVBQUgsR0FBUSxLQUEzRDtRQUNBcUUsS0FBSyxDQUFDNTBELFlBQU4sQ0FBbUIsWUFBbkIsRUFBaUMsQ0FBQyxDQUFDcXdELFVBQW5DOzs7TUFHRixTQUFTd0UsY0FBVCxHQUEwQjtRQUN4QixJQUFJN3pDLEVBQUUsR0FBRzlKLEdBQUcsQ0FBQyxVQUFELEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5Qix1R0FBekIsQ0FBWjtRQUNBLElBQUloekMsR0FBRyxHQUFHZ3pDLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQzhKLEVBQUQsQ0FBUixFQUFjLElBQWQsRUFBb0IsZ0VBQXBCLENBQWIsQ0FGd0I7Ozs7O1FBT3hCLElBQUl4TCxNQUFKLEVBQVk7VUFBRXdMLEVBQUUsQ0FBQ3JyRCxLQUFILENBQVMrMEMsS0FBVCxHQUFpQixRQUFqQjtTQUFkLE1BQ0s7VUFBRXNXLEVBQUUsQ0FBQ2hoQixZQUFILENBQWdCLE1BQWhCLEVBQXdCLEtBQXhCO1NBUmlCOzs7UUFVeEIsSUFBSWdXLEdBQUosRUFBUztVQUFFZ0wsRUFBRSxDQUFDcnJELEtBQUgsQ0FBU20vRixNQUFULEdBQWtCLGlCQUFsQjs7O1FBQ1hILG1CQUFtQixDQUFDM3pDLEVBQUQsQ0FBbkI7UUFDQSxPQUFPOThDLEdBQVA7T0EzaVFpQjs7Ozs7Ozs7TUFzalFuQixTQUFTNndGLGdCQUFULENBQTBCcFQsVUFBMUIsRUFBc0M7UUFDcEMsSUFBSWtPLGNBQWMsR0FBR2xPLFVBQVUsQ0FBQ2tPLGNBQWhDO1FBRUEsSUFBSW1GLE9BQU8sR0FBR3JULFVBQVUsQ0FBQ3FULE9BQVgsR0FBcUIsRUFBbkM7UUFFQXJULFVBQVUsQ0FBQ3p5RixTQUFYLEdBQXVCO1VBQ3JCc0wsV0FBVyxFQUFFbW5GLFVBRFE7VUFFckJ0dUMsS0FBSyxFQUFFLGlCQUFVO1lBQUN2b0QsTUFBTSxDQUFDdW9ELEtBQVA7WUFBZ0IsS0FBS3o5QyxPQUFMLENBQWF1OEQsS0FBYixDQUFtQjllLEtBQW5CO1dBRmI7VUFJckI0aEQsU0FBUyxFQUFFLG1CQUFTakksTUFBVCxFQUFpQjUvRixLQUFqQixFQUF3QjtZQUNqQyxJQUFJc3NDLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtnQkFBNEJ3SixHQUFHLEdBQUd4SixPQUFPLENBQUNzekQsTUFBRCxDQUF6Qzs7WUFDQSxJQUFJdHpELE9BQU8sQ0FBQ3N6RCxNQUFELENBQVAsSUFBbUI1L0YsS0FBbkIsSUFBNEI0L0YsTUFBTSxJQUFJLE1BQTFDLEVBQWtEO2NBQUU7OztZQUNwRHR6RCxPQUFPLENBQUNzekQsTUFBRCxDQUFQLEdBQWtCNS9GLEtBQWxCOztZQUNBLElBQUl5aUcsY0FBYyxDQUFDMWtHLGNBQWYsQ0FBOEI2aEcsTUFBOUIsQ0FBSixFQUNFO2NBQUV0OEMsU0FBUyxDQUFDLElBQUQsRUFBT20vQyxjQUFjLENBQUM3QyxNQUFELENBQXJCLENBQVQsQ0FBd0MsSUFBeEMsRUFBOEM1L0YsS0FBOUMsRUFBcUQ4MUMsR0FBckQ7OztZQUNKc2IsTUFBTSxDQUFDLElBQUQsRUFBTyxjQUFQLEVBQXVCLElBQXZCLEVBQTZCd3VDLE1BQTdCLENBQU47V0FWbUI7VUFhckIxOEIsU0FBUyxFQUFFLG1CQUFTMDhCLE1BQVQsRUFBaUI7WUFBQyxPQUFPLEtBQUt0ekQsT0FBTCxDQUFhc3pELE1BQWIsQ0FBUDtXQWJSO1VBY3JCa0ksTUFBTSxFQUFFLGtCQUFXO1lBQUMsT0FBTyxLQUFLcndDLEdBQVo7V0FkQztVQWdCckJzd0MsU0FBUyxFQUFFLG1CQUFTcm5GLEdBQVQsRUFBY2lyRCxNQUFkLEVBQXNCO1lBQy9CLEtBQUtsa0MsS0FBTCxDQUFXbTJELE9BQVgsQ0FBbUJqeUIsTUFBTSxHQUFHLE1BQUgsR0FBWSxTQUFyQyxFQUFnRHVzQixTQUFTLENBQUN4M0UsR0FBRCxDQUF6RDtXQWpCbUI7VUFtQnJCc25GLFlBQVksRUFBRSxzQkFBU3RuRixHQUFULEVBQWM7WUFDMUIsSUFBSWdqRCxJQUFJLEdBQUcsS0FBS2o4QixLQUFMLENBQVdtMkQsT0FBdEI7O1lBQ0EsS0FBSyxJQUFJeDVGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzL0QsSUFBSSxDQUFDMWhFLE1BQXpCLEVBQWlDLEVBQUVvQyxDQUFuQyxFQUNFO2NBQUUsSUFBSXMvRCxJQUFJLENBQUN0L0QsQ0FBRCxDQUFKLElBQVdzYyxHQUFYLElBQWtCZ2pELElBQUksQ0FBQ3QvRCxDQUFELENBQUosQ0FBUTNCLElBQVIsSUFBZ0JpZSxHQUF0QyxFQUEyQztnQkFDM0NnakQsSUFBSSxDQUFDdHhDLE1BQUwsQ0FBWWh1QixDQUFaLEVBQWUsQ0FBZjtnQkFDQSxPQUFPLElBQVA7OztXQXhCZTtVQTRCckI2akcsVUFBVSxFQUFFcG9CLFFBQVEsQ0FBQyxVQUFTaHJCLElBQVQsRUFBZXZvQixPQUFmLEVBQXdCO1lBQzNDLElBQUl0ckMsSUFBSSxHQUFHNnpELElBQUksQ0FBQ29ILEtBQUwsR0FBYXBILElBQWIsR0FBb0IwL0IsVUFBVSxDQUFDeC9CLE9BQVgsQ0FBbUIsS0FBS3pvQixPQUF4QixFQUFpQ3VvQixJQUFqQyxDQUEvQjs7WUFDQSxJQUFJN3pELElBQUksQ0FBQzIwRCxVQUFULEVBQXFCO2NBQUUsTUFBTSxJQUFJanVCLEtBQUosQ0FBVSwrQkFBVixDQUFOOzs7WUFDdkJxbEIsWUFBWSxDQUFDLEtBQUt0bEIsS0FBTCxDQUFXK3lCLFFBQVosRUFDQztjQUFDeDVELElBQUksRUFBRUEsSUFBUDtjQUFha25HLFFBQVEsRUFBRXJ6QyxJQUF2QjtjQUE2QjZGLE1BQU0sRUFBRXB1QixPQUFPLElBQUlBLE9BQU8sQ0FBQ291QixNQUF4RDtjQUNDek4sUUFBUSxFQUFHM2dCLE9BQU8sSUFBSUEsT0FBTyxDQUFDMmdCLFFBQXBCLElBQWlDO2FBRjdDLEVBR0MsVUFBVXNOLE9BQVYsRUFBbUI7Y0FBRSxPQUFPQSxPQUFPLENBQUN0TixRQUFmO2FBSHRCLENBQVo7WUFJQSxLQUFLeGxCLEtBQUwsQ0FBVzB5QixPQUFYO1lBQ0FzWSxTQUFTLENBQUMsSUFBRCxDQUFUO1dBUmtCLENBNUJDO1VBc0NyQjAxQixhQUFhLEVBQUV0b0IsUUFBUSxDQUFDLFVBQVNockIsSUFBVCxFQUFlO1lBQ3JDLElBQUkyRixRQUFRLEdBQUcsS0FBSy95QixLQUFMLENBQVcreUIsUUFBMUI7O1lBQ0EsS0FBSyxJQUFJcDJELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvMkQsUUFBUSxDQUFDeDRELE1BQTdCLEVBQXFDLEVBQUVvQyxDQUF2QyxFQUEwQztjQUN4QyxJQUFJb3FELEdBQUcsR0FBR2dNLFFBQVEsQ0FBQ3AyRCxDQUFELENBQVIsQ0FBWThqRyxRQUF0Qjs7Y0FDQSxJQUFJMTVDLEdBQUcsSUFBSXFHLElBQVAsSUFBZSxPQUFPQSxJQUFQLElBQWUsUUFBZixJQUEyQnJHLEdBQUcsQ0FBQy9yRCxJQUFKLElBQVlveUQsSUFBMUQsRUFBZ0U7Z0JBQzlEMkYsUUFBUSxDQUFDcG9DLE1BQVQsQ0FBZ0JodUIsQ0FBaEIsRUFBbUIsQ0FBbkI7Z0JBQ0EsS0FBS3FqQyxLQUFMLENBQVcweUIsT0FBWDtnQkFDQXNZLFNBQVMsQ0FBQyxJQUFELENBQVQ7Z0JBQ0E7OztXQVJpQixDQXRDRjtVQW1EckJ5cUIsVUFBVSxFQUFFcmQsUUFBUSxDQUFDLFVBQVNyd0UsQ0FBVCxFQUFZcStDLEdBQVosRUFBaUIyM0MsVUFBakIsRUFBNkI7WUFDaEQsSUFBSSxPQUFPMzNDLEdBQVAsSUFBYyxRQUFkLElBQTBCLE9BQU9BLEdBQVAsSUFBYyxRQUE1QyxFQUFzRDtjQUNwRCxJQUFJQSxHQUFHLElBQUksSUFBWCxFQUFpQjtnQkFBRUEsR0FBRyxHQUFHLEtBQUt2aEIsT0FBTCxDQUFhNDZELFdBQWIsR0FBMkIsT0FBM0IsR0FBcUMsTUFBM0M7ZUFBbkIsTUFDSztnQkFBRXI1QyxHQUFHLEdBQUdBLEdBQUcsR0FBRyxLQUFILEdBQVcsVUFBcEI7Ozs7WUFFVCxJQUFJMkssTUFBTSxDQUFDLEtBQUtmLEdBQU4sRUFBV2pvRCxDQUFYLENBQVYsRUFBeUI7Y0FBRTB0RixVQUFVLENBQUMsSUFBRCxFQUFPMXRGLENBQVAsRUFBVXErQyxHQUFWLEVBQWUyM0MsVUFBZixDQUFWOztXQUxULENBbkRDO1VBMERyQmhKLGVBQWUsRUFBRTNjLFFBQVEsQ0FBQyxVQUFTMGxCLEdBQVQsRUFBYztZQUN0QyxJQUFJdHhCLE1BQU0sR0FBRyxLQUFLeGMsR0FBTCxDQUFTdWMsR0FBVCxDQUFhQyxNQUExQjtnQkFBa0NwNUQsR0FBRyxHQUFHLENBQUMsQ0FBekM7O1lBQ0EsS0FBSyxJQUFJelcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO2NBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCOztjQUNBLElBQUksQ0FBQys4QyxLQUFLLENBQUN2MEIsS0FBTixFQUFMLEVBQW9CO2dCQUNsQixJQUFJek8sSUFBSSxHQUFHZ2pDLEtBQUssQ0FBQ2hqQyxJQUFOLEVBQVg7b0JBQXlCd0QsRUFBRSxHQUFHdy9CLEtBQUssQ0FBQ3gvQixFQUFOLEVBQTlCO2dCQUNBLElBQUlyQyxLQUFLLEdBQUczaEIsSUFBSSxDQUFDd0ksR0FBTCxDQUFTMFUsR0FBVCxFQUFjc0QsSUFBSSxDQUFDd3lDLElBQW5CLENBQVo7Z0JBQ0E5MUMsR0FBRyxHQUFHbGQsSUFBSSxDQUFDc0ksR0FBTCxDQUFTLEtBQUt1N0QsUUFBTCxFQUFULEVBQTBCNy9DLEVBQUUsQ0FBQ2d2QyxJQUFILElBQVdodkMsRUFBRSxDQUFDa0YsRUFBSCxHQUFRLENBQVIsR0FBWSxDQUF2QixDQUExQixJQUF1RCxDQUE3RDs7Z0JBQ0EsS0FBSyxJQUFJemEsQ0FBQyxHQUFHa1QsS0FBYixFQUFvQmxULENBQUMsR0FBR3lPLEdBQXhCLEVBQTZCLEVBQUV6TyxDQUEvQixFQUNFO2tCQUFFOHdGLFVBQVUsQ0FBQyxJQUFELEVBQU85d0YsQ0FBUCxFQUFVbTVGLEdBQVYsQ0FBVjs7O2dCQUNKLElBQUk2QyxTQUFTLEdBQUcsS0FBSzN3QyxHQUFMLENBQVN1YyxHQUFULENBQWFDLE1BQTdCOztnQkFDQSxJQUFJOTFELElBQUksQ0FBQzBJLEVBQUwsSUFBVyxDQUFYLElBQWdCb3RELE1BQU0sQ0FBQ2p5RSxNQUFQLElBQWlCb21HLFNBQVMsQ0FBQ3BtRyxNQUEzQyxJQUFxRG9tRyxTQUFTLENBQUNoa0csQ0FBRCxDQUFULENBQWErWixJQUFiLEdBQW9CMEksRUFBcEIsR0FBeUIsQ0FBbEYsRUFDRTtrQkFBRW1rRSxtQkFBbUIsQ0FBQyxLQUFLdnpCLEdBQU4sRUFBV3J6RCxDQUFYLEVBQWMsSUFBSXFoRixLQUFKLENBQVV0bkUsSUFBVixFQUFnQmlxRixTQUFTLENBQUNoa0csQ0FBRCxDQUFULENBQWF1ZCxFQUFiLEVBQWhCLENBQWQsRUFBa0R3cUMsY0FBbEQsQ0FBbkI7O2VBUk4sTUFTTyxJQUFJaEwsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFYLEdBQWtCOTFDLEdBQXRCLEVBQTJCO2dCQUNoQ3FpRixVQUFVLENBQUMsSUFBRCxFQUFPLzdDLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBbEIsRUFBd0I0MEMsR0FBeEIsRUFBNkIsSUFBN0IsQ0FBVjtnQkFDQTFxRixHQUFHLEdBQUdzbUMsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFqQjs7Z0JBQ0EsSUFBSXZzRCxDQUFDLElBQUksS0FBS3F6RCxHQUFMLENBQVN1YyxHQUFULENBQWFFLFNBQXRCLEVBQWlDO2tCQUFFNkYsbUJBQW1CLENBQUMsSUFBRCxDQUFuQjs7OztXQWhCaEIsQ0ExREo7OztVQWlGckJzdUIsVUFBVSxFQUFFLG9CQUFTbndGLEdBQVQsRUFBY3FqRCxPQUFkLEVBQXVCO1lBQ2pDLE9BQU9ZLFNBQVMsQ0FBQyxJQUFELEVBQU9qa0QsR0FBUCxFQUFZcWpELE9BQVosQ0FBaEI7V0FsRm1CO1VBcUZyQitzQyxhQUFhLEVBQUUsdUJBQVMzM0MsSUFBVCxFQUFlNEssT0FBZixFQUF3QjtZQUNyQyxPQUFPWSxTQUFTLENBQUMsSUFBRCxFQUFPdkQsR0FBRyxDQUFDakksSUFBRCxDQUFWLEVBQWtCNEssT0FBbEIsRUFBMkIsSUFBM0IsQ0FBaEI7V0F0Rm1CO1VBeUZyQmd0QyxjQUFjLEVBQUUsd0JBQVNyd0YsR0FBVCxFQUFjO1lBQzVCQSxHQUFHLEdBQUdpaEQsUUFBTyxDQUFDLEtBQUsxQixHQUFOLEVBQVd2L0MsR0FBWCxDQUFiO1lBQ0EsSUFBSTQ4QixNQUFNLEdBQUdnbUIsYUFBYSxDQUFDLElBQUQsRUFBT3RELE9BQU8sQ0FBQyxLQUFLQyxHQUFOLEVBQVd2L0MsR0FBRyxDQUFDeTRDLElBQWYsQ0FBZCxDQUExQjtZQUNBLElBQUlSLE1BQU0sR0FBRyxDQUFiO2dCQUFnQnhHLEtBQUssR0FBRyxDQUFDN1UsTUFBTSxDQUFDOXlDLE1BQVAsR0FBZ0IsQ0FBakIsSUFBc0IsQ0FBOUM7Z0JBQWlENmtCLEVBQUUsR0FBRzNPLEdBQUcsQ0FBQzJPLEVBQTFEO1lBQ0EsSUFBSXJrQixJQUFKOztZQUNBLElBQUlxa0IsRUFBRSxJQUFJLENBQVYsRUFBYTtjQUFFcmtCLElBQUksR0FBR3N5QyxNQUFNLENBQUMsQ0FBRCxDQUFiO2FBQWYsTUFDSztjQUFFLFNBQVM7Z0JBQ2QsSUFBSW1aLEdBQUcsR0FBSWtDLE1BQU0sR0FBR3hHLEtBQVYsSUFBb0IsQ0FBOUI7O2dCQUNBLElBQUksQ0FBQ3NFLEdBQUcsR0FBR25aLE1BQU0sQ0FBQ21aLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBWCxDQUFULEdBQXlCLENBQTdCLEtBQW1DcG5DLEVBQXZDLEVBQTJDO2tCQUFFOGlDLEtBQUssR0FBR3NFLEdBQVI7aUJBQTdDLE1BQ0ssSUFBSW5aLE1BQU0sQ0FBQ21aLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBWCxDQUFOLEdBQXNCcG5DLEVBQTFCLEVBQThCO2tCQUFFc3BDLE1BQU0sR0FBR2xDLEdBQUcsR0FBRyxDQUFmO2lCQUFoQyxNQUNBO2tCQUFFenJELElBQUksR0FBR3N5QyxNQUFNLENBQUNtWixHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVgsQ0FBYjtrQkFBNEI7Ozs7O1lBRXJDLElBQUk2a0IsR0FBRyxHQUFHdHdFLElBQUksR0FBR0EsSUFBSSxDQUFDeVksT0FBTCxDQUFhLFVBQWIsQ0FBSCxHQUE4QixDQUFDLENBQTdDO1lBQ0EsT0FBTzYzRCxHQUFHLEdBQUcsQ0FBTixHQUFVdHdFLElBQVYsR0FBaUJzd0UsR0FBRyxJQUFJLENBQVAsR0FBVyxJQUFYLEdBQWtCdHdFLElBQUksQ0FBQ2lELEtBQUwsQ0FBVyxDQUFYLEVBQWNxdEUsR0FBRyxHQUFHLENBQXBCLENBQTFDO1dBdEdtQjtVQXlHckJxMEIsU0FBUyxFQUFFLG1CQUFTanZGLEdBQVQsRUFBYztZQUN2QixJQUFJbFgsSUFBSSxHQUFHLEtBQUt5MkQsR0FBTCxDQUFTejJELElBQXBCOztZQUNBLElBQUksQ0FBQ0EsSUFBSSxDQUFDMDBELFNBQVYsRUFBcUI7Y0FBRSxPQUFPMTBELElBQVA7OztZQUN2QixPQUFPdXpGLFVBQVUsQ0FBQzcrQixTQUFYLENBQXFCMTBELElBQXJCLEVBQTJCLEtBQUtxbkcsVUFBTCxDQUFnQm53RixHQUFoQixFQUFxQnV2QixLQUFoRCxFQUF1RHptQyxJQUE5RDtXQTVHbUI7VUErR3JCd25HLFNBQVMsRUFBRSxtQkFBU3R3RixHQUFULEVBQWMxVixJQUFkLEVBQW9CO1lBQzdCLE9BQU8sS0FBS2ltRyxVQUFMLENBQWdCdndGLEdBQWhCLEVBQXFCMVYsSUFBckIsRUFBMkIsQ0FBM0IsQ0FBUDtXQWhIbUI7VUFtSHJCaW1HLFVBQVUsRUFBRSxvQkFBU3Z3RixHQUFULEVBQWMxVixJQUFkLEVBQW9CO1lBQzlCLElBQUk0ckQsS0FBSyxHQUFHLEVBQVo7O1lBQ0EsSUFBSSxDQUFDdzVDLE9BQU8sQ0FBQzdwRyxjQUFSLENBQXVCeUUsSUFBdkIsQ0FBTCxFQUFtQztjQUFFLE9BQU80ckQsS0FBUDs7O1lBQ3JDLElBQUlzNkMsSUFBSSxHQUFHZCxPQUFPLENBQUNwbEcsSUFBRCxDQUFsQjtnQkFBMEJ4QixJQUFJLEdBQUcsS0FBS21tRyxTQUFMLENBQWVqdkYsR0FBZixDQUFqQzs7WUFDQSxJQUFJLE9BQU9sWCxJQUFJLENBQUN3QixJQUFELENBQVgsSUFBcUIsUUFBekIsRUFBbUM7Y0FDakMsSUFBSWttRyxJQUFJLENBQUMxbkcsSUFBSSxDQUFDd0IsSUFBRCxDQUFMLENBQVIsRUFBc0I7Z0JBQUU0ckQsS0FBSyxDQUFDcnRELElBQU4sQ0FBVzJuRyxJQUFJLENBQUMxbkcsSUFBSSxDQUFDd0IsSUFBRCxDQUFMLENBQWY7O2FBRDFCLE1BRU8sSUFBSXhCLElBQUksQ0FBQ3dCLElBQUQsQ0FBUixFQUFnQjtjQUNyQixLQUFLLElBQUk0QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcEQsSUFBSSxDQUFDd0IsSUFBRCxDQUFKLENBQVdSLE1BQS9CLEVBQXVDb0MsQ0FBQyxFQUF4QyxFQUE0QztnQkFDMUMsSUFBSTlFLEdBQUcsR0FBR29wRyxJQUFJLENBQUMxbkcsSUFBSSxDQUFDd0IsSUFBRCxDQUFKLENBQVc0QixDQUFYLENBQUQsQ0FBZDs7Z0JBQ0EsSUFBSTlFLEdBQUosRUFBUztrQkFBRTh1RCxLQUFLLENBQUNydEQsSUFBTixDQUFXekIsR0FBWDs7O2FBSFIsTUFLQSxJQUFJMEIsSUFBSSxDQUFDbzBELFVBQUwsSUFBbUJzekMsSUFBSSxDQUFDMW5HLElBQUksQ0FBQ28wRCxVQUFOLENBQTNCLEVBQThDO2NBQ25EaEgsS0FBSyxDQUFDcnRELElBQU4sQ0FBVzJuRyxJQUFJLENBQUMxbkcsSUFBSSxDQUFDbzBELFVBQU4sQ0FBZjthQURLLE1BRUEsSUFBSXN6QyxJQUFJLENBQUMxbkcsSUFBSSxDQUFDeUIsSUFBTixDQUFSLEVBQXFCO2NBQzFCMnJELEtBQUssQ0FBQ3J0RCxJQUFOLENBQVcybkcsSUFBSSxDQUFDMW5HLElBQUksQ0FBQ3lCLElBQU4sQ0FBZjs7O1lBRUYsS0FBSyxJQUFJNnNELEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdvNUMsSUFBSSxDQUFDbitELE9BQUwsQ0FBYXZvQyxNQUFyQyxFQUE2Q3N0RCxHQUFHLEVBQWhELEVBQW9EO2NBQ2xELElBQUlkLEdBQUcsR0FBR2s2QyxJQUFJLENBQUNuK0QsT0FBTCxDQUFhK2tCLEdBQWIsQ0FBVjs7Y0FDQSxJQUFJZCxHQUFHLENBQUNULElBQUosQ0FBUy9zRCxJQUFULEVBQWUsSUFBZixLQUF3QmlhLE9BQU8sQ0FBQ216QyxLQUFELEVBQVFJLEdBQUcsQ0FBQ2x2RCxHQUFaLENBQVAsSUFBMkIsQ0FBQyxDQUF4RCxFQUNFO2dCQUFFOHVELEtBQUssQ0FBQ3J0RCxJQUFOLENBQVd5dEQsR0FBRyxDQUFDbHZELEdBQWY7Ozs7WUFFTixPQUFPOHVELEtBQVA7V0F4SW1CO1VBMklyQnU2QyxhQUFhLEVBQUUsdUJBQVNoNEMsSUFBVCxFQUFlNEssT0FBZixFQUF3QjtZQUNyQyxJQUFJOUQsR0FBRyxHQUFHLEtBQUtBLEdBQWY7WUFDQTlHLElBQUksR0FBR3VJLFFBQVEsQ0FBQ3pCLEdBQUQsRUFBTTlHLElBQUksSUFBSSxJQUFSLEdBQWU4RyxHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUFoQixHQUF1QixDQUF0QyxHQUF5Q3kwQyxJQUEvQyxDQUFmO1lBQ0EsT0FBT3FLLGdCQUFnQixDQUFDLElBQUQsRUFBT3JLLElBQUksR0FBRyxDQUFkLEVBQWlCNEssT0FBakIsQ0FBaEIsQ0FBMEM5ekIsS0FBakQ7V0E5SW1CO1VBaUpyQm9vQyxZQUFZLEVBQUUsc0JBQVN2d0QsS0FBVCxFQUFnQnRlLElBQWhCLEVBQXNCO1lBQ2xDLElBQUlrWCxHQUFKO2dCQUFTaXBDLEtBQUssR0FBRyxLQUFLc1csR0FBTCxDQUFTdWMsR0FBVCxDQUFhSixPQUFiLEVBQWpCOztZQUNBLElBQUl0MEQsS0FBSyxJQUFJLElBQWIsRUFBbUI7Y0FBRXBILEdBQUcsR0FBR2lwQyxLQUFLLENBQUN2MkIsSUFBWjthQUFyQixNQUNLLElBQUksT0FBT3RMLEtBQVAsSUFBZ0IsUUFBcEIsRUFBOEI7Y0FBRXBILEdBQUcsR0FBR2loRCxRQUFPLENBQUMsS0FBSzFCLEdBQU4sRUFBV240QyxLQUFYLENBQWI7YUFBaEMsTUFDQTtjQUFFcEgsR0FBRyxHQUFHb0gsS0FBSyxHQUFHNmhDLEtBQUssQ0FBQ2hqQyxJQUFOLEVBQUgsR0FBa0JnakMsS0FBSyxDQUFDeC9CLEVBQU4sRUFBN0I7OztZQUNQLE9BQU9rdUQsYUFBWSxDQUFDLElBQUQsRUFBTzMzRCxHQUFQLEVBQVlsWCxJQUFJLElBQUksTUFBcEIsQ0FBbkI7V0F0Sm1CO1VBeUpyQjR1RSxVQUFVLEVBQUUsb0JBQVMxM0QsR0FBVCxFQUFjbFgsSUFBZCxFQUFvQjtZQUM5QixPQUFPNHVFLFdBQVUsQ0FBQyxJQUFELEVBQU96VyxRQUFPLENBQUMsS0FBSzFCLEdBQU4sRUFBV3YvQyxHQUFYLENBQWQsRUFBK0JsWCxJQUFJLElBQUksTUFBdkMsQ0FBakI7V0ExSm1CO1VBNkpyQnN2RSxVQUFVLEVBQUUsb0JBQVNiLE1BQVQsRUFBaUJ6dUUsSUFBakIsRUFBdUI7WUFDakN5dUUsTUFBTSxHQUFHRCxlQUFlLENBQUMsSUFBRCxFQUFPQyxNQUFQLEVBQWV6dUUsSUFBSSxJQUFJLE1BQXZCLENBQXhCO1lBQ0EsT0FBT3N2RSxXQUFVLENBQUMsSUFBRCxFQUFPYixNQUFNLENBQUN2dUMsSUFBZCxFQUFvQnV1QyxNQUFNLENBQUMzd0IsR0FBM0IsQ0FBakI7V0EvSm1CO1VBa0tyQnVaLFlBQVksRUFBRSxzQkFBUzdhLE1BQVQsRUFBaUJ4OEMsSUFBakIsRUFBdUI7WUFDbkN3OEMsTUFBTSxHQUFHZ3lCLGVBQWUsQ0FBQyxJQUFELEVBQU87Y0FBQzF3QixHQUFHLEVBQUV0QixNQUFOO2NBQWN0YyxJQUFJLEVBQUU7YUFBM0IsRUFBK0JsZ0MsSUFBSSxJQUFJLE1BQXZDLENBQWYsQ0FBOEQ4OUMsR0FBdkU7WUFDQSxPQUFPdVosYUFBWSxDQUFDLEtBQUtaLEdBQU4sRUFBV2phLE1BQU0sR0FBRyxLQUFLaDFDLE9BQUwsQ0FBYTZtRSxVQUFqQyxDQUFuQjtXQXBLbUI7VUFzS3JCek4sWUFBWSxFQUFFLHNCQUFTalIsSUFBVCxFQUFlM3ZELElBQWYsRUFBcUJtdUUsY0FBckIsRUFBcUM7WUFDakQsSUFBSXQwRCxHQUFHLEdBQUcsS0FBVjtnQkFBaUJnbkQsT0FBakI7O1lBQ0EsSUFBSSxPQUFPbFIsSUFBUCxJQUFlLFFBQW5CLEVBQTZCO2NBQzNCLElBQUk5bEMsSUFBSSxHQUFHLEtBQUs0c0MsR0FBTCxDQUFTdmxELEtBQVQsR0FBaUIsS0FBS3VsRCxHQUFMLENBQVN2N0MsSUFBMUIsR0FBaUMsQ0FBNUM7O2NBQ0EsSUFBSXkwQyxJQUFJLEdBQUcsS0FBSzhHLEdBQUwsQ0FBU3ZsRCxLQUFwQixFQUEyQjtnQkFBRXkrQyxJQUFJLEdBQUcsS0FBSzhHLEdBQUwsQ0FBU3ZsRCxLQUFoQjtlQUE3QixNQUNLLElBQUl5K0MsSUFBSSxHQUFHOWxDLElBQVgsRUFBaUI7Z0JBQUU4bEMsSUFBSSxHQUFHOWxDLElBQVA7Z0JBQWFoUSxHQUFHLEdBQUcsSUFBTjs7O2NBQ3JDZ25ELE9BQU8sR0FBR3JLLE9BQU8sQ0FBQyxLQUFLQyxHQUFOLEVBQVc5RyxJQUFYLENBQWpCO2FBSkYsTUFLTztjQUNMa1IsT0FBTyxHQUFHbFIsSUFBVjs7O1lBRUYsT0FBT3VlLGVBQWUsQ0FBQyxJQUFELEVBQU9yTixPQUFQLEVBQWdCO2NBQUMvaUIsR0FBRyxFQUFFLENBQU47Y0FBUzVkLElBQUksRUFBRTthQUEvQixFQUFtQ2xnQyxJQUFJLElBQUksTUFBM0MsRUFBbURtdUUsY0FBYyxJQUFJdDBELEdBQXJFLENBQWYsQ0FBeUZpa0MsR0FBekYsSUFDSmprQyxHQUFHLEdBQUcsS0FBSzQ4QyxHQUFMLENBQVNqYSxNQUFULEdBQWtCb2tCLGFBQVksQ0FBQ0MsT0FBRCxDQUFqQyxHQUE2QyxDQUQ1QyxDQUFQO1dBaExtQjtVQW9MckIrbUMsaUJBQWlCLEVBQUUsNkJBQVc7WUFBRSxPQUFPajNCLFVBQVUsQ0FBQyxLQUFLbnBFLE9BQU4sQ0FBakI7V0FwTFg7VUFxTHJCcWdHLGdCQUFnQixFQUFFLDRCQUFXO1lBQUUsT0FBT3I3QixTQUFTLENBQUMsS0FBS2hsRSxPQUFOLENBQWhCO1dBckxWO1VBdUxyQnNnRyxXQUFXLEVBQUUsdUJBQVc7WUFBRSxPQUFPO2NBQUMzcUYsSUFBSSxFQUFFLEtBQUszVixPQUFMLENBQWFrekQsUUFBcEI7Y0FBOEIvNUMsRUFBRSxFQUFFLEtBQUtuWixPQUFMLENBQWFtekQ7YUFBdEQ7V0F2TEw7VUF5THJCb3RDLFNBQVMsRUFBRSxtQkFBUzd3RixHQUFULEVBQWNxVCxJQUFkLEVBQW9CNmdDLE1BQXBCLEVBQTRCb3ZCLElBQTVCLEVBQWtDQyxLQUFsQyxFQUF5QztZQUNsRCxJQUFJanpFLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtZQUNBMFAsR0FBRyxHQUFHMjNELGFBQVksQ0FBQyxJQUFELEVBQU8xVyxRQUFPLENBQUMsS0FBSzFCLEdBQU4sRUFBV3YvQyxHQUFYLENBQWQsQ0FBbEI7WUFDQSxJQUFJNG1DLEdBQUcsR0FBRzVtQyxHQUFHLENBQUN5ekQsTUFBZDtnQkFBc0J6cUMsSUFBSSxHQUFHaHBCLEdBQUcsQ0FBQ2dwQixJQUFqQztZQUNBM1YsSUFBSSxDQUFDaGpCLEtBQUwsQ0FBVytkLFFBQVgsR0FBc0IsVUFBdEI7WUFDQWlGLElBQUksQ0FBQ3FuQixZQUFMLENBQWtCLGtCQUFsQixFQUFzQyxNQUF0QztZQUNBLEtBQUtwcUMsT0FBTCxDQUFhdThELEtBQWIsQ0FBbUJFLGFBQW5CLENBQWlDMTVDLElBQWpDO1lBQ0EvaUIsT0FBTyxDQUFDeWhFLEtBQVIsQ0FBY3hoRSxXQUFkLENBQTBCOGlCLElBQTFCOztZQUNBLElBQUlpd0QsSUFBSSxJQUFJLE1BQVosRUFBb0I7Y0FDbEIxOEIsR0FBRyxHQUFHNW1DLEdBQUcsQ0FBQzRtQyxHQUFWO2FBREYsTUFFTyxJQUFJMDhCLElBQUksSUFBSSxPQUFSLElBQW1CQSxJQUFJLElBQUksTUFBL0IsRUFBdUM7Y0FDNUMsSUFBSXd0QixNQUFNLEdBQUdyckcsSUFBSSxDQUFDd0ksR0FBTCxDQUFTcUMsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0JpOEMsWUFBekIsRUFBdUMsS0FBS3pULEdBQUwsQ0FBU2phLE1BQWhELENBQWI7a0JBQ0F5ckQsTUFBTSxHQUFHdHJHLElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3FDLE9BQU8sQ0FBQ3loRSxLQUFSLENBQWNGLFdBQXZCLEVBQW9DdmhFLE9BQU8sQ0FBQzRoRSxTQUFSLENBQWtCTCxXQUF0RCxDQURULENBRDRDOztjQUk1QyxJQUFJLENBQUN5UixJQUFJLElBQUksT0FBUixJQUFtQnRqRSxHQUFHLENBQUN5ekQsTUFBSixHQUFhcGdELElBQUksQ0FBQ3luQyxZQUFsQixHQUFpQ2cyQyxNQUFyRCxLQUFnRTl3RixHQUFHLENBQUM0bUMsR0FBSixHQUFVdnpCLElBQUksQ0FBQ3luQyxZQUFuRixFQUNFO2dCQUFFbFUsR0FBRyxHQUFHNW1DLEdBQUcsQ0FBQzRtQyxHQUFKLEdBQVV2ekIsSUFBSSxDQUFDeW5DLFlBQXJCO2VBREosTUFFSyxJQUFJOTZDLEdBQUcsQ0FBQ3l6RCxNQUFKLEdBQWFwZ0QsSUFBSSxDQUFDeW5DLFlBQWxCLElBQWtDZzJDLE1BQXRDLEVBQ0g7Z0JBQUVscUQsR0FBRyxHQUFHNW1DLEdBQUcsQ0FBQ3l6RCxNQUFWOzs7Y0FDSixJQUFJenFDLElBQUksR0FBRzNWLElBQUksQ0FBQzBuQyxXQUFaLEdBQTBCZzJDLE1BQTlCLEVBQ0U7Z0JBQUUvbkUsSUFBSSxHQUFHK25FLE1BQU0sR0FBRzE5RSxJQUFJLENBQUMwbkMsV0FBckI7Ozs7WUFFTjFuQyxJQUFJLENBQUNoakIsS0FBTCxDQUFXdTJDLEdBQVgsR0FBaUJBLEdBQUcsR0FBRyxJQUF2QjtZQUNBdnpCLElBQUksQ0FBQ2hqQixLQUFMLENBQVcyNEIsSUFBWCxHQUFrQjNWLElBQUksQ0FBQ2hqQixLQUFMLENBQVdnckQsS0FBWCxHQUFtQixFQUFyQzs7WUFDQSxJQUFJa29CLEtBQUssSUFBSSxPQUFiLEVBQXNCO2NBQ3BCdjZDLElBQUksR0FBRzE0QixPQUFPLENBQUN5aEUsS0FBUixDQUFjRixXQUFkLEdBQTRCeCtDLElBQUksQ0FBQzBuQyxXQUF4QztjQUNBMW5DLElBQUksQ0FBQ2hqQixLQUFMLENBQVdnckQsS0FBWCxHQUFtQixLQUFuQjthQUZGLE1BR087Y0FDTCxJQUFJa29CLEtBQUssSUFBSSxNQUFiLEVBQXFCO2dCQUFFdjZDLElBQUksR0FBRyxDQUFQO2VBQXZCLE1BQ0ssSUFBSXU2QyxLQUFLLElBQUksUUFBYixFQUF1QjtnQkFBRXY2QyxJQUFJLEdBQUcsQ0FBQzE0QixPQUFPLENBQUN5aEUsS0FBUixDQUFjRixXQUFkLEdBQTRCeCtDLElBQUksQ0FBQzBuQyxXQUFsQyxJQUFpRCxDQUF4RDs7O2NBQzlCMW5DLElBQUksQ0FBQ2hqQixLQUFMLENBQVcyNEIsSUFBWCxHQUFrQkEsSUFBSSxHQUFHLElBQXpCOzs7WUFFRixJQUFJa3JCLE1BQUosRUFDRTtjQUFFb3NCLGNBQWMsQ0FBQyxJQUFELEVBQU87Z0JBQUN0M0MsSUFBSSxFQUFFQSxJQUFQO2dCQUFhNGQsR0FBRyxFQUFFQSxHQUFsQjtnQkFBdUJ5VSxLQUFLLEVBQUVyeUIsSUFBSSxHQUFHM1YsSUFBSSxDQUFDMG5DLFdBQTFDO2dCQUF1RDBZLE1BQU0sRUFBRTdzQixHQUFHLEdBQUd2ekIsSUFBSSxDQUFDeW5DO2VBQWpGLENBQWQ7O1dBek5lO1VBNE5yQmsyQyxnQkFBZ0IsRUFBRXJwQixRQUFRLENBQUN2NkIsU0FBRCxDQTVOTDtVQTZOckI2akQsaUJBQWlCLEVBQUV0cEIsUUFBUSxDQUFDK2UsVUFBRCxDQTdOTjtVQThOckJ3SyxjQUFjLEVBQUV6SyxPQTlOSztVQStOckIwSyxrQkFBa0IsRUFBRXhwQixRQUFRLENBQUN1ZixXQUFELENBL05QO1VBaU9yQnRDLFdBQVcsRUFBRSxxQkFBU2xGLEdBQVQsRUFBYztZQUN6QixJQUFJbUMsUUFBUSxDQUFDaDhGLGNBQVQsQ0FBd0I2NUYsR0FBeEIsQ0FBSixFQUNFO2NBQUUsT0FBT21DLFFBQVEsQ0FBQ25DLEdBQUQsQ0FBUixDQUFjMTVGLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBUDs7V0FuT2U7VUFzT3JCMG9HLGVBQWUsRUFBRS9tQixRQUFRLENBQUMsVUFBU3ovQixJQUFULEVBQWU7WUFBRXdtRCxlQUFlLENBQUMsSUFBRCxFQUFPeG1ELElBQVAsQ0FBZjtXQUFsQixDQXRPSjtVQXdPckJrcEQsUUFBUSxFQUFFLGtCQUFTbnJGLElBQVQsRUFBZW9yRixNQUFmLEVBQXVCMUosSUFBdkIsRUFBNkJ4RyxRQUE3QixFQUF1QztZQUMvQyxJQUFJeHJDLEdBQUcsR0FBRyxDQUFWOztZQUNBLElBQUkwN0MsTUFBTSxHQUFHLENBQWIsRUFBZ0I7Y0FBRTE3QyxHQUFHLEdBQUcsQ0FBQyxDQUFQO2NBQVUwN0MsTUFBTSxHQUFHLENBQUNBLE1BQVY7OztZQUM1QixJQUFJLzZDLEdBQUcsR0FBRzJLLFFBQU8sQ0FBQyxLQUFLMUIsR0FBTixFQUFXdDVDLElBQVgsQ0FBakI7O1lBQ0EsS0FBSyxJQUFJL1osQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21sRyxNQUFwQixFQUE0QixFQUFFbmxHLENBQTlCLEVBQWlDO2NBQy9Cb3FELEdBQUcsR0FBRzg2QyxTQUFRLENBQUMsS0FBSzd4QyxHQUFOLEVBQVdqSixHQUFYLEVBQWdCWCxHQUFoQixFQUFxQmd5QyxJQUFyQixFQUEyQnhHLFFBQTNCLENBQWQ7O2NBQ0EsSUFBSTdxQyxHQUFHLENBQUNnN0MsT0FBUixFQUFpQjtnQkFBRTs7OztZQUVyQixPQUFPaDdDLEdBQVA7V0FoUG1CO1VBbVByQmd0QyxLQUFLLEVBQUUzYixRQUFRLENBQUMsVUFBU2h5QixHQUFULEVBQWNneUMsSUFBZCxFQUFvQjtZQUNsQyxJQUFJeFEsTUFBTSxHQUFHLElBQWI7WUFFQSxLQUFLMEMsa0JBQUwsQ0FBd0IsVUFBVTV3QyxLQUFWLEVBQWlCO2NBQ3ZDLElBQUlrdUMsTUFBTSxDQUFDN21GLE9BQVAsQ0FBZTh1RSxLQUFmLElBQXdCK1gsTUFBTSxDQUFDNTNCLEdBQVAsQ0FBVzJwQixNQUFuQyxJQUE2Q2pnQyxLQUFLLENBQUN2MEIsS0FBTixFQUFqRCxFQUNFO2dCQUFFLE9BQU8wOEUsU0FBUSxDQUFDamEsTUFBTSxDQUFDNTNCLEdBQVIsRUFBYXRXLEtBQUssQ0FBQ3YyQixJQUFuQixFQUF5QmlqQyxHQUF6QixFQUE4Qmd5QyxJQUE5QixFQUFvQ3hRLE1BQU0sQ0FBQy9pRCxPQUFQLENBQWVtOUQsZUFBbkQsQ0FBZjtlQURKLE1BR0U7Z0JBQUUsT0FBTzU3QyxHQUFHLEdBQUcsQ0FBTixHQUFVMU0sS0FBSyxDQUFDaGpDLElBQU4sRUFBVixHQUF5QmdqQyxLQUFLLENBQUN4L0IsRUFBTixFQUFoQzs7YUFKTixFQUtHNHFDLFFBTEg7V0FIYSxDQW5QTTtVQThQckIwdkMsT0FBTyxFQUFFcGMsUUFBUSxDQUFDLFVBQVNoeUIsR0FBVCxFQUFjZ3lDLElBQWQsRUFBb0I7WUFDcEMsSUFBSTdyQixHQUFHLEdBQUcsS0FBS3ZjLEdBQUwsQ0FBU3VjLEdBQW5CO2dCQUF3QnZjLEdBQUcsR0FBRyxLQUFLQSxHQUFuQzs7WUFDQSxJQUFJdWMsR0FBRyxDQUFDMFIsaUJBQUosRUFBSixFQUNFO2NBQUVqdUIsR0FBRyxDQUFDMDZCLGdCQUFKLENBQXFCLEVBQXJCLEVBQXlCLElBQXpCLEVBQStCLFNBQS9CO2FBREosTUFHRTtjQUFFMEcsbUJBQW1CLENBQUMsSUFBRCxFQUFPLFVBQVUxM0MsS0FBVixFQUFpQjtnQkFDM0MsSUFBSTh1QixLQUFLLEdBQUdxNUIsU0FBUSxDQUFDN3hDLEdBQUQsRUFBTXRXLEtBQUssQ0FBQ3YyQixJQUFaLEVBQWtCaWpDLEdBQWxCLEVBQXVCZ3lDLElBQXZCLEVBQTZCLEtBQTdCLENBQXBCOztnQkFDQSxPQUFPaHlDLEdBQUcsR0FBRyxDQUFOLEdBQVU7a0JBQUMxdkMsSUFBSSxFQUFFOHhELEtBQVA7a0JBQWN0dUQsRUFBRSxFQUFFdy9CLEtBQUssQ0FBQ3YyQjtpQkFBbEMsR0FBMEM7a0JBQUN6TSxJQUFJLEVBQUVnakMsS0FBSyxDQUFDdjJCLElBQWI7a0JBQW1CakosRUFBRSxFQUFFc3VEO2lCQUF4RTtlQUZtQixDQUFuQjs7V0FMVyxDQTlQSTtVQXlRckJ5NUIsUUFBUSxFQUFFLGtCQUFTdnJGLElBQVQsRUFBZW9yRixNQUFmLEVBQXVCMUosSUFBdkIsRUFBNkI4SixVQUE3QixFQUF5QztZQUNqRCxJQUFJOTdDLEdBQUcsR0FBRyxDQUFWO2dCQUFhdC9DLENBQUMsR0FBR283RixVQUFqQjs7WUFDQSxJQUFJSixNQUFNLEdBQUcsQ0FBYixFQUFnQjtjQUFFMTdDLEdBQUcsR0FBRyxDQUFDLENBQVA7Y0FBVTA3QyxNQUFNLEdBQUcsQ0FBQ0EsTUFBVjs7O1lBQzVCLElBQUkvNkMsR0FBRyxHQUFHMkssUUFBTyxDQUFDLEtBQUsxQixHQUFOLEVBQVd0NUMsSUFBWCxDQUFqQjs7WUFDQSxLQUFLLElBQUkvWixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbWxHLE1BQXBCLEVBQTRCLEVBQUVubEcsQ0FBOUIsRUFBaUM7Y0FDL0IsSUFBSXFyRSxNQUFNLEdBQUdJLGFBQVksQ0FBQyxJQUFELEVBQU9yaEIsR0FBUCxFQUFZLEtBQVosQ0FBekI7O2NBQ0EsSUFBSWpnRCxDQUFDLElBQUksSUFBVCxFQUFlO2dCQUFFQSxDQUFDLEdBQUdraEUsTUFBTSxDQUFDdnVDLElBQVg7ZUFBakIsTUFDSztnQkFBRXV1QyxNQUFNLENBQUN2dUMsSUFBUCxHQUFjM3lCLENBQWQ7OztjQUNQaWdELEdBQUcsR0FBR2s3QyxTQUFRLENBQUMsSUFBRCxFQUFPajZCLE1BQVAsRUFBZTVoQixHQUFmLEVBQW9CZ3lDLElBQXBCLENBQWQ7O2NBQ0EsSUFBSXJ4QyxHQUFHLENBQUNnN0MsT0FBUixFQUFpQjtnQkFBRTs7OztZQUVyQixPQUFPaDdDLEdBQVA7V0FwUm1CO1VBdVJyQjJzQyxLQUFLLEVBQUV0YixRQUFRLENBQUMsVUFBU2h5QixHQUFULEVBQWNneUMsSUFBZCxFQUFvQjtZQUNsQyxJQUFJeFEsTUFBTSxHQUFHLElBQWI7WUFFQSxJQUFJNTNCLEdBQUcsR0FBRyxLQUFLQSxHQUFmO2dCQUFvQm15QyxLQUFLLEdBQUcsRUFBNUI7WUFDQSxJQUFJdi9DLFFBQVEsR0FBRyxDQUFDLEtBQUs3aEQsT0FBTCxDQUFhOHVFLEtBQWQsSUFBdUIsQ0FBQzdmLEdBQUcsQ0FBQzJwQixNQUE1QixJQUFzQzNwQixHQUFHLENBQUN1YyxHQUFKLENBQVEwUixpQkFBUixFQUFyRDtZQUNBanVCLEdBQUcsQ0FBQ3M2QixrQkFBSixDQUF1QixVQUFVNXdDLEtBQVYsRUFBaUI7Y0FDdEMsSUFBSWtKLFFBQUosRUFDRTtnQkFBRSxPQUFPd0QsR0FBRyxHQUFHLENBQU4sR0FBVTFNLEtBQUssQ0FBQ2hqQyxJQUFOLEVBQVYsR0FBeUJnakMsS0FBSyxDQUFDeC9CLEVBQU4sRUFBaEM7OztjQUNKLElBQUlrb0YsT0FBTyxHQUFHaDZCLGFBQVksQ0FBQ3dmLE1BQUQsRUFBU2x1QyxLQUFLLENBQUN2MkIsSUFBZixFQUFxQixLQUFyQixDQUExQjs7Y0FDQSxJQUFJdTJCLEtBQUssQ0FBQ3dvRCxVQUFOLElBQW9CLElBQXhCLEVBQThCO2dCQUFFRSxPQUFPLENBQUMzb0UsSUFBUixHQUFlaWdCLEtBQUssQ0FBQ3dvRCxVQUFyQjs7O2NBQ2hDQyxLQUFLLENBQUM3b0csSUFBTixDQUFXOG9HLE9BQU8sQ0FBQzNvRSxJQUFuQjs7Y0FDQSxJQUFJaHBCLEdBQUcsR0FBR3d4RixTQUFRLENBQUNyYSxNQUFELEVBQVN3YSxPQUFULEVBQWtCaDhDLEdBQWxCLEVBQXVCZ3lDLElBQXZCLENBQWxCOztjQUNBLElBQUlBLElBQUksSUFBSSxNQUFSLElBQWtCMStDLEtBQUssSUFBSXNXLEdBQUcsQ0FBQ3VjLEdBQUosQ0FBUUosT0FBUixFQUEvQixFQUNFO2dCQUFFaUcsY0FBYyxDQUFDd1YsTUFBRCxFQUFTemYsV0FBVSxDQUFDeWYsTUFBRCxFQUFTbjNFLEdBQVQsRUFBYyxLQUFkLENBQVYsQ0FBK0I0bUMsR0FBL0IsR0FBcUMrcUQsT0FBTyxDQUFDL3FELEdBQXRELENBQWQ7OztjQUNKLE9BQU81bUMsR0FBUDthQVRGLEVBVUdxMEMsUUFWSDs7WUFXQSxJQUFJcTlDLEtBQUssQ0FBQzVuRyxNQUFWLEVBQWtCO2NBQUUsS0FBSyxJQUFJb0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3F6RCxHQUFHLENBQUN1YyxHQUFKLENBQVFDLE1BQVIsQ0FBZWp5RSxNQUFuQyxFQUEyQ29DLENBQUMsRUFBNUMsRUFDbEI7Z0JBQUVxekQsR0FBRyxDQUFDdWMsR0FBSixDQUFRQyxNQUFSLENBQWU3dkUsQ0FBZixFQUFrQnVsRyxVQUFsQixHQUErQkMsS0FBSyxDQUFDeGxHLENBQUQsQ0FBcEM7OztXQWpCUyxDQXZSTTs7VUE0U3JCdThGLFVBQVUsRUFBRSxvQkFBU3pvRixHQUFULEVBQWM7WUFDeEIsSUFBSXUvQyxHQUFHLEdBQUcsS0FBS0EsR0FBZjtnQkFBb0I5RyxJQUFJLEdBQUc2RyxPQUFPLENBQUNDLEdBQUQsRUFBTXYvQyxHQUFHLENBQUN5NEMsSUFBVixDQUFQLENBQXVCdlEsSUFBbEQ7WUFDQSxJQUFJOWdDLEtBQUssR0FBR3BILEdBQUcsQ0FBQzJPLEVBQWhCO2dCQUFvQmhNLEdBQUcsR0FBRzNDLEdBQUcsQ0FBQzJPLEVBQTlCOztZQUNBLElBQUk4cEMsSUFBSixFQUFVO2NBQ1IsSUFBSW5ELE1BQU0sR0FBRyxLQUFLZzdDLFNBQUwsQ0FBZXR3RixHQUFmLEVBQW9CLFdBQXBCLENBQWI7O2NBQ0EsSUFBSSxDQUFDQSxHQUFHLENBQUN1SyxNQUFKLElBQWMsUUFBZCxJQUEwQjVILEdBQUcsSUFBSTgxQyxJQUFJLENBQUMzdUQsTUFBdkMsS0FBa0RzZCxLQUF0RCxFQUE2RDtnQkFBRSxFQUFFQSxLQUFGO2VBQS9ELE1BQStFO2dCQUFFLEVBQUV6RSxHQUFGOzs7Y0FDakYsSUFBSWl2RixTQUFTLEdBQUduNUMsSUFBSSxDQUFDcHJELE1BQUwsQ0FBWStaLEtBQVosQ0FBaEI7Y0FDQSxJQUFJN1EsS0FBSyxHQUFHOCtDLFVBQVUsQ0FBQ3U4QyxTQUFELEVBQVl0OEMsTUFBWixDQUFWLEdBQ1IsVUFBVTNtQyxFQUFWLEVBQWM7Z0JBQUUsT0FBTzBtQyxVQUFVLENBQUMxbUMsRUFBRCxFQUFLMm1DLE1BQUwsQ0FBakI7ZUFEUixHQUVSLEtBQUs1K0MsSUFBTCxDQUFVazdGLFNBQVYsSUFBdUIsVUFBVWpqRixFQUFWLEVBQWM7Z0JBQUUsT0FBTyxLQUFLalksSUFBTCxDQUFVaVksRUFBVixDQUFQO2VBQXZDLEdBQ0EsVUFBVUEsRUFBVixFQUFjO2dCQUFFLE9BQVEsQ0FBQyxLQUFLalksSUFBTCxDQUFVaVksRUFBVixDQUFELElBQWtCLENBQUMwbUMsVUFBVSxDQUFDMW1DLEVBQUQsQ0FBckM7ZUFIcEI7O2NBSUEsT0FBT3ZILEtBQUssR0FBRyxDQUFSLElBQWE3USxLQUFLLENBQUNraUQsSUFBSSxDQUFDcHJELE1BQUwsQ0FBWStaLEtBQUssR0FBRyxDQUFwQixDQUFELENBQXpCLEVBQW1EO2dCQUFFLEVBQUVBLEtBQUY7OztjQUNyRCxPQUFPekUsR0FBRyxHQUFHODFDLElBQUksQ0FBQzN1RCxNQUFYLElBQXFCeU0sS0FBSyxDQUFDa2lELElBQUksQ0FBQ3ByRCxNQUFMLENBQVlzVixHQUFaLENBQUQsQ0FBakMsRUFBcUQ7Z0JBQUUsRUFBRUEsR0FBRjs7OztZQUV6RCxPQUFPLElBQUk0cUUsS0FBSixDQUFVN3NCLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBTCxFQUFXcnhDLEtBQVgsQ0FBYixFQUFnQ3M1QyxHQUFHLENBQUMxZ0QsR0FBRyxDQUFDeTRDLElBQUwsRUFBVzkxQyxHQUFYLENBQW5DLENBQVA7V0ExVG1CO1VBNlRyQnVpRixlQUFlLEVBQUUseUJBQVNwOUYsS0FBVCxFQUFnQjtZQUMvQixJQUFJQSxLQUFLLElBQUksSUFBVCxJQUFpQkEsS0FBSyxJQUFJLEtBQUt5bkMsS0FBTCxDQUFXNGpCLFNBQXpDLEVBQW9EO2NBQUU7OztZQUN0RCxJQUFJLEtBQUs1akIsS0FBTCxDQUFXNGpCLFNBQVgsR0FBdUIsQ0FBQyxLQUFLNWpCLEtBQUwsQ0FBVzRqQixTQUF2QyxFQUNFO2NBQUVULFFBQVEsQ0FBQyxLQUFLcGlELE9BQUwsQ0FBYW91RSxTQUFkLEVBQXlCLHNCQUF6QixDQUFSO2FBREosTUFHRTtjQUFFcHRCLE9BQU8sQ0FBQyxLQUFLaGhELE9BQUwsQ0FBYW91RSxTQUFkLEVBQXlCLHNCQUF6QixDQUFQOzs7WUFFSnhsQixNQUFNLENBQUMsSUFBRCxFQUFPLGlCQUFQLEVBQTBCLElBQTFCLEVBQWdDLEtBQUszcEIsS0FBTCxDQUFXNGpCLFNBQTNDLENBQU47V0FwVW1CO1VBc1VyQjByQixRQUFRLEVBQUUsb0JBQVc7WUFBRSxPQUFPLEtBQUt2dUUsT0FBTCxDQUFhdThELEtBQWIsQ0FBbUJ3NUIsUUFBbkIsTUFBaUM3ekMsU0FBUyxFQUFqRDtXQXRVRjtVQXVVckJ3cUMsVUFBVSxFQUFFLHNCQUFXO1lBQUUsT0FBTyxDQUFDLEVBQUUsS0FBSzVvRCxPQUFMLENBQWFrekIsUUFBYixJQUF5QixLQUFLL0gsR0FBTCxDQUFTNjBCLFFBQXBDLENBQVI7V0F2VUo7VUF5VXJCeWQsUUFBUSxFQUFFbHFCLFFBQVEsQ0FBQyxVQUFVdHhFLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtZQUFFMnJFLGNBQWMsQ0FBQyxJQUFELEVBQU81ckUsQ0FBUCxFQUFVQyxDQUFWLENBQWQ7V0FBbkIsQ0F6VUc7VUEwVXJCdzdGLGFBQWEsRUFBRSx5QkFBVztZQUN4QixJQUFJai9CLFFBQVEsR0FBRyxLQUFLdmlFLE9BQUwsQ0FBYXVpRSxRQUE1QjtZQUNBLE9BQU87Y0FBQzdwQyxJQUFJLEVBQUU2cEMsUUFBUSxDQUFDNkQsVUFBaEI7Y0FBNEI5dkIsR0FBRyxFQUFFaXNCLFFBQVEsQ0FBQ2lFLFNBQTFDO2NBQ0N4eEIsTUFBTSxFQUFFdXRCLFFBQVEsQ0FBQzRQLFlBQVQsR0FBd0IvUCxTQUFTLENBQUMsSUFBRCxDQUFqQyxHQUEwQyxLQUFLcGlFLE9BQUwsQ0FBYTJpRSxTQURoRTtjQUVDN3RCLEtBQUssRUFBRXl0QixRQUFRLENBQUMrUCxXQUFULEdBQXVCbFEsU0FBUyxDQUFDLElBQUQsQ0FBaEMsR0FBeUMsS0FBS3BpRSxPQUFMLENBQWF3aUUsUUFGOUQ7Y0FHQ0UsWUFBWSxFQUFFRCxhQUFhLENBQUMsSUFBRCxDQUg1QjtjQUdvQ2xCLFdBQVcsRUFBRWUsWUFBWSxDQUFDLElBQUQ7YUFIcEU7V0E1VW1CO1VBa1ZyQjBOLGNBQWMsRUFBRXFILFFBQVEsQ0FBQyxVQUFTMStCLEtBQVQsRUFBZ0J1M0IsTUFBaEIsRUFBd0I7WUFDL0MsSUFBSXYzQixLQUFLLElBQUksSUFBYixFQUFtQjtjQUNqQkEsS0FBSyxHQUFHO2dCQUFDaGpDLElBQUksRUFBRSxLQUFLczVDLEdBQUwsQ0FBU3VjLEdBQVQsQ0FBYUosT0FBYixHQUF1QmhwRCxJQUE5QjtnQkFBb0NqSixFQUFFLEVBQUU7ZUFBaEQ7O2NBQ0EsSUFBSSsyRCxNQUFNLElBQUksSUFBZCxFQUFvQjtnQkFBRUEsTUFBTSxHQUFHLEtBQUtwc0MsT0FBTCxDQUFhNHRDLGtCQUF0Qjs7YUFGeEIsTUFHTyxJQUFJLE9BQU8vNEIsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtjQUNuQ0EsS0FBSyxHQUFHO2dCQUFDaGpDLElBQUksRUFBRXk2QyxHQUFHLENBQUN6WCxLQUFELEVBQVEsQ0FBUixDQUFWO2dCQUFzQngvQixFQUFFLEVBQUU7ZUFBbEM7YUFESyxNQUVBLElBQUl3L0IsS0FBSyxDQUFDaGpDLElBQU4sSUFBYyxJQUFsQixFQUF3QjtjQUM3QmdqQyxLQUFLLEdBQUc7Z0JBQUNoakMsSUFBSSxFQUFFZ2pDLEtBQVA7Z0JBQWN4L0IsRUFBRSxFQUFFO2VBQTFCOzs7WUFFRixJQUFJLENBQUN3L0IsS0FBSyxDQUFDeC9CLEVBQVgsRUFBZTtjQUFFdy9CLEtBQUssQ0FBQ3gvQixFQUFOLEdBQVd3L0IsS0FBSyxDQUFDaGpDLElBQWpCOzs7WUFDakJnakMsS0FBSyxDQUFDdTNCLE1BQU4sR0FBZUEsTUFBTSxJQUFJLENBQXpCOztZQUVBLElBQUl2M0IsS0FBSyxDQUFDaGpDLElBQU4sQ0FBV3d5QyxJQUFYLElBQW1CLElBQXZCLEVBQTZCO2NBQzNCeXBCLGFBQWEsQ0FBQyxJQUFELEVBQU9qNUIsS0FBUCxDQUFiO2FBREYsTUFFTztjQUNMazVCLG1CQUFtQixDQUFDLElBQUQsRUFBT2w1QixLQUFLLENBQUNoakMsSUFBYixFQUFtQmdqQyxLQUFLLENBQUN4L0IsRUFBekIsRUFBNkJ3L0IsS0FBSyxDQUFDdTNCLE1BQW5DLENBQW5COztXQWZvQixDQWxWSDtVQXFXckJ3ZSxPQUFPLEVBQUVyWCxRQUFRLENBQUMsVUFBU3ZpQyxLQUFULEVBQWdCRSxNQUFoQixFQUF3QjtZQUN4QyxJQUFJNnhDLE1BQU0sR0FBRyxJQUFiOztZQUVBLElBQUk0YSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVM3FHLEdBQVYsRUFBZTtjQUFFLE9BQU8sT0FBT0EsR0FBUCxJQUFjLFFBQWQsSUFBMEIsUUFBUXNQLElBQVIsQ0FBYS9NLE1BQU0sQ0FBQ3ZDLEdBQUQsQ0FBbkIsQ0FBMUIsR0FBc0RBLEdBQUcsR0FBRyxJQUE1RCxHQUFtRUEsR0FBMUU7YUFBakM7O1lBQ0EsSUFBSWcrQyxLQUFLLElBQUksSUFBYixFQUFtQjtjQUFFLEtBQUs5MEMsT0FBTCxDQUFheW1CLE9BQWIsQ0FBcUIxbUIsS0FBckIsQ0FBMkIrMEMsS0FBM0IsR0FBbUMyc0QsU0FBUyxDQUFDM3NELEtBQUQsQ0FBNUM7OztZQUNyQixJQUFJRSxNQUFNLElBQUksSUFBZCxFQUFvQjtjQUFFLEtBQUtoMUMsT0FBTCxDQUFheW1CLE9BQWIsQ0FBcUIxbUIsS0FBckIsQ0FBMkJpMUMsTUFBM0IsR0FBb0N5c0QsU0FBUyxDQUFDenNELE1BQUQsQ0FBN0M7OztZQUN0QixJQUFJLEtBQUtsUixPQUFMLENBQWFnL0IsWUFBakIsRUFBK0I7Y0FBRThDLHlCQUF5QixDQUFDLElBQUQsQ0FBekI7OztZQUNqQyxJQUFJalcsTUFBTSxHQUFHLEtBQUszdkQsT0FBTCxDQUFha3pELFFBQTFCO1lBQ0EsS0FBS2pFLEdBQUwsQ0FBU241QyxJQUFULENBQWM2NUMsTUFBZCxFQUFzQixLQUFLM3ZELE9BQUwsQ0FBYW16RCxNQUFuQyxFQUEyQyxVQUFVaEwsSUFBVixFQUFnQjtjQUN6RCxJQUFJQSxJQUFJLENBQUN3WSxPQUFULEVBQWtCO2dCQUFFLEtBQUssSUFBSS9rRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdXNELElBQUksQ0FBQ3dZLE9BQUwsQ0FBYW5uRSxNQUFqQyxFQUF5Q29DLENBQUMsRUFBMUMsRUFDbEI7a0JBQUUsSUFBSXVzRCxJQUFJLENBQUN3WSxPQUFMLENBQWEva0UsQ0FBYixFQUFnQm1sRSxTQUFwQixFQUErQjtvQkFBRTRKLGFBQWEsQ0FBQ2tjLE1BQUQsRUFBU2wzQixNQUFULEVBQWlCLFFBQWpCLENBQWI7b0JBQXlDOzs7OztjQUM5RSxFQUFFQSxNQUFGO2FBSEY7WUFLQSxLQUFLckcsS0FBTCxDQUFXd2EsV0FBWCxHQUF5QixJQUF6QjtZQUNBbGIsTUFBTSxDQUFDLElBQUQsRUFBTyxTQUFQLEVBQWtCLElBQWxCLENBQU47V0FkZSxDQXJXSTtVQXNYckI5TixTQUFTLEVBQUUsbUJBQVNoakQsQ0FBVCxFQUFXO1lBQUMsT0FBT3MvRSxPQUFPLENBQUMsSUFBRCxFQUFPdC9FLENBQVAsQ0FBZDtXQXRYRjtVQXVYckJ1OUUsY0FBYyxFQUFFLDBCQUFVO1lBQUMsT0FBT0EsZUFBYyxDQUFDLElBQUQsQ0FBckI7V0F2WE47VUF3WHJCTyxZQUFZLEVBQUUsd0JBQVU7WUFBQyxPQUFPQSxhQUFZLENBQUMsSUFBRCxDQUFuQjtXQXhYSjtVQTBYckIya0IsT0FBTyxFQUFFbGpCLFFBQVEsQ0FBQyxZQUFXO1lBQzNCLElBQUlsSSxTQUFTLEdBQUcsS0FBS252RSxPQUFMLENBQWFnbUUsZ0JBQTdCO1lBQ0FpRSxTQUFTLENBQUMsSUFBRCxDQUFUO1lBQ0EsS0FBSzNnQixLQUFMLENBQVd3YSxXQUFYLEdBQXlCLElBQXpCO1lBQ0FnQyxXQUFXLENBQUMsSUFBRCxDQUFYO1lBQ0E2TCxjQUFjLENBQUMsSUFBRCxFQUFPLEtBQUsxaUIsR0FBTCxDQUFTbVgsVUFBaEIsRUFBNEIsS0FBS25YLEdBQUwsQ0FBU3VYLFNBQXJDLENBQWQ7WUFDQTZULGlCQUFpQixDQUFDLEtBQUtyNkUsT0FBTixDQUFqQjs7WUFDQSxJQUFJbXZFLFNBQVMsSUFBSSxJQUFiLElBQXFCaDZFLElBQUksQ0FBQ2tYLEdBQUwsQ0FBUzhpRSxTQUFTLEdBQUdoRyxVQUFVLENBQUMsS0FBS25wRSxPQUFOLENBQS9CLElBQWlELEVBQXRFLElBQTRFLEtBQUs4akMsT0FBTCxDQUFhZy9CLFlBQTdGLEVBQ0U7Y0FBRTRHLG1CQUFtQixDQUFDLElBQUQsQ0FBbkI7OztZQUNKOWdCLE1BQU0sQ0FBQyxJQUFELEVBQU8sU0FBUCxFQUFrQixJQUFsQixDQUFOO1dBVGUsQ0ExWEk7VUFzWXJCODRDLE9BQU8sRUFBRXJxQixRQUFRLENBQUMsVUFBU3BvQixHQUFULEVBQWM7WUFDOUIsSUFBSTNoQixHQUFHLEdBQUcsS0FBSzJoQixHQUFmO1lBQ0EzaEIsR0FBRyxDQUFDeWIsRUFBSixHQUFTLElBQVQsQ0FGOEI7O1lBSTlCLElBQUksS0FBSzlwQixLQUFMLENBQVc4M0QsYUFBZixFQUE4QjtjQUFFLEtBQUs5M0QsS0FBTCxDQUFXODNELGFBQVg7OztZQUNoQ3hYLFNBQVMsQ0FBQyxJQUFELEVBQU90d0IsR0FBUCxDQUFUO1lBQ0E2VyxXQUFXLENBQUMsSUFBRCxDQUFYO1lBQ0EsS0FBSzlsRSxPQUFMLENBQWF1OEQsS0FBYixDQUFtQmg4QixLQUFuQjtZQUNBb3hDLGNBQWMsQ0FBQyxJQUFELEVBQU8xaUIsR0FBRyxDQUFDbVgsVUFBWCxFQUF1Qm5YLEdBQUcsQ0FBQ3VYLFNBQTNCLENBQWQ7WUFDQSxLQUFLbGQsS0FBTCxDQUFXNG9CLFdBQVgsR0FBeUIsSUFBekI7WUFDQS9ULFdBQVcsQ0FBQyxJQUFELEVBQU8sU0FBUCxFQUFrQixJQUFsQixFQUF3Qjd3QixHQUF4QixDQUFYO1lBQ0EsT0FBT0EsR0FBUDtXQVhlLENBdFlJO1VBb1pyQnEwRCxNQUFNLEVBQUUsZ0JBQVNDLFVBQVQsRUFBcUI7WUFDM0IsSUFBSUMsT0FBTyxHQUFHLEtBQUsvOUQsT0FBTCxDQUFhKzlELE9BQTNCO1lBQ0EsT0FBT0EsT0FBTyxJQUFJL3JHLE1BQU0sQ0FBQ3dELFNBQVAsQ0FBaUIvRCxjQUFqQixDQUFnQ0csSUFBaEMsQ0FBcUNtc0csT0FBckMsRUFBOENELFVBQTlDLENBQVgsR0FBdUVDLE9BQU8sQ0FBQ0QsVUFBRCxDQUE5RSxHQUE2RkEsVUFBcEc7V0F0Wm1CO1VBeVpyQnBILGFBQWEsRUFBRSx5QkFBVTtZQUFDLE9BQU8sS0FBS3g2RixPQUFMLENBQWF1OEQsS0FBYixDQUFtQnc1QixRQUFuQixFQUFQO1dBelpMO1VBMFpyQi9wQixpQkFBaUIsRUFBRSw2QkFBVTtZQUFDLE9BQU8sS0FBS2hzRSxPQUFMLENBQWF5bUIsT0FBcEI7V0ExWlQ7VUEyWnJCcTdFLGtCQUFrQixFQUFFLDhCQUFVO1lBQUMsT0FBTyxLQUFLOWhHLE9BQUwsQ0FBYXVpRSxRQUFwQjtXQTNaVjtVQTRackJ3L0IsZ0JBQWdCLEVBQUUsNEJBQVU7WUFBQyxPQUFPLEtBQUsvaEcsT0FBTCxDQUFhc2hFLE9BQXBCOztTQTVaL0I7UUE4WkE3WCxVQUFVLENBQUNzaUMsVUFBRCxDQUFWOztRQUVBQSxVQUFVLENBQUNpVyxjQUFYLEdBQTRCLFVBQVNob0csSUFBVCxFQUFlQyxJQUFmLEVBQXFCekMsS0FBckIsRUFBNEI7VUFDdEQsSUFBSSxDQUFDNG5HLE9BQU8sQ0FBQzdwRyxjQUFSLENBQXVCeUUsSUFBdkIsQ0FBTCxFQUFtQztZQUFFb2xHLE9BQU8sQ0FBQ3BsRyxJQUFELENBQVAsR0FBZ0IreEYsVUFBVSxDQUFDL3hGLElBQUQsQ0FBVixHQUFtQjtjQUFDK25DLE9BQU8sRUFBRTthQUE3Qzs7O1VBQ3JDcTlELE9BQU8sQ0FBQ3BsRyxJQUFELENBQVAsQ0FBY0MsSUFBZCxJQUFzQnpDLEtBQXRCO1NBRkY7O1FBSUF1MEYsVUFBVSxDQUFDa1csb0JBQVgsR0FBa0MsVUFBU2pvRyxJQUFULEVBQWVDLElBQWYsRUFBcUIrNUIsU0FBckIsRUFBZ0N4OEIsS0FBaEMsRUFBdUM7VUFDdkV1MEYsVUFBVSxDQUFDaVcsY0FBWCxDQUEwQmhvRyxJQUExQixFQUFnQ0MsSUFBaEMsRUFBc0N6QyxLQUF0Qzs7VUFDQTRuRyxPQUFPLENBQUNwbEcsSUFBRCxDQUFQLENBQWMrbkMsT0FBZCxDQUFzQnhwQyxJQUF0QixDQUEyQjtZQUFDZ3RELElBQUksRUFBRXZ4QixTQUFQO1lBQWtCbDlCLEdBQUcsRUFBRVU7V0FBbEQ7U0FGRjtPQS85UWlCOzs7Ozs7Ozs7OztNQTgrUW5CLFNBQVNzcEcsU0FBVCxDQUFrQjd4QyxHQUFsQixFQUF1QnYvQyxHQUF2QixFQUE0QjIxQyxHQUE1QixFQUFpQ2d5QyxJQUFqQyxFQUF1Q3hHLFFBQXZDLEVBQWlEO1FBQy9DLElBQUl4TixNQUFNLEdBQUczekUsR0FBYjtRQUNBLElBQUl3eUYsT0FBTyxHQUFHNzhDLEdBQWQ7UUFDQSxJQUFJZ1UsT0FBTyxHQUFHckssT0FBTyxDQUFDQyxHQUFELEVBQU12L0MsR0FBRyxDQUFDeTRDLElBQVYsQ0FBckI7UUFDQSxJQUFJZzZDLE9BQU8sR0FBR3RSLFFBQVEsSUFBSTVoQyxHQUFHLENBQUN0SSxTQUFKLElBQWlCLEtBQTdCLEdBQXFDLENBQUN0QixHQUF0QyxHQUE0Q0EsR0FBMUQ7O1FBQ0EsU0FBUys4QyxZQUFULEdBQXdCO1VBQ3RCLElBQUlwL0YsQ0FBQyxHQUFHME0sR0FBRyxDQUFDeTRDLElBQUosR0FBV2c2QyxPQUFuQjs7VUFDQSxJQUFJbi9GLENBQUMsR0FBR2lzRCxHQUFHLENBQUN2bEQsS0FBUixJQUFpQjFHLENBQUMsSUFBSWlzRCxHQUFHLENBQUN2bEQsS0FBSixHQUFZdWxELEdBQUcsQ0FBQ3Y3QyxJQUExQyxFQUFnRDtZQUFFLE9BQU8sS0FBUDs7O1VBQ2xEaEUsR0FBRyxHQUFHLElBQUkwZ0QsR0FBSixDQUFRcHRELENBQVIsRUFBVzBNLEdBQUcsQ0FBQzJPLEVBQWYsRUFBbUIzTyxHQUFHLENBQUN1SyxNQUF2QixDQUFOO1VBQ0EsT0FBT28vQyxPQUFPLEdBQUdySyxPQUFPLENBQUNDLEdBQUQsRUFBTWpzRCxDQUFOLENBQXhCOzs7UUFFRixTQUFTcS9GLFFBQVQsQ0FBa0JDLFdBQWxCLEVBQStCO1VBQzdCLElBQUl6eUYsSUFBSjs7VUFDQSxJQUFJd25GLElBQUksSUFBSSxXQUFaLEVBQXlCO1lBQ3ZCLElBQUloNUUsRUFBRSxHQUFHZzdDLE9BQU8sQ0FBQ3poQixJQUFSLENBQWFqdUMsVUFBYixDQUF3QitGLEdBQUcsQ0FBQzJPLEVBQUosSUFBVWduQyxHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVYsR0FBYyxDQUFDLENBQXpCLENBQXhCLENBQVQ7O1lBQ0EsSUFBSTduRCxLQUFLLENBQUM2Z0IsRUFBRCxDQUFULEVBQWU7Y0FDYnhPLElBQUksR0FBRyxJQUFQO2FBREYsTUFFTztjQUNMLElBQUkweUYsTUFBTSxHQUFHbDlDLEdBQUcsR0FBRyxDQUFOLEdBQVVobkMsRUFBRSxJQUFJLE1BQU4sSUFBZ0JBLEVBQUUsR0FBRyxNQUEvQixHQUF3Q0EsRUFBRSxJQUFJLE1BQU4sSUFBZ0JBLEVBQUUsR0FBRyxNQUExRTtjQUNBeE8sSUFBSSxHQUFHLElBQUl1Z0QsR0FBSixDQUFRMWdELEdBQUcsQ0FBQ3k0QyxJQUFaLEVBQWtCaHpELElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVl4SSxJQUFJLENBQUNzSSxHQUFMLENBQVM0N0QsT0FBTyxDQUFDemhCLElBQVIsQ0FBYXArQyxNQUF0QixFQUE4QmtXLEdBQUcsQ0FBQzJPLEVBQUosR0FBU2duQyxHQUFHLElBQUlrOUMsTUFBTSxHQUFHLENBQUgsR0FBTyxDQUFqQixDQUExQyxDQUFaLENBQWxCLEVBQStGLENBQUNsOUMsR0FBaEcsQ0FBUDs7V0FOSixNQVFPLElBQUl3ckMsUUFBSixFQUFjO1lBQ25CaGhGLElBQUksR0FBR21oRixZQUFZLENBQUMvaEMsR0FBRyxDQUFDbEcsRUFBTCxFQUFTc1EsT0FBVCxFQUFrQjNwRCxHQUFsQixFQUF1QjIxQyxHQUF2QixDQUFuQjtXQURLLE1BRUE7WUFDTHgxQyxJQUFJLEdBQUc4Z0YsYUFBYSxDQUFDdDNCLE9BQUQsRUFBVTNwRCxHQUFWLEVBQWUyMUMsR0FBZixDQUFwQjs7O1VBRUYsSUFBSXgxQyxJQUFJLElBQUksSUFBWixFQUFrQjtZQUNoQixJQUFJLENBQUN5eUYsV0FBRCxJQUFnQkYsWUFBWSxFQUFoQyxFQUNFO2NBQUUxeUYsR0FBRyxHQUFHa2hGLFNBQVMsQ0FBQ0MsUUFBRCxFQUFXNWhDLEdBQUcsQ0FBQ2xHLEVBQWYsRUFBbUJzUSxPQUFuQixFQUE0QjNwRCxHQUFHLENBQUN5NEMsSUFBaEMsRUFBc0NnNkMsT0FBdEMsQ0FBZjthQURKLE1BR0U7Y0FBRSxPQUFPLEtBQVA7O1dBSk4sTUFLTztZQUNMenlGLEdBQUcsR0FBR0csSUFBTjs7O1VBRUYsT0FBTyxJQUFQOzs7UUFHRixJQUFJd25GLElBQUksSUFBSSxNQUFSLElBQWtCQSxJQUFJLElBQUksV0FBOUIsRUFBMkM7VUFDekNnTCxRQUFRO1NBRFYsTUFFTyxJQUFJaEwsSUFBSSxJQUFJLFFBQVosRUFBc0I7VUFDM0JnTCxRQUFRLENBQUMsSUFBRCxDQUFSO1NBREssTUFFQSxJQUFJaEwsSUFBSSxJQUFJLE1BQVIsSUFBa0JBLElBQUksSUFBSSxPQUE5QixFQUF1QztVQUM1QyxJQUFJbUwsT0FBTyxHQUFHLElBQWQ7Y0FBb0Iza0MsS0FBSyxHQUFHdzVCLElBQUksSUFBSSxPQUFwQztVQUNBLElBQUlyeUMsTUFBTSxHQUFHaUssR0FBRyxDQUFDbEcsRUFBSixJQUFVa0csR0FBRyxDQUFDbEcsRUFBSixDQUFPaTNDLFNBQVAsQ0FBaUJ0d0YsR0FBakIsRUFBc0IsV0FBdEIsQ0FBdkI7O1VBQ0EsS0FBSyxJQUFJaEcsS0FBSyxHQUFHLElBQWpCLEdBQXdCQSxLQUFLLEdBQUcsS0FBaEMsRUFBdUM7WUFDckMsSUFBSTI3QyxHQUFHLEdBQUcsQ0FBTixJQUFXLENBQUNnOUMsUUFBUSxDQUFDLENBQUMzNEYsS0FBRixDQUF4QixFQUFrQztjQUFFOzs7WUFDcEMsSUFBSXM4QyxHQUFHLEdBQUdxVCxPQUFPLENBQUN6aEIsSUFBUixDQUFhNzZDLE1BQWIsQ0FBb0IyUyxHQUFHLENBQUMyTyxFQUF4QixLQUErQixJQUF6QztZQUNBLElBQUlya0IsSUFBSSxHQUFHK3FELFVBQVUsQ0FBQ2lCLEdBQUQsRUFBTWhCLE1BQU4sQ0FBVixHQUEwQixHQUExQixHQUNQNlksS0FBSyxJQUFJN1gsR0FBRyxJQUFJLElBQWhCLEdBQXVCLEdBQXZCLEdBQ0EsQ0FBQzZYLEtBQUQsSUFBVSxLQUFLejNELElBQUwsQ0FBVTQvQyxHQUFWLENBQVYsR0FBMkIsSUFBM0IsR0FDQSxHQUhKOztZQUlBLElBQUk2WCxLQUFLLElBQUksQ0FBQ24wRCxLQUFWLElBQW1CLENBQUMxUCxJQUF4QixFQUE4QjtjQUFFQSxJQUFJLEdBQUcsR0FBUDs7O1lBQ2hDLElBQUl3b0csT0FBTyxJQUFJQSxPQUFPLElBQUl4b0csSUFBMUIsRUFBZ0M7Y0FDOUIsSUFBSXFyRCxHQUFHLEdBQUcsQ0FBVixFQUFhO2dCQUFDQSxHQUFHLEdBQUcsQ0FBTjtnQkFBU2c5QyxRQUFRO2dCQUFJM3lGLEdBQUcsQ0FBQ3VLLE1BQUosR0FBYSxPQUFiOzs7Y0FDbkM7OztZQUdGLElBQUlqZ0IsSUFBSixFQUFVO2NBQUV3b0csT0FBTyxHQUFHeG9HLElBQVY7OztZQUNaLElBQUlxckQsR0FBRyxHQUFHLENBQU4sSUFBVyxDQUFDZzlDLFFBQVEsQ0FBQyxDQUFDMzRGLEtBQUYsQ0FBeEIsRUFBa0M7Y0FBRTs7Ozs7UUFHeEMsSUFBSWxMLE1BQU0sR0FBRzBrRixVQUFVLENBQUNqMEIsR0FBRCxFQUFNdi9DLEdBQU4sRUFBVzJ6RSxNQUFYLEVBQW1CNmUsT0FBbkIsRUFBNEIsSUFBNUIsQ0FBdkI7O1FBQ0EsSUFBSTV4QyxjQUFjLENBQUMreUIsTUFBRCxFQUFTN2tGLE1BQVQsQ0FBbEIsRUFBb0M7VUFBRUEsTUFBTSxDQUFDd2lHLE9BQVAsR0FBaUIsSUFBakI7OztRQUN0QyxPQUFPeGlHLE1BQVA7T0E3aVJpQjs7Ozs7TUFtalJuQixTQUFTMGlHLFNBQVQsQ0FBa0JuNEMsRUFBbEIsRUFBc0JyNUMsR0FBdEIsRUFBMkIyMUMsR0FBM0IsRUFBZ0NneUMsSUFBaEMsRUFBc0M7UUFDcEMsSUFBSXBvQyxHQUFHLEdBQUdsRyxFQUFFLENBQUNrRyxHQUFiO1lBQWtCbHBELENBQUMsR0FBRzJKLEdBQUcsQ0FBQ2dwQixJQUExQjtZQUFnQzF5QixDQUFoQzs7UUFDQSxJQUFJcXhGLElBQUksSUFBSSxNQUFaLEVBQW9CO1VBQ2xCLElBQUlvTCxRQUFRLEdBQUd0dEcsSUFBSSxDQUFDc0ksR0FBTCxDQUFTc3JELEVBQUUsQ0FBQy9vRCxPQUFILENBQVd5bUIsT0FBWCxDQUFtQmk4QyxZQUE1QixFQUEwQ3h0RSxNQUFNLENBQUM0NkUsV0FBUCxJQUFzQnY1RSxRQUFRLENBQUNpSixlQUFULENBQXlCa2pFLFlBQXpGLENBQWY7VUFDQSxJQUFJZ2dDLFVBQVUsR0FBR3Z0RyxJQUFJLENBQUN3SSxHQUFMLENBQVM4a0csUUFBUSxHQUFHLEtBQUt0NUIsVUFBVSxDQUFDcGdCLEVBQUUsQ0FBQy9vRCxPQUFKLENBQW5DLEVBQWlELENBQWpELENBQWpCO1VBQ0FnRyxDQUFDLEdBQUcsQ0FBQ3EvQyxHQUFHLEdBQUcsQ0FBTixHQUFVMzFDLEdBQUcsQ0FBQ3l6RCxNQUFkLEdBQXVCenpELEdBQUcsQ0FBQzRtQyxHQUE1QixJQUFtQytPLEdBQUcsR0FBR3E5QyxVQUE3QztTQUhGLE1BS08sSUFBSXJMLElBQUksSUFBSSxNQUFaLEVBQW9CO1VBQ3pCcnhGLENBQUMsR0FBR3EvQyxHQUFHLEdBQUcsQ0FBTixHQUFVMzFDLEdBQUcsQ0FBQ3l6RCxNQUFKLEdBQWEsQ0FBdkIsR0FBMkJ6ekQsR0FBRyxDQUFDNG1DLEdBQUosR0FBVSxDQUF6Qzs7O1FBRUYsSUFBSTM3QyxNQUFKOztRQUNBLFNBQVM7VUFDUEEsTUFBTSxHQUFHbXRFLFdBQVUsQ0FBQy9lLEVBQUQsRUFBS2hqRCxDQUFMLEVBQVFDLENBQVIsQ0FBbkI7O1VBQ0EsSUFBSSxDQUFDckwsTUFBTSxDQUFDaXRFLE9BQVosRUFBcUI7WUFBRTs7O1VBQ3ZCLElBQUl2aUIsR0FBRyxHQUFHLENBQU4sR0FBVXIvQyxDQUFDLElBQUksQ0FBZixHQUFtQkEsQ0FBQyxJQUFJaXBELEdBQUcsQ0FBQ2phLE1BQWhDLEVBQXdDO1lBQUVyNkMsTUFBTSxDQUFDcW1HLE9BQVAsR0FBaUIsSUFBakI7WUFBdUI7OztVQUNqRWg3RixDQUFDLElBQUlxL0MsR0FBRyxHQUFHLENBQVg7OztRQUVGLE9BQU8xcUQsTUFBUDtPQXBrUmlCOzs7TUF5a1JuQixJQUFJZ29HLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBUzU1QyxFQUFULEVBQWE7UUFDdEMsS0FBS0EsRUFBTCxHQUFVQSxFQUFWO1FBQ0EsS0FBSzY1QyxjQUFMLEdBQXNCLEtBQUtDLGdCQUFMLEdBQXdCLEtBQUtDLGFBQUwsR0FBcUIsS0FBS0MsZUFBTCxHQUF1QixJQUExRjtRQUNBLEtBQUtDLE9BQUwsR0FBZSxJQUFJNS9DLE9BQUosRUFBZjtRQUNBLEtBQUs2L0MsU0FBTCxHQUFpQixJQUFqQjtRQUNBLEtBQUtDLFdBQUwsR0FBbUIsS0FBbkI7UUFDQSxLQUFLQyxjQUFMLEdBQXNCLElBQXRCO09BTkY7O01BU0FSLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCbzhCLElBQS9CLEdBQXNDLFVBQVUxMUIsT0FBVixFQUFtQjtRQUNyRCxJQUFJNm1GLE1BQU0sR0FBRyxJQUFiO1FBRUYsSUFBSXRxQixLQUFLLEdBQUcsSUFBWjtZQUFrQnhULEVBQUUsR0FBR3dULEtBQUssQ0FBQ3hULEVBQTdCO1FBQ0EsSUFBSXo2QyxHQUFHLEdBQUdpdUQsS0FBSyxDQUFDanVELEdBQU4sR0FBWXRPLE9BQU8sQ0FBQ2l2RSxPQUE5QjtRQUNBM2dFLEdBQUcsQ0FBQzgwRixlQUFKLEdBQXNCLElBQXRCO1FBQ0FyRSxtQkFBbUIsQ0FBQ3p3RixHQUFELEVBQU15NkMsRUFBRSxDQUFDamxCLE9BQUgsQ0FBVzIyRCxVQUFqQixFQUE2QjF4QyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXNDJELFdBQXhDLEVBQXFEM3hDLEVBQUUsQ0FBQ2psQixPQUFILENBQVc2MkQsY0FBaEUsQ0FBbkI7O1FBRUEsU0FBUzBJLGNBQVQsQ0FBd0J6dEcsQ0FBeEIsRUFBMkI7VUFDekIsS0FBSyxJQUFJd1YsQ0FBQyxHQUFHeFYsQ0FBQyxDQUFDK0UsTUFBZixFQUF1QnlRLENBQXZCLEVBQTBCQSxDQUFDLEdBQUdBLENBQUMsQ0FBQzQ4QixVQUFoQyxFQUE0QztZQUMxQyxJQUFJNThCLENBQUMsSUFBSWtELEdBQVQsRUFBYztjQUFFLE9BQU8sSUFBUDs7O1lBQ2hCLElBQUksaUNBQWlDbEksSUFBakMsQ0FBc0NnRixDQUFDLENBQUM4MUMsU0FBeEMsQ0FBSixFQUF3RDtjQUFFOzs7O1VBRTVELE9BQU8sS0FBUDs7O1FBR0ZtSCxFQUFFLENBQUMvNUMsR0FBRCxFQUFNLE9BQU4sRUFBZSxVQUFVMVksQ0FBVixFQUFhO1VBQzVCLElBQUksQ0FBQ3l0RyxjQUFjLENBQUN6dEcsQ0FBRCxDQUFmLElBQXNCa3pELGNBQWMsQ0FBQ0MsRUFBRCxFQUFLbnpELENBQUwsQ0FBcEMsSUFBK0N5b0csV0FBVyxDQUFDem9HLENBQUQsRUFBSW16RCxFQUFKLENBQTlELEVBQXVFO1lBQUU7V0FEN0M7OztVQUc1QixJQUFJckosVUFBVSxJQUFJLEVBQWxCLEVBQXNCO1lBQUU5OUIsVUFBVSxDQUFDazVCLFNBQVMsQ0FBQ2lPLEVBQUQsRUFBSyxZQUFZO2NBQUUsT0FBTzg5QixNQUFNLENBQUN5YyxhQUFQLEVBQVA7YUFBbkIsQ0FBVixFQUFnRSxFQUFoRSxDQUFWOztTQUh4QixDQUFGO1FBTUFqN0MsRUFBRSxDQUFDLzVDLEdBQUQsRUFBTSxrQkFBTixFQUEwQixVQUFVMVksQ0FBVixFQUFhO1VBQ3ZDaXhGLE1BQU0sQ0FBQ29jLFNBQVAsR0FBbUI7WUFBQ3I0RixJQUFJLEVBQUVoVixDQUFDLENBQUNnVixJQUFUO1lBQWU4RyxJQUFJLEVBQUU7V0FBeEM7U0FEQSxDQUFGO1FBR0EyMkMsRUFBRSxDQUFDLzVDLEdBQUQsRUFBTSxtQkFBTixFQUEyQixVQUFVMVksQ0FBVixFQUFhO1VBQ3hDLElBQUksQ0FBQ2l4RixNQUFNLENBQUNvYyxTQUFaLEVBQXVCO1lBQUVwYyxNQUFNLENBQUNvYyxTQUFQLEdBQW1CO2NBQUNyNEYsSUFBSSxFQUFFaFYsQ0FBQyxDQUFDZ1YsSUFBVDtjQUFlOEcsSUFBSSxFQUFFO2FBQXhDOztTQUR6QixDQUFGO1FBR0EyMkMsRUFBRSxDQUFDLzVDLEdBQUQsRUFBTSxnQkFBTixFQUF3QixVQUFVMVksQ0FBVixFQUFhO1VBQ3JDLElBQUlpeEYsTUFBTSxDQUFDb2MsU0FBWCxFQUFzQjtZQUNwQixJQUFJcnRHLENBQUMsQ0FBQ2dWLElBQUYsSUFBVWk4RSxNQUFNLENBQUNvYyxTQUFQLENBQWlCcjRGLElBQS9CLEVBQXFDO2NBQUVpOEUsTUFBTSxDQUFDMGMsZUFBUDs7O1lBQ3ZDMWMsTUFBTSxDQUFDb2MsU0FBUCxDQUFpQnZ4RixJQUFqQixHQUF3QixJQUF4Qjs7U0FIRixDQUFGO1FBT0EyMkMsRUFBRSxDQUFDLzVDLEdBQUQsRUFBTSxZQUFOLEVBQW9CLFlBQVk7VUFBRSxPQUFPaXVELEtBQUssQ0FBQ2luQyxtQkFBTixFQUFQO1NBQWxDLENBQUY7UUFFQW43QyxFQUFFLENBQUMvNUMsR0FBRCxFQUFNLE9BQU4sRUFBZSxZQUFZO1VBQzNCLElBQUksQ0FBQ3U0RSxNQUFNLENBQUNvYyxTQUFaLEVBQXVCO1lBQUVwYyxNQUFNLENBQUMwYyxlQUFQOztTQUR6QixDQUFGOztRQUlBLFNBQVNFLFNBQVQsQ0FBbUI3dEcsQ0FBbkIsRUFBc0I7VUFDcEIsSUFBSSxDQUFDeXRHLGNBQWMsQ0FBQ3p0RyxDQUFELENBQWYsSUFBc0JrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUF4QyxFQUFpRDtZQUFFOzs7VUFDbkQsSUFBSW16RCxFQUFFLENBQUNtMEIsaUJBQUgsRUFBSixFQUE0QjtZQUMxQnVnQixhQUFhLENBQUM7Y0FBQ1UsUUFBUSxFQUFFLEtBQVg7Y0FBa0J2bUQsSUFBSSxFQUFFbVIsRUFBRSxDQUFDMmdDLGFBQUg7YUFBekIsQ0FBYjs7WUFDQSxJQUFJOXpGLENBQUMsQ0FBQ29FLElBQUYsSUFBVSxLQUFkLEVBQXFCO2NBQUUrdUQsRUFBRSxDQUFDNGdDLGdCQUFILENBQW9CLEVBQXBCLEVBQXdCLElBQXhCLEVBQThCLEtBQTlCOztXQUZ6QixNQUdPLElBQUksQ0FBQzVnQyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXNC9ELGVBQWhCLEVBQWlDO1lBQ3RDO1dBREssTUFFQTtZQUNMLElBQUlqNEIsTUFBTSxHQUFHb3pCLGNBQWMsQ0FBQzkxQyxFQUFELENBQTNCO1lBQ0EwMEMsYUFBYSxDQUFDO2NBQUNVLFFBQVEsRUFBRSxJQUFYO2NBQWlCdm1ELElBQUksRUFBRTZ6QixNQUFNLENBQUM3ekI7YUFBL0IsQ0FBYjs7WUFDQSxJQUFJaGlELENBQUMsQ0FBQ29FLElBQUYsSUFBVSxLQUFkLEVBQXFCO2NBQ25CK3VELEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFZO2dCQUN2QmlPLEVBQUUsQ0FBQ3lnQyxhQUFILENBQWlCL2QsTUFBTSxDQUFDQSxNQUF4QixFQUFnQyxDQUFoQyxFQUFtQzluQixjQUFuQztnQkFDQW9GLEVBQUUsQ0FBQzRnQyxnQkFBSCxDQUFvQixFQUFwQixFQUF3QixJQUF4QixFQUE4QixLQUE5QjtlQUZGOzs7O1VBTUosSUFBSS96RixDQUFDLENBQUMyb0csYUFBTixFQUFxQjtZQUNuQjNvRyxDQUFDLENBQUMyb0csYUFBRixDQUFnQm9GLFNBQWhCO1lBQ0EsSUFBSXArRCxPQUFPLEdBQUdpNEQsVUFBVSxDQUFDNWxELElBQVgsQ0FBZ0J4K0MsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBZCxDQUZtQjs7WUFJbkJ4RCxDQUFDLENBQUMyb0csYUFBRixDQUFnQjlRLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDbG9ELE9BQWhDOztZQUNBLElBQUkzdkMsQ0FBQyxDQUFDMm9HLGFBQUYsQ0FBZ0JoUixPQUFoQixDQUF3QixNQUF4QixLQUFtQ2hvRCxPQUF2QyxFQUFnRDtjQUM5QzN2QyxDQUFDLENBQUM4OUMsY0FBRjtjQUNBOztXQXhCZ0I7OztVQTRCcEIsSUFBSWt3RCxNQUFNLEdBQUczRSxjQUFjLEVBQTNCO2NBQStCN3pDLEVBQUUsR0FBR3c0QyxNQUFNLENBQUNuK0QsVUFBM0M7VUFDQXNqQixFQUFFLENBQUMvb0QsT0FBSCxDQUFXNGhFLFNBQVgsQ0FBcUJ2OUIsWUFBckIsQ0FBa0N1L0QsTUFBbEMsRUFBMEM3NkMsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzRoRSxTQUFYLENBQXFCbjhCLFVBQS9EO1VBQ0EybEIsRUFBRSxDQUFDNXpELEtBQUgsR0FBV2dtRyxVQUFVLENBQUM1bEQsSUFBWCxDQUFnQngrQyxJQUFoQixDQUFxQixJQUFyQixDQUFYO1VBQ0EsSUFBSXlxRyxRQUFRLEdBQUczaEQsU0FBUyxFQUF4QjtVQUNBSyxXQUFXLENBQUM2SSxFQUFELENBQVg7VUFDQXhwQyxVQUFVLENBQUMsWUFBWTtZQUNyQm1uQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXNGhFLFNBQVgsQ0FBcUJqZ0QsV0FBckIsQ0FBaUNpaUYsTUFBakM7WUFDQUMsUUFBUSxDQUFDcG1ELEtBQVQ7O1lBQ0EsSUFBSW9tRCxRQUFRLElBQUl2MUYsR0FBaEIsRUFBcUI7Y0FBRWl1RCxLQUFLLENBQUN1bkMsb0JBQU47O1dBSGYsRUFJUCxFQUpPLENBQVY7OztRQU1GejdDLEVBQUUsQ0FBQy81QyxHQUFELEVBQU0sTUFBTixFQUFjbTFGLFNBQWQsQ0FBRjtRQUNBcDdDLEVBQUUsQ0FBQy81QyxHQUFELEVBQU0sS0FBTixFQUFhbTFGLFNBQWIsQ0FBRjtPQWpGRjs7TUFvRkFkLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCMmhHLHdCQUEvQixHQUEwRCxVQUFVOEksS0FBVixFQUFpQjs7UUFFekUsSUFBR0EsS0FBSCxFQUFVO1VBQ1IsS0FBS3oxRixHQUFMLENBQVM4N0IsWUFBVCxDQUFzQixZQUF0QixFQUFvQzI1RCxLQUFwQztTQURGLE1BRU87VUFDTCxLQUFLejFGLEdBQUwsQ0FBU200QixlQUFULENBQXlCLFlBQXpCOztPQUxKOztNQVNBazhELG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCNnhFLGdCQUEvQixHQUFrRCxZQUFZO1FBQzVELElBQUkzc0UsTUFBTSxHQUFHMnNFLGdCQUFnQixDQUFDLEtBQUtwaUIsRUFBTixFQUFVLEtBQVYsQ0FBN0I7UUFDQXZxRCxNQUFNLENBQUNpL0MsS0FBUCxHQUFleUUsU0FBUyxNQUFNLEtBQUs1ekMsR0FBbkM7UUFDQSxPQUFPOVAsTUFBUDtPQUhGOztNQU1BbWtHLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCNHhFLGFBQS9CLEdBQStDLFVBQVV2ckMsSUFBVixFQUFnQmkzQyxTQUFoQixFQUEyQjtRQUN4RSxJQUFJLENBQUNqM0MsSUFBRCxJQUFTLENBQUMsS0FBS29wQixFQUFMLENBQVEvb0QsT0FBUixDQUFnQmt0QixJQUFoQixDQUFxQjF6QixNQUFuQyxFQUEyQztVQUFFOzs7UUFDN0MsSUFBSW1tQyxJQUFJLENBQUM4ZCxLQUFMLElBQWNtNUIsU0FBbEIsRUFBNkI7VUFBRSxLQUFLa3RCLG9CQUFMOzs7UUFDL0IsS0FBS0Usc0JBQUwsQ0FBNEJya0UsSUFBNUI7T0FIRjs7TUFNQWdqRSxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQjZ4RCxZQUEvQixHQUE4QyxZQUFZO1FBQ3hELE9BQU8sS0FBS3BDLEVBQUwsQ0FBUS9vRCxPQUFSLENBQWdCeW1CLE9BQWhCLENBQXdCNGtDLGFBQXhCLENBQXNDRixZQUF0QyxFQUFQO09BREY7O01BSUF3M0Msb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0J3cUcsb0JBQS9CLEdBQXNELFlBQVk7UUFDaEUsSUFBSXQ0QixHQUFHLEdBQUcsS0FBS3JnQixZQUFMLEVBQVY7WUFBK0JwQyxFQUFFLEdBQUcsS0FBS0EsRUFBekM7WUFBNkN1MEIsSUFBSSxHQUFHdjBCLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VjLEdBQVAsQ0FBV0osT0FBWCxFQUFwRDtRQUNBLElBQUl6MUQsSUFBSSxHQUFHMm5FLElBQUksQ0FBQzNuRSxJQUFMLEVBQVg7WUFBd0J3RCxFQUFFLEdBQUdta0UsSUFBSSxDQUFDbmtFLEVBQUwsRUFBN0I7O1FBRUEsSUFBSTR2QyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQVgsSUFBcUJwSyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQWhDLElBQTRDdjlDLElBQUksQ0FBQ3d5QyxJQUFMLElBQWFZLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBcEUsSUFBOEVoNkMsRUFBRSxDQUFDZ3ZDLElBQUgsR0FBVVksRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t6RCxRQUF2RyxFQUFpSDtVQUMvR3NZLEdBQUcsQ0FBQzJOLGVBQUo7VUFDQTs7O1FBR0YsSUFBSThxQixTQUFTLEdBQUdDLFFBQVEsQ0FBQ243QyxFQUFELEVBQUt5aUIsR0FBRyxDQUFDbU4sVUFBVCxFQUFxQm5OLEdBQUcsQ0FBQ3FOLFlBQXpCLENBQXhCO1FBQ0EsSUFBSXNyQixRQUFRLEdBQUdELFFBQVEsQ0FBQ243QyxFQUFELEVBQUt5aUIsR0FBRyxDQUFDc04sU0FBVCxFQUFvQnROLEdBQUcsQ0FBQ3VOLFdBQXhCLENBQXZCOztRQUNBLElBQUlrckIsU0FBUyxJQUFJLENBQUNBLFNBQVMsQ0FBQ0csR0FBeEIsSUFBK0JELFFBQS9CLElBQTJDLENBQUNBLFFBQVEsQ0FBQ0MsR0FBckQsSUFDQS96QyxHQUFHLENBQUNJLE1BQU0sQ0FBQ3d6QyxTQUFELEVBQVlFLFFBQVosQ0FBUCxFQUE4Qnh1RixJQUE5QixDQUFILElBQTBDLENBRDFDLElBRUEwNkMsR0FBRyxDQUFDRyxNQUFNLENBQUN5ekMsU0FBRCxFQUFZRSxRQUFaLENBQVAsRUFBOEJockYsRUFBOUIsQ0FBSCxJQUF3QyxDQUY1QyxFQUdFO1VBQUU7OztRQUVKLElBQUkrVCxJQUFJLEdBQUc2N0IsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t0QixJQUF0QjtRQUNBLElBQUlwVyxLQUFLLEdBQUluQixJQUFJLENBQUN3eUMsSUFBTCxJQUFhWSxFQUFFLENBQUMvb0QsT0FBSCxDQUFXa3pELFFBQXhCLElBQW9DbXhDLFFBQVEsQ0FBQ3Q3QyxFQUFELEVBQUtwekMsSUFBTCxDQUE3QyxJQUNSO1VBQUNvTixJQUFJLEVBQUVtSyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFxOUIsT0FBUixDQUFnQnJ5QyxHQUFoQixDQUFvQixDQUFwQixDQUFQO1VBQStCOFYsTUFBTSxFQUFFO1NBRDNDO1FBRUEsSUFBSTNiLEdBQUcsR0FBRzhHLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVVZLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdtekQsTUFBckIsSUFBK0JreEMsUUFBUSxDQUFDdDdDLEVBQUQsRUFBSzV2QyxFQUFMLENBQWpEOztRQUNBLElBQUksQ0FBQzlHLEdBQUwsRUFBVTtVQUNSLElBQUlrNEMsT0FBTyxHQUFHcjlCLElBQUksQ0FBQ0EsSUFBSSxDQUFDMXpCLE1BQUwsR0FBYyxDQUFmLENBQUosQ0FBc0Ird0QsT0FBcEM7VUFDQSxJQUFJcnlDLEdBQUcsR0FBR3F5QyxPQUFPLENBQUMyUSxJQUFSLEdBQWUzUSxPQUFPLENBQUMyUSxJQUFSLENBQWEzUSxPQUFPLENBQUMyUSxJQUFSLENBQWExaEUsTUFBYixHQUFzQixDQUFuQyxDQUFmLEdBQXVEK3dELE9BQU8sQ0FBQ3J5QyxHQUF6RTtVQUNBN0YsR0FBRyxHQUFHO1lBQUMwUSxJQUFJLEVBQUU3SyxHQUFHLENBQUNBLEdBQUcsQ0FBQzFlLE1BQUosR0FBYSxDQUFkLENBQVY7WUFBNEJ3MEIsTUFBTSxFQUFFOVYsR0FBRyxDQUFDQSxHQUFHLENBQUMxZSxNQUFKLEdBQWEsQ0FBZCxDQUFILEdBQXNCMGUsR0FBRyxDQUFDQSxHQUFHLENBQUMxZSxNQUFKLEdBQWEsQ0FBZDtXQUFuRTs7O1FBR0YsSUFBSSxDQUFDc2QsS0FBRCxJQUFVLENBQUN6RSxHQUFmLEVBQW9CO1VBQ2xCbTVELEdBQUcsQ0FBQzJOLGVBQUo7VUFDQTs7O1FBR0YsSUFBSTdyQyxHQUFHLEdBQUdrK0IsR0FBRyxDQUFDODRCLFVBQUosSUFBa0I5NEIsR0FBRyxDQUFDKzRCLFVBQUosQ0FBZSxDQUFmLENBQTVCO1lBQStDQyxHQUEvQzs7UUFDQSxJQUFJO1VBQUVBLEdBQUcsR0FBRzdyRCxLQUFLLENBQUM3aEMsS0FBSyxDQUFDaU0sSUFBUCxFQUFhak0sS0FBSyxDQUFDa1gsTUFBbkIsRUFBMkIzYixHQUFHLENBQUMyYixNQUEvQixFQUF1QzNiLEdBQUcsQ0FBQzBRLElBQTNDLENBQVg7U0FBTixDQUNBLE9BQU1udEIsQ0FBTixFQUFTLEVBakN1RDs7O1FBa0NoRSxJQUFJNHVHLEdBQUosRUFBUztVQUNQLElBQUksQ0FBQ25sRCxLQUFELElBQVUwSixFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQXZCLEVBQWdDO1lBQzlCekMsR0FBRyxDQUFDM3BCLFFBQUosQ0FBYS9xQyxLQUFLLENBQUNpTSxJQUFuQixFQUF5QmpNLEtBQUssQ0FBQ2tYLE1BQS9COztZQUNBLElBQUksQ0FBQ3cyRSxHQUFHLENBQUNyc0MsU0FBVCxFQUFvQjtjQUNsQnFULEdBQUcsQ0FBQzJOLGVBQUo7Y0FDQTNOLEdBQUcsQ0FBQzROLFFBQUosQ0FBYW9yQixHQUFiOztXQUpKLE1BTU87WUFDTGg1QixHQUFHLENBQUMyTixlQUFKO1lBQ0EzTixHQUFHLENBQUM0TixRQUFKLENBQWFvckIsR0FBYjs7O1VBRUYsSUFBSWwzRCxHQUFHLElBQUlrK0IsR0FBRyxDQUFDbU4sVUFBSixJQUFrQixJQUE3QixFQUFtQztZQUFFbk4sR0FBRyxDQUFDNE4sUUFBSixDQUFhOXJDLEdBQWI7V0FBckMsTUFDSyxJQUFJK1IsS0FBSixFQUFXO1lBQUUsS0FBS29sRCxnQkFBTDs7OztRQUVwQixLQUFLQyxpQkFBTDtPQWhERjs7TUFtREEvQixvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQm1yRyxnQkFBL0IsR0FBa0QsWUFBWTtRQUMxRCxJQUFJNWQsTUFBTSxHQUFHLElBQWI7UUFFRnRqQyxZQUFZLENBQUMsS0FBSzIvQyxXQUFOLENBQVo7UUFDQSxLQUFLQSxXQUFMLEdBQW1CdGhGLFVBQVUsQ0FBQyxZQUFZO1VBQ3hDaWxFLE1BQU0sQ0FBQ3FjLFdBQVAsR0FBcUIsS0FBckI7O1VBQ0EsSUFBSXJjLE1BQU0sQ0FBQ3BSLGdCQUFQLEVBQUosRUFDRTtZQUFFb1IsTUFBTSxDQUFDOTlCLEVBQVAsQ0FBVWpPLFNBQVYsQ0FBb0IsWUFBWTtjQUFFLE9BQU8rckMsTUFBTSxDQUFDOTlCLEVBQVAsQ0FBVU8sS0FBVixDQUFnQm1zQixnQkFBaEIsR0FBbUMsSUFBMUM7YUFBbEM7O1NBSHVCLEVBSTFCLEVBSjBCLENBQTdCO09BSkY7O01BV0FrdEIsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0IwcUcsc0JBQS9CLEdBQXdELFVBQVVya0UsSUFBVixFQUFnQjtRQUN0RTBoQixvQkFBb0IsQ0FBQyxLQUFLMEgsRUFBTCxDQUFRL29ELE9BQVIsQ0FBZ0JvdUUsU0FBakIsRUFBNEJ6dUMsSUFBSSxDQUFDMnJDLE9BQWpDLENBQXBCO1FBQ0FqcUIsb0JBQW9CLENBQUMsS0FBSzBILEVBQUwsQ0FBUS9vRCxPQUFSLENBQWdCODVFLFlBQWpCLEVBQStCbjZDLElBQUksQ0FBQzJyQixTQUFwQyxDQUFwQjtPQUZGOztNQUtBcTNDLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCb3JHLGlCQUEvQixHQUFtRCxZQUFZO1FBQzdELElBQUlsNUIsR0FBRyxHQUFHLEtBQUtyZ0IsWUFBTCxFQUFWO1FBQ0EsS0FBS3kzQyxjQUFMLEdBQXNCcDNCLEdBQUcsQ0FBQ21OLFVBQTFCO1FBQXNDLEtBQUtrcUIsZ0JBQUwsR0FBd0JyM0IsR0FBRyxDQUFDcU4sWUFBNUI7UUFDdEMsS0FBS2lxQixhQUFMLEdBQXFCdDNCLEdBQUcsQ0FBQ3NOLFNBQXpCO1FBQW9DLEtBQUtpcUIsZUFBTCxHQUF1QnYzQixHQUFHLENBQUN1TixXQUEzQjtPQUh0Qzs7TUFNQTRwQixvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQnFyRyxpQkFBL0IsR0FBbUQsWUFBWTtRQUM3RCxJQUFJbjVCLEdBQUcsR0FBRyxLQUFLcmdCLFlBQUwsRUFBVjs7UUFDQSxJQUFJLENBQUNxZ0IsR0FBRyxDQUFDODRCLFVBQVQsRUFBcUI7VUFBRSxPQUFPLEtBQVA7OztRQUN2QixJQUFJdmhGLElBQUksR0FBR3lvRCxHQUFHLENBQUMrNEIsVUFBSixDQUFlLENBQWYsRUFBa0JLLHVCQUE3QjtRQUNBLE9BQU81aUQsUUFBUSxDQUFDLEtBQUsxekMsR0FBTixFQUFXeVUsSUFBWCxDQUFmO09BSkY7O01BT0E0L0Usb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0Jta0QsS0FBL0IsR0FBdUMsWUFBWTtRQUNqRCxJQUFJLEtBQUtzTCxFQUFMLENBQVFqbEIsT0FBUixDQUFnQmt6QixRQUFoQixJQUE0QixVQUFoQyxFQUE0QztVQUMxQyxJQUFJLENBQUMsS0FBSzJ0QyxpQkFBTCxFQUFELElBQTZCemlELFNBQVMsTUFBTSxLQUFLNXpDLEdBQXJELEVBQ0U7WUFBRSxLQUFLNDhELGFBQUwsQ0FBbUIsS0FBS0MsZ0JBQUwsRUFBbkIsRUFBNEMsSUFBNUM7OztVQUNKLEtBQUs3OEQsR0FBTCxDQUFTbXZDLEtBQVQ7O09BSko7O01BT0FrbEQsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0J5aEcsSUFBL0IsR0FBc0MsWUFBWTtRQUFFLEtBQUt6c0YsR0FBTCxDQUFTeXNGLElBQVQ7T0FBcEQ7O01BQ0E0SCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQnk4RixRQUEvQixHQUEwQyxZQUFZO1FBQUUsT0FBTyxLQUFLem5GLEdBQVo7T0FBeEQ7O01BRUFxMEYsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0J1OUYsYUFBL0IsR0FBK0MsWUFBWTtRQUFFLE9BQU8sSUFBUDtPQUE3RDs7TUFFQThMLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCdTFFLGFBQS9CLEdBQStDLFlBQVk7UUFDdkQsSUFBSWdZLE1BQU0sR0FBRyxJQUFiO1FBRUYsSUFBSXRxQixLQUFLLEdBQUcsSUFBWjs7UUFDQSxJQUFJLEtBQUtvb0MsaUJBQUwsRUFBSixFQUNFO1VBQUUvaUYsVUFBVSxDQUFDLFlBQVk7WUFBRSxPQUFPaWxFLE1BQU0sQ0FBQ2dlLGFBQVAsRUFBUDtXQUFmLEVBQWlELEVBQWpELENBQVY7U0FESixNQUdFO1VBQUV6dEIsT0FBTyxDQUFDLEtBQUtydUIsRUFBTixFQUFVLFlBQVk7WUFBRSxPQUFPd1QsS0FBSyxDQUFDeFQsRUFBTixDQUFTTyxLQUFULENBQWVtc0IsZ0JBQWYsR0FBa0MsSUFBekM7V0FBeEIsQ0FBUDs7O1FBRUosU0FBU3F2QixJQUFULEdBQWdCO1VBQ2QsSUFBSXZvQyxLQUFLLENBQUN4VCxFQUFOLENBQVM5cEIsS0FBVCxDQUFlZ3ZDLE9BQW5CLEVBQTRCO1lBQzFCMVIsS0FBSyxDQUFDc29DLGFBQU47WUFDQXRvQyxLQUFLLENBQUN5bUMsT0FBTixDQUFjdi9GLEdBQWQsQ0FBa0I4NEQsS0FBSyxDQUFDeFQsRUFBTixDQUFTamxCLE9BQVQsQ0FBaUJpaEUsWUFBbkMsRUFBaURELElBQWpEOzs7O1FBR0osS0FBSzlCLE9BQUwsQ0FBYXYvRixHQUFiLENBQWlCLEtBQUtzbEQsRUFBTCxDQUFRamxCLE9BQVIsQ0FBZ0JpaEUsWUFBakMsRUFBK0NELElBQS9DO09BZkY7O01Ba0JBbkMsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0JtOEUsZ0JBQS9CLEdBQWtELFlBQVk7UUFDNUQsSUFBSWpLLEdBQUcsR0FBRyxLQUFLcmdCLFlBQUwsRUFBVjtRQUNBLE9BQU9xZ0IsR0FBRyxDQUFDbU4sVUFBSixJQUFrQixLQUFLaXFCLGNBQXZCLElBQXlDcDNCLEdBQUcsQ0FBQ3FOLFlBQUosSUFBb0IsS0FBS2dxQixnQkFBbEUsSUFDTHIzQixHQUFHLENBQUNzTixTQUFKLElBQWlCLEtBQUtncUIsYUFEakIsSUFDa0N0M0IsR0FBRyxDQUFDdU4sV0FBSixJQUFtQixLQUFLZ3FCLGVBRGpFO09BRkY7O01BTUFKLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCdXJHLGFBQS9CLEdBQStDLFlBQVk7UUFDekQsSUFBSSxLQUFLMUIsY0FBTCxJQUF1QixJQUF2QixJQUErQixLQUFLRCxXQUFwQyxJQUFtRCxDQUFDLEtBQUt6dEIsZ0JBQUwsRUFBeEQsRUFBaUY7VUFBRTs7O1FBQ25GLElBQUlqSyxHQUFHLEdBQUcsS0FBS3JnQixZQUFMLEVBQVY7WUFBK0JwQyxFQUFFLEdBQUcsS0FBS0EsRUFBekMsQ0FGeUQ7Ozs7Ozs7UUFTekQsSUFBSXpJLE9BQU8sSUFBSVIsTUFBWCxJQUFxQixLQUFLaUosRUFBTCxDQUFRL29ELE9BQVIsQ0FBZ0JtZ0UsV0FBaEIsQ0FBNEIzbUUsTUFBakQsSUFBMkR3ckcsVUFBVSxDQUFDeDVCLEdBQUcsQ0FBQ21OLFVBQUwsQ0FBekUsRUFBMkY7VUFDekYsS0FBSzV2QixFQUFMLENBQVEyM0MsZ0JBQVIsQ0FBeUI7WUFBQzFtRyxJQUFJLEVBQUUsU0FBUDtZQUFrQjYxRixPQUFPLEVBQUUsQ0FBM0I7WUFBOEJuOEMsY0FBYyxFQUFFditDLElBQUksQ0FBQ2tYO1dBQTVFO1VBQ0EsS0FBSzB1RixJQUFMO1VBQ0EsS0FBS3Q5QyxLQUFMO1VBQ0E7OztRQUVGLElBQUksS0FBS3dsRCxTQUFULEVBQW9CO1VBQUU7OztRQUN0QixLQUFLeUIsaUJBQUw7UUFDQSxJQUFJeHhGLE1BQU0sR0FBR2d4RixRQUFRLENBQUNuN0MsRUFBRCxFQUFLeWlCLEdBQUcsQ0FBQ21OLFVBQVQsRUFBcUJuTixHQUFHLENBQUNxTixZQUF6QixDQUFyQjtRQUNBLElBQUl6MkQsSUFBSSxHQUFHOGhGLFFBQVEsQ0FBQ243QyxFQUFELEVBQUt5aUIsR0FBRyxDQUFDc04sU0FBVCxFQUFvQnROLEdBQUcsQ0FBQ3VOLFdBQXhCLENBQW5COztRQUNBLElBQUk3bEUsTUFBTSxJQUFJa1AsSUFBZCxFQUFvQjtVQUFFZzFELE9BQU8sQ0FBQ3J1QixFQUFELEVBQUssWUFBWTtZQUM1Q3E1QixZQUFZLENBQUNyNUIsRUFBRSxDQUFDa0csR0FBSixFQUFTdXVCLGVBQWUsQ0FBQ3RxRSxNQUFELEVBQVNrUCxJQUFULENBQXhCLEVBQXdDdWhDLGNBQXhDLENBQVo7O1lBQ0EsSUFBSXp3QyxNQUFNLENBQUNreEYsR0FBUCxJQUFjaGlGLElBQUksQ0FBQ2dpRixHQUF2QixFQUE0QjtjQUFFcjdDLEVBQUUsQ0FBQ08sS0FBSCxDQUFTbXNCLGdCQUFULEdBQTRCLElBQTVCOztXQUZILENBQVA7O09BbkJ4Qjs7TUF5QkFrdEIsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0IyckcsV0FBL0IsR0FBNkMsWUFBWTtRQUN2RCxJQUFJLEtBQUs5QixjQUFMLElBQXVCLElBQTNCLEVBQWlDO1VBQy9CNS9DLFlBQVksQ0FBQyxLQUFLNC9DLGNBQU4sQ0FBWjtVQUNBLEtBQUtBLGNBQUwsR0FBc0IsSUFBdEI7OztRQUdGLElBQUlwNkMsRUFBRSxHQUFHLEtBQUtBLEVBQWQ7WUFBa0Ivb0QsT0FBTyxHQUFHK29ELEVBQUUsQ0FBQy9vRCxPQUEvQjtZQUF3Q3dyRSxHQUFHLEdBQUd6aUIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdWMsR0FBUCxDQUFXSixPQUFYLEVBQTlDO1FBQ0EsSUFBSXoxRCxJQUFJLEdBQUc2MUQsR0FBRyxDQUFDNzFELElBQUosRUFBWDtZQUF1QndELEVBQUUsR0FBR3F5RCxHQUFHLENBQUNyeUQsRUFBSixFQUE1Qjs7UUFDQSxJQUFJeEQsSUFBSSxDQUFDMEksRUFBTCxJQUFXLENBQVgsSUFBZ0IxSSxJQUFJLENBQUN3eUMsSUFBTCxHQUFZWSxFQUFFLENBQUN5MUIsU0FBSCxFQUFoQyxFQUNFO1VBQUU3b0UsSUFBSSxHQUFHeTZDLEdBQUcsQ0FBQ3o2QyxJQUFJLENBQUN3eUMsSUFBTCxHQUFZLENBQWIsRUFBZ0I2RyxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVN0NUMsSUFBSSxDQUFDd3lDLElBQUwsR0FBWSxDQUFyQixDQUFQLENBQStCM3VELE1BQS9DLENBQVY7OztRQUNKLElBQUkyZixFQUFFLENBQUNrRixFQUFILElBQVMyd0MsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTOTFDLEVBQUUsQ0FBQ2d2QyxJQUFaLENBQVAsQ0FBeUJ2USxJQUF6QixDQUE4QnArQyxNQUF2QyxJQUFpRDJmLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVVZLEVBQUUsQ0FBQ2lRLFFBQUgsRUFBL0QsRUFDRTtVQUFFNy9DLEVBQUUsR0FBR2kzQyxHQUFHLENBQUNqM0MsRUFBRSxDQUFDZ3ZDLElBQUgsR0FBVSxDQUFYLEVBQWMsQ0FBZCxDQUFSOzs7UUFDSixJQUFJeHlDLElBQUksQ0FBQ3d5QyxJQUFMLEdBQVlub0QsT0FBTyxDQUFDa3pELFFBQXBCLElBQWdDLzVDLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVVub0QsT0FBTyxDQUFDbXpELE1BQVIsR0FBaUIsQ0FBL0QsRUFBa0U7VUFBRSxPQUFPLEtBQVA7OztRQUVwRSxJQUFJbjFELFNBQUosRUFBZTJ2RSxRQUFmLEVBQXlCdTNCLFFBQXpCOztRQUNBLElBQUl2dkYsSUFBSSxDQUFDd3lDLElBQUwsSUFBYW5vRCxPQUFPLENBQUNrekQsUUFBckIsSUFBaUMsQ0FBQ2wxRCxTQUFTLEdBQUc0bEUsYUFBYSxDQUFDN2EsRUFBRCxFQUFLcHpDLElBQUksQ0FBQ3d5QyxJQUFWLENBQTFCLEtBQThDLENBQW5GLEVBQXNGO1VBQ3BGd2xCLFFBQVEsR0FBR2hlLE1BQU0sQ0FBQzN2RCxPQUFPLENBQUNrdEIsSUFBUixDQUFhLENBQWIsRUFBZ0JpN0IsSUFBakIsQ0FBakI7VUFDQSs4QyxRQUFRLEdBQUdsbEcsT0FBTyxDQUFDa3RCLElBQVIsQ0FBYSxDQUFiLEVBQWdCbkssSUFBM0I7U0FGRixNQUdPO1VBQ0w0cUQsUUFBUSxHQUFHaGUsTUFBTSxDQUFDM3ZELE9BQU8sQ0FBQ2t0QixJQUFSLENBQWFsdkIsU0FBYixFQUF3Qm1xRCxJQUF6QixDQUFqQjtVQUNBKzhDLFFBQVEsR0FBR2xsRyxPQUFPLENBQUNrdEIsSUFBUixDQUFhbHZCLFNBQVMsR0FBRyxDQUF6QixFQUE0QitrQixJQUE1QixDQUFpQ3lsQixXQUE1Qzs7O1FBRUYsSUFBSWxiLE9BQU8sR0FBR3MyQyxhQUFhLENBQUM3YSxFQUFELEVBQUs1dkMsRUFBRSxDQUFDZ3ZDLElBQVIsQ0FBM0I7UUFDQSxJQUFJeWxCLE1BQUosRUFBWXUzQixNQUFaOztRQUNBLElBQUk3M0UsT0FBTyxJQUFJdHRCLE9BQU8sQ0FBQ2t0QixJQUFSLENBQWExekIsTUFBYixHQUFzQixDQUFyQyxFQUF3QztVQUN0Q28wRSxNQUFNLEdBQUc1dEUsT0FBTyxDQUFDbXpELE1BQVIsR0FBaUIsQ0FBMUI7VUFDQWd5QyxNQUFNLEdBQUdubEcsT0FBTyxDQUFDaXZFLE9BQVIsQ0FBZ0I3VCxTQUF6QjtTQUZGLE1BR087VUFDTHdTLE1BQU0sR0FBR2plLE1BQU0sQ0FBQzN2RCxPQUFPLENBQUNrdEIsSUFBUixDQUFhSSxPQUFPLEdBQUcsQ0FBdkIsRUFBMEI2NkIsSUFBM0IsQ0FBTixHQUF5QyxDQUFsRDtVQUNBZzlDLE1BQU0sR0FBR25sRyxPQUFPLENBQUNrdEIsSUFBUixDQUFhSSxPQUFPLEdBQUcsQ0FBdkIsRUFBMEJ2SyxJQUExQixDQUErQnFpRixlQUF4Qzs7O1FBR0YsSUFBSSxDQUFDRixRQUFMLEVBQWU7VUFBRSxPQUFPLEtBQVA7OztRQUNqQixJQUFJRyxPQUFPLEdBQUd0OEMsRUFBRSxDQUFDa0csR0FBSCxDQUFPdTJCLFVBQVAsQ0FBa0I4ZixjQUFjLENBQUN2OEMsRUFBRCxFQUFLbThDLFFBQUwsRUFBZUMsTUFBZixFQUF1QngzQixRQUF2QixFQUFpQ0MsTUFBakMsQ0FBaEMsQ0FBZDtRQUNBLElBQUkyM0IsT0FBTyxHQUFHaDJDLFVBQVUsQ0FBQ3hHLEVBQUUsQ0FBQ2tHLEdBQUosRUFBU21CLEdBQUcsQ0FBQ3VkLFFBQUQsRUFBVyxDQUFYLENBQVosRUFBMkJ2ZCxHQUFHLENBQUN3ZCxNQUFELEVBQVM1ZSxPQUFPLENBQUNqRyxFQUFFLENBQUNrRyxHQUFKLEVBQVMyZSxNQUFULENBQVAsQ0FBd0JoMkIsSUFBeEIsQ0FBNkJwK0MsTUFBdEMsQ0FBOUIsQ0FBeEI7O1FBQ0EsT0FBTzZyRyxPQUFPLENBQUM3ckcsTUFBUixHQUFpQixDQUFqQixJQUFzQityRyxPQUFPLENBQUMvckcsTUFBUixHQUFpQixDQUE5QyxFQUFpRDtVQUMvQyxJQUFJOHFELEdBQUcsQ0FBQytnRCxPQUFELENBQUgsSUFBZ0IvZ0QsR0FBRyxDQUFDaWhELE9BQUQsQ0FBdkIsRUFBa0M7WUFBRUYsT0FBTyxDQUFDN2tFLEdBQVI7WUFBZStrRSxPQUFPLENBQUMva0UsR0FBUjtZQUFlb3RDLE1BQU07V0FBeEUsTUFDSyxJQUFJeTNCLE9BQU8sQ0FBQyxDQUFELENBQVAsSUFBY0UsT0FBTyxDQUFDLENBQUQsQ0FBekIsRUFBOEI7WUFBRUYsT0FBTyxDQUFDdjJCLEtBQVI7WUFBaUJ5MkIsT0FBTyxDQUFDejJCLEtBQVI7WUFBaUJuQixRQUFRO1dBQTFFLE1BQ0E7WUFBRTs7OztRQUdULElBQUk2M0IsUUFBUSxHQUFHLENBQWY7WUFBa0JDLE1BQU0sR0FBRyxDQUEzQjtRQUNBLElBQUl6MEIsTUFBTSxHQUFHcTBCLE9BQU8sQ0FBQyxDQUFELENBQXBCO1lBQXlCSyxNQUFNLEdBQUdILE9BQU8sQ0FBQyxDQUFELENBQXpDO1lBQThDSSxXQUFXLEdBQUd4d0csSUFBSSxDQUFDc0ksR0FBTCxDQUFTdXpFLE1BQU0sQ0FBQ3gzRSxNQUFoQixFQUF3QmtzRyxNQUFNLENBQUNsc0csTUFBL0IsQ0FBNUQ7O1FBQ0EsT0FBT2dzRyxRQUFRLEdBQUdHLFdBQVgsSUFBMEIzMEIsTUFBTSxDQUFDcm5FLFVBQVAsQ0FBa0I2N0YsUUFBbEIsS0FBK0JFLE1BQU0sQ0FBQy83RixVQUFQLENBQWtCNjdGLFFBQWxCLENBQWhFLEVBQ0U7VUFBRSxFQUFFQSxRQUFGOzs7UUFDSixJQUFJSSxNQUFNLEdBQUd0aEQsR0FBRyxDQUFDK2dELE9BQUQsQ0FBaEI7WUFBMkJRLE1BQU0sR0FBR3ZoRCxHQUFHLENBQUNpaEQsT0FBRCxDQUF2QztRQUNBLElBQUlPLFNBQVMsR0FBRzN3RyxJQUFJLENBQUNzSSxHQUFMLENBQVNtb0csTUFBTSxDQUFDcHNHLE1BQVAsSUFBaUI2ckcsT0FBTyxDQUFDN3JHLE1BQVIsSUFBa0IsQ0FBbEIsR0FBc0Jnc0csUUFBdEIsR0FBaUMsQ0FBbEQsQ0FBVCxFQUNTSyxNQUFNLENBQUNyc0csTUFBUCxJQUFpQityRyxPQUFPLENBQUMvckcsTUFBUixJQUFrQixDQUFsQixHQUFzQmdzRyxRQUF0QixHQUFpQyxDQUFsRCxDQURULENBQWhCOztRQUVBLE9BQU9DLE1BQU0sR0FBR0ssU0FBVCxJQUNBRixNQUFNLENBQUNqOEYsVUFBUCxDQUFrQmk4RixNQUFNLENBQUNwc0csTUFBUCxHQUFnQmlzRyxNQUFoQixHQUF5QixDQUEzQyxLQUFpREksTUFBTSxDQUFDbDhGLFVBQVAsQ0FBa0JrOEYsTUFBTSxDQUFDcnNHLE1BQVAsR0FBZ0Jpc0csTUFBaEIsR0FBeUIsQ0FBM0MsQ0FEeEQsRUFFRTtVQUFFLEVBQUVBLE1BQUY7U0FsRG1EOzs7UUFvRHZELElBQUlKLE9BQU8sQ0FBQzdyRyxNQUFSLElBQWtCLENBQWxCLElBQXVCK3JHLE9BQU8sQ0FBQy9yRyxNQUFSLElBQWtCLENBQXpDLElBQThDbTBFLFFBQVEsSUFBSWg0RCxJQUFJLENBQUN3eUMsSUFBbkUsRUFBeUU7VUFDdkUsT0FBT3E5QyxRQUFRLElBQUlBLFFBQVEsR0FBRzd2RixJQUFJLENBQUMwSSxFQUE1QixJQUNBdW5GLE1BQU0sQ0FBQ2o4RixVQUFQLENBQWtCaThGLE1BQU0sQ0FBQ3BzRyxNQUFQLEdBQWdCaXNHLE1BQWhCLEdBQXlCLENBQTNDLEtBQWlESSxNQUFNLENBQUNsOEYsVUFBUCxDQUFrQms4RixNQUFNLENBQUNyc0csTUFBUCxHQUFnQmlzRyxNQUFoQixHQUF5QixDQUEzQyxDQUR4RCxFQUN1RztZQUNyR0QsUUFBUTtZQUNSQyxNQUFNOzs7O1FBSVZKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDN3JHLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUCxHQUE4Qm9zRyxNQUFNLENBQUMzb0csS0FBUCxDQUFhLENBQWIsRUFBZ0Iyb0csTUFBTSxDQUFDcHNHLE1BQVAsR0FBZ0Jpc0csTUFBaEMsRUFBd0NsOUYsT0FBeEMsQ0FBZ0QsVUFBaEQsRUFBNEQsRUFBNUQsQ0FBOUI7UUFDQTg4RixPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFBLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV3BvRyxLQUFYLENBQWlCdW9HLFFBQWpCLEVBQTJCajlGLE9BQTNCLENBQW1DLFVBQW5DLEVBQStDLEVBQS9DLENBQWI7UUFFQSxJQUFJdzlGLE1BQU0sR0FBRzMxQyxHQUFHLENBQUN1ZCxRQUFELEVBQVc2M0IsUUFBWCxDQUFoQjtRQUNBLElBQUlRLElBQUksR0FBRzUxQyxHQUFHLENBQUN3ZCxNQUFELEVBQVMyM0IsT0FBTyxDQUFDL3JHLE1BQVIsR0FBaUI4cUQsR0FBRyxDQUFDaWhELE9BQUQsQ0FBSCxDQUFhL3JHLE1BQWIsR0FBc0Jpc0csTUFBdkMsR0FBZ0QsQ0FBekQsQ0FBZDs7UUFDQSxJQUFJSixPQUFPLENBQUM3ckcsTUFBUixHQUFpQixDQUFqQixJQUFzQjZyRyxPQUFPLENBQUMsQ0FBRCxDQUE3QixJQUFvQ2gxQyxHQUFHLENBQUMwMUMsTUFBRCxFQUFTQyxJQUFULENBQTNDLEVBQTJEO1VBQ3pEemdCLGFBQVksQ0FBQ3g4QixFQUFFLENBQUNrRyxHQUFKLEVBQVNvMkMsT0FBVCxFQUFrQlUsTUFBbEIsRUFBMEJDLElBQTFCLEVBQWdDLFFBQWhDLENBQVo7O1VBQ0EsT0FBTyxJQUFQOztPQW5FSjs7TUF1RUFyRCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQjI3RixZQUEvQixHQUE4QyxZQUFZO1FBQ3hELEtBQUt1TyxtQkFBTDtPQURGOztNQUdBYixvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQmluQyxLQUEvQixHQUF1QyxZQUFZO1FBQ2pELEtBQUtpakUsbUJBQUw7T0FERjs7TUFHQWIsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0JrcUcsbUJBQS9CLEdBQXFELFlBQVk7UUFDL0QsSUFBSSxDQUFDLEtBQUtQLFNBQVYsRUFBcUI7VUFBRTs7O1FBQ3ZCMS9DLFlBQVksQ0FBQyxLQUFLNC9DLGNBQU4sQ0FBWjtRQUNBLEtBQUtGLFNBQUwsR0FBaUIsSUFBakI7UUFDQSxLQUFLSyxhQUFMO1FBQ0EsS0FBS2gxRixHQUFMLENBQVN5c0YsSUFBVDtRQUNBLEtBQUt6c0YsR0FBTCxDQUFTbXZDLEtBQVQ7T0FORjs7TUFRQWtsRCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQmlxRyxlQUEvQixHQUFpRCxZQUFZO1FBQ3pELElBQUkxYyxNQUFNLEdBQUcsSUFBYjs7UUFFRixJQUFJLEtBQUtzYyxjQUFMLElBQXVCLElBQTNCLEVBQWlDO1VBQUU7OztRQUNuQyxLQUFLQSxjQUFMLEdBQXNCdmhGLFVBQVUsQ0FBQyxZQUFZO1VBQzNDaWxFLE1BQU0sQ0FBQ3NjLGNBQVAsR0FBd0IsSUFBeEI7O1VBQ0EsSUFBSXRjLE1BQU0sQ0FBQ29jLFNBQVgsRUFBc0I7WUFDcEIsSUFBSXBjLE1BQU0sQ0FBQ29jLFNBQVAsQ0FBaUJ2eEYsSUFBckIsRUFBMkI7Y0FBRW0xRSxNQUFNLENBQUNvYyxTQUFQLEdBQW1CLElBQW5CO2FBQTdCLE1BQ0s7Y0FBRTs7OztVQUVUcGMsTUFBTSxDQUFDeWMsYUFBUDtTQU44QixFQU83QixFQVA2QixDQUFoQztPQUpGOztNQWNBWCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQmdxRyxhQUEvQixHQUErQyxZQUFZO1FBQ3ZELElBQUl6YyxNQUFNLEdBQUcsSUFBYjs7UUFFRixJQUFJLEtBQUs5OUIsRUFBTCxDQUFRMmpDLFVBQVIsTUFBd0IsQ0FBQyxLQUFLdVksV0FBTCxFQUE3QixFQUNFO1VBQUU3dEIsT0FBTyxDQUFDLEtBQUtydUIsRUFBTixFQUFVLFlBQVk7WUFBRSxPQUFPa2hCLFNBQVMsQ0FBQzRjLE1BQU0sQ0FBQzk5QixFQUFSLENBQWhCO1dBQXhCLENBQVA7O09BSk47O01BT0E0NUMsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0JtakUsYUFBL0IsR0FBK0MsVUFBVTE1QyxJQUFWLEVBQWdCO1FBQzdEQSxJQUFJLENBQUNxZ0YsZUFBTCxHQUF1QixPQUF2QjtPQURGOztNQUlBVCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQjg4RixVQUEvQixHQUE0QyxVQUFVeGdHLENBQVYsRUFBYTtRQUN2RCxJQUFJQSxDQUFDLENBQUN5Z0csUUFBRixJQUFjLENBQWQsSUFBbUIsS0FBSzRNLFNBQTVCLEVBQXVDO1VBQUU7OztRQUN6Q3J0RyxDQUFDLENBQUM4OUMsY0FBRjs7UUFDQSxJQUFJLENBQUMsS0FBS3FWLEVBQUwsQ0FBUTJqQyxVQUFSLEVBQUwsRUFDRTtVQUFFNXhDLFNBQVMsQ0FBQyxLQUFLaU8sRUFBTixFQUFVNDBDLGNBQVYsQ0FBVCxDQUFtQyxLQUFLNTBDLEVBQXhDLEVBQTRDMXZELE1BQU0sQ0FBQytWLFlBQVAsQ0FBb0J4WixDQUFDLENBQUN5Z0csUUFBRixJQUFjLElBQWQsR0FBcUJ6Z0csQ0FBQyxDQUFDaTZGLE9BQXZCLEdBQWlDajZGLENBQUMsQ0FBQ3lnRyxRQUF2RCxDQUE1QyxFQUE4RyxDQUE5Rzs7T0FKTjs7TUFPQXNNLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCMGhHLGVBQS9CLEdBQWlELFVBQVVsa0csR0FBVixFQUFlO1FBQzlELEtBQUt3WCxHQUFMLENBQVM4MEYsZUFBVCxHQUEyQi9wRyxNQUFNLENBQUN2QyxHQUFHLElBQUksVUFBUixDQUFqQztPQURGOztNQUlBNnJHLG9CQUFvQixDQUFDcnBHLFNBQXJCLENBQStCNDlGLGFBQS9CLEdBQStDLFlBQVksRUFBM0Q7O01BQ0F5TCxvQkFBb0IsQ0FBQ3JwRyxTQUFyQixDQUErQjZoRyxhQUEvQixHQUErQyxZQUFZLEVBQTNEOztNQUVBd0gsb0JBQW9CLENBQUNycEcsU0FBckIsQ0FBK0JrakUscUJBQS9CLEdBQXVELElBQXZEOztNQUVBLFNBQVM2bkMsUUFBVCxDQUFrQnQ3QyxFQUFsQixFQUFzQnI1QyxHQUF0QixFQUEyQjtRQUN6QixJQUFJd2QsSUFBSSxHQUFHeTJDLGVBQWUsQ0FBQzVhLEVBQUQsRUFBS3I1QyxHQUFHLENBQUN5NEMsSUFBVCxDQUExQjs7UUFDQSxJQUFJLENBQUNqN0IsSUFBRCxJQUFTQSxJQUFJLENBQUNrd0MsTUFBbEIsRUFBMEI7VUFBRSxPQUFPLElBQVA7OztRQUM1QixJQUFJalYsSUFBSSxHQUFHNkcsT0FBTyxDQUFDakcsRUFBRSxDQUFDa0csR0FBSixFQUFTdi9DLEdBQUcsQ0FBQ3k0QyxJQUFiLENBQWxCO1FBQ0EsSUFBSXhvQixJQUFJLEdBQUd5akMsZUFBZSxDQUFDbDJDLElBQUQsRUFBT2k3QixJQUFQLEVBQWF6NEMsR0FBRyxDQUFDeTRDLElBQWpCLENBQTFCO1FBRUEsSUFBSXhDLEtBQUssR0FBR3VDLFFBQVEsQ0FBQ0MsSUFBRCxFQUFPWSxFQUFFLENBQUNrRyxHQUFILENBQU90SSxTQUFkLENBQXBCO1lBQThDa21CLElBQUksR0FBRyxNQUFyRDs7UUFDQSxJQUFJbG5CLEtBQUosRUFBVztVQUNULElBQUk2aEIsT0FBTyxHQUFHemhCLGFBQWEsQ0FBQ0osS0FBRCxFQUFRajJDLEdBQUcsQ0FBQzJPLEVBQVosQ0FBM0I7VUFDQXd1RCxJQUFJLEdBQUdyRixPQUFPLEdBQUcsQ0FBVixHQUFjLE9BQWQsR0FBd0IsTUFBL0I7OztRQUVGLElBQUlocEUsTUFBTSxHQUFHK2xFLHNCQUFzQixDQUFDNWtDLElBQUksQ0FBQ3puQixHQUFOLEVBQVd4SSxHQUFHLENBQUMyTyxFQUFmLEVBQW1Cd3VELElBQW5CLENBQW5DO1FBQ0FydUUsTUFBTSxDQUFDd3ZCLE1BQVAsR0FBZ0J4dkIsTUFBTSxDQUFDcWpELFFBQVAsSUFBbUIsT0FBbkIsR0FBNkJyakQsTUFBTSxDQUFDNlQsR0FBcEMsR0FBMEM3VCxNQUFNLENBQUNzWSxLQUFqRTtRQUNBLE9BQU90WSxNQUFQOzs7TUFHRixTQUFTd21HLFVBQVQsQ0FBb0JqaUYsSUFBcEIsRUFBMEI7UUFDeEIsS0FBSyxJQUFJa2pGLElBQUksR0FBR2xqRixJQUFoQixFQUFzQmtqRixJQUF0QixFQUE0QkEsSUFBSSxHQUFHQSxJQUFJLENBQUNqK0QsVUFBeEMsRUFDRTtVQUFFLElBQUksNEJBQTRCNWhDLElBQTVCLENBQWlDNi9GLElBQUksQ0FBQy9rRCxTQUF0QyxDQUFKLEVBQXNEO1lBQUUsT0FBTyxJQUFQOzs7O1FBQzVELE9BQU8sS0FBUDs7O01BR0YsU0FBU2dsRCxNQUFULENBQWdCeDJGLEdBQWhCLEVBQXFCMDBGLEdBQXJCLEVBQTBCO1FBQUUsSUFBSUEsR0FBSixFQUFTO1VBQUUxMEYsR0FBRyxDQUFDMDBGLEdBQUosR0FBVSxJQUFWOzs7UUFBa0IsT0FBTzEwRixHQUFQOzs7TUFFekQsU0FBUzQxRixjQUFULENBQXdCdjhDLEVBQXhCLEVBQTRCcHpDLElBQTVCLEVBQWtDd0QsRUFBbEMsRUFBc0N3MEQsUUFBdEMsRUFBZ0RDLE1BQWhELEVBQXdEO1FBQ3RELElBQUloMkIsSUFBSSxHQUFHLEVBQVg7WUFBZXV1RCxPQUFPLEdBQUcsS0FBekI7WUFBZ0N4ZCxPQUFPLEdBQUc1L0IsRUFBRSxDQUFDa0csR0FBSCxDQUFPNjVCLGFBQVAsRUFBMUM7WUFBa0VzZCxjQUFjLEdBQUcsS0FBbkY7O1FBQ0EsU0FBU0MsZUFBVCxDQUF5QnJ1RyxFQUF6QixFQUE2QjtVQUFFLE9BQU8sVUFBVXVxQyxNQUFWLEVBQWtCO1lBQUUsT0FBT0EsTUFBTSxDQUFDdnFDLEVBQVAsSUFBYUEsRUFBcEI7V0FBM0I7OztRQUMvQixTQUFTc0ksS0FBVCxHQUFpQjtVQUNmLElBQUk2bEcsT0FBSixFQUFhO1lBQ1h2dUQsSUFBSSxJQUFJK3dDLE9BQVI7O1lBQ0EsSUFBSXlkLGNBQUosRUFBb0I7Y0FBRXh1RCxJQUFJLElBQUkrd0MsT0FBUjs7O1lBQ3RCd2QsT0FBTyxHQUFHQyxjQUFjLEdBQUcsS0FBM0I7Ozs7UUFHSixTQUFTRSxPQUFULENBQWlCejlGLEdBQWpCLEVBQXNCO1VBQ3BCLElBQUlBLEdBQUosRUFBUztZQUNQdkksS0FBSztZQUNMczNDLElBQUksSUFBSS91QyxHQUFSOzs7O1FBR0osU0FBUzA5RixJQUFULENBQWN4akYsSUFBZCxFQUFvQjtVQUNsQixJQUFJQSxJQUFJLENBQUMraUIsUUFBTCxJQUFpQixDQUFyQixFQUF3QjtZQUN0QixJQUFJMGdFLE1BQU0sR0FBR3pqRixJQUFJLENBQUNxakIsWUFBTCxDQUFrQixTQUFsQixDQUFiOztZQUNBLElBQUlvZ0UsTUFBSixFQUFZO2NBQ1ZGLE9BQU8sQ0FBQ0UsTUFBRCxDQUFQO2NBQ0E7OztZQUVGLElBQUlDLFFBQVEsR0FBRzFqRixJQUFJLENBQUNxakIsWUFBTCxDQUFrQixXQUFsQixDQUFmO2dCQUErQ3VTLEtBQS9DOztZQUNBLElBQUk4dEQsUUFBSixFQUFjO2NBQ1osSUFBSTdnRCxLQUFLLEdBQUdtRCxFQUFFLENBQUNtL0IsU0FBSCxDQUFhOTNCLEdBQUcsQ0FBQ3VkLFFBQUQsRUFBVyxDQUFYLENBQWhCLEVBQStCdmQsR0FBRyxDQUFDd2QsTUFBTSxHQUFHLENBQVYsRUFBYSxDQUFiLENBQWxDLEVBQW1EeTRCLGVBQWUsQ0FBQyxDQUFDSSxRQUFGLENBQWxFLENBQVo7O2NBQ0EsSUFBSTdnRCxLQUFLLENBQUNwc0QsTUFBTixLQUFpQm0vQyxLQUFLLEdBQUdpTixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsc0MsSUFBVCxDQUFjLENBQWQsQ0FBekIsQ0FBSixFQUNFO2dCQUFFNHNGLE9BQU8sQ0FBQy8yQyxVQUFVLENBQUN4RyxFQUFFLENBQUNrRyxHQUFKLEVBQVN0VyxLQUFLLENBQUNoakMsSUFBZixFQUFxQmdqQyxLQUFLLENBQUN4L0IsRUFBM0IsQ0FBVixDQUF5Qy9mLElBQXpDLENBQThDdXZGLE9BQTlDLENBQUQsQ0FBUDs7O2NBQ0o7OztZQUVGLElBQUk1bEUsSUFBSSxDQUFDcWpCLFlBQUwsQ0FBa0IsaUJBQWxCLEtBQXdDLE9BQTVDLEVBQXFEO2NBQUU7OztZQUN2RCxJQUFJc2dFLE9BQU8sR0FBRyw2QkFBNkJ0Z0csSUFBN0IsQ0FBa0MyYyxJQUFJLENBQUNtMkQsUUFBdkMsQ0FBZDs7WUFDQSxJQUFJLENBQUMsUUFBUTl5RSxJQUFSLENBQWEyYyxJQUFJLENBQUNtMkQsUUFBbEIsQ0FBRCxJQUFnQ24yRCxJQUFJLENBQUM0akIsV0FBTCxDQUFpQm50QyxNQUFqQixJQUEyQixDQUEvRCxFQUFrRTtjQUFFOzs7WUFFcEUsSUFBSWt0RyxPQUFKLEVBQWE7Y0FBRXBtRyxLQUFLOzs7WUFDcEIsS0FBSyxJQUFJMUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21uQixJQUFJLENBQUM2aUIsVUFBTCxDQUFnQnBzQyxNQUFwQyxFQUE0Q29DLENBQUMsRUFBN0MsRUFDRTtjQUFFMnFHLElBQUksQ0FBQ3hqRixJQUFJLENBQUM2aUIsVUFBTCxDQUFnQmhxQyxDQUFoQixDQUFELENBQUo7OztZQUVKLElBQUksYUFBYXdLLElBQWIsQ0FBa0IyYyxJQUFJLENBQUNtMkQsUUFBdkIsQ0FBSixFQUFzQztjQUFFa3RCLGNBQWMsR0FBRyxJQUFqQjs7O1lBQ3hDLElBQUlNLE9BQUosRUFBYTtjQUFFUCxPQUFPLEdBQUcsSUFBVjs7V0F0QmpCLE1BdUJPLElBQUlwakYsSUFBSSxDQUFDK2lCLFFBQUwsSUFBaUIsQ0FBckIsRUFBd0I7WUFDN0J3Z0UsT0FBTyxDQUFDdmpGLElBQUksQ0FBQzRqRixTQUFMLENBQWVwK0YsT0FBZixDQUF1QixTQUF2QixFQUFrQyxFQUFsQyxFQUFzQ0EsT0FBdEMsQ0FBOEMsU0FBOUMsRUFBeUQsR0FBekQsQ0FBRCxDQUFQOzs7O1FBR0osU0FBUztVQUNQZytGLElBQUksQ0FBQzV3RixJQUFELENBQUo7O1VBQ0EsSUFBSUEsSUFBSSxJQUFJd0QsRUFBWixFQUFnQjtZQUFFOzs7VUFDbEJ4RCxJQUFJLEdBQUdBLElBQUksQ0FBQzZ5QixXQUFaO1VBQ0E0OUQsY0FBYyxHQUFHLEtBQWpCOzs7UUFFRixPQUFPeHVELElBQVA7OztNQUdGLFNBQVNzc0QsUUFBVCxDQUFrQm43QyxFQUFsQixFQUFzQmhtQyxJQUF0QixFQUE0QmlMLE1BQTVCLEVBQW9DO1FBQ2xDLElBQUk0NEUsUUFBSjs7UUFDQSxJQUFJN2pGLElBQUksSUFBSWdtQyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXaXZFLE9BQXZCLEVBQWdDO1VBQzlCMjNCLFFBQVEsR0FBRzc5QyxFQUFFLENBQUMvb0QsT0FBSCxDQUFXaXZFLE9BQVgsQ0FBbUJycEMsVUFBbkIsQ0FBOEI1WCxNQUE5QixDQUFYOztVQUNBLElBQUksQ0FBQzQ0RSxRQUFMLEVBQWU7WUFBRSxPQUFPVixNQUFNLENBQUNuOUMsRUFBRSxDQUFDNEgsT0FBSCxDQUFXUCxHQUFHLENBQUNySCxFQUFFLENBQUMvb0QsT0FBSCxDQUFXbXpELE1BQVgsR0FBb0IsQ0FBckIsQ0FBZCxDQUFELEVBQXlDLElBQXpDLENBQWI7OztVQUNqQnB3QyxJQUFJLEdBQUcsSUFBUDtVQUFhaUwsTUFBTSxHQUFHLENBQVQ7U0FIZixNQUlPO1VBQ0wsS0FBSzQ0RSxRQUFRLEdBQUc3akYsSUFBaEIsR0FBdUI2akYsUUFBUSxHQUFHQSxRQUFRLENBQUM1K0QsVUFBM0MsRUFBdUQ7WUFDckQsSUFBSSxDQUFDNCtELFFBQUQsSUFBYUEsUUFBUSxJQUFJNzlDLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdpdkUsT0FBeEMsRUFBaUQ7Y0FBRSxPQUFPLElBQVA7OztZQUNuRCxJQUFJMjNCLFFBQVEsQ0FBQzUrRCxVQUFULElBQXVCNCtELFFBQVEsQ0FBQzUrRCxVQUFULElBQXVCK2dCLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdpdkUsT0FBN0QsRUFBc0U7Y0FBRTs7Ozs7UUFHNUUsS0FBSyxJQUFJcnpFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtdEQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV2t0QixJQUFYLENBQWdCMXpCLE1BQXBDLEVBQTRDb0MsQ0FBQyxFQUE3QyxFQUFpRDtVQUMvQyxJQUFJeStELFFBQVEsR0FBR3RSLEVBQUUsQ0FBQy9vRCxPQUFILENBQVdrdEIsSUFBWCxDQUFnQnR4QixDQUFoQixDQUFmOztVQUNBLElBQUl5K0QsUUFBUSxDQUFDdDNDLElBQVQsSUFBaUI2akYsUUFBckIsRUFDRTtZQUFFLE9BQU9DLG9CQUFvQixDQUFDeHNDLFFBQUQsRUFBV3QzQyxJQUFYLEVBQWlCaUwsTUFBakIsQ0FBM0I7Ozs7O01BSVIsU0FBUzY0RSxvQkFBVCxDQUE4QnhzQyxRQUE5QixFQUF3Q3QzQyxJQUF4QyxFQUE4Q2lMLE1BQTlDLEVBQXNEO1FBQ3BELElBQUl2SCxPQUFPLEdBQUc0ekMsUUFBUSxDQUFDemlCLElBQVQsQ0FBY25TLFVBQTVCO1lBQXdDMitELEdBQUcsR0FBRyxLQUE5Qzs7UUFDQSxJQUFJLENBQUNyaEYsSUFBRCxJQUFTLENBQUNpL0IsUUFBUSxDQUFDdjdCLE9BQUQsRUFBVTFELElBQVYsQ0FBdEIsRUFBdUM7VUFBRSxPQUFPbWpGLE1BQU0sQ0FBQzkxQyxHQUFHLENBQUNULE1BQU0sQ0FBQzBLLFFBQVEsQ0FBQ2xTLElBQVYsQ0FBUCxFQUF3QixDQUF4QixDQUFKLEVBQWdDLElBQWhDLENBQWI7OztRQUN6QyxJQUFJcGxDLElBQUksSUFBSTBELE9BQVosRUFBcUI7VUFDbkIyOUUsR0FBRyxHQUFHLElBQU47VUFDQXJoRixJQUFJLEdBQUcwRCxPQUFPLENBQUNtZixVQUFSLENBQW1CNVgsTUFBbkIsQ0FBUDtVQUNBQSxNQUFNLEdBQUcsQ0FBVDs7VUFDQSxJQUFJLENBQUNqTCxJQUFMLEVBQVc7WUFDVCxJQUFJb2xDLElBQUksR0FBR2tTLFFBQVEsQ0FBQ00sSUFBVCxHQUFnQnJXLEdBQUcsQ0FBQytWLFFBQVEsQ0FBQ00sSUFBVixDQUFuQixHQUFxQ04sUUFBUSxDQUFDbFMsSUFBekQ7WUFDQSxPQUFPKzlDLE1BQU0sQ0FBQzkxQyxHQUFHLENBQUNULE1BQU0sQ0FBQ3hILElBQUQsQ0FBUCxFQUFlQSxJQUFJLENBQUN2USxJQUFMLENBQVVwK0MsTUFBekIsQ0FBSixFQUFzQzRxRyxHQUF0QyxDQUFiOzs7O1FBSUosSUFBSTBDLFFBQVEsR0FBRy9qRixJQUFJLENBQUMraUIsUUFBTCxJQUFpQixDQUFqQixHQUFxQi9pQixJQUFyQixHQUE0QixJQUEzQztZQUFpRGdrRixPQUFPLEdBQUdoa0YsSUFBM0Q7O1FBQ0EsSUFBSSxDQUFDK2pGLFFBQUQsSUFBYS9qRixJQUFJLENBQUM2aUIsVUFBTCxDQUFnQnBzQyxNQUFoQixJQUEwQixDQUF2QyxJQUE0Q3VwQixJQUFJLENBQUMwaUIsVUFBTCxDQUFnQkssUUFBaEIsSUFBNEIsQ0FBNUUsRUFBK0U7VUFDN0VnaEUsUUFBUSxHQUFHL2pGLElBQUksQ0FBQzBpQixVQUFoQjs7VUFDQSxJQUFJelgsTUFBSixFQUFZO1lBQUVBLE1BQU0sR0FBRzg0RSxRQUFRLENBQUNILFNBQVQsQ0FBbUJudEcsTUFBNUI7Ozs7UUFFaEIsT0FBT3V0RyxPQUFPLENBQUMvK0QsVUFBUixJQUFzQnZoQixPQUE3QixFQUFzQztVQUFFc2dGLE9BQU8sR0FBR0EsT0FBTyxDQUFDLytELFVBQWxCOzs7UUFDeEMsSUFBSXVpQixPQUFPLEdBQUc4UCxRQUFRLENBQUM5UCxPQUF2QjtZQUFnQzJRLElBQUksR0FBRzNRLE9BQU8sQ0FBQzJRLElBQS9DOztRQUVBLFNBQVN4aEQsSUFBVCxDQUFjb3RGLFFBQWQsRUFBd0JDLE9BQXhCLEVBQWlDLzRFLE1BQWpDLEVBQXlDO1VBQ3ZDLEtBQUssSUFBSXB5QixDQUFDLEdBQUcsQ0FBQyxDQUFkLEVBQWlCQSxDQUFDLElBQUlzL0QsSUFBSSxHQUFHQSxJQUFJLENBQUMxaEUsTUFBUixHQUFpQixDQUF6QixDQUFsQixFQUErQ29DLENBQUMsRUFBaEQsRUFBb0Q7WUFDbEQsSUFBSXNjLEdBQUcsR0FBR3RjLENBQUMsR0FBRyxDQUFKLEdBQVEydUQsT0FBTyxDQUFDcnlDLEdBQWhCLEdBQXNCZ2pELElBQUksQ0FBQ3QvRCxDQUFELENBQXBDOztZQUNBLEtBQUssSUFBSWdJLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzVSxHQUFHLENBQUMxZSxNQUF4QixFQUFnQ29LLENBQUMsSUFBSSxDQUFyQyxFQUF3QztjQUN0QyxJQUFJb2pHLE9BQU8sR0FBRzl1RixHQUFHLENBQUN0VSxDQUFDLEdBQUcsQ0FBTCxDQUFqQjs7Y0FDQSxJQUFJb2pHLE9BQU8sSUFBSUYsUUFBWCxJQUF1QkUsT0FBTyxJQUFJRCxPQUF0QyxFQUErQztnQkFDN0MsSUFBSTUrQyxJQUFJLEdBQUd3SCxNQUFNLENBQUMvekQsQ0FBQyxHQUFHLENBQUosR0FBUXkrRCxRQUFRLENBQUNsUyxJQUFqQixHQUF3QmtTLFFBQVEsQ0FBQ00sSUFBVCxDQUFjLytELENBQWQsQ0FBekIsQ0FBakI7Z0JBQ0EsSUFBSXlpQixFQUFFLEdBQUduRyxHQUFHLENBQUN0VSxDQUFELENBQUgsR0FBU29xQixNQUFsQjs7Z0JBQ0EsSUFBSUEsTUFBTSxHQUFHLENBQVQsSUFBY2c1RSxPQUFPLElBQUlGLFFBQTdCLEVBQXVDO2tCQUFFem9GLEVBQUUsR0FBR25HLEdBQUcsQ0FBQ3RVLENBQUMsSUFBSW9xQixNQUFNLEdBQUcsQ0FBSCxHQUFPLENBQWpCLENBQUYsQ0FBUjs7O2dCQUN6QyxPQUFPb2lDLEdBQUcsQ0FBQ2pJLElBQUQsRUFBTzlwQyxFQUFQLENBQVY7Ozs7OztRQUtSLElBQUl1bkMsS0FBSyxHQUFHbHNDLElBQUksQ0FBQ290RixRQUFELEVBQVdDLE9BQVgsRUFBb0IvNEUsTUFBcEIsQ0FBaEI7O1FBQ0EsSUFBSTQzQixLQUFKLEVBQVc7VUFBRSxPQUFPc2dELE1BQU0sQ0FBQ3RnRCxLQUFELEVBQVF3K0MsR0FBUixDQUFiO1NBcEN1Qzs7O1FBdUNwRCxLQUFLLElBQUlqakQsS0FBSyxHQUFHNGxELE9BQU8sQ0FBQ3YrRCxXQUFwQixFQUFpQ3lnQyxJQUFJLEdBQUc2OUIsUUFBUSxHQUFHQSxRQUFRLENBQUNILFNBQVQsQ0FBbUJudEcsTUFBbkIsR0FBNEJ3MEIsTUFBL0IsR0FBd0MsQ0FBN0YsRUFBZ0dtekIsS0FBaEcsRUFBdUdBLEtBQUssR0FBR0EsS0FBSyxDQUFDM1ksV0FBckgsRUFBa0k7VUFDaElvZCxLQUFLLEdBQUdsc0MsSUFBSSxDQUFDeW5DLEtBQUQsRUFBUUEsS0FBSyxDQUFDMWIsVUFBZCxFQUEwQixDQUExQixDQUFaOztVQUNBLElBQUltZ0IsS0FBSixFQUNFO1lBQUUsT0FBT3NnRCxNQUFNLENBQUM5MUMsR0FBRyxDQUFDeEssS0FBSyxDQUFDdUMsSUFBUCxFQUFhdkMsS0FBSyxDQUFDdm5DLEVBQU4sR0FBVzRxRCxJQUF4QixDQUFKLEVBQW1DbTdCLEdBQW5DLENBQWI7V0FESixNQUdFO1lBQUVuN0IsSUFBSSxJQUFJOW5CLEtBQUssQ0FBQ3hhLFdBQU4sQ0FBa0JudEMsTUFBMUI7Ozs7UUFFTixLQUFLLElBQUltdUQsTUFBTSxHQUFHby9DLE9BQU8sQ0FBQzNCLGVBQXJCLEVBQXNDNkIsTUFBTSxHQUFHajVFLE1BQXBELEVBQTREMjVCLE1BQTVELEVBQW9FQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ3k5QyxlQUFwRixFQUFxRztVQUNuR3gvQyxLQUFLLEdBQUdsc0MsSUFBSSxDQUFDaXVDLE1BQUQsRUFBU0EsTUFBTSxDQUFDbGlCLFVBQWhCLEVBQTRCLENBQUMsQ0FBN0IsQ0FBWjs7VUFDQSxJQUFJbWdCLEtBQUosRUFDRTtZQUFFLE9BQU9zZ0QsTUFBTSxDQUFDOTFDLEdBQUcsQ0FBQ3hLLEtBQUssQ0FBQ3VDLElBQVAsRUFBYXZDLEtBQUssQ0FBQ3ZuQyxFQUFOLEdBQVc0b0YsTUFBeEIsQ0FBSixFQUFxQzdDLEdBQXJDLENBQWI7V0FESixNQUdFO1lBQUU2QyxNQUFNLElBQUl0L0MsTUFBTSxDQUFDaGhCLFdBQVAsQ0FBbUJudEMsTUFBN0I7OztPQTdsU1c7OztNQW1tU25CLElBQUkwdEcsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFTbitDLEVBQVQsRUFBYTtRQUMvQixLQUFLQSxFQUFMLEdBQVVBLEVBQVYsQ0FEK0I7O1FBRy9CLEtBQUtvK0MsU0FBTCxHQUFpQixFQUFqQixDQUgrQjs7OztRQVEvQixLQUFLQyxXQUFMLEdBQW1CLEtBQW5CLENBUitCOztRQVUvQixLQUFLcEUsT0FBTCxHQUFlLElBQUk1L0MsT0FBSixFQUFmLENBVitCOztRQVkvQixLQUFLOEgsWUFBTCxHQUFvQixLQUFwQjtRQUNBLEtBQUsrM0MsU0FBTCxHQUFpQixJQUFqQjtPQWJGOztNQWdCQWlFLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCbzhCLElBQXhCLEdBQStCLFVBQVUxMUIsT0FBVixFQUFtQjtRQUM5QyxJQUFJNm1GLE1BQU0sR0FBRyxJQUFiO1FBRUYsSUFBSXRxQixLQUFLLEdBQUcsSUFBWjtZQUFrQnhULEVBQUUsR0FBRyxLQUFLQSxFQUE1QjtRQUNBLEtBQUtzK0MsV0FBTCxDQUFpQnJuRyxPQUFqQjtRQUNBLElBQUlvckQsRUFBRSxHQUFHLEtBQUtrOEMsUUFBZDtRQUVBdG5HLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCNGQsWUFBaEIsQ0FBNkIsS0FBSzVkLE9BQWxDLEVBQTJDem1CLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCZ2YsVUFBM0QsRUFQZ0Q7O1FBVWhELElBQUkyYSxHQUFKLEVBQVM7VUFBRWdMLEVBQUUsQ0FBQ3JyRCxLQUFILENBQVMrMEMsS0FBVCxHQUFpQixLQUFqQjs7O1FBRVh1VCxFQUFFLENBQUMrQyxFQUFELEVBQUssT0FBTCxFQUFjLFlBQVk7VUFDMUIsSUFBSTNMLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXBCLElBQXlCbW5DLE1BQU0sQ0FBQzM3QixZQUFwQyxFQUFrRDtZQUFFMjdCLE1BQU0sQ0FBQzM3QixZQUFQLEdBQXNCLElBQXRCOzs7VUFDcERxUixLQUFLLENBQUN1b0MsSUFBTjtTQUZBLENBQUY7UUFLQXo4QyxFQUFFLENBQUMrQyxFQUFELEVBQUssT0FBTCxFQUFjLFVBQVV4MUQsQ0FBVixFQUFhO1VBQzNCLElBQUlrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFkLElBQXlCeW9HLFdBQVcsQ0FBQ3pvRyxDQUFELEVBQUltekQsRUFBSixDQUF4QyxFQUFpRDtZQUFFOzs7VUFFbkRBLEVBQUUsQ0FBQzlwQixLQUFILENBQVMyOEQsYUFBVCxHQUF5QixDQUFDLElBQUl6bkYsSUFBSixFQUExQjtVQUNBb29ELEtBQUssQ0FBQ2dyQyxRQUFOO1NBSkEsQ0FBRjs7UUFPQSxTQUFTQyxjQUFULENBQXdCNXhHLENBQXhCLEVBQTJCO1VBQ3pCLElBQUlrekQsY0FBYyxDQUFDQyxFQUFELEVBQUtuekQsQ0FBTCxDQUFsQixFQUEyQjtZQUFFOzs7VUFDN0IsSUFBSW16RCxFQUFFLENBQUNtMEIsaUJBQUgsRUFBSixFQUE0QjtZQUMxQnVnQixhQUFhLENBQUM7Y0FBQ1UsUUFBUSxFQUFFLEtBQVg7Y0FBa0J2bUQsSUFBSSxFQUFFbVIsRUFBRSxDQUFDMmdDLGFBQUg7YUFBekIsQ0FBYjtXQURGLE1BRU8sSUFBSSxDQUFDM2dDLEVBQUUsQ0FBQ2psQixPQUFILENBQVc0L0QsZUFBaEIsRUFBaUM7WUFDdEM7V0FESyxNQUVBO1lBQ0wsSUFBSWo0QixNQUFNLEdBQUdvekIsY0FBYyxDQUFDOTFDLEVBQUQsQ0FBM0I7WUFDQTAwQyxhQUFhLENBQUM7Y0FBQ1UsUUFBUSxFQUFFLElBQVg7Y0FBaUJ2bUQsSUFBSSxFQUFFNnpCLE1BQU0sQ0FBQzd6QjthQUEvQixDQUFiOztZQUNBLElBQUloaUQsQ0FBQyxDQUFDb0UsSUFBRixJQUFVLEtBQWQsRUFBcUI7Y0FDbkIrdUQsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUIvZCxNQUFNLENBQUNBLE1BQXhCLEVBQWdDLElBQWhDLEVBQXNDOW5CLGNBQXRDO2FBREYsTUFFTztjQUNMNFksS0FBSyxDQUFDNHFDLFNBQU4sR0FBa0IsRUFBbEI7Y0FDQS83QyxFQUFFLENBQUM1ekQsS0FBSCxHQUFXaTBFLE1BQU0sQ0FBQzd6QixJQUFQLENBQVl4K0MsSUFBWixDQUFpQixJQUFqQixDQUFYO2NBQ0FtcEQsV0FBVyxDQUFDNkksRUFBRCxDQUFYOzs7O1VBR0osSUFBSXgxRCxDQUFDLENBQUNvRSxJQUFGLElBQVUsS0FBZCxFQUFxQjtZQUFFK3VELEVBQUUsQ0FBQzlwQixLQUFILENBQVM0OEQsV0FBVCxHQUF1QixDQUFDLElBQUkxbkYsSUFBSixFQUF4Qjs7OztRQUV6QmswQyxFQUFFLENBQUMrQyxFQUFELEVBQUssS0FBTCxFQUFZbzhDLGNBQVosQ0FBRjtRQUNBbi9DLEVBQUUsQ0FBQytDLEVBQUQsRUFBSyxNQUFMLEVBQWFvOEMsY0FBYixDQUFGO1FBRUFuL0MsRUFBRSxDQUFDcm9ELE9BQU8sQ0FBQ3VpRSxRQUFULEVBQW1CLE9BQW5CLEVBQTRCLFVBQVUzc0UsQ0FBVixFQUFhO1VBQ3pDLElBQUk0ckUsYUFBYSxDQUFDeGhFLE9BQUQsRUFBVXBLLENBQVYsQ0FBYixJQUE2Qmt6RCxjQUFjLENBQUNDLEVBQUQsRUFBS256RCxDQUFMLENBQS9DLEVBQXdEO1lBQUU7OztVQUMxRCxJQUFJLENBQUN3MUQsRUFBRSxDQUFDelYsYUFBUixFQUF1QjtZQUNyQm9ULEVBQUUsQ0FBQzlwQixLQUFILENBQVMyOEQsYUFBVCxHQUF5QixDQUFDLElBQUl6bkYsSUFBSixFQUExQjtZQUNBb29ELEtBQUssQ0FBQzllLEtBQU47WUFDQTtXQUx1Qzs7O1VBU3pDLElBQUl2OEIsS0FBSyxHQUFHLElBQUl1bUYsS0FBSixDQUFVLE9BQVYsQ0FBWjtVQUNBdm1GLEtBQUssQ0FBQ3E5RSxhQUFOLEdBQXNCM29HLENBQUMsQ0FBQzJvRyxhQUF4QjtVQUNBbnpDLEVBQUUsQ0FBQ3pWLGFBQUgsQ0FBaUJ6MEIsS0FBakI7U0FYQSxDQUFGLENBOUNnRDs7UUE2RGhEbW5DLEVBQUUsQ0FBQ3JvRCxPQUFPLENBQUM0aEUsU0FBVCxFQUFvQixhQUFwQixFQUFtQyxVQUFVaHNFLENBQVYsRUFBYTtVQUNoRCxJQUFJLENBQUM0ckUsYUFBYSxDQUFDeGhFLE9BQUQsRUFBVXBLLENBQVYsQ0FBbEIsRUFBZ0M7WUFBRTh6RCxnQkFBZ0IsQ0FBQzl6RCxDQUFELENBQWhCOztTQURsQyxDQUFGO1FBSUF5eUQsRUFBRSxDQUFDK0MsRUFBRCxFQUFLLGtCQUFMLEVBQXlCLFlBQVk7VUFDckMsSUFBSXQwQyxLQUFLLEdBQUdpeUMsRUFBRSxDQUFDeW9CLFNBQUgsQ0FBYSxNQUFiLENBQVo7O1VBQ0EsSUFBSWpWLEtBQUssQ0FBQzBtQyxTQUFWLEVBQXFCO1lBQUUxbUMsS0FBSyxDQUFDMG1DLFNBQU4sQ0FBZ0J0cUQsS0FBaEIsQ0FBc0I5MkIsS0FBdEI7OztVQUN2QjA2QyxLQUFLLENBQUMwbUMsU0FBTixHQUFrQjtZQUNoQm5zRixLQUFLLEVBQUVBLEtBRFM7WUFFaEI2aEMsS0FBSyxFQUFFb1EsRUFBRSxDQUFDdytCLFFBQUgsQ0FBWXp3RSxLQUFaLEVBQW1CaXlDLEVBQUUsQ0FBQ3lvQixTQUFILENBQWEsSUFBYixDQUFuQixFQUF1QztjQUFDdHdCLFNBQVMsRUFBRTthQUFuRDtXQUZUO1NBSEEsQ0FBRjtRQVFBbUgsRUFBRSxDQUFDK0MsRUFBRCxFQUFLLGdCQUFMLEVBQXVCLFlBQVk7VUFDbkMsSUFBSW1SLEtBQUssQ0FBQzBtQyxTQUFWLEVBQXFCO1lBQ25CMW1DLEtBQUssQ0FBQ3VvQyxJQUFOO1lBQ0F2b0MsS0FBSyxDQUFDMG1DLFNBQU4sQ0FBZ0J0cUQsS0FBaEIsQ0FBc0I5MkIsS0FBdEI7WUFDQTA2QyxLQUFLLENBQUMwbUMsU0FBTixHQUFrQixJQUFsQjs7U0FKRixDQUFGO09BekVGOztNQWtGQWlFLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCK3RHLFdBQXhCLEdBQXNDLFVBQVVLLFFBQVYsRUFBb0I7O1FBRXhELEtBQUtqaEYsT0FBTCxHQUFldzRFLGNBQWMsRUFBN0IsQ0FGd0Q7OztRQUt4RCxLQUFLcUksUUFBTCxHQUFnQixLQUFLN2dGLE9BQUwsQ0FBYWdmLFVBQTdCO09BTEY7O01BUUF5aEUsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0IyaEcsd0JBQXhCLEdBQW1ELFVBQVU4SSxLQUFWLEVBQWlCOztRQUVsRSxJQUFHQSxLQUFILEVBQVU7VUFDUixLQUFLdUQsUUFBTCxDQUFjbDlELFlBQWQsQ0FBMkIsWUFBM0IsRUFBeUMyNUQsS0FBekM7U0FERixNQUVPO1VBQ0wsS0FBS3VELFFBQUwsQ0FBYzdnRSxlQUFkLENBQThCLFlBQTlCOztPQUxKOztNQVNBeWdFLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCNnhFLGdCQUF4QixHQUEyQyxZQUFZOztRQUVyRCxJQUFJcGlCLEVBQUUsR0FBRyxLQUFLQSxFQUFkO1lBQWtCL29ELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBL0I7WUFBd0NpdkQsR0FBRyxHQUFHbEcsRUFBRSxDQUFDa0csR0FBakQ7UUFDQSxJQUFJendELE1BQU0sR0FBRzJzRSxnQkFBZ0IsQ0FBQ3BpQixFQUFELENBQTdCLENBSHFEOztRQU1yRCxJQUFJQSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXNmpFLG1CQUFmLEVBQW9DO1VBQ2xDLElBQUl0RyxPQUFPLEdBQUdoNkIsYUFBWSxDQUFDdGUsRUFBRCxFQUFLa0csR0FBRyxDQUFDdWMsR0FBSixDQUFRSixPQUFSLEdBQWtCaHBELElBQXZCLEVBQTZCLEtBQTdCLENBQTFCOztVQUNBLElBQUl3bEYsT0FBTyxHQUFHNW5HLE9BQU8sQ0FBQ3ltQixPQUFSLENBQWdCeXZCLHFCQUFoQixFQUFkO2NBQXVEMnhELE9BQU8sR0FBRzduRyxPQUFPLENBQUNpdkUsT0FBUixDQUFnQi80QixxQkFBaEIsRUFBakU7VUFDQTEzQyxNQUFNLENBQUNzcEcsS0FBUCxHQUFlM3lHLElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVl4SSxJQUFJLENBQUNzSSxHQUFMLENBQVN1QyxPQUFPLENBQUN5bUIsT0FBUixDQUFnQmk4QyxZQUFoQixHQUErQixFQUF4QyxFQUNTMitCLE9BQU8sQ0FBQy9xRCxHQUFSLEdBQWN1eEQsT0FBTyxDQUFDdnhELEdBQXRCLEdBQTRCc3hELE9BQU8sQ0FBQ3R4RCxHQUQ3QyxDQUFaLENBQWY7VUFFQTkzQyxNQUFNLENBQUN1cEcsTUFBUCxHQUFnQjV5RyxJQUFJLENBQUN3SSxHQUFMLENBQVMsQ0FBVCxFQUFZeEksSUFBSSxDQUFDc0ksR0FBTCxDQUFTdUMsT0FBTyxDQUFDeW1CLE9BQVIsQ0FBZ0I4NkMsV0FBaEIsR0FBOEIsRUFBdkMsRUFDUzgvQixPQUFPLENBQUMzb0UsSUFBUixHQUFlbXZFLE9BQU8sQ0FBQ252RSxJQUF2QixHQUE4Qmt2RSxPQUFPLENBQUNsdkUsSUFEL0MsQ0FBWixDQUFoQjs7O1FBSUYsT0FBT2w2QixNQUFQO09BZkY7O01Ba0JBMG9HLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCNHhFLGFBQXhCLEdBQXdDLFVBQVU4OEIsS0FBVixFQUFpQjtRQUN2RCxJQUFJai9DLEVBQUUsR0FBRyxLQUFLQSxFQUFkO1lBQWtCL29ELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBL0I7UUFDQXFoRCxvQkFBb0IsQ0FBQ3JoRCxPQUFPLENBQUNvdUUsU0FBVCxFQUFvQjQ1QixLQUFLLENBQUMxOEIsT0FBMUIsQ0FBcEI7UUFDQWpxQixvQkFBb0IsQ0FBQ3JoRCxPQUFPLENBQUM4NUUsWUFBVCxFQUF1Qmt1QixLQUFLLENBQUMxOEMsU0FBN0IsQ0FBcEI7O1FBQ0EsSUFBSTA4QyxLQUFLLENBQUNGLEtBQU4sSUFBZSxJQUFuQixFQUF5QjtVQUN2QixLQUFLcmhGLE9BQUwsQ0FBYTFtQixLQUFiLENBQW1CdTJDLEdBQW5CLEdBQXlCMHhELEtBQUssQ0FBQ0YsS0FBTixHQUFjLElBQXZDO1VBQ0EsS0FBS3JoRixPQUFMLENBQWExbUIsS0FBYixDQUFtQjI0QixJQUFuQixHQUEwQnN2RSxLQUFLLENBQUNELE1BQU4sR0FBZSxJQUF6Qzs7T0FOSixDQXh1U21COzs7O01Bb3ZTbkJiLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCaW5DLEtBQXhCLEdBQWdDLFVBQVVnMUMsTUFBVixFQUFrQjtRQUNoRCxJQUFJLEtBQUsweUIsa0JBQUwsSUFBMkIsS0FBS2hGLFNBQXBDLEVBQStDO1VBQUU7OztRQUNqRCxJQUFJbDZDLEVBQUUsR0FBRyxLQUFLQSxFQUFkOztRQUNBLElBQUlBLEVBQUUsQ0FBQ20wQixpQkFBSCxFQUFKLEVBQTRCO1VBQzFCLEtBQUtpcUIsU0FBTCxHQUFpQixFQUFqQjtVQUNBLElBQUk1aEUsT0FBTyxHQUFHd2pCLEVBQUUsQ0FBQ29DLFlBQUgsRUFBZDtVQUNBLEtBQUttOEMsUUFBTCxDQUFjOXZHLEtBQWQsR0FBc0IrdEMsT0FBdEI7O1VBQ0EsSUFBSXdqQixFQUFFLENBQUM5cEIsS0FBSCxDQUFTZ3ZDLE9BQWIsRUFBc0I7WUFBRTFyQixXQUFXLENBQUMsS0FBSytrRCxRQUFOLENBQVg7OztVQUN4QixJQUFJN25ELEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO1lBQUUsS0FBS3dMLFlBQUwsR0FBb0IzbEIsT0FBcEI7O1NBTC9CLE1BTU8sSUFBSSxDQUFDZ3dDLE1BQUwsRUFBYTtVQUNsQixLQUFLNHhCLFNBQUwsR0FBaUIsS0FBS0csUUFBTCxDQUFjOXZHLEtBQWQsR0FBc0IsRUFBdkM7O1VBQ0EsSUFBSWlvRCxFQUFFLElBQUlDLFVBQVUsSUFBSSxDQUF4QixFQUEyQjtZQUFFLEtBQUt3TCxZQUFMLEdBQW9CLElBQXBCOzs7T0FYakM7O01BZUFnOEMsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0J5OEYsUUFBeEIsR0FBbUMsWUFBWTtRQUFFLE9BQU8sS0FBS3VSLFFBQVo7T0FBakQ7O01BRUFKLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCdTlGLGFBQXhCLEdBQXdDLFlBQVk7UUFBRSxPQUFPLEtBQVA7T0FBdEQ7O01BRUFxUSxhQUFhLENBQUM1dEcsU0FBZCxDQUF3Qm1rRCxLQUF4QixHQUFnQyxZQUFZO1FBQzFDLElBQUksS0FBS3NMLEVBQUwsQ0FBUWpsQixPQUFSLENBQWdCa3pCLFFBQWhCLElBQTRCLFVBQTVCLEtBQTJDLENBQUN6VyxNQUFELElBQVcyQixTQUFTLE1BQU0sS0FBS29sRCxRQUExRSxDQUFKLEVBQXlGO1VBQ3ZGLElBQUk7WUFBRSxLQUFLQSxRQUFMLENBQWM3cEQsS0FBZDtXQUFOLENBQ0EsT0FBTzduRCxDQUFQLEVBQVUsRUFGNkU7OztPQUQzRjs7TUFPQXN4RyxhQUFhLENBQUM1dEcsU0FBZCxDQUF3QnloRyxJQUF4QixHQUErQixZQUFZO1FBQUUsS0FBS3VNLFFBQUwsQ0FBY3ZNLElBQWQ7T0FBN0M7O01BRUFtTSxhQUFhLENBQUM1dEcsU0FBZCxDQUF3QjZoRyxhQUF4QixHQUF3QyxZQUFZO1FBQ2xELEtBQUsxMEUsT0FBTCxDQUFhMW1CLEtBQWIsQ0FBbUJ1MkMsR0FBbkIsR0FBeUIsS0FBSzd2QixPQUFMLENBQWExbUIsS0FBYixDQUFtQjI0QixJQUFuQixHQUEwQixDQUFuRDtPQURGOztNQUlBd3VFLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCdTFFLGFBQXhCLEdBQXdDLFlBQVk7UUFBRSxLQUFLcTVCLFFBQUw7T0FBdEQsQ0FweFNtQjs7OztNQXd4U25CaEIsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0I0dUcsUUFBeEIsR0FBbUMsWUFBWTtRQUMzQyxJQUFJcmhCLE1BQU0sR0FBRyxJQUFiOztRQUVGLElBQUksS0FBS3VnQixXQUFULEVBQXNCO1VBQUU7OztRQUN4QixLQUFLcEUsT0FBTCxDQUFhdi9GLEdBQWIsQ0FBaUIsS0FBS3NsRCxFQUFMLENBQVFqbEIsT0FBUixDQUFnQmloRSxZQUFqQyxFQUErQyxZQUFZO1VBQ3pEbGUsTUFBTSxDQUFDaWUsSUFBUDs7VUFDQSxJQUFJamUsTUFBTSxDQUFDOTlCLEVBQVAsQ0FBVTlwQixLQUFWLENBQWdCZ3ZDLE9BQXBCLEVBQTZCO1lBQUU0WSxNQUFNLENBQUNxaEIsUUFBUDs7U0FGakM7T0FKRixDQXh4U21COzs7OztNQXF5U25CaEIsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0JpdUcsUUFBeEIsR0FBbUMsWUFBWTtRQUM3QyxJQUFJWSxNQUFNLEdBQUcsS0FBYjtZQUFvQjVyQyxLQUFLLEdBQUcsSUFBNUI7UUFDQUEsS0FBSyxDQUFDNnFDLFdBQU4sR0FBb0IsSUFBcEI7O1FBQ0EsU0FBUzlzRixDQUFULEdBQWE7VUFDWCxJQUFJNjFELE9BQU8sR0FBRzVULEtBQUssQ0FBQ3VvQyxJQUFOLEVBQWQ7O1VBQ0EsSUFBSSxDQUFDMzBCLE9BQUQsSUFBWSxDQUFDZzRCLE1BQWpCLEVBQXlCO1lBQUNBLE1BQU0sR0FBRyxJQUFUO1lBQWU1ckMsS0FBSyxDQUFDeW1DLE9BQU4sQ0FBY3YvRixHQUFkLENBQWtCLEVBQWxCLEVBQXNCNlcsQ0FBdEI7V0FBekMsTUFDSztZQUFDaWlELEtBQUssQ0FBQzZxQyxXQUFOLEdBQW9CLEtBQXBCO1lBQTJCN3FDLEtBQUssQ0FBQzJyQyxRQUFOOzs7O1FBRW5DM3JDLEtBQUssQ0FBQ3ltQyxPQUFOLENBQWN2L0YsR0FBZCxDQUFrQixFQUFsQixFQUFzQjZXLENBQXRCO09BUkYsQ0FyeVNtQjs7Ozs7Ozs7TUFzelNuQjRzRixhQUFhLENBQUM1dEcsU0FBZCxDQUF3QndyRyxJQUF4QixHQUErQixZQUFZO1FBQ3ZDLElBQUlqZSxNQUFNLEdBQUcsSUFBYjtRQUVGLElBQUk5OUIsRUFBRSxHQUFHLEtBQUtBLEVBQWQ7WUFBa0J3VCxLQUFLLEdBQUcsS0FBSytxQyxRQUEvQjtZQUF5Q0gsU0FBUyxHQUFHLEtBQUtBLFNBQTFELENBSHlDOzs7OztRQVF6QyxJQUFJLEtBQUtjLGtCQUFMLElBQTJCLENBQUNsL0MsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU2d2QyxPQUFyQyxJQUNDL2lCLFlBQVksQ0FBQ3FSLEtBQUQsQ0FBWixJQUF1QixDQUFDNHFDLFNBQXhCLElBQXFDLENBQUMsS0FBS2xFLFNBRDVDLElBRUFsNkMsRUFBRSxDQUFDMmpDLFVBQUgsRUFGQSxJQUVtQjNqQyxFQUFFLENBQUNqbEIsT0FBSCxDQUFXMDZELFlBRjlCLElBRThDejFDLEVBQUUsQ0FBQzlwQixLQUFILENBQVN3MkQsTUFGM0QsRUFHRTtVQUFFLE9BQU8sS0FBUDs7O1FBRUosSUFBSTc5QyxJQUFJLEdBQUcya0IsS0FBSyxDQUFDL2tFLEtBQWpCLENBYnlDOztRQWV6QyxJQUFJb2dELElBQUksSUFBSXV2RCxTQUFSLElBQXFCLENBQUNwK0MsRUFBRSxDQUFDbTBCLGlCQUFILEVBQTFCLEVBQWtEO1VBQUUsT0FBTyxLQUFQO1NBZlg7Ozs7O1FBbUJ6QyxJQUFJejlCLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXBCLElBQXlCLEtBQUt3TCxZQUFMLEtBQXNCdFQsSUFBL0MsSUFDQTRJLEdBQUcsSUFBSSxrQkFBa0JwNkMsSUFBbEIsQ0FBdUJ3eEMsSUFBdkIsQ0FEWCxFQUN5QztVQUN2Q21SLEVBQUUsQ0FBQy9vRCxPQUFILENBQVd1OEQsS0FBWCxDQUFpQmg4QixLQUFqQjtVQUNBLE9BQU8sS0FBUDs7O1FBR0YsSUFBSXdvQixFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFQLElBQWN6aUIsRUFBRSxDQUFDL29ELE9BQUgsQ0FBVzR1RSxpQkFBN0IsRUFBZ0Q7VUFDOUMsSUFBSWxsRSxLQUFLLEdBQUdrdUMsSUFBSSxDQUFDanVDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBWjs7VUFDQSxJQUFJRCxLQUFLLElBQUksTUFBVCxJQUFtQixDQUFDeTlGLFNBQXhCLEVBQW1DO1lBQUVBLFNBQVMsR0FBRyxRQUFaOzs7VUFDckMsSUFBSXo5RixLQUFLLElBQUksTUFBYixFQUFxQjtZQUFFLEtBQUs2MkIsS0FBTDtZQUFjLE9BQU8sS0FBS3dvQixFQUFMLENBQVF1ckMsV0FBUixDQUFvQixNQUFwQixDQUFQOztTQTVCRTs7O1FBK0J6QyxJQUFJOFQsSUFBSSxHQUFHLENBQVg7WUFBY3BsRyxDQUFDLEdBQUc3TixJQUFJLENBQUNzSSxHQUFMLENBQVMwcEcsU0FBUyxDQUFDM3RHLE1BQW5CLEVBQTJCbytDLElBQUksQ0FBQ3ArQyxNQUFoQyxDQUFsQjs7UUFDQSxPQUFPNHVHLElBQUksR0FBR3BsRyxDQUFQLElBQVlta0csU0FBUyxDQUFDeDlGLFVBQVYsQ0FBcUJ5K0YsSUFBckIsS0FBOEJ4d0QsSUFBSSxDQUFDanVDLFVBQUwsQ0FBZ0J5K0YsSUFBaEIsQ0FBakQsRUFBd0U7VUFBRSxFQUFFQSxJQUFGOzs7UUFFMUVoeEIsT0FBTyxDQUFDcnVCLEVBQUQsRUFBSyxZQUFZO1VBQ3RCNDBDLGNBQWMsQ0FBQzUwQyxFQUFELEVBQUtuUixJQUFJLENBQUMzNkMsS0FBTCxDQUFXbXJHLElBQVgsQ0FBTCxFQUF1QmpCLFNBQVMsQ0FBQzN0RyxNQUFWLEdBQW1CNHVHLElBQTFDLEVBQ0MsSUFERCxFQUNPdmhCLE1BQU0sQ0FBQ29jLFNBQVAsR0FBbUIsVUFBbkIsR0FBZ0MsSUFEdkMsQ0FBZCxDQURzQjs7VUFLdEIsSUFBSXJyRCxJQUFJLENBQUNwK0MsTUFBTCxHQUFjLElBQWQsSUFBc0JvK0MsSUFBSSxDQUFDbmxDLE9BQUwsQ0FBYSxJQUFiLElBQXFCLENBQUMsQ0FBaEQsRUFBbUQ7WUFBRThwRCxLQUFLLENBQUMva0UsS0FBTixHQUFjcXZGLE1BQU0sQ0FBQ3NnQixTQUFQLEdBQW1CLEVBQWpDO1dBQXJELE1BQ0s7WUFBRXRnQixNQUFNLENBQUNzZ0IsU0FBUCxHQUFtQnZ2RCxJQUFuQjs7O1VBRVAsSUFBSWl2QyxNQUFNLENBQUNvYyxTQUFYLEVBQXNCO1lBQ3BCcGMsTUFBTSxDQUFDb2MsU0FBUCxDQUFpQnRxRCxLQUFqQixDQUF1QjkyQixLQUF2QjtZQUNBZ2xFLE1BQU0sQ0FBQ29jLFNBQVAsQ0FBaUJ0cUQsS0FBakIsR0FBeUJvUSxFQUFFLENBQUN3K0IsUUFBSCxDQUFZVixNQUFNLENBQUNvYyxTQUFQLENBQWlCbnNGLEtBQTdCLEVBQW9DaXlDLEVBQUUsQ0FBQ3lvQixTQUFILENBQWEsSUFBYixDQUFwQyxFQUNVO2NBQUN0d0IsU0FBUyxFQUFFO2FBRHRCLENBQXpCOztTQVZHLENBQVA7UUFjQSxPQUFPLElBQVA7T0FoREY7O01BbURBZ21ELGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCMjdGLFlBQXhCLEdBQXVDLFlBQVk7UUFDakQsSUFBSSxLQUFLbVMsV0FBTCxJQUFvQixLQUFLdEMsSUFBTCxFQUF4QixFQUFxQztVQUFFLEtBQUtzQyxXQUFMLEdBQW1CLEtBQW5COztPQUR6Qzs7TUFJQUYsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0I4OEYsVUFBeEIsR0FBcUMsWUFBWTtRQUMvQyxJQUFJMzJDLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO1VBQUUsS0FBS3dMLFlBQUwsR0FBb0IsSUFBcEI7OztRQUM3QixLQUFLcThDLFFBQUw7T0FGRjs7TUFLQUwsYUFBYSxDQUFDNXRHLFNBQWQsQ0FBd0I0OUYsYUFBeEIsR0FBd0MsVUFBVXRoRyxDQUFWLEVBQWE7UUFDbkQsSUFBSTJtRSxLQUFLLEdBQUcsSUFBWjtZQUFrQnhULEVBQUUsR0FBR3dULEtBQUssQ0FBQ3hULEVBQTdCO1lBQWlDL29ELE9BQU8sR0FBRytvRCxFQUFFLENBQUMvb0QsT0FBOUM7WUFBdURvckQsRUFBRSxHQUFHbVIsS0FBSyxDQUFDK3FDLFFBQWxFOztRQUNBLElBQUkvcUMsS0FBSyxDQUFDMHJDLGtCQUFWLEVBQThCO1VBQUUxckMsS0FBSyxDQUFDMHJDLGtCQUFOOzs7UUFDaEMsSUFBSXY0RixHQUFHLEdBQUdrNkQsWUFBWSxDQUFDN2dCLEVBQUQsRUFBS256RCxDQUFMLENBQXRCO1lBQStCeTZFLFNBQVMsR0FBR3J3RSxPQUFPLENBQUN1aUUsUUFBUixDQUFpQmlFLFNBQTVEOztRQUNBLElBQUksQ0FBQzkyRCxHQUFELElBQVFxd0MsTUFBWixFQUFvQjtVQUFFO1NBSjZCOzs7OztRQVFuRCxJQUFJeGYsS0FBSyxHQUFHd29CLEVBQUUsQ0FBQ2psQixPQUFILENBQVd1a0UsMkJBQXZCOztRQUNBLElBQUk5bkUsS0FBSyxJQUFJd29CLEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VjLEdBQVAsQ0FBV3hwQixRQUFYLENBQW9CdHlDLEdBQXBCLEtBQTRCLENBQUMsQ0FBMUMsRUFDRTtVQUFFb3JDLFNBQVMsQ0FBQ2lPLEVBQUQsRUFBS3E1QixZQUFMLENBQVQsQ0FBNEJyNUIsRUFBRSxDQUFDa0csR0FBL0IsRUFBb0N1dUIsZUFBZSxDQUFDOXRFLEdBQUQsQ0FBbkQsRUFBMERpMEMsY0FBMUQ7OztRQUVKLElBQUkya0QsTUFBTSxHQUFHbDlDLEVBQUUsQ0FBQ3JyRCxLQUFILENBQVM0ckMsT0FBdEI7WUFBK0I0OEQsYUFBYSxHQUFHaHNDLEtBQUssQ0FBQzkxQyxPQUFOLENBQWMxbUIsS0FBZCxDQUFvQjRyQyxPQUFuRTtRQUNBLElBQUk2OEQsVUFBVSxHQUFHanNDLEtBQUssQ0FBQzkxQyxPQUFOLENBQWNnaUYsWUFBZCxDQUEyQnZ5RCxxQkFBM0IsRUFBakI7UUFDQXFtQixLQUFLLENBQUM5MUMsT0FBTixDQUFjMW1CLEtBQWQsQ0FBb0I0ckMsT0FBcEIsR0FBOEIsa0JBQTlCO1FBQ0F5ZixFQUFFLENBQUNyckQsS0FBSCxDQUFTNHJDLE9BQVQsR0FBbUIsaUVBQWlFLzFDLENBQUMsQ0FBQ3lnRCxPQUFGLEdBQVlteUQsVUFBVSxDQUFDbHlELEdBQXZCLEdBQTZCLENBQTlGLElBQW1HLFlBQW5HLElBQW1IMWdELENBQUMsQ0FBQ3VnRCxPQUFGLEdBQVlxeUQsVUFBVSxDQUFDOXZFLElBQXZCLEdBQThCLENBQWpKLElBQXNKLHdDQUF0SixJQUFrTSttQixFQUFFLEdBQUcsMEJBQUgsR0FBZ0MsYUFBcE8sSUFBcVAsbUhBQXhRO1FBQ0EsSUFBSWlwRCxVQUFKOztRQUNBLElBQUk5b0QsTUFBSixFQUFZO1VBQUU4b0QsVUFBVSxHQUFHeHpHLE1BQU0sQ0FBQ3l6RyxPQUFwQjtTQWpCcUM7OztRQWtCbkQzb0csT0FBTyxDQUFDdThELEtBQVIsQ0FBYzllLEtBQWQ7O1FBQ0EsSUFBSW1DLE1BQUosRUFBWTtVQUFFMXFELE1BQU0sQ0FBQ3FzRyxRQUFQLENBQWdCLElBQWhCLEVBQXNCbUgsVUFBdEI7OztRQUNkMW9HLE9BQU8sQ0FBQ3U4RCxLQUFSLENBQWNoOEIsS0FBZCxHQXBCbUQ7O1FBc0JuRCxJQUFJLENBQUN3b0IsRUFBRSxDQUFDbTBCLGlCQUFILEVBQUwsRUFBNkI7VUFBRTl4QixFQUFFLENBQUM1ekQsS0FBSCxHQUFXK2tFLEtBQUssQ0FBQzRxQyxTQUFOLEdBQWtCLEdBQTdCOzs7UUFDL0I1cUMsS0FBSyxDQUFDMHJDLGtCQUFOLEdBQTJCVyxNQUEzQjtRQUNBNW9HLE9BQU8sQ0FBQzR1RSxpQkFBUixHQUE0QjdsQixFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFuQztRQUNBam9CLFlBQVksQ0FBQ3ZqRCxPQUFPLENBQUM2b0csa0JBQVQsQ0FBWixDQXpCbUQ7Ozs7UUE4Qm5ELFNBQVNDLG9CQUFULEdBQWdDO1VBQzlCLElBQUkxOUMsRUFBRSxDQUFDM0ksY0FBSCxJQUFxQixJQUF6QixFQUErQjtZQUM3QixJQUFJNUssUUFBUSxHQUFHa1IsRUFBRSxDQUFDbTBCLGlCQUFILEVBQWY7WUFDQSxJQUFJNnJCLE1BQU0sR0FBRyxZQUFZbHhELFFBQVEsR0FBR3VULEVBQUUsQ0FBQzV6RCxLQUFOLEdBQWMsRUFBbEMsQ0FBYjtZQUNBNHpELEVBQUUsQ0FBQzV6RCxLQUFILEdBQVcsUUFBWCxDQUg2Qjs7WUFJN0I0ekQsRUFBRSxDQUFDNXpELEtBQUgsR0FBV3V4RyxNQUFYO1lBQ0F4c0MsS0FBSyxDQUFDNHFDLFNBQU4sR0FBa0J0dkQsUUFBUSxHQUFHLEVBQUgsR0FBUSxRQUFsQztZQUNBdVQsRUFBRSxDQUFDM0ksY0FBSCxHQUFvQixDQUFwQjtZQUF1QjJJLEVBQUUsQ0FBQzFJLFlBQUgsR0FBa0JxbUQsTUFBTSxDQUFDdnZHLE1BQXpCLENBTk07OztZQVM3QndHLE9BQU8sQ0FBQzR1RSxpQkFBUixHQUE0QjdsQixFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUFuQzs7OztRQUdKLFNBQVNvOUIsTUFBVCxHQUFrQjtVQUNoQixJQUFJcnNDLEtBQUssQ0FBQzByQyxrQkFBTixJQUE0QlcsTUFBaEMsRUFBd0M7WUFBRTs7O1VBQzFDcnNDLEtBQUssQ0FBQzByQyxrQkFBTixHQUEyQixLQUEzQjtVQUNBMXJDLEtBQUssQ0FBQzkxQyxPQUFOLENBQWMxbUIsS0FBZCxDQUFvQjRyQyxPQUFwQixHQUE4QjQ4RCxhQUE5QjtVQUNBbjlDLEVBQUUsQ0FBQ3JyRCxLQUFILENBQVM0ckMsT0FBVCxHQUFtQjI4RCxNQUFuQjs7VUFDQSxJQUFJN29ELEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO1lBQUUxL0MsT0FBTyxDQUFDb3lFLFVBQVIsQ0FBbUJKLFlBQW5CLENBQWdDaHlFLE9BQU8sQ0FBQ3VpRSxRQUFSLENBQWlCaUUsU0FBakIsR0FBNkI2SixTQUE3RDtXQUxaOzs7VUFRaEIsSUFBSWpsQixFQUFFLENBQUMzSSxjQUFILElBQXFCLElBQXpCLEVBQStCO1lBQzdCLElBQUksQ0FBQ2hELEVBQUQsSUFBUUEsRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBL0IsRUFBbUM7Y0FBRW9wRCxvQkFBb0I7OztZQUN6RCxJQUFJbHRHLENBQUMsR0FBRyxDQUFSO2dCQUFXa3BHLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVk7Y0FDNUIsSUFBSTlrRyxPQUFPLENBQUM0dUUsaUJBQVIsSUFBNkI3bEIsRUFBRSxDQUFDa0csR0FBSCxDQUFPdWMsR0FBcEMsSUFBMkNwZ0IsRUFBRSxDQUFDM0ksY0FBSCxJQUFxQixDQUFoRSxJQUNBMkksRUFBRSxDQUFDMUksWUFBSCxHQUFrQixDQURsQixJQUN1QjZaLEtBQUssQ0FBQzRxQyxTQUFOLElBQW1CLFFBRDlDLEVBQ3dEO2dCQUN0RHJzRCxTQUFTLENBQUNpTyxFQUFELEVBQUtnN0IsU0FBTCxDQUFULENBQXlCaDdCLEVBQXpCO2VBRkYsTUFHTyxJQUFJbnRELENBQUMsS0FBSyxFQUFWLEVBQWM7Z0JBQ25Cb0UsT0FBTyxDQUFDNm9HLGtCQUFSLEdBQTZCam5GLFVBQVUsQ0FBQ2tqRixJQUFELEVBQU8sR0FBUCxDQUF2QztlQURLLE1BRUE7Z0JBQ0w5a0csT0FBTyxDQUFDNHVFLGlCQUFSLEdBQTRCLElBQTVCO2dCQUNBNXVFLE9BQU8sQ0FBQ3U4RCxLQUFSLENBQWNoOEIsS0FBZDs7YUFSSjs7WUFXQXZnQyxPQUFPLENBQUM2b0csa0JBQVIsR0FBNkJqbkYsVUFBVSxDQUFDa2pGLElBQUQsRUFBTyxHQUFQLENBQXZDOzs7O1FBSUosSUFBSXJsRCxFQUFFLElBQUlDLFVBQVUsSUFBSSxDQUF4QixFQUEyQjtVQUFFb3BELG9CQUFvQjs7O1FBQ2pELElBQUlqb0QsaUJBQUosRUFBdUI7VUFDckJpSixNQUFNLENBQUNsMEQsQ0FBRCxDQUFOOztVQUNBLElBQUlvekcsT0FBTyxHQUFHLFNBQVZBLE9BQVUsR0FBWTtZQUN4QnRnRCxHQUFHLENBQUN4ekQsTUFBRCxFQUFTLFNBQVQsRUFBb0I4ekcsT0FBcEIsQ0FBSDtZQUNBcG5GLFVBQVUsQ0FBQ2duRixNQUFELEVBQVMsRUFBVCxDQUFWO1dBRkY7O1VBSUF2Z0QsRUFBRSxDQUFDbnpELE1BQUQsRUFBUyxTQUFULEVBQW9COHpHLE9BQXBCLENBQUY7U0FORixNQU9PO1VBQ0xwbkYsVUFBVSxDQUFDZ25GLE1BQUQsRUFBUyxFQUFULENBQVY7O09BN0VKOztNQWlGQTFCLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCMGhHLGVBQXhCLEdBQTBDLFVBQVVsa0csR0FBVixFQUFlO1FBQ3ZELElBQUksQ0FBQ0EsR0FBTCxFQUFVO1VBQUUsS0FBS3lwQyxLQUFMOzs7UUFDWixLQUFLK21FLFFBQUwsQ0FBYzJCLFFBQWQsR0FBeUJueUcsR0FBRyxJQUFJLFVBQWhDO1FBQ0EsS0FBS3d3RyxRQUFMLENBQWN0d0MsUUFBZCxHQUF5QixDQUFDLENBQUNsZ0UsR0FBM0I7T0FIRjs7TUFNQW93RyxhQUFhLENBQUM1dEcsU0FBZCxDQUF3Qm1qRSxhQUF4QixHQUF3QyxZQUFZLEVBQXBEOztNQUVBeXFDLGFBQWEsQ0FBQzV0RyxTQUFkLENBQXdCa2pFLHFCQUF4QixHQUFnRCxLQUFoRDs7TUFFQSxTQUFTMHNDLFlBQVQsQ0FBc0I1QixRQUF0QixFQUFnQ3hqRSxPQUFoQyxFQUF5QztRQUN2Q0EsT0FBTyxHQUFHQSxPQUFPLEdBQUc4ZSxPQUFPLENBQUM5ZSxPQUFELENBQVYsR0FBc0IsRUFBdkM7UUFDQUEsT0FBTyxDQUFDdHNDLEtBQVIsR0FBZ0I4dkcsUUFBUSxDQUFDOXZHLEtBQXpCOztRQUNBLElBQUksQ0FBQ3NzQyxPQUFPLENBQUNxbEUsUUFBVCxJQUFxQjdCLFFBQVEsQ0FBQ3AwQixRQUFsQyxFQUNFO1VBQUVwdkMsT0FBTyxDQUFDcWxFLFFBQVIsR0FBbUI3QixRQUFRLENBQUNwMEIsUUFBNUI7OztRQUNKLElBQUksQ0FBQ3B2QyxPQUFPLENBQUNzbEUsV0FBVCxJQUF3QjlCLFFBQVEsQ0FBQzhCLFdBQXJDLEVBQ0U7VUFBRXRsRSxPQUFPLENBQUNzbEUsV0FBUixHQUFzQjlCLFFBQVEsQ0FBQzhCLFdBQS9CO1NBTm1DOzs7O1FBU3ZDLElBQUl0bEUsT0FBTyxDQUFDZzRELFNBQVIsSUFBcUIsSUFBekIsRUFBK0I7VUFDN0IsSUFBSXZ0QixRQUFRLEdBQUdyc0IsU0FBUyxFQUF4QjtVQUNBcGUsT0FBTyxDQUFDZzRELFNBQVIsR0FBb0J2dEIsUUFBUSxJQUFJKzRCLFFBQVosSUFDbEJBLFFBQVEsQ0FBQ2xoRSxZQUFULENBQXNCLFdBQXRCLEtBQXNDLElBQXRDLElBQThDbW9DLFFBQVEsSUFBSWg0RSxRQUFRLENBQUNvOUMsSUFEckU7OztRQUlGLFNBQVMyZCxJQUFULEdBQWdCO1VBQUNnMkMsUUFBUSxDQUFDOXZHLEtBQVQsR0FBaUJ1eEQsRUFBRSxDQUFDOC9CLFFBQUgsRUFBakI7OztRQUVqQixJQUFJd2dCLFVBQUo7O1FBQ0EsSUFBSS9CLFFBQVEsQ0FBQ2dDLElBQWIsRUFBbUI7VUFDakJqaEQsRUFBRSxDQUFDaS9DLFFBQVEsQ0FBQ2dDLElBQVYsRUFBZ0IsUUFBaEIsRUFBMEJoNEMsSUFBMUIsQ0FBRixDQURpQjs7VUFHakIsSUFBSSxDQUFDeHRCLE9BQU8sQ0FBQ3lsRSxzQkFBYixFQUFxQztZQUNuQyxJQUFJRCxJQUFJLEdBQUdoQyxRQUFRLENBQUNnQyxJQUFwQjtZQUNBRCxVQUFVLEdBQUdDLElBQUksQ0FBQ0UsTUFBbEI7O1lBQ0EsSUFBSTtjQUNGLElBQUlDLGFBQWEsR0FBR0gsSUFBSSxDQUFDRSxNQUFMLEdBQWMsWUFBWTtnQkFDNUNsNEMsSUFBSTtnQkFDSmc0QyxJQUFJLENBQUNFLE1BQUwsR0FBY0gsVUFBZDtnQkFDQUMsSUFBSSxDQUFDRSxNQUFMO2dCQUNBRixJQUFJLENBQUNFLE1BQUwsR0FBY0MsYUFBZDtlQUpGO2FBREYsQ0FPRSxPQUFNN3pHLENBQU4sRUFBUzs7OztRQUlma3VDLE9BQU8sQ0FBQ2s0RCxVQUFSLEdBQXFCLFVBQVVqekMsRUFBVixFQUFjO1VBQ2pDQSxFQUFFLENBQUN1SSxJQUFILEdBQVVBLElBQVY7O1VBQ0F2SSxFQUFFLENBQUMyZ0QsV0FBSCxHQUFpQixZQUFZO1lBQUUsT0FBT3BDLFFBQVA7V0FBL0I7O1VBQ0F2K0MsRUFBRSxDQUFDNGdELFVBQUgsR0FBZ0IsWUFBWTtZQUMxQjVnRCxFQUFFLENBQUM0Z0QsVUFBSCxHQUFnQm5zRyxLQUFoQixDQUQwQjs7WUFFMUI4ekQsSUFBSTtZQUNKZzJDLFFBQVEsQ0FBQ3QvRCxVQUFULENBQW9Ccm1CLFdBQXBCLENBQWdDb25DLEVBQUUsQ0FBQ2lqQixpQkFBSCxFQUFoQztZQUNBczdCLFFBQVEsQ0FBQ3ZuRyxLQUFULENBQWVDLE9BQWYsR0FBeUIsRUFBekI7O1lBQ0EsSUFBSXNuRyxRQUFRLENBQUNnQyxJQUFiLEVBQW1CO2NBQ2pCNWdELEdBQUcsQ0FBQzQrQyxRQUFRLENBQUNnQyxJQUFWLEVBQWdCLFFBQWhCLEVBQTBCaDRDLElBQTFCLENBQUg7O2NBQ0EsSUFBSSxDQUFDeHRCLE9BQU8sQ0FBQ3lsRSxzQkFBVCxJQUFtQyxPQUFPakMsUUFBUSxDQUFDZ0MsSUFBVCxDQUFjRSxNQUFyQixJQUErQixVQUF0RSxFQUNFO2dCQUFFbEMsUUFBUSxDQUFDZ0MsSUFBVCxDQUFjRSxNQUFkLEdBQXVCSCxVQUF2Qjs7O1dBUlI7U0FIRjs7UUFnQkEvQixRQUFRLENBQUN2bkcsS0FBVCxDQUFlQyxPQUFmLEdBQXlCLE1BQXpCO1FBQ0EsSUFBSStvRCxFQUFFLEdBQUdnakMsVUFBVSxDQUFDLFVBQVVocEUsSUFBVixFQUFnQjtVQUFFLE9BQU91a0YsUUFBUSxDQUFDdC9ELFVBQVQsQ0FBb0IzRCxZQUFwQixDQUFpQ3RoQixJQUFqQyxFQUF1Q3VrRixRQUFRLENBQUM5K0QsV0FBaEQsQ0FBUDtTQUFuQixFQUNqQjFFLE9BRGlCLENBQW5CO1FBRUEsT0FBT2lsQixFQUFQOzs7TUFHRixTQUFTNmdELGNBQVQsQ0FBd0I3ZCxVQUF4QixFQUFvQztRQUNsQ0EsVUFBVSxDQUFDcmpDLEdBQVgsR0FBaUJBLEdBQWpCO1FBQ0FxakMsVUFBVSxDQUFDMWpDLEVBQVgsR0FBZ0JBLEVBQWhCO1FBQ0EwakMsVUFBVSxDQUFDaFEsZ0JBQVgsR0FBOEJBLGdCQUE5QjtRQUNBZ1EsVUFBVSxDQUFDckQsR0FBWCxHQUFpQkEsR0FBakI7UUFDQXFELFVBQVUsQ0FBQ3ZHLFVBQVgsR0FBd0J4NkIsY0FBeEI7UUFDQStnQyxVQUFVLENBQUNocEMsV0FBWCxHQUF5QkEsV0FBekI7UUFDQWdwQyxVQUFVLENBQUMvbkMsVUFBWCxHQUF3QkEsVUFBeEI7UUFDQStuQyxVQUFVLENBQUNobkMsVUFBWCxHQUF3QkYsZUFBeEI7UUFDQWtuQyxVQUFVLENBQUNyb0MsSUFBWCxHQUFrQkEsSUFBbEI7UUFDQXFvQyxVQUFVLENBQUNuakMsTUFBWCxHQUFvQkEsTUFBcEI7UUFDQW1qQyxVQUFVLENBQUNweUIsSUFBWCxHQUFrQkEsSUFBbEI7UUFDQW95QixVQUFVLENBQUN0TyxTQUFYLEdBQXVCQSxTQUF2QjtRQUNBc08sVUFBVSxDQUFDL1csY0FBWCxHQUE0QkEsY0FBNUI7UUFDQStXLFVBQVUsQ0FBQzM3QixHQUFYLEdBQWlCQSxHQUFqQjtRQUNBMjdCLFVBQVUsQ0FBQzhkLE1BQVgsR0FBb0J4NUMsR0FBcEI7UUFDQTA3QixVQUFVLENBQUNoZ0MsS0FBWCxHQUFtQkEsS0FBbkI7UUFDQWdnQyxVQUFVLENBQUMvL0IsU0FBWCxHQUF1QkEsU0FBdkI7UUFDQSsvQixVQUFVLENBQUN6L0IsV0FBWCxHQUF5QkEsV0FBekI7UUFDQXkvQixVQUFVLENBQUN4L0IsT0FBWCxHQUFxQkEsT0FBckI7UUFDQXcvQixVQUFVLENBQUNyL0IsY0FBWCxHQUE0QkEsY0FBNUI7UUFDQXEvQixVQUFVLENBQUNoL0IsVUFBWCxHQUF3QkEsVUFBeEI7UUFDQWcvQixVQUFVLENBQUMvK0IsU0FBWCxHQUF1QkEsU0FBdkI7UUFDQSsrQixVQUFVLENBQUM1K0IsVUFBWCxHQUF3QkEsVUFBeEI7UUFDQTQrQixVQUFVLENBQUM3K0IsU0FBWCxHQUF1QkEsU0FBdkI7UUFDQTYrQixVQUFVLENBQUN3RixRQUFYLEdBQXNCQSxRQUF0QjtRQUNBeEYsVUFBVSxDQUFDNkMsTUFBWCxHQUFvQkEsTUFBcEI7UUFDQTdDLFVBQVUsQ0FBQ29FLE9BQVgsR0FBcUJBLE9BQXJCO1FBQ0FwRSxVQUFVLENBQUM2RCxhQUFYLEdBQTJCQSxhQUEzQjtRQUNBN0QsVUFBVSxDQUFDMEQsU0FBWCxHQUF1QkEsU0FBdkI7UUFDQTFELFVBQVUsQ0FBQ3VELGVBQVgsR0FBNkJBLGVBQTdCO1FBQ0F2RCxVQUFVLENBQUN6K0IsWUFBWCxHQUEwQkEsWUFBMUI7UUFDQXkrQixVQUFVLENBQUNqRSxnQkFBWCxHQUE4QkEsZ0JBQTlCO1FBQ0FpRSxVQUFVLENBQUM1RSxVQUFYLEdBQXdCQSxVQUF4QjtRQUNBNEUsVUFBVSxDQUFDckYsVUFBWCxHQUF3QkEsVUFBeEI7UUFDQXFGLFVBQVUsQ0FBQ3JpQyxnQkFBWCxHQUE4QkEsZ0JBQTlCO1FBQ0FxaUMsVUFBVSxDQUFDbmlDLGlCQUFYLEdBQStCQSxpQkFBL0I7UUFDQW1pQyxVQUFVLENBQUNqaUMsTUFBWCxHQUFvQkEsTUFBcEI7UUFDQWlpQyxVQUFVLENBQUMzcEMsUUFBWCxHQUFzQkEsUUFBdEI7UUFDQTJwQyxVQUFVLENBQUMvcEMsUUFBWCxHQUFzQkEsUUFBdEI7UUFDQStwQyxVQUFVLENBQUMvcUMsT0FBWCxHQUFxQkEsT0FBckI7UUFDQStxQyxVQUFVLENBQUM0QyxRQUFYLEdBQXNCQSxRQUF0QjtPQS9pVGlCOzs7TUFvalRuQnVMLGFBQWEsQ0FBQ25PLFVBQUQsQ0FBYjtNQUVBb1QsZ0JBQWdCLENBQUNwVCxVQUFELENBQWhCLENBdGpUbUI7O01BeWpUbkIsSUFBSStkLFlBQVksR0FBRyxnREFBZ0RoeEcsS0FBaEQsQ0FBc0QsR0FBdEQsQ0FBbkI7O01BQ0EsS0FBSyxJQUFJZ3FELElBQVQsSUFBaUI0bEMsR0FBRyxDQUFDcHZGLFNBQXJCLEVBQWdDO1FBQUUsSUFBSW92RixHQUFHLENBQUNwdkYsU0FBSixDQUFjL0QsY0FBZCxDQUE2QnV0RCxJQUE3QixLQUFzQ3J3QyxPQUFPLENBQUNxM0YsWUFBRCxFQUFlaG5ELElBQWYsQ0FBUCxHQUE4QixDQUF4RSxFQUNoQztVQUFFaXBDLFVBQVUsQ0FBQ3p5RixTQUFYLENBQXFCd3BELElBQXJCLElBQThCLFVBQVN0c0MsTUFBVCxFQUFpQjtZQUMvQyxPQUFPLFlBQVc7Y0FBQyxPQUFPQSxNQUFNLENBQUM1YyxLQUFQLENBQWEsS0FBS3ExRCxHQUFsQixFQUF1QnAxRCxTQUF2QixDQUFQO2FBQW5CO1dBRDZCLENBRTVCNnVGLEdBQUcsQ0FBQ3B2RixTQUFKLENBQWN3cEQsSUFBZCxDQUY0QixDQUE3Qjs7OztNQUlKMkcsVUFBVSxDQUFDaS9CLEdBQUQsQ0FBVjtNQUNBcUQsVUFBVSxDQUFDMlAsV0FBWCxHQUF5QjtRQUFDLFlBQVl3TCxhQUFiO1FBQTRCLG1CQUFtQnZFO09BQXhFLENBaGtUbUI7Ozs7TUFxa1RuQjVXLFVBQVUsQ0FBQzkvQixVQUFYLEdBQXdCLFVBQVNoeUQ7O1FBQW1CO1FBQ2xELElBQUksQ0FBQzh4RixVQUFVLENBQUNpTyxRQUFYLENBQW9CeGhHLElBQXJCLElBQTZCeUIsSUFBSSxJQUFJLE1BQXpDLEVBQWlEO1VBQUU4eEYsVUFBVSxDQUFDaU8sUUFBWCxDQUFvQnhoRyxJQUFwQixHQUEyQnlCLElBQTNCOzs7UUFDbkRneUQsVUFBVSxDQUFDcnlELEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJDLFNBQXZCO09BRkY7O01BS0FreUYsVUFBVSxDQUFDNS9CLFVBQVgsR0FBd0JBLFVBQXhCLENBMWtUbUI7O01BNmtUbkI0L0IsVUFBVSxDQUFDOS9CLFVBQVgsQ0FBc0IsTUFBdEIsRUFBOEIsWUFBWTtRQUFFLE9BQVE7VUFBQ3dILEtBQUssRUFBRSxlQUFVSixNQUFWLEVBQWtCO1lBQUUsT0FBT0EsTUFBTSxDQUFDcEYsU0FBUCxFQUFQOztTQUFwQztPQUE1QztNQUNBODlCLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLFlBQXRCLEVBQW9DLE1BQXBDLEVBOWtUbUI7O01Ba2xUbkI0L0IsVUFBVSxDQUFDZ2UsZUFBWCxHQUE2QixVQUFVOXZHLElBQVYsRUFBZ0IrdkcsSUFBaEIsRUFBc0I7UUFDakRqZSxVQUFVLENBQUN6eUYsU0FBWCxDQUFxQlcsSUFBckIsSUFBNkIrdkcsSUFBN0I7T0FERjs7TUFHQWplLFVBQVUsQ0FBQ2tlLGtCQUFYLEdBQWdDLFVBQVVod0csSUFBVixFQUFnQit2RyxJQUFoQixFQUFzQjtRQUNwRHRoQixHQUFHLENBQUNwdkYsU0FBSixDQUFjVyxJQUFkLElBQXNCK3ZHLElBQXRCO09BREY7O01BSUFqZSxVQUFVLENBQUNtZCxZQUFYLEdBQTBCQSxZQUExQjtNQUVBVSxjQUFjLENBQUM3ZCxVQUFELENBQWQ7TUFFQUEsVUFBVSxDQUFDNTFGLE9BQVgsR0FBcUIsUUFBckI7TUFFQSxPQUFPNDFGLFVBQVA7S0FubVRELENBQUQ7Ozs7OztJQ05BLENBQUMsVUFBU3NELEdBQVQsRUFBYztNQUNiLEFBQ0VBLEdBQUcsQ0FBQ3g1RixVQUFELENBQUgsQ0FERjtLQURGLEVBT0csVUFBU2syRixVQUFULEVBQXFCOztNQUd4QkEsVUFBVSxDQUFDOS9CLFVBQVgsQ0FBc0IsWUFBdEIsRUFBb0MsVUFBU2krQyxNQUFULEVBQWlCQyxZQUFqQixFQUErQjtRQUNqRSxJQUFJL00sVUFBVSxHQUFHOE0sTUFBTSxDQUFDOU0sVUFBeEI7UUFDQSxJQUFJZ04sZUFBZSxHQUFHRCxZQUFZLENBQUNDLGVBQW5DO1FBQ0EsSUFBSUMsVUFBVSxHQUFHRixZQUFZLENBQUNHLE1BQTlCO1FBQ0EsSUFBSUMsUUFBUSxHQUFHSixZQUFZLENBQUNLLElBQWIsSUFBcUJILFVBQXBDO1FBQ0EsSUFBSUksVUFBVSxHQUFHTixZQUFZLENBQUNNLFVBQWIsS0FBNEIsS0FBN0M7UUFDQSxJQUFJQyxJQUFJLEdBQUdQLFlBQVksQ0FBQ1EsVUFBeEI7UUFDQSxJQUFJQyxNQUFNLEdBQUdULFlBQVksQ0FBQ1UsY0FBYixJQUErQixrQkFBNUMsQ0FQaUU7O1FBV2pFLElBQUlDLFFBQVEsR0FBRyxZQUFVO1VBQ3ZCLFNBQVNDLEVBQVQsQ0FBWS93RyxJQUFaLEVBQWtCO1lBQUMsT0FBTztjQUFDQSxJQUFJLEVBQUVBLElBQVA7Y0FBYStGLEtBQUssRUFBRTthQUEzQjs7O1VBQ25CLElBQUkyRixDQUFDLEdBQUdxbEcsRUFBRSxDQUFDLFdBQUQsQ0FBVjtjQUF5QnJ3RyxDQUFDLEdBQUdxd0csRUFBRSxDQUFDLFdBQUQsQ0FBL0I7Y0FBOEM3aEcsQ0FBQyxHQUFHNmhHLEVBQUUsQ0FBQyxXQUFELENBQXBEO2NBQW1Fem9HLENBQUMsR0FBR3lvRyxFQUFFLENBQUMsV0FBRCxDQUF6RTtVQUNBLElBQUlDLFFBQVEsR0FBR0QsRUFBRSxDQUFDLFVBQUQsQ0FBakI7Y0FBK0JFLElBQUksR0FBRztZQUFDanhHLElBQUksRUFBRSxNQUFQO1lBQWUrRixLQUFLLEVBQUU7V0FBNUQ7VUFFQSxPQUFPO1lBQ0wsTUFBTWdyRyxFQUFFLENBQUMsSUFBRCxDQURIO1lBQ1csU0FBU3JsRyxDQURwQjtZQUN1QixRQUFRQSxDQUQvQjtZQUNrQyxRQUFRaEwsQ0FEMUM7WUFDNkMsTUFBTUEsQ0FEbkQ7WUFDc0QsT0FBT0EsQ0FEN0Q7WUFDZ0UsV0FBV0EsQ0FEM0U7WUFFTCxVQUFVNEgsQ0FGTDtZQUVRLFNBQVNBLENBRmpCO1lBRW9CLFlBQVlBLENBRmhDO1lBRW1DLE9BQU95b0csRUFBRSxDQUFDLEtBQUQsQ0FGNUM7WUFFcUQsVUFBVTdoRyxDQUYvRDtZQUVrRSxRQUFRQSxDQUYxRTtZQUU2RSxTQUFTQSxDQUZ0RjtZQUdMLFlBQVk2aEcsRUFBRSxDQUFDLFVBQUQsQ0FIVDtZQUd1QixPQUFPQSxFQUFFLENBQUMsS0FBRCxDQUhoQztZQUd5QyxTQUFTQSxFQUFFLENBQUMsS0FBRCxDQUhwRDtZQUc2RCxPQUFPQSxFQUFFLENBQUMsS0FBRCxDQUh0RTtZQUlMLFlBQVlBLEVBQUUsQ0FBQyxVQUFELENBSlQ7WUFJdUIsU0FBU0EsRUFBRSxDQUFDLE9BQUQsQ0FKbEM7WUFLTCxPQUFPQSxFQUFFLENBQUMsS0FBRCxDQUxKO1lBS2EsVUFBVUEsRUFBRSxDQUFDLFFBQUQsQ0FMekI7WUFLcUMsUUFBUUEsRUFBRSxDQUFDLE1BQUQsQ0FML0M7WUFLeUQsV0FBV0EsRUFBRSxDQUFDLFNBQUQsQ0FMdEU7WUFNTCxNQUFNQyxRQU5EO1lBTVcsVUFBVUEsUUFOckI7WUFNK0IsY0FBY0EsUUFON0M7WUFPTCxRQUFRQyxJQVBIO1lBT1MsU0FBU0EsSUFQbEI7WUFPd0IsUUFBUUEsSUFQaEM7WUFPc0MsYUFBYUEsSUFQbkQ7WUFPeUQsT0FBT0EsSUFQaEU7WUFPc0UsWUFBWUEsSUFQbEY7WUFRTCxRQUFRRixFQUFFLENBQUMsTUFBRCxDQVJMO1lBUWUsU0FBU0EsRUFBRSxDQUFDLE9BQUQsQ0FSMUI7WUFRcUMsU0FBU0EsRUFBRSxDQUFDLE1BQUQsQ0FSaEQ7WUFTTCxTQUFTN2hHLENBVEo7WUFTTyxVQUFVNmhHLEVBQUUsQ0FBQyxRQUFELENBVG5CO1lBUytCLFVBQVVBLEVBQUUsQ0FBQyxRQUFELENBVDNDO1lBU3VELFdBQVc3aEcsQ0FUbEU7WUFVTCxTQUFTQTtXQVZYO1NBTGEsRUFBZjs7UUFtQkEsSUFBSWdpRyxjQUFjLEdBQUcsbUJBQXJCO1FBQ0EsSUFBSUMsZUFBZSxHQUFHLHVGQUF0Qjs7UUFFQSxTQUFTQyxVQUFULENBQW9CLzNDLE1BQXBCLEVBQTRCO1VBQzFCLElBQUlnNEMsT0FBTyxHQUFHLEtBQWQ7Y0FBcUJ4N0YsSUFBckI7Y0FBMkJ5N0YsS0FBSyxHQUFHLEtBQW5DOztVQUNBLE9BQU8sQ0FBQ3o3RixJQUFJLEdBQUd3akQsTUFBTSxDQUFDeGpELElBQVAsRUFBUixLQUEwQixJQUFqQyxFQUF1QztZQUNyQyxJQUFJLENBQUN3N0YsT0FBTCxFQUFjO2NBQ1osSUFBSXg3RixJQUFJLElBQUksR0FBUixJQUFlLENBQUN5N0YsS0FBcEIsRUFBMkI7Y0FDM0IsSUFBSXo3RixJQUFJLElBQUksR0FBWixFQUFpQnk3RixLQUFLLEdBQUcsSUFBUixDQUFqQixLQUNLLElBQUlBLEtBQUssSUFBSXo3RixJQUFJLElBQUksR0FBckIsRUFBMEJ5N0YsS0FBSyxHQUFHLEtBQVI7OztZQUVqQ0QsT0FBTyxHQUFHLENBQUNBLE9BQUQsSUFBWXg3RixJQUFJLElBQUksSUFBOUI7O1NBekM2RDs7OztRQStDakUsSUFBSTdWLElBQUosRUFBVXVyQyxPQUFWOztRQUNBLFNBQVNqd0IsR0FBVCxDQUFhaTJGLEVBQWIsRUFBaUJ4ckcsS0FBakIsRUFBd0J5ckcsSUFBeEIsRUFBOEI7VUFDNUJ4eEcsSUFBSSxHQUFHdXhHLEVBQVA7VUFBV2htRSxPQUFPLEdBQUdpbUUsSUFBVjtVQUNYLE9BQU96ckcsS0FBUDs7O1FBRUYsU0FBUzByRyxTQUFULENBQW1CcDRDLE1BQW5CLEVBQTJCcDBCLEtBQTNCLEVBQWtDO1VBQ2hDLElBQUk1Z0IsRUFBRSxHQUFHZzFDLE1BQU0sQ0FBQ3hqRCxJQUFQLEVBQVQ7O1VBQ0EsSUFBSXdPLEVBQUUsSUFBSSxHQUFOLElBQWFBLEVBQUUsSUFBSSxHQUF2QixFQUE0QjtZQUMxQjRnQixLQUFLLENBQUN5c0UsUUFBTixHQUFpQkMsV0FBVyxDQUFDdHRGLEVBQUQsQ0FBNUI7WUFDQSxPQUFPNGdCLEtBQUssQ0FBQ3lzRSxRQUFOLENBQWVyNEMsTUFBZixFQUF1QnAwQixLQUF2QixDQUFQO1dBRkYsTUFHTyxJQUFJNWdCLEVBQUUsSUFBSSxHQUFOLElBQWFnMUMsTUFBTSxDQUFDN3JELEtBQVAsQ0FBYSxnQ0FBYixDQUFqQixFQUFpRTtZQUN0RSxPQUFPOE4sR0FBRyxDQUFDLFFBQUQsRUFBVyxRQUFYLENBQVY7V0FESyxNQUVBLElBQUkrSSxFQUFFLElBQUksR0FBTixJQUFhZzFDLE1BQU0sQ0FBQzdyRCxLQUFQLENBQWEsSUFBYixDQUFqQixFQUFxQztZQUMxQyxPQUFPOE4sR0FBRyxDQUFDLFFBQUQsRUFBVyxNQUFYLENBQVY7V0FESyxNQUVBLElBQUkscUJBQXFCbFAsSUFBckIsQ0FBMEJpWSxFQUExQixDQUFKLEVBQW1DO1lBQ3hDLE9BQU8vSSxHQUFHLENBQUMrSSxFQUFELENBQVY7V0FESyxNQUVBLElBQUlBLEVBQUUsSUFBSSxHQUFOLElBQWFnMUMsTUFBTSxDQUFDdkYsR0FBUCxDQUFXLEdBQVgsQ0FBakIsRUFBa0M7WUFDdkMsT0FBT3g0QyxHQUFHLENBQUMsSUFBRCxFQUFPLFVBQVAsQ0FBVjtXQURLLE1BRUEsSUFBSStJLEVBQUUsSUFBSSxHQUFOLElBQWFnMUMsTUFBTSxDQUFDN3JELEtBQVAsQ0FBYSx1Q0FBYixDQUFqQixFQUF3RTtZQUM3RSxPQUFPOE4sR0FBRyxDQUFDLFFBQUQsRUFBVyxRQUFYLENBQVY7V0FESyxNQUVBLElBQUksS0FBS2xQLElBQUwsQ0FBVWlZLEVBQVYsQ0FBSixFQUFtQjtZQUN4QmcxQyxNQUFNLENBQUM3ckQsS0FBUCxDQUFhLGtEQUFiO1lBQ0EsT0FBTzhOLEdBQUcsQ0FBQyxRQUFELEVBQVcsUUFBWCxDQUFWO1dBRkssTUFHQSxJQUFJK0ksRUFBRSxJQUFJLEdBQVYsRUFBZTtZQUNwQixJQUFJZzFDLE1BQU0sQ0FBQ3ZGLEdBQVAsQ0FBVyxHQUFYLENBQUosRUFBcUI7Y0FDbkI3dUIsS0FBSyxDQUFDeXNFLFFBQU4sR0FBaUJFLFlBQWpCO2NBQ0EsT0FBT0EsWUFBWSxDQUFDdjRDLE1BQUQsRUFBU3AwQixLQUFULENBQW5CO2FBRkYsTUFHTyxJQUFJbzBCLE1BQU0sQ0FBQ3ZGLEdBQVAsQ0FBVyxHQUFYLENBQUosRUFBcUI7Y0FDMUJ1RixNQUFNLENBQUNwRixTQUFQO2NBQ0EsT0FBTzM0QyxHQUFHLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FBVjthQUZLLE1BR0EsSUFBSXUyRixpQkFBaUIsQ0FBQ3g0QyxNQUFELEVBQVNwMEIsS0FBVCxFQUFnQixDQUFoQixDQUFyQixFQUF5QztjQUM5Q21zRSxVQUFVLENBQUMvM0MsTUFBRCxDQUFWO2NBQ0FBLE1BQU0sQ0FBQzdyRCxLQUFQLENBQWEsbUNBQWI7Y0FDQSxPQUFPOE4sR0FBRyxDQUFDLFFBQUQsRUFBVyxVQUFYLENBQVY7YUFISyxNQUlBO2NBQ0wrOUMsTUFBTSxDQUFDdkYsR0FBUCxDQUFXLEdBQVg7Y0FDQSxPQUFPeDRDLEdBQUcsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5Qis5QyxNQUFNLENBQUNwUyxPQUFQLEVBQXpCLENBQVY7O1dBYkcsTUFlQSxJQUFJNWlDLEVBQUUsSUFBSSxHQUFWLEVBQWU7WUFDcEI0Z0IsS0FBSyxDQUFDeXNFLFFBQU4sR0FBaUJJLFVBQWpCO1lBQ0EsT0FBT0EsVUFBVSxDQUFDejRDLE1BQUQsRUFBU3AwQixLQUFULENBQWpCO1dBRkssTUFHQSxJQUFJNWdCLEVBQUUsSUFBSSxHQUFOLElBQWFnMUMsTUFBTSxDQUFDeEYsSUFBUCxNQUFpQixHQUFsQyxFQUF1QztZQUM1Q3dGLE1BQU0sQ0FBQ3BGLFNBQVA7WUFDQSxPQUFPMzRDLEdBQUcsQ0FBQyxNQUFELEVBQVMsTUFBVCxDQUFWO1dBRkssTUFHQSxJQUFJK0ksRUFBRSxJQUFJLEdBQU4sSUFBYWcxQyxNQUFNLENBQUN0RixRQUFQLENBQWdCNjhDLE1BQWhCLENBQWpCLEVBQTBDO1lBQy9DLE9BQU90MUYsR0FBRyxDQUFDLFVBQUQsRUFBYSxVQUFiLENBQVY7V0FESyxNQUVBLElBQUkrSSxFQUFFLElBQUksR0FBTixJQUFhZzFDLE1BQU0sQ0FBQzdyRCxLQUFQLENBQWEsS0FBYixDQUFiLElBQ0M2VyxFQUFFLElBQUksR0FBTixJQUFhZzFDLE1BQU0sQ0FBQzdyRCxLQUFQLENBQWEsSUFBYixDQUFiLElBQW1DLENBQUMsS0FBS3BCLElBQUwsQ0FBVWl0RCxNQUFNLENBQUNockQsTUFBUCxDQUFjcEwsS0FBZCxDQUFvQixDQUFwQixFQUF1Qm8yRCxNQUFNLENBQUN2OEMsS0FBOUIsQ0FBVixDQUR6QyxFQUMyRjtZQUNoR3U4QyxNQUFNLENBQUNwRixTQUFQO1lBQ0EsT0FBTzM0QyxHQUFHLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FBVjtXQUhLLE1BSUEsSUFBSTQxRixjQUFjLENBQUM5a0csSUFBZixDQUFvQmlZLEVBQXBCLENBQUosRUFBNkI7WUFDbEMsSUFBSUEsRUFBRSxJQUFJLEdBQU4sSUFBYSxDQUFDNGdCLEtBQUssQ0FBQzhzRSxPQUFwQixJQUErQjlzRSxLQUFLLENBQUM4c0UsT0FBTixDQUFjL3hHLElBQWQsSUFBc0IsR0FBekQsRUFBOEQ7Y0FDNUQsSUFBSXE1RCxNQUFNLENBQUN2RixHQUFQLENBQVcsR0FBWCxDQUFKLEVBQXFCO2dCQUNuQixJQUFJenZDLEVBQUUsSUFBSSxHQUFOLElBQWFBLEVBQUUsSUFBSSxHQUF2QixFQUE0QmcxQyxNQUFNLENBQUN2RixHQUFQLENBQVcsR0FBWDtlQUQ5QixNQUVPLElBQUksY0FBYzFuRCxJQUFkLENBQW1CaVksRUFBbkIsQ0FBSixFQUE0QjtnQkFDakNnMUMsTUFBTSxDQUFDdkYsR0FBUCxDQUFXenZDLEVBQVg7Z0JBQ0EsSUFBSUEsRUFBRSxJQUFJLEdBQVYsRUFBZWcxQyxNQUFNLENBQUN2RixHQUFQLENBQVd6dkMsRUFBWDs7OztZQUduQixJQUFJQSxFQUFFLElBQUksR0FBTixJQUFhZzFDLE1BQU0sQ0FBQ3ZGLEdBQVAsQ0FBVyxHQUFYLENBQWpCLEVBQWtDLE9BQU94NEMsR0FBRyxDQUFDLEdBQUQsQ0FBVjtZQUNsQyxPQUFPQSxHQUFHLENBQUMsVUFBRCxFQUFhLFVBQWIsRUFBeUIrOUMsTUFBTSxDQUFDcFMsT0FBUCxFQUF6QixDQUFWO1dBVkssTUFXQSxJQUFJMnBELE1BQU0sQ0FBQ3hrRyxJQUFQLENBQVlpWSxFQUFaLENBQUosRUFBcUI7WUFDMUJnMUMsTUFBTSxDQUFDdEYsUUFBUCxDQUFnQjY4QyxNQUFoQjtZQUNBLElBQUl6TyxJQUFJLEdBQUc5b0MsTUFBTSxDQUFDcFMsT0FBUCxFQUFYOztZQUNBLElBQUloaUIsS0FBSyxDQUFDK3NFLFFBQU4sSUFBa0IsR0FBdEIsRUFBMkI7Y0FDekIsSUFBSWxCLFFBQVEsQ0FBQzV0RyxvQkFBVCxDQUE4QmkvRixJQUE5QixDQUFKLEVBQXlDO2dCQUN2QyxJQUFJNE8sRUFBRSxHQUFHRCxRQUFRLENBQUMzTyxJQUFELENBQWpCO2dCQUNBLE9BQU83bUYsR0FBRyxDQUFDeTFGLEVBQUUsQ0FBQy93RyxJQUFKLEVBQVUrd0csRUFBRSxDQUFDaHJHLEtBQWIsRUFBb0JvOEYsSUFBcEIsQ0FBVjs7O2NBRUYsSUFBSUEsSUFBSSxJQUFJLE9BQVIsSUFBbUI5b0MsTUFBTSxDQUFDN3JELEtBQVAsQ0FBYSwwQ0FBYixFQUF5RCxLQUF6RCxDQUF2QixFQUNFLE9BQU84TixHQUFHLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUI2bUYsSUFBckIsQ0FBVjs7O1lBRUosT0FBTzdtRixHQUFHLENBQUMsVUFBRCxFQUFhLFVBQWIsRUFBeUI2bUYsSUFBekIsQ0FBVjs7OztRQUlKLFNBQVN3UCxXQUFULENBQXFCTSxLQUFyQixFQUE0QjtVQUMxQixPQUFPLFVBQVM1NEMsTUFBVCxFQUFpQnAwQixLQUFqQixFQUF3QjtZQUM3QixJQUFJb3NFLE9BQU8sR0FBRyxLQUFkO2dCQUFxQng3RixJQUFyQjs7WUFDQSxJQUFJdzZGLFVBQVUsSUFBSWgzQyxNQUFNLENBQUN4RixJQUFQLE1BQWlCLEdBQS9CLElBQXNDd0YsTUFBTSxDQUFDN3JELEtBQVAsQ0FBYTJqRyxlQUFiLENBQTFDLEVBQXdFO2NBQ3RFbHNFLEtBQUssQ0FBQ3lzRSxRQUFOLEdBQWlCRCxTQUFqQjtjQUNBLE9BQU9uMkYsR0FBRyxDQUFDLGdCQUFELEVBQW1CLE1BQW5CLENBQVY7OztZQUVGLE9BQU8sQ0FBQ3pGLElBQUksR0FBR3dqRCxNQUFNLENBQUN4akQsSUFBUCxFQUFSLEtBQTBCLElBQWpDLEVBQXVDO2NBQ3JDLElBQUlBLElBQUksSUFBSW84RixLQUFSLElBQWlCLENBQUNaLE9BQXRCLEVBQStCO2NBQy9CQSxPQUFPLEdBQUcsQ0FBQ0EsT0FBRCxJQUFZeDdGLElBQUksSUFBSSxJQUE5Qjs7O1lBRUYsSUFBSSxDQUFDdzdGLE9BQUwsRUFBY3BzRSxLQUFLLENBQUN5c0UsUUFBTixHQUFpQkQsU0FBakI7WUFDZCxPQUFPbjJGLEdBQUcsQ0FBQyxRQUFELEVBQVcsUUFBWCxDQUFWO1dBWEY7OztRQWVGLFNBQVNzMkYsWUFBVCxDQUFzQnY0QyxNQUF0QixFQUE4QnAwQixLQUE5QixFQUFxQztVQUNuQyxJQUFJaXRFLFFBQVEsR0FBRyxLQUFmO2NBQXNCN3RGLEVBQXRCOztVQUNBLE9BQU9BLEVBQUUsR0FBR2cxQyxNQUFNLENBQUN4akQsSUFBUCxFQUFaLEVBQTJCO1lBQ3pCLElBQUl3TyxFQUFFLElBQUksR0FBTixJQUFhNnRGLFFBQWpCLEVBQTJCO2NBQ3pCanRFLEtBQUssQ0FBQ3lzRSxRQUFOLEdBQWlCRCxTQUFqQjtjQUNBOzs7WUFFRlMsUUFBUSxHQUFJN3RGLEVBQUUsSUFBSSxHQUFsQjs7O1VBRUYsT0FBTy9JLEdBQUcsQ0FBQyxTQUFELEVBQVksU0FBWixDQUFWOzs7UUFHRixTQUFTdzJGLFVBQVQsQ0FBb0J6NEMsTUFBcEIsRUFBNEJwMEIsS0FBNUIsRUFBbUM7VUFDakMsSUFBSW9zRSxPQUFPLEdBQUcsS0FBZDtjQUFxQng3RixJQUFyQjs7VUFDQSxPQUFPLENBQUNBLElBQUksR0FBR3dqRCxNQUFNLENBQUN4akQsSUFBUCxFQUFSLEtBQTBCLElBQWpDLEVBQXVDO1lBQ3JDLElBQUksQ0FBQ3c3RixPQUFELEtBQWF4N0YsSUFBSSxJQUFJLEdBQVIsSUFBZUEsSUFBSSxJQUFJLEdBQVIsSUFBZXdqRCxNQUFNLENBQUN2RixHQUFQLENBQVcsR0FBWCxDQUEzQyxDQUFKLEVBQWlFO2NBQy9EN3VCLEtBQUssQ0FBQ3lzRSxRQUFOLEdBQWlCRCxTQUFqQjtjQUNBOzs7WUFFRkosT0FBTyxHQUFHLENBQUNBLE9BQUQsSUFBWXg3RixJQUFJLElBQUksSUFBOUI7OztVQUVGLE9BQU95RixHQUFHLENBQUMsT0FBRCxFQUFVLFVBQVYsRUFBc0IrOUMsTUFBTSxDQUFDcFMsT0FBUCxFQUF0QixDQUFWOzs7UUFHRixJQUFJa3JELFFBQVEsR0FBRyxRQUFmLENBbktpRTs7Ozs7Ozs7UUEyS2pFLFNBQVNDLFlBQVQsQ0FBc0IvNEMsTUFBdEIsRUFBOEJwMEIsS0FBOUIsRUFBcUM7VUFDbkMsSUFBSUEsS0FBSyxDQUFDb3RFLFVBQVYsRUFBc0JwdEUsS0FBSyxDQUFDb3RFLFVBQU4sR0FBbUIsSUFBbkI7VUFDdEIsSUFBSTcwRCxLQUFLLEdBQUc2YixNQUFNLENBQUNockQsTUFBUCxDQUFjb0ssT0FBZCxDQUFzQixJQUF0QixFQUE0QjRnRCxNQUFNLENBQUN2OEMsS0FBbkMsQ0FBWjtVQUNBLElBQUkwZ0MsS0FBSyxHQUFHLENBQVosRUFBZTs7VUFFZixJQUFJa3pELElBQUosRUFBVTs7WUFDUixJQUFJLytGLENBQUMsR0FBRyw2Q0FBNkNoVyxJQUE3QyxDQUFrRDA5RCxNQUFNLENBQUNockQsTUFBUCxDQUFjcEwsS0FBZCxDQUFvQm8yRCxNQUFNLENBQUN2OEMsS0FBM0IsRUFBa0MwZ0MsS0FBbEMsQ0FBbEQsQ0FBUjtZQUNBLElBQUk3ckMsQ0FBSixFQUFPNnJDLEtBQUssR0FBRzdyQyxDQUFDLENBQUMvTixLQUFWOzs7VUFHVCxJQUFJazZCLEtBQUssR0FBRyxDQUFaO2NBQWV3MEUsWUFBWSxHQUFHLEtBQTlCOztVQUNBLEtBQUssSUFBSTU4RixHQUFHLEdBQUc4bkMsS0FBSyxHQUFHLENBQXZCLEVBQTBCOW5DLEdBQUcsSUFBSSxDQUFqQyxFQUFvQyxFQUFFQSxHQUF0QyxFQUEyQztZQUN6QyxJQUFJMk8sRUFBRSxHQUFHZzFDLE1BQU0sQ0FBQ2hyRCxNQUFQLENBQWN0TCxNQUFkLENBQXFCMlMsR0FBckIsQ0FBVDtZQUNBLElBQUk2OEYsT0FBTyxHQUFHSixRQUFRLENBQUMxNUYsT0FBVCxDQUFpQjRMLEVBQWpCLENBQWQ7O1lBQ0EsSUFBSWt1RixPQUFPLElBQUksQ0FBWCxJQUFnQkEsT0FBTyxHQUFHLENBQTlCLEVBQWlDO2NBQy9CLElBQUksQ0FBQ3owRSxLQUFMLEVBQVk7Z0JBQUUsRUFBRXBvQixHQUFGO2dCQUFPOzs7Y0FDckIsSUFBSSxFQUFFb29CLEtBQUYsSUFBVyxDQUFmLEVBQWtCO2dCQUFFLElBQUl6WixFQUFFLElBQUksR0FBVixFQUFlaXVGLFlBQVksR0FBRyxJQUFmO2dCQUFxQjs7YUFGMUQsTUFHTyxJQUFJQyxPQUFPLElBQUksQ0FBWCxJQUFnQkEsT0FBTyxHQUFHLENBQTlCLEVBQWlDO2NBQ3RDLEVBQUV6MEUsS0FBRjthQURLLE1BRUEsSUFBSTh5RSxNQUFNLENBQUN4a0csSUFBUCxDQUFZaVksRUFBWixDQUFKLEVBQXFCO2NBQzFCaXVGLFlBQVksR0FBRyxJQUFmO2FBREssTUFFQSxJQUFJLFVBQVVsbUcsSUFBVixDQUFlaVksRUFBZixDQUFKLEVBQXdCO2NBQzdCLFFBQVEsRUFBRTNPLEdBQVYsRUFBZTtnQkFDYixJQUFJQSxHQUFHLElBQUksQ0FBWCxFQUFjO2dCQUNkLElBQUlHLElBQUksR0FBR3dqRCxNQUFNLENBQUNockQsTUFBUCxDQUFjdEwsTUFBZCxDQUFxQjJTLEdBQUcsR0FBRyxDQUEzQixDQUFYOztnQkFDQSxJQUFJRyxJQUFJLElBQUl3TyxFQUFSLElBQWNnMUMsTUFBTSxDQUFDaHJELE1BQVAsQ0FBY3RMLE1BQWQsQ0FBcUIyUyxHQUFHLEdBQUcsQ0FBM0IsS0FBaUMsSUFBbkQsRUFBeUQ7a0JBQUVBLEdBQUc7a0JBQUk7OzthQUovRCxNQU1BLElBQUk0OEYsWUFBWSxJQUFJLENBQUN4MEUsS0FBckIsRUFBNEI7Y0FDakMsRUFBRXBvQixHQUFGO2NBQ0E7Ozs7VUFHSixJQUFJNDhGLFlBQVksSUFBSSxDQUFDeDBFLEtBQXJCLEVBQTRCbUgsS0FBSyxDQUFDb3RFLFVBQU4sR0FBbUIzOEYsR0FBbkI7U0EzTW1DOzs7UUFnTmpFLElBQUk4OEYsV0FBVyxHQUFHO1VBQUMsUUFBUSxJQUFUO1VBQWUsVUFBVSxJQUF6QjtVQUErQixZQUFZLElBQTNDO1VBQWlELFVBQVUsSUFBM0Q7VUFDQyxVQUFVLElBRFg7VUFDaUIsUUFBUSxJQUR6QjtVQUMrQixVQUFVLElBRHpDO1VBQytDLGtCQUFrQjtTQURuRjs7UUFHQSxTQUFTQyxTQUFULENBQW1CbDRDLFFBQW5CLEVBQTZCbkcsTUFBN0IsRUFBcUNwMEQsSUFBckMsRUFBMkN3Z0YsS0FBM0MsRUFBa0R0eUQsSUFBbEQsRUFBd0R5WCxJQUF4RCxFQUE4RDtVQUM1RCxLQUFLNDBCLFFBQUwsR0FBZ0JBLFFBQWhCO1VBQ0EsS0FBS25HLE1BQUwsR0FBY0EsTUFBZDtVQUNBLEtBQUtwMEQsSUFBTCxHQUFZQSxJQUFaO1VBQ0EsS0FBS2t1QixJQUFMLEdBQVlBLElBQVo7VUFDQSxLQUFLeVgsSUFBTCxHQUFZQSxJQUFaO1VBQ0EsSUFBSTY2QyxLQUFLLElBQUksSUFBYixFQUFtQixLQUFLQSxLQUFMLEdBQWFBLEtBQWI7OztRQUdyQixTQUFTa3lCLE9BQVQsQ0FBaUJ6dEUsS0FBakIsRUFBd0IwdEUsT0FBeEIsRUFBaUM7VUFDL0IsSUFBSSxDQUFDbEMsVUFBTCxFQUFpQixPQUFPLEtBQVA7O1VBQ2pCLEtBQUssSUFBSTltRixDQUFDLEdBQUdzYixLQUFLLENBQUMydEUsU0FBbkIsRUFBOEJqcEYsQ0FBOUIsRUFBaUNBLENBQUMsR0FBR0EsQ0FBQyxDQUFDOVQsSUFBdkM7WUFDRSxJQUFJOFQsQ0FBQyxDQUFDMXBCLElBQUYsSUFBVTB5RyxPQUFkLEVBQXVCLE9BQU8sSUFBUDs7O1VBQ3pCLEtBQUssSUFBSUUsRUFBRSxHQUFHNXRFLEtBQUssQ0FBQzlzQixPQUFwQixFQUE2QjA2RixFQUE3QixFQUFpQ0EsRUFBRSxHQUFHQSxFQUFFLENBQUMza0YsSUFBekMsRUFBK0M7WUFDN0MsS0FBSyxJQUFJdkUsQ0FBQyxHQUFHa3BGLEVBQUUsQ0FBQ0MsSUFBaEIsRUFBc0JucEYsQ0FBdEIsRUFBeUJBLENBQUMsR0FBR0EsQ0FBQyxDQUFDOVQsSUFBL0I7Y0FDRSxJQUFJOFQsQ0FBQyxDQUFDMXBCLElBQUYsSUFBVTB5RyxPQUFkLEVBQXVCLE9BQU8sSUFBUDs7Ozs7UUFJN0IsU0FBU0ksT0FBVCxDQUFpQjl0RSxLQUFqQixFQUF3QmwvQixLQUF4QixFQUErQi9GLElBQS9CLEVBQXFDdXJDLE9BQXJDLEVBQThDOHRCLE1BQTlDLEVBQXNEO1VBQ3BELElBQUkyNUMsRUFBRSxHQUFHL3RFLEtBQUssQ0FBQyt0RSxFQUFmLENBRG9EOzs7VUFJcERILEVBQUUsQ0FBQzV0RSxLQUFILEdBQVdBLEtBQVg7VUFBa0I0dEUsRUFBRSxDQUFDeDVDLE1BQUgsR0FBWUEsTUFBWjtVQUFvQnc1QyxFQUFFLENBQUNJLE1BQUgsR0FBWSxJQUFaLEVBQWtCSixFQUFFLENBQUNHLEVBQUgsR0FBUUEsRUFBMUI7VUFBOEJILEVBQUUsQ0FBQzlzRyxLQUFILEdBQVdBLEtBQVg7VUFFcEUsSUFBSSxDQUFDay9CLEtBQUssQ0FBQzhzRSxPQUFOLENBQWN4MkcsY0FBZCxDQUE2QixPQUE3QixDQUFMLEVBQ0UwcEMsS0FBSyxDQUFDOHNFLE9BQU4sQ0FBY3Z4QixLQUFkLEdBQXNCLElBQXRCOztVQUVGLE9BQU0sSUFBTixFQUFZO1lBQ1YsSUFBSTB5QixVQUFVLEdBQUdGLEVBQUUsQ0FBQ3h6RyxNQUFILEdBQVl3ekcsRUFBRSxDQUFDeHNFLEdBQUgsRUFBWixHQUF1QitwRSxRQUFRLEdBQUc0QyxVQUFILEdBQWdCQyxTQUFoRTs7WUFDQSxJQUFJRixVQUFVLENBQUNsekcsSUFBRCxFQUFPdXJDLE9BQVAsQ0FBZCxFQUErQjtjQUM3QixPQUFNeW5FLEVBQUUsQ0FBQ3h6RyxNQUFILElBQWF3ekcsRUFBRSxDQUFDQSxFQUFFLENBQUN4ekcsTUFBSCxHQUFZLENBQWIsQ0FBRixDQUFrQjZ6RyxHQUFyQztnQkFDRUwsRUFBRSxDQUFDeHNFLEdBQUg7OztjQUNGLElBQUlxc0UsRUFBRSxDQUFDSSxNQUFQLEVBQWUsT0FBT0osRUFBRSxDQUFDSSxNQUFWO2NBQ2YsSUFBSWp6RyxJQUFJLElBQUksVUFBUixJQUFzQjB5RyxPQUFPLENBQUN6dEUsS0FBRCxFQUFRc0csT0FBUixDQUFqQyxFQUFtRCxPQUFPLFlBQVA7Y0FDbkQsT0FBT3hsQyxLQUFQOzs7U0F0UDJEOzs7UUE2UGpFLElBQUk4c0csRUFBRSxHQUFHO1VBQUM1dEUsS0FBSyxFQUFFLElBQVI7VUFBY212QixNQUFNLEVBQUUsSUFBdEI7VUFBNEI2K0MsTUFBTSxFQUFFLElBQXBDO1VBQTBDRCxFQUFFLEVBQUU7U0FBdkQ7O1FBQ0EsU0FBU00sSUFBVCxHQUFnQjtVQUNkLEtBQUssSUFBSTF4RyxDQUFDLEdBQUcvQixTQUFTLENBQUNMLE1BQVYsR0FBbUIsQ0FBaEMsRUFBbUNvQyxDQUFDLElBQUksQ0FBeEMsRUFBMkNBLENBQUMsRUFBNUM7WUFBZ0RpeEcsRUFBRSxDQUFDRyxFQUFILENBQU16MEcsSUFBTixDQUFXc0IsU0FBUyxDQUFDK0IsQ0FBRCxDQUFwQjs7OztRQUVsRCxTQUFTNHZHLElBQVQsR0FBZ0I7VUFDZDhCLElBQUksQ0FBQzF6RyxLQUFMLENBQVcsSUFBWCxFQUFpQkMsU0FBakI7VUFDQSxPQUFPLElBQVA7OztRQUVGLFNBQVMwekcsTUFBVCxDQUFnQnR6RyxJQUFoQixFQUFzQnk1QixJQUF0QixFQUE0QjtVQUMxQixLQUFLLElBQUkvUCxDQUFDLEdBQUcrUCxJQUFiLEVBQW1CL1AsQ0FBbkIsRUFBc0JBLENBQUMsR0FBR0EsQ0FBQyxDQUFDOVQsSUFBNUI7WUFBa0MsSUFBSThULENBQUMsQ0FBQzFwQixJQUFGLElBQVVBLElBQWQsRUFBb0IsT0FBTyxJQUFQOzs7VUFDdEQsT0FBTyxLQUFQOzs7UUFFRixTQUFTdXpHLFFBQVQsQ0FBa0JiLE9BQWxCLEVBQTJCO1VBQ3pCLElBQUkxdEUsS0FBSyxHQUFHNHRFLEVBQUUsQ0FBQzV0RSxLQUFmO1VBQ0E0dEUsRUFBRSxDQUFDSSxNQUFILEdBQVksS0FBWjtVQUNBLElBQUksQ0FBQ3hDLFVBQUwsRUFBaUI7O1VBQ2pCLElBQUl4ckUsS0FBSyxDQUFDOXNCLE9BQVYsRUFBbUI7WUFDakIsSUFBSThzQixLQUFLLENBQUM4c0UsT0FBTixDQUFjcHNFLElBQWQsSUFBc0IsS0FBdEIsSUFBK0JWLEtBQUssQ0FBQzlzQixPQUFyQyxJQUFnRDhzQixLQUFLLENBQUM5c0IsT0FBTixDQUFjczdGLEtBQWxFLEVBQXlFOztjQUV2RSxJQUFJQyxVQUFVLEdBQUdDLGlCQUFpQixDQUFDaEIsT0FBRCxFQUFVMXRFLEtBQUssQ0FBQzlzQixPQUFoQixDQUFsQzs7Y0FDQSxJQUFJdTdGLFVBQVUsSUFBSSxJQUFsQixFQUF3QjtnQkFDdEJ6dUUsS0FBSyxDQUFDOXNCLE9BQU4sR0FBZ0J1N0YsVUFBaEI7Z0JBQ0E7O2FBTEosTUFPTyxJQUFJLENBQUNILE1BQU0sQ0FBQ1osT0FBRCxFQUFVMXRFLEtBQUssQ0FBQzJ0RSxTQUFoQixDQUFYLEVBQXVDO2NBQzVDM3RFLEtBQUssQ0FBQzJ0RSxTQUFOLEdBQWtCLElBQUlnQixHQUFKLENBQVFqQixPQUFSLEVBQWlCMXRFLEtBQUssQ0FBQzJ0RSxTQUF2QixDQUFsQjtjQUNBOztXQWRxQjs7O1VBa0J6QixJQUFJekMsWUFBWSxDQUFDMEQsVUFBYixJQUEyQixDQUFDTixNQUFNLENBQUNaLE9BQUQsRUFBVTF0RSxLQUFLLENBQUM0dUUsVUFBaEIsQ0FBdEMsRUFDRTV1RSxLQUFLLENBQUM0dUUsVUFBTixHQUFtQixJQUFJRCxHQUFKLENBQVFqQixPQUFSLEVBQWlCMXRFLEtBQUssQ0FBQzR1RSxVQUF2QixDQUFuQjs7O1FBRUosU0FBU0YsaUJBQVQsQ0FBMkJoQixPQUEzQixFQUFvQ3g2RixPQUFwQyxFQUE2QztVQUMzQyxJQUFJLENBQUNBLE9BQUwsRUFBYztZQUNaLE9BQU8sSUFBUDtXQURGLE1BRU8sSUFBSUEsT0FBTyxDQUFDczdGLEtBQVosRUFBbUI7WUFDeEIsSUFBSTcrQyxLQUFLLEdBQUcrK0MsaUJBQWlCLENBQUNoQixPQUFELEVBQVV4NkYsT0FBTyxDQUFDK1YsSUFBbEIsQ0FBN0I7WUFDQSxJQUFJLENBQUMwbUMsS0FBTCxFQUFZLE9BQU8sSUFBUDtZQUNaLElBQUlBLEtBQUssSUFBSXo4QyxPQUFPLENBQUMrVixJQUFyQixFQUEyQixPQUFPL1YsT0FBUDtZQUMzQixPQUFPLElBQUlpckIsT0FBSixDQUFZd3hCLEtBQVosRUFBbUJ6OEMsT0FBTyxDQUFDMjZGLElBQTNCLEVBQWlDLElBQWpDLENBQVA7V0FKSyxNQUtBLElBQUlTLE1BQU0sQ0FBQ1osT0FBRCxFQUFVeDZGLE9BQU8sQ0FBQzI2RixJQUFsQixDQUFWLEVBQW1DO1lBQ3hDLE9BQU8zNkYsT0FBUDtXQURLLE1BRUE7WUFDTCxPQUFPLElBQUlpckIsT0FBSixDQUFZanJCLE9BQU8sQ0FBQytWLElBQXBCLEVBQTBCLElBQUkwbEYsR0FBSixDQUFRakIsT0FBUixFQUFpQng2RixPQUFPLENBQUMyNkYsSUFBekIsQ0FBMUIsRUFBMEQsS0FBMUQsQ0FBUDs7OztRQUlKLFNBQVNnQixVQUFULENBQW9CN3pHLElBQXBCLEVBQTBCO1VBQ3hCLE9BQU9BLElBQUksSUFBSSxRQUFSLElBQW9CQSxJQUFJLElBQUksU0FBNUIsSUFBeUNBLElBQUksSUFBSSxXQUFqRCxJQUFnRUEsSUFBSSxJQUFJLFVBQXhFLElBQXNGQSxJQUFJLElBQUksVUFBckc7U0E5UytEOzs7UUFtVGpFLFNBQVNtakMsT0FBVCxDQUFpQmxWLElBQWpCLEVBQXVCNGtGLElBQXZCLEVBQTZCVyxLQUE3QixFQUFvQztVQUFFLEtBQUt2bEYsSUFBTCxHQUFZQSxJQUFaO1VBQWtCLEtBQUs0a0YsSUFBTCxHQUFZQSxJQUFaO1VBQWtCLEtBQUtXLEtBQUwsR0FBYUEsS0FBYjs7O1FBQzFFLFNBQVNHLEdBQVQsQ0FBYTN6RyxJQUFiLEVBQW1CNFYsSUFBbkIsRUFBeUI7VUFBRSxLQUFLNVYsSUFBTCxHQUFZQSxJQUFaO1VBQWtCLEtBQUs0VixJQUFMLEdBQVlBLElBQVo7OztRQUU3QyxJQUFJaytGLFdBQVcsR0FBRyxJQUFJSCxHQUFKLENBQVEsTUFBUixFQUFnQixJQUFJQSxHQUFKLENBQVEsV0FBUixFQUFxQixJQUFyQixDQUFoQixDQUFsQjs7UUFDQSxTQUFTSSxXQUFULEdBQXVCO1VBQ3JCbkIsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUzlzQixPQUFULEdBQW1CLElBQUlpckIsT0FBSixDQUFZeXZFLEVBQUUsQ0FBQzV0RSxLQUFILENBQVM5c0IsT0FBckIsRUFBOEIwNkYsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUzJ0RSxTQUF2QyxFQUFrRCxLQUFsRCxDQUFuQjtVQUNBQyxFQUFFLENBQUM1dEUsS0FBSCxDQUFTMnRFLFNBQVQsR0FBcUJtQixXQUFyQjs7O1FBRUYsU0FBU0UsZ0JBQVQsR0FBNEI7VUFDMUJwQixFQUFFLENBQUM1dEUsS0FBSCxDQUFTOXNCLE9BQVQsR0FBbUIsSUFBSWlyQixPQUFKLENBQVl5dkUsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUzlzQixPQUFyQixFQUE4QjA2RixFQUFFLENBQUM1dEUsS0FBSCxDQUFTMnRFLFNBQXZDLEVBQWtELElBQWxELENBQW5CO1VBQ0FDLEVBQUUsQ0FBQzV0RSxLQUFILENBQVMydEUsU0FBVCxHQUFxQixJQUFyQjs7O1FBRUYsU0FBU3NCLFVBQVQsR0FBc0I7VUFDcEJyQixFQUFFLENBQUM1dEUsS0FBSCxDQUFTMnRFLFNBQVQsR0FBcUJDLEVBQUUsQ0FBQzV0RSxLQUFILENBQVM5c0IsT0FBVCxDQUFpQjI2RixJQUF0QztVQUNBRCxFQUFFLENBQUM1dEUsS0FBSCxDQUFTOXNCLE9BQVQsR0FBbUIwNkYsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUzlzQixPQUFULENBQWlCK1YsSUFBcEM7OztRQUVGZ21GLFVBQVUsQ0FBQ2IsR0FBWCxHQUFpQixJQUFqQjs7UUFDQSxTQUFTYyxPQUFULENBQWlCbjBHLElBQWpCLEVBQXVCMmxDLElBQXZCLEVBQTZCO1VBQzNCLElBQUluaEMsTUFBTSxHQUFHLFNBQVRBLE1BQVMsR0FBVztZQUN0QixJQUFJeWdDLEtBQUssR0FBRzR0RSxFQUFFLENBQUM1dEUsS0FBZjtnQkFBc0JnK0QsTUFBTSxHQUFHaCtELEtBQUssQ0FBQ3MxQixRQUFyQztZQUNBLElBQUl0MUIsS0FBSyxDQUFDOHNFLE9BQU4sQ0FBYy94RyxJQUFkLElBQXNCLE1BQTFCLEVBQWtDaWpHLE1BQU0sR0FBR2grRCxLQUFLLENBQUM4c0UsT0FBTixDQUFjeDNDLFFBQXZCLENBQWxDLEtBQ0ssS0FBSyxJQUFJekUsS0FBSyxHQUFHN3dCLEtBQUssQ0FBQzhzRSxPQUF2QixFQUFnQ2o4QyxLQUFLLElBQUlBLEtBQUssQ0FBQzkxRCxJQUFOLElBQWMsR0FBdkIsSUFBOEI4MUQsS0FBSyxDQUFDMHFCLEtBQXBFLEVBQTJFMXFCLEtBQUssR0FBR0EsS0FBSyxDQUFDNW5DLElBQXpGO2NBQ0grMEUsTUFBTSxHQUFHbnRDLEtBQUssQ0FBQ3lFLFFBQWY7O1lBQ0Z0MUIsS0FBSyxDQUFDOHNFLE9BQU4sR0FBZ0IsSUFBSVUsU0FBSixDQUFjeFAsTUFBZCxFQUFzQjRQLEVBQUUsQ0FBQ3g1QyxNQUFILENBQVVqRixNQUFWLEVBQXRCLEVBQTBDcDBELElBQTFDLEVBQWdELElBQWhELEVBQXNEaWxDLEtBQUssQ0FBQzhzRSxPQUE1RCxFQUFxRXBzRSxJQUFyRSxDQUFoQjtXQUxGOztVQU9BbmhDLE1BQU0sQ0FBQzZ1RyxHQUFQLEdBQWEsSUFBYjtVQUNBLE9BQU83dUcsTUFBUDs7O1FBRUYsU0FBUzR2RyxNQUFULEdBQWtCO1VBQ2hCLElBQUludkUsS0FBSyxHQUFHNHRFLEVBQUUsQ0FBQzV0RSxLQUFmOztVQUNBLElBQUlBLEtBQUssQ0FBQzhzRSxPQUFOLENBQWM3akYsSUFBbEIsRUFBd0I7WUFDdEIsSUFBSStXLEtBQUssQ0FBQzhzRSxPQUFOLENBQWMveEcsSUFBZCxJQUFzQixHQUExQixFQUNFaWxDLEtBQUssQ0FBQ3MxQixRQUFOLEdBQWlCdDFCLEtBQUssQ0FBQzhzRSxPQUFOLENBQWN4M0MsUUFBL0I7WUFDRnQxQixLQUFLLENBQUM4c0UsT0FBTixHQUFnQjlzRSxLQUFLLENBQUM4c0UsT0FBTixDQUFjN2pGLElBQTlCOzs7O1FBR0prbUYsTUFBTSxDQUFDZixHQUFQLEdBQWEsSUFBYjs7UUFFQSxTQUFTZ0IsTUFBVCxDQUFnQkMsTUFBaEIsRUFBd0I7VUFDdEIsU0FBU3R6RyxHQUFULENBQWFoQixJQUFiLEVBQW1CO1lBQ2pCLElBQUlBLElBQUksSUFBSXMwRyxNQUFaLEVBQW9CLE9BQU85QyxJQUFJLEVBQVgsQ0FBcEIsS0FDSyxJQUFJOEMsTUFBTSxJQUFJLEdBQVYsSUFBaUJ0MEcsSUFBSSxJQUFJLEdBQXpCLElBQWdDQSxJQUFJLElBQUksR0FBeEMsSUFBK0NBLElBQUksSUFBSSxHQUEzRCxFQUFnRSxPQUFPc3pHLElBQUksRUFBWCxDQUFoRSxLQUNBLE9BQU85QixJQUFJLENBQUN4d0csR0FBRCxDQUFYOztVQUVQLE9BQU9BLEdBQVA7OztRQUdGLFNBQVNveUcsU0FBVCxDQUFtQnB6RyxJQUFuQixFQUF5QnhDLEtBQXpCLEVBQWdDO1VBQzlCLElBQUl3QyxJQUFJLElBQUksS0FBWixFQUFtQixPQUFPd3hHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxRQUFELEVBQVczMkcsS0FBWCxDQUFSLEVBQTJCKzJHLE1BQTNCLEVBQW1DRixNQUFNLENBQUMsR0FBRCxDQUF6QyxFQUFnREQsTUFBaEQsQ0FBWDtVQUNuQixJQUFJcDBHLElBQUksSUFBSSxXQUFaLEVBQXlCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQkssU0FBbEIsRUFBNkJwQixTQUE3QixFQUF3Q2dCLE1BQXhDLENBQVg7VUFDekIsSUFBSXAwRyxJQUFJLElBQUksV0FBWixFQUF5QixPQUFPd3hHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxNQUFELENBQVIsRUFBa0JmLFNBQWxCLEVBQTZCZ0IsTUFBN0IsQ0FBWDtVQUN6QixJQUFJcDBHLElBQUksSUFBSSxXQUFaLEVBQXlCLE9BQU82eUcsRUFBRSxDQUFDeDVDLE1BQUgsQ0FBVTdyRCxLQUFWLENBQWdCLE9BQWhCLEVBQXlCLEtBQXpCLElBQWtDZ2tHLElBQUksRUFBdEMsR0FBMkNBLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxNQUFELENBQVIsRUFBa0JNLGVBQWxCLEVBQW1DSixNQUFNLENBQUMsR0FBRCxDQUF6QyxFQUFnREQsTUFBaEQsQ0FBdEQ7VUFDekIsSUFBSXAwRyxJQUFJLElBQUksVUFBWixFQUF3QixPQUFPd3hHLElBQUksQ0FBQzZDLE1BQU0sQ0FBQyxHQUFELENBQVAsQ0FBWDtVQUN4QixJQUFJcjBHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLEdBQUQsQ0FBUixFQUFlRixnQkFBZixFQUFpQ1IsS0FBakMsRUFBd0NXLE1BQXhDLEVBQWdERixVQUFoRCxDQUFYO1VBQ2pCLElBQUlsMEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLEVBQVg7O1VBQ2pCLElBQUl4eEcsSUFBSSxJQUFJLElBQVosRUFBa0I7WUFDaEIsSUFBSTZ5RyxFQUFFLENBQUM1dEUsS0FBSCxDQUFTOHNFLE9BQVQsQ0FBaUJwc0UsSUFBakIsSUFBeUIsTUFBekIsSUFBbUNrdEUsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUyt0RSxFQUFULENBQVlILEVBQUUsQ0FBQzV0RSxLQUFILENBQVMrdEUsRUFBVCxDQUFZeHpHLE1BQVosR0FBcUIsQ0FBakMsS0FBdUM0MEcsTUFBOUUsRUFDRXZCLEVBQUUsQ0FBQzV0RSxLQUFILENBQVMrdEUsRUFBVCxDQUFZeHNFLEdBQVo7WUFDRixPQUFPZ3JFLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxNQUFELENBQVIsRUFBa0JLLFNBQWxCLEVBQTZCcEIsU0FBN0IsRUFBd0NnQixNQUF4QyxFQUFnRE0sU0FBaEQsQ0FBWDs7O1VBRUYsSUFBSTEwRyxJQUFJLElBQUksVUFBWixFQUF3QixPQUFPd3hHLElBQUksQ0FBQ21ELFdBQUQsQ0FBWDtVQUN4QixJQUFJMzBHLElBQUksSUFBSSxLQUFaLEVBQW1CLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQkYsZ0JBQWxCLEVBQW9DVyxPQUFwQyxFQUE2Q3hCLFNBQTdDLEVBQXdEYyxVQUF4RCxFQUFvRUUsTUFBcEUsQ0FBWDs7VUFDbkIsSUFBSXAwRyxJQUFJLElBQUksT0FBUixJQUFvQjB3RyxJQUFJLElBQUlsekcsS0FBSyxJQUFJLFdBQXpDLEVBQXVEO1lBQ3JEcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFDQSxPQUFPekIsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsRUFBU24wRyxJQUFJLElBQUksT0FBUixHQUFrQkEsSUFBbEIsR0FBeUJ4QyxLQUFsQyxDQUFSLEVBQWtEMHBELFNBQWxELEVBQTZEa3RELE1BQTdELENBQVg7OztVQUVGLElBQUlwMEcsSUFBSSxJQUFJLFVBQVosRUFBd0I7WUFDdEIsSUFBSTB3RyxJQUFJLElBQUlsekcsS0FBSyxJQUFJLFNBQXJCLEVBQWdDO2NBQzlCcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7Y0FDQSxPQUFPekIsSUFBSSxDQUFDNEIsU0FBRCxDQUFYO2FBRkYsTUFHTyxJQUFJMUMsSUFBSSxLQUFLbHpHLEtBQUssSUFBSSxRQUFULElBQXFCQSxLQUFLLElBQUksTUFBOUIsSUFBd0NBLEtBQUssSUFBSSxNQUF0RCxDQUFKLElBQXFFcTFHLEVBQUUsQ0FBQ3g1QyxNQUFILENBQVU3ckQsS0FBVixDQUFnQixRQUFoQixFQUEwQixLQUExQixDQUF6RSxFQUEyRztjQUNoSHFsRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO2NBQ0EsSUFBSXoxRyxLQUFLLElBQUksTUFBYixFQUFxQixPQUFPZzBHLElBQUksQ0FBQ3FELE9BQUQsQ0FBWCxDQUFyQixLQUNLLElBQUlyM0csS0FBSyxJQUFJLE1BQWIsRUFBcUIsT0FBT2cwRyxJQUFJLENBQUNzRCxRQUFELEVBQVdULE1BQU0sQ0FBQyxVQUFELENBQWpCLEVBQStCVSxRQUEvQixFQUF5Q1YsTUFBTSxDQUFDLEdBQUQsQ0FBL0MsQ0FBWCxDQUFyQixLQUNBLE9BQU83QyxJQUFJLENBQUMyQyxPQUFPLENBQUMsTUFBRCxDQUFSLEVBQWtCNy9DLE9BQWxCLEVBQTJCKy9DLE1BQU0sQ0FBQyxHQUFELENBQWpDLEVBQXdDRixPQUFPLENBQUMsR0FBRCxDQUEvQyxFQUFzRFYsS0FBdEQsRUFBNkRXLE1BQTdELEVBQXFFQSxNQUFyRSxDQUFYO2FBSkEsTUFLQSxJQUFJMUQsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxXQUFyQixFQUFrQztjQUN2Q3ExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO2NBQ0EsT0FBT3pCLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxNQUFELENBQVIsRUFBa0JoQixVQUFsQixFQUE4QkMsU0FBOUIsRUFBeUNnQixNQUF6QyxDQUFYO2FBRkssTUFHQSxJQUFJMUQsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxVQUFyQixFQUFpQztjQUN0Q3ExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO2NBQ0EsT0FBT3pCLElBQUksQ0FBQzRCLFNBQUQsQ0FBWDthQUZLLE1BR0E7Y0FDTCxPQUFPNUIsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQmEsVUFBbEIsQ0FBWDs7OztVQUdKLElBQUloMUcsSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBT3d4RyxJQUFJLENBQUMyQyxPQUFPLENBQUMsTUFBRCxDQUFSLEVBQWtCSyxTQUFsQixFQUE2QkgsTUFBTSxDQUFDLEdBQUQsQ0FBbkMsRUFBMENGLE9BQU8sQ0FBQyxHQUFELEVBQU0sUUFBTixDQUFqRCxFQUFrRUYsZ0JBQWxFLEVBQ0NSLEtBREQsRUFDUVcsTUFEUixFQUNnQkEsTUFEaEIsRUFDd0JGLFVBRHhCLENBQVg7VUFFdEIsSUFBSWwwRyxJQUFJLElBQUksTUFBWixFQUFvQixPQUFPd3hHLElBQUksQ0FBQzJCLFVBQUQsRUFBYWtCLE1BQU0sQ0FBQyxHQUFELENBQW5CLENBQVg7VUFDcEIsSUFBSXIwRyxJQUFJLElBQUksU0FBWixFQUF1QixPQUFPd3hHLElBQUksQ0FBQzZDLE1BQU0sQ0FBQyxHQUFELENBQVAsQ0FBWDtVQUN2QixJQUFJcjBHLElBQUksSUFBSSxPQUFaLEVBQXFCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQkgsV0FBbEIsRUFBK0JpQixpQkFBL0IsRUFBa0Q3QixTQUFsRCxFQUE2RGdCLE1BQTdELEVBQXFFRixVQUFyRSxDQUFYO1VBQ3JCLElBQUlsMEcsSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBT3d4RyxJQUFJLENBQUMyQyxPQUFPLENBQUMsTUFBRCxDQUFSLEVBQWtCZSxXQUFsQixFQUErQmQsTUFBL0IsQ0FBWDtVQUN0QixJQUFJcDBHLElBQUksSUFBSSxRQUFaLEVBQXNCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQmdCLFdBQWxCLEVBQStCZixNQUEvQixDQUFYO1VBQ3RCLElBQUlwMEcsSUFBSSxJQUFJLE9BQVosRUFBcUIsT0FBT3d4RyxJQUFJLENBQUM0QixTQUFELENBQVg7VUFDckIsSUFBSTUxRyxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzJCLFVBQUQsRUFBYUMsU0FBYixDQUFYO1VBQ2xCLE9BQU9FLElBQUksQ0FBQ2EsT0FBTyxDQUFDLE1BQUQsQ0FBUixFQUFrQmhCLFVBQWxCLEVBQThCa0IsTUFBTSxDQUFDLEdBQUQsQ0FBcEMsRUFBMkNELE1BQTNDLENBQVg7OztRQUVGLFNBQVNhLGlCQUFULENBQTJCajFHLElBQTNCLEVBQWlDO1VBQy9CLElBQUlBLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDNEQsTUFBRCxFQUFTZixNQUFNLENBQUMsR0FBRCxDQUFmLENBQVg7OztRQUVuQixTQUFTbEIsVUFBVCxDQUFvQm56RyxJQUFwQixFQUEwQnhDLEtBQTFCLEVBQWlDO1VBQy9CLE9BQU82M0csZUFBZSxDQUFDcjFHLElBQUQsRUFBT3hDLEtBQVAsRUFBYyxLQUFkLENBQXRCOzs7UUFFRixTQUFTODNHLGlCQUFULENBQTJCdDFHLElBQTNCLEVBQWlDeEMsS0FBakMsRUFBd0M7VUFDdEMsT0FBTzYzRyxlQUFlLENBQUNyMUcsSUFBRCxFQUFPeEMsS0FBUCxFQUFjLElBQWQsQ0FBdEI7OztRQUVGLFNBQVNnM0csU0FBVCxDQUFtQngwRyxJQUFuQixFQUF5QjtVQUN2QixJQUFJQSxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPc3pHLElBQUksRUFBWDtVQUNqQixPQUFPOUIsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLEdBQUQsQ0FBUixFQUFlTSxlQUFmLEVBQWdDSixNQUFNLENBQUMsR0FBRCxDQUF0QyxFQUE2Q0QsTUFBN0MsQ0FBWDs7O1FBRUYsU0FBU2lCLGVBQVQsQ0FBeUJyMUcsSUFBekIsRUFBK0J4QyxLQUEvQixFQUFzQyszRyxPQUF0QyxFQUErQztVQUM3QyxJQUFJMUMsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBU290RSxVQUFULElBQXVCUSxFQUFFLENBQUN4NUMsTUFBSCxDQUFVdjhDLEtBQXJDLEVBQTRDO1lBQzFDLElBQUk2OEIsSUFBSSxHQUFHNDdELE9BQU8sR0FBR0MsZ0JBQUgsR0FBc0JDLFNBQXhDO1lBQ0EsSUFBSXoxRyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQ3dDLFdBQUQsRUFBY0csT0FBTyxDQUFDLEdBQUQsQ0FBckIsRUFBNEJ1QixRQUFRLENBQUNOLE1BQUQsRUFBUyxHQUFULENBQXBDLEVBQW1EaEIsTUFBbkQsRUFBMkRDLE1BQU0sQ0FBQyxJQUFELENBQWpFLEVBQXlFMTZELElBQXpFLEVBQStFdTZELFVBQS9FLENBQVgsQ0FBakIsS0FDSyxJQUFJbDBHLElBQUksSUFBSSxVQUFaLEVBQXdCLE9BQU9zekcsSUFBSSxDQUFDVSxXQUFELEVBQWMxL0MsT0FBZCxFQUF1QisvQyxNQUFNLENBQUMsSUFBRCxDQUE3QixFQUFxQzE2RCxJQUFyQyxFQUEyQ3U2RCxVQUEzQyxDQUFYOzs7VUFHL0IsSUFBSXlCLE9BQU8sR0FBR0osT0FBTyxHQUFHSyxvQkFBSCxHQUEwQkMsa0JBQS9DO1VBQ0EsSUFBSXJELFdBQVcsQ0FBQ2ozRyxjQUFaLENBQTJCeUUsSUFBM0IsQ0FBSixFQUFzQyxPQUFPd3hHLElBQUksQ0FBQ21FLE9BQUQsQ0FBWDtVQUN0QyxJQUFJMzFHLElBQUksSUFBSSxVQUFaLEVBQXdCLE9BQU93eEcsSUFBSSxDQUFDbUQsV0FBRCxFQUFjZ0IsT0FBZCxDQUFYOztVQUN4QixJQUFJMzFHLElBQUksSUFBSSxPQUFSLElBQW9CMHdHLElBQUksSUFBSWx6RyxLQUFLLElBQUksV0FBekMsRUFBdUQ7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUMyQyxPQUFPLENBQUMsTUFBRCxDQUFSLEVBQWtCMkIsZUFBbEIsRUFBbUMxQixNQUFuQyxDQUFYOzs7VUFDaEYsSUFBSXAwRyxJQUFJLElBQUksV0FBUixJQUF1QkEsSUFBSSxJQUFJLE9BQW5DLEVBQTRDLE9BQU93eEcsSUFBSSxDQUFDK0QsT0FBTyxHQUFHRCxpQkFBSCxHQUF1Qm5DLFVBQS9CLENBQVg7VUFDNUMsSUFBSW56RyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZU0sZUFBZixFQUFnQ0osTUFBTSxDQUFDLEdBQUQsQ0FBdEMsRUFBNkNELE1BQTdDLEVBQXFEdUIsT0FBckQsQ0FBWDtVQUNqQixJQUFJMzFHLElBQUksSUFBSSxVQUFSLElBQXNCQSxJQUFJLElBQUksUUFBbEMsRUFBNEMsT0FBT3d4RyxJQUFJLENBQUMrRCxPQUFPLEdBQUdELGlCQUFILEdBQXVCbkMsVUFBL0IsQ0FBWDtVQUM1QyxJQUFJbnpHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLEdBQUQsQ0FBUixFQUFlNEIsWUFBZixFQUE2QjNCLE1BQTdCLEVBQXFDdUIsT0FBckMsQ0FBWDtVQUNqQixJQUFJMzFHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU9nMkcsWUFBWSxDQUFDQyxPQUFELEVBQVUsR0FBVixFQUFlLElBQWYsRUFBcUJOLE9BQXJCLENBQW5CO1VBQ2pCLElBQUkzMUcsSUFBSSxJQUFJLE9BQVosRUFBcUIsT0FBT3N6RyxJQUFJLENBQUM0QyxLQUFELEVBQVFQLE9BQVIsQ0FBWDtVQUNyQixJQUFJMzFHLElBQUksSUFBSSxLQUFaLEVBQW1CLE9BQU93eEcsSUFBSSxDQUFDMkUsV0FBVyxDQUFDWixPQUFELENBQVosQ0FBWDtVQUNuQixPQUFPL0QsSUFBSSxFQUFYOzs7UUFFRixTQUFTaUQsZUFBVCxDQUF5QnowRyxJQUF6QixFQUErQjtVQUM3QixJQUFJQSxJQUFJLENBQUN3TixLQUFMLENBQVcsWUFBWCxDQUFKLEVBQThCLE9BQU84bEcsSUFBSSxFQUFYO1VBQzlCLE9BQU9BLElBQUksQ0FBQ0gsVUFBRCxDQUFYOzs7UUFHRixTQUFTMEMsa0JBQVQsQ0FBNEI3MUcsSUFBNUIsRUFBa0N4QyxLQUFsQyxFQUF5QztVQUN2QyxJQUFJd0MsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUNpRCxlQUFELENBQVg7VUFDakIsT0FBT21CLG9CQUFvQixDQUFDNTFHLElBQUQsRUFBT3hDLEtBQVAsRUFBYyxLQUFkLENBQTNCOzs7UUFFRixTQUFTbzRHLG9CQUFULENBQThCNTFHLElBQTlCLEVBQW9DeEMsS0FBcEMsRUFBMkMrM0csT0FBM0MsRUFBb0Q7VUFDbEQsSUFBSWxwQixFQUFFLEdBQUdrcEIsT0FBTyxJQUFJLEtBQVgsR0FBbUJNLGtCQUFuQixHQUF3Q0Qsb0JBQWpEO1VBQ0EsSUFBSVEsSUFBSSxHQUFHYixPQUFPLElBQUksS0FBWCxHQUFtQnBDLFVBQW5CLEdBQWdDbUMsaUJBQTNDO1VBQ0EsSUFBSXQxRyxJQUFJLElBQUksSUFBWixFQUFrQixPQUFPd3hHLElBQUksQ0FBQ3dDLFdBQUQsRUFBY3VCLE9BQU8sR0FBR0MsZ0JBQUgsR0FBc0JDLFNBQTNDLEVBQXNEdkIsVUFBdEQsQ0FBWDs7VUFDbEIsSUFBSWwwRyxJQUFJLElBQUksVUFBWixFQUF3QjtZQUN0QixJQUFJLFVBQVVvTSxJQUFWLENBQWU1TyxLQUFmLEtBQXlCa3pHLElBQUksSUFBSWx6RyxLQUFLLElBQUksR0FBOUMsRUFBbUQsT0FBT2cwRyxJQUFJLENBQUNubEIsRUFBRCxDQUFYO1lBQ25ELElBQUlxa0IsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxHQUFqQixJQUF3QnExRyxFQUFFLENBQUN4NUMsTUFBSCxDQUFVN3JELEtBQVYsQ0FBZ0IsMEJBQWhCLEVBQTRDLEtBQTVDLENBQTVCLEVBQ0UsT0FBT2drRyxJQUFJLENBQUMyQyxPQUFPLENBQUMsR0FBRCxDQUFSLEVBQWV1QixRQUFRLENBQUNYLFFBQUQsRUFBVyxHQUFYLENBQXZCLEVBQXdDWCxNQUF4QyxFQUFnRC9uQixFQUFoRCxDQUFYO1lBQ0YsSUFBSTd1RixLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzJCLFVBQUQsRUFBYWtCLE1BQU0sQ0FBQyxHQUFELENBQW5CLEVBQTBCK0IsSUFBMUIsQ0FBWDtZQUNsQixPQUFPNUUsSUFBSSxDQUFDNEUsSUFBRCxDQUFYOzs7VUFFRixJQUFJcDJHLElBQUksSUFBSSxPQUFaLEVBQXFCO1lBQUUsT0FBT3N6RyxJQUFJLENBQUM0QyxLQUFELEVBQVE3cEIsRUFBUixDQUFYOzs7VUFDdkIsSUFBSXJzRixJQUFJLElBQUksR0FBWixFQUFpQjtVQUNqQixJQUFJQSxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPZzJHLFlBQVksQ0FBQ1YsaUJBQUQsRUFBb0IsR0FBcEIsRUFBeUIsTUFBekIsRUFBaUNqcEIsRUFBakMsQ0FBbkI7VUFDakIsSUFBSXJzRixJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQzZFLFFBQUQsRUFBV2hxQixFQUFYLENBQVg7VUFDakIsSUFBSXJzRixJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZU0sZUFBZixFQUFnQ0osTUFBTSxDQUFDLEdBQUQsQ0FBdEMsRUFBNkNELE1BQTdDLEVBQXFEL25CLEVBQXJELENBQVg7O1VBQ2pCLElBQUlxa0IsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxJQUFyQixFQUEyQjtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQ3VELFFBQUQsRUFBVzFvQixFQUFYLENBQVg7OztVQUNwRCxJQUFJcnNGLElBQUksSUFBSSxRQUFaLEVBQXNCO1lBQ3BCNnlHLEVBQUUsQ0FBQzV0RSxLQUFILENBQVMrc0UsUUFBVCxHQUFvQmEsRUFBRSxDQUFDSSxNQUFILEdBQVksVUFBaEM7WUFDQUosRUFBRSxDQUFDeDVDLE1BQUgsQ0FBVWxGLE1BQVYsQ0FBaUIwK0MsRUFBRSxDQUFDeDVDLE1BQUgsQ0FBVTNqRCxHQUFWLEdBQWdCbTlGLEVBQUUsQ0FBQ3g1QyxNQUFILENBQVV2OEMsS0FBMUIsR0FBa0MsQ0FBbkQ7WUFDQSxPQUFPMDBGLElBQUksQ0FBQzRFLElBQUQsQ0FBWDs7OztRQUdKLFNBQVNGLEtBQVQsQ0FBZWwyRyxJQUFmLEVBQXFCeEMsS0FBckIsRUFBNEI7VUFDMUIsSUFBSXdDLElBQUksSUFBSSxPQUFaLEVBQXFCLE9BQU9zekcsSUFBSSxFQUFYO1VBQ3JCLElBQUk5MUcsS0FBSyxDQUFDeUYsS0FBTixDQUFZekYsS0FBSyxDQUFDZ0MsTUFBTixHQUFlLENBQTNCLEtBQWlDLElBQXJDLEVBQTJDLE9BQU9neUcsSUFBSSxDQUFDMEUsS0FBRCxDQUFYO1VBQzNDLE9BQU8xRSxJQUFJLENBQUNpRCxlQUFELEVBQWtCNkIsYUFBbEIsQ0FBWDs7O1FBRUYsU0FBU0EsYUFBVCxDQUF1QnQyRyxJQUF2QixFQUE2QjtVQUMzQixJQUFJQSxJQUFJLElBQUksR0FBWixFQUFpQjtZQUNmNnlHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFVBQVo7WUFDQUosRUFBRSxDQUFDNXRFLEtBQUgsQ0FBU3lzRSxRQUFULEdBQW9CSSxVQUFwQjtZQUNBLE9BQU9OLElBQUksQ0FBQzBFLEtBQUQsQ0FBWDs7OztRQUdKLFNBQVNULFNBQVQsQ0FBbUJ6MUcsSUFBbkIsRUFBeUI7VUFDdkJveUcsWUFBWSxDQUFDUyxFQUFFLENBQUN4NUMsTUFBSixFQUFZdzVDLEVBQUUsQ0FBQzV0RSxLQUFmLENBQVo7VUFDQSxPQUFPcXVFLElBQUksQ0FBQ3R6RyxJQUFJLElBQUksR0FBUixHQUFjb3pHLFNBQWQsR0FBMEJELFVBQTNCLENBQVg7OztRQUVGLFNBQVNxQyxnQkFBVCxDQUEwQngxRyxJQUExQixFQUFnQztVQUM5Qm95RyxZQUFZLENBQUNTLEVBQUUsQ0FBQ3g1QyxNQUFKLEVBQVl3NUMsRUFBRSxDQUFDNXRFLEtBQWYsQ0FBWjtVQUNBLE9BQU9xdUUsSUFBSSxDQUFDdHpHLElBQUksSUFBSSxHQUFSLEdBQWNvekcsU0FBZCxHQUEwQmtDLGlCQUEzQixDQUFYOzs7UUFFRixTQUFTYSxXQUFULENBQXFCWixPQUFyQixFQUE4QjtVQUM1QixPQUFPLFVBQVN2MUcsSUFBVCxFQUFlO1lBQ3BCLElBQUlBLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDK0QsT0FBTyxHQUFHZ0IsYUFBSCxHQUFtQjUxRyxNQUEzQixDQUFYLENBQWpCLEtBQ0ssSUFBSVgsSUFBSSxJQUFJLFVBQVIsSUFBc0Iwd0csSUFBMUIsRUFBZ0MsT0FBT2MsSUFBSSxDQUFDZ0YsYUFBRCxFQUFnQmpCLE9BQU8sR0FBR0ssb0JBQUgsR0FBMEJDLGtCQUFqRCxDQUFYLENBQWhDLEtBQ0EsT0FBT3ZDLElBQUksQ0FBQ2lDLE9BQU8sR0FBR0QsaUJBQUgsR0FBdUJuQyxVQUEvQixDQUFYO1dBSFA7OztRQU1GLFNBQVN4eUcsTUFBVCxDQUFnQjgxRyxDQUFoQixFQUFtQmo1RyxLQUFuQixFQUEwQjtVQUN4QixJQUFJQSxLQUFLLElBQUksUUFBYixFQUF1QjtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQ3FFLGtCQUFELENBQVg7Ozs7UUFFbEQsU0FBU1UsYUFBVCxDQUF1QkUsQ0FBdkIsRUFBMEJqNUcsS0FBMUIsRUFBaUM7VUFDL0IsSUFBSUEsS0FBSyxJQUFJLFFBQWIsRUFBdUI7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUNvRSxvQkFBRCxDQUFYOzs7O1FBRWxELFNBQVNaLFVBQVQsQ0FBb0JoMUcsSUFBcEIsRUFBMEI7VUFDeEIsSUFBSUEsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUM0QyxNQUFELEVBQVNoQixTQUFULENBQVg7VUFDakIsT0FBT0UsSUFBSSxDQUFDdUMsa0JBQUQsRUFBcUJ4QixNQUFNLENBQUMsR0FBRCxDQUEzQixFQUFrQ0QsTUFBbEMsQ0FBWDs7O1FBRUYsU0FBU2lDLFFBQVQsQ0FBa0JyMkcsSUFBbEIsRUFBd0I7VUFDdEIsSUFBSUEsSUFBSSxJQUFJLFVBQVosRUFBd0I7WUFBQzZ5RyxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1lBQXdCLE9BQU96QixJQUFJLEVBQVg7Ozs7UUFFbkQsU0FBU3lFLE9BQVQsQ0FBaUJqMkcsSUFBakIsRUFBdUJ4QyxLQUF2QixFQUE4QjtVQUM1QixJQUFJd0MsSUFBSSxJQUFJLE9BQVosRUFBcUI7WUFDbkI2eUcsRUFBRSxDQUFDSSxNQUFILEdBQVksVUFBWjtZQUNBLE9BQU96QixJQUFJLENBQUN5RSxPQUFELENBQVg7V0FGRixNQUdPLElBQUlqMkcsSUFBSSxJQUFJLFVBQVIsSUFBc0I2eUcsRUFBRSxDQUFDOXNHLEtBQUgsSUFBWSxTQUF0QyxFQUFpRDtZQUN0RDhzRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1lBQ0EsSUFBSXoxRyxLQUFLLElBQUksS0FBVCxJQUFrQkEsS0FBSyxJQUFJLEtBQS9CLEVBQXNDLE9BQU9nMEcsSUFBSSxDQUFDa0YsWUFBRCxDQUFYO1lBQ3RDLElBQUkva0csQ0FBSixDQUhzRDs7WUFJdEQsSUFBSSsrRixJQUFJLElBQUltQyxFQUFFLENBQUM1dEUsS0FBSCxDQUFTb3RFLFVBQVQsSUFBdUJRLEVBQUUsQ0FBQ3g1QyxNQUFILENBQVV2OEMsS0FBekMsS0FBbURuTCxDQUFDLEdBQUdraEcsRUFBRSxDQUFDeDVDLE1BQUgsQ0FBVTdyRCxLQUFWLENBQWdCLFVBQWhCLEVBQTRCLEtBQTVCLENBQXZELENBQUosRUFDRXFsRyxFQUFFLENBQUM1dEUsS0FBSCxDQUFTb3RFLFVBQVQsR0FBc0JRLEVBQUUsQ0FBQ3g1QyxNQUFILENBQVUzakQsR0FBVixHQUFnQi9ELENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS25TLE1BQTNDO1lBQ0YsT0FBT2d5RyxJQUFJLENBQUNtRixTQUFELENBQVg7V0FOSyxNQU9BLElBQUkzMkcsSUFBSSxJQUFJLFFBQVIsSUFBb0JBLElBQUksSUFBSSxRQUFoQyxFQUEwQztZQUMvQzZ5RyxFQUFFLENBQUNJLE1BQUgsR0FBWTVDLFVBQVUsR0FBRyxVQUFILEdBQWlCd0MsRUFBRSxDQUFDOXNHLEtBQUgsR0FBVyxXQUFsRDtZQUNBLE9BQU95ckcsSUFBSSxDQUFDbUYsU0FBRCxDQUFYO1dBRkssTUFHQSxJQUFJMzJHLElBQUksSUFBSSxnQkFBWixFQUE4QjtZQUNuQyxPQUFPd3hHLElBQUksQ0FBQ21GLFNBQUQsQ0FBWDtXQURLLE1BRUEsSUFBSWpHLElBQUksSUFBSW9ELFVBQVUsQ0FBQ3QyRyxLQUFELENBQXRCLEVBQStCO1lBQ3BDcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFDQSxPQUFPekIsSUFBSSxDQUFDeUUsT0FBRCxDQUFYO1dBRkssTUFHQSxJQUFJajJHLElBQUksSUFBSSxHQUFaLEVBQWlCO1lBQ3RCLE9BQU93eEcsSUFBSSxDQUFDMkIsVUFBRCxFQUFheUQsU0FBYixFQUF3QnZDLE1BQU0sQ0FBQyxHQUFELENBQTlCLEVBQXFDc0MsU0FBckMsQ0FBWDtXQURLLE1BRUEsSUFBSTMyRyxJQUFJLElBQUksUUFBWixFQUFzQjtZQUMzQixPQUFPd3hHLElBQUksQ0FBQzhELGlCQUFELEVBQW9CcUIsU0FBcEIsQ0FBWDtXQURLLE1BRUEsSUFBSW41RyxLQUFLLElBQUksR0FBYixFQUFrQjtZQUN2QnExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQ0EsT0FBT3pCLElBQUksQ0FBQ3lFLE9BQUQsQ0FBWDtXQUZLLE1BR0EsSUFBSWoyRyxJQUFJLElBQUksR0FBWixFQUFpQjtZQUN0QixPQUFPc3pHLElBQUksQ0FBQ3FELFNBQUQsQ0FBWDs7OztRQUdKLFNBQVNELFlBQVQsQ0FBc0IxMkcsSUFBdEIsRUFBNEI7VUFDMUIsSUFBSUEsSUFBSSxJQUFJLFVBQVosRUFBd0IsT0FBT3N6RyxJQUFJLENBQUNxRCxTQUFELENBQVg7VUFDeEI5RCxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1VBQ0EsT0FBT3pCLElBQUksQ0FBQ21ELFdBQUQsQ0FBWDs7O1FBRUYsU0FBU2dDLFNBQVQsQ0FBbUIzMkcsSUFBbkIsRUFBeUI7VUFDdkIsSUFBSUEsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUM4RCxpQkFBRCxDQUFYO1VBQ2pCLElBQUl0MUcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3N6RyxJQUFJLENBQUNxQixXQUFELENBQVg7OztRQUVuQixTQUFTZSxRQUFULENBQWtCbUIsSUFBbEIsRUFBd0J4K0YsR0FBeEIsRUFBNkJ5K0YsR0FBN0IsRUFBa0M7VUFDaEMsU0FBU0MsT0FBVCxDQUFpQi8yRyxJQUFqQixFQUF1QnhDLEtBQXZCLEVBQThCO1lBQzVCLElBQUlzNUcsR0FBRyxHQUFHQSxHQUFHLENBQUNyK0YsT0FBSixDQUFZelksSUFBWixJQUFvQixDQUFDLENBQXhCLEdBQTRCQSxJQUFJLElBQUksR0FBM0MsRUFBZ0Q7Y0FDOUMsSUFBSXF6RyxHQUFHLEdBQUdSLEVBQUUsQ0FBQzV0RSxLQUFILENBQVM4c0UsT0FBbkI7Y0FDQSxJQUFJc0IsR0FBRyxDQUFDMXRFLElBQUosSUFBWSxNQUFoQixFQUF3QjB0RSxHQUFHLENBQUMzOUYsR0FBSixHQUFVLENBQUMyOUYsR0FBRyxDQUFDMzlGLEdBQUosSUFBVyxDQUFaLElBQWlCLENBQTNCO2NBQ3hCLE9BQU84N0YsSUFBSSxDQUFDLFVBQVN4eEcsSUFBVCxFQUFleEMsS0FBZixFQUFzQjtnQkFDaEMsSUFBSXdDLElBQUksSUFBSXFZLEdBQVIsSUFBZTdhLEtBQUssSUFBSTZhLEdBQTVCLEVBQWlDLE9BQU9pN0YsSUFBSSxFQUFYO2dCQUNqQyxPQUFPQSxJQUFJLENBQUN1RCxJQUFELENBQVg7ZUFGUyxFQUdSRSxPQUhRLENBQVg7OztZQUtGLElBQUkvMkcsSUFBSSxJQUFJcVksR0FBUixJQUFlN2EsS0FBSyxJQUFJNmEsR0FBNUIsRUFBaUMsT0FBT201RixJQUFJLEVBQVg7WUFDakMsSUFBSXNGLEdBQUcsSUFBSUEsR0FBRyxDQUFDcitGLE9BQUosQ0FBWSxHQUFaLElBQW1CLENBQUMsQ0FBL0IsRUFBa0MsT0FBTzY2RixJQUFJLENBQUN1RCxJQUFELENBQVg7WUFDbEMsT0FBT3JGLElBQUksQ0FBQzZDLE1BQU0sQ0FBQ2g4RixHQUFELENBQVAsQ0FBWDs7O1VBRUYsT0FBTyxVQUFTclksSUFBVCxFQUFleEMsS0FBZixFQUFzQjtZQUMzQixJQUFJd0MsSUFBSSxJQUFJcVksR0FBUixJQUFlN2EsS0FBSyxJQUFJNmEsR0FBNUIsRUFBaUMsT0FBT201RixJQUFJLEVBQVg7WUFDakMsT0FBTzhCLElBQUksQ0FBQ3VELElBQUQsRUFBT0UsT0FBUCxDQUFYO1dBRkY7OztRQUtGLFNBQVNmLFlBQVQsQ0FBc0JhLElBQXRCLEVBQTRCeCtGLEdBQTVCLEVBQWlDc3RCLElBQWpDLEVBQXVDO1VBQ3JDLEtBQUssSUFBSS9qQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHL0IsU0FBUyxDQUFDTCxNQUE5QixFQUFzQ29DLENBQUMsRUFBdkM7WUFDRWl4RyxFQUFFLENBQUNHLEVBQUgsQ0FBTXowRyxJQUFOLENBQVdzQixTQUFTLENBQUMrQixDQUFELENBQXBCOzs7VUFDRixPQUFPNHZHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQzk3RixHQUFELEVBQU1zdEIsSUFBTixDQUFSLEVBQXFCK3ZFLFFBQVEsQ0FBQ21CLElBQUQsRUFBT3grRixHQUFQLENBQTdCLEVBQTBDKzdGLE1BQTFDLENBQVg7OztRQUVGLFNBQVNYLEtBQVQsQ0FBZXp6RyxJQUFmLEVBQXFCO1VBQ25CLElBQUlBLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxFQUFYO1VBQ2pCLE9BQU84QixJQUFJLENBQUNGLFNBQUQsRUFBWUssS0FBWixDQUFYOzs7UUFFRixTQUFTbUQsU0FBVCxDQUFtQjUyRyxJQUFuQixFQUF5QnhDLEtBQXpCLEVBQWdDO1VBQzlCLElBQUlrekcsSUFBSixFQUFVO1lBQ1IsSUFBSTF3RyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDtZQUNqQixJQUFJdjNHLEtBQUssSUFBSSxHQUFiLEVBQWtCLE9BQU9nMEcsSUFBSSxDQUFDb0YsU0FBRCxDQUFYOzs7O1FBR3RCLFNBQVNJLGFBQVQsQ0FBdUJoM0csSUFBdkIsRUFBNkJ4QyxLQUE3QixFQUFvQztVQUNsQyxJQUFJa3pHLElBQUksS0FBSzF3RyxJQUFJLElBQUksR0FBUixJQUFleEMsS0FBSyxJQUFJLElBQTdCLENBQVIsRUFBNEMsT0FBT2cwRyxJQUFJLENBQUN1RCxRQUFELENBQVg7OztRQUU5QyxTQUFTa0MsWUFBVCxDQUFzQmozRyxJQUF0QixFQUE0QjtVQUMxQixJQUFJMHdHLElBQUksSUFBSTF3RyxJQUFJLElBQUksR0FBcEIsRUFBeUI7WUFDdkIsSUFBSTZ5RyxFQUFFLENBQUN4NUMsTUFBSCxDQUFVN3JELEtBQVYsQ0FBZ0IsZ0JBQWhCLEVBQWtDLEtBQWxDLENBQUosRUFBOEMsT0FBT2drRyxJQUFJLENBQUMyQixVQUFELEVBQWErRCxJQUFiLEVBQW1CbkMsUUFBbkIsQ0FBWCxDQUE5QyxLQUNLLE9BQU92RCxJQUFJLENBQUN1RCxRQUFELENBQVg7Ozs7UUFHVCxTQUFTbUMsSUFBVCxDQUFjVCxDQUFkLEVBQWlCajVHLEtBQWpCLEVBQXdCO1VBQ3RCLElBQUlBLEtBQUssSUFBSSxJQUFiLEVBQW1CO1lBQ2pCcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFDQSxPQUFPekIsSUFBSSxFQUFYOzs7O1FBR0osU0FBU3VELFFBQVQsQ0FBa0IvMEcsSUFBbEIsRUFBd0J4QyxLQUF4QixFQUErQjtVQUM3QixJQUFJQSxLQUFLLElBQUksT0FBVCxJQUFvQkEsS0FBSyxJQUFJLFFBQTdCLElBQXlDQSxLQUFLLElBQUksT0FBbEQsSUFBNkRBLEtBQUssSUFBSSxVQUExRSxFQUFzRjtZQUNwRnExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQ0EsT0FBT3pCLElBQUksQ0FBQ2gwRyxLQUFLLElBQUksUUFBVCxHQUFvQjgzRyxpQkFBcEIsR0FBd0NQLFFBQXpDLENBQVg7OztVQUVGLElBQUkvMEcsSUFBSSxJQUFJLFVBQVIsSUFBc0J4QyxLQUFLLElBQUksTUFBbkMsRUFBMkM7WUFDekNxMUcsRUFBRSxDQUFDSSxNQUFILEdBQVksTUFBWjtZQUNBLE9BQU96QixJQUFJLENBQUMyRixTQUFELENBQVg7OztVQUVGLElBQUkzNUcsS0FBSyxJQUFJLEdBQVQsSUFBZ0JBLEtBQUssSUFBSSxHQUE3QixFQUFrQyxPQUFPZzBHLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDtVQUNsQyxJQUFJLzBHLElBQUksSUFBSSxRQUFSLElBQW9CQSxJQUFJLElBQUksUUFBNUIsSUFBd0NBLElBQUksSUFBSSxNQUFwRCxFQUE0RCxPQUFPd3hHLElBQUksQ0FBQzJGLFNBQUQsQ0FBWDtVQUM1RCxJQUFJbjNHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLEdBQUQsQ0FBUixFQUFldUIsUUFBUSxDQUFDWCxRQUFELEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUF2QixFQUE2Q1gsTUFBN0MsRUFBcUQrQyxTQUFyRCxDQUFYO1VBQ2pCLElBQUluM0csSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUMyQyxPQUFPLENBQUMsR0FBRCxDQUFSLEVBQWVpRCxTQUFmLEVBQTBCaEQsTUFBMUIsRUFBa0MrQyxTQUFsQyxDQUFYO1VBQ2pCLElBQUluM0csSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUNrRSxRQUFRLENBQUMyQixPQUFELEVBQVUsR0FBVixDQUFULEVBQXlCQyxlQUF6QixFQUEwQ0gsU0FBMUMsQ0FBWDtVQUNqQixJQUFJbjNHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDa0UsUUFBUSxDQUFDWCxRQUFELEVBQVcsR0FBWCxDQUFULEVBQTBCQSxRQUExQixDQUFYOztVQUNqQixJQUFJLzBHLElBQUksSUFBSSxPQUFaLEVBQXFCO1lBQUUsT0FBT3N6RyxJQUFJLENBQUNpRSxTQUFELEVBQVlKLFNBQVosQ0FBWDs7OztRQUV6QixTQUFTRyxlQUFULENBQXlCdDNHLElBQXpCLEVBQStCO1VBQzdCLElBQUlBLElBQUksSUFBSSxJQUFaLEVBQWtCLE9BQU93eEcsSUFBSSxDQUFDdUQsUUFBRCxDQUFYOzs7UUFFcEIsU0FBU3FDLFNBQVQsQ0FBbUJwM0csSUFBbkIsRUFBeUI7VUFDdkIsSUFBSUEsSUFBSSxDQUFDd04sS0FBTCxDQUFXLFVBQVgsQ0FBSixFQUE0QixPQUFPZ2tHLElBQUksRUFBWDtVQUM1QixJQUFJeHhHLElBQUksSUFBSSxHQUFSLElBQWVBLElBQUksSUFBSSxHQUEzQixFQUFnQyxPQUFPd3hHLElBQUksQ0FBQzRGLFNBQUQsQ0FBWDtVQUNoQyxPQUFPOUQsSUFBSSxDQUFDa0UsUUFBRCxFQUFXSixTQUFYLENBQVg7OztRQUVGLFNBQVNJLFFBQVQsQ0FBa0J4M0csSUFBbEIsRUFBd0J4QyxLQUF4QixFQUErQjtVQUM3QixJQUFJd0MsSUFBSSxJQUFJLFVBQVIsSUFBc0I2eUcsRUFBRSxDQUFDOXNHLEtBQUgsSUFBWSxTQUF0QyxFQUFpRDtZQUMvQzhzRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1lBQ0EsT0FBT3pCLElBQUksQ0FBQ2dHLFFBQUQsQ0FBWDtXQUZGLE1BR08sSUFBSWg2RyxLQUFLLElBQUksR0FBVCxJQUFnQndDLElBQUksSUFBSSxRQUF4QixJQUFvQ0EsSUFBSSxJQUFJLFFBQWhELEVBQTBEO1lBQy9ELE9BQU93eEcsSUFBSSxDQUFDZ0csUUFBRCxDQUFYO1dBREssTUFFQSxJQUFJeDNHLElBQUksSUFBSSxHQUFaLEVBQWlCO1lBQ3RCLE9BQU93eEcsSUFBSSxDQUFDdUQsUUFBRCxDQUFYO1dBREssTUFFQSxJQUFJLzBHLElBQUksSUFBSSxHQUFaLEVBQWlCO1lBQ3RCLE9BQU93eEcsSUFBSSxDQUFDNkMsTUFBTSxDQUFDLFVBQUQsQ0FBUCxFQUFxQjJDLGFBQXJCLEVBQW9DM0MsTUFBTSxDQUFDLEdBQUQsQ0FBMUMsRUFBaURtRCxRQUFqRCxDQUFYO1dBREssTUFFQSxJQUFJeDNHLElBQUksSUFBSSxHQUFaLEVBQWlCO1lBQ3RCLE9BQU9zekcsSUFBSSxDQUFDbUUsWUFBRCxFQUFlRCxRQUFmLENBQVg7V0FESyxNQUVBLElBQUksQ0FBQ3gzRyxJQUFJLENBQUN3TixLQUFMLENBQVcsWUFBWCxDQUFMLEVBQStCO1lBQ3BDLE9BQU9na0csSUFBSSxFQUFYOzs7O1FBR0osU0FBUytGLFNBQVQsQ0FBbUJ2M0csSUFBbkIsRUFBeUJ4QyxLQUF6QixFQUFnQztVQUM5QixJQUFJd0MsSUFBSSxJQUFJLE9BQVosRUFBcUIsT0FBT3N6RyxJQUFJLEVBQVg7VUFDckIsSUFBSTkxRyxLQUFLLENBQUN5RixLQUFOLENBQVl6RixLQUFLLENBQUNnQyxNQUFOLEdBQWUsQ0FBM0IsS0FBaUMsSUFBckMsRUFBMkMsT0FBT2d5RyxJQUFJLENBQUMrRixTQUFELENBQVg7VUFDM0MsT0FBTy9GLElBQUksQ0FBQ3VELFFBQUQsRUFBVzJDLGlCQUFYLENBQVg7OztRQUVGLFNBQVNBLGlCQUFULENBQTJCMTNHLElBQTNCLEVBQWlDO1VBQy9CLElBQUlBLElBQUksSUFBSSxHQUFaLEVBQWlCO1lBQ2Y2eUcsRUFBRSxDQUFDSSxNQUFILEdBQVksVUFBWjtZQUNBSixFQUFFLENBQUM1dEUsS0FBSCxDQUFTeXNFLFFBQVQsR0FBb0JJLFVBQXBCO1lBQ0EsT0FBT04sSUFBSSxDQUFDK0YsU0FBRCxDQUFYOzs7O1FBR0osU0FBU0YsT0FBVCxDQUFpQnIzRyxJQUFqQixFQUF1QnhDLEtBQXZCLEVBQThCO1VBQzVCLElBQUl3QyxJQUFJLElBQUksVUFBUixJQUFzQjZ5RyxFQUFFLENBQUN4NUMsTUFBSCxDQUFVN3JELEtBQVYsQ0FBZ0IsVUFBaEIsRUFBNEIsS0FBNUIsQ0FBdEIsSUFBNERoUSxLQUFLLElBQUksR0FBekUsRUFBOEUsT0FBT2cwRyxJQUFJLENBQUM2RixPQUFELENBQVg7VUFDOUUsSUFBSXIzRyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDtVQUNqQixJQUFJLzBHLElBQUksSUFBSSxRQUFaLEVBQXNCLE9BQU93eEcsSUFBSSxDQUFDNkYsT0FBRCxDQUFYO1VBQ3RCLE9BQU8vRCxJQUFJLENBQUN5QixRQUFELENBQVg7OztRQUVGLFNBQVNvQyxTQUFULENBQW1CbjNHLElBQW5CLEVBQXlCeEMsS0FBekIsRUFBZ0M7VUFDOUIsSUFBSUEsS0FBSyxJQUFJLEdBQWIsRUFBa0IsT0FBT2cwRyxJQUFJLENBQUMyQyxPQUFPLENBQUMsR0FBRCxDQUFSLEVBQWV1QixRQUFRLENBQUNYLFFBQUQsRUFBVyxHQUFYLENBQXZCLEVBQXdDWCxNQUF4QyxFQUFnRCtDLFNBQWhELENBQVg7VUFDbEIsSUFBSTM1RyxLQUFLLElBQUksR0FBVCxJQUFnQndDLElBQUksSUFBSSxHQUF4QixJQUErQnhDLEtBQUssSUFBSSxHQUE1QyxFQUFpRCxPQUFPZzBHLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDtVQUNqRCxJQUFJLzBHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDdUQsUUFBRCxFQUFXVixNQUFNLENBQUMsR0FBRCxDQUFqQixFQUF3QjhDLFNBQXhCLENBQVg7O1VBQ2pCLElBQUkzNUcsS0FBSyxJQUFJLFNBQVQsSUFBc0JBLEtBQUssSUFBSSxZQUFuQyxFQUFpRDtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDs7O1VBQzFFLElBQUl2M0csS0FBSyxJQUFJLEdBQWIsRUFBa0IsT0FBT2cwRyxJQUFJLENBQUN1RCxRQUFELEVBQVdWLE1BQU0sQ0FBQyxHQUFELENBQWpCLEVBQXdCVSxRQUF4QixDQUFYOzs7UUFFcEIsU0FBU3lCLGFBQVQsQ0FBdUJDLENBQXZCLEVBQTBCajVHLEtBQTFCLEVBQWlDO1VBQy9CLElBQUlBLEtBQUssSUFBSSxHQUFiLEVBQWtCLE9BQU9nMEcsSUFBSSxDQUFDMkMsT0FBTyxDQUFDLEdBQUQsQ0FBUixFQUFldUIsUUFBUSxDQUFDWCxRQUFELEVBQVcsR0FBWCxDQUF2QixFQUF3Q1gsTUFBeEMsRUFBZ0QrQyxTQUFoRCxDQUFYOzs7UUFFcEIsU0FBU1EsU0FBVCxHQUFxQjtVQUNuQixPQUFPckUsSUFBSSxDQUFDeUIsUUFBRCxFQUFXNkMsZ0JBQVgsQ0FBWDs7O1FBRUYsU0FBU0EsZ0JBQVQsQ0FBMEJuQixDQUExQixFQUE2Qmo1RyxLQUE3QixFQUFvQztVQUNsQyxJQUFJQSxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQ3VELFFBQUQsQ0FBWDs7O1FBRXBCLFNBQVNSLE1BQVQsQ0FBZ0JrQyxDQUFoQixFQUFtQmo1RyxLQUFuQixFQUEwQjtVQUN4QixJQUFJQSxLQUFLLElBQUksTUFBYixFQUFxQjtZQUFDcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQ3FELE9BQUQsQ0FBWDs7O1VBQzdDLE9BQU92QixJQUFJLENBQUNoL0MsT0FBRCxFQUFVc2lELFNBQVYsRUFBcUJpQixXQUFyQixFQUFrQ0MsVUFBbEMsQ0FBWDs7O1FBRUYsU0FBU3hqRCxPQUFULENBQWlCdDBELElBQWpCLEVBQXVCeEMsS0FBdkIsRUFBOEI7VUFDNUIsSUFBSWt6RyxJQUFJLElBQUlvRCxVQUFVLENBQUN0MkcsS0FBRCxDQUF0QixFQUErQjtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQ2w5QyxPQUFELENBQVg7OztVQUN4RCxJQUFJdDBELElBQUksSUFBSSxVQUFaLEVBQXdCO1lBQUV3ekcsUUFBUSxDQUFDaDJHLEtBQUQsQ0FBUjtZQUFpQixPQUFPZzBHLElBQUksRUFBWDs7O1VBQzNDLElBQUl4eEcsSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBT3d4RyxJQUFJLENBQUNsOUMsT0FBRCxDQUFYO1VBQ3RCLElBQUl0MEQsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT2cyRyxZQUFZLENBQUMrQixVQUFELEVBQWEsR0FBYixDQUFuQjtVQUNqQixJQUFJLzNHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU9nMkcsWUFBWSxDQUFDZ0MsV0FBRCxFQUFjLEdBQWQsQ0FBbkI7OztRQUVuQixTQUFTQSxXQUFULENBQXFCaDRHLElBQXJCLEVBQTJCeEMsS0FBM0IsRUFBa0M7VUFDaEMsSUFBSXdDLElBQUksSUFBSSxVQUFSLElBQXNCLENBQUM2eUcsRUFBRSxDQUFDeDVDLE1BQUgsQ0FBVTdyRCxLQUFWLENBQWdCLE9BQWhCLEVBQXlCLEtBQXpCLENBQTNCLEVBQTREO1lBQzFEZ21HLFFBQVEsQ0FBQ2gyRyxLQUFELENBQVI7WUFDQSxPQUFPZzBHLElBQUksQ0FBQ3FHLFdBQUQsQ0FBWDs7O1VBRUYsSUFBSTczRyxJQUFJLElBQUksVUFBWixFQUF3QjZ5RyxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1VBQ3hCLElBQUlqekcsSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBT3d4RyxJQUFJLENBQUNsOUMsT0FBRCxDQUFYO1VBQ3RCLElBQUl0MEQsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3N6RyxJQUFJLEVBQVg7VUFDakIsSUFBSXR6RyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQzJCLFVBQUQsRUFBYWtCLE1BQU0sQ0FBQyxHQUFELENBQW5CLEVBQTBCQSxNQUFNLENBQUMsR0FBRCxDQUFoQyxFQUF1QzJELFdBQXZDLENBQVg7VUFDakIsT0FBT3hHLElBQUksQ0FBQzZDLE1BQU0sQ0FBQyxHQUFELENBQVAsRUFBYy8vQyxPQUFkLEVBQXVCdWpELFdBQXZCLENBQVg7OztRQUVGLFNBQVNFLFVBQVQsR0FBc0I7VUFDcEIsT0FBT3pFLElBQUksQ0FBQ2gvQyxPQUFELEVBQVV1akQsV0FBVixDQUFYOzs7UUFFRixTQUFTQSxXQUFULENBQXFCSSxLQUFyQixFQUE0Qno2RyxLQUE1QixFQUFtQztVQUNqQyxJQUFJQSxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzhELGlCQUFELENBQVg7OztRQUVwQixTQUFTd0MsVUFBVCxDQUFvQjkzRyxJQUFwQixFQUEwQjtVQUN4QixJQUFJQSxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksQ0FBQytDLE1BQUQsQ0FBWDs7O1FBRW5CLFNBQVNHLFNBQVQsQ0FBbUIxMEcsSUFBbkIsRUFBeUJ4QyxLQUF6QixFQUFnQztVQUM5QixJQUFJd0MsSUFBSSxJQUFJLFdBQVIsSUFBdUJ4QyxLQUFLLElBQUksTUFBcEMsRUFBNEMsT0FBT2cwRyxJQUFJLENBQUMyQyxPQUFPLENBQUMsTUFBRCxFQUFTLE1BQVQsQ0FBUixFQUEwQmYsU0FBMUIsRUFBcUNnQixNQUFyQyxDQUFYOzs7UUFFOUMsU0FBU1EsT0FBVCxDQUFpQjUwRyxJQUFqQixFQUF1QnhDLEtBQXZCLEVBQThCO1VBQzVCLElBQUlBLEtBQUssSUFBSSxPQUFiLEVBQXNCLE9BQU9nMEcsSUFBSSxDQUFDb0QsT0FBRCxDQUFYO1VBQ3RCLElBQUk1MEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUMyQyxPQUFPLENBQUMsR0FBRCxDQUFSLEVBQWUrRCxRQUFmLEVBQXlCOUQsTUFBekIsQ0FBWDs7O1FBRW5CLFNBQVM4RCxRQUFULENBQWtCbDRHLElBQWxCLEVBQXdCO1VBQ3RCLElBQUlBLElBQUksSUFBSSxLQUFaLEVBQW1CLE9BQU93eEcsSUFBSSxDQUFDK0MsTUFBRCxFQUFTNEQsUUFBVCxDQUFYO1VBQ25CLElBQUluNEcsSUFBSSxJQUFJLFVBQVosRUFBd0IsT0FBT3d4RyxJQUFJLENBQUMyRyxRQUFELENBQVg7VUFDeEIsT0FBTzdFLElBQUksQ0FBQzZFLFFBQUQsQ0FBWDs7O1FBRUYsU0FBU0EsUUFBVCxDQUFrQm40RyxJQUFsQixFQUF3QnhDLEtBQXhCLEVBQStCO1VBQzdCLElBQUl3QyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPd3hHLElBQUksRUFBWDtVQUNqQixJQUFJeHhHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDMkcsUUFBRCxDQUFYOztVQUNqQixJQUFJMzZHLEtBQUssSUFBSSxJQUFULElBQWlCQSxLQUFLLElBQUksSUFBOUIsRUFBb0M7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUMyQixVQUFELEVBQWFnRixRQUFiLENBQVg7OztVQUM3RCxPQUFPN0UsSUFBSSxDQUFDSCxVQUFELEVBQWFnRixRQUFiLENBQVg7OztRQUVGLFNBQVN4RCxXQUFULENBQXFCMzBHLElBQXJCLEVBQTJCeEMsS0FBM0IsRUFBa0M7VUFDaEMsSUFBSUEsS0FBSyxJQUFJLEdBQWIsRUFBa0I7WUFBQ3ExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUNtRCxXQUFELENBQVg7OztVQUMxQyxJQUFJMzBHLElBQUksSUFBSSxVQUFaLEVBQXdCO1lBQUN3ekcsUUFBUSxDQUFDaDJHLEtBQUQsQ0FBUjtZQUFpQixPQUFPZzBHLElBQUksQ0FBQ21ELFdBQUQsQ0FBWDs7O1VBQzFDLElBQUkzMEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUN3QyxXQUFELEVBQWNHLE9BQU8sQ0FBQyxHQUFELENBQXJCLEVBQTRCdUIsUUFBUSxDQUFDTixNQUFELEVBQVMsR0FBVCxDQUFwQyxFQUFtRGhCLE1BQW5ELEVBQTJENkMsWUFBM0QsRUFBeUU3RCxTQUF6RSxFQUFvRmMsVUFBcEYsQ0FBWDtVQUNqQixJQUFJeEQsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxHQUFyQixFQUEwQixPQUFPZzBHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZXVCLFFBQVEsQ0FBQ2lDLFNBQUQsRUFBWSxHQUFaLENBQXZCLEVBQXlDdkQsTUFBekMsRUFBaURPLFdBQWpELENBQVg7OztRQUU1QixTQUFTOEMsWUFBVCxDQUFzQnozRyxJQUF0QixFQUE0QnhDLEtBQTVCLEVBQW1DO1VBQ2pDLElBQUlBLEtBQUssSUFBSSxHQUFiLEVBQWtCO1lBQUNxMUcsRUFBRSxDQUFDSSxNQUFILEdBQVksU0FBWjtZQUF1QixPQUFPekIsSUFBSSxDQUFDaUcsWUFBRCxDQUFYOzs7VUFDMUMsSUFBSXozRyxJQUFJLElBQUksVUFBWixFQUF3QjtZQUFDd3pHLFFBQVEsQ0FBQ2gyRyxLQUFELENBQVI7WUFBaUIsT0FBT2cwRyxJQUFJLENBQUNpRyxZQUFELENBQVg7OztVQUMxQyxJQUFJejNHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDd0MsV0FBRCxFQUFjRyxPQUFPLENBQUMsR0FBRCxDQUFyQixFQUE0QnVCLFFBQVEsQ0FBQ04sTUFBRCxFQUFTLEdBQVQsQ0FBcEMsRUFBbURoQixNQUFuRCxFQUEyRDZDLFlBQTNELEVBQXlFL0MsVUFBekUsQ0FBWDtVQUNqQixJQUFJeEQsSUFBSSxJQUFJbHpHLEtBQUssSUFBSSxHQUFyQixFQUEwQixPQUFPZzBHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZXVCLFFBQVEsQ0FBQ2lDLFNBQUQsRUFBWSxHQUFaLENBQXZCLEVBQXlDdkQsTUFBekMsRUFBaURxRCxZQUFqRCxDQUFYOzs7UUFFNUIsU0FBUzNDLFFBQVQsQ0FBa0I5MEcsSUFBbEIsRUFBd0J4QyxLQUF4QixFQUErQjtVQUM3QixJQUFJd0MsSUFBSSxJQUFJLFNBQVIsSUFBcUJBLElBQUksSUFBSSxVQUFqQyxFQUE2QztZQUMzQzZ5RyxFQUFFLENBQUNJLE1BQUgsR0FBWSxNQUFaO1lBQ0EsT0FBT3pCLElBQUksQ0FBQ3NELFFBQUQsQ0FBWDtXQUZGLE1BR08sSUFBSXQzRyxLQUFLLElBQUksR0FBYixFQUFrQjtZQUN2QixPQUFPZzBHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZXVCLFFBQVEsQ0FBQ2lDLFNBQUQsRUFBWSxHQUFaLENBQXZCLEVBQXlDdkQsTUFBekMsQ0FBWDs7OztRQUdKLFNBQVNnQixNQUFULENBQWdCcDFHLElBQWhCLEVBQXNCeEMsS0FBdEIsRUFBNkI7VUFDM0IsSUFBSUEsS0FBSyxJQUFJLEdBQWIsRUFBa0JnMEcsSUFBSSxDQUFDMkIsVUFBRCxFQUFhaUMsTUFBYixDQUFKO1VBQ2xCLElBQUlwMUcsSUFBSSxJQUFJLFFBQVosRUFBc0IsT0FBT3d4RyxJQUFJLENBQUM0RCxNQUFELENBQVg7O1VBQ3RCLElBQUkxRSxJQUFJLElBQUlvRCxVQUFVLENBQUN0MkcsS0FBRCxDQUF0QixFQUErQjtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQzRELE1BQUQsQ0FBWDs7O1VBQ3hELElBQUkxRSxJQUFJLElBQUkxd0csSUFBSSxJQUFJLE1BQXBCLEVBQTRCLE9BQU93eEcsSUFBSSxDQUFDb0YsU0FBRCxFQUFZaUIsV0FBWixDQUFYO1VBQzVCLE9BQU92RSxJQUFJLENBQUNoL0MsT0FBRCxFQUFVc2lELFNBQVYsRUFBcUJpQixXQUFyQixDQUFYOzs7UUFFRixTQUFTL0IsZUFBVCxDQUF5QjkxRyxJQUF6QixFQUErQnhDLEtBQS9CLEVBQXNDOztVQUVwQyxJQUFJd0MsSUFBSSxJQUFJLFVBQVosRUFBd0IsT0FBT2tuRCxTQUFTLENBQUNsbkQsSUFBRCxFQUFPeEMsS0FBUCxDQUFoQjtVQUN4QixPQUFPNDZHLGNBQWMsQ0FBQ3A0RyxJQUFELEVBQU94QyxLQUFQLENBQXJCOzs7UUFFRixTQUFTMHBELFNBQVQsQ0FBbUJsbkQsSUFBbkIsRUFBeUJ4QyxLQUF6QixFQUFnQztVQUM5QixJQUFJd0MsSUFBSSxJQUFJLFVBQVosRUFBd0I7WUFBQ3d6RyxRQUFRLENBQUNoMkcsS0FBRCxDQUFSO1lBQWlCLE9BQU9nMEcsSUFBSSxDQUFDNEcsY0FBRCxDQUFYOzs7O1FBRTVDLFNBQVNBLGNBQVQsQ0FBd0JwNEcsSUFBeEIsRUFBOEJ4QyxLQUE5QixFQUFxQztVQUNuQyxJQUFJQSxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzJDLE9BQU8sQ0FBQyxHQUFELENBQVIsRUFBZXVCLFFBQVEsQ0FBQ2lDLFNBQUQsRUFBWSxHQUFaLENBQXZCLEVBQXlDdkQsTUFBekMsRUFBaURnRSxjQUFqRCxDQUFYOztVQUNsQixJQUFJNTZHLEtBQUssSUFBSSxTQUFULElBQXNCQSxLQUFLLElBQUksWUFBL0IsSUFBZ0RrekcsSUFBSSxJQUFJMXdHLElBQUksSUFBSSxHQUFwRSxFQUEwRTtZQUN4RSxJQUFJeEMsS0FBSyxJQUFJLFlBQWIsRUFBMkJxMUcsRUFBRSxDQUFDSSxNQUFILEdBQVksU0FBWjtZQUMzQixPQUFPekIsSUFBSSxDQUFDZCxJQUFJLEdBQUdxRSxRQUFILEdBQWM1QixVQUFuQixFQUErQmlGLGNBQS9CLENBQVg7OztVQUVGLElBQUlwNEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUMyQyxPQUFPLENBQUMsR0FBRCxDQUFSLEVBQWVrRSxTQUFmLEVBQTBCakUsTUFBMUIsQ0FBWDs7O1FBRW5CLFNBQVNpRSxTQUFULENBQW1CcjRHLElBQW5CLEVBQXlCeEMsS0FBekIsRUFBZ0M7VUFDOUIsSUFBSXdDLElBQUksSUFBSSxPQUFSLElBQ0NBLElBQUksSUFBSSxVQUFSLEtBQ0N4QyxLQUFLLElBQUksUUFBVCxJQUFxQkEsS0FBSyxJQUFJLEtBQTlCLElBQXVDQSxLQUFLLElBQUksS0FBaEQsSUFBMERrekcsSUFBSSxJQUFJb0QsVUFBVSxDQUFDdDJHLEtBQUQsQ0FEN0UsS0FFQXExRyxFQUFFLENBQUN4NUMsTUFBSCxDQUFVN3JELEtBQVYsQ0FBZ0Isc0JBQWhCLEVBQXdDLEtBQXhDLENBSEwsRUFHc0Q7WUFDcERxbEcsRUFBRSxDQUFDSSxNQUFILEdBQVksU0FBWjtZQUNBLE9BQU96QixJQUFJLENBQUM2RyxTQUFELENBQVg7OztVQUVGLElBQUlyNEcsSUFBSSxJQUFJLFVBQVIsSUFBc0I2eUcsRUFBRSxDQUFDOXNHLEtBQUgsSUFBWSxTQUF0QyxFQUFpRDtZQUMvQzhzRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxVQUFaO1lBQ0EsT0FBT3pCLElBQUksQ0FBQzhHLFVBQUQsRUFBYUQsU0FBYixDQUFYOzs7VUFFRixJQUFJcjRHLElBQUksSUFBSSxRQUFSLElBQW9CQSxJQUFJLElBQUksUUFBaEMsRUFBMEMsT0FBT3d4RyxJQUFJLENBQUM4RyxVQUFELEVBQWFELFNBQWIsQ0FBWDtVQUMxQyxJQUFJcjRHLElBQUksSUFBSSxHQUFaLEVBQ0UsT0FBT3d4RyxJQUFJLENBQUMyQixVQUFELEVBQWF5RCxTQUFiLEVBQXdCdkMsTUFBTSxDQUFDLEdBQUQsQ0FBOUIsRUFBcUNpRSxVQUFyQyxFQUFpREQsU0FBakQsQ0FBWDs7VUFDRixJQUFJNzZHLEtBQUssSUFBSSxHQUFiLEVBQWtCO1lBQ2hCcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFDQSxPQUFPekIsSUFBSSxDQUFDNkcsU0FBRCxDQUFYOzs7VUFFRixJQUFJM0gsSUFBSSxJQUFJMXdHLElBQUksSUFBSSxHQUFwQixFQUF5QixPQUFPc3pHLElBQUksQ0FBQ21FLFlBQUQsRUFBZVksU0FBZixDQUFYO1VBQ3pCLElBQUlyNEcsSUFBSSxJQUFJLEdBQVIsSUFBZUEsSUFBSSxJQUFJLEdBQTNCLEVBQWdDLE9BQU93eEcsSUFBSSxDQUFDNkcsU0FBRCxDQUFYO1VBQ2hDLElBQUlyNEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLEVBQVg7VUFDakIsSUFBSWgwRyxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzJCLFVBQUQsRUFBYWtGLFNBQWIsQ0FBWDs7O1FBRXBCLFNBQVNDLFVBQVQsQ0FBb0J0NEcsSUFBcEIsRUFBMEJ4QyxLQUExQixFQUFpQztVQUMvQixJQUFJQSxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzhHLFVBQUQsQ0FBWDtVQUNsQixJQUFJOTZHLEtBQUssSUFBSSxHQUFiLEVBQWtCLE9BQU9nMEcsSUFBSSxDQUFDOEcsVUFBRCxDQUFYO1VBQ2xCLElBQUl0NEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLENBQUN1RCxRQUFELEVBQVc4QyxXQUFYLENBQVg7VUFDakIsSUFBSXI2RyxLQUFLLElBQUksR0FBYixFQUFrQixPQUFPZzBHLElBQUksQ0FBQzhELGlCQUFELENBQVg7VUFDbEIsSUFBSW45RixPQUFPLEdBQUcwNkYsRUFBRSxDQUFDNXRFLEtBQUgsQ0FBUzhzRSxPQUFULENBQWlCN2pGLElBQS9CO2NBQXFDcXFGLFdBQVcsR0FBR3BnRyxPQUFPLElBQUlBLE9BQU8sQ0FBQ3d0QixJQUFSLElBQWdCLFdBQTlFO1VBQ0EsT0FBTzJ0RSxJQUFJLENBQUNpRixXQUFXLEdBQUdkLFlBQUgsR0FBa0I5QyxXQUE5QixDQUFYOzs7UUFFRixTQUFTTyxXQUFULENBQXFCbDFHLElBQXJCLEVBQTJCeEMsS0FBM0IsRUFBa0M7VUFDaEMsSUFBSUEsS0FBSyxJQUFJLEdBQWIsRUFBa0I7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUNnSCxTQUFELEVBQVluRSxNQUFNLENBQUMsR0FBRCxDQUFsQixDQUFYOzs7VUFDM0MsSUFBSTcyRyxLQUFLLElBQUksU0FBYixFQUF3QjtZQUFFcTFHLEVBQUUsQ0FBQ0ksTUFBSCxHQUFZLFNBQVo7WUFBdUIsT0FBT3pCLElBQUksQ0FBQzJCLFVBQUQsRUFBYWtCLE1BQU0sQ0FBQyxHQUFELENBQW5CLENBQVg7OztVQUNqRCxJQUFJcjBHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDa0UsUUFBUSxDQUFDK0MsV0FBRCxFQUFjLEdBQWQsQ0FBVCxFQUE2QkQsU0FBN0IsRUFBd0NuRSxNQUFNLENBQUMsR0FBRCxDQUE5QyxDQUFYO1VBQ2pCLE9BQU9mLElBQUksQ0FBQ0YsU0FBRCxDQUFYOzs7UUFFRixTQUFTcUYsV0FBVCxDQUFxQno0RyxJQUFyQixFQUEyQnhDLEtBQTNCLEVBQWtDO1VBQ2hDLElBQUlBLEtBQUssSUFBSSxJQUFiLEVBQW1CO1lBQUVxMUcsRUFBRSxDQUFDSSxNQUFILEdBQVksU0FBWjtZQUF1QixPQUFPekIsSUFBSSxDQUFDNkMsTUFBTSxDQUFDLFVBQUQsQ0FBUCxDQUFYOzs7VUFDNUMsSUFBSXIwRyxJQUFJLElBQUksVUFBWixFQUF3QixPQUFPc3pHLElBQUksQ0FBQ2dDLGlCQUFELEVBQW9CbUQsV0FBcEIsQ0FBWDs7O1FBRTFCLFNBQVN0RCxXQUFULENBQXFCbjFHLElBQXJCLEVBQTJCO1VBQ3pCLElBQUlBLElBQUksSUFBSSxRQUFaLEVBQXNCLE9BQU93eEcsSUFBSSxFQUFYO1VBQ3RCLElBQUl4eEcsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3N6RyxJQUFJLENBQUNILFVBQUQsQ0FBWDtVQUNqQixJQUFJbnpHLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU9zekcsSUFBSSxDQUFDdUMsa0JBQUQsQ0FBWDtVQUNqQixPQUFPdkMsSUFBSSxDQUFDb0YsVUFBRCxFQUFhQyxnQkFBYixFQUErQkgsU0FBL0IsQ0FBWDs7O1FBRUYsU0FBU0UsVUFBVCxDQUFvQjE0RyxJQUFwQixFQUEwQnhDLEtBQTFCLEVBQWlDO1VBQy9CLElBQUl3QyxJQUFJLElBQUksR0FBWixFQUFpQixPQUFPZzJHLFlBQVksQ0FBQzBDLFVBQUQsRUFBYSxHQUFiLENBQW5CO1VBQ2pCLElBQUkxNEcsSUFBSSxJQUFJLFVBQVosRUFBd0J3ekcsUUFBUSxDQUFDaDJHLEtBQUQsQ0FBUjtVQUN4QixJQUFJQSxLQUFLLElBQUksR0FBYixFQUFrQnExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1VBQ2xCLE9BQU96QixJQUFJLENBQUNvSCxPQUFELENBQVg7OztRQUVGLFNBQVNELGdCQUFULENBQTBCMzRHLElBQTFCLEVBQWdDO1VBQzlCLElBQUlBLElBQUksSUFBSSxHQUFaLEVBQWlCLE9BQU93eEcsSUFBSSxDQUFDa0gsVUFBRCxFQUFhQyxnQkFBYixDQUFYOzs7UUFFbkIsU0FBU0MsT0FBVCxDQUFpQlgsS0FBakIsRUFBd0J6NkcsS0FBeEIsRUFBK0I7VUFDN0IsSUFBSUEsS0FBSyxJQUFJLElBQWIsRUFBbUI7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUNrSCxVQUFELENBQVg7Ozs7UUFFOUMsU0FBU0YsU0FBVCxDQUFtQlAsS0FBbkIsRUFBMEJ6NkcsS0FBMUIsRUFBaUM7VUFDL0IsSUFBSUEsS0FBSyxJQUFJLE1BQWIsRUFBcUI7WUFBRXExRyxFQUFFLENBQUNJLE1BQUgsR0FBWSxTQUFaO1lBQXVCLE9BQU96QixJQUFJLENBQUMyQixVQUFELENBQVg7Ozs7UUFFaEQsU0FBUzRDLFlBQVQsQ0FBc0IvMUcsSUFBdEIsRUFBNEI7VUFDMUIsSUFBSUEsSUFBSSxJQUFJLEdBQVosRUFBaUIsT0FBT3d4RyxJQUFJLEVBQVg7VUFDakIsT0FBTzhCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ0osaUJBQUQsRUFBb0IsR0FBcEIsQ0FBVCxDQUFYOzs7UUFFRixTQUFTVCxPQUFULEdBQW1CO1VBQ2pCLE9BQU92QixJQUFJLENBQUNhLE9BQU8sQ0FBQyxNQUFELENBQVIsRUFBa0I3L0MsT0FBbEIsRUFBMkIrL0MsTUFBTSxDQUFDLEdBQUQsQ0FBakMsRUFBd0NGLE9BQU8sQ0FBQyxHQUFELENBQS9DLEVBQXNEdUIsUUFBUSxDQUFDbUQsVUFBRCxFQUFhLEdBQWIsQ0FBOUQsRUFBaUZ6RSxNQUFqRixFQUF5RkEsTUFBekYsQ0FBWDs7O1FBRUYsU0FBU3lFLFVBQVQsR0FBc0I7VUFDcEIsT0FBT3ZGLElBQUksQ0FBQ2gvQyxPQUFELEVBQVV1akQsV0FBVixDQUFYOzs7UUFHRixTQUFTaUIsb0JBQVQsQ0FBOEI3ekUsS0FBOUIsRUFBcUM4ekUsU0FBckMsRUFBZ0Q7VUFDOUMsT0FBTzl6RSxLQUFLLENBQUMrc0UsUUFBTixJQUFrQixVQUFsQixJQUFnQy9zRSxLQUFLLENBQUMrc0UsUUFBTixJQUFrQixHQUFsRCxJQUNMZCxjQUFjLENBQUM5a0csSUFBZixDQUFvQjJzRyxTQUFTLENBQUNoMkcsTUFBVixDQUFpQixDQUFqQixDQUFwQixDQURLLElBRUwsT0FBT3FKLElBQVAsQ0FBWTJzRyxTQUFTLENBQUNoMkcsTUFBVixDQUFpQixDQUFqQixDQUFaLENBRkY7OztRQUtGLFNBQVM4dUcsaUJBQVQsQ0FBMkJ4NEMsTUFBM0IsRUFBbUNwMEIsS0FBbkMsRUFBMENrdkIsTUFBMUMsRUFBa0Q7VUFDaEQsT0FBT2x2QixLQUFLLENBQUN5c0UsUUFBTixJQUFrQkQsU0FBbEIsSUFDTCxpRkFBaUZybEcsSUFBakYsQ0FBc0Y2NEIsS0FBSyxDQUFDK3NFLFFBQTVGLENBREssSUFFSi9zRSxLQUFLLENBQUMrc0UsUUFBTixJQUFrQixPQUFsQixJQUE2QixTQUFTNWxHLElBQVQsQ0FBY2l0RCxNQUFNLENBQUNockQsTUFBUCxDQUFjcEwsS0FBZCxDQUFvQixDQUFwQixFQUF1Qm8yRCxNQUFNLENBQUMzakQsR0FBUCxJQUFjeStDLE1BQU0sSUFBSSxDQUF4QixDQUF2QixDQUFkLENBRmhDO1NBNTBCK0Q7OztRQW0xQmpFLE9BQU87VUFDTGhCLFVBQVUsRUFBRSxvQkFBUzZsRCxVQUFULEVBQXFCO1lBQy9CLElBQUkvekUsS0FBSyxHQUFHO2NBQ1Z5c0UsUUFBUSxFQUFFRCxTQURBO2NBRVZPLFFBQVEsRUFBRSxLQUZBO2NBR1ZnQixFQUFFLEVBQUUsRUFITTtjQUlWakIsT0FBTyxFQUFFLElBQUlVLFNBQUosQ0FBYyxDQUFDdUcsVUFBVSxJQUFJLENBQWYsSUFBb0I1VixVQUFsQyxFQUE4QyxDQUE5QyxFQUFpRCxPQUFqRCxFQUEwRCxLQUExRCxDQUpDO2NBS1Z3UCxTQUFTLEVBQUV6QyxZQUFZLENBQUN5QyxTQUxkO2NBTVZ6NkYsT0FBTyxFQUFFZzRGLFlBQVksQ0FBQ3lDLFNBQWIsSUFBMEIsSUFBSXh2RSxPQUFKLENBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QixLQUF4QixDQU56QjtjQU9WbTNCLFFBQVEsRUFBRXkrQyxVQUFVLElBQUk7YUFQMUI7WUFTQSxJQUFJN0ksWUFBWSxDQUFDMEQsVUFBYixJQUEyQixPQUFPMUQsWUFBWSxDQUFDMEQsVUFBcEIsSUFBa0MsUUFBakUsRUFDRTV1RSxLQUFLLENBQUM0dUUsVUFBTixHQUFtQjFELFlBQVksQ0FBQzBELFVBQWhDO1lBQ0YsT0FBTzV1RSxLQUFQO1dBYkc7VUFnQkx3MEIsS0FBSyxFQUFFLGVBQVNKLE1BQVQsRUFBaUJwMEIsS0FBakIsRUFBd0I7WUFDN0IsSUFBSW8wQixNQUFNLENBQUN6RixHQUFQLEVBQUosRUFBa0I7Y0FDaEIsSUFBSSxDQUFDM3VCLEtBQUssQ0FBQzhzRSxPQUFOLENBQWN4MkcsY0FBZCxDQUE2QixPQUE3QixDQUFMLEVBQ0UwcEMsS0FBSyxDQUFDOHNFLE9BQU4sQ0FBY3Z4QixLQUFkLEdBQXNCLEtBQXRCO2NBQ0Z2N0MsS0FBSyxDQUFDczFCLFFBQU4sR0FBaUJsQixNQUFNLENBQUNoRixXQUFQLEVBQWpCO2NBQ0ErOUMsWUFBWSxDQUFDLzRDLE1BQUQsRUFBU3AwQixLQUFULENBQVo7OztZQUVGLElBQUlBLEtBQUssQ0FBQ3lzRSxRQUFOLElBQWtCRSxZQUFsQixJQUFrQ3Y0QyxNQUFNLENBQUNyRixRQUFQLEVBQXRDLEVBQXlELE9BQU8sSUFBUDtZQUN6RCxJQUFJanVELEtBQUssR0FBR2svQixLQUFLLENBQUN5c0UsUUFBTixDQUFlcjRDLE1BQWYsRUFBdUJwMEIsS0FBdkIsQ0FBWjtZQUNBLElBQUlqbEMsSUFBSSxJQUFJLFNBQVosRUFBdUIsT0FBTytGLEtBQVA7WUFDdkJrL0IsS0FBSyxDQUFDK3NFLFFBQU4sR0FBaUJoeUcsSUFBSSxJQUFJLFVBQVIsS0FBdUJ1ckMsT0FBTyxJQUFJLElBQVgsSUFBbUJBLE9BQU8sSUFBSSxJQUFyRCxJQUE2RCxRQUE3RCxHQUF3RXZyQyxJQUF6RjtZQUNBLE9BQU8reUcsT0FBTyxDQUFDOXRFLEtBQUQsRUFBUWwvQixLQUFSLEVBQWUvRixJQUFmLEVBQXFCdXJDLE9BQXJCLEVBQThCOHRCLE1BQTlCLENBQWQ7V0EzQkc7VUE4Qkw0cEMsTUFBTSxFQUFFLGdCQUFTaCtELEtBQVQsRUFBZ0I4ekUsU0FBaEIsRUFBMkI7WUFDakMsSUFBSTl6RSxLQUFLLENBQUN5c0UsUUFBTixJQUFrQkUsWUFBbEIsSUFBa0Mzc0UsS0FBSyxDQUFDeXNFLFFBQU4sSUFBa0JJLFVBQXhELEVBQW9FLE9BQU8vZixVQUFVLENBQUNyb0MsSUFBbEI7WUFDcEUsSUFBSXprQixLQUFLLENBQUN5c0UsUUFBTixJQUFrQkQsU0FBdEIsRUFBaUMsT0FBTyxDQUFQO1lBQ2pDLElBQUl3SCxTQUFTLEdBQUdGLFNBQVMsSUFBSUEsU0FBUyxDQUFDaDJHLE1BQVYsQ0FBaUIsQ0FBakIsQ0FBN0I7Z0JBQWtEZ3ZHLE9BQU8sR0FBRzlzRSxLQUFLLENBQUM4c0UsT0FBbEU7Z0JBQTJFejFELEdBQTNFLENBSGlDOztZQUtqQyxJQUFJLENBQUMsYUFBYWx3QyxJQUFiLENBQWtCMnNHLFNBQWxCLENBQUwsRUFBbUMsS0FBSyxJQUFJbjNHLENBQUMsR0FBR3FqQyxLQUFLLENBQUMrdEUsRUFBTixDQUFTeHpHLE1BQVQsR0FBa0IsQ0FBL0IsRUFBa0NvQyxDQUFDLElBQUksQ0FBdkMsRUFBMEMsRUFBRUEsQ0FBNUMsRUFBK0M7Y0FDaEYsSUFBSWpDLENBQUMsR0FBR3NsQyxLQUFLLENBQUMrdEUsRUFBTixDQUFTcHhHLENBQVQsQ0FBUjtjQUNBLElBQUlqQyxDQUFDLElBQUl5MEcsTUFBVCxFQUFpQnJDLE9BQU8sR0FBR0EsT0FBTyxDQUFDN2pGLElBQWxCLENBQWpCLEtBQ0ssSUFBSXZ1QixDQUFDLElBQUkrMEcsU0FBTCxJQUFrQi8wRyxDQUFDLElBQUl1MEcsVUFBM0IsRUFBdUM7OztZQUU5QyxPQUFPLENBQUNuQyxPQUFPLENBQUMveEcsSUFBUixJQUFnQixNQUFoQixJQUEwQit4RyxPQUFPLENBQUMveEcsSUFBUixJQUFnQixNQUEzQyxNQUNDaTVHLFNBQVMsSUFBSSxHQUFiLElBQXFCLENBQUMzOEQsR0FBRyxHQUFHclgsS0FBSyxDQUFDK3RFLEVBQU4sQ0FBUy90RSxLQUFLLENBQUMrdEUsRUFBTixDQUFTeHpHLE1BQVQsR0FBa0IsQ0FBM0IsQ0FBUCxNQUNDODhDLEdBQUcsSUFBSXU1RCxrQkFBUCxJQUE2QnY1RCxHQUFHLElBQUlzNUQsb0JBRHJDLEtBRUEsQ0FBQyxtQkFBbUJ4cEcsSUFBbkIsQ0FBd0Iyc0csU0FBeEIsQ0FIdkIsQ0FBUDtjQUlFaEgsT0FBTyxHQUFHQSxPQUFPLENBQUM3akYsSUFBbEI7OztZQUNGLElBQUlraUYsZUFBZSxJQUFJMkIsT0FBTyxDQUFDL3hHLElBQVIsSUFBZ0IsR0FBbkMsSUFBMEMreEcsT0FBTyxDQUFDN2pGLElBQVIsQ0FBYWx1QixJQUFiLElBQXFCLE1BQW5FLEVBQ0UreEcsT0FBTyxHQUFHQSxPQUFPLENBQUM3akYsSUFBbEI7WUFDRixJQUFJbHVCLElBQUksR0FBRyt4RyxPQUFPLENBQUMveEcsSUFBbkI7Z0JBQXlCbXNHLE9BQU8sR0FBRzhNLFNBQVMsSUFBSWo1RyxJQUFoRDtZQUVBLElBQUlBLElBQUksSUFBSSxRQUFaLEVBQXNCLE9BQU8reEcsT0FBTyxDQUFDeDNDLFFBQVIsSUFBb0J0MUIsS0FBSyxDQUFDK3NFLFFBQU4sSUFBa0IsVUFBbEIsSUFBZ0Mvc0UsS0FBSyxDQUFDK3NFLFFBQU4sSUFBa0IsR0FBbEQsR0FBd0RELE9BQU8sQ0FBQ3BzRSxJQUFSLENBQWFubUMsTUFBYixHQUFzQixDQUE5RSxHQUFrRixDQUF0RyxDQUFQLENBQXRCLEtBQ0ssSUFBSVEsSUFBSSxJQUFJLE1BQVIsSUFBa0JpNUcsU0FBUyxJQUFJLEdBQW5DLEVBQXdDLE9BQU9sSCxPQUFPLENBQUN4M0MsUUFBZixDQUF4QyxLQUNBLElBQUl2NkQsSUFBSSxJQUFJLE1BQVosRUFBb0IsT0FBTyt4RyxPQUFPLENBQUN4M0MsUUFBUixHQUFtQjZvQyxVQUExQixDQUFwQixLQUNBLElBQUlwakcsSUFBSSxJQUFJLE1BQVosRUFDSCxPQUFPK3hHLE9BQU8sQ0FBQ3gzQyxRQUFSLElBQW9CdStDLG9CQUFvQixDQUFDN3pFLEtBQUQsRUFBUTh6RSxTQUFSLENBQXBCLEdBQXlDM0ksZUFBZSxJQUFJaE4sVUFBNUQsR0FBeUUsQ0FBN0YsQ0FBUCxDQURHLEtBRUEsSUFBSTJPLE9BQU8sQ0FBQ3BzRSxJQUFSLElBQWdCLFFBQWhCLElBQTRCLENBQUN3bUUsT0FBN0IsSUFBd0NnRSxZQUFZLENBQUMrSSxrQkFBYixJQUFtQyxLQUEvRSxFQUNILE9BQU9uSCxPQUFPLENBQUN4M0MsUUFBUixJQUFvQixzQkFBc0JudUQsSUFBdEIsQ0FBMkIyc0csU0FBM0IsSUFBd0MzVixVQUF4QyxHQUFxRCxJQUFJQSxVQUE3RSxDQUFQLENBREcsS0FFQSxJQUFJMk8sT0FBTyxDQUFDdnhCLEtBQVosRUFBbUIsT0FBT3V4QixPQUFPLENBQUMzOUMsTUFBUixJQUFrQiszQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQWhDLENBQVAsQ0FBbkIsS0FDQSxPQUFPNEYsT0FBTyxDQUFDeDNDLFFBQVIsSUFBb0I0eEMsT0FBTyxHQUFHLENBQUgsR0FBTy9JLFVBQWxDLENBQVA7V0F6REY7VUE0REx3QixhQUFhLEVBQUUsbUNBNURWO1VBNkRMdVUsaUJBQWlCLEVBQUU1SSxRQUFRLEdBQUcsSUFBSCxHQUFVLElBN0RoQztVQThETDZJLGVBQWUsRUFBRTdJLFFBQVEsR0FBRyxJQUFILEdBQVUsSUE5RDlCO1VBK0RMOEksb0JBQW9CLEVBQUU5SSxRQUFRLEdBQUcsSUFBSCxHQUFVLEtBL0RuQztVQWdFTCtJLFdBQVcsRUFBRS9JLFFBQVEsR0FBRyxJQUFILEdBQVUsSUFoRTFCO1VBaUVMZ0osSUFBSSxFQUFFLE9BakVEO1VBa0VMQyxhQUFhLEVBQUUsZ0JBbEVWO1VBb0VMNW1ELFVBQVUsRUFBRTI5QyxRQUFRLEdBQUcsTUFBSCxHQUFZLFlBcEUzQjtVQXFFTEYsVUFBVSxFQUFFQSxVQXJFUDtVQXNFTEUsUUFBUSxFQUFFQSxRQXRFTDtVQXdFTHNCLGlCQUFpQixFQUFFQSxpQkF4RWQ7VUEwRUw0SCxjQUFjLEVBQUUsd0JBQVN4MEUsS0FBVCxFQUFnQjtZQUM5Qjh0RSxPQUFPLENBQUM5dEUsS0FBRCxFQUFRLE1BQVIsRUFBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsRUFBZ0MsSUFBSThzRCxVQUFVLENBQUN6K0IsWUFBZixDQUE0QixFQUE1QixFQUFnQyxDQUFoQyxFQUFtQyxJQUFuQyxDQUFoQyxDQUFQOztTQTNFSjtPQW4xQkY7TUFtNkJBeStCLFVBQVUsQ0FBQ2lXLGNBQVgsQ0FBMEIsV0FBMUIsRUFBdUMsWUFBdkMsRUFBcUQsT0FBckQ7TUFFQWpXLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLGlCQUF0QixFQUF5QyxZQUF6QztNQUNBNC9CLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLGlCQUF0QixFQUF5QyxZQUF6QztNQUNBNC9CLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLHdCQUF0QixFQUFnRCxZQUFoRDtNQUNBNC9CLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLDBCQUF0QixFQUFrRCxZQUFsRDtNQUNBNC9CLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLHdCQUF0QixFQUFnRCxZQUFoRDtNQUNBNC9CLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLGtCQUF0QixFQUEwQztRQUFFbHlELElBQUksRUFBRSxZQUFSO1FBQXNCdXdHLElBQUksRUFBRTtPQUF0RTtNQUNBemUsVUFBVSxDQUFDNS9CLFVBQVgsQ0FBc0Isb0JBQXRCLEVBQTRDO1FBQUVseUQsSUFBSSxFQUFFLFlBQVI7UUFBc0J1d0csSUFBSSxFQUFFO09BQXhFO01BQ0F6ZSxVQUFVLENBQUM1L0IsVUFBWCxDQUFzQiwyQkFBdEIsRUFBbUQ7UUFBRWx5RCxJQUFJLEVBQUUsWUFBUjtRQUFzQnV3RyxJQUFJLEVBQUU7T0FBL0U7TUFDQXplLFVBQVUsQ0FBQzUvQixVQUFYLENBQXNCLHFCQUF0QixFQUE2QztRQUFFbHlELElBQUksRUFBRSxZQUFSO1FBQXNCcXdHLE1BQU0sRUFBRTtPQUEzRTtNQUNBdmUsVUFBVSxDQUFDNS9CLFVBQVgsQ0FBc0IsaUJBQXRCLEVBQXlDO1FBQUVseUQsSUFBSSxFQUFFLFlBQVI7UUFBc0Iwd0csVUFBVSxFQUFFO09BQTNFO01BQ0E1ZSxVQUFVLENBQUM1L0IsVUFBWCxDQUFzQix3QkFBdEIsRUFBZ0Q7UUFBRWx5RCxJQUFJLEVBQUUsWUFBUjtRQUFzQjB3RyxVQUFVLEVBQUU7T0FBbEY7S0F6N0JBOzs7Ozs7SUNBQSxDQUFDLFVBQVN0YixHQUFULEVBQWM7TUFDYixBQUNFQSxHQUFHLENBQUN4NUYsVUFBRCxDQUFILENBREY7S0FERixFQU9HLFVBQVNrMkYsVUFBVCxFQUFxQjs7TUFFdEIsSUFBSTM3QixHQUFHLEdBQUcyN0IsVUFBVSxDQUFDMzdCLEdBQXJCOztNQUVBLFNBQVMvMEMsV0FBVCxDQUFxQmtCLE1BQXJCLEVBQTZCO1FBQzNCLElBQUloQixLQUFLLEdBQUdnQixNQUFNLENBQUNoQixLQUFuQjtRQUNBLE9BQU9BLEtBQUssSUFBSSxJQUFULEdBQWdCQSxLQUFoQixHQUF3QixDQUFDZ0IsTUFBTSxDQUFDekMsVUFBUCxHQUFvQixHQUFwQixHQUEwQixFQUEzQixLQUMxQnlDLE1BQU0sQ0FBQ3ZuQixNQUFQLEdBQWdCLEdBQWhCLEdBQXNCLEVBREksS0FFMUJ1bkIsTUFBTSxDQUFDeEMsU0FBUCxHQUFtQixHQUFuQixHQUF5QixFQUZDLENBQS9COzs7TUFLRixTQUFTMjVGLFdBQVQsQ0FBcUJuM0YsTUFBckIsRUFBNkJoQixLQUE3QixFQUFvQztRQUNsQyxJQUFJMGxDLE9BQU8sR0FBRzVsQyxXQUFXLENBQUNrQixNQUFELENBQXpCO1lBQW1DNWhCLE1BQU0sR0FBR3NtRCxPQUE1Qzs7UUFDQSxLQUFLLElBQUlybEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJmLEtBQUssQ0FBQy9oQixNQUExQixFQUFrQ29DLENBQUMsRUFBbkM7VUFBdUMsSUFBSWpCLE1BQU0sQ0FBQzhYLE9BQVAsQ0FBZThJLEtBQUssQ0FBQ3hlLE1BQU4sQ0FBYW5CLENBQWIsQ0FBZixLQUFtQyxDQUFDLENBQXhDLEVBQ3JDakIsTUFBTSxJQUFJNGdCLEtBQUssQ0FBQ3hlLE1BQU4sQ0FBYW5CLENBQWIsQ0FBVjs7O1FBQ0YsT0FBT3FsRCxPQUFPLElBQUl0bUQsTUFBWCxHQUFvQjRoQixNQUFwQixHQUE2QixJQUFJeFUsTUFBSixDQUFXd1UsTUFBTSxDQUFDcmlCLE1BQWxCLEVBQTBCUyxNQUExQixDQUFwQzs7O01BR0YsU0FBU2c1RyxjQUFULENBQXdCcDNGLE1BQXhCLEVBQWdDO1FBQzlCLE9BQU8sMEJBQTBCblcsSUFBMUIsQ0FBK0JtVyxNQUFNLENBQUNyaUIsTUFBdEMsQ0FBUDs7O01BR0YsU0FBUzA1RyxtQkFBVCxDQUE2QjNrRCxHQUE3QixFQUFrQzF5QyxNQUFsQyxFQUEwQ3pGLEtBQTFDLEVBQWlEO1FBQy9DeUYsTUFBTSxHQUFHbTNGLFdBQVcsQ0FBQ24zRixNQUFELEVBQVMsR0FBVCxDQUFwQjs7UUFDQSxLQUFLLElBQUk0ckMsSUFBSSxHQUFHcnhDLEtBQUssQ0FBQ3F4QyxJQUFqQixFQUF1QjlwQyxFQUFFLEdBQUd2SCxLQUFLLENBQUN1SCxFQUFsQyxFQUFzQ2dFLElBQUksR0FBRzRzQyxHQUFHLENBQUMrSixRQUFKLEVBQWxELEVBQWtFN1EsSUFBSSxJQUFJOWxDLElBQTFFLEVBQWdGOGxDLElBQUksSUFBSTlwQyxFQUFFLEdBQUcsQ0FBN0YsRUFBZ0c7VUFDOUY5QixNQUFNLENBQUNwQixTQUFQLEdBQW1Ca0QsRUFBbkI7VUFDQSxJQUFJaFcsTUFBTSxHQUFHNG1ELEdBQUcsQ0FBQ0QsT0FBSixDQUFZN0csSUFBWixDQUFiO2NBQWdDM2dELEtBQUssR0FBRytVLE1BQU0sQ0FBQzVtQixJQUFQLENBQVkwUyxNQUFaLENBQXhDO1VBQ0EsSUFBSWIsS0FBSixFQUNFLE9BQU87WUFBQ21PLElBQUksRUFBRXk2QyxHQUFHLENBQUNqSSxJQUFELEVBQU8zZ0QsS0FBSyxDQUFDNUosS0FBYixDQUFWO1lBQ0N1YixFQUFFLEVBQUVpM0MsR0FBRyxDQUFDakksSUFBRCxFQUFPM2dELEtBQUssQ0FBQzVKLEtBQU4sR0FBYzRKLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2hPLE1BQTlCLENBRFI7WUFFQ2dPLEtBQUssRUFBRUE7V0FGZjs7OztNQU1OLFNBQVNxc0csNEJBQVQsQ0FBc0M1a0QsR0FBdEMsRUFBMkMxeUMsTUFBM0MsRUFBbUR6RixLQUFuRCxFQUEwRDtRQUN4RCxJQUFJLENBQUM2OEYsY0FBYyxDQUFDcDNGLE1BQUQsQ0FBbkIsRUFBNkIsT0FBT3EzRixtQkFBbUIsQ0FBQzNrRCxHQUFELEVBQU0xeUMsTUFBTixFQUFjekYsS0FBZCxDQUExQjtRQUU3QnlGLE1BQU0sR0FBR20zRixXQUFXLENBQUNuM0YsTUFBRCxFQUFTLElBQVQsQ0FBcEI7UUFDQSxJQUFJbFUsTUFBSjtZQUFZNm1ELEtBQUssR0FBRyxDQUFwQjs7UUFDQSxLQUFLLElBQUkvRyxJQUFJLEdBQUdyeEMsS0FBSyxDQUFDcXhDLElBQWpCLEVBQXVCOWxDLElBQUksR0FBRzRzQyxHQUFHLENBQUMrSixRQUFKLEVBQW5DLEVBQW1EN1EsSUFBSSxJQUFJOWxDLElBQTNELEdBQWtFOzs7Ozs7VUFNaEUsS0FBSyxJQUFJem1CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzekQsS0FBcEIsRUFBMkJ0ekQsQ0FBQyxFQUE1QixFQUFnQztZQUM5QixJQUFJdXNELElBQUksR0FBRzlsQyxJQUFYLEVBQWlCO1lBQ2pCLElBQUlzbEUsT0FBTyxHQUFHMTRCLEdBQUcsQ0FBQ0QsT0FBSixDQUFZN0csSUFBSSxFQUFoQixDQUFkO1lBQ0E5L0MsTUFBTSxHQUFHQSxNQUFNLElBQUksSUFBVixHQUFpQnMvRSxPQUFqQixHQUEyQnQvRSxNQUFNLEdBQUcsSUFBVCxHQUFnQnMvRSxPQUFwRDs7O1VBRUZ6NEIsS0FBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7VUFDQTN5QyxNQUFNLENBQUNwQixTQUFQLEdBQW1CckUsS0FBSyxDQUFDdUgsRUFBekI7VUFDQSxJQUFJN1csS0FBSyxHQUFHK1UsTUFBTSxDQUFDNW1CLElBQVAsQ0FBWTBTLE1BQVosQ0FBWjs7VUFDQSxJQUFJYixLQUFKLEVBQVc7WUFDVCxJQUFJbWdELE1BQU0sR0FBR3QvQyxNQUFNLENBQUNwTCxLQUFQLENBQWEsQ0FBYixFQUFnQnVLLEtBQUssQ0FBQzVKLEtBQXRCLEVBQTZCOUUsS0FBN0IsQ0FBbUMsSUFBbkMsQ0FBYjtnQkFBdURnN0csTUFBTSxHQUFHdHNHLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzFPLEtBQVQsQ0FBZSxJQUFmLENBQWhFO1lBQ0EsSUFBSWk3RyxTQUFTLEdBQUdqOUYsS0FBSyxDQUFDcXhDLElBQU4sR0FBYVIsTUFBTSxDQUFDbnVELE1BQXBCLEdBQTZCLENBQTdDO2dCQUFnRGc4RCxPQUFPLEdBQUc3TixNQUFNLENBQUNBLE1BQU0sQ0FBQ251RCxNQUFQLEdBQWdCLENBQWpCLENBQU4sQ0FBMEJBLE1BQXBGO1lBQ0EsT0FBTztjQUFDbWMsSUFBSSxFQUFFeTZDLEdBQUcsQ0FBQzJqRCxTQUFELEVBQVl2K0MsT0FBWixDQUFWO2NBQ0NyOEMsRUFBRSxFQUFFaTNDLEdBQUcsQ0FBQzJqRCxTQUFTLEdBQUdELE1BQU0sQ0FBQ3Q2RyxNQUFuQixHQUE0QixDQUE3QixFQUNDczZHLE1BQU0sQ0FBQ3Q2RyxNQUFQLElBQWlCLENBQWpCLEdBQXFCZzhELE9BQU8sR0FBR3MrQyxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVV0NkcsTUFBekMsR0FBa0RzNkcsTUFBTSxDQUFDQSxNQUFNLENBQUN0NkcsTUFBUCxHQUFnQixDQUFqQixDQUFOLENBQTBCQSxNQUQ3RSxDQURSO2NBR0NnTyxLQUFLLEVBQUVBO2FBSGY7Ozs7O01BUU4sU0FBU3dzRyxXQUFULENBQXFCM3JHLE1BQXJCLEVBQTZCa1UsTUFBN0IsRUFBcUMwM0YsU0FBckMsRUFBZ0Q7UUFDOUMsSUFBSXpzRyxLQUFKO1lBQVdtTyxJQUFJLEdBQUcsQ0FBbEI7O1FBQ0EsT0FBT0EsSUFBSSxJQUFJdE4sTUFBTSxDQUFDN08sTUFBdEIsRUFBOEI7VUFDNUIraUIsTUFBTSxDQUFDcEIsU0FBUCxHQUFtQnhGLElBQW5CO1VBQ0EsSUFBSXUrRixRQUFRLEdBQUczM0YsTUFBTSxDQUFDNW1CLElBQVAsQ0FBWTBTLE1BQVosQ0FBZjtVQUNBLElBQUksQ0FBQzZyRyxRQUFMLEVBQWU7VUFDZixJQUFJN2hHLEdBQUcsR0FBRzZoRyxRQUFRLENBQUN0MkcsS0FBVCxHQUFpQnMyRyxRQUFRLENBQUMsQ0FBRCxDQUFSLENBQVkxNkcsTUFBdkM7VUFDQSxJQUFJNlksR0FBRyxHQUFHaEssTUFBTSxDQUFDN08sTUFBUCxHQUFnQnk2RyxTQUExQixFQUFxQztVQUNyQyxJQUFJLENBQUN6c0csS0FBRCxJQUFVNkssR0FBRyxHQUFHN0ssS0FBSyxDQUFDNUosS0FBTixHQUFjNEosS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTaE8sTUFBM0MsRUFDRWdPLEtBQUssR0FBRzBzRyxRQUFSO1VBQ0Z2K0YsSUFBSSxHQUFHdStGLFFBQVEsQ0FBQ3QyRyxLQUFULEdBQWlCLENBQXhCOzs7UUFFRixPQUFPNEosS0FBUDs7O01BR0YsU0FBUzJzRyxvQkFBVCxDQUE4QmxsRCxHQUE5QixFQUFtQzF5QyxNQUFuQyxFQUEyQ3pGLEtBQTNDLEVBQWtEO1FBQ2hEeUYsTUFBTSxHQUFHbTNGLFdBQVcsQ0FBQ24zRixNQUFELEVBQVMsR0FBVCxDQUFwQjs7UUFDQSxLQUFLLElBQUk0ckMsSUFBSSxHQUFHcnhDLEtBQUssQ0FBQ3F4QyxJQUFqQixFQUF1QjlwQyxFQUFFLEdBQUd2SCxLQUFLLENBQUN1SCxFQUFsQyxFQUFzQzNVLEtBQUssR0FBR3VsRCxHQUFHLENBQUN1dkIsU0FBSixFQUFuRCxFQUFvRXIyQixJQUFJLElBQUl6K0MsS0FBNUUsRUFBbUZ5K0MsSUFBSSxJQUFJOXBDLEVBQUUsR0FBRyxDQUFDLENBQWpHLEVBQW9HO1VBQ2xHLElBQUloVyxNQUFNLEdBQUc0bUQsR0FBRyxDQUFDRCxPQUFKLENBQVk3RyxJQUFaLENBQWI7VUFDQSxJQUFJM2dELEtBQUssR0FBR3dzRyxXQUFXLENBQUMzckcsTUFBRCxFQUFTa1UsTUFBVCxFQUFpQjhCLEVBQUUsR0FBRyxDQUFMLEdBQVMsQ0FBVCxHQUFhaFcsTUFBTSxDQUFDN08sTUFBUCxHQUFnQjZrQixFQUE5QyxDQUF2QjtVQUNBLElBQUk3VyxLQUFKLEVBQ0UsT0FBTztZQUFDbU8sSUFBSSxFQUFFeTZDLEdBQUcsQ0FBQ2pJLElBQUQsRUFBTzNnRCxLQUFLLENBQUM1SixLQUFiLENBQVY7WUFDQ3ViLEVBQUUsRUFBRWkzQyxHQUFHLENBQUNqSSxJQUFELEVBQU8zZ0QsS0FBSyxDQUFDNUosS0FBTixHQUFjNEosS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTaE8sTUFBOUIsQ0FEUjtZQUVDZ08sS0FBSyxFQUFFQTtXQUZmOzs7O01BTU4sU0FBUzRzRyw2QkFBVCxDQUF1Q25sRCxHQUF2QyxFQUE0QzF5QyxNQUE1QyxFQUFvRHpGLEtBQXBELEVBQTJEO1FBQ3pELElBQUksQ0FBQzY4RixjQUFjLENBQUNwM0YsTUFBRCxDQUFuQixFQUE2QixPQUFPNDNGLG9CQUFvQixDQUFDbGxELEdBQUQsRUFBTTF5QyxNQUFOLEVBQWN6RixLQUFkLENBQTNCO1FBQzdCeUYsTUFBTSxHQUFHbTNGLFdBQVcsQ0FBQ24zRixNQUFELEVBQVMsSUFBVCxDQUFwQjtRQUNBLElBQUlsVSxNQUFKO1lBQVlpbkQsU0FBUyxHQUFHLENBQXhCO1lBQTJCMmtELFNBQVMsR0FBR2hsRCxHQUFHLENBQUNELE9BQUosQ0FBWWw0QyxLQUFLLENBQUNxeEMsSUFBbEIsRUFBd0IzdUQsTUFBeEIsR0FBaUNzZCxLQUFLLENBQUN1SCxFQUE5RTs7UUFDQSxLQUFLLElBQUk4cEMsSUFBSSxHQUFHcnhDLEtBQUssQ0FBQ3F4QyxJQUFqQixFQUF1QnorQyxLQUFLLEdBQUd1bEQsR0FBRyxDQUFDdXZCLFNBQUosRUFBcEMsRUFBcURyMkIsSUFBSSxJQUFJeitDLEtBQTdELEdBQXFFO1VBQ25FLEtBQUssSUFBSTlOLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwekQsU0FBSixJQUFpQm5ILElBQUksSUFBSXorQyxLQUF6QyxFQUFnRDlOLENBQUMsRUFBakQsRUFBcUQ7WUFDbkQsSUFBSStyRixPQUFPLEdBQUcxNEIsR0FBRyxDQUFDRCxPQUFKLENBQVk3RyxJQUFJLEVBQWhCLENBQWQ7WUFDQTkvQyxNQUFNLEdBQUdBLE1BQU0sSUFBSSxJQUFWLEdBQWlCcy9FLE9BQWpCLEdBQTJCQSxPQUFPLEdBQUcsSUFBVixHQUFpQnQvRSxNQUFyRDs7O1VBRUZpbkQsU0FBUyxJQUFJLENBQWI7VUFFQSxJQUFJOW5ELEtBQUssR0FBR3dzRyxXQUFXLENBQUMzckcsTUFBRCxFQUFTa1UsTUFBVCxFQUFpQjAzRixTQUFqQixDQUF2Qjs7VUFDQSxJQUFJenNHLEtBQUosRUFBVztZQUNULElBQUltZ0QsTUFBTSxHQUFHdC9DLE1BQU0sQ0FBQ3BMLEtBQVAsQ0FBYSxDQUFiLEVBQWdCdUssS0FBSyxDQUFDNUosS0FBdEIsRUFBNkI5RSxLQUE3QixDQUFtQyxJQUFuQyxDQUFiO2dCQUF1RGc3RyxNQUFNLEdBQUd0c0csS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMU8sS0FBVCxDQUFlLElBQWYsQ0FBaEU7WUFDQSxJQUFJaTdHLFNBQVMsR0FBRzVyRCxJQUFJLEdBQUdSLE1BQU0sQ0FBQ251RCxNQUE5QjtnQkFBc0NnOEQsT0FBTyxHQUFHN04sTUFBTSxDQUFDQSxNQUFNLENBQUNudUQsTUFBUCxHQUFnQixDQUFqQixDQUFOLENBQTBCQSxNQUExRTtZQUNBLE9BQU87Y0FBQ21jLElBQUksRUFBRXk2QyxHQUFHLENBQUMyakQsU0FBRCxFQUFZditDLE9BQVosQ0FBVjtjQUNDcjhDLEVBQUUsRUFBRWkzQyxHQUFHLENBQUMyakQsU0FBUyxHQUFHRCxNQUFNLENBQUN0NkcsTUFBbkIsR0FBNEIsQ0FBN0IsRUFDQ3M2RyxNQUFNLENBQUN0NkcsTUFBUCxJQUFpQixDQUFqQixHQUFxQmc4RCxPQUFPLEdBQUdzK0MsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVdDZHLE1BQXpDLEdBQWtEczZHLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDdDZHLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBTixDQUEwQkEsTUFEN0UsQ0FEUjtjQUdDZ08sS0FBSyxFQUFFQTthQUhmOzs7OztNQVFOLElBQUk2c0csTUFBSixFQUFZQyxNQUFaOztNQUNBLElBQUlqN0csTUFBTSxDQUFDQyxTQUFQLENBQWlCaTdHLFNBQXJCLEVBQWdDO1FBQzlCRixNQUFNLEdBQUcsZ0JBQVN4ckcsR0FBVCxFQUFjO1VBQUUsT0FBT0EsR0FBRyxDQUFDMHJHLFNBQUosQ0FBYyxLQUFkLEVBQXFCdGhHLFdBQXJCLEVBQVA7U0FBekI7O1FBQ0FxaEcsTUFBTSxHQUFHLGdCQUFTenJHLEdBQVQsRUFBYztVQUFFLE9BQU9BLEdBQUcsQ0FBQzByRyxTQUFKLENBQWMsS0FBZCxDQUFQO1NBQXpCO09BRkYsTUFHTztRQUNMRixNQUFNLEdBQUcsZ0JBQVN4ckcsR0FBVCxFQUFjO1VBQUUsT0FBT0EsR0FBRyxDQUFDb0ssV0FBSixFQUFQO1NBQXpCOztRQUNBcWhHLE1BQU0sR0FBRyxnQkFBU3pyRyxHQUFULEVBQWM7VUFBRSxPQUFPQSxHQUFQO1NBQXpCO09BeEhvQjs7OztNQTZIdEIsU0FBUzJyRyxTQUFULENBQW1CQyxJQUFuQixFQUF5QkMsTUFBekIsRUFBaUNobEcsR0FBakMsRUFBc0NpbEcsUUFBdEMsRUFBZ0Q7UUFDOUMsSUFBSUYsSUFBSSxDQUFDajdHLE1BQUwsSUFBZWs3RyxNQUFNLENBQUNsN0csTUFBMUIsRUFBa0MsT0FBT2tXLEdBQVA7O1FBQ2xDLEtBQUssSUFBSWpTLEdBQUcsR0FBRyxDQUFWLEVBQWFFLEdBQUcsR0FBRytSLEdBQUcsR0FBR3ZhLElBQUksQ0FBQ3dJLEdBQUwsQ0FBUyxDQUFULEVBQVk4MkcsSUFBSSxDQUFDajdHLE1BQUwsR0FBY2s3RyxNQUFNLENBQUNsN0csTUFBakMsQ0FBOUIsSUFBMEU7VUFDeEUsSUFBSWlFLEdBQUcsSUFBSUUsR0FBWCxFQUFnQixPQUFPRixHQUFQO1VBQ2hCLElBQUlnb0QsR0FBRyxHQUFJaG9ELEdBQUcsR0FBR0UsR0FBUCxJQUFlLENBQXpCO1VBQ0EsSUFBSW9KLEdBQUcsR0FBRzR0RyxRQUFRLENBQUNGLElBQUksQ0FBQ3gzRyxLQUFMLENBQVcsQ0FBWCxFQUFjd29ELEdBQWQsQ0FBRCxDQUFSLENBQTZCanNELE1BQXZDO1VBQ0EsSUFBSXVOLEdBQUcsSUFBSTJJLEdBQVgsRUFBZ0IsT0FBTysxQyxHQUFQLENBQWhCLEtBQ0ssSUFBSTErQyxHQUFHLEdBQUcySSxHQUFWLEVBQWUvUixHQUFHLEdBQUc4bkQsR0FBTixDQUFmLEtBQ0Fob0QsR0FBRyxHQUFHZ29ELEdBQUcsR0FBRyxDQUFaOzs7O01BSVQsU0FBU212RCxtQkFBVCxDQUE2QjNsRCxHQUE3QixFQUFrQzRsRCxLQUFsQyxFQUF5Qy85RixLQUF6QyxFQUFnRGcrRixRQUFoRCxFQUEwRDs7O1FBR3hELElBQUksQ0FBQ0QsS0FBSyxDQUFDcjdHLE1BQVgsRUFBbUIsT0FBTyxJQUFQO1FBQ25CLElBQUkrNUcsSUFBSSxHQUFHdUIsUUFBUSxHQUFHVCxNQUFILEdBQVlDLE1BQS9CO1FBQ0EsSUFBSW5sRCxLQUFLLEdBQUdva0QsSUFBSSxDQUFDc0IsS0FBRCxDQUFKLENBQVkvN0csS0FBWixDQUFrQixVQUFsQixDQUFaOztRQUVBd1osTUFBTSxFQUFFLEtBQUssSUFBSTYxQyxJQUFJLEdBQUdyeEMsS0FBSyxDQUFDcXhDLElBQWpCLEVBQXVCOXBDLEVBQUUsR0FBR3ZILEtBQUssQ0FBQ3VILEVBQWxDLEVBQXNDZ0UsSUFBSSxHQUFHNHNDLEdBQUcsQ0FBQytKLFFBQUosS0FBaUIsQ0FBakIsR0FBcUI3SixLQUFLLENBQUMzMUQsTUFBN0UsRUFBcUYydUQsSUFBSSxJQUFJOWxDLElBQTdGLEVBQW1HOGxDLElBQUksSUFBSTlwQyxFQUFFLEdBQUcsQ0FBaEgsRUFBbUg7VUFDekgsSUFBSW8yRixJQUFJLEdBQUd4bEQsR0FBRyxDQUFDRCxPQUFKLENBQVk3RyxJQUFaLEVBQWtCbHJELEtBQWxCLENBQXdCb2hCLEVBQXhCLENBQVg7Y0FBd0NoVyxNQUFNLEdBQUdrckcsSUFBSSxDQUFDa0IsSUFBRCxDQUFyRDs7VUFDQSxJQUFJdGxELEtBQUssQ0FBQzMxRCxNQUFOLElBQWdCLENBQXBCLEVBQXVCO1lBQ3JCLElBQUlvc0QsS0FBSyxHQUFHdjlDLE1BQU0sQ0FBQ29LLE9BQVAsQ0FBZTA4QyxLQUFLLENBQUMsQ0FBRCxDQUFwQixDQUFaO1lBQ0EsSUFBSXZKLEtBQUssSUFBSSxDQUFDLENBQWQsRUFBaUIsU0FBU3R6QyxNQUFUO1lBQ2pCLElBQUl3RSxLQUFLLEdBQUcwOUYsU0FBUyxDQUFDQyxJQUFELEVBQU9wc0csTUFBUCxFQUFldTlDLEtBQWYsRUFBc0IydEQsSUFBdEIsQ0FBVCxHQUF1Q2wxRixFQUFuRDtZQUNBLE9BQU87Y0FBQzFJLElBQUksRUFBRXk2QyxHQUFHLENBQUNqSSxJQUFELEVBQU9xc0QsU0FBUyxDQUFDQyxJQUFELEVBQU9wc0csTUFBUCxFQUFldTlDLEtBQWYsRUFBc0IydEQsSUFBdEIsQ0FBVCxHQUF1Q2wxRixFQUE5QyxDQUFWO2NBQ0NsRixFQUFFLEVBQUVpM0MsR0FBRyxDQUFDakksSUFBRCxFQUFPcXNELFNBQVMsQ0FBQ0MsSUFBRCxFQUFPcHNHLE1BQVAsRUFBZXU5QyxLQUFLLEdBQUd1SixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMzMUQsTUFBaEMsRUFBd0MrNUcsSUFBeEMsQ0FBVCxHQUF5RGwxRixFQUFoRTthQURmO1dBSkYsTUFNTztZQUNMLElBQUkwMkYsT0FBTyxHQUFHMXNHLE1BQU0sQ0FBQzdPLE1BQVAsR0FBZ0IyMUQsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMzFELE1BQXZDO1lBQ0EsSUFBSTZPLE1BQU0sQ0FBQ3BMLEtBQVAsQ0FBYTgzRyxPQUFiLEtBQXlCNWxELEtBQUssQ0FBQyxDQUFELENBQWxDLEVBQXVDLFNBQVM3OEMsTUFBVDs7WUFDdkMsS0FBSyxJQUFJMVcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3V6RCxLQUFLLENBQUMzMUQsTUFBTixHQUFlLENBQW5DLEVBQXNDb0MsQ0FBQyxFQUF2QztjQUNFLElBQUkyM0csSUFBSSxDQUFDdGtELEdBQUcsQ0FBQ0QsT0FBSixDQUFZN0csSUFBSSxHQUFHdnNELENBQW5CLENBQUQsQ0FBSixJQUErQnV6RCxLQUFLLENBQUN2ekQsQ0FBRCxDQUF4QyxFQUE2QyxTQUFTMFcsTUFBVDs7O1lBQy9DLElBQUlELEdBQUcsR0FBRzQ4QyxHQUFHLENBQUNELE9BQUosQ0FBWTdHLElBQUksR0FBR2dILEtBQUssQ0FBQzMxRCxNQUFiLEdBQXNCLENBQWxDLENBQVY7Z0JBQWdEdzdHLFNBQVMsR0FBR3pCLElBQUksQ0FBQ2xoRyxHQUFELENBQWhFO2dCQUF1RTJtRCxRQUFRLEdBQUc3SixLQUFLLENBQUNBLEtBQUssQ0FBQzMxRCxNQUFOLEdBQWUsQ0FBaEIsQ0FBdkY7WUFDQSxJQUFJdzdHLFNBQVMsQ0FBQy8zRyxLQUFWLENBQWdCLENBQWhCLEVBQW1CKzdELFFBQVEsQ0FBQ3gvRCxNQUE1QixLQUF1Q3cvRCxRQUEzQyxFQUFxRCxTQUFTMW1ELE1BQVQ7WUFDckQsT0FBTztjQUFDcUQsSUFBSSxFQUFFeTZDLEdBQUcsQ0FBQ2pJLElBQUQsRUFBT3FzRCxTQUFTLENBQUNDLElBQUQsRUFBT3BzRyxNQUFQLEVBQWUwc0csT0FBZixFQUF3QnhCLElBQXhCLENBQVQsR0FBeUNsMUYsRUFBaEQsQ0FBVjtjQUNDbEYsRUFBRSxFQUFFaTNDLEdBQUcsQ0FBQ2pJLElBQUksR0FBR2dILEtBQUssQ0FBQzMxRCxNQUFiLEdBQXNCLENBQXZCLEVBQTBCZzdHLFNBQVMsQ0FBQ25pRyxHQUFELEVBQU0yaUcsU0FBTixFQUFpQmg4QyxRQUFRLENBQUN4L0QsTUFBMUIsRUFBa0MrNUcsSUFBbEMsQ0FBbkM7YUFEZjs7Ozs7TUFNTixTQUFTMEIsb0JBQVQsQ0FBOEJobUQsR0FBOUIsRUFBbUM0bEQsS0FBbkMsRUFBMEMvOUYsS0FBMUMsRUFBaURnK0YsUUFBakQsRUFBMkQ7UUFDekQsSUFBSSxDQUFDRCxLQUFLLENBQUNyN0csTUFBWCxFQUFtQixPQUFPLElBQVA7UUFDbkIsSUFBSSs1RyxJQUFJLEdBQUd1QixRQUFRLEdBQUdULE1BQUgsR0FBWUMsTUFBL0I7UUFDQSxJQUFJbmxELEtBQUssR0FBR29rRCxJQUFJLENBQUNzQixLQUFELENBQUosQ0FBWS83RyxLQUFaLENBQWtCLFVBQWxCLENBQVo7O1FBRUF3WixNQUFNLEVBQUUsS0FBSyxJQUFJNjFDLElBQUksR0FBR3J4QyxLQUFLLENBQUNxeEMsSUFBakIsRUFBdUI5cEMsRUFBRSxHQUFHdkgsS0FBSyxDQUFDdUgsRUFBbEMsRUFBc0MzVSxLQUFLLEdBQUd1bEQsR0FBRyxDQUFDdXZCLFNBQUosS0FBa0IsQ0FBbEIsR0FBc0JydkIsS0FBSyxDQUFDMzFELE1BQS9FLEVBQXVGMnVELElBQUksSUFBSXorQyxLQUEvRixFQUFzR3krQyxJQUFJLElBQUk5cEMsRUFBRSxHQUFHLENBQUMsQ0FBcEgsRUFBdUg7VUFDN0gsSUFBSW8yRixJQUFJLEdBQUd4bEQsR0FBRyxDQUFDRCxPQUFKLENBQVk3RyxJQUFaLENBQVg7VUFDQSxJQUFJOXBDLEVBQUUsR0FBRyxDQUFDLENBQVYsRUFBYW8yRixJQUFJLEdBQUdBLElBQUksQ0FBQ3gzRyxLQUFMLENBQVcsQ0FBWCxFQUFjb2hCLEVBQWQsQ0FBUDtVQUNiLElBQUloVyxNQUFNLEdBQUdrckcsSUFBSSxDQUFDa0IsSUFBRCxDQUFqQjs7VUFDQSxJQUFJdGxELEtBQUssQ0FBQzMxRCxNQUFOLElBQWdCLENBQXBCLEVBQXVCO1lBQ3JCLElBQUlvc0QsS0FBSyxHQUFHdjlDLE1BQU0sQ0FBQzRRLFdBQVAsQ0FBbUJrMkMsS0FBSyxDQUFDLENBQUQsQ0FBeEIsQ0FBWjtZQUNBLElBQUl2SixLQUFLLElBQUksQ0FBQyxDQUFkLEVBQWlCLFNBQVN0ekMsTUFBVDtZQUNqQixPQUFPO2NBQUNxRCxJQUFJLEVBQUV5NkMsR0FBRyxDQUFDakksSUFBRCxFQUFPcXNELFNBQVMsQ0FBQ0MsSUFBRCxFQUFPcHNHLE1BQVAsRUFBZXU5QyxLQUFmLEVBQXNCMnRELElBQXRCLENBQWhCLENBQVY7Y0FDQ3A2RixFQUFFLEVBQUVpM0MsR0FBRyxDQUFDakksSUFBRCxFQUFPcXNELFNBQVMsQ0FBQ0MsSUFBRCxFQUFPcHNHLE1BQVAsRUFBZXU5QyxLQUFLLEdBQUd1SixLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMzMUQsTUFBaEMsRUFBd0MrNUcsSUFBeEMsQ0FBaEI7YUFEZjtXQUhGLE1BS087WUFDTCxJQUFJdjZDLFFBQVEsR0FBRzdKLEtBQUssQ0FBQ0EsS0FBSyxDQUFDMzFELE1BQU4sR0FBZSxDQUFoQixDQUFwQjtZQUNBLElBQUk2TyxNQUFNLENBQUNwTCxLQUFQLENBQWEsQ0FBYixFQUFnQis3RCxRQUFRLENBQUN4L0QsTUFBekIsS0FBb0N3L0QsUUFBeEMsRUFBa0QsU0FBUzFtRCxNQUFUOztZQUNsRCxLQUFLLElBQUkxVyxDQUFDLEdBQUcsQ0FBUixFQUFXa2IsS0FBSyxHQUFHcXhDLElBQUksR0FBR2dILEtBQUssQ0FBQzMxRCxNQUFiLEdBQXNCLENBQTlDLEVBQWlEb0MsQ0FBQyxHQUFHdXpELEtBQUssQ0FBQzMxRCxNQUFOLEdBQWUsQ0FBcEUsRUFBdUVvQyxDQUFDLEVBQXhFO2NBQ0UsSUFBSTIzRyxJQUFJLENBQUN0a0QsR0FBRyxDQUFDRCxPQUFKLENBQVlsNEMsS0FBSyxHQUFHbGIsQ0FBcEIsQ0FBRCxDQUFKLElBQWdDdXpELEtBQUssQ0FBQ3Z6RCxDQUFELENBQXpDLEVBQThDLFNBQVMwVyxNQUFUOzs7WUFDaEQsSUFBSWdrQyxHQUFHLEdBQUcyWSxHQUFHLENBQUNELE9BQUosQ0FBWTdHLElBQUksR0FBRyxDQUFQLEdBQVdnSCxLQUFLLENBQUMzMUQsTUFBN0IsQ0FBVjtnQkFBZ0QwN0csU0FBUyxHQUFHM0IsSUFBSSxDQUFDajlELEdBQUQsQ0FBaEU7WUFDQSxJQUFJNCtELFNBQVMsQ0FBQ2o0RyxLQUFWLENBQWdCaTRHLFNBQVMsQ0FBQzE3RyxNQUFWLEdBQW1CMjFELEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzMxRCxNQUE1QyxLQUF1RDIxRCxLQUFLLENBQUMsQ0FBRCxDQUFoRSxFQUFxRSxTQUFTNzhDLE1BQVQ7WUFDckUsT0FBTztjQUFDcUQsSUFBSSxFQUFFeTZDLEdBQUcsQ0FBQ2pJLElBQUksR0FBRyxDQUFQLEdBQVdnSCxLQUFLLENBQUMzMUQsTUFBbEIsRUFBMEJnN0csU0FBUyxDQUFDbCtELEdBQUQsRUFBTTQrRCxTQUFOLEVBQWlCNStELEdBQUcsQ0FBQzk4QyxNQUFKLEdBQWEyMUQsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMzFELE1BQXZDLEVBQStDKzVHLElBQS9DLENBQW5DLENBQVY7Y0FDQ3A2RixFQUFFLEVBQUVpM0MsR0FBRyxDQUFDakksSUFBRCxFQUFPcXNELFNBQVMsQ0FBQ0MsSUFBRCxFQUFPcHNHLE1BQVAsRUFBZTJ3RCxRQUFRLENBQUN4L0QsTUFBeEIsRUFBZ0MrNUcsSUFBaEMsQ0FBaEI7YUFEZjs7Ozs7TUFNTixTQUFTNEIsWUFBVCxDQUFzQmxtRCxHQUF0QixFQUEyQjRsRCxLQUEzQixFQUFrQ25sRyxHQUFsQyxFQUF1Q28wQixPQUF2QyxFQUFnRDtRQUM5QyxLQUFLc3hFLFlBQUwsR0FBb0IsS0FBcEI7UUFDQSxLQUFLQyxlQUFMLEdBQXVCLEtBQXZCO1FBQ0EsS0FBS3BtRCxHQUFMLEdBQVdBLEdBQVg7UUFDQXYvQyxHQUFHLEdBQUdBLEdBQUcsR0FBR3UvQyxHQUFHLENBQUMwQixPQUFKLENBQVlqaEQsR0FBWixDQUFILEdBQXNCMGdELEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFsQztRQUNBLEtBQUsxZ0QsR0FBTCxHQUFXO1VBQUNpRyxJQUFJLEVBQUVqRyxHQUFQO1VBQVl5SixFQUFFLEVBQUV6SjtTQUEzQjtRQUVBLElBQUlvbEcsUUFBSjs7UUFDQSxJQUFJLE9BQU9oeEUsT0FBUCxJQUFrQixRQUF0QixFQUFnQztVQUM5Qmd4RSxRQUFRLEdBQUdoeEUsT0FBTyxDQUFDZ3hFLFFBQW5CO1NBREYsTUFFTzs7VUFDTEEsUUFBUSxHQUFHaHhFLE9BQVg7VUFDQUEsT0FBTyxHQUFHLElBQVY7OztRQUdGLElBQUksT0FBTyt3RSxLQUFQLElBQWdCLFFBQXBCLEVBQThCO1VBQzVCLElBQUlDLFFBQVEsSUFBSSxJQUFoQixFQUFzQkEsUUFBUSxHQUFHLEtBQVg7O1VBQ3RCLEtBQUtRLE9BQUwsR0FBZSxVQUFTN25GLE9BQVQsRUFBa0IvZCxHQUFsQixFQUF1QjtZQUNwQyxPQUFPLENBQUMrZCxPQUFPLEdBQUd3bkYsb0JBQUgsR0FBMEJMLG1CQUFsQyxFQUF1RDNsRCxHQUF2RCxFQUE0RDRsRCxLQUE1RCxFQUFtRW5sRyxHQUFuRSxFQUF3RW9sRyxRQUF4RSxDQUFQO1dBREY7U0FGRixNQUtPO1VBQ0xELEtBQUssR0FBR25CLFdBQVcsQ0FBQ21CLEtBQUQsRUFBUSxJQUFSLENBQW5CO1VBQ0EsSUFBSSxDQUFDL3dFLE9BQUQsSUFBWUEsT0FBTyxDQUFDL3BCLFNBQVIsS0FBc0IsS0FBdEMsRUFDRSxLQUFLdTdGLE9BQUwsR0FBZSxVQUFTN25GLE9BQVQsRUFBa0IvZCxHQUFsQixFQUF1QjtZQUNwQyxPQUFPLENBQUMrZCxPQUFPLEdBQUcybUYsNkJBQUgsR0FBbUNQLDRCQUEzQyxFQUF5RTVrRCxHQUF6RSxFQUE4RTRsRCxLQUE5RSxFQUFxRm5sRyxHQUFyRixDQUFQO1dBREYsQ0FERixLQUtFLEtBQUs0bEcsT0FBTCxHQUFlLFVBQVM3bkYsT0FBVCxFQUFrQi9kLEdBQWxCLEVBQXVCO1lBQ3BDLE9BQU8sQ0FBQytkLE9BQU8sR0FBRzBtRixvQkFBSCxHQUEwQlAsbUJBQWxDLEVBQXVEM2tELEdBQXZELEVBQTRENGxELEtBQTVELEVBQW1FbmxHLEdBQW5FLENBQVA7V0FERjs7OztNQU1OeWxHLFlBQVksQ0FBQzc3RyxTQUFiLEdBQXlCO1FBQ3ZCaThHLFFBQVEsRUFBRSxvQkFBVztVQUFDLE9BQU8sS0FBSzc3RixJQUFMLENBQVUsS0FBVixDQUFQO1NBREM7UUFFdkI4N0YsWUFBWSxFQUFFLHdCQUFXO1VBQUMsT0FBTyxLQUFLOTdGLElBQUwsQ0FBVSxJQUFWLENBQVA7U0FGSDtRQUl2QkEsSUFBSSxFQUFFLGNBQVMrVCxPQUFULEVBQWtCO1VBQ3RCLElBQUlyTCxJQUFJLEdBQUcsS0FBSzZzQyxHQUFMLENBQVMwQixPQUFULENBQWlCbGpDLE9BQU8sR0FBRyxLQUFLL2QsR0FBTCxDQUFTaUcsSUFBWixHQUFtQixLQUFLakcsR0FBTCxDQUFTeUosRUFBcEQsQ0FBWDs7VUFDQSxJQUFJLEtBQUtrOEYsZUFBTCxJQUF3QixLQUFLRCxZQUFqQyxFQUErQzs7WUFFN0NoekYsSUFBSSxHQUFHZ3VDLEdBQUcsQ0FBQ2h1QyxJQUFJLENBQUMrbEMsSUFBTixFQUFZL2xDLElBQUksQ0FBQy9ELEVBQWpCLENBQVY7O1lBQ0EsSUFBSW9QLE9BQUosRUFBYTtjQUNYckwsSUFBSSxDQUFDL0QsRUFBTDs7Y0FDQSxJQUFJK0QsSUFBSSxDQUFDL0QsRUFBTCxHQUFVLENBQWQsRUFBaUI7Z0JBQ2YrRCxJQUFJLENBQUMrbEMsSUFBTDtnQkFDQS9sQyxJQUFJLENBQUMvRCxFQUFMLEdBQVUsQ0FBQyxLQUFLNHdDLEdBQUwsQ0FBU0QsT0FBVCxDQUFpQjVzQyxJQUFJLENBQUMrbEMsSUFBdEIsS0FBK0IsRUFBaEMsRUFBb0MzdUQsTUFBOUM7O2FBSkosTUFNTztjQUNMNG9CLElBQUksQ0FBQy9ELEVBQUw7O2NBQ0EsSUFBSStELElBQUksQ0FBQy9ELEVBQUwsR0FBVSxDQUFDLEtBQUs0d0MsR0FBTCxDQUFTRCxPQUFULENBQWlCNXNDLElBQUksQ0FBQytsQyxJQUF0QixLQUErQixFQUFoQyxFQUFvQzN1RCxNQUFsRCxFQUEwRDtnQkFDeEQ0b0IsSUFBSSxDQUFDL0QsRUFBTCxHQUFVLENBQVY7Z0JBQ0ErRCxJQUFJLENBQUMrbEMsSUFBTDs7OztZQUdKLElBQUk0akMsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQnpuRixJQUFsQixFQUF3QixLQUFLNnNDLEdBQUwsQ0FBUzBCLE9BQVQsQ0FBaUJ2dUMsSUFBakIsQ0FBeEIsS0FBbUQsQ0FBdkQsRUFBMEQ7Y0FDdkQsT0FBTyxLQUFLZ3pGLFlBQUwsR0FBb0IsS0FBM0I7Ozs7VUFHTCxJQUFJNTJHLE1BQU0sR0FBRyxLQUFLODJHLE9BQUwsQ0FBYTduRixPQUFiLEVBQXNCckwsSUFBdEIsQ0FBYjtVQUNBLEtBQUtpekYsZUFBTCxHQUF1QjcyRyxNQUFNLElBQUl1dEYsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQnJyRyxNQUFNLENBQUNtWCxJQUF6QixFQUErQm5YLE1BQU0sQ0FBQzJhLEVBQXRDLEtBQTZDLENBQTlFOztVQUVBLElBQUkzYSxNQUFKLEVBQVk7WUFDVixLQUFLa1IsR0FBTCxHQUFXbFIsTUFBWDtZQUNBLEtBQUs0MkcsWUFBTCxHQUFvQixJQUFwQjtZQUNBLE9BQU8sS0FBSzFsRyxHQUFMLENBQVNsSSxLQUFULElBQWtCLElBQXpCO1dBSEYsTUFJTztZQUNMLElBQUk2SyxHQUFHLEdBQUcrOUMsR0FBRyxDQUFDM2lDLE9BQU8sR0FBRyxLQUFLd2hDLEdBQUwsQ0FBU3V2QixTQUFULEVBQUgsR0FBMEIsS0FBS3Z2QixHQUFMLENBQVMrSixRQUFULEtBQXNCLENBQXhELEVBQTJELENBQTNELENBQWI7WUFDQSxLQUFLdHBELEdBQUwsR0FBVztjQUFDaUcsSUFBSSxFQUFFdEQsR0FBUDtjQUFZOEcsRUFBRSxFQUFFOUc7YUFBM0I7WUFDQSxPQUFPLEtBQUsraUcsWUFBTCxHQUFvQixLQUEzQjs7U0FwQ21CO1FBd0N2QnovRixJQUFJLEVBQUUsZ0JBQVc7VUFBQyxJQUFJLEtBQUt5L0YsWUFBVCxFQUF1QixPQUFPLEtBQUsxbEcsR0FBTCxDQUFTaUcsSUFBaEI7U0F4Q2xCO1FBeUN2QndELEVBQUUsRUFBRSxjQUFXO1VBQUMsSUFBSSxLQUFLaThGLFlBQVQsRUFBdUIsT0FBTyxLQUFLMWxHLEdBQUwsQ0FBU3lKLEVBQWhCO1NBekNoQjtRQTJDdkI1USxPQUFPLEVBQUUsaUJBQVM4OEYsT0FBVCxFQUFrQnZoRCxNQUFsQixFQUEwQjtVQUNqQyxJQUFJLENBQUMsS0FBS3N4RCxZQUFWLEVBQXdCO1VBQ3hCLElBQUlqbUQsS0FBSyxHQUFHNDhCLFVBQVUsQ0FBQ3ZHLFVBQVgsQ0FBc0I2ZixPQUF0QixDQUFaO1VBQ0EsS0FBS3AyQyxHQUFMLENBQVNzMkIsWUFBVCxDQUFzQnAyQixLQUF0QixFQUE2QixLQUFLei9DLEdBQUwsQ0FBU2lHLElBQXRDLEVBQTRDLEtBQUtqRyxHQUFMLENBQVN5SixFQUFyRCxFQUF5RDJxQyxNQUF6RDtVQUNBLEtBQUtwMEMsR0FBTCxDQUFTeUosRUFBVCxHQUFjaTNDLEdBQUcsQ0FBQyxLQUFLMWdELEdBQUwsQ0FBU2lHLElBQVQsQ0FBY3d5QyxJQUFkLEdBQXFCZ0gsS0FBSyxDQUFDMzFELE1BQTNCLEdBQW9DLENBQXJDLEVBQ0MyMUQsS0FBSyxDQUFDQSxLQUFLLENBQUMzMUQsTUFBTixHQUFlLENBQWhCLENBQUwsQ0FBd0JBLE1BQXhCLElBQWtDMjFELEtBQUssQ0FBQzMxRCxNQUFOLElBQWdCLENBQWhCLEdBQW9CLEtBQUtrVyxHQUFMLENBQVNpRyxJQUFULENBQWMwSSxFQUFsQyxHQUF1QyxDQUF6RSxDQURELENBQWpCOztPQS9DSjtNQW9EQTB0RSxVQUFVLENBQUNnZSxlQUFYLENBQTJCLGlCQUEzQixFQUE4QyxVQUFTOEssS0FBVCxFQUFnQm5sRyxHQUFoQixFQUFxQm9sRyxRQUFyQixFQUErQjtRQUMzRSxPQUFPLElBQUlLLFlBQUosQ0FBaUIsS0FBS2xtRCxHQUF0QixFQUEyQjRsRCxLQUEzQixFQUFrQ25sRyxHQUFsQyxFQUF1Q29sRyxRQUF2QyxDQUFQO09BREY7TUFHQS9vQixVQUFVLENBQUNrZSxrQkFBWCxDQUE4QixpQkFBOUIsRUFBaUQsVUFBUzRLLEtBQVQsRUFBZ0JubEcsR0FBaEIsRUFBcUJvbEcsUUFBckIsRUFBK0I7UUFDOUUsT0FBTyxJQUFJSyxZQUFKLENBQWlCLElBQWpCLEVBQXVCTixLQUF2QixFQUE4Qm5sRyxHQUE5QixFQUFtQ29sRyxRQUFuQyxDQUFQO09BREY7TUFJQS9vQixVQUFVLENBQUNnZSxlQUFYLENBQTJCLGVBQTNCLEVBQTRDLFVBQVM4SyxLQUFULEVBQWdCQyxRQUFoQixFQUEwQjtRQUNwRSxJQUFJcnBDLE1BQU0sR0FBRyxFQUFiO1FBQ0EsSUFBSXpsQixHQUFHLEdBQUcsS0FBS3l2RCxlQUFMLENBQXFCWixLQUFyQixFQUE0QixLQUFLcmpDLFNBQUwsQ0FBZSxNQUFmLENBQTVCLEVBQW9Ec2pDLFFBQXBELENBQVY7O1FBQ0EsT0FBTzl1RCxHQUFHLENBQUN1dkQsUUFBSixFQUFQLEVBQXVCO1VBQ3JCLElBQUl4cEIsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQjdqRCxHQUFHLENBQUM3c0MsRUFBSixFQUFsQixFQUE0QixLQUFLcTRELFNBQUwsQ0FBZSxJQUFmLENBQTVCLElBQW9ELENBQXhELEVBQTJEO1VBQzNEL0YsTUFBTSxDQUFDbHpFLElBQVAsQ0FBWTtZQUFDMmEsTUFBTSxFQUFFOHlDLEdBQUcsQ0FBQ3J3QyxJQUFKLEVBQVQ7WUFBcUJ5TSxJQUFJLEVBQUU0akMsR0FBRyxDQUFDN3NDLEVBQUo7V0FBdkM7OztRQUVGLElBQUlzeUQsTUFBTSxDQUFDanlFLE1BQVgsRUFDRSxLQUFLZ3dGLGFBQUwsQ0FBbUIvZCxNQUFuQixFQUEyQixDQUEzQjtPQVJKO0tBblNGOzs7Ozs7SUNBQSxDQUFDLFVBQVM0akIsR0FBVCxFQUFjO01BQ2IsQUFDRUEsR0FBRyxDQUFDeDVGLFVBQUQsQ0FBSCxDQURGO0tBREYsRUFPRyxVQUFTazJGLFVBQVQsRUFBcUI7TUFDdEIsSUFBSTJwQixNQUFNLEdBQUcsVUFBVXR2RyxJQUFWLENBQWV3YyxTQUFTLENBQUNnQixTQUF6QixNQUNWcnRCLFFBQVEsQ0FBQ29wRCxZQUFULElBQXlCLElBQXpCLElBQWlDcHBELFFBQVEsQ0FBQ29wRCxZQUFULEdBQXdCLENBRC9DLENBQWI7TUFHQSxJQUFJeVEsR0FBRyxHQUFHMjdCLFVBQVUsQ0FBQzM3QixHQUFyQjtNQUVBLElBQUl1bEQsUUFBUSxHQUFHO1FBQUMsS0FBSyxJQUFOO1FBQVksS0FBSyxJQUFqQjtRQUF1QixLQUFLLElBQTVCO1FBQWtDLEtBQUssSUFBdkM7UUFBNkMsS0FBSyxJQUFsRDtRQUF3RCxLQUFLLElBQTdEO1FBQW1FLEtBQUssSUFBeEU7UUFBOEUsS0FBSztPQUFsRzs7TUFFQSxTQUFTQyxZQUFULENBQXNCMUwsTUFBdEIsRUFBOEI7UUFDNUIsT0FBT0EsTUFBTSxJQUFJQSxNQUFNLENBQUMwTCxZQUFqQixJQUFpQyxXQUF4Qzs7O01BR0YsU0FBU0MsbUJBQVQsQ0FBNkI5c0QsRUFBN0IsRUFBaUNtaUMsS0FBakMsRUFBd0NnZixNQUF4QyxFQUFnRDtRQUM5QyxJQUFJL2hELElBQUksR0FBR1ksRUFBRSxDQUFDa2dDLGFBQUgsQ0FBaUJpQyxLQUFLLENBQUMvaUMsSUFBdkIsQ0FBWDtZQUF5Q3o0QyxHQUFHLEdBQUd3N0UsS0FBSyxDQUFDN3NFLEVBQU4sR0FBVyxDQUExRDtRQUNBLElBQUl5M0YsV0FBVyxHQUFHNUwsTUFBTSxJQUFJQSxNQUFNLENBQUM0TCxXQUFuQztRQUNBLElBQUlBLFdBQVcsSUFBSSxJQUFuQixFQUNFQSxXQUFXLEdBQUcsMEJBQTBCMXZHLElBQTFCLENBQStCMmlELEVBQUUsQ0FBQ2lqQixpQkFBSCxHQUF1QjlxQixTQUF0RCxDQUFkO1FBQ0YsSUFBSW52QyxFQUFFLEdBQUc2akcsWUFBWSxDQUFDMUwsTUFBRCxDQUFyQixDQUw4Qzs7Ozs7UUFXOUMsSUFBSTFpRyxLQUFLLEdBQUksQ0FBQ3N1RyxXQUFELElBQWdCcG1HLEdBQUcsSUFBSSxDQUF2QixJQUE0QnFDLEVBQUUsQ0FBQzNMLElBQUgsQ0FBUStoRCxJQUFJLENBQUN2USxJQUFMLENBQVU3NkMsTUFBVixDQUFpQjJTLEdBQWpCLENBQVIsQ0FBNUIsSUFBOERpbUcsUUFBUSxDQUFDeHRELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVTc2QyxNQUFWLENBQWlCMlMsR0FBakIsQ0FBRCxDQUF2RSxJQUNScUMsRUFBRSxDQUFDM0wsSUFBSCxDQUFRK2hELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVTc2QyxNQUFWLENBQWlCMlMsR0FBRyxHQUFHLENBQXZCLENBQVIsS0FBc0NpbUcsUUFBUSxDQUFDeHRELElBQUksQ0FBQ3ZRLElBQUwsQ0FBVTc2QyxNQUFWLENBQWlCLEVBQUUyUyxHQUFuQixDQUFELENBRGxEO1FBRUEsSUFBSSxDQUFDbEksS0FBTCxFQUFZLE9BQU8sSUFBUDtRQUNaLElBQUk2OUMsR0FBRyxHQUFHNzlDLEtBQUssQ0FBQ3pLLE1BQU4sQ0FBYSxDQUFiLEtBQW1CLEdBQW5CLEdBQXlCLENBQXpCLEdBQTZCLENBQUMsQ0FBeEM7UUFDQSxJQUFJbXRHLE1BQU0sSUFBSUEsTUFBTSxDQUFDNkwsTUFBakIsSUFBNEIxd0QsR0FBRyxHQUFHLENBQVAsS0FBYzMxQyxHQUFHLElBQUl3N0UsS0FBSyxDQUFDN3NFLEVBQTNCLENBQS9CLEVBQStELE9BQU8sSUFBUDtRQUMvRCxJQUFJdGUsS0FBSyxHQUFHZ3BELEVBQUUsQ0FBQ2czQyxjQUFILENBQWtCM3ZDLEdBQUcsQ0FBQzg2QixLQUFLLENBQUMvaUMsSUFBUCxFQUFhejRDLEdBQUcsR0FBRyxDQUFuQixDQUFyQixDQUFaO1FBRUEsSUFBSWsyQyxLQUFLLEdBQUdvd0QsY0FBYyxDQUFDanRELEVBQUQsRUFBS3FILEdBQUcsQ0FBQzg2QixLQUFLLENBQUMvaUMsSUFBUCxFQUFhejRDLEdBQUcsSUFBSTIxQyxHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVYsR0FBYyxDQUFsQixDQUFoQixDQUFSLEVBQStDQSxHQUEvQyxFQUFvRHRsRCxLQUFwRCxFQUEyRG1xRyxNQUEzRCxDQUExQjtRQUNBLElBQUl0a0QsS0FBSyxJQUFJLElBQWIsRUFBbUIsT0FBTyxJQUFQO1FBQ25CLE9BQU87VUFBQ2p3QyxJQUFJLEVBQUV5NkMsR0FBRyxDQUFDODZCLEtBQUssQ0FBQy9pQyxJQUFQLEVBQWF6NEMsR0FBYixDQUFWO1VBQTZCeUosRUFBRSxFQUFFeXNDLEtBQUssSUFBSUEsS0FBSyxDQUFDbDJDLEdBQWhEO1VBQ0NsSSxLQUFLLEVBQUVvK0MsS0FBSyxJQUFJQSxLQUFLLENBQUN2bkMsRUFBTixJQUFZN1csS0FBSyxDQUFDekssTUFBTixDQUFhLENBQWIsQ0FEN0I7VUFDOENrNUcsT0FBTyxFQUFFNXdELEdBQUcsR0FBRztTQURwRTtPQWhDb0I7Ozs7Ozs7OztNQTJDdEIsU0FBUzJ3RCxjQUFULENBQXdCanRELEVBQXhCLEVBQTRCbWlDLEtBQTVCLEVBQW1DN2xDLEdBQW5DLEVBQXdDdGxELEtBQXhDLEVBQStDbXFHLE1BQS9DLEVBQXVEO1FBQ3JELElBQUlnTSxVQUFVLEdBQUloTSxNQUFNLElBQUlBLE1BQU0sQ0FBQ2lNLGlCQUFsQixJQUF3QyxLQUF6RDtRQUNBLElBQUlDLFlBQVksR0FBSWxNLE1BQU0sSUFBSUEsTUFBTSxDQUFDa00sWUFBbEIsSUFBbUMsSUFBdEQ7UUFFQSxJQUFJQyxLQUFLLEdBQUcsRUFBWjtRQUNBLElBQUl0a0csRUFBRSxHQUFHNmpHLFlBQVksQ0FBQzFMLE1BQUQsQ0FBckI7UUFDQSxJQUFJNVgsT0FBTyxHQUFHanRDLEdBQUcsR0FBRyxDQUFOLEdBQVVsd0QsSUFBSSxDQUFDc0ksR0FBTCxDQUFTeXRGLEtBQUssQ0FBQy9pQyxJQUFOLEdBQWFpdUQsWUFBdEIsRUFBb0NydEQsRUFBRSxDQUFDaVEsUUFBSCxLQUFnQixDQUFwRCxDQUFWLEdBQ1U3akUsSUFBSSxDQUFDd0ksR0FBTCxDQUFTb3JELEVBQUUsQ0FBQ3kxQixTQUFILEtBQWlCLENBQTFCLEVBQTZCME0sS0FBSyxDQUFDL2lDLElBQU4sR0FBYWl1RCxZQUExQyxDQUR4Qjs7UUFFQSxLQUFLLElBQUl6bUQsTUFBTSxHQUFHdTdCLEtBQUssQ0FBQy9pQyxJQUF4QixFQUE4QndILE1BQU0sSUFBSTJpQyxPQUF4QyxFQUFpRDNpQyxNQUFNLElBQUl0SyxHQUEzRCxFQUFnRTtVQUM5RCxJQUFJOEMsSUFBSSxHQUFHWSxFQUFFLENBQUNpRyxPQUFILENBQVdXLE1BQVgsQ0FBWDtVQUNBLElBQUksQ0FBQ3hILElBQUwsRUFBVztVQUNYLElBQUl6NEMsR0FBRyxHQUFHMjFDLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBVixHQUFjOEMsSUFBSSxDQUFDM3VELE1BQUwsR0FBYyxDQUF0QztjQUF5QzZZLEdBQUcsR0FBR2d6QyxHQUFHLEdBQUcsQ0FBTixHQUFVOEMsSUFBSSxDQUFDM3VELE1BQWYsR0FBd0IsQ0FBQyxDQUF4RTtVQUNBLElBQUkydUQsSUFBSSxDQUFDM3VELE1BQUwsR0FBYzA4RyxVQUFsQixFQUE4QjtVQUM5QixJQUFJdm1ELE1BQU0sSUFBSXU3QixLQUFLLENBQUMvaUMsSUFBcEIsRUFBMEJ6NEMsR0FBRyxHQUFHdzdFLEtBQUssQ0FBQzdzRSxFQUFOLElBQVlnbkMsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWMsQ0FBMUIsQ0FBTjs7VUFDMUIsT0FBTzMxQyxHQUFHLElBQUkyQyxHQUFkLEVBQW1CM0MsR0FBRyxJQUFJMjFDLEdBQTFCLEVBQStCO1lBQzdCLElBQUlobkMsRUFBRSxHQUFHOHBDLElBQUksQ0FBQ3ByRCxNQUFMLENBQVkyUyxHQUFaLENBQVQ7O1lBQ0EsSUFBSXFDLEVBQUUsQ0FBQzNMLElBQUgsQ0FBUWlZLEVBQVIsTUFBZ0J0ZSxLQUFLLEtBQUszSCxTQUFWLElBQ0EsQ0FBQzJ3RCxFQUFFLENBQUNnM0MsY0FBSCxDQUFrQjN2QyxHQUFHLENBQUNULE1BQUQsRUFBU2pnRCxHQUFHLEdBQUcsQ0FBZixDQUFyQixLQUEyQyxFQUE1QyxNQUFvRDNQLEtBQUssSUFBSSxFQUE3RCxDQURoQixDQUFKLEVBQ3VGO2NBQ3JGLElBQUl5SCxLQUFLLEdBQUdtdUcsUUFBUSxDQUFDdDNGLEVBQUQsQ0FBcEI7Y0FDQSxJQUFJN1csS0FBSyxJQUFLQSxLQUFLLENBQUN6SyxNQUFOLENBQWEsQ0FBYixLQUFtQixHQUFwQixJQUE2QnNvRCxHQUFHLEdBQUcsQ0FBaEQsRUFBb0RneEQsS0FBSyxDQUFDOTlHLElBQU4sQ0FBVzhsQixFQUFYLEVBQXBELEtBQ0ssSUFBSSxDQUFDZzRGLEtBQUssQ0FBQzc4RyxNQUFYLEVBQW1CLE9BQU87Z0JBQUNrVyxHQUFHLEVBQUUwZ0QsR0FBRyxDQUFDVCxNQUFELEVBQVNqZ0QsR0FBVCxDQUFUO2dCQUF3QjJPLEVBQUUsRUFBRUE7ZUFBbkMsQ0FBbkIsS0FDQWc0RixLQUFLLENBQUM3MUUsR0FBTjs7Ozs7UUFJWCxPQUFPbXZCLE1BQU0sR0FBR3RLLEdBQVQsS0FBaUJBLEdBQUcsR0FBRyxDQUFOLEdBQVUwRCxFQUFFLENBQUNpUSxRQUFILEVBQVYsR0FBMEJqUSxFQUFFLENBQUN5MUIsU0FBSCxFQUEzQyxJQUE2RCxLQUE3RCxHQUFxRSxJQUE1RTs7O01BR0YsU0FBUzgzQixhQUFULENBQXVCdnRELEVBQXZCLEVBQTJCd3RELFNBQTNCLEVBQXNDck0sTUFBdEMsRUFBOEM7O1FBRTVDLElBQUlzTSxlQUFlLEdBQUd6dEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3EzRSxhQUFULENBQXVCRyxzQkFBdkIsSUFBaUQsSUFBdkU7WUFDRUMsb0JBQW9CLEdBQUd4TSxNQUFNLElBQUlBLE1BQU0sQ0FBQ3dNLG9CQUQxQztRQUVBLElBQUlDLEtBQUssR0FBRyxFQUFaO1lBQWdCbHJDLE1BQU0sR0FBRzFpQixFQUFFLENBQUNzZ0MsY0FBSCxFQUF6Qjs7UUFDQSxLQUFLLElBQUl6dEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUk0TCxLQUFLLEdBQUdpa0UsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVd29CLEtBQVYsTUFBcUJ5eEYsbUJBQW1CLENBQUM5c0QsRUFBRCxFQUFLMGlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVXdtQixJQUFmLEVBQXFCOG5GLE1BQXJCLENBQXBEOztVQUNBLElBQUkxaUcsS0FBSyxLQUFLQSxLQUFLLENBQUNBLEtBQU4sSUFBZWt2RyxvQkFBb0IsS0FBSyxLQUE3QyxDQUFMLElBQTREM3RELEVBQUUsQ0FBQ2lHLE9BQUgsQ0FBV3huRCxLQUFLLENBQUNtTyxJQUFOLENBQVd3eUMsSUFBdEIsRUFBNEIzdUQsTUFBNUIsSUFBc0NnOUcsZUFBdEcsRUFBdUg7WUFDckgsSUFBSXoyRyxLQUFLLEdBQUd5SCxLQUFLLENBQUNBLEtBQU4sR0FBYyw0QkFBZCxHQUE2QywrQkFBekQ7WUFDQW12RyxLQUFLLENBQUNwK0csSUFBTixDQUFXd3dELEVBQUUsQ0FBQ3crQixRQUFILENBQVkvL0UsS0FBSyxDQUFDbU8sSUFBbEIsRUFBd0J5NkMsR0FBRyxDQUFDNW9ELEtBQUssQ0FBQ21PLElBQU4sQ0FBV3d5QyxJQUFaLEVBQWtCM2dELEtBQUssQ0FBQ21PLElBQU4sQ0FBVzBJLEVBQVgsR0FBZ0IsQ0FBbEMsQ0FBM0IsRUFBaUU7Y0FBQzZpQyxTQUFTLEVBQUVuaEQ7YUFBN0UsQ0FBWDtZQUNBLElBQUl5SCxLQUFLLENBQUMyUixFQUFOLElBQVk0dkMsRUFBRSxDQUFDaUcsT0FBSCxDQUFXeG5ELEtBQUssQ0FBQzJSLEVBQU4sQ0FBU2d2QyxJQUFwQixFQUEwQjN1RCxNQUExQixJQUFvQ2c5RyxlQUFwRCxFQUNFRyxLQUFLLENBQUNwK0csSUFBTixDQUFXd3dELEVBQUUsQ0FBQ3crQixRQUFILENBQVkvL0UsS0FBSyxDQUFDMlIsRUFBbEIsRUFBc0JpM0MsR0FBRyxDQUFDNW9ELEtBQUssQ0FBQzJSLEVBQU4sQ0FBU2d2QyxJQUFWLEVBQWdCM2dELEtBQUssQ0FBQzJSLEVBQU4sQ0FBU2tGLEVBQVQsR0FBYyxDQUE5QixDQUF6QixFQUEyRDtjQUFDNmlDLFNBQVMsRUFBRW5oRDthQUF2RSxDQUFYOzs7O1FBSU4sSUFBSTQyRyxLQUFLLENBQUNuOUcsTUFBVixFQUFrQjs7O1VBR2hCLElBQUlrOEcsTUFBTSxJQUFJM3NELEVBQUUsQ0FBQzlwQixLQUFILENBQVNndkMsT0FBdkIsRUFBZ0NsbEIsRUFBRSxDQUFDdEwsS0FBSDs7VUFFaEMsSUFBSTU3QixLQUFLLEdBQUcsU0FBUkEsS0FBUSxHQUFXO1lBQ3JCa25DLEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO2NBQ3RCLEtBQUssSUFBSWwvQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHKzZHLEtBQUssQ0FBQ245RyxNQUExQixFQUFrQ29DLENBQUMsRUFBbkM7Z0JBQXVDKzZHLEtBQUssQ0FBQy82RyxDQUFELENBQUwsQ0FBU2ltQixLQUFUOzthQUR6QztXQURGOztVQUtBLElBQUkwMEYsU0FBSixFQUFlMzBGLFVBQVUsQ0FBQ0MsS0FBRCxFQUFRLEdBQVIsQ0FBVixDQUFmLEtBQ0ssT0FBT0EsS0FBUDs7OztNQUlULFNBQVMrMEYsZUFBVCxDQUF5Qjd0RCxFQUF6QixFQUE2QjtRQUMzQkEsRUFBRSxDQUFDak8sU0FBSCxDQUFhLFlBQVc7VUFDdEIsSUFBSWlPLEVBQUUsQ0FBQzlwQixLQUFILENBQVNxM0UsYUFBVCxDQUF1Qk8sb0JBQTNCLEVBQWlEO1lBQy9DOXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVNxM0UsYUFBVCxDQUF1Qk8sb0JBQXZCO1lBQ0E5dEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3EzRSxhQUFULENBQXVCTyxvQkFBdkIsR0FBOEMsSUFBOUM7OztVQUVGOXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVNxM0UsYUFBVCxDQUF1Qk8sb0JBQXZCLEdBQThDUCxhQUFhLENBQUN2dEQsRUFBRCxFQUFLLEtBQUwsRUFBWUEsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3EzRSxhQUFyQixDQUEzRDtTQUxGOzs7TUFTRixTQUFTUSxnQkFBVCxDQUEwQi90RCxFQUExQixFQUE4QjtRQUM1QixJQUFJQSxFQUFFLENBQUM5cEIsS0FBSCxDQUFTcTNFLGFBQVQsSUFBMEJ2dEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3EzRSxhQUFULENBQXVCTyxvQkFBckQsRUFBMkU7VUFDekU5dEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3EzRSxhQUFULENBQXVCTyxvQkFBdkI7VUFDQTl0RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTcTNFLGFBQVQsQ0FBdUJPLG9CQUF2QixHQUE4QyxJQUE5Qzs7OztNQUlKOXFCLFVBQVUsQ0FBQ3NPLFlBQVgsQ0FBd0IsZUFBeEIsRUFBeUMsS0FBekMsRUFBZ0QsVUFBU3R4QyxFQUFULEVBQWFqeUQsR0FBYixFQUFrQncyQyxHQUFsQixFQUF1QjtRQUNyRSxJQUFJQSxHQUFHLElBQUlBLEdBQUcsSUFBSXkrQyxVQUFVLENBQUNnTyxJQUE3QixFQUFtQztVQUNqQ2h4QyxFQUFFLENBQUNMLEdBQUgsQ0FBTyxnQkFBUCxFQUF5Qmt1RCxlQUF6QjtVQUNBN3RELEVBQUUsQ0FBQ0wsR0FBSCxDQUFPLE9BQVAsRUFBZ0JrdUQsZUFBaEI7VUFDQTd0RCxFQUFFLENBQUNMLEdBQUgsQ0FBTyxNQUFQLEVBQWVvdUQsZ0JBQWY7VUFDQUEsZ0JBQWdCLENBQUMvdEQsRUFBRCxDQUFoQjs7O1FBRUYsSUFBSWp5RCxHQUFKLEVBQVM7VUFDUGl5RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTcTNFLGFBQVQsR0FBeUIsT0FBT3gvRyxHQUFQLElBQWMsUUFBZCxHQUF5QkEsR0FBekIsR0FBK0IsRUFBeEQ7VUFDQWl5RCxFQUFFLENBQUNWLEVBQUgsQ0FBTSxnQkFBTixFQUF3QnV1RCxlQUF4QjtVQUNBN3RELEVBQUUsQ0FBQ1YsRUFBSCxDQUFNLE9BQU4sRUFBZXV1RCxlQUFmO1VBQ0E3dEQsRUFBRSxDQUFDVixFQUFILENBQU0sTUFBTixFQUFjeXVELGdCQUFkOztPQVhKO01BZUEvcUIsVUFBVSxDQUFDZ2UsZUFBWCxDQUEyQixlQUEzQixFQUE0QyxZQUFXO1FBQUN1TSxhQUFhLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBYjtPQUF4RDtNQUNBdnFCLFVBQVUsQ0FBQ2dlLGVBQVgsQ0FBMkIscUJBQTNCLEVBQWtELFVBQVNyNkYsR0FBVCxFQUFjdzZGLE1BQWQsRUFBc0I2TSxTQUF0QixFQUFnQzs7UUFFaEYsSUFBSUEsU0FBUyxJQUFJLE9BQU83TSxNQUFQLElBQWlCLFNBQWxDLEVBQTZDO1VBQzNDLElBQUksQ0FBQzZNLFNBQUwsRUFBZ0I7WUFDZDdNLE1BQU0sR0FBR0EsTUFBTSxHQUFHO2NBQUM2TCxNQUFNLEVBQUU7YUFBWixHQUFvQixJQUFuQztXQURGLE1BRU87WUFDTGdCLFNBQVMsQ0FBQ2hCLE1BQVYsR0FBbUI3TCxNQUFuQjtZQUNBQSxNQUFNLEdBQUc2TSxTQUFUOzs7O1FBR0osT0FBT2xCLG1CQUFtQixDQUFDLElBQUQsRUFBT25tRyxHQUFQLEVBQVl3NkYsTUFBWixDQUExQjtPQVZGO01BWUFuZSxVQUFVLENBQUNnZSxlQUFYLENBQTJCLGdCQUEzQixFQUE2QyxVQUFTcjZGLEdBQVQsRUFBYzIxQyxHQUFkLEVBQW1CdGxELEtBQW5CLEVBQTBCbXFHLE1BQTFCLEVBQWlDO1FBQzVFLE9BQU84TCxjQUFjLENBQUMsSUFBRCxFQUFPdG1HLEdBQVAsRUFBWTIxQyxHQUFaLEVBQWlCdGxELEtBQWpCLEVBQXdCbXFHLE1BQXhCLENBQXJCO09BREY7S0F6SkY7Ozs7Ozs7O0lDR0EsQ0FBQyxVQUFTN2EsR0FBVCxFQUFjO01BQ2IsQUFDRUEsR0FBRyxDQUFDeDVGLFVBQUQsRUFBK0JhLFlBQS9CLEVBQXdFQyxhQUF4RSxDQUFILENBREY7S0FERixFQU9HLFVBQVNvMUYsVUFBVCxFQUFxQjs7TUFHdEIsSUFBSWlyQixJQUFJLEdBQUdqckIsVUFBVSxDQUFDd0YsUUFBdEI7TUFDQSxJQUFJbmhDLEdBQUcsR0FBRzI3QixVQUFVLENBQUMzN0IsR0FBckIsQ0FKc0I7O01BT3RCLFNBQVM2bUQsY0FBVCxDQUF3QmhvRCxHQUF4QixFQUE2Qm40QyxLQUE3QixFQUFvQ3V1QyxHQUFwQyxFQUF5QztRQUN2QyxJQUFJQSxHQUFHLEdBQUcsQ0FBTixJQUFXdnVDLEtBQUssQ0FBQ3VILEVBQU4sSUFBWSxDQUEzQixFQUE4QixPQUFPNHdDLEdBQUcsQ0FBQzBCLE9BQUosQ0FBWVAsR0FBRyxDQUFDdDVDLEtBQUssQ0FBQ3F4QyxJQUFOLEdBQWEsQ0FBZCxDQUFmLENBQVA7UUFDOUIsSUFBSUEsSUFBSSxHQUFHOEcsR0FBRyxDQUFDRCxPQUFKLENBQVlsNEMsS0FBSyxDQUFDcXhDLElBQWxCLENBQVg7UUFDQSxJQUFJOUMsR0FBRyxHQUFHLENBQU4sSUFBV3Z1QyxLQUFLLENBQUN1SCxFQUFOLElBQVk4cEMsSUFBSSxDQUFDM3VELE1BQWhDLEVBQXdDLE9BQU95MUQsR0FBRyxDQUFDMEIsT0FBSixDQUFZUCxHQUFHLENBQUN0NUMsS0FBSyxDQUFDcXhDLElBQU4sR0FBYSxDQUFkLEVBQWlCLENBQWpCLENBQWYsQ0FBUDtRQUN4QyxJQUFJbHBCLEtBQUssR0FBRyxPQUFaO1lBQXFCamxDLElBQXJCO1lBQTJCazlHLFFBQVEsR0FBR3BnRyxLQUFLLENBQUN1SCxFQUE1Qzs7UUFDQSxLQUFLLElBQUkzTyxHQUFHLEdBQUd3bkcsUUFBVixFQUFvQnRoSCxDQUFDLEdBQUd5dkQsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWM4QyxJQUFJLENBQUMzdUQsTUFBM0MsRUFBbURvQyxDQUFDLEdBQUcsQ0FBNUQsRUFBK0Q4VCxHQUFHLElBQUk5WixDQUF0RSxFQUF5RThaLEdBQUcsSUFBSTIxQyxHQUFQLEVBQVl6cEQsQ0FBQyxFQUF0RixFQUEwRjtVQUN4RixJQUFJaVUsSUFBSSxHQUFHczRDLElBQUksQ0FBQ3ByRCxNQUFMLENBQVlzb0QsR0FBRyxHQUFHLENBQU4sR0FBVTMxQyxHQUFHLEdBQUcsQ0FBaEIsR0FBb0JBLEdBQWhDLENBQVg7VUFDQSxJQUFJeW5HLEdBQUcsR0FBR3RuRyxJQUFJLElBQUksR0FBUixJQUFlazhFLFVBQVUsQ0FBQ2huQyxVQUFYLENBQXNCbDFDLElBQXRCLENBQWYsR0FBNkMsR0FBN0MsR0FBbUQsR0FBN0Q7VUFDQSxJQUFJc25HLEdBQUcsSUFBSSxHQUFQLElBQWN0bkcsSUFBSSxDQUFDaTFDLFdBQUwsTUFBc0JqMUMsSUFBeEMsRUFBOENzbkcsR0FBRyxHQUFHLEdBQU47O1VBQzlDLElBQUlsNEUsS0FBSyxJQUFJLE9BQWIsRUFBc0I7WUFDcEIsSUFBSWs0RSxHQUFHLElBQUksR0FBWCxFQUFnQjtjQUFFbDRFLEtBQUssR0FBRyxJQUFSO2NBQWNqbEMsSUFBSSxHQUFHbTlHLEdBQVA7YUFBaEMsTUFDS0QsUUFBUSxHQUFHeG5HLEdBQUcsR0FBRzIxQyxHQUFqQjtXQUZQLE1BR08sSUFBSXBtQixLQUFLLElBQUksSUFBYixFQUFtQjtZQUN4QixJQUFJamxDLElBQUksSUFBSW05RyxHQUFaLEVBQWlCO2NBQ2YsSUFBSW45RyxJQUFJLElBQUksR0FBUixJQUFlbTlHLEdBQUcsSUFBSSxHQUF0QixJQUE2Qjl4RCxHQUFHLEdBQUcsQ0FBdkMsRUFBMEMzMUMsR0FBRzs7Y0FDN0MsSUFBSTFWLElBQUksSUFBSSxHQUFSLElBQWVtOUcsR0FBRyxJQUFJLEdBQXRCLElBQTZCOXhELEdBQUcsR0FBRyxDQUF2QyxFQUEwQzs7Z0JBQ3hDLElBQUkzMUMsR0FBRyxJQUFJd25HLFFBQVEsR0FBRyxDQUF0QixFQUF5QjtrQkFBRWw5RyxJQUFJLEdBQUcsR0FBUDtrQkFBWTtpQkFBdkMsTUFDSzBWLEdBQUc7OztjQUVWOzs7OztRQUlOLE9BQU8wZ0QsR0FBRyxDQUFDdDVDLEtBQUssQ0FBQ3F4QyxJQUFQLEVBQWF6NEMsR0FBYixDQUFWOzs7TUFHRixTQUFTMG5HLFdBQVQsQ0FBcUJydUQsRUFBckIsRUFBeUIxRCxHQUF6QixFQUE4QjtRQUM1QjBELEVBQUUsQ0FBQ3dnQyxrQkFBSCxDQUFzQixVQUFTNXdDLEtBQVQsRUFBZ0I7VUFDcEMsSUFBSW9RLEVBQUUsQ0FBQy9vRCxPQUFILENBQVc4dUUsS0FBWCxJQUFvQi9sQixFQUFFLENBQUNrRyxHQUFILENBQU8ycEIsTUFBM0IsSUFBcUNqZ0MsS0FBSyxDQUFDdjBCLEtBQU4sRUFBekMsRUFDRSxPQUFPNnlGLGNBQWMsQ0FBQ2x1RCxFQUFFLENBQUNrRyxHQUFKLEVBQVN0VyxLQUFLLENBQUN2MkIsSUFBZixFQUFxQmlqQyxHQUFyQixDQUFyQixDQURGLEtBR0UsT0FBT0EsR0FBRyxHQUFHLENBQU4sR0FBVTFNLEtBQUssQ0FBQ2hqQyxJQUFOLEVBQVYsR0FBeUJnakMsS0FBSyxDQUFDeC9CLEVBQU4sRUFBaEM7U0FKSjs7O01BUUY2OUYsSUFBSSxDQUFDSyxhQUFMLEdBQXFCLFVBQVN0dUQsRUFBVCxFQUFhO1FBQUVxdUQsV0FBVyxDQUFDcnVELEVBQUQsRUFBSyxDQUFDLENBQU4sQ0FBWDtPQUFwQzs7TUFDQWl1RCxJQUFJLENBQUNNLGNBQUwsR0FBc0IsVUFBU3Z1RCxFQUFULEVBQWE7UUFBRXF1RCxXQUFXLENBQUNydUQsRUFBRCxFQUFLLENBQUwsQ0FBWDtPQUFyQzs7TUFFQWl1RCxJQUFJLENBQUNPLFlBQUwsR0FBb0IsVUFBU3h1RCxFQUFULEVBQWE7UUFDL0IsSUFBSXBwQixJQUFJLEdBQUdvcEIsRUFBRSxDQUFDeTRDLGFBQUgsRUFBWDs7UUFDQSxJQUFJLENBQUN6NEMsRUFBRSxDQUFDbTBCLGlCQUFILEVBQUwsRUFBNkI7VUFDM0IsSUFBSXM2QixpQkFBaUIsR0FBR3p1RCxFQUFFLENBQUM4RyxZQUFILENBQWdCbHdCLElBQUksQ0FBQzJXLEdBQUwsR0FBVzNXLElBQUksQ0FBQytpQyxZQUFoQyxFQUE4QyxPQUE5QyxDQUF4QjtVQUNBLElBQUkzWixFQUFFLENBQUN5b0IsU0FBSCxHQUFlcnBCLElBQWYsSUFBdUJxdkQsaUJBQTNCLEVBQ0V6dUQsRUFBRSxDQUFDdXJDLFdBQUgsQ0FBZSxVQUFmOzs7UUFFSnZyQyxFQUFFLENBQUN3NEMsUUFBSCxDQUFZLElBQVosRUFBa0I1aEUsSUFBSSxDQUFDMlcsR0FBTCxHQUFXeVMsRUFBRSxDQUFDcTNDLGlCQUFILEVBQTdCO09BUEY7O01BU0E0VyxJQUFJLENBQUNTLGNBQUwsR0FBc0IsVUFBUzF1RCxFQUFULEVBQWE7UUFDakMsSUFBSXBwQixJQUFJLEdBQUdvcEIsRUFBRSxDQUFDeTRDLGFBQUgsRUFBWDs7UUFDQSxJQUFJLENBQUN6NEMsRUFBRSxDQUFDbTBCLGlCQUFILEVBQUwsRUFBNkI7VUFDM0IsSUFBSXc2QixjQUFjLEdBQUczdUQsRUFBRSxDQUFDOEcsWUFBSCxDQUFnQmx3QixJQUFJLENBQUMyVyxHQUFyQixFQUEwQixPQUExQixJQUFtQyxDQUF4RDtVQUNBLElBQUl5UyxFQUFFLENBQUN5b0IsU0FBSCxHQUFlcnBCLElBQWYsSUFBdUJ1dkQsY0FBM0IsRUFDRTN1RCxFQUFFLENBQUN1ckMsV0FBSCxDQUFlLFlBQWY7OztRQUVKdnJDLEVBQUUsQ0FBQ3c0QyxRQUFILENBQVksSUFBWixFQUFrQjVoRSxJQUFJLENBQUMyVyxHQUFMLEdBQVd5UyxFQUFFLENBQUNxM0MsaUJBQUgsRUFBN0I7T0FQRjs7TUFVQTRXLElBQUksQ0FBQ1csb0JBQUwsR0FBNEIsVUFBUzV1RCxFQUFULEVBQWE7UUFDdkMsSUFBSTBpQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtZQUFrQ3V1QixVQUFVLEdBQUcsRUFBL0M7O1FBQ0EsS0FBSyxJQUFJaDhHLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQTNCLEVBQW1Db0MsQ0FBQyxFQUFwQyxFQUF3QztVQUN0QyxJQUFJK1osSUFBSSxHQUFHODFELE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVStaLElBQVYsRUFBWDtjQUE2QndELEVBQUUsR0FBR3N5RCxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVV1ZCxFQUFWLEVBQWxDOztVQUNBLEtBQUssSUFBSWd2QyxJQUFJLEdBQUd4eUMsSUFBSSxDQUFDd3lDLElBQXJCLEVBQTJCQSxJQUFJLElBQUlodkMsRUFBRSxDQUFDZ3ZDLElBQXRDLEVBQTRDLEVBQUVBLElBQTlDO1lBQ0UsSUFBSSxFQUFFaHZDLEVBQUUsQ0FBQ2d2QyxJQUFILEdBQVV4eUMsSUFBSSxDQUFDd3lDLElBQWYsSUFBdUJBLElBQUksSUFBSWh2QyxFQUFFLENBQUNndkMsSUFBbEMsSUFBMENodkMsRUFBRSxDQUFDa0YsRUFBSCxJQUFTLENBQXJELENBQUosRUFDRXU1RixVQUFVLENBQUNyL0csSUFBWCxDQUFnQjtjQUFDMmEsTUFBTSxFQUFFaTFDLElBQUksSUFBSXh5QyxJQUFJLENBQUN3eUMsSUFBYixHQUFvQnh5QyxJQUFwQixHQUEyQnk2QyxHQUFHLENBQUNqSSxJQUFELEVBQU8sQ0FBUCxDQUF2QztjQUNDL2xDLElBQUksRUFBRStsQyxJQUFJLElBQUlodkMsRUFBRSxDQUFDZ3ZDLElBQVgsR0FBa0JodkMsRUFBbEIsR0FBdUJpM0MsR0FBRyxDQUFDakksSUFBRDthQURqRDs7OztRQUdOWSxFQUFFLENBQUN5Z0MsYUFBSCxDQUFpQm91QixVQUFqQixFQUE2QixDQUE3QjtPQVRGOztNQVlBWixJQUFJLENBQUNhLGtCQUFMLEdBQTBCLFVBQVM5dUQsRUFBVCxFQUFhO1FBQ3JDLElBQUlwUSxLQUFLLEdBQUdvUSxFQUFFLENBQUNzZ0MsY0FBSCxHQUFvQixDQUFwQixDQUFaO1FBQ0F0Z0MsRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0J6cEMsS0FBSyxDQUFDemxDLE1BQXRCLEVBQThCeWxDLEtBQUssQ0FBQ3YyQixJQUFwQyxFQUEwQztVQUFDd2hDLE1BQU0sRUFBRTtTQUFuRDtPQUZGOztNQUtBb3pELElBQUksQ0FBQ2MsVUFBTCxHQUFrQixVQUFTL3VELEVBQVQsRUFBYTtRQUM3QixJQUFJMGlCLE1BQU0sR0FBRzFpQixFQUFFLENBQUNzZ0MsY0FBSCxFQUFiO1lBQWtDMHVCLFFBQVEsR0FBRyxFQUE3Qzs7UUFDQSxLQUFLLElBQUluOEcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCO1VBQ0FtOEcsUUFBUSxDQUFDeC9HLElBQVQsQ0FBYztZQUFDMmEsTUFBTSxFQUFFazlDLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ2hqQyxJQUFOLEdBQWF3eUMsSUFBZCxFQUFvQixDQUFwQixDQUFaO1lBQ0MvbEMsSUFBSSxFQUFFZ3VDLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ3gvQixFQUFOLEdBQVdndkMsSUFBWCxHQUFrQixDQUFuQixFQUFzQixDQUF0QjtXQUR4Qjs7O1FBR0ZZLEVBQUUsQ0FBQ3lnQyxhQUFILENBQWlCdXVCLFFBQWpCO09BUEY7O01BVUEsU0FBU0MsVUFBVCxDQUFvQmp2RCxFQUFwQixFQUF3QitYLEtBQXhCLEVBQStCO1FBQzdCLElBQUkvWCxFQUFFLENBQUMyakMsVUFBSCxFQUFKLEVBQXFCLE9BQU9YLFVBQVUsQ0FBQ3JvQyxJQUFsQjtRQUNyQnFGLEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO1VBQ3RCLElBQUkvekMsR0FBRyxHQUFHZ2lELEVBQUUsQ0FBQ3NnQyxjQUFILEdBQW9CN3ZGLE1BQTlCO2NBQXNDeStHLFlBQVksR0FBRyxFQUFyRDtjQUF5RDUxRixJQUFJLEdBQUcsQ0FBQyxDQUFqRTs7VUFDQSxLQUFLLElBQUl6bUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21MLEdBQXBCLEVBQXlCbkwsQ0FBQyxFQUExQixFQUE4QjtZQUM1QixJQUFJd21CLElBQUksR0FBRzJtQyxFQUFFLENBQUNzZ0MsY0FBSCxHQUFvQnp0RixDQUFwQixFQUF1QndtQixJQUFsQztZQUNBLElBQUlBLElBQUksQ0FBQytsQyxJQUFMLElBQWE5bEMsSUFBakIsRUFBdUI7WUFDdkIsSUFBSTVHLEVBQUUsR0FBRzIwQyxHQUFHLENBQUNodUMsSUFBSSxDQUFDK2xDLElBQUwsSUFBYTJZLEtBQUssR0FBRyxDQUFILEdBQU8sQ0FBekIsQ0FBRCxFQUE4QixDQUE5QixDQUFaO1lBQ0EvWCxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixJQUFoQixFQUFzQjlwRSxFQUF0QixFQUEwQixJQUExQixFQUFnQyxhQUFoQztZQUNBc3RDLEVBQUUsQ0FBQzJyQyxVQUFILENBQWNqNUUsRUFBRSxDQUFDMHNDLElBQWpCLEVBQXVCLElBQXZCLEVBQTZCLElBQTdCO1lBQ0E4dkQsWUFBWSxDQUFDMS9HLElBQWIsQ0FBa0I7Y0FBQzZwQixJQUFJLEVBQUUzRyxFQUFQO2NBQVd2SSxNQUFNLEVBQUV1STthQUFyQztZQUNBNEcsSUFBSSxHQUFHRCxJQUFJLENBQUMrbEMsSUFBTCxHQUFZLENBQW5COzs7VUFFRlksRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUJ5dUIsWUFBakI7U0FYRjtRQWFBbHZELEVBQUUsQ0FBQ3VyQyxXQUFILENBQWUsWUFBZjs7O01BR0YwaUIsSUFBSSxDQUFDa0IsZUFBTCxHQUF1QixVQUFTbnZELEVBQVQsRUFBYTtRQUFFLE9BQU9pdkQsVUFBVSxDQUFDanZELEVBQUQsRUFBSyxLQUFMLENBQWpCO09BQXRDOztNQUVBaXVELElBQUksQ0FBQ21CLGdCQUFMLEdBQXdCLFVBQVNwdkQsRUFBVCxFQUFhO1FBQUUsT0FBT2l2RCxVQUFVLENBQUNqdkQsRUFBRCxFQUFLLElBQUwsQ0FBakI7T0FBdkM7O01BRUEsU0FBU3F2RCxNQUFULENBQWdCcnZELEVBQWhCLEVBQW9CcjVDLEdBQXBCLEVBQXlCO1FBQ3ZCLElBQUlvSCxLQUFLLEdBQUdwSCxHQUFHLENBQUMyTyxFQUFoQjtZQUFvQmhNLEdBQUcsR0FBR3lFLEtBQTFCO1lBQWlDcXhDLElBQUksR0FBR1ksRUFBRSxDQUFDaUcsT0FBSCxDQUFXdC9DLEdBQUcsQ0FBQ3k0QyxJQUFmLENBQXhDOztRQUNBLE9BQU9yeEMsS0FBSyxJQUFJaTFFLFVBQVUsQ0FBQ2huQyxVQUFYLENBQXNCb0QsSUFBSSxDQUFDcHJELE1BQUwsQ0FBWStaLEtBQUssR0FBRyxDQUFwQixDQUF0QixDQUFoQjtVQUErRCxFQUFFQSxLQUFGOzs7UUFDL0QsT0FBT3pFLEdBQUcsR0FBRzgxQyxJQUFJLENBQUMzdUQsTUFBWCxJQUFxQnV5RixVQUFVLENBQUNobkMsVUFBWCxDQUFzQm9ELElBQUksQ0FBQ3ByRCxNQUFMLENBQVlzVixHQUFaLENBQXRCLENBQTVCO1VBQXFFLEVBQUVBLEdBQUY7OztRQUNyRSxPQUFPO1VBQUNzRCxJQUFJLEVBQUV5NkMsR0FBRyxDQUFDMWdELEdBQUcsQ0FBQ3k0QyxJQUFMLEVBQVdyeEMsS0FBWCxDQUFWO1VBQTZCcUMsRUFBRSxFQUFFaTNDLEdBQUcsQ0FBQzFnRCxHQUFHLENBQUN5NEMsSUFBTCxFQUFXOTFDLEdBQVgsQ0FBcEM7VUFBcUQ4cEYsSUFBSSxFQUFFaDBDLElBQUksQ0FBQ2xyRCxLQUFMLENBQVc2WixLQUFYLEVBQWtCekUsR0FBbEI7U0FBbEU7OztNQUdGMmtHLElBQUksQ0FBQ3FCLG9CQUFMLEdBQTRCLFVBQVN0dkQsRUFBVCxFQUFhO1FBQ3ZDLElBQUlwekMsSUFBSSxHQUFHb3pDLEVBQUUsQ0FBQ3lvQixTQUFILENBQWEsTUFBYixDQUFYO1lBQWlDcjRELEVBQUUsR0FBRzR2QyxFQUFFLENBQUN5b0IsU0FBSCxDQUFhLElBQWIsQ0FBdEM7UUFDQSxJQUFJOG1DLFFBQVEsR0FBR3Z2RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTczVFLG1CQUFULElBQWdDeHZELEVBQUUsQ0FBQ2tHLEdBQUgsQ0FBT3VjLEdBQXREOztRQUNBLElBQUl1Z0IsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQmwwRixJQUFsQixFQUF3QndELEVBQXhCLEtBQStCLENBQW5DLEVBQXNDO1VBQ3BDLElBQUlnakYsSUFBSSxHQUFHaWMsTUFBTSxDQUFDcnZELEVBQUQsRUFBS3B6QyxJQUFMLENBQWpCO1VBQ0EsSUFBSSxDQUFDd21GLElBQUksQ0FBQ0EsSUFBVixFQUFnQjtVQUNoQnB6QyxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQitaLElBQUksQ0FBQ3htRixJQUFyQixFQUEyQndtRixJQUFJLENBQUNoakYsRUFBaEM7VUFDQW0vRixRQUFRLEdBQUcsSUFBWDtTQUpGLE1BS087VUFDTCxJQUFJMWdFLElBQUksR0FBR21SLEVBQUUsQ0FBQ2lnQyxRQUFILENBQVlyekUsSUFBWixFQUFrQndELEVBQWxCLENBQVg7VUFDQSxJQUFJMDdGLEtBQUssR0FBR3lELFFBQVEsR0FBRyxJQUFJdndHLE1BQUosQ0FBVyxRQUFRNnZDLElBQVIsR0FBZSxLQUExQixDQUFILEdBQXNDQSxJQUExRDtVQUNBLElBQUlvTyxHQUFHLEdBQUcrQyxFQUFFLENBQUMwc0QsZUFBSCxDQUFtQlosS0FBbkIsRUFBMEIxN0YsRUFBMUIsQ0FBVjtVQUNBLElBQUl5c0MsS0FBSyxHQUFHSSxHQUFHLENBQUN1dkQsUUFBSixFQUFaOztVQUNBLElBQUksQ0FBQzN2RCxLQUFMLEVBQVk7WUFDVkksR0FBRyxHQUFHK0MsRUFBRSxDQUFDMHNELGVBQUgsQ0FBbUJaLEtBQW5CLEVBQTBCemtELEdBQUcsQ0FBQ3JILEVBQUUsQ0FBQ3kxQixTQUFILEVBQUQsRUFBaUIsQ0FBakIsQ0FBN0IsQ0FBTjtZQUNBNTRCLEtBQUssR0FBR0ksR0FBRyxDQUFDdXZELFFBQUosRUFBUjs7O1VBRUYsSUFBSSxDQUFDM3ZELEtBQUQsSUFBVTR5RCxlQUFlLENBQUN6dkQsRUFBRSxDQUFDc2dDLGNBQUgsRUFBRCxFQUFzQnJqQyxHQUFHLENBQUNyd0MsSUFBSixFQUF0QixFQUFrQ3F3QyxHQUFHLENBQUM3c0MsRUFBSixFQUFsQyxDQUE3QixFQUEwRTtVQUMxRTR2QyxFQUFFLENBQUMwZ0MsWUFBSCxDQUFnQnpqQyxHQUFHLENBQUNyd0MsSUFBSixFQUFoQixFQUE0QnF3QyxHQUFHLENBQUM3c0MsRUFBSixFQUE1Qjs7O1FBRUYsSUFBSW0vRixRQUFKLEVBQ0V2dkQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3M1RSxtQkFBVCxHQUErQnh2RCxFQUFFLENBQUNrRyxHQUFILENBQU91YyxHQUF0QztPQXJCSjs7TUF3QkF3ckMsSUFBSSxDQUFDeUIsMkJBQUwsR0FBbUMsVUFBUzF2RCxFQUFULEVBQWE7UUFDOUMsSUFBSTJ2RCxVQUFVLEdBQUczdkQsRUFBRSxDQUFDeW9CLFNBQUgsQ0FBYSxRQUFiLENBQWpCO1lBQXlDbW5DLFFBQVEsR0FBRzV2RCxFQUFFLENBQUN5b0IsU0FBSCxDQUFhLE1BQWIsQ0FBcEQ7UUFDQXdsQyxJQUFJLENBQUNxQixvQkFBTCxDQUEwQnR2RCxFQUExQjs7UUFDQSxJQUFJZ2pDLFVBQVUsQ0FBQzhkLE1BQVgsQ0FBa0I2TyxVQUFsQixFQUE4QkMsUUFBOUIsS0FBMkMsQ0FBL0MsRUFBa0Q7VUFDaEQ1dkQsRUFBRSxDQUFDa0csR0FBSCxDQUFPdTZCLGFBQVAsQ0FBcUJ6Z0MsRUFBRSxDQUFDa0csR0FBSCxDQUFPbzZCLGNBQVAsR0FDaEJqeEUsTUFEZ0IsQ0FDVCxVQUFVb3pELEdBQVYsRUFBZTtZQUNyQixPQUFPQSxHQUFHLENBQUN0NEQsTUFBSixJQUFjd2xHLFVBQWQsSUFBNEJsdEMsR0FBRyxDQUFDcHBELElBQUosSUFBWXUyRixRQUEvQztXQUZlLENBQXJCOztPQUpKOztNQVdBLFNBQVNDLG9CQUFULENBQThCN3ZELEVBQTlCLEVBQWtDMUQsR0FBbEMsRUFBdUM7UUFDckMsSUFBSW9tQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtZQUFrQ3VXLFNBQVMsR0FBRyxFQUE5Qzs7UUFDQSxLQUFLLElBQUloa0csQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCO1VBQ0EsSUFBSXFuRixTQUFTLEdBQUdsNkIsRUFBRSxDQUFDbTRDLFFBQUgsQ0FDWnZvRCxLQUFLLENBQUN6bEMsTUFETSxFQUNFbXlDLEdBREYsRUFDTyxNQURQLEVBQ2UxTSxLQUFLLENBQUN6bEMsTUFBTixDQUFhaXVGLFVBRDVCLENBQWhCO1VBRUEsSUFBSWhlLE9BQU8sR0FBR3A2QixFQUFFLENBQUNtNEMsUUFBSCxDQUNWdm9ELEtBQUssQ0FBQ3YyQixJQURJLEVBQ0VpakMsR0FERixFQUNPLE1BRFAsRUFDZTFNLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrK0UsVUFEMUIsQ0FBZDtVQUVBbGUsU0FBUyxDQUFDa2UsVUFBVixHQUF1QnhvRCxLQUFLLENBQUN6bEMsTUFBTixDQUFhaXVGLFVBQWIsSUFBMkIsSUFBM0IsR0FDbkJ4b0QsS0FBSyxDQUFDemxDLE1BQU4sQ0FBYWl1RixVQURNLEdBQ09wNEMsRUFBRSxDQUFDc2UsWUFBSCxDQUFnQjF1QixLQUFLLENBQUN6bEMsTUFBdEIsRUFBOEIsS0FBOUIsRUFBcUN3bEIsSUFEbkU7VUFFQXlxRCxPQUFPLENBQUNnZSxVQUFSLEdBQXFCeG9ELEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrK0UsVUFBWCxJQUF5QixJQUF6QixHQUNqQnhvRCxLQUFLLENBQUN2MkIsSUFBTixDQUFXKytFLFVBRE0sR0FDT3A0QyxFQUFFLENBQUNzZSxZQUFILENBQWdCMXVCLEtBQUssQ0FBQ3YyQixJQUF0QixFQUE0QixLQUE1QixFQUFtQ3NXLElBRC9EO1VBRUEsSUFBSW1nRixRQUFRLEdBQUc7WUFBQzNsRyxNQUFNLEVBQUUrdkUsU0FBVDtZQUFvQjdnRSxJQUFJLEVBQUUrZ0U7V0FBekM7VUFDQXljLFNBQVMsQ0FBQ3JuRyxJQUFWLENBQWVvZ0QsS0FBZjtVQUNBaW5ELFNBQVMsQ0FBQ3JuRyxJQUFWLENBQWVzZ0gsUUFBZjs7O1FBRUY5dkQsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUJvVyxTQUFqQjs7O01BRUZvWCxJQUFJLENBQUM4QixtQkFBTCxHQUEyQixVQUFTL3ZELEVBQVQsRUFBYTtRQUFFNnZELG9CQUFvQixDQUFDN3ZELEVBQUQsRUFBSyxDQUFDLENBQU4sQ0FBcEI7T0FBMUM7O01BQ0FpdUQsSUFBSSxDQUFDK0IsbUJBQUwsR0FBMkIsVUFBU2h3RCxFQUFULEVBQWE7UUFBRTZ2RCxvQkFBb0IsQ0FBQzd2RCxFQUFELEVBQUssQ0FBTCxDQUFwQjtPQUExQzs7TUFFQSxTQUFTeXZELGVBQVQsQ0FBeUIvc0MsTUFBekIsRUFBaUM5MUQsSUFBakMsRUFBdUN3RCxFQUF2QyxFQUEyQztRQUN6QyxLQUFLLElBQUl2ZCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEM7VUFDRSxJQUFJbXdGLFVBQVUsQ0FBQzhkLE1BQVgsQ0FBa0JwK0IsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVK1osSUFBVixFQUFsQixFQUFvQ0EsSUFBcEMsS0FBNkMsQ0FBN0MsSUFDQW8yRSxVQUFVLENBQUM4ZCxNQUFYLENBQWtCcCtCLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVXVkLEVBQVYsRUFBbEIsRUFBa0NBLEVBQWxDLEtBQXlDLENBRDdDLEVBQ2dELE9BQU8sSUFBUDs7O1FBQ2xELE9BQU8sS0FBUDs7O01BR0YsSUFBSTYvRixNQUFNLEdBQUcsUUFBYjs7TUFDQSxTQUFTQyxxQkFBVCxDQUErQmx3RCxFQUEvQixFQUFtQztRQUNqQyxJQUFJMGlCLE1BQU0sR0FBRzFpQixFQUFFLENBQUNzZ0MsY0FBSCxFQUFiO1lBQWtDdVcsU0FBUyxHQUFHLEVBQTlDOztRQUNBLEtBQUssSUFBSWhrRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7VUFDdEMsSUFBSSs4QyxLQUFLLEdBQUc4eUIsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBbEI7Y0FBdUI4VCxHQUFHLEdBQUdpcEMsS0FBSyxDQUFDdjJCLElBQW5DO2NBQXlDODJGLE9BQU8sR0FBR253RCxFQUFFLENBQUNpdEQsY0FBSCxDQUFrQnRtRyxHQUFsQixFQUF1QixDQUFDLENBQXhCLENBQW5EO1VBQ0EsSUFBSSxDQUFDd3BHLE9BQUwsRUFBYyxPQUFPLEtBQVA7O1VBQ2QsU0FBUztZQUNQLElBQUkvUyxPQUFPLEdBQUdwOUMsRUFBRSxDQUFDaXRELGNBQUgsQ0FBa0J0bUcsR0FBbEIsRUFBdUIsQ0FBdkIsQ0FBZDtZQUNBLElBQUksQ0FBQ3kyRixPQUFMLEVBQWMsT0FBTyxLQUFQOztZQUNkLElBQUlBLE9BQU8sQ0FBQzluRixFQUFSLElBQWMyNkYsTUFBTSxDQUFDajhHLE1BQVAsQ0FBY2k4RyxNQUFNLENBQUN2bUcsT0FBUCxDQUFleW1HLE9BQU8sQ0FBQzc2RixFQUF2QixJQUE2QixDQUEzQyxDQUFsQixFQUFpRTtjQUMvRCxJQUFJNjRGLFFBQVEsR0FBRzltRCxHQUFHLENBQUM4b0QsT0FBTyxDQUFDeHBHLEdBQVIsQ0FBWXk0QyxJQUFiLEVBQW1CK3dELE9BQU8sQ0FBQ3hwRyxHQUFSLENBQVkyTyxFQUFaLEdBQWlCLENBQXBDLENBQWxCOztjQUNBLElBQUkwdEUsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQnFOLFFBQWxCLEVBQTRCditELEtBQUssQ0FBQ2hqQyxJQUFOLEVBQTVCLEtBQTZDLENBQTdDLElBQ0FvMkUsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQjFELE9BQU8sQ0FBQ3oyRixHQUExQixFQUErQmlwQyxLQUFLLENBQUN4L0IsRUFBTixFQUEvQixLQUE4QyxDQURsRCxFQUNxRDtnQkFDbkQrL0YsT0FBTyxHQUFHbndELEVBQUUsQ0FBQ2l0RCxjQUFILENBQWtCa0QsT0FBTyxDQUFDeHBHLEdBQTFCLEVBQStCLENBQUMsQ0FBaEMsQ0FBVjtnQkFDQSxJQUFJLENBQUN3cEcsT0FBTCxFQUFjLE9BQU8sS0FBUDtlQUhoQixNQUlPO2dCQUNMdFosU0FBUyxDQUFDcm5HLElBQVYsQ0FBZTtrQkFBQzJhLE1BQU0sRUFBRWdrRyxRQUFUO2tCQUFtQjkwRixJQUFJLEVBQUUrakYsT0FBTyxDQUFDejJGO2lCQUFoRDtnQkFDQTs7OztZQUdKQSxHQUFHLEdBQUcwZ0QsR0FBRyxDQUFDKzFDLE9BQU8sQ0FBQ3oyRixHQUFSLENBQVl5NEMsSUFBYixFQUFtQmcrQyxPQUFPLENBQUN6MkYsR0FBUixDQUFZMk8sRUFBWixHQUFpQixDQUFwQyxDQUFUOzs7O1FBR0owcUMsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUJvVyxTQUFqQjtRQUNBLE9BQU8sSUFBUDs7O01BR0ZvWCxJQUFJLENBQUNtQyxXQUFMLEdBQW1CLFVBQVNwd0QsRUFBVCxFQUFhO1FBQzlCa3dELHFCQUFxQixDQUFDbHdELEVBQUQsQ0FBckIsSUFBNkJBLEVBQUUsQ0FBQ3VyQyxXQUFILENBQWUsV0FBZixDQUE3QjtPQURGOztNQUdBMGlCLElBQUksQ0FBQ2lDLHFCQUFMLEdBQTZCLFVBQVNsd0QsRUFBVCxFQUFhO1FBQ3hDLElBQUksQ0FBQ2t3RCxxQkFBcUIsQ0FBQ2x3RCxFQUFELENBQTFCLEVBQWdDLE9BQU9nakMsVUFBVSxDQUFDcm9DLElBQWxCO09BRGxDOztNQUlBLFNBQVMwMUQsUUFBVCxDQUFrQnAvRyxJQUFsQixFQUF3QjtRQUN0QixPQUFPLENBQUNBLElBQUQsR0FBUSxJQUFSLEdBQWUsa0JBQWtCb00sSUFBbEIsQ0FBdUJwTSxJQUF2QixJQUErQkEsSUFBL0IsR0FBc0M1QixTQUE1RDs7O01BR0Y0K0csSUFBSSxDQUFDcUMsV0FBTCxHQUFtQixVQUFTdHdELEVBQVQsRUFBYTtRQUM5QkEsRUFBRSxDQUFDd2dDLGtCQUFILENBQXNCLFVBQVM1d0MsS0FBVCxFQUFnQjtVQUNwQyxJQUFJOW9DLElBQUksR0FBR2s1QyxFQUFFLENBQUNpdEQsY0FBSCxDQUFrQnI5RCxLQUFLLENBQUN2MkIsSUFBeEIsRUFBOEIsQ0FBOUIsRUFBaUNnM0YsUUFBUSxDQUFDcndELEVBQUUsQ0FBQ2czQyxjQUFILENBQWtCcG5ELEtBQUssQ0FBQ3YyQixJQUF4QixDQUFELENBQXpDLENBQVg7VUFDQSxJQUFJdlMsSUFBSSxJQUFJazhFLFVBQVUsQ0FBQzhkLE1BQVgsQ0FBa0JoNkYsSUFBSSxDQUFDSCxHQUF2QixFQUE0QmlwQyxLQUFLLENBQUN2MkIsSUFBbEMsS0FBMkMsQ0FBdkQsRUFBMEQsT0FBT3ZTLElBQUksQ0FBQ0gsR0FBWjtVQUMxRCxJQUFJd1ksSUFBSSxHQUFHNmdDLEVBQUUsQ0FBQ2l0RCxjQUFILENBQWtCcjlELEtBQUssQ0FBQ3YyQixJQUF4QixFQUE4QixDQUFDLENBQS9CLEVBQWtDZzNGLFFBQVEsQ0FBQ3J3RCxFQUFFLENBQUNnM0MsY0FBSCxDQUFrQjN2QyxHQUFHLENBQUN6WCxLQUFLLENBQUN2MkIsSUFBTixDQUFXK2xDLElBQVosRUFBa0J4UCxLQUFLLENBQUN2MkIsSUFBTixDQUFXL0QsRUFBWCxHQUFnQixDQUFsQyxDQUFyQixDQUFELENBQTFDLENBQVg7VUFDQSxPQUFPNkosSUFBSSxJQUFJa29DLEdBQUcsQ0FBQ2xvQyxJQUFJLENBQUN4WSxHQUFMLENBQVN5NEMsSUFBVixFQUFnQmpnQyxJQUFJLENBQUN4WSxHQUFMLENBQVMyTyxFQUFULEdBQWMsQ0FBOUIsQ0FBWCxJQUErQ3M2QixLQUFLLENBQUN2MkIsSUFBNUQ7U0FKRjtPQURGOztNQVNBNDBGLElBQUksQ0FBQ3NDLFVBQUwsR0FBa0IsVUFBU3Z3RCxFQUFULEVBQWE7UUFDN0IsSUFBSUEsRUFBRSxDQUFDMmpDLFVBQUgsRUFBSixFQUFxQixPQUFPWCxVQUFVLENBQUNyb0MsSUFBbEI7UUFDckIsSUFBSStuQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtZQUFrQ2t3QixXQUFXLEdBQUcsRUFBaEQ7WUFBb0Q5OUYsRUFBRSxHQUFHc3RDLEVBQUUsQ0FBQ3kxQixTQUFILEtBQWlCLENBQTFFO1lBQTZFZzdCLE9BQU8sR0FBRyxFQUF2Rjs7UUFDQSxLQUFLLElBQUk1OUcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCO2NBQXVCK1osSUFBSSxHQUFHZ2pDLEtBQUssQ0FBQ2hqQyxJQUFOLEdBQWF3eUMsSUFBYixHQUFvQixDQUFsRDtjQUFxRGh2QyxFQUFFLEdBQUd3L0IsS0FBSyxDQUFDeC9CLEVBQU4sR0FBV2d2QyxJQUFyRTtVQUNBcXhELE9BQU8sQ0FBQ2poSCxJQUFSLENBQWE7WUFBQzJhLE1BQU0sRUFBRWs5QyxHQUFHLENBQUN6WCxLQUFLLENBQUN6bEMsTUFBTixDQUFhaTFDLElBQWIsR0FBb0IsQ0FBckIsRUFBd0J4UCxLQUFLLENBQUN6bEMsTUFBTixDQUFhbUwsRUFBckMsQ0FBWjtZQUNDK0QsSUFBSSxFQUFFZ3VDLEdBQUcsQ0FBQ3pYLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcrbEMsSUFBWCxHQUFrQixDQUFuQixFQUFzQnhQLEtBQUssQ0FBQ3YyQixJQUFOLENBQVcvRCxFQUFqQztXQUR2QjtVQUVBLElBQUlzNkIsS0FBSyxDQUFDeC9CLEVBQU4sR0FBV2tGLEVBQVgsSUFBaUIsQ0FBakIsSUFBc0IsQ0FBQ3M2QixLQUFLLENBQUN2MEIsS0FBTixFQUEzQixFQUEwQyxFQUFFakwsRUFBRjtVQUMxQyxJQUFJeEQsSUFBSSxHQUFHOEYsRUFBWCxFQUFlODlGLFdBQVcsQ0FBQ2hoSCxJQUFaLENBQWlCb2QsSUFBakIsRUFBdUJ3RCxFQUF2QixFQUFmLEtBQ0ssSUFBSW9nRyxXQUFXLENBQUMvL0csTUFBaEIsRUFBd0IrL0csV0FBVyxDQUFDQSxXQUFXLENBQUMvL0csTUFBWixHQUFxQixDQUF0QixDQUFYLEdBQXNDMmYsRUFBdEM7VUFDN0JzQyxFQUFFLEdBQUd0QyxFQUFMOzs7UUFFRjR2QyxFQUFFLENBQUNqTyxTQUFILENBQWEsWUFBVztVQUN0QixLQUFLLElBQUlsL0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzI5RyxXQUFXLENBQUMvL0csTUFBaEMsRUFBd0NvQyxDQUFDLElBQUksQ0FBN0MsRUFBZ0Q7WUFDOUMsSUFBSStaLElBQUksR0FBRzRqRyxXQUFXLENBQUMzOUcsQ0FBRCxDQUF0QjtnQkFBMkJ1ZCxFQUFFLEdBQUdvZ0csV0FBVyxDQUFDMzlHLENBQUMsR0FBRyxDQUFMLENBQTNDO1lBQ0EsSUFBSXVzRCxJQUFJLEdBQUdZLEVBQUUsQ0FBQ2lHLE9BQUgsQ0FBV3I1QyxJQUFYLENBQVg7WUFDQW96QyxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixFQUFoQixFQUFvQm4xQixHQUFHLENBQUN6NkMsSUFBRCxFQUFPLENBQVAsQ0FBdkIsRUFBa0N5NkMsR0FBRyxDQUFDejZDLElBQUksR0FBRyxDQUFSLEVBQVcsQ0FBWCxDQUFyQyxFQUFvRCxXQUFwRDtZQUNBLElBQUl3RCxFQUFFLEdBQUc0dkMsRUFBRSxDQUFDaVEsUUFBSCxFQUFULEVBQ0VqUSxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixPQUFPcDlCLElBQXZCLEVBQTZCaUksR0FBRyxDQUFDckgsRUFBRSxDQUFDaVEsUUFBSCxFQUFELENBQWhDLEVBQWlELElBQWpELEVBQXVELFdBQXZELEVBREYsS0FHRWpRLEVBQUUsQ0FBQ3c4QixZQUFILENBQWdCcDlCLElBQUksR0FBRyxJQUF2QixFQUE2QmlJLEdBQUcsQ0FBQ2ozQyxFQUFELEVBQUssQ0FBTCxDQUFoQyxFQUF5QyxJQUF6QyxFQUErQyxXQUEvQzs7O1VBRUo0dkMsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUJnd0IsT0FBakI7VUFDQXp3RCxFQUFFLENBQUNpbkIsY0FBSDtTQVhGO09BWkY7O01BMkJBZ25DLElBQUksQ0FBQ3lDLFlBQUwsR0FBb0IsVUFBUzF3RCxFQUFULEVBQWE7UUFDL0IsSUFBSUEsRUFBRSxDQUFDMmpDLFVBQUgsRUFBSixFQUFxQixPQUFPWCxVQUFVLENBQUNyb0MsSUFBbEI7UUFDckIsSUFBSStuQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtZQUFrQ2t3QixXQUFXLEdBQUcsRUFBaEQ7WUFBb0Q5OUYsRUFBRSxHQUFHc3RDLEVBQUUsQ0FBQ2lRLFFBQUgsS0FBZ0IsQ0FBekU7O1FBQ0EsS0FBSyxJQUFJcDlELENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBUCxHQUFnQixDQUE3QixFQUFnQ29DLENBQUMsSUFBSSxDQUFyQyxFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztVQUMzQyxJQUFJKzhDLEtBQUssR0FBRzh5QixNQUFNLENBQUM3dkUsQ0FBRCxDQUFsQjtjQUF1QitaLElBQUksR0FBR2dqQyxLQUFLLENBQUN4L0IsRUFBTixHQUFXZ3ZDLElBQVgsR0FBa0IsQ0FBaEQ7Y0FBbURodkMsRUFBRSxHQUFHdy9CLEtBQUssQ0FBQ2hqQyxJQUFOLEdBQWF3eUMsSUFBckU7VUFDQSxJQUFJeFAsS0FBSyxDQUFDeC9CLEVBQU4sR0FBV2tGLEVBQVgsSUFBaUIsQ0FBakIsSUFBc0IsQ0FBQ3M2QixLQUFLLENBQUN2MEIsS0FBTixFQUEzQixFQUEwQ3pPLElBQUk7VUFDOUMsSUFBSUEsSUFBSSxHQUFHOEYsRUFBWCxFQUFlODlGLFdBQVcsQ0FBQ2hoSCxJQUFaLENBQWlCb2QsSUFBakIsRUFBdUJ3RCxFQUF2QixFQUFmLEtBQ0ssSUFBSW9nRyxXQUFXLENBQUMvL0csTUFBaEIsRUFBd0IrL0csV0FBVyxDQUFDQSxXQUFXLENBQUMvL0csTUFBWixHQUFxQixDQUF0QixDQUFYLEdBQXNDMmYsRUFBdEM7VUFDN0JzQyxFQUFFLEdBQUd0QyxFQUFMOzs7UUFFRjR2QyxFQUFFLENBQUNqTyxTQUFILENBQWEsWUFBVztVQUN0QixLQUFLLElBQUlsL0MsQ0FBQyxHQUFHMjlHLFdBQVcsQ0FBQy8vRyxNQUFaLEdBQXFCLENBQWxDLEVBQXFDb0MsQ0FBQyxJQUFJLENBQTFDLEVBQTZDQSxDQUFDLElBQUksQ0FBbEQsRUFBcUQ7WUFDbkQsSUFBSStaLElBQUksR0FBRzRqRyxXQUFXLENBQUMzOUcsQ0FBRCxDQUF0QjtnQkFBMkJ1ZCxFQUFFLEdBQUdvZ0csV0FBVyxDQUFDMzlHLENBQUMsR0FBRyxDQUFMLENBQTNDO1lBQ0EsSUFBSXVzRCxJQUFJLEdBQUdZLEVBQUUsQ0FBQ2lHLE9BQUgsQ0FBV3I1QyxJQUFYLENBQVg7WUFDQSxJQUFJQSxJQUFJLElBQUlvekMsRUFBRSxDQUFDaVEsUUFBSCxFQUFaLEVBQ0VqUSxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixFQUFoQixFQUFvQm4xQixHQUFHLENBQUN6NkMsSUFBSSxHQUFHLENBQVIsQ0FBdkIsRUFBbUN5NkMsR0FBRyxDQUFDejZDLElBQUQsQ0FBdEMsRUFBOEMsV0FBOUMsRUFERixLQUdFb3pDLEVBQUUsQ0FBQ3c4QixZQUFILENBQWdCLEVBQWhCLEVBQW9CbjFCLEdBQUcsQ0FBQ3o2QyxJQUFELEVBQU8sQ0FBUCxDQUF2QixFQUFrQ3k2QyxHQUFHLENBQUN6NkMsSUFBSSxHQUFHLENBQVIsRUFBVyxDQUFYLENBQXJDLEVBQW9ELFdBQXBEO1lBQ0ZvekMsRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0JwOUIsSUFBSSxHQUFHLElBQXZCLEVBQTZCaUksR0FBRyxDQUFDajNDLEVBQUQsRUFBSyxDQUFMLENBQWhDLEVBQXlDLElBQXpDLEVBQStDLFdBQS9DOzs7VUFFRjR2QyxFQUFFLENBQUNpbkIsY0FBSDtTQVZGO09BVkY7O01Bd0JBZ25DLElBQUksQ0FBQzBDLHFCQUFMLEdBQTZCLFVBQVMzd0QsRUFBVCxFQUFhO1FBQ3hDQSxFQUFFLENBQUM0d0QsYUFBSCxDQUFpQjtVQUFFMWMsTUFBTSxFQUFFO1NBQTNCO09BREY7O01BSUErWixJQUFJLENBQUM0QyxTQUFMLEdBQWlCLFVBQVM3d0QsRUFBVCxFQUFhO1FBQzVCLElBQUkwaUIsTUFBTSxHQUFHMWlCLEVBQUUsQ0FBQ3NnQyxjQUFILEVBQWI7WUFBa0N3d0IsTUFBTSxHQUFHLEVBQTNDOztRQUNBLEtBQUssSUFBSWorRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7VUFDdEMsSUFBSSs4QyxLQUFLLEdBQUc4eUIsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBbEI7Y0FBdUIrWixJQUFJLEdBQUdnakMsS0FBSyxDQUFDaGpDLElBQU4sRUFBOUI7VUFDQSxJQUFJbUIsS0FBSyxHQUFHbkIsSUFBSSxDQUFDd3lDLElBQWpCO2NBQXVCOTFDLEdBQUcsR0FBR3NtQyxLQUFLLENBQUN4L0IsRUFBTixHQUFXZ3ZDLElBQXhDOztVQUNBLE9BQU92c0QsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUFQLEdBQWdCLENBQXBCLElBQXlCaXlFLE1BQU0sQ0FBQzd2RSxDQUFDLEdBQUcsQ0FBTCxDQUFOLENBQWMrWixJQUFkLEdBQXFCd3lDLElBQXJCLElBQTZCOTFDLEdBQTdEO1lBQ0VBLEdBQUcsR0FBR281RCxNQUFNLENBQUMsRUFBRTd2RSxDQUFILENBQU4sQ0FBWXVkLEVBQVosR0FBaUJndkMsSUFBdkI7OztVQUNGMHhELE1BQU0sQ0FBQ3RoSCxJQUFQLENBQVk7WUFBQ3VlLEtBQUssRUFBRUEsS0FBUjtZQUFlekUsR0FBRyxFQUFFQSxHQUFwQjtZQUF5QmEsTUFBTSxFQUFFLENBQUN5bEMsS0FBSyxDQUFDdjBCLEtBQU4sRUFBRCxJQUFrQnpPO1dBQS9EOzs7UUFFRm96QyxFQUFFLENBQUNqTyxTQUFILENBQWEsWUFBVztVQUN0QixJQUFJOXNCLE1BQU0sR0FBRyxDQUFiO2NBQWdCeTlDLE1BQU0sR0FBRyxFQUF6Qjs7VUFDQSxLQUFLLElBQUk3dkUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2krRyxNQUFNLENBQUNyZ0gsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1lBQ3RDLElBQUlpaEMsR0FBRyxHQUFHZzlFLE1BQU0sQ0FBQ2orRyxDQUFELENBQWhCO1lBQ0EsSUFBSXNYLE1BQU0sR0FBRzJwQixHQUFHLENBQUMzcEIsTUFBSixJQUFjazlDLEdBQUcsQ0FBQ3Z6QixHQUFHLENBQUMzcEIsTUFBSixDQUFXaTFDLElBQVgsR0FBa0JuNkIsTUFBbkIsRUFBMkI2TyxHQUFHLENBQUMzcEIsTUFBSixDQUFXbUwsRUFBdEMsQ0FBOUI7Z0JBQXlFK0QsSUFBekU7O1lBQ0EsS0FBSyxJQUFJK2xDLElBQUksR0FBR3RyQixHQUFHLENBQUMvbEIsS0FBcEIsRUFBMkJxeEMsSUFBSSxJQUFJdHJCLEdBQUcsQ0FBQ3hxQixHQUF2QyxFQUE0QzgxQyxJQUFJLEVBQWhELEVBQW9EO2NBQ2xELElBQUkyeEQsTUFBTSxHQUFHM3hELElBQUksR0FBR242QixNQUFwQjtjQUNBLElBQUltNkIsSUFBSSxJQUFJdHJCLEdBQUcsQ0FBQ3hxQixHQUFoQixFQUFxQitQLElBQUksR0FBR2d1QyxHQUFHLENBQUMwcEQsTUFBRCxFQUFTL3dELEVBQUUsQ0FBQ2lHLE9BQUgsQ0FBVzhxRCxNQUFYLEVBQW1CdGdILE1BQW5CLEdBQTRCLENBQXJDLENBQVY7O2NBQ3JCLElBQUlzZ0gsTUFBTSxHQUFHL3dELEVBQUUsQ0FBQ2lRLFFBQUgsRUFBYixFQUE0QjtnQkFDMUJqUSxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixHQUFoQixFQUFxQm4xQixHQUFHLENBQUMwcEQsTUFBRCxDQUF4QixFQUFrQzFwRCxHQUFHLENBQUMwcEQsTUFBTSxHQUFHLENBQVYsRUFBYSxPQUFPbmtILElBQVAsQ0FBWW96RCxFQUFFLENBQUNpRyxPQUFILENBQVc4cUQsTUFBTSxHQUFHLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsRUFBdUN0Z0gsTUFBcEQsQ0FBckM7Z0JBQ0EsRUFBRXcwQixNQUFGOzs7O1lBR0p5OUMsTUFBTSxDQUFDbHpFLElBQVAsQ0FBWTtjQUFDMmEsTUFBTSxFQUFFQSxNQUFNLElBQUlrUCxJQUFuQjtjQUF5QkEsSUFBSSxFQUFFQTthQUEzQzs7O1VBRUYybUMsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUIvZCxNQUFqQixFQUF5QixDQUF6QjtTQWZGO09BVEY7O01BNEJBdXJDLElBQUksQ0FBQytDLGFBQUwsR0FBcUIsVUFBU2h4RCxFQUFULEVBQWE7UUFDaENBLEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO1VBQ3RCLElBQUl3cEQsVUFBVSxHQUFHdjdDLEVBQUUsQ0FBQ3NnQyxjQUFILEdBQW9CN3ZGLE1BQXJDOztVQUNBLEtBQUssSUFBSW9DLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwb0csVUFBcEIsRUFBZ0Mxb0csQ0FBQyxFQUFqQyxFQUFxQztZQUNuQyxJQUFJKzhDLEtBQUssR0FBR29RLEVBQUUsQ0FBQ3NnQyxjQUFILEdBQW9CenRGLENBQXBCLENBQVo7WUFDQSxJQUFJKzhDLEtBQUssQ0FBQ3YwQixLQUFOLEVBQUosRUFDRTJrQyxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQng4QixFQUFFLENBQUNpRyxPQUFILENBQVdyVyxLQUFLLENBQUN2MkIsSUFBTixDQUFXK2xDLElBQXRCLElBQThCLElBQTlDLEVBQW9EaUksR0FBRyxDQUFDelgsS0FBSyxDQUFDdjJCLElBQU4sQ0FBVytsQyxJQUFaLEVBQWtCLENBQWxCLENBQXZELEVBREYsS0FHRVksRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0J4OEIsRUFBRSxDQUFDaWdDLFFBQUgsQ0FBWXJ3QyxLQUFLLENBQUNoakMsSUFBTixFQUFaLEVBQTBCZ2pDLEtBQUssQ0FBQ3gvQixFQUFOLEVBQTFCLENBQWhCLEVBQXVEdy9CLEtBQUssQ0FBQ2hqQyxJQUFOLEVBQXZEOzs7VUFFSm96QyxFQUFFLENBQUNpbkIsY0FBSDtTQVRGO09BREY7O01BZUEsU0FBU2dxQyxTQUFULENBQW1CanhELEVBQW5CLEVBQXVCa3hELGFBQXZCLEVBQXNDdHpELFNBQXRDLEVBQWlEO1FBQy9DLElBQUlvQyxFQUFFLENBQUMyakMsVUFBSCxFQUFKLEVBQXFCLE9BQU9YLFVBQVUsQ0FBQ3JvQyxJQUFsQjtRQUNyQixJQUFJK25CLE1BQU0sR0FBRzFpQixFQUFFLENBQUNzZ0MsY0FBSCxFQUFiO1lBQWtDNndCLE1BQU0sR0FBRyxFQUEzQztZQUErQ3JpRSxRQUEvQzs7UUFDQSxLQUFLLElBQUlqOEMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1VBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCO1VBQ0EsSUFBSSs4QyxLQUFLLENBQUN2MEIsS0FBTixFQUFKLEVBQW1CO1VBQ25CLElBQUl6TyxJQUFJLEdBQUdnakMsS0FBSyxDQUFDaGpDLElBQU4sR0FBYXd5QyxJQUF4QjtjQUE4Qmh2QyxFQUFFLEdBQUd3L0IsS0FBSyxDQUFDeC9CLEVBQU4sR0FBV2d2QyxJQUE5Qzs7VUFDQSxPQUFPdnNELENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBUCxHQUFnQixDQUFwQixJQUF5Qml5RSxNQUFNLENBQUM3dkUsQ0FBQyxHQUFHLENBQUwsQ0FBTixDQUFjK1osSUFBZCxHQUFxQnd5QyxJQUFyQixJQUE2Qmh2QyxFQUE3RDtZQUNFQSxFQUFFLEdBQUdzeUQsTUFBTSxDQUFDLEVBQUU3dkUsQ0FBSCxDQUFOLENBQVl1ZCxFQUFaLEdBQWlCZ3ZDLElBQXRCOzs7VUFDRixJQUFJLENBQUNzakIsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVdWQsRUFBVixHQUFla0YsRUFBcEIsRUFBd0JsRixFQUFFO1VBQzFCK2dHLE1BQU0sQ0FBQzNoSCxJQUFQLENBQVlvZCxJQUFaLEVBQWtCd0QsRUFBbEI7OztRQUVGLElBQUkrZ0csTUFBTSxDQUFDMWdILE1BQVgsRUFBbUJxK0MsUUFBUSxHQUFHLElBQVgsQ0FBbkIsS0FDS3FpRSxNQUFNLENBQUMzaEgsSUFBUCxDQUFZd3dELEVBQUUsQ0FBQ3kxQixTQUFILEVBQVosRUFBNEJ6MUIsRUFBRSxDQUFDaVEsUUFBSCxFQUE1QjtRQUVMalEsRUFBRSxDQUFDak8sU0FBSCxDQUFhLFlBQVc7VUFDdEIsSUFBSTJ3QixNQUFNLEdBQUcsRUFBYjs7VUFDQSxLQUFLLElBQUk3dkUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3MrRyxNQUFNLENBQUMxZ0gsTUFBM0IsRUFBbUNvQyxDQUFDLElBQUksQ0FBeEMsRUFBMkM7WUFDekMsSUFBSStaLElBQUksR0FBR3VrRyxNQUFNLENBQUN0K0csQ0FBRCxDQUFqQjtnQkFBc0J1ZCxFQUFFLEdBQUcrZ0csTUFBTSxDQUFDdCtHLENBQUMsR0FBRyxDQUFMLENBQWpDO1lBQ0EsSUFBSWtiLEtBQUssR0FBR3M1QyxHQUFHLENBQUN6NkMsSUFBRCxFQUFPLENBQVAsQ0FBZjtnQkFBMEJ0RCxHQUFHLEdBQUcrOUMsR0FBRyxDQUFDajNDLEVBQUQsQ0FBbkM7WUFDQSxJQUFJZzJDLEtBQUssR0FBR3BHLEVBQUUsQ0FBQ2lnQyxRQUFILENBQVlseUUsS0FBWixFQUFtQnpFLEdBQW5CLEVBQXdCLEtBQXhCLENBQVo7WUFDQSxJQUFJNG5HLGFBQUosRUFDRTlxRCxLQUFLLENBQUNqNEMsSUFBTixDQUFXLFVBQVNqaEIsQ0FBVCxFQUFZeUQsQ0FBWixFQUFlO2NBQUUsT0FBT3pELENBQUMsR0FBR3lELENBQUosR0FBUSxDQUFDaXRELFNBQVQsR0FBcUIxd0QsQ0FBQyxJQUFJeUQsQ0FBTCxHQUFTLENBQVQsR0FBYWl0RCxTQUF6QzthQUE1QixFQURGLEtBR0V3SSxLQUFLLENBQUNqNEMsSUFBTixDQUFXLFVBQVNqaEIsQ0FBVCxFQUFZeUQsQ0FBWixFQUFlO2NBQ3hCLElBQUl5Z0gsRUFBRSxHQUFHbGtILENBQUMsQ0FBQzZ1RCxXQUFGLEVBQVQ7a0JBQTBCczFELEVBQUUsR0FBRzFnSCxDQUFDLENBQUNvckQsV0FBRixFQUEvQjs7Y0FDQSxJQUFJcTFELEVBQUUsSUFBSUMsRUFBVixFQUFjO2dCQUFFbmtILENBQUMsR0FBR2trSCxFQUFKO2dCQUFRemdILENBQUMsR0FBRzBnSCxFQUFKOzs7Y0FDeEIsT0FBT25rSCxDQUFDLEdBQUd5RCxDQUFKLEdBQVEsQ0FBQ2l0RCxTQUFULEdBQXFCMXdELENBQUMsSUFBSXlELENBQUwsR0FBUyxDQUFULEdBQWFpdEQsU0FBekM7YUFIRjtZQUtGb0MsRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0JwMkIsS0FBaEIsRUFBdUJyNEMsS0FBdkIsRUFBOEJ6RSxHQUE5QjtZQUNBLElBQUl3bEMsUUFBSixFQUFjNHpCLE1BQU0sQ0FBQ2x6RSxJQUFQLENBQVk7Y0FBQzJhLE1BQU0sRUFBRTRELEtBQVQ7Y0FBZ0JzTCxJQUFJLEVBQUVndUMsR0FBRyxDQUFDajNDLEVBQUUsR0FBRyxDQUFOLEVBQVMsQ0FBVDthQUFyQzs7O1VBRWhCLElBQUkwK0IsUUFBSixFQUFja1IsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUIvZCxNQUFqQixFQUF5QixDQUF6QjtTQWpCaEI7OztNQXFCRnVyQyxJQUFJLENBQUNnRCxTQUFMLEdBQWlCLFVBQVNqeEQsRUFBVCxFQUFhO1FBQUVpeEQsU0FBUyxDQUFDanhELEVBQUQsRUFBSyxJQUFMLEVBQVcsQ0FBWCxDQUFUO09BQWhDOztNQUNBaXVELElBQUksQ0FBQ3FELGdCQUFMLEdBQXdCLFVBQVN0eEQsRUFBVCxFQUFhO1FBQUVpeEQsU0FBUyxDQUFDanhELEVBQUQsRUFBSyxJQUFMLEVBQVcsQ0FBQyxDQUFaLENBQVQ7T0FBdkM7O01BQ0FpdUQsSUFBSSxDQUFDc0Qsb0JBQUwsR0FBNEIsVUFBU3Z4RCxFQUFULEVBQWE7UUFBRWl4RCxTQUFTLENBQUNqeEQsRUFBRCxFQUFLLEtBQUwsRUFBWSxDQUFaLENBQVQ7T0FBM0M7O01BQ0FpdUQsSUFBSSxDQUFDdUQsMkJBQUwsR0FBbUMsVUFBU3h4RCxFQUFULEVBQWE7UUFBRWl4RCxTQUFTLENBQUNqeEQsRUFBRCxFQUFLLEtBQUwsRUFBWSxDQUFDLENBQWIsQ0FBVDtPQUFsRDs7TUFFQWl1RCxJQUFJLENBQUN3RCxZQUFMLEdBQW9CLFVBQVN6eEQsRUFBVCxFQUFhO1FBQy9CLElBQUk0dEQsS0FBSyxHQUFHNXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVN3N0UsZ0JBQXJCO1FBQ0EsSUFBSTlELEtBQUosRUFBVyxPQUFPQSxLQUFLLENBQUNuOUcsTUFBYixFQUFxQjtVQUM5QixJQUFJeW5ELE9BQU8sR0FBRzAxRCxLQUFLLENBQUM3bkMsS0FBTixFQUFkO1VBQ0EsSUFBSWxwQixLQUFLLEdBQUczRSxPQUFPLENBQUN2bkMsSUFBUixFQUFaOztVQUNBLElBQUlrc0MsS0FBSixFQUFXO1lBQ1Qrd0QsS0FBSyxDQUFDcCtHLElBQU4sQ0FBVzBvRCxPQUFYO1lBQ0EsT0FBTzhILEVBQUUsQ0FBQ3E1QixZQUFILENBQWdCeDhCLEtBQUssQ0FBQ2p3QyxJQUF0QixFQUE0Qml3QyxLQUFLLENBQUN6c0MsRUFBbEMsQ0FBUDs7O09BUE47O01BWUE2OUYsSUFBSSxDQUFDMEQsWUFBTCxHQUFvQixVQUFTM3hELEVBQVQsRUFBYTtRQUMvQixJQUFJNHRELEtBQUssR0FBRzV0RCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTdzdFLGdCQUFyQjtRQUNBLElBQUk5RCxLQUFKLEVBQVcsT0FBT0EsS0FBSyxDQUFDbjlHLE1BQWIsRUFBcUI7VUFDOUJtOUcsS0FBSyxDQUFDNWtFLE9BQU4sQ0FBYzRrRSxLQUFLLENBQUNuMkUsR0FBTixFQUFkO1VBQ0EsSUFBSW9sQixLQUFLLEdBQUcrd0QsS0FBSyxDQUFDQSxLQUFLLENBQUNuOUcsTUFBTixHQUFlLENBQWhCLENBQUwsQ0FBd0JrZ0IsSUFBeEIsRUFBWjtVQUNBLElBQUksQ0FBQ2tzQyxLQUFMLEVBQ0Urd0QsS0FBSyxDQUFDbjJFLEdBQU4sR0FERixLQUdFLE9BQU91b0IsRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0J4OEIsS0FBSyxDQUFDandDLElBQXRCLEVBQTRCaXdDLEtBQUssQ0FBQ3pzQyxFQUFsQyxDQUFQOztPQVJOOztNQVlBNjlGLElBQUksQ0FBQzJELGNBQUwsR0FBc0IsVUFBUzV4RCxFQUFULEVBQWE7UUFDakMsSUFBSTBpQixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtRQUNBLElBQUlzdEIsS0FBSyxHQUFHNXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVN3N0UsZ0JBQVQsS0FBOEIxeEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3c3RSxnQkFBVCxHQUE0QixFQUExRCxDQUFaOztRQUNBLEtBQUssSUFBSTcrRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUEzQixFQUFtQ29DLENBQUMsRUFBcEMsRUFBd0M7VUFDdEMsSUFBSStaLElBQUksR0FBRzgxRCxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVUrWixJQUFWLEVBQVg7Y0FBNkJ3RCxFQUFFLEdBQUdzeUQsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVdWQsRUFBVixFQUFsQztVQUNBLElBQUl5c0MsS0FBSyxHQUFHNmxCLE1BQU0sQ0FBQzd2RSxDQUFELENBQU4sQ0FBVXdvQixLQUFWLEtBQW9CMmtDLEVBQUUsQ0FBQ3dpQyxXQUFILENBQWU1MUUsSUFBZixDQUFwQixHQUEyQ296QyxFQUFFLENBQUNtL0IsU0FBSCxDQUFhdnlFLElBQWIsRUFBbUJ3RCxFQUFuQixDQUF2RDs7VUFDQSxLQUFLLElBQUl2VixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ2lELEtBQUssQ0FBQ3BzRCxNQUExQixFQUFrQ29LLENBQUMsRUFBbkMsRUFBdUM7WUFDckMsSUFBSWdpRCxLQUFLLENBQUNoaUQsQ0FBRCxDQUFMLENBQVNnM0csZUFBYixFQUE4QjtjQUM1QmgxRCxLQUFLLENBQUNoaUQsQ0FBRCxDQUFMLENBQVNpZSxLQUFUOztjQUNBLEtBQUssSUFBSS9kLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2eUcsS0FBSyxDQUFDbjlHLE1BQTFCLEVBQWtDc0ssQ0FBQyxFQUFuQztnQkFDRSxJQUFJNnlHLEtBQUssQ0FBQzd5RyxDQUFELENBQUwsSUFBWThoRCxLQUFLLENBQUNoaUQsQ0FBRCxDQUFyQixFQUNFK3lHLEtBQUssQ0FBQy9zRixNQUFOLENBQWE5bEIsQ0FBQyxFQUFkLEVBQWtCLENBQWxCOzs7Y0FDSjs7OztVQUdKLElBQUlGLENBQUMsSUFBSWdpRCxLQUFLLENBQUNwc0QsTUFBZixFQUNFbTlHLEtBQUssQ0FBQ3ArRyxJQUFOLENBQVd3d0QsRUFBRSxDQUFDdytCLFFBQUgsQ0FBWTV4RSxJQUFaLEVBQWtCd0QsRUFBbEIsRUFBc0I7WUFBQ3loRyxlQUFlLEVBQUUsSUFBbEI7WUFBd0IvakQsY0FBYyxFQUFFO1dBQTlELENBQVg7O09BaEJOOztNQW9CQW1nRCxJQUFJLENBQUM2RCxjQUFMLEdBQXNCLFVBQVM5eEQsRUFBVCxFQUFhO1FBQ2pDLElBQUk0dEQsS0FBSyxHQUFHNXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVN3N0UsZ0JBQXJCO1FBQ0EsSUFBSTlELEtBQUosRUFBVyxLQUFLLElBQUkvNkcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRys2RyxLQUFLLENBQUNuOUcsTUFBMUIsRUFBa0NvQyxDQUFDLEVBQW5DO1VBQXVDKzZHLEtBQUssQ0FBQy82RyxDQUFELENBQUwsQ0FBU2ltQixLQUFUOztRQUNsRDgwRixLQUFLLENBQUNuOUcsTUFBTixHQUFlLENBQWY7T0FIRjs7TUFNQXc5RyxJQUFJLENBQUM4RCxlQUFMLEdBQXVCLFVBQVMveEQsRUFBVCxFQUFhO1FBQ2xDLElBQUk0dEQsS0FBSyxHQUFHNXRELEVBQUUsQ0FBQzlwQixLQUFILENBQVN3N0UsZ0JBQXJCO1lBQXVDaHZDLE1BQU0sR0FBRyxFQUFoRDtRQUNBLElBQUlrckMsS0FBSixFQUFXLEtBQUssSUFBSS82RyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHKzZHLEtBQUssQ0FBQ245RyxNQUExQixFQUFrQ29DLENBQUMsRUFBbkMsRUFBdUM7VUFDaEQsSUFBSWdxRCxLQUFLLEdBQUcrd0QsS0FBSyxDQUFDLzZHLENBQUQsQ0FBTCxDQUFTOGQsSUFBVCxFQUFaO1VBQ0EsSUFBSSxDQUFDa3NDLEtBQUwsRUFDRSt3RCxLQUFLLENBQUMvc0YsTUFBTixDQUFhaHVCLENBQUMsRUFBZCxFQUFrQixDQUFsQixFQURGLEtBR0U2dkUsTUFBTSxDQUFDbHpFLElBQVAsQ0FBWTtZQUFDMmEsTUFBTSxFQUFFMHlDLEtBQUssQ0FBQ2p3QyxJQUFmO1lBQXFCeU0sSUFBSSxFQUFFd2pDLEtBQUssQ0FBQ3pzQztXQUE3Qzs7UUFFSixJQUFJc3lELE1BQU0sQ0FBQ2p5RSxNQUFYLEVBQ0V1dkQsRUFBRSxDQUFDeWdDLGFBQUgsQ0FBaUIvZCxNQUFqQixFQUF5QixDQUF6QjtPQVZKOztNQWFBLFNBQVNzdkMscUJBQVQsQ0FBK0JoeUQsRUFBL0IsRUFBbUNzbUMsR0FBbkMsRUFBd0M7UUFDdEN0bUMsRUFBRSxDQUFDak8sU0FBSCxDQUFhLFlBQVc7VUFDdEIsSUFBSTJ3QixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjtjQUFrQzJ4QixPQUFPLEdBQUcsRUFBNUM7Y0FBZ0RDLFlBQVksR0FBRyxFQUEvRDs7VUFDQSxLQUFLLElBQUlyL0csQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZ2RSxNQUFNLENBQUNqeUUsTUFBM0IsRUFBbUNvQyxDQUFDLEVBQXBDLEVBQXdDO1lBQ3RDLElBQUkrOEMsS0FBSyxHQUFHOHlCLE1BQU0sQ0FBQzd2RSxDQUFELENBQWxCOztZQUNBLElBQUkrOEMsS0FBSyxDQUFDdjBCLEtBQU4sRUFBSixFQUFtQjtjQUFFNDJGLE9BQU8sQ0FBQ3ppSCxJQUFSLENBQWFxRCxDQUFiO2NBQWlCcS9HLFlBQVksQ0FBQzFpSCxJQUFiLENBQWtCLEVBQWxCO2FBQXRDLE1BQ0swaUgsWUFBWSxDQUFDMWlILElBQWIsQ0FBa0I4MkYsR0FBRyxDQUFDdG1DLEVBQUUsQ0FBQ2lnQyxRQUFILENBQVlyd0MsS0FBSyxDQUFDaGpDLElBQU4sRUFBWixFQUEwQmdqQyxLQUFLLENBQUN4L0IsRUFBTixFQUExQixDQUFELENBQXJCOzs7VUFFUDR2QyxFQUFFLENBQUM4Z0MsaUJBQUgsQ0FBcUJveEIsWUFBckIsRUFBbUMsUUFBbkMsRUFBNkMsTUFBN0M7O1VBQ0EsS0FBSyxJQUFJci9HLENBQUMsR0FBR28vRyxPQUFPLENBQUN4aEgsTUFBUixHQUFpQixDQUF6QixFQUE0QmlpQixFQUFqQyxFQUFxQzdmLENBQUMsSUFBSSxDQUExQyxFQUE2Q0EsQ0FBQyxFQUE5QyxFQUFrRDtZQUNoRCxJQUFJKzhDLEtBQUssR0FBRzh5QixNQUFNLENBQUN1dkMsT0FBTyxDQUFDcC9HLENBQUQsQ0FBUixDQUFsQjtZQUNBLElBQUk2ZixFQUFFLElBQUlzd0UsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQmx4RCxLQUFLLENBQUN2MkIsSUFBeEIsRUFBOEIzRyxFQUE5QixJQUFvQyxDQUE5QyxFQUFpRDtZQUNqRCxJQUFJMGdGLElBQUksR0FBR2ljLE1BQU0sQ0FBQ3J2RCxFQUFELEVBQUtwUSxLQUFLLENBQUN2MkIsSUFBWCxDQUFqQjtZQUNBM0csRUFBRSxHQUFHMGdGLElBQUksQ0FBQ3htRixJQUFWO1lBQ0FvekMsRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0I4SixHQUFHLENBQUM4TSxJQUFJLENBQUNBLElBQU4sQ0FBbkIsRUFBZ0NBLElBQUksQ0FBQ3htRixJQUFyQyxFQUEyQ3dtRixJQUFJLENBQUNoakYsRUFBaEQ7O1NBYko7OztNQWtCRjY5RixJQUFJLENBQUNrRSxjQUFMLEdBQXNCLFVBQVNueUQsRUFBVCxFQUFhO1FBQ2pDLElBQUlBLEVBQUUsQ0FBQ20wQixpQkFBSCxFQUFKLEVBQTRCLE9BQU82TyxVQUFVLENBQUNyb0MsSUFBbEI7UUFFNUJxRixFQUFFLENBQUNqTyxTQUFILENBQWEsWUFBVztVQUN0QixJQUFJd3dCLE9BQU8sR0FBR3ZpQixFQUFFLENBQUNzZ0MsY0FBSCxFQUFkO1VBQ0EsSUFBSStULFVBQVUsR0FBR3IwQyxFQUFFLENBQUMyUixTQUFILENBQWEsWUFBYixDQUFqQjs7VUFFQSxLQUFLLElBQUk5K0QsQ0FBQyxHQUFHMHZFLE9BQU8sQ0FBQzl4RSxNQUFSLEdBQWlCLENBQTlCLEVBQWlDb0MsQ0FBQyxJQUFJLENBQXRDLEVBQXlDQSxDQUFDLEVBQTFDLEVBQThDO1lBQzVDLElBQUlrd0UsTUFBTSxHQUFHUixPQUFPLENBQUMxdkUsQ0FBRCxDQUFQLENBQVd3bUIsSUFBeEI7WUFDQSxJQUFJKzRGLGFBQWEsR0FBR3B5RCxFQUFFLENBQUNpZ0MsUUFBSCxDQUFZO2NBQUM3Z0MsSUFBSSxFQUFFMmpCLE1BQU0sQ0FBQzNqQixJQUFkO2NBQW9COXBDLEVBQUUsRUFBRTthQUFwQyxFQUF3Q3l0RCxNQUF4QyxDQUFwQjtZQUNBLElBQUkxZCxNQUFNLEdBQUcyOUIsVUFBVSxDQUFDaHBDLFdBQVgsQ0FBdUJvNEQsYUFBdkIsRUFBc0MsSUFBdEMsRUFBNENweUQsRUFBRSxDQUFDMlIsU0FBSCxDQUFhLFNBQWIsQ0FBNUMsQ0FBYixDQUg0Qzs7WUFNNUMsSUFBSTBnRCxTQUFTLEdBQUdyeUQsRUFBRSxDQUFDKzNDLFFBQUgsQ0FBWWgxQixNQUFaLEVBQW9CLENBQUMsQ0FBckIsRUFBd0IsTUFBeEIsRUFBZ0MsS0FBaEMsQ0FBaEI7O1lBRUEsSUFBSXF2QyxhQUFhLElBQUksQ0FBQyxLQUFLLzBHLElBQUwsQ0FBVSswRyxhQUFWLENBQWxCLElBQThDL3NELE1BQU0sR0FBR2d2QyxVQUFULElBQXVCLENBQXpFLEVBQTRFO2NBQzFFLElBQUlpZSxVQUFVLEdBQUcsSUFBSWpyRCxHQUFKLENBQVEwYixNQUFNLENBQUMzakIsSUFBZixFQUNmNGpDLFVBQVUsQ0FBQy9uQyxVQUFYLENBQXNCbTNELGFBQXRCLEVBQXFDL3NELE1BQU0sR0FBR2d2QyxVQUE5QyxFQUEwREEsVUFBMUQsQ0FEZSxDQUFqQixDQUQwRTs7Y0FLMUUsSUFBSWllLFVBQVUsQ0FBQ2g5RixFQUFYLElBQWlCeXRELE1BQU0sQ0FBQ3p0RCxFQUE1QixFQUFnQys4RixTQUFTLEdBQUdDLFVBQVo7OztZQUdsQ3R5RCxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixFQUFoQixFQUFvQjYxQixTQUFwQixFQUErQnR2QyxNQUEvQixFQUF1QyxTQUF2Qzs7U0FwQko7T0FIRjs7TUE0QkFrckMsSUFBSSxDQUFDc0UsWUFBTCxHQUFvQixVQUFTdnlELEVBQVQsRUFBYTtRQUMvQkEsRUFBRSxDQUFDak8sU0FBSCxDQUFhLFlBQVc7VUFDdEIsSUFBSTJ3QixNQUFNLEdBQUcxaUIsRUFBRSxDQUFDc2dDLGNBQUgsRUFBYjs7VUFDQSxLQUFLLElBQUl6dEYsQ0FBQyxHQUFHNnZFLE1BQU0sQ0FBQ2p5RSxNQUFQLEdBQWdCLENBQTdCLEVBQWdDb0MsQ0FBQyxJQUFJLENBQXJDLEVBQXdDQSxDQUFDLEVBQXpDO1lBQ0VtdEQsRUFBRSxDQUFDdzhCLFlBQUgsQ0FBZ0IsRUFBaEIsRUFBb0I5WixNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVVzWCxNQUE5QixFQUFzQ2s5QyxHQUFHLENBQUNxYixNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVV1ZCxFQUFWLEdBQWVndkMsSUFBaEIsQ0FBekMsRUFBZ0UsU0FBaEU7OztVQUNGWSxFQUFFLENBQUNpbkIsY0FBSDtTQUpGO09BREY7O01BU0FnbkMsSUFBSSxDQUFDdUUsY0FBTCxHQUFzQixVQUFTeHlELEVBQVQsRUFBYTtRQUNqQ2d5RCxxQkFBcUIsQ0FBQ2h5RCxFQUFELEVBQUssVUFBU2xnRCxHQUFULEVBQWM7VUFBRSxPQUFPQSxHQUFHLENBQUNpOEMsV0FBSixFQUFQO1NBQXJCLENBQXJCO09BREY7O01BR0FreUQsSUFBSSxDQUFDd0UsZ0JBQUwsR0FBd0IsVUFBU3p5RCxFQUFULEVBQWE7UUFDbkNneUQscUJBQXFCLENBQUNoeUQsRUFBRCxFQUFLLFVBQVNsZ0QsR0FBVCxFQUFjO1VBQUUsT0FBT0EsR0FBRyxDQUFDb0ssV0FBSixFQUFQO1NBQXJCLENBQXJCO09BREY7O01BSUErakcsSUFBSSxDQUFDeUUsY0FBTCxHQUFzQixVQUFTMXlELEVBQVQsRUFBYTtRQUNqQyxJQUFJQSxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeThFLFdBQWIsRUFBMEIzeUQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3k4RSxXQUFULENBQXFCNzVGLEtBQXJCO1FBQzFCa25DLEVBQUUsQ0FBQzlwQixLQUFILENBQVN5OEUsV0FBVCxHQUF1QjN5RCxFQUFFLENBQUNzaUMsV0FBSCxDQUFldGlDLEVBQUUsQ0FBQ3lvQixTQUFILEVBQWYsQ0FBdkI7T0FGRjs7TUFJQXdsQyxJQUFJLENBQUMyRSxtQkFBTCxHQUEyQixVQUFTNXlELEVBQVQsRUFBYTtRQUN0QyxJQUFJbkQsS0FBSyxHQUFHbUQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3k4RSxXQUFULElBQXdCM3lELEVBQUUsQ0FBQzlwQixLQUFILENBQVN5OEUsV0FBVCxDQUFxQmhpRyxJQUFyQixFQUFwQztRQUNBLElBQUlrc0MsS0FBSixFQUFXbUQsRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0JyNUIsRUFBRSxDQUFDeW9CLFNBQUgsRUFBaEIsRUFBZ0M1ckIsS0FBaEM7T0FGYjs7TUFJQW94RCxJQUFJLENBQUM0RSxtQkFBTCxHQUEyQixVQUFTN3lELEVBQVQsRUFBYTtRQUN0QyxJQUFJbkQsS0FBSyxHQUFHbUQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3k4RSxXQUFULElBQXdCM3lELEVBQUUsQ0FBQzlwQixLQUFILENBQVN5OEUsV0FBVCxDQUFxQmhpRyxJQUFyQixFQUFwQzs7UUFDQSxJQUFJa3NDLEtBQUosRUFBVztVQUNULElBQUlqd0MsSUFBSSxHQUFHb3pDLEVBQUUsQ0FBQ3lvQixTQUFILEVBQVg7Y0FBMkJyNEQsRUFBRSxHQUFHeXNDLEtBQWhDOztVQUNBLElBQUltbUMsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQmwwRixJQUFsQixFQUF3QndELEVBQXhCLElBQThCLENBQWxDLEVBQXFDO1lBQUUsSUFBSTRsQyxHQUFHLEdBQUc1bEMsRUFBVjtZQUFjQSxFQUFFLEdBQUd4RCxJQUFMO1lBQVdBLElBQUksR0FBR29wQyxHQUFQOzs7VUFDaEVnSyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTNDhFLGFBQVQsR0FBeUI5eUQsRUFBRSxDQUFDaWdDLFFBQUgsQ0FBWXJ6RSxJQUFaLEVBQWtCd0QsRUFBbEIsQ0FBekI7VUFDQTR2QyxFQUFFLENBQUN3OEIsWUFBSCxDQUFnQixFQUFoQixFQUFvQjV2RSxJQUFwQixFQUEwQndELEVBQTFCOztPQU5KOztNQVNBNjlGLElBQUksQ0FBQzhFLG1CQUFMLEdBQTJCLFVBQVMveUQsRUFBVCxFQUFhO1FBQ3RDLElBQUluRCxLQUFLLEdBQUdtRCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeThFLFdBQVQsSUFBd0IzeUQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBU3k4RSxXQUFULENBQXFCaGlHLElBQXJCLEVBQXBDOztRQUNBLElBQUlrc0MsS0FBSixFQUFXO1VBQ1RtRCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeThFLFdBQVQsQ0FBcUI3NUYsS0FBckI7VUFDQWtuQyxFQUFFLENBQUM5cEIsS0FBSCxDQUFTeThFLFdBQVQsR0FBdUIzeUQsRUFBRSxDQUFDc2lDLFdBQUgsQ0FBZXRpQyxFQUFFLENBQUN5b0IsU0FBSCxFQUFmLENBQXZCO1VBQ0F6b0IsRUFBRSxDQUFDdWdDLFNBQUgsQ0FBYTFqQyxLQUFiOztPQUxKOztNQVFBb3hELElBQUksQ0FBQytFLFdBQUwsR0FBbUIsVUFBU2h6RCxFQUFULEVBQWE7UUFDOUIsSUFBSUEsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzQ4RSxhQUFULElBQTBCLElBQTlCLEVBQ0U5eUQsRUFBRSxDQUFDNGdDLGdCQUFILENBQW9CNWdDLEVBQUUsQ0FBQzlwQixLQUFILENBQVM0OEUsYUFBN0IsRUFBNEMsSUFBNUMsRUFBa0QsT0FBbEQ7T0FGSjs7TUFLQTdFLElBQUksQ0FBQ2dGLFlBQUwsR0FBb0IsVUFBU2p6RCxFQUFULEVBQWE7UUFDL0IsSUFBSXI1QyxHQUFHLEdBQUdxNUMsRUFBRSxDQUFDc2UsWUFBSCxDQUFnQixJQUFoQixFQUFzQixPQUF0QixDQUFWO1FBQ0F0ZSxFQUFFLENBQUN3NEMsUUFBSCxDQUFZLElBQVosRUFBa0IsQ0FBQzd4RixHQUFHLENBQUM0bUMsR0FBSixHQUFVNW1DLEdBQUcsQ0FBQ3l6RCxNQUFmLElBQXlCLENBQXpCLEdBQTZCcGEsRUFBRSxDQUFDeTRDLGFBQUgsR0FBbUI5K0IsWUFBbkIsR0FBa0MsQ0FBakY7T0FGRjs7TUFLQSxTQUFTdTVDLFNBQVQsQ0FBbUJsekQsRUFBbkIsRUFBdUI7UUFDckIsSUFBSXB6QyxJQUFJLEdBQUdvekMsRUFBRSxDQUFDeW9CLFNBQUgsQ0FBYSxNQUFiLENBQVg7WUFBaUNyNEQsRUFBRSxHQUFHNHZDLEVBQUUsQ0FBQ3lvQixTQUFILENBQWEsSUFBYixDQUF0Qzs7UUFDQSxJQUFJdWEsVUFBVSxDQUFDOGQsTUFBWCxDQUFrQmwwRixJQUFsQixFQUF3QndELEVBQXhCLEtBQStCLENBQW5DLEVBQXNDO1VBQ3BDLElBQUlnakYsSUFBSSxHQUFHaWMsTUFBTSxDQUFDcnZELEVBQUQsRUFBS3B6QyxJQUFMLENBQWpCO1VBQ0EsSUFBSSxDQUFDd21GLElBQUksQ0FBQ0EsSUFBVixFQUFnQjtVQUNoQnhtRixJQUFJLEdBQUd3bUYsSUFBSSxDQUFDeG1GLElBQVo7VUFDQXdELEVBQUUsR0FBR2dqRixJQUFJLENBQUNoakYsRUFBVjs7O1FBRUYsT0FBTztVQUFDeEQsSUFBSSxFQUFFQSxJQUFQO1VBQWF3RCxFQUFFLEVBQUVBLEVBQWpCO1VBQXFCMDdGLEtBQUssRUFBRTlyRCxFQUFFLENBQUNpZ0MsUUFBSCxDQUFZcnpFLElBQVosRUFBa0J3RCxFQUFsQixDQUE1QjtVQUFtRGdqRixJQUFJLEVBQUVBO1NBQWhFOzs7TUFHRixTQUFTK2YsV0FBVCxDQUFxQm56RCxFQUFyQixFQUF5Qmt0RCxPQUF6QixFQUFrQztRQUNoQyxJQUFJdDdHLE1BQU0sR0FBR3NoSCxTQUFTLENBQUNsekQsRUFBRCxDQUF0QjtRQUNBLElBQUksQ0FBQ3B1RCxNQUFMLEVBQWE7UUFDYixJQUFJazZHLEtBQUssR0FBR2w2RyxNQUFNLENBQUNrNkcsS0FBbkI7UUFDQSxJQUFJN3VELEdBQUcsR0FBRytDLEVBQUUsQ0FBQzBzRCxlQUFILENBQW1CWixLQUFuQixFQUEwQm9CLE9BQU8sR0FBR3Q3RyxNQUFNLENBQUN3ZSxFQUFWLEdBQWV4ZSxNQUFNLENBQUNnYixJQUF2RCxDQUFWOztRQUVBLElBQUlzZ0csT0FBTyxHQUFHandELEdBQUcsQ0FBQ3V2RCxRQUFKLEVBQUgsR0FBb0J2dkQsR0FBRyxDQUFDd3ZELFlBQUosRUFBL0IsRUFBbUQ7VUFDakR6c0QsRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0JwOEIsR0FBRyxDQUFDcndDLElBQUosRUFBaEIsRUFBNEJxd0MsR0FBRyxDQUFDN3NDLEVBQUosRUFBNUI7U0FERixNQUVPO1VBQ0w2c0MsR0FBRyxHQUFHK0MsRUFBRSxDQUFDMHNELGVBQUgsQ0FBbUJaLEtBQW5CLEVBQTBCb0IsT0FBTyxHQUFHN2xELEdBQUcsQ0FBQ3JILEVBQUUsQ0FBQ3kxQixTQUFILEVBQUQsRUFBaUIsQ0FBakIsQ0FBTixHQUNHejFCLEVBQUUsQ0FBQzRILE9BQUgsQ0FBV1AsR0FBRyxDQUFDckgsRUFBRSxDQUFDaVEsUUFBSCxFQUFELENBQWQsQ0FEcEMsQ0FBTjtVQUVBLElBQUlpOUMsT0FBTyxHQUFHandELEdBQUcsQ0FBQ3V2RCxRQUFKLEVBQUgsR0FBb0J2dkQsR0FBRyxDQUFDd3ZELFlBQUosRUFBL0IsRUFDRXpzRCxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQnA4QixHQUFHLENBQUNyd0MsSUFBSixFQUFoQixFQUE0QnF3QyxHQUFHLENBQUM3c0MsRUFBSixFQUE1QixFQURGLEtBRUssSUFBSXhlLE1BQU0sQ0FBQ3doRyxJQUFYLEVBQ0hwekMsRUFBRSxDQUFDcTVCLFlBQUgsQ0FBZ0J6bkYsTUFBTSxDQUFDZ2IsSUFBdkIsRUFBNkJoYixNQUFNLENBQUN3ZSxFQUFwQzs7OztNQUdONjlGLElBQUksQ0FBQ21GLFNBQUwsR0FBaUIsVUFBU3B6RCxFQUFULEVBQWE7UUFBRW16RCxXQUFXLENBQUNuekQsRUFBRCxFQUFLLElBQUwsQ0FBWDtPQUFoQzs7TUFDQWl1RCxJQUFJLENBQUNvRixpQkFBTCxHQUF5QixVQUFTcnpELEVBQVQsRUFBYTtRQUFFbXpELFdBQVcsQ0FBQ256RCxFQUFELEVBQUksS0FBSixDQUFYO09BQXhDOztNQUNBaXVELElBQUksQ0FBQ3FGLFlBQUwsR0FBb0IsVUFBU3R6RCxFQUFULEVBQWE7UUFDL0IsSUFBSXB1RCxNQUFNLEdBQUdzaEgsU0FBUyxDQUFDbHpELEVBQUQsQ0FBdEI7UUFDQSxJQUFJLENBQUNwdUQsTUFBTCxFQUFhO1FBQ2IsSUFBSXFyRCxHQUFHLEdBQUcrQyxFQUFFLENBQUMwc0QsZUFBSCxDQUFtQjk2RyxNQUFNLENBQUNrNkcsS0FBMUIsQ0FBVjtRQUNBLElBQUlTLE9BQU8sR0FBRyxFQUFkO1FBQ0EsSUFBSWdILFlBQVksR0FBRyxDQUFDLENBQXBCOztRQUNBLE9BQU90MkQsR0FBRyxDQUFDdXZELFFBQUosRUFBUCxFQUF1QjtVQUNyQkQsT0FBTyxDQUFDLzhHLElBQVIsQ0FBYTtZQUFDMmEsTUFBTSxFQUFFOHlDLEdBQUcsQ0FBQ3J3QyxJQUFKLEVBQVQ7WUFBcUJ5TSxJQUFJLEVBQUU0akMsR0FBRyxDQUFDN3NDLEVBQUo7V0FBeEM7VUFDQSxJQUFJNnNDLEdBQUcsQ0FBQ3J3QyxJQUFKLEdBQVd3eUMsSUFBWCxJQUFtQnh0RCxNQUFNLENBQUNnYixJQUFQLENBQVl3eUMsSUFBL0IsSUFBdUNuQyxHQUFHLENBQUNyd0MsSUFBSixHQUFXMEksRUFBWCxJQUFpQjFqQixNQUFNLENBQUNnYixJQUFQLENBQVkwSSxFQUF4RSxFQUNFaStGLFlBQVk7OztRQUVoQnZ6RCxFQUFFLENBQUN5Z0MsYUFBSCxDQUFpQjhyQixPQUFqQixFQUEwQmdILFlBQTFCO09BWEY7O01BZUEsSUFBSTF0QixNQUFNLEdBQUc3QyxVQUFVLENBQUM2QyxNQUF4QjtNQUNBQSxNQUFNLENBQUMydEIsVUFBUCxHQUFvQjtRQUNsQixZQUFZLGtCQURNO1FBRWxCLGFBQWEsWUFGSztRQUdsQixnQkFBZ0IsWUFIRTtRQUlsQixTQUFTLFdBSlM7UUFLbEIsYUFBYSxlQUxLO1FBTWxCLGNBQWMsZ0JBTkk7UUFPbEIsZUFBZSxjQVBHO1FBUWxCLGlCQUFpQixnQkFSQztRQVNsQixTQUFTLFlBVFM7UUFVbEIsZUFBZSxzQkFWRztRQVdsQixPQUFPLG9CQVhXO1FBWWxCLGFBQWEsaUJBWks7UUFhbEIsbUJBQW1CLGtCQWJEO1FBY2xCLFNBQVMsc0JBZFM7UUFlbEIsbUJBQW1CLGFBZkQ7UUFnQmxCLGVBQWUsdUJBaEJHO1FBaUJsQixTQUFTLGFBakJTO1FBa0JsQixlQUFlLFlBbEJHO1FBbUJsQixpQkFBaUIsY0FuQkM7UUFvQmxCLFNBQVMsdUJBcEJTO1FBcUJsQixTQUFTLFdBckJTO1FBc0JsQixlQUFlLGVBdEJHO1FBdUJsQixNQUFNLFdBdkJZO1FBd0JsQixZQUFZLGtCQXhCTTtRQXlCbEIsVUFBVSxzQkF6QlE7UUEwQmxCLGdCQUFnQiw2QkExQkU7UUEyQmxCLE1BQU0sY0EzQlk7UUE0QmxCLFlBQVksY0E1Qk07UUE2QmxCLFVBQVUsZ0JBN0JRO1FBOEJsQixnQkFBZ0IsZ0JBOUJFO1FBK0JsQixVQUFVLGlCQS9CUTtRQWdDbEIsYUFBYSxnQkFoQ0s7UUFpQ2xCLGVBQWUsNkJBakNHO1FBa0NsQixlQUFlLGNBbENHO1FBbUNsQixlQUFlLGdCQW5DRztRQW9DbEIsZUFBZSxrQkFwQ0c7UUFxQ2xCLG1CQUFtQixnQkFyQ0Q7UUFzQ2xCLGVBQWUscUJBdENHO1FBdUNsQixlQUFlLHFCQXZDRztRQXdDbEIsZUFBZSxxQkF4Q0c7UUF5Q2xCLGVBQWUsYUF6Q0c7UUEwQ2xCLGVBQWUsY0ExQ0c7UUEyQ2xCLGVBQWUsZ0JBM0NHO1FBNENsQix1QkFBdUIsYUE1Q0w7UUE2Q2xCLGVBQWUsU0E3Q0c7UUE4Q2xCLGVBQWUsV0E5Q0c7UUErQ2xCLGVBQWUsV0EvQ0c7UUFnRGxCLGlCQUFpQixxQkFoREM7UUFpRGxCLG1CQUFtQixxQkFqREQ7UUFrRGxCLFVBQVUsV0FsRFE7UUFtRGxCLGdCQUFnQixtQkFuREU7UUFvRGxCLFVBQVUsY0FwRFE7UUFxRGxCLGVBQWUsTUFyREc7UUFzRGxCLGVBQWUsUUF0REc7UUF1RGxCLFNBQVMsaUJBdkRTO1FBd0RsQixlQUFlLHdCQXhERztRQXlEbEIsU0FBUyxTQXpEUztRQTBEbEIsTUFBTSxVQTFEWTtRQTJEbEIsWUFBWSxVQTNETTtRQTREbEIsZUFBZTtPQTVEakI7TUE4REF4d0IsVUFBVSxDQUFDdUQsZUFBWCxDQUEyQlYsTUFBTSxDQUFDMnRCLFVBQWxDO01BRUEzdEIsTUFBTSxDQUFDNHRCLFNBQVAsR0FBbUI7UUFDakIsYUFBYSxZQURJO1FBRWpCLGdCQUFnQixZQUZDO1FBR2pCLFNBQVMsV0FIUTtRQUlqQixVQUFVLGdCQUpPO1FBS2pCLFlBQVksZUFMSztRQU1qQixhQUFhLGdCQU5JO1FBT2pCLFdBQVcsY0FQTTtRQVFqQixhQUFhLGdCQVJJO1FBU2pCLFVBQVUsWUFUTztRQVVqQixnQkFBZ0Isc0JBVkM7UUFXakIsT0FBTyxvQkFYVTtRQVlqQixjQUFjLGlCQVpHO1FBYWpCLG9CQUFvQixrQkFiSDtRQWNqQixVQUFVLHNCQWRPO1FBZWpCLG9CQUFvQixhQWZIO1FBZ0JqQixnQkFBZ0IsdUJBaEJDO1FBaUJqQixVQUFVLGFBakJPO1FBa0JqQixpQkFBaUIsWUFsQkE7UUFtQmpCLG1CQUFtQixjQW5CRjtRQW9CakIsVUFBVSx1QkFwQk87UUFxQmpCLFVBQVUsV0FyQk87UUFzQmpCLGdCQUFnQixlQXRCQztRQXVCakIsTUFBTSxXQXZCVztRQXdCakIsWUFBWSxrQkF4Qks7UUF5QmpCLFdBQVcsc0JBekJNO1FBMEJqQixpQkFBaUIsNkJBMUJBO1FBMkJqQixNQUFNLGNBM0JXO1FBNEJqQixZQUFZLGNBNUJLO1FBNkJqQixXQUFXLGdCQTdCTTtRQThCakIsaUJBQWlCLGdCQTlCQTtRQStCakIsVUFBVSxpQkEvQk87UUFnQ2pCLGFBQWEsZ0JBaENJO1FBaUNqQixpQkFBaUIsNkJBakNBO1FBa0NqQixpQkFBaUIsY0FsQ0E7UUFtQ2pCLGlCQUFpQixnQkFuQ0E7UUFvQ2pCLGlCQUFpQixrQkFwQ0E7UUFxQ2pCLHFCQUFxQixnQkFyQ0o7UUFzQ2pCLGlCQUFpQixxQkF0Q0E7UUF1Q2pCLGlCQUFpQixxQkF2Q0E7UUF3Q2pCLGlCQUFpQixxQkF4Q0E7UUF5Q2pCLGlCQUFpQixhQXpDQTtRQTBDakIsaUJBQWlCLGNBMUNBO1FBMkNqQixpQkFBaUIsZ0JBM0NBO1FBNENqQix5QkFBeUIsYUE1Q1I7UUE2Q2pCLGlCQUFpQixTQTdDQTtRQThDakIsaUJBQWlCLFdBOUNBO1FBK0NqQixpQkFBaUIsV0EvQ0E7UUFnRGpCLGVBQWUscUJBaERFO1FBaURqQixpQkFBaUIscUJBakRBO1FBa0RqQixXQUFXLFdBbERNO1FBbURqQixpQkFBaUIsbUJBbkRBO1FBb0RqQixVQUFVLGNBcERPO1FBcURqQixnQkFBZ0IsTUFyREM7UUFzRGpCLGdCQUFnQixRQXREQztRQXVEakIsVUFBVSxpQkF2RE87UUF3RGpCLGdCQUFnQix3QkF4REM7UUF5RGpCLFVBQVUsU0F6RE87UUEwRGpCLE1BQU0sVUExRFc7UUEyRGpCLFlBQVksVUEzREs7UUE0RGpCLGVBQWU7T0E1RGpCO01BOERBendCLFVBQVUsQ0FBQ3VELGVBQVgsQ0FBMkJWLE1BQU0sQ0FBQzR0QixTQUFsQztNQUVBLElBQUloOEQsR0FBRyxHQUFHb3VDLE1BQU0sQ0FBQzZ0QixPQUFQLElBQWtCN3RCLE1BQU0sQ0FBQ0ksVUFBbkM7TUFDQUosTUFBTSxDQUFDOHRCLE9BQVAsR0FBaUJsOEQsR0FBRyxHQUFHb3VDLE1BQU0sQ0FBQzJ0QixVQUFWLEdBQXVCM3RCLE1BQU0sQ0FBQzR0QixTQUFsRDtLQXhzQkY7Ozs7Ozs7SUNEQSxDQUFDLFVBQVNudEIsR0FBVCxFQUFjO01BQ2IsQUFDRUEsR0FBRyxDQUFDeDVGLFVBQUQsQ0FBSCxDQURGO0tBREYsRUFPRyxVQUFTazJGLFVBQVQsRUFBcUI7TUFDdEIsU0FBUzR3QixTQUFULENBQW1CNXpELEVBQW5CLEVBQXVCcGhCLFFBQXZCLEVBQWlDdzdCLE1BQWpDLEVBQXlDO1FBQ3ZDLElBQUkzZ0UsSUFBSSxHQUFHdW1ELEVBQUUsQ0FBQ2lqQixpQkFBSCxFQUFYO1FBQ0EsSUFBSTR3QyxNQUFKO1FBQ0FBLE1BQU0sR0FBR3A2RyxJQUFJLENBQUN2QyxXQUFMLENBQWlCMUosUUFBUSxDQUFDRSxhQUFULENBQXVCLEtBQXZCLENBQWpCLENBQVQ7UUFDQSxJQUFJMHNFLE1BQUosRUFDRXk1QyxNQUFNLENBQUMxN0QsU0FBUCxHQUFtQiw0Q0FBbkIsQ0FERixLQUdFMDdELE1BQU0sQ0FBQzE3RCxTQUFQLEdBQW1CLHlDQUFuQjs7UUFFRixJQUFJLE9BQU92WixRQUFQLElBQW1CLFFBQXZCLEVBQWlDO1VBQy9CaTFFLE1BQU0sQ0FBQzcxRSxTQUFQLEdBQW1CWSxRQUFuQjtTQURGLE1BRU87O1VBQ0xpMUUsTUFBTSxDQUFDMzhHLFdBQVAsQ0FBbUIwbkMsUUFBbkI7OztRQUVGb2tELFVBQVUsQ0FBQzNwQyxRQUFYLENBQW9CNS9DLElBQXBCLEVBQTBCLGVBQTFCO1FBQ0EsT0FBT282RyxNQUFQOzs7TUFHRixTQUFTQyxpQkFBVCxDQUEyQjl6RCxFQUEzQixFQUErQit6RCxNQUEvQixFQUF1QztRQUNyQyxJQUFJL3pELEVBQUUsQ0FBQzlwQixLQUFILENBQVM4OUUsd0JBQWIsRUFDRWgwRCxFQUFFLENBQUM5cEIsS0FBSCxDQUFTODlFLHdCQUFUO1FBQ0ZoMEQsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzg5RSx3QkFBVCxHQUFvQ0QsTUFBcEM7OztNQUdGL3dCLFVBQVUsQ0FBQ2dlLGVBQVgsQ0FBMkIsWUFBM0IsRUFBeUMsVUFBU3BpRSxRQUFULEVBQW1CcTFFLFFBQW5CLEVBQTZCbDVFLE9BQTdCLEVBQXNDO1FBQzdFLElBQUksQ0FBQ0EsT0FBTCxFQUFjQSxPQUFPLEdBQUcsRUFBVjtRQUVkKzRFLGlCQUFpQixDQUFDLElBQUQsRUFBTyxJQUFQLENBQWpCO1FBRUEsSUFBSUQsTUFBTSxHQUFHRCxTQUFTLENBQUMsSUFBRCxFQUFPaDFFLFFBQVAsRUFBaUI3RCxPQUFPLENBQUNxL0IsTUFBekIsQ0FBdEI7UUFDQSxJQUFJODVDLE1BQU0sR0FBRyxLQUFiO1lBQW9CNTJCLEVBQUUsR0FBRyxJQUF6Qjs7UUFDQSxTQUFTL2xGLEtBQVQsQ0FBZXc4RyxNQUFmLEVBQXVCO1VBQ3JCLElBQUksT0FBT0EsTUFBUCxJQUFpQixRQUFyQixFQUErQjtZQUM3QmpnQixHQUFHLENBQUNybEcsS0FBSixHQUFZc2xILE1BQVo7V0FERixNQUVPO1lBQ0wsSUFBSUcsTUFBSixFQUFZO1lBQ1pBLE1BQU0sR0FBRyxJQUFUO1lBQ0FseEIsVUFBVSxDQUFDL3FDLE9BQVgsQ0FBbUI0N0QsTUFBTSxDQUFDNTBFLFVBQTFCLEVBQXNDLGVBQXRDO1lBQ0E0MEUsTUFBTSxDQUFDNTBFLFVBQVAsQ0FBa0JybUIsV0FBbEIsQ0FBOEJpN0YsTUFBOUI7WUFDQXYyQixFQUFFLENBQUM1b0MsS0FBSDtZQUVBLElBQUkzWixPQUFPLENBQUNvNUUsT0FBWixFQUFxQnA1RSxPQUFPLENBQUNvNUUsT0FBUixDQUFnQk4sTUFBaEI7Ozs7UUFJekIsSUFBSS9mLEdBQUcsR0FBRytmLE1BQU0sQ0FBQ08sb0JBQVAsQ0FBNEIsT0FBNUIsRUFBcUMsQ0FBckMsQ0FBVjtZQUFtRGp6RCxNQUFuRDs7UUFDQSxJQUFJMnlDLEdBQUosRUFBUztVQUNQQSxHQUFHLENBQUNwL0MsS0FBSjs7VUFFQSxJQUFJM1osT0FBTyxDQUFDdHNDLEtBQVosRUFBbUI7WUFDakJxbEcsR0FBRyxDQUFDcmxHLEtBQUosR0FBWXNzQyxPQUFPLENBQUN0c0MsS0FBcEI7O1lBQ0EsSUFBSXNzQyxPQUFPLENBQUNzNUUsaUJBQVIsS0FBOEIsS0FBbEMsRUFBeUM7Y0FDdkN2Z0IsR0FBRyxDQUFDcjZDLE1BQUo7Ozs7VUFJSixJQUFJMWUsT0FBTyxDQUFDdTVFLE9BQVosRUFDRXR4QixVQUFVLENBQUMxakMsRUFBWCxDQUFjdzBDLEdBQWQsRUFBbUIsT0FBbkIsRUFBNEIsVUFBU2puRyxDQUFULEVBQVk7WUFBRWt1QyxPQUFPLENBQUN1NUUsT0FBUixDQUFnQnpuSCxDQUFoQixFQUFtQmluRyxHQUFHLENBQUNybEcsS0FBdkIsRUFBOEI4SSxLQUE5QjtXQUExQztVQUNGLElBQUl3akMsT0FBTyxDQUFDcXlELE9BQVosRUFDRXBLLFVBQVUsQ0FBQzFqQyxFQUFYLENBQWN3MEMsR0FBZCxFQUFtQixPQUFuQixFQUE0QixVQUFTam5HLENBQVQsRUFBWTtZQUFDa3VDLE9BQU8sQ0FBQ3F5RCxPQUFSLENBQWdCdmdHLENBQWhCLEVBQW1CaW5HLEdBQUcsQ0FBQ3JsRyxLQUF2QixFQUE4QjhJLEtBQTlCO1dBQXpDO1VBRUZ5ckYsVUFBVSxDQUFDMWpDLEVBQVgsQ0FBY3cwQyxHQUFkLEVBQW1CLFNBQW5CLEVBQThCLFVBQVNqbkcsQ0FBVCxFQUFZO1lBQ3hDLElBQUlrdUMsT0FBTyxJQUFJQSxPQUFPLENBQUNnWixTQUFuQixJQUFnQ2haLE9BQU8sQ0FBQ2daLFNBQVIsQ0FBa0JsbkQsQ0FBbEIsRUFBcUJpbkcsR0FBRyxDQUFDcmxHLEtBQXpCLEVBQWdDOEksS0FBaEMsQ0FBcEMsRUFBNEU7Y0FBRTs7O1lBQzlFLElBQUkxSyxDQUFDLENBQUNpNkYsT0FBRixJQUFhLEVBQWIsSUFBb0IvckQsT0FBTyxDQUFDdzVFLFlBQVIsS0FBeUIsS0FBekIsSUFBa0MxbkgsQ0FBQyxDQUFDaTZGLE9BQUYsSUFBYSxFQUF2RSxFQUE0RTtjQUMxRWdOLEdBQUcsQ0FBQzlCLElBQUo7Y0FDQWhQLFVBQVUsQ0FBQ2ppQyxNQUFYLENBQWtCbDBELENBQWxCO2NBQ0EwSyxLQUFLOzs7WUFFUCxJQUFJMUssQ0FBQyxDQUFDaTZGLE9BQUYsSUFBYSxFQUFqQixFQUFxQm10QixRQUFRLENBQUNuZ0IsR0FBRyxDQUFDcmxHLEtBQUwsRUFBWTVCLENBQVosQ0FBUjtXQVB2QjtVQVVBLElBQUlrdUMsT0FBTyxDQUFDeTVFLFdBQVIsS0FBd0IsS0FBNUIsRUFBbUN4eEIsVUFBVSxDQUFDMWpDLEVBQVgsQ0FBY3UwRCxNQUFkLEVBQXNCLFVBQXRCLEVBQWtDLFVBQVVZLEdBQVYsRUFBZTtZQUNsRixJQUFJQSxHQUFHLENBQUNDLGFBQUosS0FBc0IsSUFBMUIsRUFBZ0NuOUcsS0FBSztXQURKO1NBekJyQyxNQTRCTyxJQUFJNHBELE1BQU0sR0FBRzB5RCxNQUFNLENBQUNPLG9CQUFQLENBQTRCLFFBQTVCLEVBQXNDLENBQXRDLENBQWIsRUFBdUQ7VUFDNURweEIsVUFBVSxDQUFDMWpDLEVBQVgsQ0FBYzZCLE1BQWQsRUFBc0IsT0FBdEIsRUFBK0IsWUFBVztZQUN4QzVwRCxLQUFLO1lBQ0wrbEYsRUFBRSxDQUFDNW9DLEtBQUg7V0FGRjtVQUtBLElBQUkzWixPQUFPLENBQUN5NUUsV0FBUixLQUF3QixLQUE1QixFQUFtQ3h4QixVQUFVLENBQUMxakMsRUFBWCxDQUFjNkIsTUFBZCxFQUFzQixNQUF0QixFQUE4QjVwRCxLQUE5QjtVQUVuQzRwRCxNQUFNLENBQUN6TSxLQUFQOzs7UUFFRixPQUFPbjlDLEtBQVA7T0E1REY7TUErREF5ckYsVUFBVSxDQUFDZ2UsZUFBWCxDQUEyQixhQUEzQixFQUEwQyxVQUFTcGlFLFFBQVQsRUFBbUJtMkIsU0FBbkIsRUFBOEJoNkIsT0FBOUIsRUFBdUM7UUFDL0UrNEUsaUJBQWlCLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBakI7UUFDQSxJQUFJRCxNQUFNLEdBQUdELFNBQVMsQ0FBQyxJQUFELEVBQU9oMUUsUUFBUCxFQUFpQjdELE9BQU8sSUFBSUEsT0FBTyxDQUFDcS9CLE1BQXBDLENBQXRCO1FBQ0EsSUFBSTgxQixPQUFPLEdBQUcyakIsTUFBTSxDQUFDTyxvQkFBUCxDQUE0QixRQUE1QixDQUFkO1FBQ0EsSUFBSUYsTUFBTSxHQUFHLEtBQWI7WUFBb0I1MkIsRUFBRSxHQUFHLElBQXpCO1lBQStCcTNCLFFBQVEsR0FBRyxDQUExQzs7UUFDQSxTQUFTcDlHLEtBQVQsR0FBaUI7VUFDZixJQUFJMjhHLE1BQUosRUFBWTtVQUNaQSxNQUFNLEdBQUcsSUFBVDtVQUNBbHhCLFVBQVUsQ0FBQy9xQyxPQUFYLENBQW1CNDdELE1BQU0sQ0FBQzUwRSxVQUExQixFQUFzQyxlQUF0QztVQUNBNDBFLE1BQU0sQ0FBQzUwRSxVQUFQLENBQWtCcm1CLFdBQWxCLENBQThCaTdGLE1BQTlCO1VBQ0F2MkIsRUFBRSxDQUFDNW9DLEtBQUg7OztRQUVGdzdDLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV3g3QyxLQUFYOztRQUNBLEtBQUssSUFBSTdoRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcTlGLE9BQU8sQ0FBQ3ovRixNQUE1QixFQUFvQyxFQUFFb0MsQ0FBdEMsRUFBeUM7VUFDdkMsSUFBSWxDLENBQUMsR0FBR3UvRixPQUFPLENBQUNyOUYsQ0FBRCxDQUFmOztVQUNBLENBQUMsVUFBU29oSCxRQUFULEVBQW1CO1lBQ2xCanhCLFVBQVUsQ0FBQzFqQyxFQUFYLENBQWMzdUQsQ0FBZCxFQUFpQixPQUFqQixFQUEwQixVQUFTOUQsQ0FBVCxFQUFZO2NBQ3BDbTJGLFVBQVUsQ0FBQ3JpQyxnQkFBWCxDQUE0Qjl6RCxDQUE1QjtjQUNBMEssS0FBSztjQUNMLElBQUkwOEcsUUFBSixFQUFjQSxRQUFRLENBQUMzMkIsRUFBRCxDQUFSO2FBSGhCO1dBREYsRUFNR3ZvQixTQUFTLENBQUNsaUUsQ0FBRCxDQU5aOztVQU9BbXdGLFVBQVUsQ0FBQzFqQyxFQUFYLENBQWMzdUQsQ0FBZCxFQUFpQixNQUFqQixFQUF5QixZQUFXO1lBQ2xDLEVBQUVna0gsUUFBRjtZQUNBOTdGLFVBQVUsQ0FBQyxZQUFXO2NBQUUsSUFBSTg3RixRQUFRLElBQUksQ0FBaEIsRUFBbUJwOUcsS0FBSzthQUF0QyxFQUE2QyxHQUE3QyxDQUFWO1dBRkY7VUFJQXlyRixVQUFVLENBQUMxakMsRUFBWCxDQUFjM3VELENBQWQsRUFBaUIsT0FBakIsRUFBMEIsWUFBVztZQUFFLEVBQUVna0gsUUFBRjtXQUF2Qzs7T0ExQko7O0VBK0JGO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztNQUNFM3hCLFVBQVUsQ0FBQ2dlLGVBQVgsQ0FBMkIsa0JBQTNCLEVBQStDLFVBQVNwaUUsUUFBVCxFQUFtQjdELE9BQW5CLEVBQTRCO1FBQ3pFKzRFLGlCQUFpQixDQUFDLElBQUQsRUFBT3Y4RyxLQUFQLENBQWpCO1FBQ0EsSUFBSXM4RyxNQUFNLEdBQUdELFNBQVMsQ0FBQyxJQUFELEVBQU9oMUUsUUFBUCxFQUFpQjdELE9BQU8sSUFBSUEsT0FBTyxDQUFDcS9CLE1BQXBDLENBQXRCO1FBQ0EsSUFBSTg1QyxNQUFNLEdBQUcsS0FBYjtZQUFvQlUsU0FBcEI7UUFDQSxJQUFJQyxRQUFRLEdBQUc5NUUsT0FBTyxJQUFJLE9BQU9BLE9BQU8sQ0FBQzg1RSxRQUFmLEtBQTRCLFdBQXZDLEdBQXFEOTVFLE9BQU8sQ0FBQzg1RSxRQUE3RCxHQUF3RSxJQUF2Rjs7UUFFQSxTQUFTdDlHLEtBQVQsR0FBaUI7VUFDZixJQUFJMjhHLE1BQUosRUFBWTtVQUNaQSxNQUFNLEdBQUcsSUFBVDtVQUNBMTVELFlBQVksQ0FBQ282RCxTQUFELENBQVo7VUFDQTV4QixVQUFVLENBQUMvcUMsT0FBWCxDQUFtQjQ3RCxNQUFNLENBQUM1MEUsVUFBMUIsRUFBc0MsZUFBdEM7VUFDQTQwRSxNQUFNLENBQUM1MEUsVUFBUCxDQUFrQnJtQixXQUFsQixDQUE4Qmk3RixNQUE5Qjs7O1FBR0Y3d0IsVUFBVSxDQUFDMWpDLEVBQVgsQ0FBY3UwRCxNQUFkLEVBQXNCLE9BQXRCLEVBQStCLFVBQVNobkgsQ0FBVCxFQUFZO1VBQ3pDbTJGLFVBQVUsQ0FBQ3JpQyxnQkFBWCxDQUE0Qjl6RCxDQUE1QjtVQUNBMEssS0FBSztTQUZQO1FBS0EsSUFBSXM5RyxRQUFKLEVBQ0VELFNBQVMsR0FBRy83RixVQUFVLENBQUN0aEIsS0FBRCxFQUFRczlHLFFBQVIsQ0FBdEI7UUFFRixPQUFPdDlHLEtBQVA7T0F0QkY7S0FySUY7Ozs7Ozs7Ozs7OztJQ01BLENBQUMsVUFBUyt1RixHQUFULEVBQWM7TUFDYixBQUNFQSxHQUFHLENBQUN4NUYsVUFBRCxFQUFrQ2EsWUFBbEMsRUFBNkRDLE1BQTdELENBQUgsQ0FERjtLQURGLEVBT0csVUFBU28xRixVQUFULEVBQXFCOztNQUl0QkEsVUFBVSxDQUFDc08sWUFBWCxDQUF3QixRQUF4QixFQUFrQztRQUFDbDNCLE1BQU0sRUFBRTtPQUEzQzs7TUFFQSxTQUFTMDZDLGFBQVQsQ0FBdUJoSixLQUF2QixFQUE4QnJtRCxlQUE5QixFQUErQztRQUM3QyxJQUFJLE9BQU9xbUQsS0FBUCxJQUFnQixRQUFwQixFQUNFQSxLQUFLLEdBQUcsSUFBSTlzRyxNQUFKLENBQVc4c0csS0FBSyxDQUFDdHNHLE9BQU4sQ0FBYyxxQ0FBZCxFQUFxRCxNQUFyRCxDQUFYLEVBQXlFaW1ELGVBQWUsR0FBRyxJQUFILEdBQVUsR0FBbEcsQ0FBUixDQURGLEtBRUssSUFBSSxDQUFDcW1ELEtBQUssQ0FBQzcvRyxNQUFYLEVBQ0g2L0csS0FBSyxHQUFHLElBQUk5c0csTUFBSixDQUFXOHNHLEtBQUssQ0FBQzM2RyxNQUFqQixFQUF5QjI2RyxLQUFLLENBQUMvNkYsVUFBTixHQUFtQixJQUFuQixHQUEwQixHQUFuRCxDQUFSO1FBRUYsT0FBTztVQUFDMjVDLEtBQUssRUFBRSxlQUFTSixNQUFULEVBQWlCO1lBQzlCd2hELEtBQUssQ0FBQzE1RixTQUFOLEdBQWtCazRDLE1BQU0sQ0FBQzNqRCxHQUF6QjtZQUNBLElBQUlsSSxLQUFLLEdBQUdxdEcsS0FBSyxDQUFDbC9HLElBQU4sQ0FBVzA5RCxNQUFNLENBQUNockQsTUFBbEIsQ0FBWjs7WUFDQSxJQUFJYixLQUFLLElBQUlBLEtBQUssQ0FBQzVKLEtBQU4sSUFBZXkxRCxNQUFNLENBQUMzakQsR0FBbkMsRUFBd0M7Y0FDdEMyakQsTUFBTSxDQUFDM2pELEdBQVAsSUFBY2xJLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2hPLE1BQVQsSUFBbUIsQ0FBakM7Y0FDQSxPQUFPLFdBQVA7YUFGRixNQUdPLElBQUlnTyxLQUFKLEVBQVc7Y0FDaEI2ckQsTUFBTSxDQUFDM2pELEdBQVAsR0FBYWxJLEtBQUssQ0FBQzVKLEtBQW5CO2FBREssTUFFQTtjQUNMeTFELE1BQU0sQ0FBQ3BGLFNBQVA7OztTQVRKOzs7TUFjRixTQUFTNnZELFdBQVQsR0FBdUI7UUFDckIsS0FBS0MsT0FBTCxHQUFlLEtBQUtDLEtBQUwsR0FBYSxLQUFLQyxTQUFMLEdBQWlCLEtBQUtwSixLQUFMLEdBQWEsSUFBMUQ7UUFDQSxLQUFLOWlELE9BQUwsR0FBZSxJQUFmOzs7TUFHRixTQUFTbXNELGNBQVQsQ0FBd0JuMUQsRUFBeEIsRUFBNEI7UUFDMUIsT0FBT0EsRUFBRSxDQUFDOXBCLEtBQUgsQ0FBUzNzQixNQUFULEtBQW9CeTJDLEVBQUUsQ0FBQzlwQixLQUFILENBQVMzc0IsTUFBVCxHQUFrQixJQUFJd3JHLFdBQUosRUFBdEMsQ0FBUDs7O01BR0YsU0FBU0ssb0JBQVQsQ0FBOEJ0SixLQUE5QixFQUFxQztRQUNuQyxPQUFPLE9BQU9BLEtBQVAsSUFBZ0IsUUFBaEIsSUFBNEJBLEtBQUssSUFBSUEsS0FBSyxDQUFDNWhHLFdBQU4sRUFBNUM7OztNQUdGLFNBQVN3aUcsZUFBVCxDQUF5QjFzRCxFQUF6QixFQUE2QjhyRCxLQUE3QixFQUFvQ25sRyxHQUFwQyxFQUF5Qzs7UUFFdkMsT0FBT3E1QyxFQUFFLENBQUMwc0QsZUFBSCxDQUFtQlosS0FBbkIsRUFBMEJubEcsR0FBMUIsRUFBK0I7VUFBQ29sRyxRQUFRLEVBQUVxSixvQkFBb0IsQ0FBQ3RKLEtBQUQsQ0FBL0I7VUFBd0M5NkYsU0FBUyxFQUFFO1NBQWxGLENBQVA7OztNQUdGLFNBQVNxa0csZ0JBQVQsQ0FBMEJyMUQsRUFBMUIsRUFBOEJuUixJQUE5QixFQUFvQ3VpRCxLQUFwQyxFQUEyQ2trQixPQUEzQyxFQUFvRHZoRSxTQUFwRCxFQUErRDtRQUM3RGlNLEVBQUUsQ0FBQ3UxRCxVQUFILENBQWMxbUUsSUFBZCxFQUFvQnltRSxPQUFwQixFQUE2QjtVQUMzQjdtSCxLQUFLLEVBQUUyaUcsS0FEb0I7VUFFM0JpakIsaUJBQWlCLEVBQUUsSUFGUTtVQUczQkUsWUFBWSxFQUFFLEtBSGE7VUFJM0JKLE9BQU8sRUFBRSxtQkFBVztZQUFFcUIsV0FBVyxDQUFDeDFELEVBQUQsQ0FBWDtXQUpLO1VBSzNCak0sU0FBUyxFQUFFQSxTQUxnQjtVQU0zQnFtQixNQUFNLEVBQUVwYSxFQUFFLENBQUNqbEIsT0FBSCxDQUFXeHhCLE1BQVgsQ0FBa0I2d0Q7U0FONUI7OztNQVVGLFNBQVN5NUMsTUFBVCxDQUFnQjd6RCxFQUFoQixFQUFvQm5SLElBQXBCLEVBQTBCNG1FLFNBQTFCLEVBQXFDcmtCLEtBQXJDLEVBQTRDcmlHLENBQTVDLEVBQStDO1FBQzdDLElBQUlpeEQsRUFBRSxDQUFDdTFELFVBQVAsRUFBbUJ2MUQsRUFBRSxDQUFDdTFELFVBQUgsQ0FBYzFtRSxJQUFkLEVBQW9COS9DLENBQXBCLEVBQXVCO1VBQUNOLEtBQUssRUFBRTJpRyxLQUFSO1VBQWVpakIsaUJBQWlCLEVBQUUsSUFBbEM7VUFBd0NqNkMsTUFBTSxFQUFFcGEsRUFBRSxDQUFDamxCLE9BQUgsQ0FBV3h4QixNQUFYLENBQWtCNndEO1NBQXpGLEVBQW5CLEtBQ0tyckUsQ0FBQyxDQUFDMm1ILE1BQU0sQ0FBQ0QsU0FBRCxFQUFZcmtCLEtBQVosQ0FBUCxDQUFEOzs7TUFHUCxTQUFTdWtCLGFBQVQsQ0FBdUIzMUQsRUFBdkIsRUFBMkJuUixJQUEzQixFQUFpQzRtRSxTQUFqQyxFQUE0Q0csRUFBNUMsRUFBZ0Q7UUFDOUMsSUFBSTUxRCxFQUFFLENBQUM2MUQsV0FBUCxFQUFvQjcxRCxFQUFFLENBQUM2MUQsV0FBSCxDQUFlaG5FLElBQWYsRUFBcUIrbUUsRUFBckIsRUFBcEIsS0FDSyxJQUFJRSxPQUFPLENBQUNMLFNBQUQsQ0FBWCxFQUF3QkcsRUFBRSxDQUFDLENBQUQsQ0FBRjs7O01BRy9CLFNBQVNHLFdBQVQsQ0FBcUJ6MkcsTUFBckIsRUFBNkI7UUFDM0IsT0FBT0EsTUFBTSxDQUFDRSxPQUFQLENBQWUsY0FBZixFQUErQixVQUFTZixLQUFULEVBQWdCNlcsRUFBaEIsRUFBb0I7VUFDeEQsSUFBSUEsRUFBRSxJQUFJLEdBQVYsRUFBZSxPQUFPLElBQVA7VUFDZixJQUFJQSxFQUFFLElBQUksR0FBVixFQUFlLE9BQU8sSUFBUDtVQUNmLElBQUlBLEVBQUUsSUFBSSxHQUFWLEVBQWUsT0FBTyxJQUFQO1VBQ2YsSUFBSUEsRUFBRSxJQUFJLElBQVYsRUFBZ0IsT0FBTyxJQUFQO1VBQ2hCLE9BQU83VyxLQUFQO1NBTEssQ0FBUDs7O01BU0YsU0FBU3UzRyxVQUFULENBQW9CbEssS0FBcEIsRUFBMkI7UUFDekIsSUFBSW1LLElBQUksR0FBR25LLEtBQUssQ0FBQ3J0RyxLQUFOLENBQVksb0JBQVosQ0FBWDs7UUFDQSxJQUFJdzNHLElBQUosRUFBVTtVQUNSLElBQUk7WUFBRW5LLEtBQUssR0FBRyxJQUFJOXNHLE1BQUosQ0FBV2kzRyxJQUFJLENBQUMsQ0FBRCxDQUFmLEVBQW9CQSxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVF2c0csT0FBUixDQUFnQixHQUFoQixLQUF3QixDQUFDLENBQXpCLEdBQTZCLEVBQTdCLEdBQWtDLEdBQXRELENBQVI7V0FBTixDQUNBLE9BQU03YyxDQUFOLEVBQVMsRUFGRDs7U0FBVixNQUdPO1VBQ0xpL0csS0FBSyxHQUFHaUssV0FBVyxDQUFDakssS0FBRCxDQUFuQjs7O1FBRUYsSUFBSSxPQUFPQSxLQUFQLElBQWdCLFFBQWhCLEdBQTJCQSxLQUFLLElBQUksRUFBcEMsR0FBeUNBLEtBQUssQ0FBQ3p1RyxJQUFOLENBQVcsRUFBWCxDQUE3QyxFQUNFeXVHLEtBQUssR0FBRyxJQUFSO1FBQ0YsT0FBT0EsS0FBUDs7O01BR0YsU0FBU29LLFdBQVQsQ0FBcUJsMkQsRUFBckIsRUFBeUI5cEIsS0FBekIsRUFBZ0M0MUUsS0FBaEMsRUFBdUM7UUFDckM1MUUsS0FBSyxDQUFDaWdGLFNBQU4sR0FBa0JySyxLQUFsQjtRQUNBNTFFLEtBQUssQ0FBQzQxRSxLQUFOLEdBQWNrSyxVQUFVLENBQUNsSyxLQUFELENBQXhCO1FBQ0E5ckQsRUFBRSxDQUFDNDJDLGFBQUgsQ0FBaUIxZ0UsS0FBSyxDQUFDOHlCLE9BQXZCLEVBQWdDb3NELG9CQUFvQixDQUFDbC9FLEtBQUssQ0FBQzQxRSxLQUFQLENBQXBEO1FBQ0E1MUUsS0FBSyxDQUFDOHlCLE9BQU4sR0FBZ0I4ckQsYUFBYSxDQUFDNStFLEtBQUssQ0FBQzQxRSxLQUFQLEVBQWNzSixvQkFBb0IsQ0FBQ2wvRSxLQUFLLENBQUM0MUUsS0FBUCxDQUFsQyxDQUE3QjtRQUNBOXJELEVBQUUsQ0FBQzAyQyxVQUFILENBQWN4Z0UsS0FBSyxDQUFDOHlCLE9BQXBCOztRQUNBLElBQUloSixFQUFFLENBQUNvMkQsc0JBQVAsRUFBK0I7VUFDN0IsSUFBSWxnRixLQUFLLENBQUNtZ0YsUUFBVixFQUFvQjtZQUFFbmdGLEtBQUssQ0FBQ21nRixRQUFOLENBQWV2OUYsS0FBZjtZQUF3Qm9kLEtBQUssQ0FBQ21nRixRQUFOLEdBQWlCLElBQWpCOzs7VUFDOUNuZ0YsS0FBSyxDQUFDbWdGLFFBQU4sR0FBaUJyMkQsRUFBRSxDQUFDbzJELHNCQUFILENBQTBCbGdGLEtBQUssQ0FBQzQxRSxLQUFoQyxFQUF1Q3NKLG9CQUFvQixDQUFDbC9FLEtBQUssQ0FBQzQxRSxLQUFQLENBQTNELENBQWpCOzs7O01BSUosU0FBU3dLLFFBQVQsQ0FBa0J0MkQsRUFBbEIsRUFBc0J1MkQsR0FBdEIsRUFBMkJDLFVBQTNCLEVBQXVDQyxTQUF2QyxFQUFrRDtRQUNoRCxJQUFJdmdGLEtBQUssR0FBR2kvRSxjQUFjLENBQUNuMUQsRUFBRCxDQUExQjtRQUNBLElBQUk5cEIsS0FBSyxDQUFDNDFFLEtBQVYsRUFBaUIsT0FBT1UsUUFBUSxDQUFDeHNELEVBQUQsRUFBS3UyRCxHQUFMLENBQWY7UUFDakIsSUFBSXgvRixDQUFDLEdBQUdpcEMsRUFBRSxDQUFDb0MsWUFBSCxNQUFxQmxzQixLQUFLLENBQUNnL0UsU0FBbkM7UUFDQSxJQUFJbitGLENBQUMsWUFBWS9YLE1BQWIsSUFBdUIrWCxDQUFDLENBQUM1bEIsTUFBRixJQUFZLElBQXZDLEVBQTZDNGxCLENBQUMsR0FBRyxJQUFKOztRQUM3QyxJQUFJeS9GLFVBQVUsSUFBSXgyRCxFQUFFLENBQUN1MUQsVUFBckIsRUFBaUM7VUFDL0IsSUFBSW1CLE1BQU0sR0FBRyxJQUFiOztVQUNBLElBQUlDLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVM3SyxLQUFULEVBQWdCM3pGLEtBQWhCLEVBQXVCO1lBQ3RDNnFFLFVBQVUsQ0FBQ2ppQyxNQUFYLENBQWtCNW9DLEtBQWxCO1lBQ0EsSUFBSSxDQUFDMnpGLEtBQUwsRUFBWTs7WUFDWixJQUFJQSxLQUFLLElBQUk1MUUsS0FBSyxDQUFDaWdGLFNBQW5CLEVBQThCO2NBQzVCRCxXQUFXLENBQUNsMkQsRUFBRCxFQUFLOXBCLEtBQUwsRUFBWTQxRSxLQUFaLENBQVg7Y0FDQTUxRSxLQUFLLENBQUM4K0UsT0FBTixHQUFnQjkrRSxLQUFLLENBQUMrK0UsS0FBTixHQUFjajFELEVBQUUsQ0FBQ3lvQixTQUFILEVBQTlCOzs7WUFFRixJQUFJaXVDLE1BQUosRUFBWUEsTUFBTSxDQUFDMS9HLEtBQVAsQ0FBYTQvRyxPQUFiLEdBQXVCLENBQXZCO1lBQ1pwSyxRQUFRLENBQUN4c0QsRUFBRCxFQUFLN25DLEtBQUssQ0FBQ2d2RSxRQUFYLEVBQXFCLFVBQVN1Z0IsQ0FBVCxFQUFZdDNGLEVBQVosRUFBZ0I7Y0FDM0MsSUFBSXlqRyxNQUFKO2NBQ0EsSUFBSXpqRyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQVYsSUFBZTV4RCxRQUFRLENBQUNpbkQsYUFBeEIsS0FDQ28vRCxNQUFNLEdBQUc3ekQsRUFBRSxDQUFDL29ELE9BQUgsQ0FBV3ltQixPQUFYLENBQW1CKzJCLGFBQW5CLENBQWlDLG9CQUFqQyxDQURWLEtBRUFvL0QsTUFBTSxDQUFDMW1FLHFCQUFQLEdBQStCaXRCLE1BQS9CLEdBQXdDLENBQXhDLEdBQTRDcGEsRUFBRSxDQUFDc2UsWUFBSCxDQUFnQmx1RCxFQUFoQixFQUFvQixRQUFwQixFQUE4Qm05QixHQUY5RSxFQUdFLENBQUNtcEUsTUFBTSxHQUFHN0MsTUFBVixFQUFrQjc4RyxLQUFsQixDQUF3QjQvRyxPQUF4QixHQUFrQyxFQUFsQzthQUxJLENBQVI7V0FSRjs7VUFnQkF2QixnQkFBZ0IsQ0FBQ3IxRCxFQUFELEVBQUs2MkQsY0FBYyxDQUFDNzJELEVBQUQsQ0FBbkIsRUFBeUJqcEMsQ0FBekIsRUFBNEI0L0YsVUFBNUIsRUFBd0MsVUFBU3grRixLQUFULEVBQWdCMnpGLEtBQWhCLEVBQXVCO1lBQzdFLElBQUkxa0IsT0FBTyxHQUFHcEUsVUFBVSxDQUFDb0UsT0FBWCxDQUFtQmp2RSxLQUFuQixDQUFkO1lBQ0EsSUFBSTIrRixLQUFLLEdBQUc5MkQsRUFBRSxDQUFDMlIsU0FBSCxDQUFhLFdBQWIsQ0FBWjtnQkFBdUMwMEIsR0FBRyxHQUFJeXdCLEtBQUssSUFBSUEsS0FBSyxDQUFDMXZCLE9BQUQsQ0FBZixJQUE2QnBFLFVBQVUsQ0FBQzZDLE1BQVgsQ0FBa0I3bEMsRUFBRSxDQUFDMlIsU0FBSCxDQUFhLFFBQWIsQ0FBbEIsRUFBMEN5MUIsT0FBMUMsQ0FBMUU7O1lBQ0EsSUFBSWYsR0FBRyxJQUFJLFVBQVAsSUFBcUJBLEdBQUcsSUFBSSxVQUE1QixJQUNGQSxHQUFHLElBQUksb0JBREwsSUFDNkJBLEdBQUcsSUFBSSxvQkFEeEMsRUFDOEQ7Y0FDNURyRCxVQUFVLENBQUNqaUMsTUFBWCxDQUFrQjVvQyxLQUFsQjtjQUNBKzlGLFdBQVcsQ0FBQ2wyRCxFQUFELEVBQUttMUQsY0FBYyxDQUFDbjFELEVBQUQsQ0FBbkIsRUFBeUI4ckQsS0FBekIsQ0FBWDtjQUNBOXJELEVBQUUsQ0FBQ3VyQyxXQUFILENBQWVsRixHQUFmO2FBSkYsTUFLTyxJQUFJQSxHQUFHLElBQUksTUFBUCxJQUFpQkEsR0FBRyxJQUFJLGdCQUE1QixFQUE4QztjQUNuRHJELFVBQVUsQ0FBQ2ppQyxNQUFYLENBQWtCNW9DLEtBQWxCO2NBQ0F3K0YsVUFBVSxDQUFDN0ssS0FBRCxFQUFRM3pGLEtBQVIsQ0FBVjs7V0FWWSxDQUFoQjs7VUFhQSxJQUFJcytGLFNBQVMsSUFBSTEvRixDQUFqQixFQUFvQjtZQUNsQm0vRixXQUFXLENBQUNsMkQsRUFBRCxFQUFLOXBCLEtBQUwsRUFBWW5mLENBQVosQ0FBWDtZQUNBeTFGLFFBQVEsQ0FBQ3hzRCxFQUFELEVBQUt1MkQsR0FBTCxDQUFSOztTQWpDSixNQW1DTztVQUNMMUMsTUFBTSxDQUFDN3pELEVBQUQsRUFBSzYyRCxjQUFjLENBQUM3MkQsRUFBRCxDQUFuQixFQUF5QixhQUF6QixFQUF3Q2pwQyxDQUF4QyxFQUEyQyxVQUFTKzBGLEtBQVQsRUFBZ0I7WUFDL0QsSUFBSUEsS0FBSyxJQUFJLENBQUM1MUUsS0FBSyxDQUFDNDFFLEtBQXBCLEVBQTJCOXJELEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO2NBQ2pEbWtFLFdBQVcsQ0FBQ2wyRCxFQUFELEVBQUs5cEIsS0FBTCxFQUFZNDFFLEtBQVosQ0FBWDtjQUNBNTFFLEtBQUssQ0FBQzgrRSxPQUFOLEdBQWdCOStFLEtBQUssQ0FBQysrRSxLQUFOLEdBQWNqMUQsRUFBRSxDQUFDeW9CLFNBQUgsRUFBOUI7Y0FDQStqQyxRQUFRLENBQUN4c0QsRUFBRCxFQUFLdTJELEdBQUwsQ0FBUjthQUh5QjtXQUR2QixDQUFOOzs7O01BVUosU0FBUy9KLFFBQVQsQ0FBa0J4c0QsRUFBbEIsRUFBc0J1MkQsR0FBdEIsRUFBMkJ0QyxRQUEzQixFQUFxQztRQUFDajBELEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO1VBQzVELElBQUk3YixLQUFLLEdBQUdpL0UsY0FBYyxDQUFDbjFELEVBQUQsQ0FBMUI7VUFDQSxJQUFJK2lCLE1BQU0sR0FBRzJwQyxlQUFlLENBQUMxc0QsRUFBRCxFQUFLOXBCLEtBQUssQ0FBQzQxRSxLQUFYLEVBQWtCeUssR0FBRyxHQUFHcmdGLEtBQUssQ0FBQzgrRSxPQUFULEdBQW1COStFLEtBQUssQ0FBQysrRSxLQUE5QyxDQUE1Qjs7VUFDQSxJQUFJLENBQUNseUMsTUFBTSxDQUFDcHlELElBQVAsQ0FBWTRsRyxHQUFaLENBQUwsRUFBdUI7WUFDckJ4ekMsTUFBTSxHQUFHMnBDLGVBQWUsQ0FBQzFzRCxFQUFELEVBQUs5cEIsS0FBSyxDQUFDNDFFLEtBQVgsRUFBa0J5SyxHQUFHLEdBQUd2ekIsVUFBVSxDQUFDMzdCLEdBQVgsQ0FBZXJILEVBQUUsQ0FBQ2lRLFFBQUgsRUFBZixDQUFILEdBQW1DK3lCLFVBQVUsQ0FBQzM3QixHQUFYLENBQWVySCxFQUFFLENBQUN5MUIsU0FBSCxFQUFmLEVBQStCLENBQS9CLENBQXhELENBQXhCO1lBQ0EsSUFBSSxDQUFDMVMsTUFBTSxDQUFDcHlELElBQVAsQ0FBWTRsRyxHQUFaLENBQUwsRUFBdUI7OztVQUV6QnYyRCxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQnRXLE1BQU0sQ0FBQ24yRCxJQUFQLEVBQWhCLEVBQStCbTJELE1BQU0sQ0FBQzN5RCxFQUFQLEVBQS9CO1VBQ0E0dkMsRUFBRSxDQUFDaW5CLGNBQUgsQ0FBa0I7WUFBQ3I2RCxJQUFJLEVBQUVtMkQsTUFBTSxDQUFDbjJELElBQVAsRUFBUDtZQUFzQndELEVBQUUsRUFBRTJ5RCxNQUFNLENBQUMzeUQsRUFBUDtXQUE1QyxFQUEwRCxFQUExRDtVQUNBOGxCLEtBQUssQ0FBQzgrRSxPQUFOLEdBQWdCanlDLE1BQU0sQ0FBQ24yRCxJQUFQLEVBQWhCO1VBQStCc3BCLEtBQUssQ0FBQysrRSxLQUFOLEdBQWNseUMsTUFBTSxDQUFDM3lELEVBQVAsRUFBZDtVQUMvQixJQUFJNmpHLFFBQUosRUFBY0EsUUFBUSxDQUFDbHhDLE1BQU0sQ0FBQ24yRCxJQUFQLEVBQUQsRUFBZ0JtMkQsTUFBTSxDQUFDM3lELEVBQVAsRUFBaEIsQ0FBUjtTQVZzQjs7O01BYXRDLFNBQVNvbEcsV0FBVCxDQUFxQngxRCxFQUFyQixFQUF5QjtRQUFDQSxFQUFFLENBQUNqTyxTQUFILENBQWEsWUFBVztVQUNoRCxJQUFJN2IsS0FBSyxHQUFHaS9FLGNBQWMsQ0FBQ24xRCxFQUFELENBQTFCO1VBQ0E5cEIsS0FBSyxDQUFDZy9FLFNBQU4sR0FBa0JoL0UsS0FBSyxDQUFDNDFFLEtBQXhCO1VBQ0EsSUFBSSxDQUFDNTFFLEtBQUssQ0FBQzQxRSxLQUFYLEVBQWtCO1VBQ2xCNTFFLEtBQUssQ0FBQzQxRSxLQUFOLEdBQWM1MUUsS0FBSyxDQUFDaWdGLFNBQU4sR0FBa0IsSUFBaEM7VUFDQW4yRCxFQUFFLENBQUM0MkMsYUFBSCxDQUFpQjFnRSxLQUFLLENBQUM4eUIsT0FBdkI7O1VBQ0EsSUFBSTl5QixLQUFLLENBQUNtZ0YsUUFBVixFQUFvQjtZQUFFbmdGLEtBQUssQ0FBQ21nRixRQUFOLENBQWV2OUYsS0FBZjtZQUF3Qm9kLEtBQUssQ0FBQ21nRixRQUFOLEdBQWlCLElBQWpCOztTQU50Qjs7O01BUzFCLFNBQVNyaEgsRUFBVCxDQUFZcEIsR0FBWixFQUFpQm1qSCxLQUFqQixFQUF3QjtRQUN0QixJQUFJMW5GLE9BQU8sR0FBR3o3QixHQUFHLEdBQUdwRyxRQUFRLENBQUNFLGFBQVQsQ0FBdUJrRyxHQUF2QixDQUFILEdBQWlDcEcsUUFBUSxDQUFDc2xFLHNCQUFULEVBQWxEOztRQUNBLEtBQUssSUFBSXBtRSxHQUFULElBQWdCcXFILEtBQWhCLEVBQXVCO1VBQ3JCMW5GLE9BQU8sQ0FBQzNpQyxHQUFELENBQVAsR0FBZXFxSCxLQUFLLENBQUNycUgsR0FBRCxDQUFwQjs7O1FBRUYsS0FBSyxJQUFJbUcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRy9CLFNBQVMsQ0FBQ0wsTUFBOUIsRUFBc0NvQyxDQUFDLEVBQXZDLEVBQTJDO1VBQ3pDLElBQUlxbUQsS0FBSyxHQUFHcG9ELFNBQVMsQ0FBQytCLENBQUQsQ0FBckI7VUFDQXc4QixPQUFPLENBQUNuNEIsV0FBUixDQUFvQixPQUFPZ2lELEtBQVAsSUFBZ0IsUUFBaEIsR0FBMkIxckQsUUFBUSxDQUFDeXNCLGNBQVQsQ0FBd0JpL0IsS0FBeEIsQ0FBM0IsR0FBNERBLEtBQWhGOzs7UUFFRixPQUFPN3BCLE9BQVA7OztNQUdGLFNBQVN3bkYsY0FBVCxDQUF3QjcyRCxFQUF4QixFQUE2QjtRQUMzQixPQUFPaHJELEVBQUUsQ0FBQyxFQUFELEVBQUssSUFBTCxFQUNDQSxFQUFFLENBQUMsTUFBRCxFQUFTO1VBQUNtakQsU0FBUyxFQUFFO1NBQXJCLEVBQWlENkgsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxTQUFWLENBQWpELENBREgsRUFDMkUsR0FEM0UsRUFFQzVqRyxFQUFFLENBQUMsT0FBRCxFQUFVO1VBQUMvRCxJQUFJLEVBQUUsTUFBUDtVQUFlLFNBQVMsYUFBeEI7VUFBdUNrbkQsU0FBUyxFQUFFO1NBQTVELENBRkgsRUFFNEYsR0FGNUYsRUFHQ25qRCxFQUFFLENBQUMsTUFBRCxFQUFTO1VBQUNnQyxLQUFLLEVBQUUsYUFBUjtVQUF1Qm1oRCxTQUFTLEVBQUU7U0FBM0MsRUFDQzZILEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUscUNBQVYsQ0FERCxDQUhILENBQVQ7OztNQU1GLFNBQVNvZSxxQkFBVCxDQUErQmgzRCxFQUEvQixFQUFtQztRQUNqQyxPQUFPaHJELEVBQUUsQ0FBQyxFQUFELEVBQUssSUFBTCxFQUFXLEdBQVgsRUFDQ0EsRUFBRSxDQUFDLE9BQUQsRUFBVTtVQUFDL0QsSUFBSSxFQUFFLE1BQVA7VUFBZSxTQUFTLGFBQXhCO1VBQXVDa25ELFNBQVMsRUFBRTtTQUE1RCxDQURILEVBQzRGLEdBRDVGLEVBRUNuakQsRUFBRSxDQUFDLE1BQUQsRUFBUztVQUFDZ0MsS0FBSyxFQUFFLGFBQVI7VUFBdUJtaEQsU0FBUyxFQUFFO1NBQTNDLEVBQ0M2SCxFQUFFLENBQUM0NEMsTUFBSCxDQUFVLHFDQUFWLENBREQsQ0FGSCxDQUFUOzs7TUFLRixTQUFTcWUseUJBQVQsQ0FBbUNqM0QsRUFBbkMsRUFBdUM7UUFDckMsT0FBT2hyRCxFQUFFLENBQUMsRUFBRCxFQUFLLElBQUwsRUFDQ0EsRUFBRSxDQUFDLE1BQUQsRUFBUztVQUFDbWpELFNBQVMsRUFBRTtTQUFyQixFQUFpRDZILEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUsT0FBVixDQUFqRCxDQURILEVBQ3lFLEdBRHpFLEVBRUM1akcsRUFBRSxDQUFDLE9BQUQsRUFBVTtVQUFDL0QsSUFBSSxFQUFFLE1BQVA7VUFBZSxTQUFTLGFBQXhCO1VBQXVDa25ELFNBQVMsRUFBRTtTQUE1RCxDQUZILENBQVQ7OztNQUlGLFNBQVMrK0QsbUJBQVQsQ0FBNkJsM0QsRUFBN0IsRUFBaUM7UUFDL0IsT0FBT2hyRCxFQUFFLENBQUMsRUFBRCxFQUFLLElBQUwsRUFDQ0EsRUFBRSxDQUFDLE1BQUQsRUFBUztVQUFDbWpELFNBQVMsRUFBRTtTQUFyQixFQUFpRDZILEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUsVUFBVixDQUFqRCxDQURILEVBQzRFLEdBRDVFLEVBRUM1akcsRUFBRSxDQUFDLFFBQUQsRUFBVyxFQUFYLEVBQWVnckQsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxLQUFWLENBQWYsQ0FGSCxFQUVxQyxHQUZyQyxFQUdDNWpHLEVBQUUsQ0FBQyxRQUFELEVBQVcsRUFBWCxFQUFlZ3JELEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUsSUFBVixDQUFmLENBSEgsRUFHb0MsR0FIcEMsRUFJQzVqRyxFQUFFLENBQUMsUUFBRCxFQUFXLEVBQVgsRUFBZWdyRCxFQUFFLENBQUM0NEMsTUFBSCxDQUFVLEtBQVYsQ0FBZixDQUpILEVBSXFDLEdBSnJDLEVBS0M1akcsRUFBRSxDQUFDLFFBQUQsRUFBVyxFQUFYLEVBQWVnckQsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxNQUFWLENBQWYsQ0FMSCxDQUFUOzs7TUFRRixTQUFTdWUsVUFBVCxDQUFvQm4zRCxFQUFwQixFQUF3QjhyRCxLQUF4QixFQUErQmo5RCxJQUEvQixFQUFxQztRQUNuQ21SLEVBQUUsQ0FBQ2pPLFNBQUgsQ0FBYSxZQUFXO1VBQ3RCLEtBQUssSUFBSWd4QixNQUFNLEdBQUcycEMsZUFBZSxDQUFDMXNELEVBQUQsRUFBSzhyRCxLQUFMLENBQWpDLEVBQThDL29DLE1BQU0sQ0FBQ3lwQyxRQUFQLEVBQTlDLEdBQWtFO1lBQ2hFLElBQUksT0FBT1YsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtjQUM1QixJQUFJcnRHLEtBQUssR0FBR3VoRCxFQUFFLENBQUNpZ0MsUUFBSCxDQUFZbGQsTUFBTSxDQUFDbjJELElBQVAsRUFBWixFQUEyQm0yRCxNQUFNLENBQUMzeUQsRUFBUCxFQUEzQixFQUF3QzNSLEtBQXhDLENBQThDcXRHLEtBQTlDLENBQVo7Y0FDQS9vQyxNQUFNLENBQUN2akUsT0FBUCxDQUFlcXZDLElBQUksQ0FBQ3J2QyxPQUFMLENBQWEsU0FBYixFQUF3QixVQUFTa29HLENBQVQsRUFBWTcwRyxDQUFaLEVBQWU7Z0JBQUMsT0FBTzRMLEtBQUssQ0FBQzVMLENBQUQsQ0FBWjtlQUF4QyxDQUFmO2FBRkYsTUFHT2t3RSxNQUFNLENBQUN2akUsT0FBUCxDQUFlcXZDLElBQWY7O1NBTFg7OztNQVVGLFNBQVNydkMsT0FBVCxDQUFpQndnRCxFQUFqQixFQUFxQjVoQyxHQUFyQixFQUEwQjtRQUN4QixJQUFJNGhDLEVBQUUsQ0FBQzJSLFNBQUgsQ0FBYSxVQUFiLENBQUosRUFBOEI7UUFDOUIsSUFBSW02QyxLQUFLLEdBQUc5ckQsRUFBRSxDQUFDb0MsWUFBSCxNQUFxQit5RCxjQUFjLENBQUNuMUQsRUFBRCxDQUFkLENBQW1CazFELFNBQXBEO1FBQ0EsSUFBSWtDLFVBQVUsR0FBR2g1RixHQUFHLEdBQUc0aEMsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxjQUFWLENBQUgsR0FBK0I1NEMsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxVQUFWLENBQW5EO1FBQ0EsSUFBSXg1RCxRQUFRLEdBQUdwcUMsRUFBRSxDQUFDLEVBQUQsRUFBSyxJQUFMLEVBQ0NBLEVBQUUsQ0FBQyxNQUFELEVBQVM7VUFBQ21qRCxTQUFTLEVBQUU7U0FBckIsRUFBaURpL0QsVUFBakQsQ0FESCxFQUVDSixxQkFBcUIsQ0FBQ2gzRCxFQUFELENBRnRCLENBQWpCO1FBR0E2ekQsTUFBTSxDQUFDN3pELEVBQUQsRUFBSzVnQixRQUFMLEVBQWVnNEUsVUFBZixFQUEyQnRMLEtBQTNCLEVBQWtDLFVBQVNBLEtBQVQsRUFBZ0I7VUFDdEQsSUFBSSxDQUFDQSxLQUFMLEVBQVk7VUFDWkEsS0FBSyxHQUFHa0ssVUFBVSxDQUFDbEssS0FBRCxDQUFsQjtVQUNBK0gsTUFBTSxDQUFDN3pELEVBQUQsRUFBS2kzRCx5QkFBeUIsQ0FBQ2ozRCxFQUFELENBQTlCLEVBQW9DQSxFQUFFLENBQUM0NEMsTUFBSCxDQUFVLGVBQVYsQ0FBcEMsRUFBZ0UsRUFBaEUsRUFBb0UsVUFBUy9wRCxJQUFULEVBQWU7WUFDdkZBLElBQUksR0FBR2tuRSxXQUFXLENBQUNsbkUsSUFBRCxDQUFsQjs7WUFDQSxJQUFJendCLEdBQUosRUFBUztjQUNQKzRGLFVBQVUsQ0FBQ24zRCxFQUFELEVBQUs4ckQsS0FBTCxFQUFZajlELElBQVosQ0FBVjthQURGLE1BRU87Y0FDTDJtRSxXQUFXLENBQUN4MUQsRUFBRCxDQUFYO2NBQ0EsSUFBSStpQixNQUFNLEdBQUcycEMsZUFBZSxDQUFDMXNELEVBQUQsRUFBSzhyRCxLQUFMLEVBQVk5ckQsRUFBRSxDQUFDeW9CLFNBQUgsQ0FBYSxNQUFiLENBQVosQ0FBNUI7O2NBQ0EsSUFBSTR1QyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFXO2dCQUN2QixJQUFJdHBHLEtBQUssR0FBR2cxRCxNQUFNLENBQUNuMkQsSUFBUCxFQUFaO29CQUEyQm5PLEtBQTNCOztnQkFDQSxJQUFJLEVBQUVBLEtBQUssR0FBR3NrRSxNQUFNLENBQUN5cEMsUUFBUCxFQUFWLENBQUosRUFBa0M7a0JBQ2hDenBDLE1BQU0sR0FBRzJwQyxlQUFlLENBQUMxc0QsRUFBRCxFQUFLOHJELEtBQUwsQ0FBeEI7a0JBQ0EsSUFBSSxFQUFFcnRHLEtBQUssR0FBR3NrRSxNQUFNLENBQUN5cEMsUUFBUCxFQUFWLEtBQ0N6K0YsS0FBSyxJQUFJZzFELE1BQU0sQ0FBQ24yRCxJQUFQLEdBQWN3eUMsSUFBZCxJQUFzQnJ4QyxLQUFLLENBQUNxeEMsSUFBckMsSUFBNkMyakIsTUFBTSxDQUFDbjJELElBQVAsR0FBYzBJLEVBQWQsSUFBb0J2SCxLQUFLLENBQUN1SCxFQUQ1RSxFQUNpRjs7O2dCQUVuRjBxQyxFQUFFLENBQUNxNUIsWUFBSCxDQUFnQnRXLE1BQU0sQ0FBQ24yRCxJQUFQLEVBQWhCLEVBQStCbTJELE1BQU0sQ0FBQzN5RCxFQUFQLEVBQS9CO2dCQUNBNHZDLEVBQUUsQ0FBQ2luQixjQUFILENBQWtCO2tCQUFDcjZELElBQUksRUFBRW0yRCxNQUFNLENBQUNuMkQsSUFBUCxFQUFQO2tCQUFzQndELEVBQUUsRUFBRTJ5RCxNQUFNLENBQUMzeUQsRUFBUDtpQkFBNUM7Z0JBQ0F1bEcsYUFBYSxDQUFDMzFELEVBQUQsRUFBS2szRCxtQkFBbUIsQ0FBQ2wzRCxFQUFELENBQXhCLEVBQThCQSxFQUFFLENBQUM0NEMsTUFBSCxDQUFVLFVBQVYsQ0FBOUIsRUFDQyxDQUFDLFlBQVc7a0JBQUMwZSxTQUFTLENBQUM3NEcsS0FBRCxDQUFUO2lCQUFiLEVBQWlDNDRHLE9BQWpDLEVBQ0MsWUFBVztrQkFBQ0YsVUFBVSxDQUFDbjNELEVBQUQsRUFBSzhyRCxLQUFMLEVBQVlqOUQsSUFBWixDQUFWO2lCQURiLENBREQsQ0FBYjtlQVRGOztjQWFBLElBQUl5b0UsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBUzc0RyxLQUFULEVBQWdCO2dCQUM5QnNrRSxNQUFNLENBQUN2akUsT0FBUCxDQUFlLE9BQU9zc0csS0FBUCxJQUFnQixRQUFoQixHQUEyQmo5RCxJQUEzQixHQUNBQSxJQUFJLENBQUNydkMsT0FBTCxDQUFhLFNBQWIsRUFBd0IsVUFBU2tvRyxDQUFULEVBQVk3MEcsQ0FBWixFQUFlO2tCQUFDLE9BQU80TCxLQUFLLENBQUM1TCxDQUFELENBQVo7aUJBQXhDLENBRGY7Z0JBRUF3a0gsT0FBTztlQUhUOztjQUtBQSxPQUFPOztXQXpCTCxDQUFOO1NBSEksQ0FBTjs7O01Ba0NGcjBCLFVBQVUsQ0FBQ3dGLFFBQVgsQ0FBb0I3M0UsSUFBcEIsR0FBMkIsVUFBU3F2QyxFQUFULEVBQWE7UUFBQ3cxRCxXQUFXLENBQUN4MUQsRUFBRCxDQUFYO1FBQWlCczJELFFBQVEsQ0FBQ3QyRCxFQUFELENBQVI7T0FBMUQ7O01BQ0FnakMsVUFBVSxDQUFDd0YsUUFBWCxDQUFvQit1QixjQUFwQixHQUFxQyxVQUFTdjNELEVBQVQsRUFBYTtRQUFDdzFELFdBQVcsQ0FBQ3gxRCxFQUFELENBQVg7UUFBaUJzMkQsUUFBUSxDQUFDdDJELEVBQUQsRUFBSyxLQUFMLEVBQVksSUFBWixDQUFSO09BQXBFOztNQUNBZ2pDLFVBQVUsQ0FBQ3dGLFFBQVgsQ0FBb0JndkIsa0JBQXBCLEdBQXlDLFVBQVN4M0QsRUFBVCxFQUFhO1FBQUNzMkQsUUFBUSxDQUFDdDJELEVBQUQsRUFBSyxLQUFMLEVBQVksSUFBWixFQUFrQixJQUFsQixDQUFSO09BQXZEOztNQUNBZ2pDLFVBQVUsQ0FBQ3dGLFFBQVgsQ0FBb0JpdkIsa0JBQXBCLEdBQXlDLFVBQVN6M0QsRUFBVCxFQUFhO1FBQUNzMkQsUUFBUSxDQUFDdDJELEVBQUQsRUFBSyxJQUFMLEVBQVcsSUFBWCxFQUFpQixJQUFqQixDQUFSO09BQXZEOztNQUNBZ2pDLFVBQVUsQ0FBQ3dGLFFBQVgsQ0FBb0Jna0IsUUFBcEIsR0FBK0I4SixRQUEvQjs7TUFDQXR6QixVQUFVLENBQUN3RixRQUFYLENBQW9Ca3ZCLFFBQXBCLEdBQStCLFVBQVMxM0QsRUFBVCxFQUFhO1FBQUNzMkQsUUFBUSxDQUFDdDJELEVBQUQsRUFBSyxJQUFMLENBQVI7T0FBN0M7O01BQ0FnakMsVUFBVSxDQUFDd0YsUUFBWCxDQUFvQmd0QixXQUFwQixHQUFrQ0EsV0FBbEM7TUFDQXh5QixVQUFVLENBQUN3RixRQUFYLENBQW9CaHBGLE9BQXBCLEdBQThCQSxPQUE5Qjs7TUFDQXdqRixVQUFVLENBQUN3RixRQUFYLENBQW9CMnVCLFVBQXBCLEdBQWlDLFVBQVNuM0QsRUFBVCxFQUFhO1FBQUN4Z0QsT0FBTyxDQUFDd2dELEVBQUQsRUFBSyxJQUFMLENBQVA7T0FBL0M7S0F2UkY7Ozs7Ozs7SUNOQSxDQUFDLFVBQVNzbUMsR0FBVCxFQUFjO01BQ2IsQUFDRUEsR0FBRyxDQUFDeDVGLFVBQUQsRUFBa0NhLE1BQWxDLENBQUgsQ0FERjtLQURGLEVBT0csVUFBU3ExRixVQUFULEVBQXFCOztNQUl0QkEsVUFBVSxDQUFDc08sWUFBWCxDQUF3QixRQUF4QixFQUFrQztRQUFDbDNCLE1BQU0sRUFBRTtPQUEzQzs7TUFFQSxTQUFTeTVDLE1BQVQsQ0FBZ0I3ekQsRUFBaEIsRUFBb0JuUixJQUFwQixFQUEwQjRtRSxTQUExQixFQUFxQ3JrQixLQUFyQyxFQUE0Q3JpRyxDQUE1QyxFQUErQztRQUM3QyxJQUFJaXhELEVBQUUsQ0FBQ3UxRCxVQUFQLEVBQW1CdjFELEVBQUUsQ0FBQ3UxRCxVQUFILENBQWMxbUUsSUFBZCxFQUFvQjkvQyxDQUFwQixFQUF1QjtVQUFDTixLQUFLLEVBQUUyaUcsS0FBUjtVQUFlaWpCLGlCQUFpQixFQUFFLElBQWxDO1VBQXdDajZDLE1BQU0sRUFBRXBhLEVBQUUsQ0FBQ2psQixPQUFILENBQVd4eEIsTUFBWCxDQUFrQjZ3RDtTQUF6RixFQUFuQixLQUNLcnJFLENBQUMsQ0FBQzJtSCxNQUFNLENBQUNELFNBQUQsRUFBWXJrQixLQUFaLENBQVAsQ0FBRDs7O01BR1AsU0FBU3VtQixhQUFULENBQXVCMzNELEVBQXZCLEVBQTJCO1FBQ3pCLE9BQU9BLEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUsZUFBVixJQUE2QixxSUFBN0IsR0FBcUs1NEMsRUFBRSxDQUFDNDRDLE1BQUgsQ0FBVSxxQ0FBVixDQUFySyxHQUF3TixTQUEvTjs7O01BR0YsU0FBU2dmLGFBQVQsQ0FBdUI1M0QsRUFBdkIsRUFBMkIxZ0QsTUFBM0IsRUFBbUM7UUFDakMsSUFBSXFNLEdBQUcsR0FBR3pLLE1BQU0sQ0FBQzVCLE1BQUQsQ0FBaEI7UUFDQSxJQUFJLFFBQVFqQyxJQUFSLENBQWFpQyxNQUFiLENBQUosRUFBMEIsT0FBTzBnRCxFQUFFLENBQUN5b0IsU0FBSCxHQUFlcnBCLElBQWYsR0FBc0J6ekMsR0FBN0IsQ0FBMUIsS0FDSyxPQUFPQSxHQUFHLEdBQUcsQ0FBYjs7O01BR1BxM0UsVUFBVSxDQUFDd0YsUUFBWCxDQUFvQnF2QixVQUFwQixHQUFpQyxVQUFTNzNELEVBQVQsRUFBYTtRQUM1QyxJQUFJL0MsR0FBRyxHQUFHK0MsRUFBRSxDQUFDeW9CLFNBQUgsRUFBVjtRQUNBb3JDLE1BQU0sQ0FBQzd6RCxFQUFELEVBQUsyM0QsYUFBYSxDQUFDMzNELEVBQUQsQ0FBbEIsRUFBd0JBLEVBQUUsQ0FBQzQ0QyxNQUFILENBQVUsZUFBVixDQUF4QixFQUFxRDM3QyxHQUFHLENBQUNtQyxJQUFKLEdBQVcsQ0FBWixHQUFpQixHQUFqQixHQUF1Qm5DLEdBQUcsQ0FBQzNuQyxFQUEvRSxFQUFtRixVQUFTd2lHLE1BQVQsRUFBaUI7VUFDeEcsSUFBSSxDQUFDQSxNQUFMLEVBQWE7VUFFYixJQUFJcjVHLEtBQUo7O1VBQ0EsSUFBSUEsS0FBSyxHQUFHLG9DQUFvQzdSLElBQXBDLENBQXlDa3JILE1BQXpDLENBQVosRUFBOEQ7WUFDNUQ5M0QsRUFBRSxDQUFDdWdDLFNBQUgsQ0FBYXEzQixhQUFhLENBQUM1M0QsRUFBRCxFQUFLdmhELEtBQUssQ0FBQyxDQUFELENBQVYsQ0FBMUIsRUFBMEN5QyxNQUFNLENBQUN6QyxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQWhEO1dBREYsTUFFTyxJQUFJQSxLQUFLLEdBQUcsZ0NBQWdDN1IsSUFBaEMsQ0FBcUNrckgsTUFBckMsQ0FBWixFQUEwRDtZQUMvRCxJQUFJMTRELElBQUksR0FBR2h6RCxJQUFJLENBQUMrL0IsS0FBTCxDQUFXNnpCLEVBQUUsQ0FBQ3FnQyxTQUFILEtBQWlCbi9FLE1BQU0sQ0FBQ3pDLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBdkIsR0FBb0MsR0FBL0MsQ0FBWDtZQUNBLElBQUksUUFBUXBCLElBQVIsQ0FBYW9CLEtBQUssQ0FBQyxDQUFELENBQWxCLENBQUosRUFBNEIyZ0QsSUFBSSxHQUFHbkMsR0FBRyxDQUFDbUMsSUFBSixHQUFXQSxJQUFYLEdBQWtCLENBQXpCO1lBQzVCWSxFQUFFLENBQUN1Z0MsU0FBSCxDQUFhbmhDLElBQUksR0FBRyxDQUFwQixFQUF1Qm5DLEdBQUcsQ0FBQzNuQyxFQUEzQjtXQUhLLE1BSUEsSUFBSTdXLEtBQUssR0FBRyw0QkFBNEI3UixJQUE1QixDQUFpQ2tySCxNQUFqQyxDQUFaLEVBQXNEO1lBQzNEOTNELEVBQUUsQ0FBQ3VnQyxTQUFILENBQWFxM0IsYUFBYSxDQUFDNTNELEVBQUQsRUFBS3ZoRCxLQUFLLENBQUMsQ0FBRCxDQUFWLENBQTFCLEVBQTBDdytDLEdBQUcsQ0FBQzNuQyxFQUE5Qzs7U0FYRSxDQUFOO09BRkY7O01Ba0JBMHRFLFVBQVUsQ0FBQzZDLE1BQVgsQ0FBa0IsU0FBbEIsRUFBNkIsT0FBN0IsSUFBd0MsWUFBeEM7S0E5Q0Y7Ozs7OztJQ0ZBLENBQUMsVUFBU1MsR0FBVCxFQUFjO01BQ2IsQUFDRUEsR0FBRyxDQUFDeDVGLFVBQUQsQ0FBSCxDQURGO0tBREYsRUFPRyxVQUFTazJGLFVBQVQsRUFBcUI7O01BR3RCLElBQUkrMEIsU0FBUyxHQUFHLEVBQWhCO01BQ0EsSUFBSUMsS0FBSyxHQUFHLGFBQVo7TUFDQSxJQUFJM3dELEdBQUcsR0FBRzI3QixVQUFVLENBQUMzN0IsR0FBckI7VUFBMEJDLEdBQUcsR0FBRzA3QixVQUFVLENBQUM4ZCxNQUEzQzs7TUFFQSxTQUFTaFYsVUFBVCxDQUFvQmhzRixHQUFwQixFQUF5QjtRQUN2QixJQUFJKzhDLEtBQUssR0FBRy84QyxHQUFHLENBQUN5SixNQUFKLENBQVd5dUcsS0FBWCxDQUFaO1FBQ0EsT0FBT243RCxLQUFLLElBQUksQ0FBQyxDQUFWLEdBQWMsQ0FBZCxHQUFrQkEsS0FBekI7OztNQUdGbW1DLFVBQVUsQ0FBQ3dGLFFBQVgsQ0FBb0Jvb0IsYUFBcEIsR0FBb0MsVUFBUzV3RCxFQUFULEVBQWE7UUFDL0NBLEVBQUUsQ0FBQzR3RCxhQUFIO09BREY7O01BSUE1dEIsVUFBVSxDQUFDZ2UsZUFBWCxDQUEyQixlQUEzQixFQUE0QyxVQUFTam1FLE9BQVQsRUFBa0I7UUFDNUQsSUFBSSxDQUFDQSxPQUFMLEVBQWNBLE9BQU8sR0FBR2c5RSxTQUFWO1FBQ2QsSUFBSS8zRCxFQUFFLEdBQUcsSUFBVDtRQUNBLElBQUlpNEQsT0FBTyxHQUFHLzNHLFFBQWQ7WUFBd0J3aUUsTUFBTSxHQUFHLEtBQUs0ZCxjQUFMLEVBQWpDO1lBQXdEN3dGLElBQUksR0FBRyxJQUEvRDs7UUFDQSxLQUFLLElBQUlvRCxDQUFDLEdBQUc2dkUsTUFBTSxDQUFDanlFLE1BQVAsR0FBZ0IsQ0FBN0IsRUFBZ0NvQyxDQUFDLElBQUksQ0FBckMsRUFBd0NBLENBQUMsRUFBekMsRUFBNkM7VUFDM0MsSUFBSStaLElBQUksR0FBRzgxRCxNQUFNLENBQUM3dkUsQ0FBRCxDQUFOLENBQVUrWixJQUFWLEVBQVg7Y0FBNkJ3RCxFQUFFLEdBQUdzeUQsTUFBTSxDQUFDN3ZFLENBQUQsQ0FBTixDQUFVdWQsRUFBVixFQUFsQztVQUNBLElBQUl4RCxJQUFJLENBQUN3eUMsSUFBTCxJQUFhNjRELE9BQWpCLEVBQTBCO1VBQzFCLElBQUk3bkcsRUFBRSxDQUFDZ3ZDLElBQUgsSUFBVzY0RCxPQUFmLEVBQXdCN25HLEVBQUUsR0FBR2kzQyxHQUFHLENBQUM0d0QsT0FBRCxFQUFVLENBQVYsQ0FBUjtVQUN4QkEsT0FBTyxHQUFHcnJHLElBQUksQ0FBQ3d5QyxJQUFmOztVQUNBLElBQUkzdkQsSUFBSSxJQUFJLElBQVosRUFBa0I7WUFDaEIsSUFBSXV3RCxFQUFFLENBQUNrNEQsU0FBSCxDQUFhdHJHLElBQWIsRUFBbUJ3RCxFQUFuQixFQUF1QjJxQixPQUF2QixDQUFKLEVBQXFDdHJDLElBQUksR0FBRyxJQUFQLENBQXJDLEtBQ0s7Y0FBRXV3RCxFQUFFLENBQUN1cUQsV0FBSCxDQUFlMzlGLElBQWYsRUFBcUJ3RCxFQUFyQixFQUF5QjJxQixPQUF6QjtjQUFtQ3RyQyxJQUFJLEdBQUcsTUFBUDs7V0FGNUMsTUFHTyxJQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtZQUN2QnV3RCxFQUFFLENBQUNrNEQsU0FBSCxDQUFhdHJHLElBQWIsRUFBbUJ3RCxFQUFuQixFQUF1QjJxQixPQUF2QjtXQURLLE1BRUE7WUFDTGlsQixFQUFFLENBQUN1cUQsV0FBSCxDQUFlMzlGLElBQWYsRUFBcUJ3RCxFQUFyQixFQUF5QjJxQixPQUF6Qjs7O09BZk4sRUFoQnNCOztNQXFDdEIsU0FBU285RSxvQkFBVCxDQUE4Qm40RCxFQUE5QixFQUFrQ3I1QyxHQUFsQyxFQUF1Q3k0QyxJQUF2QyxFQUE2QztRQUMzQyxPQUFPLGFBQWEvaEQsSUFBYixDQUFrQjJpRCxFQUFFLENBQUNnM0MsY0FBSCxDQUFrQjN2QyxHQUFHLENBQUMxZ0QsR0FBRyxDQUFDeTRDLElBQUwsRUFBVyxDQUFYLENBQXJCLENBQWxCLEtBQTBELENBQUMsWUFBWS9oRCxJQUFaLENBQWlCK2hELElBQWpCLENBQWxFOzs7TUFHRixTQUFTb0UsT0FBVCxDQUFpQnhELEVBQWpCLEVBQXFCcjVDLEdBQXJCLEVBQTBCO1FBQ3hCLElBQUlsWCxJQUFJLEdBQUd1d0QsRUFBRSxDQUFDd0QsT0FBSCxFQUFYO1FBQ0EsT0FBTy96RCxJQUFJLENBQUMyb0gsZ0JBQUwsS0FBMEIsS0FBMUIsSUFBbUMsQ0FBQzNvSCxJQUFJLENBQUMwMEQsU0FBekMsR0FBcUQxMEQsSUFBckQsR0FBNER1d0QsRUFBRSxDQUFDNDFDLFNBQUgsQ0FBYWp2RixHQUFiLENBQW5FOzs7TUFHRnE4RSxVQUFVLENBQUNnZSxlQUFYLENBQTJCLGFBQTNCLEVBQTBDLFVBQVNwMEYsSUFBVCxFQUFld0QsRUFBZixFQUFtQjJxQixPQUFuQixFQUE0QjtRQUNwRSxJQUFJLENBQUNBLE9BQUwsRUFBY0EsT0FBTyxHQUFHZzlFLFNBQVY7UUFDZCxJQUFJMXJILElBQUksR0FBRyxJQUFYO1lBQWlCb0QsSUFBSSxHQUFHK3pELE9BQU8sQ0FBQ24zRCxJQUFELEVBQU91Z0IsSUFBUCxDQUEvQjtRQUNBLElBQUk2b0UsU0FBUyxHQUFHcHBGLElBQUksQ0FBQzQ1RCxPQUFMLENBQWFyNUMsSUFBSSxDQUFDd3lDLElBQWxCLENBQWhCO1FBQ0EsSUFBSXEyQixTQUFTLElBQUksSUFBYixJQUFxQjBpQyxvQkFBb0IsQ0FBQzlySCxJQUFELEVBQU91Z0IsSUFBUCxFQUFhNm9FLFNBQWIsQ0FBN0MsRUFBc0U7UUFFdEUsSUFBSTRpQyxhQUFhLEdBQUd0OUUsT0FBTyxDQUFDd3ZFLFdBQVIsSUFBdUI5NkcsSUFBSSxDQUFDODZHLFdBQWhEOztRQUNBLElBQUksQ0FBQzhOLGFBQUwsRUFBb0I7VUFDbEIsSUFBSXQ5RSxPQUFPLENBQUNxdkUsaUJBQVIsSUFBNkIzNkcsSUFBSSxDQUFDMjZHLGlCQUF0QyxFQUF5RDtZQUN2RHJ2RSxPQUFPLENBQUN1OUUsU0FBUixHQUFvQixJQUFwQjtZQUNBanNILElBQUksQ0FBQ2tzSCxZQUFMLENBQWtCM3JHLElBQWxCLEVBQXdCd0QsRUFBeEIsRUFBNEIycUIsT0FBNUI7OztVQUVGOzs7UUFHRixJQUFJenhCLEdBQUcsR0FBR2xkLElBQUksQ0FBQ3NJLEdBQUwsQ0FBUzBiLEVBQUUsQ0FBQ2tGLEVBQUgsSUFBUyxDQUFULElBQWNsRixFQUFFLENBQUNndkMsSUFBSCxJQUFXeHlDLElBQUksQ0FBQ3d5QyxJQUE5QixHQUFxQ2h2QyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQS9DLEdBQW1EaHZDLEVBQUUsQ0FBQ2d2QyxJQUEvRCxFQUFxRS95RCxJQUFJLENBQUM0akUsUUFBTCxLQUFrQixDQUF2RixDQUFWO1FBQ0EsSUFBSXVvRCxHQUFHLEdBQUd6OUUsT0FBTyxDQUFDd1UsT0FBUixJQUFtQixJQUFuQixHQUEwQixHQUExQixHQUFnQ3hVLE9BQU8sQ0FBQ3dVLE9BQWxEO1FBQ0EsSUFBSWtwRSxVQUFVLEdBQUcxOUUsT0FBTyxDQUFDMjlFLGlCQUFSLElBQTZCOXJHLElBQUksQ0FBQ3d5QyxJQUFMLElBQWFodkMsRUFBRSxDQUFDZ3ZDLElBQTlEO1FBRUEveUQsSUFBSSxDQUFDMGxELFNBQUwsQ0FBZSxZQUFXO1VBQ3hCLElBQUloWCxPQUFPLENBQUNtNUQsTUFBWixFQUFvQjtZQUNsQixJQUFJeWtCLFVBQVUsR0FBRyxJQUFqQjs7WUFDQSxLQUFLLElBQUk5bEgsQ0FBQyxHQUFHK1osSUFBSSxDQUFDd3lDLElBQWxCLEVBQXdCdnNELENBQUMsR0FBR3lXLEdBQTVCLEVBQWlDLEVBQUV6VyxDQUFuQyxFQUFzQztjQUNwQyxJQUFJdXNELElBQUksR0FBRy95RCxJQUFJLENBQUM0NUQsT0FBTCxDQUFhcHpELENBQWIsQ0FBWDtjQUNBLElBQUkrbEgsVUFBVSxHQUFHeDVELElBQUksQ0FBQ2xyRCxLQUFMLENBQVcsQ0FBWCxFQUFjNDNGLFVBQVUsQ0FBQzFzQyxJQUFELENBQXhCLENBQWpCOztjQUNBLElBQUl1NUQsVUFBVSxJQUFJLElBQWQsSUFBc0JBLFVBQVUsQ0FBQ2xvSCxNQUFYLEdBQW9CbW9ILFVBQVUsQ0FBQ25vSCxNQUF6RCxFQUFpRTtnQkFDL0Rrb0gsVUFBVSxHQUFHQyxVQUFiOzs7O1lBR0osS0FBSyxJQUFJL2xILENBQUMsR0FBRytaLElBQUksQ0FBQ3d5QyxJQUFsQixFQUF3QnZzRCxDQUFDLEdBQUd5VyxHQUE1QixFQUFpQyxFQUFFelcsQ0FBbkMsRUFBc0M7Y0FDcEMsSUFBSXVzRCxJQUFJLEdBQUcveUQsSUFBSSxDQUFDNDVELE9BQUwsQ0FBYXB6RCxDQUFiLENBQVg7a0JBQTRCMHVFLEdBQUcsR0FBR28zQyxVQUFVLENBQUNsb0gsTUFBN0M7Y0FDQSxJQUFJLENBQUNnb0gsVUFBRCxJQUFlLENBQUNULEtBQUssQ0FBQzM2RyxJQUFOLENBQVcraEQsSUFBWCxDQUFwQixFQUFzQztjQUN0QyxJQUFJQSxJQUFJLENBQUNsckQsS0FBTCxDQUFXLENBQVgsRUFBY3F0RSxHQUFkLEtBQXNCbzNDLFVBQTFCLEVBQXNDcDNDLEdBQUcsR0FBR3VxQixVQUFVLENBQUMxc0MsSUFBRCxDQUFoQjtjQUN0Qy95RCxJQUFJLENBQUNtd0YsWUFBTCxDQUFrQm04QixVQUFVLEdBQUdOLGFBQWIsR0FBNkJHLEdBQS9DLEVBQW9EbnhELEdBQUcsQ0FBQ3gwRCxDQUFELEVBQUksQ0FBSixDQUF2RCxFQUErRHcwRCxHQUFHLENBQUN4MEQsQ0FBRCxFQUFJMHVFLEdBQUosQ0FBbEU7O1dBYkosTUFlTztZQUNMLEtBQUssSUFBSTF1RSxDQUFDLEdBQUcrWixJQUFJLENBQUN3eUMsSUFBbEIsRUFBd0J2c0QsQ0FBQyxHQUFHeVcsR0FBNUIsRUFBaUMsRUFBRXpXLENBQW5DLEVBQXNDO2NBQ3BDLElBQUk0bEgsVUFBVSxJQUFJVCxLQUFLLENBQUMzNkcsSUFBTixDQUFXaFIsSUFBSSxDQUFDNDVELE9BQUwsQ0FBYXB6RCxDQUFiLENBQVgsQ0FBbEIsRUFDRXhHLElBQUksQ0FBQ213RixZQUFMLENBQWtCNjdCLGFBQWEsR0FBR0csR0FBbEMsRUFBdUNueEQsR0FBRyxDQUFDeDBELENBQUQsRUFBSSxDQUFKLENBQTFDOzs7U0FuQlI7T0FuQkY7TUE0Q0Ftd0YsVUFBVSxDQUFDZ2UsZUFBWCxDQUEyQixjQUEzQixFQUEyQyxVQUFTcDBGLElBQVQsRUFBZXdELEVBQWYsRUFBbUIycUIsT0FBbkIsRUFBNEI7UUFDckUsSUFBSSxDQUFDQSxPQUFMLEVBQWNBLE9BQU8sR0FBR2c5RSxTQUFWO1FBQ2QsSUFBSTFySCxJQUFJLEdBQUcsSUFBWDtZQUFpQm9ELElBQUksR0FBRyt6RCxPQUFPLENBQUNuM0QsSUFBRCxFQUFPdWdCLElBQVAsQ0FBL0I7UUFDQSxJQUFJaXNHLFdBQVcsR0FBRzk5RSxPQUFPLENBQUNxdkUsaUJBQVIsSUFBNkIzNkcsSUFBSSxDQUFDMjZHLGlCQUFwRDtRQUNBLElBQUk2QixTQUFTLEdBQUdseEUsT0FBTyxDQUFDc3ZFLGVBQVIsSUFBMkI1NkcsSUFBSSxDQUFDNDZHLGVBQWhEOztRQUNBLElBQUksQ0FBQ3dPLFdBQUQsSUFBZ0IsQ0FBQzVNLFNBQXJCLEVBQWdDO1VBQzlCLElBQUksQ0FBQ2x4RSxPQUFPLENBQUN3dkUsV0FBUixJQUF1Qjk2RyxJQUFJLENBQUM4NkcsV0FBN0IsS0FBNkN4dkUsT0FBTyxDQUFDdTlFLFNBQVIsSUFBcUIsS0FBdEUsRUFDRWpzSCxJQUFJLENBQUNrK0csV0FBTCxDQUFpQjM5RixJQUFqQixFQUF1QndELEVBQXZCLEVBQTJCMnFCLE9BQTNCO1VBQ0Y7OztRQUVGLElBQUksY0FBYzE5QixJQUFkLENBQW1CaFIsSUFBSSxDQUFDMnFHLGNBQUwsQ0FBb0IzdkMsR0FBRyxDQUFDejZDLElBQUksQ0FBQ3d5QyxJQUFOLEVBQVksQ0FBWixDQUF2QixDQUFuQixDQUFKLEVBQWdFO1FBRWhFLElBQUk5MUMsR0FBRyxHQUFHbGQsSUFBSSxDQUFDc0ksR0FBTCxDQUFTMGIsRUFBRSxDQUFDZ3ZDLElBQVosRUFBa0IveUQsSUFBSSxDQUFDNGpFLFFBQUwsRUFBbEIsQ0FBVjtRQUNBLElBQUkzbUQsR0FBRyxJQUFJc0QsSUFBSSxDQUFDd3lDLElBQVosSUFBb0JodkMsRUFBRSxDQUFDa0YsRUFBSCxJQUFTLENBQTdCLElBQWtDMGlHLEtBQUssQ0FBQzM2RyxJQUFOLENBQVdoUixJQUFJLENBQUM0NUQsT0FBTCxDQUFhMzhDLEdBQWIsQ0FBWCxDQUF0QyxFQUFxRSxFQUFFQSxHQUFGO1FBRXJFLElBQUlrdkcsR0FBRyxHQUFHejlFLE9BQU8sQ0FBQ3dVLE9BQVIsSUFBbUIsSUFBbkIsR0FBMEIsR0FBMUIsR0FBZ0N4VSxPQUFPLENBQUN3VSxPQUFsRDtRQUNBLElBQUkzaUMsSUFBSSxDQUFDd3lDLElBQUwsR0FBWTkxQyxHQUFoQixFQUFxQjtRQUVyQmpkLElBQUksQ0FBQzBsRCxTQUFMLENBQWUsWUFBVztVQUN4QixJQUFJaFgsT0FBTyxDQUFDdTlFLFNBQVIsSUFBcUIsS0FBekIsRUFBZ0M7WUFDOUIsSUFBSVEsZUFBZSxHQUFHZCxLQUFLLENBQUMzNkcsSUFBTixDQUFXaFIsSUFBSSxDQUFDNDVELE9BQUwsQ0FBYTM4QyxHQUFiLENBQVgsQ0FBdEI7WUFDQWpkLElBQUksQ0FBQ213RixZQUFMLENBQWtCZzhCLEdBQUcsR0FBR3ZNLFNBQXhCLEVBQW1DNWtELEdBQUcsQ0FBQy85QyxHQUFELENBQXRDO1lBQ0FqZCxJQUFJLENBQUNtd0YsWUFBTCxDQUFrQnE4QixXQUFXLEdBQUdMLEdBQWhDLEVBQXFDbnhELEdBQUcsQ0FBQ3o2QyxJQUFJLENBQUN3eUMsSUFBTixFQUFZLENBQVosQ0FBeEM7WUFDQSxJQUFJMjVELElBQUksR0FBR2grRSxPQUFPLENBQUNpK0UsZ0JBQVIsSUFBNEJ2cEgsSUFBSSxDQUFDdXBILGdCQUE1QztZQUNBLElBQUlELElBQUksSUFBSSxJQUFaLEVBQWtCLEtBQUssSUFBSWxtSCxDQUFDLEdBQUcrWixJQUFJLENBQUN3eUMsSUFBTCxHQUFZLENBQXpCLEVBQTRCdnNELENBQUMsSUFBSXlXLEdBQWpDLEVBQXNDLEVBQUV6VyxDQUF4QztjQUNoQixJQUFJQSxDQUFDLElBQUl5VyxHQUFMLElBQVl3dkcsZUFBaEIsRUFDRXpzSCxJQUFJLENBQUNtd0YsWUFBTCxDQUFrQnU4QixJQUFJLEdBQUdQLEdBQXpCLEVBQThCbnhELEdBQUcsQ0FBQ3gwRCxDQUFELEVBQUksQ0FBSixDQUFqQzs7V0FQTixNQVFPO1lBQ0wsSUFBSW9tSCxRQUFRLEdBQUczeEQsR0FBRyxDQUFDajdELElBQUksQ0FBQ284RSxTQUFMLENBQWUsSUFBZixDQUFELEVBQXVCcjRELEVBQXZCLENBQUgsSUFBaUMsQ0FBaEQ7Z0JBQW1EaUwsS0FBSyxHQUFHLENBQUNodkIsSUFBSSxDQUFDOG5GLGlCQUFMLEVBQTVEO1lBQ0E5bkYsSUFBSSxDQUFDbXdGLFlBQUwsQ0FBa0J5dkIsU0FBbEIsRUFBNkI3N0YsRUFBN0I7WUFDQSxJQUFJNm9HLFFBQUosRUFBYzVzSCxJQUFJLENBQUNndEYsWUFBTCxDQUFrQmgrRCxLQUFLLEdBQUdqTCxFQUFILEdBQVEvakIsSUFBSSxDQUFDbzhFLFNBQUwsQ0FBZSxNQUFmLENBQS9CLEVBQXVEcjRELEVBQXZEO1lBQ2QvakIsSUFBSSxDQUFDbXdGLFlBQUwsQ0FBa0JxOEIsV0FBbEIsRUFBK0Jqc0csSUFBL0I7O1NBYko7T0FsQkY7TUFvQ0FvMkUsVUFBVSxDQUFDZ2UsZUFBWCxDQUEyQixXQUEzQixFQUF3QyxVQUFTcDBGLElBQVQsRUFBZXdELEVBQWYsRUFBbUIycUIsT0FBbkIsRUFBNEI7UUFDbEUsSUFBSSxDQUFDQSxPQUFMLEVBQWNBLE9BQU8sR0FBR2c5RSxTQUFWO1FBQ2QsSUFBSTFySCxJQUFJLEdBQUcsSUFBWDtZQUFpQm9ELElBQUksR0FBRyt6RCxPQUFPLENBQUNuM0QsSUFBRCxFQUFPdWdCLElBQVAsQ0FBL0I7UUFDQSxJQUFJdEQsR0FBRyxHQUFHbGQsSUFBSSxDQUFDc0ksR0FBTCxDQUFTMGIsRUFBRSxDQUFDa0YsRUFBSCxJQUFTLENBQVQsSUFBY2xGLEVBQUUsQ0FBQ2d2QyxJQUFILElBQVd4eUMsSUFBSSxDQUFDd3lDLElBQTlCLEdBQXFDaHZDLEVBQUUsQ0FBQ2d2QyxJQUF4QyxHQUErQ2h2QyxFQUFFLENBQUNndkMsSUFBSCxHQUFVLENBQWxFLEVBQXFFL3lELElBQUksQ0FBQzRqRSxRQUFMLEVBQXJFLENBQVY7WUFBaUdsaUQsS0FBSyxHQUFHM2hCLElBQUksQ0FBQ3NJLEdBQUwsQ0FBU2tZLElBQUksQ0FBQ3d5QyxJQUFkLEVBQW9COTFDLEdBQXBCLENBQXpHLENBSGtFOztRQU1sRSxJQUFJNHZHLFVBQVUsR0FBR24rRSxPQUFPLENBQUN3dkUsV0FBUixJQUF1Qjk2RyxJQUFJLENBQUM4NkcsV0FBN0M7WUFBMERua0QsS0FBSyxHQUFHLEVBQWxFO1FBQ0EsSUFBSW95RCxHQUFHLEdBQUd6OUUsT0FBTyxDQUFDd1UsT0FBUixJQUFtQixJQUFuQixHQUEwQixHQUExQixHQUFnQ3hVLE9BQU8sQ0FBQ3dVLE9BQWxEO1lBQTJENHBFLFlBQTNEOztRQUNBNU8sV0FBVyxFQUFFO1VBQ1gsSUFBSSxDQUFDMk8sVUFBTCxFQUFpQixNQUFNM08sV0FBTjs7VUFDakIsS0FBSyxJQUFJMTNHLENBQUMsR0FBR2tiLEtBQWIsRUFBb0JsYixDQUFDLElBQUl5VyxHQUF6QixFQUE4QixFQUFFelcsQ0FBaEMsRUFBbUM7WUFDakMsSUFBSXVzRCxJQUFJLEdBQUcveUQsSUFBSSxDQUFDNDVELE9BQUwsQ0FBYXB6RCxDQUFiLENBQVg7WUFDQSxJQUFJZ3FELEtBQUssR0FBR3VDLElBQUksQ0FBQzExQyxPQUFMLENBQWF3dkcsVUFBYixDQUFaO1lBQ0EsSUFBSXI4RCxLQUFLLEdBQUcsQ0FBQyxDQUFULElBQWMsQ0FBQyxVQUFVeC9DLElBQVYsQ0FBZWhSLElBQUksQ0FBQzJxRyxjQUFMLENBQW9CM3ZDLEdBQUcsQ0FBQ3gwRCxDQUFELEVBQUlncUQsS0FBSyxHQUFHLENBQVosQ0FBdkIsQ0FBZixDQUFuQixFQUEyRUEsS0FBSyxHQUFHLENBQUMsQ0FBVDtZQUMzRSxJQUFJQSxLQUFLLElBQUksQ0FBQyxDQUFWLElBQWVtN0QsS0FBSyxDQUFDMzZHLElBQU4sQ0FBVytoRCxJQUFYLENBQW5CLEVBQXFDLE1BQU1tckQsV0FBTjtZQUNyQyxJQUFJMXRELEtBQUssR0FBRyxDQUFDLENBQVQsSUFBY203RCxLQUFLLENBQUMzNkcsSUFBTixDQUFXK2hELElBQUksQ0FBQ2xyRCxLQUFMLENBQVcsQ0FBWCxFQUFjMm9ELEtBQWQsQ0FBWCxDQUFsQixFQUFvRCxNQUFNMHRELFdBQU47WUFDcERua0QsS0FBSyxDQUFDNTJELElBQU4sQ0FBVzR2RCxJQUFYOzs7VUFFRi95RCxJQUFJLENBQUMwbEQsU0FBTCxDQUFlLFlBQVc7WUFDeEIsS0FBSyxJQUFJbC9DLENBQUMsR0FBR2tiLEtBQWIsRUFBb0JsYixDQUFDLElBQUl5VyxHQUF6QixFQUE4QixFQUFFelcsQ0FBaEMsRUFBbUM7Y0FDakMsSUFBSXVzRCxJQUFJLEdBQUdnSCxLQUFLLENBQUN2ekQsQ0FBQyxHQUFHa2IsS0FBTCxDQUFoQjtjQUNBLElBQUlwSCxHQUFHLEdBQUd5NEMsSUFBSSxDQUFDMTFDLE9BQUwsQ0FBYXd2RyxVQUFiLENBQVY7a0JBQW9DMW9HLE1BQU0sR0FBRzdKLEdBQUcsR0FBR3V5RyxVQUFVLENBQUN6b0gsTUFBOUQ7Y0FDQSxJQUFJa1csR0FBRyxHQUFHLENBQVYsRUFBYTtjQUNiLElBQUl5NEMsSUFBSSxDQUFDbHJELEtBQUwsQ0FBV3NjLE1BQVgsRUFBbUJBLE1BQU0sR0FBR2dvRyxHQUFHLENBQUMvbkgsTUFBaEMsS0FBMkMrbkgsR0FBL0MsRUFBb0Rob0csTUFBTSxJQUFJZ29HLEdBQUcsQ0FBQy9uSCxNQUFkO2NBQ3BEMG9ILFlBQVksR0FBRyxJQUFmO2NBQ0E5c0gsSUFBSSxDQUFDbXdGLFlBQUwsQ0FBa0IsRUFBbEIsRUFBc0JuMUIsR0FBRyxDQUFDeDBELENBQUQsRUFBSThULEdBQUosQ0FBekIsRUFBbUMwZ0QsR0FBRyxDQUFDeDBELENBQUQsRUFBSTJkLE1BQUosQ0FBdEM7O1dBUEo7VUFVQSxJQUFJMm9HLFlBQUosRUFBa0IsT0FBTyxJQUFQO1NBNUI4Qzs7O1FBZ0NsRSxJQUFJTixXQUFXLEdBQUc5OUUsT0FBTyxDQUFDcXZFLGlCQUFSLElBQTZCMzZHLElBQUksQ0FBQzI2RyxpQkFBcEQ7UUFDQSxJQUFJNkIsU0FBUyxHQUFHbHhFLE9BQU8sQ0FBQ3N2RSxlQUFSLElBQTJCNTZHLElBQUksQ0FBQzQ2RyxlQUFoRDtRQUNBLElBQUksQ0FBQ3dPLFdBQUQsSUFBZ0IsQ0FBQzVNLFNBQXJCLEVBQWdDLE9BQU8sS0FBUDtRQUNoQyxJQUFJOE0sSUFBSSxHQUFHaCtFLE9BQU8sQ0FBQ2krRSxnQkFBUixJQUE0QnZwSCxJQUFJLENBQUN1cEgsZ0JBQTVDO1FBQ0EsSUFBSWhPLFNBQVMsR0FBRzMrRyxJQUFJLENBQUM0NUQsT0FBTCxDQUFhbDRDLEtBQWIsQ0FBaEI7WUFBcUMxVyxJQUFJLEdBQUcyekcsU0FBUyxDQUFDdGhHLE9BQVYsQ0FBa0JtdkcsV0FBbEIsQ0FBNUM7UUFDQSxJQUFJeGhILElBQUksSUFBSSxDQUFDLENBQWIsRUFBZ0IsT0FBTyxLQUFQO1FBQ2hCLElBQUkraEgsT0FBTyxHQUFHOXZHLEdBQUcsSUFBSXlFLEtBQVAsR0FBZWk5RixTQUFmLEdBQTJCMytHLElBQUksQ0FBQzQ1RCxPQUFMLENBQWEzOEMsR0FBYixDQUF6QztRQUNBLElBQUkvUixLQUFLLEdBQUc2aEgsT0FBTyxDQUFDMXZHLE9BQVIsQ0FBZ0J1aUcsU0FBaEIsRUFBMkIzaUcsR0FBRyxJQUFJeUUsS0FBUCxHQUFlMVcsSUFBSSxHQUFHd2hILFdBQVcsQ0FBQ3BvSCxNQUFsQyxHQUEyQyxDQUF0RSxDQUFaO1FBQ0EsSUFBSTRvSCxXQUFXLEdBQUdoeUQsR0FBRyxDQUFDdDVDLEtBQUQsRUFBUTFXLElBQUksR0FBRyxDQUFmLENBQXJCO1lBQXdDaWlILFNBQVMsR0FBR2p5RCxHQUFHLENBQUMvOUMsR0FBRCxFQUFNL1IsS0FBSyxHQUFHLENBQWQsQ0FBdkQ7UUFDQSxJQUFJQSxLQUFLLElBQUksQ0FBQyxDQUFWLElBQ0EsQ0FBQyxVQUFVOEYsSUFBVixDQUFlaFIsSUFBSSxDQUFDMnFHLGNBQUwsQ0FBb0JxaUIsV0FBcEIsQ0FBZixDQURELElBRUEsQ0FBQyxVQUFVaDhHLElBQVYsQ0FBZWhSLElBQUksQ0FBQzJxRyxjQUFMLENBQW9Cc2lCLFNBQXBCLENBQWYsQ0FGRCxJQUdBanRILElBQUksQ0FBQzR6RixRQUFMLENBQWNvNUIsV0FBZCxFQUEyQkMsU0FBM0IsRUFBc0MsSUFBdEMsRUFBNEM1dkcsT0FBNUMsQ0FBb0R1aUcsU0FBcEQsSUFBaUUsQ0FBQyxDQUh0RSxFQUlFLE9BQU8sS0FBUCxDQTdDZ0U7OztRQWlEbEUsSUFBSXNOLFNBQVMsR0FBR3ZPLFNBQVMsQ0FBQzk2RixXQUFWLENBQXNCMm9HLFdBQXRCLEVBQW1DanNHLElBQUksQ0FBQzBJLEVBQXhDLENBQWhCO1FBQ0EsSUFBSWtrRyxRQUFRLEdBQUdELFNBQVMsSUFBSSxDQUFDLENBQWQsR0FBa0IsQ0FBQyxDQUFuQixHQUF1QnZPLFNBQVMsQ0FBQzkyRyxLQUFWLENBQWdCLENBQWhCLEVBQW1CMFksSUFBSSxDQUFDMEksRUFBeEIsRUFBNEI1TCxPQUE1QixDQUFvQ3VpRyxTQUFwQyxFQUErQ3NOLFNBQVMsR0FBR1YsV0FBVyxDQUFDcG9ILE1BQXZFLENBQXRDO1FBQ0EsSUFBSThvSCxTQUFTLElBQUksQ0FBQyxDQUFkLElBQW1CQyxRQUFRLElBQUksQ0FBQyxDQUFoQyxJQUFxQ0EsUUFBUSxHQUFHdk4sU0FBUyxDQUFDeDdHLE1BQXJCLElBQStCbWMsSUFBSSxDQUFDMEksRUFBN0UsRUFBaUYsT0FBTyxLQUFQLENBbkRmOztRQXFEbEVra0csUUFBUSxHQUFHSixPQUFPLENBQUMxdkcsT0FBUixDQUFnQnVpRyxTQUFoQixFQUEyQjc3RixFQUFFLENBQUNrRixFQUE5QixDQUFYO1FBQ0EsSUFBSW1rRyxlQUFlLEdBQUdMLE9BQU8sQ0FBQ2xsSCxLQUFSLENBQWNrYyxFQUFFLENBQUNrRixFQUFqQixFQUFxQnBGLFdBQXJCLENBQWlDMm9HLFdBQWpDLEVBQThDVyxRQUFRLEdBQUdwcEcsRUFBRSxDQUFDa0YsRUFBNUQsQ0FBdEI7UUFDQWlrRyxTQUFTLEdBQUlDLFFBQVEsSUFBSSxDQUFDLENBQWIsSUFBa0JDLGVBQWUsSUFBSSxDQUFDLENBQXZDLEdBQTRDLENBQUMsQ0FBN0MsR0FBaURycEcsRUFBRSxDQUFDa0YsRUFBSCxHQUFRbWtHLGVBQXJFO1FBQ0EsSUFBSUQsUUFBUSxJQUFJLENBQUMsQ0FBYixJQUFrQkQsU0FBUyxJQUFJLENBQUMsQ0FBaEMsSUFBcUNBLFNBQVMsSUFBSW5wRyxFQUFFLENBQUNrRixFQUF6RCxFQUE2RCxPQUFPLEtBQVA7UUFFN0RqcEIsSUFBSSxDQUFDMGxELFNBQUwsQ0FBZSxZQUFXO1VBQ3hCMWxELElBQUksQ0FBQ213RixZQUFMLENBQWtCLEVBQWxCLEVBQXNCbjFCLEdBQUcsQ0FBQy85QyxHQUFELEVBQU0vUixLQUFLLElBQUlpaEgsR0FBRyxJQUFJWSxPQUFPLENBQUNsbEgsS0FBUixDQUFjcUQsS0FBSyxHQUFHaWhILEdBQUcsQ0FBQy9uSCxNQUExQixFQUFrQzhHLEtBQWxDLEtBQTRDaWhILEdBQW5ELEdBQXlEQSxHQUFHLENBQUMvbkgsTUFBN0QsR0FBc0UsQ0FBMUUsQ0FBWCxDQUF6QixFQUNrQjQyRCxHQUFHLENBQUMvOUMsR0FBRCxFQUFNL1IsS0FBSyxHQUFHMDBHLFNBQVMsQ0FBQ3g3RyxNQUF4QixDQURyQjtVQUVBLElBQUkwekUsT0FBTyxHQUFHOXNFLElBQUksR0FBR3doSCxXQUFXLENBQUNwb0gsTUFBakM7VUFDQSxJQUFJK25ILEdBQUcsSUFBSXhOLFNBQVMsQ0FBQzkyRyxLQUFWLENBQWdCaXdFLE9BQWhCLEVBQXlCQSxPQUFPLEdBQUdxMEMsR0FBRyxDQUFDL25ILE1BQXZDLEtBQWtEK25ILEdBQTdELEVBQWtFcjBDLE9BQU8sSUFBSXEwQyxHQUFHLENBQUMvbkgsTUFBZjtVQUNsRXBFLElBQUksQ0FBQ213RixZQUFMLENBQWtCLEVBQWxCLEVBQXNCbjFCLEdBQUcsQ0FBQ3Q1QyxLQUFELEVBQVExVyxJQUFSLENBQXpCLEVBQXdDZ3dELEdBQUcsQ0FBQ3Q1QyxLQUFELEVBQVFvMkQsT0FBUixDQUEzQztVQUNBLElBQUk0MEMsSUFBSixFQUFVLEtBQUssSUFBSWxtSCxDQUFDLEdBQUdrYixLQUFLLEdBQUcsQ0FBckIsRUFBd0JsYixDQUFDLElBQUl5VyxHQUE3QixFQUFrQyxFQUFFelcsQ0FBcEMsRUFBdUM7WUFDL0MsSUFBSXVzRCxJQUFJLEdBQUcveUQsSUFBSSxDQUFDNDVELE9BQUwsQ0FBYXB6RCxDQUFiLENBQVg7Z0JBQTRCZ3FELEtBQUssR0FBR3VDLElBQUksQ0FBQzExQyxPQUFMLENBQWFxdkcsSUFBYixDQUFwQztZQUNBLElBQUlsOEQsS0FBSyxJQUFJLENBQUMsQ0FBVixJQUFlbTdELEtBQUssQ0FBQzM2RyxJQUFOLENBQVcraEQsSUFBSSxDQUFDbHJELEtBQUwsQ0FBVyxDQUFYLEVBQWMyb0QsS0FBZCxDQUFYLENBQW5CLEVBQXFEO1lBQ3JELElBQUk2OEQsUUFBUSxHQUFHNzhELEtBQUssR0FBR2s4RCxJQUFJLENBQUN0b0gsTUFBNUI7WUFDQSxJQUFJK25ILEdBQUcsSUFBSXA1RCxJQUFJLENBQUNsckQsS0FBTCxDQUFXd2xILFFBQVgsRUFBcUJBLFFBQVEsR0FBR2xCLEdBQUcsQ0FBQy9uSCxNQUFwQyxLQUErQytuSCxHQUExRCxFQUErRGtCLFFBQVEsSUFBSWxCLEdBQUcsQ0FBQy9uSCxNQUFoQjtZQUMvRHBFLElBQUksQ0FBQ213RixZQUFMLENBQWtCLEVBQWxCLEVBQXNCbjFCLEdBQUcsQ0FBQ3gwRCxDQUFELEVBQUlncUQsS0FBSixDQUF6QixFQUFxQ3dLLEdBQUcsQ0FBQ3gwRCxDQUFELEVBQUk2bUgsUUFBSixDQUF4Qzs7U0FYSjtRQWNBLE9BQU8sSUFBUDtPQXhFRjtLQXJJRjs7OztBQ0FBLGlCQUFldjJFLEdBQWY7OztBQ0FBLHFCQUFlQSxHQUFmOzs7QUNBQSxvQkFBZUEsR0FBZjs7OztBQ2tCQTYvQyxZQUFVLENBQUN3RixRQUFYLENBQW9CamdDLElBQXBCLEdBQTJCLFVBQVN2SSxFQUFULEVBQWE7SUFDdENBLEVBQUUsQ0FBQzI1RCxZQUFILENBQWdCbHJILEtBQWhCLEdBQXdCdXhELEVBQUUsQ0FBQzgvQixRQUFILEVBQXhCO0lBRUEsSUFBTTNuRSxLQUFLLEdBQUcsSUFBSW8wQixXQUFKLENBQWdCLFFBQWhCLEVBQTBCO01BQ3RDQyxPQUFPLEVBQUUsSUFENkI7TUFFdENDLFFBQVEsRUFBRSxJQUY0QjtNQUd0Q0MsTUFBTSxFQUFFO1FBQUVqK0MsS0FBSyxFQUFFdXhELEVBQUUsQ0FBQzI1RCxZQUFILENBQWdCbHJIOztLQUhyQixDQUFkOztJQU1BdXhELEVBQUUsQ0FBQzI1RCxZQUFILENBQWdCQyxRQUFoQjs7SUFDQTU1RCxFQUFFLENBQUMyNUQsWUFBSCxDQUFnQi9zRSxhQUFoQixDQUE4QnowQixLQUE5QjtFQUNELENBWEQ7O01BYU0waEc7Ozs7O0lBbUdKLG9CQUFjO01BQUE7O01BQUE7O01BQ1o7TUFFQSxNQUFLMW1FLE1BQUwsR0FBYyxJQUFkO01BRUEsTUFBS3BILEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBS0UsTUFBTCxHQUFjLEdBQWQ7TUFDQSxNQUFLc0MsUUFBTCxHQUFnQixFQUFoQjtNQUNBLE1BQUs5L0MsS0FBTDs7O01BR0EsTUFBSytsRCxVQUFMLEdBQWtCLElBQWxCO01BWFk7Ozs7O1dBMUNkLGVBQVk7UUFDVixPQUFPLEtBQUtyQixNQUFaOztXQUdGLGFBQVUxa0QsS0FBVixFQUFpQjtRQUFBOztRQUNmLEtBQUswa0QsTUFBTCxHQUFjMWtELEtBQUssS0FBSyxJQUFWLEdBQWlCQSxLQUFqQixHQUF5QixFQUF2Qzs7UUFFQSxJQUFJLEtBQUtxckgsVUFBVCxFQUFxQjtVQUNuQixJQUFNbnpHLEdBQUcsR0FBRyxLQUFLbXpHLFVBQUwsQ0FBZ0JyeEMsU0FBaEIsRUFBWjtVQUNBLEtBQUtxeEMsVUFBTCxDQUFnQjk1QixRQUFoQixDQUF5QixLQUFLN3NDLE1BQTlCO1VBQ0EsS0FBSzJtRSxVQUFMLENBQWdCdjVCLFNBQWhCLENBQTBCNTVFLEdBQTFCO1VBQ0EsS0FBS2l6RyxRQUFMO1VBQ0EvZ0csVUFBVSxDQUFDO1lBQUEsT0FBTSxNQUFJLENBQUNpaEcsVUFBTCxDQUFnQnRvQixPQUFoQixFQUFOO1dBQUQsRUFBa0MsQ0FBbEMsQ0FBVjs7Ozs7V0FJSixlQUFZO1FBQ1YsT0FBTyxLQUFLdW9CLE1BQVo7O1dBR0YsYUFBVXRySCxLQUFWLEVBQWlCO1FBQ2YsS0FBS3NySCxNQUFMLEdBQWN0ckgsS0FBZDtRQUNBLEtBQUt1ckgsWUFBTCxHQUFvQixLQUFLRCxNQUFMLEdBQWMsQ0FBbEM7O1FBRUEsSUFBSSxLQUFLRCxVQUFULEVBQXFCO1VBQ25CLEtBQUt6MEUsYUFBTDs7Ozs7V0FJSixlQUFhO1FBQ1gsT0FBTyxLQUFLNDBFLE9BQVo7O1dBR0YsYUFBV3hySCxLQUFYLEVBQWtCO1FBQ2hCLEtBQUt3ckgsT0FBTCxHQUFleHJILEtBQWY7UUFDQSxLQUFLeXJILGFBQUwsR0FBcUIsS0FBS0QsT0FBTCxHQUFlLENBQXBDOztRQUVBLElBQUksS0FBS0gsVUFBVCxFQUFxQjtVQUNuQixLQUFLejBFLGFBQUw7Ozs7O2FBa0JKLGtCQUFTO1FBQ1AsSUFBSSxLQUFLeTBFLFVBQVQsRUFBcUI7OztVQUduQixLQUFLQSxVQUFMLENBQWdCbjBCLE9BQWhCLENBQXdCLEtBQUtxMEIsWUFBN0IsRUFBMkMsS0FBS0UsYUFBaEQ7OztRQUdGLE9BQU90c0csR0FBUCxnakJBR2UsS0FBS21zRyxNQUhwQixFQUlnQixLQUFLRSxPQUpyQixFQU1nQixLQUFLRSxTQU5yQixFQVdpQixLQUFLSCxZQVh0QixFQVlrQixLQUFLRSxhQVp2QixFQWFxQixLQUFLM3JFLFFBYjFCLEVBbUJnQixVQUFBMWhELENBQUM7VUFBQSxPQUFJQSxDQUFDLENBQUM0aUQsZUFBRixFQUFKO1NBbkJqQixFQW9Ca0IsS0FBSzhZLElBcEJ2Qjs7OzthQTBCRixtQkFBVTE3RCxDQUFWLEVBQWE7O1FBRVgsSUFBSUEsQ0FBQyxDQUFDcTZGLE9BQUYsSUFBYXI2RixDQUFDLENBQUNzNkYsUUFBbkIsRUFBNkI7VUFDM0J0NkYsQ0FBQyxDQUFDODlDLGNBQUY7O1VBRUEsSUFBSTk5QyxDQUFDLENBQUNILEdBQUYsS0FBVSxHQUFkLEVBQW1CO1lBQ2pCLEtBQUtvdEgsVUFBTCxDQUFnQmxKLGFBQWhCO1dBSnlCOzs7Ozs7O2FBVy9CLGNBQUsvakgsQ0FBTCxFQUFRO1FBQ04sS0FBS3NtRCxNQUFMLEdBQWMsS0FBSzJtRSxVQUFMLENBQWdCaDZCLFFBQWhCLEVBQWQ7UUFFQSxJQUFNM25FLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEI7VUFDdENDLE9BQU8sRUFBRSxJQUQ2QjtVQUV0Q0MsUUFBUSxFQUFFLElBRjRCO1VBR3RDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBSzBrRDs7U0FIVixDQUFkO1FBTUEsS0FBS3ltRSxRQUFMO1FBQ0EsS0FBS2h0RSxhQUFMLENBQW1CejBCLEtBQW5COzs7O2FBR0Ysd0JBQWU7UUFBQTs7UUFDYixLQUFLcThCLFVBQUwsR0FBa0IsS0FBS3pPLFVBQUwsQ0FBZ0IwTyxhQUFoQixDQUE4QixLQUE5QixDQUFsQjtRQUNBLEtBQUsybEUsY0FBTCxHQUFzQixLQUFLcjBFLFVBQUwsQ0FBZ0IwTyxhQUFoQixDQUE4QixpQkFBOUIsQ0FBdEI7UUFFQSxLQUFLcWxFLFVBQUwsR0FBa0I5MkIsVUFBVSxDQUFDLEtBQUtvM0IsY0FBTixFQUFzQjtVQUNoRDNySCxLQUFLLEVBQUUsS0FBSzBrRCxNQURvQzs7VUFFaEQxakQsSUFBSSxFQUFFLFlBRjBDO1VBR2hEKytDLEtBQUssRUFBRSxTQUh5QztVQUloRHNvQixXQUFXLEVBQUUsSUFKbUM7VUFLaEQ3YyxPQUFPLEVBQUUsQ0FMdUM7VUFNaEQ0ckMsTUFBTSxFQUFFO1NBTmtCLENBQTVCLENBSmE7O1FBY2IsS0FBS2kwQixVQUFMLENBQWdCSCxZQUFoQixHQUErQixJQUEvQixDQWRhOztRQWlCYixLQUFLRyxVQUFMLENBQWdCbjBCLE9BQWhCLENBQXdCLEtBQUtxMEIsWUFBN0IsRUFBMkMsS0FBS0UsYUFBaEQsRUFqQmE7O1FBb0JiLEtBQUtKLFVBQUwsQ0FBZ0J4akIsU0FBaEIsQ0FBMEIsV0FBMUIsRUFBdUM7VUFDckMrakIsR0FBRyxFQUFFLGFBQVNyNkQsRUFBVCxFQUFhO1lBQ2hCLElBQUluaEQsTUFBTSxHQUFHLEVBQWI7O1lBQ0EsS0FBSyxJQUFJaE0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR210RCxFQUFFLENBQUMyUixTQUFILENBQWEsWUFBYixDQUFwQixFQUFnRDkrRCxDQUFDLEVBQWpELEVBQXFEO2NBQ25EZ00sTUFBTSxJQUFJLEdBQVY7OztZQUdGbWhELEVBQUUsQ0FBQzRnQyxnQkFBSCxDQUFvQi9oRixNQUFwQjs7U0FQSixFQXBCYTs7UUFnQ2IsS0FBS2k3RyxVQUFMLENBQWdCeDZELEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLFlBQU07VUFDakMsSUFBSSxDQUFDLE1BQUksQ0FBQ3c2RCxVQUFMLENBQWdCdmpCLE1BQWhCLEdBQXlCOVUsT0FBekIsRUFBTCxFQUF5QztZQUN2QyxNQUFJLENBQUNqdEMsVUFBTCxDQUFnQmxELFNBQWhCLENBQTBCNXhCLEdBQTFCLENBQThCLE9BQTlCOztTQUZKOzs7O2FBT0Ysb0JBQVc7UUFDVCxLQUFLbzZGLFVBQUwsQ0FBZ0J2akIsTUFBaEIsR0FBeUJqVixTQUF6QjtRQUNBLEtBQUs5c0MsVUFBTCxDQUFnQmxELFNBQWhCLENBQTBCM1UsTUFBMUIsQ0FBaUMsT0FBakM7Ozs7V0FwTkYsZUFBd0I7UUFDdEIsT0FBTztVQUNMc1AsTUFBTSxFQUFFO1lBQ05oN0MsSUFBSSxFQUFFaVE7V0FGSDtVQUlMNnFDLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBTEg7VUFPTHF0QyxRQUFRLEVBQUU7WUFDUnQ5QyxJQUFJLEVBQUVpUSxNQURFO1lBRVI4SSxTQUFTLEVBQUU7V0FUUjtVQVdMdmIsS0FBSyxFQUFFO1lBQ0x3QyxJQUFJLEVBQUVYOztTQVpWOzs7O1dBaUJGLGVBQW9COzs7UUFHbEIsT0FBTzZ5QyxHQUFQLHV0QkFRd0JxTCxLQUFLLENBQUMsbUJBQUQsQ0FSN0IsRUFTNkJBLEtBQUssQ0FBQyxtQkFBRCxDQVRsQyxFQVdpQkQsUUFYakIsRUFlNkJDLEtBQUssQ0FBQyxxQkFBRCxDQWZsQyxFQXNCSThyRSxRQXRCSixFQXVCSUMsWUF2QkosRUF3QklDLFdBeEJKOzs7OztJQXRCbUJ2d0U7O0VBeU52QnlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLFdBQXRCLEVBQW1Db25HLFFBQW5DOztFQzNQQTs7Ozs7Ozs7Ozs7OztFQWdCQSxJQUFNWSxVQUFVLEdBQUcsSUFBSWw1RixPQUFKLEVBQW5CO0VBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBLEVBQU8sSUFBTW12QixTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUE2QjNoRCxDQUE3QjtJQUFBLE9BQ3BCLFlBQXVCO01BQ3RCLElBQU02YyxDQUFDLEdBQUc3YyxDQUFDLE1BQUQsbUJBQVY7TUFDQTBySCxVQUFVLENBQUMvL0csR0FBWCxDQUFla1IsQ0FBZixFQUFrQixJQUFsQjtNQUNBLE9BQU9BLENBQVA7S0FKbUI7RUFBQSxDQUFsQjtBQU9QLEVBQU8sSUFBTTh1RyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFDeHVGLENBQUQsRUFBaUM7SUFDMUQsT0FBTyxPQUFPQSxDQUFQLEtBQWEsVUFBYixJQUEyQnV1RixVQUFVLENBQUN0cUgsR0FBWCxDQUFlKzdCLENBQWYsQ0FBbEM7RUFDRCxDQUZNOztFQ3RFUDs7Ozs7Ozs7Ozs7Ozs7RUFrQkE7OztBQUdBLEVBQU8sSUFBTXl1RixZQUFZLEdBQUcsT0FBT3h1SCxNQUFQLEtBQWtCLFdBQWxCLElBQ3hCQSxNQUFNLENBQUN1aEQsY0FBUCxJQUF5QixJQURELElBRXZCdmhELE1BQU0sQ0FBQ3VoRCxjQUFQLENBQTRDa3RFLHlCQUE1QyxLQUNHdnJILFNBSEQ7QUFLUCxFQWlCQTs7Ozs7QUFJQSxFQUFPLElBQU13ckgsV0FBVyxHQUNwQixTQURTQSxXQUNULENBQUMvL0UsU0FBRCxFQUFrQi9zQixLQUFsQixFQUFtRTtJQUFBLElBQS9CekUsR0FBK0IsdUVBQWQsSUFBYzs7SUFDakUsT0FBT3lFLEtBQUssS0FBS3pFLEdBQWpCLEVBQXNCO01BQ3BCLElBQU1yTCxDQUFDLEdBQUc4UCxLQUFNLENBQUMweEIsV0FBakI7TUFDQTNFLFNBQVMsQ0FBQ2xpQixXQUFWLENBQXNCN0ssS0FBdEI7TUFDQUEsS0FBSyxHQUFHOVAsQ0FBUjs7RUFFSCxDQVBFOztFQy9DUDs7Ozs7Ozs7Ozs7Ozs7RUF3Q0E7Ozs7QUFJQSxFQUFPLElBQU13OEIsUUFBUSxHQUFHLEVBQWpCO0VBRVA7Ozs7QUFHQSxFQUFPLElBQU1FLE9BQU8sR0FBRyxFQUFoQjs7RUNqRFA7Ozs7Ozs7Ozs7Ozs7O0VBZ0JBOzs7O0FBSUEsRUFBTyxJQUFNbkIsTUFBTSxtQkFBWWxwQyxNQUFNLENBQUNsRSxJQUFJLENBQUMrQyxNQUFMLEVBQUQsQ0FBTixDQUFzQitFLEtBQXRCLENBQTRCLENBQTVCLENBQVosT0FBWjtFQUVQOzs7OztBQUlBLEVBQU8sSUFBTXdsQyxVQUFVLGlCQUFVRixNQUFWLFFBQWhCO0FBRVAsRUFFQTs7OztBQUdBLEVBQU8sSUFBTXNoRixvQkFBb0IsR0FBRyxPQUE3QjtBQUVQO0FBeUxBLEVBQU8sSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDNy9FLElBQUQ7SUFBQSxPQUF3QkEsSUFBSSxDQUFDcm1DLEtBQUwsS0FBZSxDQUFDLENBQXhDO0VBQUEsQ0FBN0I7RUFHUDs7QUFDQSxFQUFPLElBQU04a0MsWUFBWSxHQUFHLFNBQWZBLFlBQWU7SUFBQSxPQUFNbnNDLFFBQVEsQ0FBQ29zQyxhQUFULENBQXVCLEVBQXZCLENBQU47RUFBQSxDQUFyQjtFQUVQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsRUFBTyxJQUFNb2hGLHNCQUFzQjtFQUUvQiw0SUFGRzs7RUN4T1A7Ozs7O0FBSUEsTUFBYXI4RSxnQkFBYjtJQU1FLDBCQUNJQyxRQURKLEVBQ3dCcThFLFNBRHhCLEVBRUlsZ0YsT0FGSixFQUUwQjtNQUFBOztNQVBULGVBQWlDLEVBQWpDO01BUWYsS0FBSzZELFFBQUwsR0FBZ0JBLFFBQWhCO01BQ0EsS0FBS3E4RSxTQUFMLEdBQWlCQSxTQUFqQjtNQUNBLEtBQUtsZ0YsT0FBTCxHQUFlQSxPQUFmOzs7SUFYSjtNQUFBO01BQUEsT0FjRSxnQkFBT256QixNQUFQLEVBQWlDO1FBQy9CLElBQUkvVSxDQUFDLEdBQUcsQ0FBUjs7UUFEK0IsMkNBRVosS0FBS3FvSCxPQUZPOzs7UUFBQTtVQUUvQixvREFBaUM7WUFBQSxJQUF0QmhnRixJQUFzQjs7WUFDL0IsSUFBSUEsSUFBSSxLQUFLN3JDLFNBQWIsRUFBd0I7Y0FDdEI2ckMsSUFBSSxDQUFDOGtELFFBQUwsQ0FBY3A0RSxNQUFNLENBQUMvVSxDQUFELENBQXBCOzs7WUFFRkEsQ0FBQzs7O1VBTjRCOztVQUFBOzs7UUFBQSw0Q0FRWixLQUFLcW9ILE9BUk87OztRQUFBO1VBUS9CLHVEQUFpQztZQUFBLElBQXRCaGdGLEtBQXNCOztZQUMvQixJQUFJQSxLQUFJLEtBQUs3ckMsU0FBYixFQUF3QjtjQUN0QjZyQyxLQUFJLENBQUNpZ0YsTUFBTDs7OztVQVYyQjs7VUFBQTs7OztNQWRuQztNQUFBLE9BNkJFLGtCQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXVDSixJQUFNLzdFLFFBQVEsR0FBR3U3RSxZQUFZLEdBQ3pCLEtBQUsvN0UsUUFBTCxDQUFjdlAsT0FBZCxDQUFzQm1OLE9BQXRCLENBQThCd2lELFNBQTlCLENBQXdDLElBQXhDLENBRHlCLEdBRXpCeHhGLFFBQVEsQ0FBQzh4QyxVQUFULENBQW9CLEtBQUtWLFFBQUwsQ0FBY3ZQLE9BQWQsQ0FBc0JtTixPQUExQyxFQUFtRCxJQUFuRCxDQUZKO1FBSUEsSUFBTTh3RSxLQUFLLEdBQVcsRUFBdEI7UUFDQSxJQUFNbnhFLEtBQUssR0FBRyxLQUFLeUMsUUFBTCxDQUFjekMsS0FBNUIsQ0E1Q0k7O1FBOENKLElBQU1YLE1BQU0sR0FBR2h1QyxRQUFRLENBQUNpdUMsZ0JBQVQsQ0FDWDJELFFBRFcsRUFFWDs7VUFDQSxJQUhXLEVBSVgsS0FKVyxDQUFmO1FBS0EsSUFBSUcsU0FBUyxHQUFHLENBQWhCO1FBQ0EsSUFBSW5ELFNBQVMsR0FBRyxDQUFoQjtRQUNBLElBQUlsQixJQUFKO1FBQ0EsSUFBSWxoQixJQUFJLEdBQUd3aEIsTUFBTSxDQUFDc0IsUUFBUCxFQUFYLENBdERJOztRQXdESixPQUFPeUMsU0FBUyxHQUFHcEQsS0FBSyxDQUFDMXJDLE1BQXpCLEVBQWlDO1VBQy9CeXFDLElBQUksR0FBR2lCLEtBQUssQ0FBQ29ELFNBQUQsQ0FBWjs7VUFDQSxJQUFJLENBQUN3N0Usb0JBQW9CLENBQUM3L0UsSUFBRCxDQUF6QixFQUFpQztZQUMvQixLQUFLZ2dGLE9BQUwsQ0FBYTFySCxJQUFiLENBQWtCSCxTQUFsQjs7WUFDQWt3QyxTQUFTO1lBQ1Q7V0FMNkI7Ozs7O1VBVy9CLE9BQU9uRCxTQUFTLEdBQUdsQixJQUFJLENBQUNybUMsS0FBeEIsRUFBK0I7WUFDN0J1bkMsU0FBUzs7WUFDVCxJQUFJcGlCLElBQUssQ0FBQ20yRCxRQUFOLEtBQW1CLFVBQXZCLEVBQW1DO2NBQ2pDbTlCLEtBQUssQ0FBQzk5RyxJQUFOLENBQVd3cUIsSUFBWDtjQUNBd2hCLE1BQU0sQ0FBQ2UsV0FBUCxHQUFzQnZpQixJQUE0QixDQUFDd2lCLE9BQW5EOzs7WUFFRixJQUFJLENBQUN4aUIsSUFBSSxHQUFHd2hCLE1BQU0sQ0FBQ3NCLFFBQVAsRUFBUixNQUErQixJQUFuQyxFQUF5Qzs7Ozs7Y0FLdkN0QixNQUFNLENBQUNlLFdBQVAsR0FBcUIrd0UsS0FBSyxDQUFDNzFFLEdBQU4sRUFBckI7Y0FDQXpkLElBQUksR0FBR3doQixNQUFNLENBQUNzQixRQUFQLEVBQVA7O1dBdkIyQjs7O1VBNEIvQixJQUFJNUIsSUFBSSxDQUFDanFDLElBQUwsS0FBYyxNQUFsQixFQUEwQjtZQUN4QixJQUFNaXFDLE1BQUksR0FBRyxLQUFLKy9FLFNBQUwsQ0FBZUcsb0JBQWYsQ0FBb0MsS0FBS3JnRixPQUF6QyxDQUFiOztZQUNBRyxNQUFJLENBQUNtZ0YsZUFBTCxDQUFxQnJoRyxJQUFLLENBQUNxaUYsZUFBM0I7O1lBQ0EsS0FBSzZlLE9BQUwsQ0FBYTFySCxJQUFiLENBQWtCMHJDLE1BQWxCO1dBSEYsTUFJTztZQUFBOztZQUNMLHNCQUFLZ2dGLE9BQUwsRUFBYTFySCxJQUFiLHlDQUFxQixLQUFLeXJILFNBQUwsQ0FBZUssMEJBQWYsQ0FDakJ0aEcsSUFEaUIsRUFDQWtoQixJQUFJLENBQUNocUMsSUFETCxFQUNXZ3FDLElBQUksQ0FBQ1osT0FEaEIsRUFDeUIsS0FBS1MsT0FEOUIsQ0FBckI7OztVQUdGd0UsU0FBUzs7O1FBR1gsSUFBSW83RSxZQUFKLEVBQWtCO1VBQ2hCbnRILFFBQVEsQ0FBQyt0SCxTQUFULENBQW1CbjhFLFFBQW5CO1VBQ0FzTyxjQUFjLENBQUM4dEUsT0FBZixDQUF1QnA4RSxRQUF2Qjs7O1FBRUYsT0FBT0EsUUFBUDs7OztJQWhJSjtFQUFBOztFQ0RBOzs7Ozs7Ozs7RUFRQSxJQUFNOUYsTUFBTSxHQUFHbnRDLE1BQU0sQ0FBQ2t0QyxZQUFQLElBQ1hBLFlBQWEsQ0FBQ0UsWUFBZCxDQUEyQixVQUEzQixFQUF1QztJQUFDeHZCLFVBQVUsRUFBRSxvQkFBQzNILENBQUQ7TUFBQSxPQUFPQSxDQUFQOztFQUFiLENBQXZDLENBREo7RUFHQSxJQUFNcTVHLGFBQWEsY0FBT2ppRixNQUFQLE1BQW5CO0VBRUE7Ozs7O0FBSUEsTUFBYWtpRixjQUFiO0lBTUUsd0JBQ0lwaEYsT0FESixFQUNtQzF5QixNQURuQyxFQUMrRDNXLElBRC9ELEVBRUlncUgsU0FGSixFQUVnQztNQUFBOztNQUM5QixLQUFLM2dGLE9BQUwsR0FBZUEsT0FBZjtNQUNBLEtBQUsxeUIsTUFBTCxHQUFjQSxNQUFkO01BQ0EsS0FBSzNXLElBQUwsR0FBWUEsSUFBWjtNQUNBLEtBQUtncUgsU0FBTCxHQUFpQkEsU0FBakI7Ozs7Ozs7SUFaSjtNQUFBO01BQUEsT0FrQkUsbUJBQU87UUFDTCxJQUFNaGhILENBQUMsR0FBRyxLQUFLcWdDLE9BQUwsQ0FBYTdwQyxNQUFiLEdBQXNCLENBQWhDO1FBQ0EsSUFBSW1kLElBQUksR0FBRyxFQUFYO1FBQ0EsSUFBSSt0RyxnQkFBZ0IsR0FBRyxLQUF2Qjs7UUFFQSxLQUFLLElBQUk5b0gsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29ILENBQXBCLEVBQXVCcEgsQ0FBQyxFQUF4QixFQUE0QjtVQUMxQixJQUFNdVAsQ0FBQyxHQUFHLEtBQUtrNEIsT0FBTCxDQUFhem5DLENBQWIsQ0FBVixDQUQwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBbUIxQixJQUFNK29ILFdBQVcsR0FBR3g1RyxDQUFDLENBQUM4TixXQUFGLENBQWMsTUFBZCxDQUFwQixDQW5CMEI7Ozs7VUF1QjFCeXJHLGdCQUFnQixHQUFHLENBQUNDLFdBQVcsR0FBRyxDQUFDLENBQWYsSUFBb0JELGdCQUFyQixLQUNmdjVHLENBQUMsQ0FBQ3NILE9BQUYsQ0FBVSxLQUFWLEVBQWlCa3lHLFdBQVcsR0FBRyxDQUEvQixNQUFzQyxDQUFDLENBRDNDLENBdkIwQjs7OztVQTRCMUIsSUFBTUMsY0FBYyxHQUFHYixzQkFBc0IsQ0FBQ3B1SCxJQUF2QixDQUE0QndWLENBQTVCLENBQXZCOztVQUNBLElBQUl5NUcsY0FBYyxLQUFLLElBQXZCLEVBQTZCOzs7Ozs7WUFNM0JqdUcsSUFBSSxJQUFJeEwsQ0FBQyxJQUFJdTVHLGdCQUFnQixHQUFHRixhQUFILEdBQW1CL2hGLFVBQXZDLENBQVQ7V0FORixNQU9POzs7O1lBSUw5ckIsSUFBSSxJQUFJeEwsQ0FBQyxDQUFDdWpELE1BQUYsQ0FBUyxDQUFULEVBQVlrMkQsY0FBYyxDQUFDaG5ILEtBQTNCLElBQW9DZ25ILGNBQWMsQ0FBQyxDQUFELENBQWxELEdBQ0pBLGNBQWMsQ0FBQyxDQUFELENBRFYsR0FDZ0JmLG9CQURoQixHQUN1Q2UsY0FBYyxDQUFDLENBQUQsQ0FEckQsR0FFSnJpRixNQUZKOzs7O1FBS0o1ckIsSUFBSSxJQUFJLEtBQUswc0IsT0FBTCxDQUFhcmdDLENBQWIsQ0FBUjtRQUNBLE9BQU8yVCxJQUFQOzs7TUFyRUo7TUFBQSxPQXdFRSw4QkFBa0I7UUFDaEIsSUFBTWd4QixRQUFRLEdBQUdweEMsUUFBUSxDQUFDRSxhQUFULENBQXVCLFVBQXZCLENBQWpCO1FBQ0EsSUFBSWUsS0FBSyxHQUFHLEtBQUtxdEgsT0FBTCxFQUFaOztRQUNBLElBQUl4aUYsTUFBTSxLQUFLanFDLFNBQWYsRUFBMEI7Ozs7O1VBS3hCWixLQUFLLEdBQUc2cUMsTUFBTSxDQUFDdnZCLFVBQVAsQ0FBa0J0YixLQUFsQixDQUFSOzs7UUFFRm13QyxRQUFRLENBQUNaLFNBQVQsR0FBcUJ2dkMsS0FBckI7UUFDQSxPQUFPbXdDLFFBQVA7Ozs7SUFuRko7RUFBQTs7RUNoQk8sSUFBTS9FLFdBQVcsR0FBRyxTQUFkQSxXQUFjLENBQUNwckMsS0FBRCxFQUF1QztJQUNoRSxPQUNJQSxLQUFLLEtBQUssSUFBVixJQUNBLEVBQUUsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFQLEtBQWlCLFVBQWhELENBRko7RUFHRCxDQUpNO0FBS1AsRUFBTyxJQUFNcXJDLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUNyckMsS0FBRCxFQUErQztJQUN2RSxPQUFPMkgsS0FBSyxDQUFDQyxPQUFOLENBQWM1SCxLQUFkO0lBRUgsQ0FBQyxFQUFFQSxLQUFLLElBQUtBLEtBQWEsQ0FBQzZFLE1BQU0sQ0FBQ3VHLFFBQVIsQ0FBekIsQ0FGTDtFQUdELENBSk07RUFNUDs7Ozs7O0FBS0EsTUFBYWtpSCxrQkFBYjtJQU9FLDRCQUFZMXNGLE9BQVosRUFBOEJuK0IsSUFBOUIsRUFBNENvcEMsT0FBNUMsRUFBMEU7TUFBQTs7TUFGMUUsYUFBUSxJQUFSO01BR0UsS0FBS2pMLE9BQUwsR0FBZUEsT0FBZjtNQUNBLEtBQUtuK0IsSUFBTCxHQUFZQSxJQUFaO01BQ0EsS0FBS29wQyxPQUFMLEdBQWVBLE9BQWY7TUFDQSxLQUFLNkIsS0FBTCxHQUFhLEVBQWI7O01BQ0EsS0FBSyxJQUFJdHBDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5bkMsT0FBTyxDQUFDN3BDLE1BQVIsR0FBaUIsQ0FBckMsRUFBd0NvQyxDQUFDLEVBQXpDLEVBQTZDO1FBQzFDLEtBQUtzcEMsS0FBTCxDQUErQnRwQyxDQUEvQixJQUFvQyxLQUFLbXBILFdBQUwsRUFBcEM7Ozs7Ozs7O0lBYlA7TUFBQTtNQUFBLE9Bb0JZLHVCQUFXO1FBQ25CLE9BQU8sSUFBSXYrRSxhQUFKLENBQWtCLElBQWxCLENBQVA7OztNQXJCSjtNQUFBLE9Bd0JZLHFCQUFTO1FBQ2pCLElBQU1uRCxPQUFPLEdBQUcsS0FBS0EsT0FBckI7UUFDQSxJQUFNcmdDLENBQUMsR0FBR3FnQyxPQUFPLENBQUM3cEMsTUFBUixHQUFpQixDQUEzQjtRQUNBLElBQU0wckMsS0FBSyxHQUFHLEtBQUtBLEtBQW5CLENBSGlCOzs7Ozs7Ozs7Ozs7OztRQWtCakIsSUFBSWxpQyxDQUFDLEtBQUssQ0FBTixJQUFXcWdDLE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZSxFQUExQixJQUFnQ0EsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQW5ELEVBQXVEO1VBQ3JELElBQU0xZixDQUFDLEdBQUd1aEIsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMXRDLEtBQW5COztVQUNBLElBQUksT0FBT21zQixDQUFQLEtBQWEsUUFBakIsRUFBMkI7WUFDekIsT0FBT3RxQixNQUFNLENBQUNzcUIsQ0FBRCxDQUFiOzs7VUFFRixJQUFJLE9BQU9BLENBQVAsS0FBYSxRQUFiLElBQXlCLENBQUNrZixVQUFVLENBQUNsZixDQUFELENBQXhDLEVBQTZDO1lBQzNDLE9BQU9BLENBQVA7Ozs7UUFHSixJQUFJaTBCLElBQUksR0FBRyxFQUFYOztRQUVBLEtBQUssSUFBSWg4QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb0gsQ0FBcEIsRUFBdUJwSCxDQUFDLEVBQXhCLEVBQTRCO1VBQzFCZzhDLElBQUksSUFBSXZVLE9BQU8sQ0FBQ3puQyxDQUFELENBQWY7VUFDQSxJQUFNcW9DLElBQUksR0FBR2lCLEtBQUssQ0FBQ3RwQyxDQUFELENBQWxCOztVQUNBLElBQUlxb0MsSUFBSSxLQUFLN3JDLFNBQWIsRUFBd0I7WUFDdEIsSUFBTXVyQixFQUFDLEdBQUdzZ0IsSUFBSSxDQUFDenNDLEtBQWY7O1lBQ0EsSUFBSW9yQyxXQUFXLENBQUNqZixFQUFELENBQVgsSUFBa0IsQ0FBQ2tmLFVBQVUsQ0FBQ2xmLEVBQUQsQ0FBakMsRUFBc0M7Y0FDcENpMEIsSUFBSSxJQUFJLE9BQU9qMEIsRUFBUCxLQUFhLFFBQWIsR0FBd0JBLEVBQXhCLEdBQTRCdHFCLE1BQU0sQ0FBQ3NxQixFQUFELENBQTFDO2FBREYsTUFFTztjQUFBLDJDQUNXQSxFQURYOzs7Y0FBQTtnQkFDTCxvREFBbUI7a0JBQUEsSUFBUnZZLENBQVE7a0JBQ2pCd3NDLElBQUksSUFBSSxPQUFPeHNDLENBQVAsS0FBYSxRQUFiLEdBQXdCQSxDQUF4QixHQUE0Qi9SLE1BQU0sQ0FBQytSLENBQUQsQ0FBMUM7OztnQkFGRzs7Z0JBQUE7Ozs7OztRQVFYd3NDLElBQUksSUFBSXZVLE9BQU8sQ0FBQ3JnQyxDQUFELENBQWY7UUFDQSxPQUFPNDBDLElBQVA7OztNQXJFSjtNQUFBLE9Bd0VFLGtCQUFNO1FBQ0osSUFBSSxLQUFLb3pCLEtBQVQsRUFBZ0I7VUFDZCxLQUFLQSxLQUFMLEdBQWEsS0FBYjtVQUNBLEtBQUs1eUMsT0FBTCxDQUFhZ1MsWUFBYixDQUEwQixLQUFLbndDLElBQS9CLEVBQXFDLEtBQUsrcUgsU0FBTCxFQUFyQzs7Ozs7SUEzRU47RUFBQTtFQWdGQTs7OztBQUdBLE1BQWF4K0UsYUFBYjtJQUlFLHVCQUFZeStFLFNBQVosRUFBeUM7TUFBQTs7TUFGekMsYUFBaUI3c0gsU0FBakI7TUFHRSxLQUFLNnNILFNBQUwsR0FBaUJBLFNBQWpCOzs7SUFMSjtNQUFBO01BQUEsT0FRRSxrQkFBU3p0SCxLQUFULEVBQXVCO1FBQ3JCLElBQUlBLEtBQUssS0FBS2dzQyxRQUFWLEtBQXVCLENBQUNaLFdBQVcsQ0FBQ3ByQyxLQUFELENBQVosSUFBdUJBLEtBQUssS0FBSyxLQUFLQSxLQUE3RCxDQUFKLEVBQXlFO1VBQ3ZFLEtBQUtBLEtBQUwsR0FBYUEsS0FBYixDQUR1RTs7OztVQUt2RSxJQUFJLENBQUNpc0gsV0FBVyxDQUFDanNILEtBQUQsQ0FBaEIsRUFBeUI7WUFDdkIsS0FBS3l0SCxTQUFMLENBQWVqNkMsS0FBZixHQUF1QixJQUF2Qjs7Ozs7TUFmUjtNQUFBLE9Bb0JFLGtCQUFNO1FBQ0osT0FBT3k0QyxXQUFXLENBQUMsS0FBS2pzSCxLQUFOLENBQWxCLEVBQWdDO1VBQzlCLElBQU1paUQsU0FBUyxHQUFHLEtBQUtqaUQsS0FBdkI7VUFDQSxLQUFLQSxLQUFMLEdBQWFnc0MsUUFBYjtVQUNBaVcsU0FBUyxDQUFDLElBQUQsQ0FBVDs7O1FBRUYsSUFBSSxLQUFLamlELEtBQUwsS0FBZWdzQyxRQUFuQixFQUE2QjtVQUMzQjs7O1FBRUYsS0FBS3loRixTQUFMLENBQWVmLE1BQWY7Ozs7SUE3Qko7RUFBQTtFQWlDQTs7Ozs7Ozs7O0FBUUEsTUFBYWdCLFFBQWI7SUFPRSxrQkFBWXBoRixPQUFaLEVBQWtDO01BQUE7O01BSGxDLGFBQWlCMXJDLFNBQWpCO01BQ1Esc0JBQTBCQSxTQUExQjtNQUdOLEtBQUswckMsT0FBTCxHQUFlQSxPQUFmOzs7Ozs7Ozs7SUFSSjtNQUFBO01BQUEsT0FnQkUsb0JBQVdELFNBQVgsRUFBMEI7UUFDeEIsS0FBSzhFLFNBQUwsR0FBaUI5RSxTQUFTLENBQUM1akMsV0FBVixDQUFzQnlpQyxZQUFZLEVBQWxDLENBQWpCO1FBQ0EsS0FBS3lCLE9BQUwsR0FBZU4sU0FBUyxDQUFDNWpDLFdBQVYsQ0FBc0J5aUMsWUFBWSxFQUFsQyxDQUFmOzs7Ozs7Ozs7OztNQWxCSjtNQUFBLE9BNEJFLHlCQUFnQjhHLEdBQWhCLEVBQXlCO1FBQ3ZCLEtBQUtiLFNBQUwsR0FBaUJhLEdBQWpCO1FBQ0EsS0FBS3JGLE9BQUwsR0FBZXFGLEdBQUcsQ0FBQ2hCLFdBQW5COzs7Ozs7Ozs7TUE5Qko7TUFBQSxPQXNDRSx3QkFBZXZFLElBQWYsRUFBNkI7UUFDM0JBLElBQUksQ0FBQ2toRixRQUFMLENBQWMsS0FBS3g4RSxTQUFMLEdBQWlCakcsWUFBWSxFQUEzQzs7UUFDQXVCLElBQUksQ0FBQ2toRixRQUFMLENBQWMsS0FBS2hoRixPQUFMLEdBQWV6QixZQUFZLEVBQXpDOzs7Ozs7Ozs7TUF4Q0o7TUFBQSxPQWdERSx5QkFBZ0I4RyxHQUFoQixFQUE2QjtRQUMzQkEsR0FBRyxDQUFDMjdFLFFBQUosQ0FBYSxLQUFLeDhFLFNBQUwsR0FBaUJqRyxZQUFZLEVBQTFDOztRQUNBLEtBQUt5QixPQUFMLEdBQWVxRixHQUFHLENBQUNyRixPQUFuQjtRQUNBcUYsR0FBRyxDQUFDckYsT0FBSixHQUFjLEtBQUt3RSxTQUFuQjs7O01BbkRKO01BQUEsT0FzREUsa0JBQVNueEMsS0FBVCxFQUF1QjtRQUNyQixLQUFLNHRILGNBQUwsR0FBc0I1dEgsS0FBdEI7OztNQXZESjtNQUFBLE9BMERFLGtCQUFNO1FBQ0osSUFBSSxLQUFLbXhDLFNBQUwsQ0FBZVgsVUFBZixLQUE4QixJQUFsQyxFQUF3QztVQUN0Qzs7O1FBRUYsT0FBT3k3RSxXQUFXLENBQUMsS0FBSzJCLGNBQU4sQ0FBbEIsRUFBeUM7VUFDdkMsSUFBTTNyRSxTQUFTLEdBQUcsS0FBSzJyRSxjQUF2QjtVQUNBLEtBQUtBLGNBQUwsR0FBc0I1aEYsUUFBdEI7VUFDQWlXLFNBQVMsQ0FBQyxJQUFELENBQVQ7OztRQUVGLElBQU1qaUQsS0FBSyxHQUFHLEtBQUs0dEgsY0FBbkI7O1FBQ0EsSUFBSTV0SCxLQUFLLEtBQUtnc0MsUUFBZCxFQUF3QjtVQUN0Qjs7O1FBRUYsSUFBSVosV0FBVyxDQUFDcHJDLEtBQUQsQ0FBZixFQUF3QjtVQUN0QixJQUFJQSxLQUFLLEtBQUssS0FBS0EsS0FBbkIsRUFBMEI7WUFDeEIsS0FBSzZ0SCxZQUFMLENBQWtCN3RILEtBQWxCOztTQUZKLE1BSU8sSUFBSUEsS0FBSyxZQUFZaXRILGNBQXJCLEVBQXFDO1VBQzFDLEtBQUthLHNCQUFMLENBQTRCOXRILEtBQTVCO1NBREssTUFFQSxJQUFJQSxLQUFLLFlBQVkrdEgsSUFBckIsRUFBMkI7VUFDaEMsS0FBS0MsWUFBTCxDQUFrQmh1SCxLQUFsQjtTQURLLE1BRUEsSUFBSXFyQyxVQUFVLENBQUNyckMsS0FBRCxDQUFkLEVBQXVCO1VBQzVCLEtBQUtpdUgsZ0JBQUwsQ0FBc0JqdUgsS0FBdEI7U0FESyxNQUVBLElBQUlBLEtBQUssS0FBS2tzQyxPQUFkLEVBQXVCO1VBQzVCLEtBQUtsc0MsS0FBTCxHQUFha3NDLE9BQWI7VUFDQSxLQUFLN2hCLEtBQUw7U0FGSyxNQUdBOztVQUVMLEtBQUt3akcsWUFBTCxDQUFrQjd0SCxLQUFsQjs7OztNQXRGTjtNQUFBLE9BMEZVLGtCQUFTdXJCLElBQVQsRUFBbUI7UUFDekIsS0FBS29oQixPQUFMLENBQWE2RCxVQUFiLENBQXlCM0QsWUFBekIsQ0FBc0N0aEIsSUFBdEMsRUFBNEMsS0FBS29oQixPQUFqRDs7O01BM0ZKO01BQUEsT0E4RlUsc0JBQWEzc0MsS0FBYixFQUF3QjtRQUM5QixJQUFJLEtBQUtBLEtBQUwsS0FBZUEsS0FBbkIsRUFBMEI7VUFDeEI7OztRQUVGLEtBQUtxcUIsS0FBTDs7UUFDQSxLQUFLc2pHLFFBQUwsQ0FBYzN0SCxLQUFkOztRQUNBLEtBQUtBLEtBQUwsR0FBYUEsS0FBYjs7O01BcEdKO01BQUEsT0F1R1Usc0JBQWFBLEtBQWIsRUFBMkI7UUFDakMsSUFBTXVyQixJQUFJLEdBQUcsS0FBSzRsQixTQUFMLENBQWVILFdBQTVCO1FBQ0FoeEMsS0FBSyxHQUFHQSxLQUFLLElBQUksSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBN0IsQ0FGaUM7OztRQUtqQyxJQUFNa3VILGFBQWEsR0FDZixPQUFPbHVILEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQW9DNkIsTUFBTSxDQUFDN0IsS0FBRCxDQUQ5Qzs7UUFFQSxJQUFJdXJCLElBQUksS0FBSyxLQUFLb2hCLE9BQUwsQ0FBYWloRSxlQUF0QixJQUNBcmlGLElBQUksQ0FBQytpQixRQUFMLEtBQWtCOztVQUF3Qjs7OztVQUkzQy9pQixJQUFhLENBQUNuWSxJQUFkLEdBQXFCODZHLGFBQXJCO1NBTEgsTUFNTztVQUNMLEtBQUtGLFlBQUwsQ0FBa0JqdkgsUUFBUSxDQUFDeXNCLGNBQVQsQ0FBd0IwaUcsYUFBeEIsQ0FBbEI7OztRQUVGLEtBQUtsdUgsS0FBTCxHQUFhQSxLQUFiOzs7TUF2SEo7TUFBQSxPQTBIVSxnQ0FBdUJBLEtBQXZCLEVBQTRDO1FBQ2xELElBQU1td0MsUUFBUSxHQUFHLEtBQUs3RCxPQUFMLENBQWE2aEYsZUFBYixDQUE2Qm51SCxLQUE3QixDQUFqQjs7UUFDQSxJQUFJLEtBQUtBLEtBQUwsWUFBc0Jrd0MsZ0JBQXRCLElBQ0EsS0FBS2x3QyxLQUFMLENBQVdtd0MsUUFBWCxLQUF3QkEsUUFENUIsRUFDc0M7VUFDcEMsS0FBS253QyxLQUFMLENBQVdrNUMsTUFBWCxDQUFrQmw1QyxLQUFLLENBQUNtWixNQUF4QjtTQUZGLE1BR087Ozs7O1VBS0wsSUFBTStYLFFBQVEsR0FDVixJQUFJZ2YsZ0JBQUosQ0FBcUJDLFFBQXJCLEVBQStCbndDLEtBQUssQ0FBQ3dzSCxTQUFyQyxFQUFnRCxLQUFLbGdGLE9BQXJELENBREo7O1VBRUEsSUFBTXFFLFFBQVEsR0FBR3pmLFFBQVEsQ0FBQ3dmLE1BQVQsRUFBakI7O1VBQ0F4ZixRQUFRLENBQUNnb0IsTUFBVCxDQUFnQmw1QyxLQUFLLENBQUNtWixNQUF0Qjs7VUFDQSxLQUFLNjBHLFlBQUwsQ0FBa0JyOUUsUUFBbEI7O1VBQ0EsS0FBSzN3QyxLQUFMLEdBQWFreEIsUUFBYjs7OztNQXpJTjtNQUFBLE9BNklVLDBCQUFpQmx4QixLQUFqQixFQUF5Qzs7Ozs7Ozs7OztRQVcvQyxJQUFJLENBQUMySCxLQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLNUgsS0FBbkIsQ0FBTCxFQUFnQztVQUM5QixLQUFLQSxLQUFMLEdBQWEsRUFBYjtVQUNBLEtBQUtxcUIsS0FBTDtTQWI2Qzs7OztRQWtCL0MsSUFBTThuQixTQUFTLEdBQUcsS0FBS255QyxLQUF2QjtRQUNBLElBQUk4d0MsU0FBUyxHQUFHLENBQWhCO1FBQ0EsSUFBSXNCLFFBQUo7O1FBcEIrQyw0Q0FzQjVCcHlDLEtBdEI0Qjs7O1FBQUE7VUFzQi9DLHVEQUEwQjtZQUFBLElBQWZxeUMsSUFBZTs7WUFFeEJELFFBQVEsR0FBR0QsU0FBUyxDQUFDckIsU0FBRCxDQUFwQixDQUZ3Qjs7WUFLeEIsSUFBSXNCLFFBQVEsS0FBS3h4QyxTQUFqQixFQUE0QjtjQUMxQnd4QyxRQUFRLEdBQUcsSUFBSXM3RSxRQUFKLENBQWEsS0FBS3BoRixPQUFsQixDQUFYO2NBQ0E2RixTQUFTLENBQUNweEMsSUFBVixDQUFlcXhDLFFBQWY7O2NBQ0EsSUFBSXRCLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtnQkFDbkJzQixRQUFRLENBQUNnOEUsY0FBVCxDQUF3QixJQUF4QjtlQURGLE1BRU87Z0JBQ0xoOEUsUUFBUSxDQUFDaThFLGVBQVQsQ0FBeUJsOEUsU0FBUyxDQUFDckIsU0FBUyxHQUFHLENBQWIsQ0FBbEM7Ozs7WUFHSnNCLFFBQVEsQ0FBQ20vQyxRQUFULENBQWtCbC9DLElBQWxCO1lBQ0FELFFBQVEsQ0FBQ3M2RSxNQUFUO1lBQ0E1N0UsU0FBUzs7O1VBdENvQzs7VUFBQTs7O1FBeUMvQyxJQUFJQSxTQUFTLEdBQUdxQixTQUFTLENBQUNud0MsTUFBMUIsRUFBa0M7O1VBRWhDbXdDLFNBQVMsQ0FBQ253QyxNQUFWLEdBQW1COHVDLFNBQW5CO1VBQ0EsS0FBS3ptQixLQUFMLENBQVcrbkIsUUFBUSxJQUFJQSxRQUFRLENBQUN6RixPQUFoQzs7OztNQXpMTjtNQUFBLE9BNkxFLGlCQUFzQztRQUFBLElBQWhDd0UsU0FBZ0MsdUVBQWQsS0FBS0EsU0FBUztRQUNwQ2k3RSxXQUFXLENBQ1AsS0FBS2o3RSxTQUFMLENBQWVYLFVBRFIsRUFDcUJXLFNBQVMsQ0FBQ0gsV0FEL0IsRUFDNkMsS0FBS3JFLE9BRGxELENBQVg7Ozs7SUE5TEo7RUFBQTtFQW1NQTs7Ozs7Ozs7QUFPQSxNQUFhbUMsb0JBQWI7SUFPRSw4QkFBWWxPLE9BQVosRUFBOEJuK0IsSUFBOUIsRUFBNENvcEMsT0FBNUMsRUFBc0U7TUFBQTs7TUFIdEUsYUFBaUJqckMsU0FBakI7TUFDUSxzQkFBMEJBLFNBQTFCOztNQUdOLElBQUlpckMsT0FBTyxDQUFDN3BDLE1BQVIsS0FBbUIsQ0FBbkIsSUFBd0I2cEMsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQXZDLElBQTZDQSxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsRUFBaEUsRUFBb0U7UUFDbEUsTUFBTSxJQUFJbkUsS0FBSixDQUNGLHlEQURFLENBQU47OztNQUdGLEtBQUs5RyxPQUFMLEdBQWVBLE9BQWY7TUFDQSxLQUFLbitCLElBQUwsR0FBWUEsSUFBWjtNQUNBLEtBQUtvcEMsT0FBTCxHQUFlQSxPQUFmOzs7SUFkSjtNQUFBO01BQUEsT0FpQkUsa0JBQVM3ckMsS0FBVCxFQUF1QjtRQUNyQixLQUFLNHRILGNBQUwsR0FBc0I1dEgsS0FBdEI7OztNQWxCSjtNQUFBLE9BcUJFLGtCQUFNO1FBQ0osT0FBT2lzSCxXQUFXLENBQUMsS0FBSzJCLGNBQU4sQ0FBbEIsRUFBeUM7VUFDdkMsSUFBTTNyRSxTQUFTLEdBQUcsS0FBSzJyRSxjQUF2QjtVQUNBLEtBQUtBLGNBQUwsR0FBc0I1aEYsUUFBdEI7VUFDQWlXLFNBQVMsQ0FBQyxJQUFELENBQVQ7OztRQUVGLElBQUksS0FBSzJyRSxjQUFMLEtBQXdCNWhGLFFBQTVCLEVBQXNDO1VBQ3BDOzs7UUFFRixJQUFNaHNDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSzR0SCxjQUFyQjs7UUFDQSxJQUFJLEtBQUs1dEgsS0FBTCxLQUFlQSxLQUFuQixFQUEwQjtVQUN4QixJQUFJQSxLQUFKLEVBQVc7WUFDVCxLQUFLNGdDLE9BQUwsQ0FBYWdTLFlBQWIsQ0FBMEIsS0FBS253QyxJQUEvQixFQUFxQyxFQUFyQztXQURGLE1BRU87WUFDTCxLQUFLbStCLE9BQUwsQ0FBYXFPLGVBQWIsQ0FBNkIsS0FBS3hzQyxJQUFsQzs7O1VBRUYsS0FBS3pDLEtBQUwsR0FBYUEsS0FBYjs7O1FBRUYsS0FBSzR0SCxjQUFMLEdBQXNCNWhGLFFBQXRCOzs7O0lBdkNKO0VBQUE7RUEyQ0E7Ozs7Ozs7Ozs7QUFTQSxNQUFhc2lGLGlCQUFiO0lBQUE7O0lBQUE7O0lBR0UsMkJBQVkxdEYsT0FBWixFQUE4Qm4rQixJQUE5QixFQUE0Q29wQyxPQUE1QyxFQUEwRTtNQUFBOztNQUFBOztNQUN4RSwwQkFBTWpMLE9BQU4sRUFBZW4rQixJQUFmLEVBQXFCb3BDLE9BQXJCO01BQ0EsTUFBSzBpRixNQUFMLEdBQ0sxaUYsT0FBTyxDQUFDN3BDLE1BQVIsS0FBbUIsQ0FBbkIsSUFBd0I2cEMsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQXZDLElBQTZDQSxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsRUFEakU7TUFGd0U7OztJQUg1RTtNQUFBO01BQUEsT0FTWSx1QkFBVztRQUNuQixPQUFPLElBQUlnRCxZQUFKLENBQWlCLElBQWpCLENBQVA7OztNQVZKO01BQUEsT0FhWSxxQkFBUztRQUNqQixJQUFJLEtBQUswL0UsTUFBVCxFQUFpQjtVQUNmLE9BQU8sS0FBSzdnRixLQUFMLENBQVcsQ0FBWCxFQUFjMXRDLEtBQXJCOzs7UUFFRjs7O01BakJKO01BQUEsT0FvQkUsa0JBQU07UUFDSixJQUFJLEtBQUt3ekUsS0FBVCxFQUFnQjtVQUNkLEtBQUtBLEtBQUwsR0FBYSxLQUFiLENBRGM7O1VBR2IsS0FBSzV5QyxPQUFMLENBQXFCLEtBQUtuK0IsSUFBMUIsSUFBa0MsS0FBSytxSCxTQUFMLEVBQWxDOzs7OztJQXhCUDtFQUFBLEVBQXVDRixrQkFBdkM7QUE2QkEsTUFBYXorRSxZQUFiO0lBQUE7O0lBQUE7O0lBQUE7TUFBQTs7TUFBQTs7O0lBQUE7RUFBQSxFQUFrQ0csYUFBbEM7RUFHQTtFQUNBO0VBQ0E7O0VBQ0EsSUFBSXcvRSxxQkFBcUIsR0FBRyxLQUE1QjtFQUdBOztFQUNBLENBQUMsWUFBSztJQUNKLElBQUk7TUFDRixJQUFNbGlGLE9BQU8sR0FBRztRQUNkLElBQUl4bEIsT0FBSixHQUFXO1VBQ1QwbkcscUJBQXFCLEdBQUcsSUFBeEI7VUFDQSxPQUFPLEtBQVA7OztPQUhKLENBREU7O01BUUY5d0gsTUFBTSxDQUFDc3NCLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDc2lCLE9BQWhDLEVBQWdEQSxPQUFoRCxFQVJFOztNQVVGNXVDLE1BQU0sQ0FBQzIxQyxtQkFBUCxDQUEyQixNQUEzQixFQUFtQy9HLE9BQW5DLEVBQW1EQSxPQUFuRDtLQVZGLENBV0UsT0FBTzZlLEVBQVAsRUFBVzs7RUFHZCxDQWZEOztBQW1CQSxNQUFhcGMsU0FBYjtJQVNFLG1CQUFZbk8sT0FBWixFQUE4QjRmLFNBQTlCLEVBQWlEaXVFLFlBQWpELEVBQTJFO01BQUE7O01BQUE7O01BTDNFLGFBQTJDN3RILFNBQTNDO01BRVEsc0JBQW9EQSxTQUFwRDtNQUlOLEtBQUtnZ0MsT0FBTCxHQUFlQSxPQUFmO01BQ0EsS0FBSzRmLFNBQUwsR0FBaUJBLFNBQWpCO01BQ0EsS0FBS2l1RSxZQUFMLEdBQW9CQSxZQUFwQjs7TUFDQSxLQUFLQyxrQkFBTCxHQUEwQixVQUFDdHdILENBQUQ7UUFBQSxPQUFPLE1BQUksQ0FBQ2sxQyxXQUFMLENBQWlCbDFDLENBQWpCLENBQVA7T0FBMUI7OztJQWJKO01BQUE7TUFBQSxPQWdCRSxrQkFBUzRCLEtBQVQsRUFBaUQ7UUFDL0MsS0FBSzR0SCxjQUFMLEdBQXNCNXRILEtBQXRCOzs7TUFqQko7TUFBQSxPQW9CRSxrQkFBTTtRQUNKLE9BQU9pc0gsV0FBVyxDQUFDLEtBQUsyQixjQUFOLENBQWxCLEVBQXlDO1VBQ3ZDLElBQU0zckUsU0FBUyxHQUFHLEtBQUsyckUsY0FBdkI7VUFDQSxLQUFLQSxjQUFMLEdBQXNCNWhGLFFBQXRCO1VBQ0FpVyxTQUFTLENBQUMsSUFBRCxDQUFUOzs7UUFFRixJQUFJLEtBQUsyckUsY0FBTCxLQUF3QjVoRixRQUE1QixFQUFzQztVQUNwQzs7O1FBR0YsSUFBTStHLFdBQVcsR0FBRyxLQUFLNjZFLGNBQXpCO1FBQ0EsSUFBTTU2RSxXQUFXLEdBQUcsS0FBS2h6QyxLQUF6QjtRQUNBLElBQU1pekMsb0JBQW9CLEdBQUdGLFdBQVcsSUFBSSxJQUFmLElBQ3pCQyxXQUFXLElBQUksSUFBZixLQUNLRCxXQUFXLENBQUNqc0IsT0FBWixLQUF3QmtzQixXQUFXLENBQUNsc0IsT0FBcEMsSUFDQWlzQixXQUFXLENBQUNHLElBQVosS0FBcUJGLFdBQVcsQ0FBQ0UsSUFEakMsSUFFQUgsV0FBVyxDQUFDSSxPQUFaLEtBQXdCSCxXQUFXLENBQUNHLE9BSHpDLENBREo7UUFLQSxJQUFNQyxpQkFBaUIsR0FDbkJMLFdBQVcsSUFBSSxJQUFmLEtBQXdCQyxXQUFXLElBQUksSUFBZixJQUF1QkMsb0JBQS9DLENBREo7O1FBR0EsSUFBSUEsb0JBQUosRUFBMEI7VUFDeEIsS0FBS3JTLE9BQUwsQ0FBYXlTLG1CQUFiLENBQ0ksS0FBS21OLFNBRFQsRUFDb0IsS0FBS2t1RSxrQkFEekIsRUFDNkMsS0FBS0MsU0FEbEQ7OztRQUdGLElBQUl2N0UsaUJBQUosRUFBdUI7VUFDckIsS0FBS3U3RSxTQUFMLEdBQWlCQyxVQUFVLENBQUM3N0UsV0FBRCxDQUEzQjtVQUNBLEtBQUtuUyxPQUFMLENBQWE1VyxnQkFBYixDQUNJLEtBQUt3MkIsU0FEVCxFQUNvQixLQUFLa3VFLGtCQUR6QixFQUM2QyxLQUFLQyxTQURsRDs7O1FBR0YsS0FBSzN1SCxLQUFMLEdBQWEreUMsV0FBYjtRQUNBLEtBQUs2NkUsY0FBTCxHQUFzQjVoRixRQUF0Qjs7O01BbERKO01BQUEsT0FxREUscUJBQVl0aUIsS0FBWixFQUF3QjtRQUN0QixJQUFJLE9BQU8sS0FBSzFwQixLQUFaLEtBQXNCLFVBQTFCLEVBQXNDO1VBQ3BDLEtBQUtBLEtBQUwsQ0FBVzlCLElBQVgsQ0FBZ0IsS0FBS3V3SCxZQUFMLElBQXFCLEtBQUs3dEYsT0FBMUMsRUFBbURsWCxLQUFuRDtTQURGLE1BRU87VUFDSixLQUFLMXBCLEtBQUwsQ0FBbUNzekMsV0FBbkMsQ0FBK0M1cEIsS0FBL0M7Ozs7O0lBekRQO0VBQUE7RUErREE7RUFDQTs7RUFDQSxJQUFNa2xHLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUNueEYsQ0FBRDtJQUFBLE9BQTBDQSxDQUFDLEtBQ3pEK3dGLHFCQUFxQixHQUNqQjtNQUFDMW5HLE9BQU8sRUFBRTJXLENBQUMsQ0FBQzNXLE9BQVo7TUFBcUJxc0IsT0FBTyxFQUFFMVYsQ0FBQyxDQUFDMFYsT0FBaEM7TUFBeUNELElBQUksRUFBRXpWLENBQUMsQ0FBQ3lWO0tBRGhDLEdBRWpCelYsQ0FBQyxDQUFDM1csT0FIbUQsQ0FBM0M7RUFBQSxDQUFuQjs7RUMxZ0JBOzs7O0FBR0EsTUFBYStuRyx3QkFBYjtJQUFBO01BQUE7OztJQUFBO01BQUE7TUFBQTs7Ozs7Ozs7OztNQVVFLG9DQUNJanVGLE9BREosRUFDc0JuK0IsSUFEdEIsRUFDb0NvcEMsT0FEcEMsRUFFSVMsT0FGSixFQUUwQjtRQUN4QixJQUFNd2lGLE1BQU0sR0FBR3JzSCxJQUFJLENBQUMsQ0FBRCxDQUFuQjs7UUFDQSxJQUFJcXNILE1BQU0sS0FBSyxHQUFmLEVBQW9CO1VBQ2xCLElBQU1yQixVQUFTLEdBQUcsSUFBSWEsaUJBQUosQ0FBc0IxdEYsT0FBdEIsRUFBK0JuK0IsSUFBSSxDQUFDZ0QsS0FBTCxDQUFXLENBQVgsQ0FBL0IsRUFBOENvbUMsT0FBOUMsQ0FBbEI7O1VBQ0EsT0FBTzRoRixVQUFTLENBQUMvL0UsS0FBakI7OztRQUVGLElBQUlvaEYsTUFBTSxLQUFLLEdBQWYsRUFBb0I7VUFDbEIsT0FBTyxDQUFDLElBQUkvL0UsU0FBSixDQUFjbk8sT0FBZCxFQUF1Qm4rQixJQUFJLENBQUNnRCxLQUFMLENBQVcsQ0FBWCxDQUF2QixFQUFzQzZtQyxPQUFPLENBQUNtaUYsWUFBOUMsQ0FBRCxDQUFQOzs7UUFFRixJQUFJSyxNQUFNLEtBQUssR0FBZixFQUFvQjtVQUNsQixPQUFPLENBQUMsSUFBSWhnRixvQkFBSixDQUF5QmxPLE9BQXpCLEVBQWtDbitCLElBQUksQ0FBQ2dELEtBQUwsQ0FBVyxDQUFYLENBQWxDLEVBQWlEb21DLE9BQWpELENBQUQsQ0FBUDs7O1FBRUYsSUFBTTRoRixTQUFTLEdBQUcsSUFBSUgsa0JBQUosQ0FBdUIxc0YsT0FBdkIsRUFBZ0NuK0IsSUFBaEMsRUFBc0NvcEMsT0FBdEMsQ0FBbEI7UUFDQSxPQUFPNGhGLFNBQVMsQ0FBQy8vRSxLQUFqQjs7Ozs7Ozs7TUF6Qko7TUFBQSxPQStCRSw4QkFBcUJwQixPQUFyQixFQUEyQztRQUN6QyxPQUFPLElBQUlvaEYsUUFBSixDQUFhcGhGLE9BQWIsQ0FBUDs7OztJQWhDSjtFQUFBO0FBb0NBLEVBQU8sSUFBTXlpRix3QkFBd0IsR0FBRyxJQUFJRix3QkFBSixFQUFqQzs7RUMxRFA7Ozs7Ozs7Ozs7Ozs7RUF1REE7RUFDQTs7RUFDQSxJQUFJLE9BQU9ueEgsTUFBUCxLQUFrQixXQUF0QixFQUFtQztJQUNqQyxDQUFDQSxNQUFNLENBQUMsaUJBQUQsQ0FBTixLQUE4QkEsTUFBTSxDQUFDLGlCQUFELENBQU4sR0FBNEIsRUFBMUQsQ0FBRCxFQUFnRXFELElBQWhFLENBQXFFLE9BQXJFO0VBQ0Q7O01DMUNLaXVIO0lBS0osbUJBQVlwdUYsT0FBWixFQUE0QjtNQUFBOztNQUg1QixlQUF1QixJQUFJL08sR0FBSixFQUF2QjtNQUNBLGVBQVUsS0FBVjtNQUdFLEtBQUsrTyxPQUFMLEdBQWVBLE9BQWY7TUFDQSxJQUFNaWlCLFNBQVMsR0FBRyxDQUFDamlCLE9BQU8sQ0FBQ2dPLFlBQVIsQ0FBcUIsT0FBckIsS0FBaUMsRUFBbEMsRUFBc0N0dEMsS0FBdEMsQ0FBNEMsS0FBNUMsQ0FBbEI7O01BRjBCLDJDQUdSdWhELFNBSFE7OztNQUFBO1FBRzFCLG9EQUE2QjtVQUFBLElBQWxCMEcsR0FBa0I7VUFDM0IsS0FBS29SLE9BQUwsQ0FBYTFwQyxHQUFiLENBQWlCczRCLEdBQWpCOzs7UUFKd0I7O1FBQUE7Ozs7OzthQU81QixhQUFJQSxHQUFKLEVBQWU7UUFDYixLQUFLb1IsT0FBTCxDQUFhMXBDLEdBQWIsQ0FBaUJzNEIsR0FBakI7UUFDQSxLQUFLb3ZCLE9BQUwsR0FBZSxJQUFmOzs7O2FBR0YsZ0JBQU9wdkIsR0FBUCxFQUFrQjtRQUNoQixLQUFLb1IsT0FBTCxDQUFhdGUsTUFBYixDQUFvQmtOLEdBQXBCO1FBQ0EsS0FBS292QixPQUFMLEdBQWUsSUFBZjs7OzthQUdGLGtCQUFNO1FBQ0osSUFBSSxLQUFLQSxPQUFULEVBQWtCO1VBQ2hCLElBQUlzMkMsV0FBVyxHQUFHLEVBQWxCO1VBQ0EsS0FBS3QwRCxPQUFMLENBQWF2c0QsT0FBYixDQUFxQixVQUFDbTdDLEdBQUQ7WUFBQSxPQUFTMGxFLFdBQVcsSUFBSTFsRSxHQUFHLEdBQUcsR0FBOUI7V0FBckI7VUFDQSxLQUFLM29CLE9BQUwsQ0FBYWdTLFlBQWIsQ0FBMEIsT0FBMUIsRUFBbUNxOEUsV0FBbkM7Ozs7Ozs7RUFTTjs7Ozs7O0VBSUEsSUFBTUMsb0JBQW9CLEdBQUcsSUFBSXA4RixPQUFKLEVBQTdCO0VBRUE7Ozs7Ozs7Ozs7QUFTQSxFQUFPLElBQU15dkIsUUFBUSxHQUFHTixTQUFTLENBQUMsVUFBQ1MsU0FBRDtJQUFBLE9BQTBCLFVBQUNqVyxJQUFELEVBQWU7TUFDekUsSUFBSSxFQUFFQSxJQUFJLFlBQVl1QyxhQUFsQixLQUFxQ3ZDLElBQUksWUFBWW9DLFlBQXJELElBQ0FwQyxJQUFJLENBQUNnaEYsU0FBTCxDQUFlaHJILElBQWYsS0FBd0IsT0FEeEIsSUFDbUNncUMsSUFBSSxDQUFDZ2hGLFNBQUwsQ0FBZS8vRSxLQUFmLENBQXFCMXJDLE1BQXJCLEdBQThCLENBRHJFLEVBQ3dFO1FBQ3RFLE1BQU0sSUFBSTBsQyxLQUFKLENBQ0Ysb0VBQ0EsNkNBRkUsQ0FBTjs7O01BS0YsSUFBTytsRixTQUFQLEdBQW9CaGhGLElBQXBCLENBQU9naEYsU0FBUDtNQUNBLElBQU83c0YsT0FBUCxHQUFrQjZzRixTQUFsQixDQUFPN3NGLE9BQVA7TUFFQSxJQUFJdXVGLGVBQWUsR0FBR0Qsb0JBQW9CLENBQUMxd0gsR0FBckIsQ0FBeUJpdUMsSUFBekIsQ0FBdEI7O01BQ0EsSUFBSTBpRixlQUFlLEtBQUt2dUgsU0FBeEIsRUFBbUM7OztRQUdqQ2dnQyxPQUFPLENBQUNnUyxZQUFSLENBQXFCLE9BQXJCLEVBQThCNjZFLFNBQVMsQ0FBQzVoRixPQUFWLENBQWtCanFDLElBQWxCLENBQXVCLEdBQXZCLENBQTlCO1FBQ0FzdEgsb0JBQW9CLENBQUNqakgsR0FBckIsQ0FBeUJ3Z0MsSUFBekIsRUFBK0IwaUYsZUFBZSxHQUFHLElBQUl0OUYsR0FBSixFQUFqRDs7O01BR0YsSUFBTWd4QixTQUFTLEdBQ1ZqaUIsT0FBTyxDQUFDaWlCLFNBQVIsSUFBcUIsSUFBSW1zRSxTQUFKLENBQWNwdUYsT0FBZCxDQUQxQixDQW5CeUU7Ozs7TUF5QnpFdXVGLGVBQWUsQ0FBQy9nSCxPQUFoQixDQUF3QixVQUFDM0wsSUFBRCxFQUFTO1FBQy9CLElBQUksRUFBRUEsSUFBSSxJQUFJaWdELFNBQVYsQ0FBSixFQUEwQjtVQUN4QkcsU0FBUyxDQUFDM1UsTUFBVixDQUFpQnpyQyxJQUFqQjtVQUNBMHNILGVBQWdCLENBQUM5eUUsTUFBakIsQ0FBd0I1NUMsSUFBeEI7O09BSEosRUF6QnlFOztNQWlDekUsS0FBSyxJQUFNQSxJQUFYLElBQW1CaWdELFNBQW5CLEVBQThCO1FBQzVCLElBQU0xaUQsS0FBSyxHQUFHMGlELFNBQVMsQ0FBQ2pnRCxJQUFELENBQXZCOztRQUNBLElBQUl6QyxLQUFLLElBQUltdkgsZUFBZSxDQUFDenRILEdBQWhCLENBQW9CZSxJQUFwQixDQUFiLEVBQXdDOzs7VUFHdEMsSUFBSXpDLEtBQUosRUFBVztZQUNUNmlELFNBQVMsQ0FBQzV4QixHQUFWLENBQWN4dUIsSUFBZDtZQUNBMHNILGVBQWUsQ0FBQ2wrRixHQUFoQixDQUFvQnh1QixJQUFwQjtXQUZGLE1BR087WUFDTG9nRCxTQUFTLENBQUMzVSxNQUFWLENBQWlCenJDLElBQWpCO1lBQ0Ewc0gsZUFBZSxDQUFDOXlFLE1BQWhCLENBQXVCNTVDLElBQXZCOzs7OztNQUlOLElBQUksT0FBUW9nRCxTQUF1QixDQUFDNnBFLE1BQWhDLEtBQTJDLFVBQS9DLEVBQTJEO1FBQ3hEN3BFLFNBQXVCLENBQUM2cEUsTUFBeEI7O0tBaEQ2QjtFQUFBLENBQUQsQ0FBMUI7Ozs7TUM5REQwQzs7Ozs7SUEyREosa0JBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUs5eEUsS0FBTCxHQUFhLEdBQWI7TUFDQSxNQUFLRSxNQUFMLEdBQWMsRUFBZDtNQUNBLE1BQUt4OUMsS0FBTCxHQUFhLEVBQWI7TUFDQSxNQUFLcXZILFFBQUwsR0FBZ0IsS0FBaEI7TUFFQSxNQUFLam9FLE1BQUwsR0FBYyxLQUFkO01BUlk7Ozs7O2FBV2Qsa0JBQVM7UUFDUCxJQUFNdVQsT0FBTyxHQUFHO1VBQUU2WSxLQUFLLEVBQUUsS0FBS3BzQjtTQUE5QjtRQUVBLE9BQU9qb0MsR0FBUCw0V0FFWW9qQyxRQUFRLENBQUNvWSxPQUFELENBRnBCLEVBSWUsS0FBS3JkLEtBSnBCLEVBS2dCLEtBQUtFLE1BTHJCLEVBT2MsS0FBS3g5QyxLQVBuQixFQVFnQixLQUFLcXZILFFBUnJCLEVBU1ksS0FBS3p1RSxXQVRqQixFQVVlLEtBQUswRSxTQVZwQixFQVdhLEtBQUtxNUMsT0FYbEIsRUFZb0IsS0FBS2poRCxtQkFaekI7Ozs7YUFpQkYsaUJBQVE7UUFDTixJQUFNNHhFLFNBQVMsR0FBRyxLQUFLaDRFLFVBQUwsQ0FBZ0IwTyxhQUFoQixDQUE4QixVQUE5QixDQUFsQjs7UUFFQSxJQUFJc3BFLFNBQUosRUFBZTtVQUNiQSxTQUFTLENBQUNycEUsS0FBVjs7Ozs7YUFJSixtQkFBVTduRCxDQUFWLEVBQWE7O1FBRVgsSUFBSUEsQ0FBQyxDQUFDcTZGLE9BQUYsSUFBYXI2RixDQUFDLENBQUNILEdBQUYsS0FBVSxHQUEzQixFQUFnQztVQUM5QkcsQ0FBQyxDQUFDODlDLGNBQUY7VUFFQSxLQUFLMEUsV0FBTCxDQUFpQnhpRCxDQUFqQixFQUFvQixJQUFwQjs7Ozs7YUFJSixpQkFBUUEsQ0FBUixFQUFXO1FBQ1QsSUFBSUEsQ0FBQyxDQUFDK0UsTUFBRixDQUFTbkQsS0FBVCxLQUFtQixLQUFLQSxLQUF4QixJQUFpQyxLQUFLb25ELE1BQUwsS0FBZ0IsS0FBckQsRUFBNEQ7VUFDMUQsS0FBS0EsTUFBTCxHQUFjLElBQWQ7VUFDQSxLQUFLeFEsYUFBTDtTQUZGLE1BR08sSUFBSXg0QyxDQUFDLENBQUMrRSxNQUFGLENBQVNuRCxLQUFULEtBQW1CLEtBQUtBLEtBQXhCLElBQWlDLEtBQUtvbkQsTUFBTCxLQUFnQixJQUFyRCxFQUEyRDtVQUNoRSxLQUFLQSxNQUFMLEdBQWMsS0FBZDtVQUNBLEtBQUt4USxhQUFMOzs7OzthQUlKLHFCQUFZeDRDLENBQVosRUFBb0M7UUFBQSxJQUFyQmt1RSxXQUFxQix1RUFBUCxLQUFPO1FBQ2xDbHVFLENBQUMsQ0FBQzg5QyxjQUFGO1FBQ0E5OUMsQ0FBQyxDQUFDNGlELGVBQUY7O1FBRUEsSUFBSSxLQUFLb0csTUFBTCxJQUFla2xCLFdBQW5CLEVBQWdDO1VBQzlCLEtBQUt0c0UsS0FBTCxHQUFhNUIsQ0FBQyxDQUFDK0UsTUFBRixDQUFTbkQsS0FBdEI7VUFDQSxLQUFLb25ELE1BQUwsR0FBYyxLQUFkO1VBRUEsSUFBTTE5QixLQUFLLEdBQUcsSUFBSW8wQixXQUFKLENBQWdCLFFBQWhCLEVBQTBCO1lBQ3RDQyxPQUFPLEVBQUUsSUFENkI7WUFFdENDLFFBQVEsRUFBRSxJQUY0QjtZQUd0Q0MsTUFBTSxFQUFFO2NBQUVqK0MsS0FBSyxFQUFFLEtBQUtBOztXQUhWLENBQWQ7VUFNQSxLQUFLbStDLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7VUFDQSxLQUFLa3RCLGFBQUw7Ozs7O1dBbklKLGVBQXdCO1FBQ3RCLE9BQU87VUFDTDBHLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTtXQUxIO1VBT0x6UyxLQUFLLEVBQUU7WUFDTHdDLElBQUksRUFBRVg7V0FSSDtVQVVMd3RILFFBQVEsRUFBRTtZQUNSN3NILElBQUksRUFBRWl6QyxPQURFO1lBRVJRLE9BQU8sRUFBRTs7U0FaYjs7OztXQWlCRixlQUFvQjtRQUNsQixPQUFPdkIsR0FBUCxrNEJBWXdCcUwsS0FBSyxDQUFDLG1CQUFELENBWjdCLEVBYXlCQSxLQUFLLENBQUMsbUJBQUQsQ0FiOUIsRUFlbUJGLFVBZm5CLEVBa0JpQkMsUUFsQmpCLEVBbUJtQixFQW5CbkIsRUF5QndCQyxLQUFLLENBQUMsbUJBQUQsQ0F6QjdCLEVBNkJ3QkEsS0FBSyxDQUFDLHFCQUFELENBN0I3QixFQWlDd0JBLEtBQUssQ0FBQyxtQkFBRCxDQWpDN0IsRUFrQ3dCQSxLQUFLLENBQUMsbUJBQUQsQ0FsQzdCOzs7OztJQXBCaUIvRDs7RUF5SXJCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsU0FBdEIsRUFBaUNvckcsTUFBakM7Ozs7TUMxSU1HOzs7OztJQXFFSixrQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBS2p5RSxLQUFMLEdBQWEsRUFBYjtNQUNBLE1BQUtFLE1BQUwsR0FBYyxFQUFkO01BQ0EsTUFBS3g5QyxLQUFMLEdBQWEsSUFBYixFQUVBLE1BQUt3dkgsT0FBTCxHQUFlLEtBRmY7TUFHQSxNQUFLQyxVQUFMLEdBQWtCLElBQWxCO01BUlk7Ozs7O1dBL0JkLGVBQVk7UUFDVixPQUFPLEtBQUs1dUUsS0FBWjs7V0FORixhQUFVN2dELEtBQVYsRUFBaUI7UUFDZixLQUFLNmdELEtBQUwsR0FBYTdnRCxLQUFiO1FBQ0EsS0FBSzQyQyxhQUFMOzs7O1dBWUYsZUFBYTtRQUNYLE9BQU8sS0FBS2lLLEtBQVo7O1dBTkYsYUFBVzdnRCxLQUFYLEVBQWtCO1FBQ2hCLEtBQUs2Z0QsS0FBTCxHQUFhN2dELEtBQWI7UUFDQSxLQUFLNDJDLGFBQUw7Ozs7V0FPRixhQUFXNTJDLEtBQVgsRUFBa0I7UUFBQTs7UUFDaEIrckQsWUFBWSxDQUFDLEtBQUswakUsVUFBTixDQUFaOztRQUVBLElBQUl6dkgsS0FBSyxLQUFLLElBQWQsRUFBb0I7VUFFbEIsS0FBS3d2SCxPQUFMLEdBQWUsSUFBZjtVQUNBLEtBQUs1NEUsYUFBTDtVQUVBLEtBQUs2NEUsVUFBTCxHQUFrQnJsRyxVQUFVLENBQUMsWUFBTTtZQUNqQyxNQUFJLENBQUNvbEcsT0FBTCxHQUFlLEtBQWY7O1lBQ0EsTUFBSSxDQUFDNTRFLGFBQUw7V0FGMEIsRUFHekIsRUFIeUIsQ0FBNUI7U0FMRixNQVNPO1VBQ0wsS0FBSzQ0RSxPQUFMLEdBQWUsS0FBZjtVQUNBLEtBQUs1NEUsYUFBTDs7Ozs7YUFlSixrQkFBUztRQUNQLElBQU0xNkIsSUFBSSxHQUFHLEtBQUsya0MsS0FBTCxHQUFhLENBQTFCO1FBRUEsT0FBTzFoQyxHQUFQLG9nQkFHZSxLQUFLMGhDLEtBSHBCLEVBSWdCLEtBQUtBLEtBSnJCLEVBT2tCLEtBQUs2dUUsYUFQdkIsRUFRbUIsS0FBS0EsYUFSeEIsRUFTb0IsS0FBS2h5RSxtQkFUekIsRUFnQmdCcUMsS0FBSyxDQUFDLG1CQUFELENBaEJyQixFQWlCY0EsS0FBSyxDQUFDLG1CQUFELENBakJuQixFQW1CTSxLQUFLeXZFLE9BQUwsR0FDRXpqRixDQURGLDRPQU1ZZ1UsS0FBSyxDQUFDLG1CQUFELENBTmpCLElBU0U3VCxHQTVCUjs7OzthQWtDRix1QkFBYzl0QyxDQUFkLEVBQWlCO1FBQ2ZBLENBQUMsQ0FBQzg5QyxjQUFGO1FBRUEsSUFBTXVFLFVBQVUsR0FBRyxJQUFJM0MsV0FBSixDQUFnQixPQUFoQixFQUF5QjtVQUMxQ0MsT0FBTyxFQUFFLElBRGlDO1VBRTFDQyxRQUFRLEVBQUUsSUFGZ0M7VUFHMUNDLE1BQU0sRUFBRTtZQUFFaitDLEtBQUssRUFBRSxLQUFLQTs7U0FITCxDQUFuQjtRQU1BLEtBQUsyZ0QsTUFBTCxHQUFjLElBQWQ7UUFDQSxLQUFLeEMsYUFBTCxDQUFtQnNDLFVBQW5COzs7O1dBOUhGLGVBQXdCO1FBQ3RCLE9BQU87VUFDTG5ELEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTtXQUxIO1VBT0xrdUMsTUFBTSxFQUFFO1lBQ05uK0MsSUFBSSxFQUFFaXpDO1dBUkg7VUFVTHoxQyxLQUFLLEVBQUU7U0FWVDs7OztXQWNGLGVBQW9CO1FBQ2xCLE9BQU8wMEMsR0FBUCxzV0FLd0JxTCxLQUFLLENBQUMsbUJBQUQsQ0FMN0IsRUFXd0JBLEtBQUssQ0FBQyxtQkFBRCxDQVg3Qjs7Ozs7SUFqQmlCL0Q7O0VBbUlyQmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLFNBQXRCLEVBQWlDdXJHLE1BQWpDOzs7O01DbklNSTs7Ozs7SUFxR0osb0JBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtyeUUsS0FBTCxHQUFhLEdBQWI7TUFDQSxNQUFLRSxNQUFMLEdBQWMsR0FBZDtNQUNBLE1BQUs0b0UsUUFBTCxHQUFnQixDQUFoQjtNQUNBLE1BQUt3SixNQUFMLEdBQWMsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixTQUF2QixFQUFrQyxTQUFsQyxFQUE2QyxTQUE3QyxFQUF3RCxTQUF4RCxDQUFkO01BQ0EsTUFBS0MsYUFBTCxHQUFxQixLQUFyQjtNQUVBLE1BQUs1cEgsR0FBTCxHQUFXLENBQUMsQ0FBWjtNQUNBLE1BQUtFLEdBQUwsR0FBVyxDQUFYO01BRUEsTUFBSzJwSCxXQUFMLEdBQW1CLEVBQW5CO01BQ0EsTUFBS0MsV0FBTCxHQUFtQixJQUFuQjtNQUVBLE1BQUszb0UsTUFBTCxHQUFjLElBQWQ7TUFDQSxNQUFLNG9FLFNBQUwsR0FBaUIsQ0FBQ3YrRyxRQUFsQjtNQUNBLE1BQUt3K0csU0FBTCxHQUFpQixDQUFDeCtHLFFBQWxCO01BRUEsTUFBS3krRyxhQUFMLEdBQXFCLE1BQUtBLGFBQUwsQ0FBbUJ6Z0gsSUFBbkIsK0JBQXJCO01BbkJZOzs7OztXQTFCZCxhQUFVMGdILEtBQVYsRUFBaUI7UUFDZkEsS0FBSyxDQUFDLzhHLElBQU4sR0FBYXpMLEtBQUssQ0FBQ0MsT0FBTixDQUFjdW9ILEtBQUssQ0FBQy84RyxJQUFwQixJQUE0Qis4RyxLQUFLLENBQUMvOEcsSUFBbEMsR0FBeUMsQ0FBQys4RyxLQUFLLENBQUMvOEcsSUFBUCxDQUF0RCxDQURlOztRQUdmLEtBQUswOEcsV0FBTCxDQUFpQi91SCxJQUFqQixDQUFzQm92SCxLQUF0Qjs7UUFFQSxJQUFJLEtBQUtOLGFBQVQsRUFBd0I7VUFDdEIsSUFBSWwzQyxPQUFPLEdBQUcsS0FBZDs7VUFFQSxLQUFLLElBQUl2MEUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytySCxLQUFLLENBQUMvOEcsSUFBTixDQUFXcFIsTUFBL0IsRUFBdUNvQyxDQUFDLEVBQXhDLEVBQTRDO1lBQzFDLElBQUkrckgsS0FBSyxDQUFDLzhHLElBQU4sQ0FBV2hQLENBQVgsSUFBZ0IsS0FBSzRySCxTQUF6QixFQUFvQztjQUNsQyxLQUFLQSxTQUFMLEdBQWlCRyxLQUFLLENBQUMvOEcsSUFBTixDQUFXaFAsQ0FBWCxDQUFqQjtjQUNBdTBFLE9BQU8sR0FBRyxJQUFWOzs7WUFHRixJQUFJdzNDLEtBQUssQ0FBQy84RyxJQUFOLENBQVdoUCxDQUFYLElBQWdCLEtBQUs2ckgsU0FBekIsRUFBb0M7Y0FDbEMsS0FBS0EsU0FBTCxHQUFpQkUsS0FBSyxDQUFDLzhHLElBQU4sQ0FBV2hQLENBQVgsQ0FBakI7Y0FDQXUwRSxPQUFPLEdBQUcsSUFBVjs7OztVQUlKLElBQUlBLE9BQUosRUFBYTtZQUNYLEtBQUsvaEMsYUFBTDs7Ozs7O2FBMkJOLGtCQUFTO1FBQ1AsT0FBT3ozQixHQUFQLGdTQUVvQixLQUFLdStCLG1CQUZ6QixFQU1pQixLQUFLSixLQU50QixFQU9rQixLQUFLRSxNQVB2QixFQVVNLEtBQUtxeUUsYUFBTCxHQUNFMXdHLEdBREYsb0xBRXNCLEtBQUs2d0csU0FBTCxDQUFlNzhHLE9BQWYsQ0FBdUIsQ0FBdkIsQ0FGdEIsRUFHc0IsS0FBSzg4RyxTQUFMLENBQWU5OEcsT0FBZixDQUF1QixDQUF2QixDQUh0QixJQUtFKzRCLEdBZlI7Ozs7YUFxQkYsd0JBQWU7UUFHYixLQUFLa2tGLE1BQUwsR0FBYyxLQUFLOTRFLFVBQUwsQ0FBZ0IwTyxhQUFoQixDQUE4QixRQUE5QixDQUFkO1FBQ0EsS0FBS3ZpRCxHQUFMLEdBQVcsS0FBSzJzSCxNQUFMLENBQVlDLFVBQVosQ0FBdUIsSUFBdkIsQ0FBWDtRQUVBLEtBQUtDLFlBQUwsR0FBb0J2eEgsUUFBUSxDQUFDRSxhQUFULENBQXVCLFFBQXZCLENBQXBCO1FBQ0EsS0FBS3N4SCxTQUFMLEdBQWlCLEtBQUtELFlBQUwsQ0FBa0JELFVBQWxCLENBQTZCLElBQTdCLENBQWpCLENBUGE7Ozs7Ozs7UUFnQmI7Ozs7YUFHRiw2QkFBb0I7UUFDbEIsS0FBS1AsV0FBTCxDQUFpQjl0SCxNQUFqQixHQUEwQixDQUExQjtRQUNBLEtBQUsrdEgsV0FBTCxHQUFtQixJQUFuQjs7UUFFQTs7UUFFQSxLQUFLUyxLQUFMLEdBQWE5eUgsTUFBTSxDQUFDOGdELHFCQUFQLENBQTZCLEtBQUsweEUsYUFBbEMsQ0FBYjs7OzthQUdGLGdCQUFPbjNFLGlCQUFQLEVBQTBCO1FBQ3hCLEtBQUtxTyxNQUFMLEdBQWMsSUFBZDs7UUFDQSxxRUFBYXJPLGlCQUFiOzs7O2FBR0YsZ0NBQXVCO1FBQ3JCcjdDLE1BQU0sQ0FBQzZnRCxvQkFBUCxDQUE0QixLQUFLaXlFLEtBQWpDO1FBRUEsS0FBS1YsV0FBTCxDQUFpQjl0SCxNQUFqQixHQUEwQixDQUExQjtRQUNBLEtBQUt5QixHQUFMLENBQVNndEgsU0FBVCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUFLQyxhQUE5QixFQUE2QyxLQUFLQyxjQUFsRDtRQUNBLEtBQUtKLFNBQUwsQ0FBZUUsU0FBZixDQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixLQUFLQyxhQUFwQyxFQUFtRCxLQUFLQyxjQUF4RDs7UUFFQTs7OzthQUdGLHlCQUFnQjtRQUVkLElBQUksS0FBS3ZwRSxNQUFULEVBQWlCOztVQUVmLElBQU05RixLQUFLLEdBQUc1akQsTUFBTSxDQUFDa3pILGdCQUFyQjtVQUNBLEtBQUtGLGFBQUwsR0FBcUIsS0FBS3B6RSxLQUFMLEdBQWFnRSxLQUFsQztVQUNBLEtBQUtxdkUsY0FBTCxHQUFzQixLQUFLbnpFLE1BQUwsR0FBYzhELEtBQXBDO1VBRUEsS0FBSzh1RSxNQUFMLENBQVk5eUUsS0FBWixHQUFvQixLQUFLb3pFLGFBQXpCO1VBQ0EsS0FBS04sTUFBTCxDQUFZNXlFLE1BQVosR0FBcUIsS0FBS216RSxjQUExQjtVQUNBLEtBQUtMLFlBQUwsQ0FBa0JoekUsS0FBbEIsR0FBMEIsS0FBS296RSxhQUEvQjtVQUNBLEtBQUtKLFlBQUwsQ0FBa0I5eUUsTUFBbEIsR0FBMkIsS0FBS216RSxjQUFoQyxDQVRlOztVQVlmLElBQU0xcUgsR0FBRyxHQUFHLEtBQUtBLEdBQWpCO1VBQ0EsSUFBTUUsR0FBRyxHQUFHLEtBQUtBLEdBQWpCO1VBQ0EsSUFBTXEzQyxNQUFNLEdBQUcsS0FBS216RSxjQUFwQjtVQUVBLElBQU1seUgsQ0FBQyxHQUFHLENBQUMsSUFBSSsrQyxNQUFMLEtBQWdCcjNDLEdBQUcsR0FBR0YsR0FBdEIsQ0FBVjtVQUNBLElBQU0vRCxDQUFDLEdBQUdzN0MsTUFBTSxHQUFJLytDLENBQUMsR0FBR3dILEdBQXhCOztVQUVBLEtBQUs0cUgsYUFBTCxHQUFxQixVQUFDdGlILENBQUQ7WUFBQSxPQUFPOVAsQ0FBQyxHQUFHOFAsQ0FBSixHQUFRck0sQ0FBZjtXQUFyQjs7VUFFQSxLQUFLNHRILFdBQUwsQ0FBaUI5dEgsTUFBakIsR0FBMEIsQ0FBMUI7VUFDQSxLQUFLK3RILFdBQUwsR0FBbUIsSUFBbkI7VUFDQSxLQUFLdHNILEdBQUwsQ0FBU2d0SCxTQUFULENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLEtBQUtDLGFBQTlCLEVBQTZDLEtBQUtDLGNBQWxEO1VBQ0EsS0FBS0osU0FBTCxDQUFlRSxTQUFmLENBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLEtBQUtDLGFBQXBDLEVBQW1ELEtBQUtDLGNBQXhEO1VBRUEsS0FBS3ZwRSxNQUFMLEdBQWMsS0FBZDs7O1FBR0YsSUFBTTBwRSxjQUFjLEdBQUcsS0FBS2hCLFdBQUwsQ0FBaUI5dEgsTUFBeEM7O1FBRUEsSUFBSTh1SCxjQUFjLEdBQUcsQ0FBckIsRUFBd0I7VUFDdEIsSUFBSUMsaUJBQWlCLEdBQUcsQ0FBeEI7VUFDQSxJQUFJQyxLQUFLLEdBQUcsS0FBWjtVQUNBLElBQU1DLGFBQWEsR0FBRyxLQUFLN0ssUUFBTCxHQUFnQixLQUFLOW9FLEtBQTNDOztVQUVBLElBQUksS0FBS3l5RSxXQUFMLEtBQXFCLElBQXpCLEVBQStCO1lBQzdCLEtBQUtBLFdBQUwsR0FBbUJweUgsSUFBSSxDQUFDb0ksS0FBTCxDQUFXLEtBQUsrcEgsV0FBTCxDQUFpQixDQUFqQixFQUFvQjF0RixJQUFwQixHQUEyQjZ1RixhQUF0QyxDQUFuQjtXQU5vQjs7O1VBVXRCLE9BQU8sS0FBS25CLFdBQUwsQ0FBaUI5dEgsTUFBakIsR0FBMEIsQ0FBakMsRUFBb0M7WUFDbEMrdUgsaUJBQWlCLElBQUksQ0FBckI7WUFFQSxJQUFNRyxjQUFjLEdBQUcsS0FBS25CLFdBQUwsR0FBbUJrQixhQUExQztZQUNBLElBQU1FLGFBQWEsR0FBRyxDQUFDLEtBQUtwQixXQUFMLEdBQW1CLENBQXBCLElBQXlCa0IsYUFBL0MsQ0FKa0M7O1lBTWxDLElBQUlHLGNBQWMsR0FBRyxJQUFyQixDQU5rQzs7WUFTbEMsS0FBSyxJQUFJaHRILENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBSzBySCxXQUFMLENBQWlCOXRILE1BQXJDLEVBQTZDb0MsQ0FBQyxFQUE5QyxFQUFrRDtjQUNoRCxJQUFNK3JILEtBQUssR0FBRyxLQUFLTCxXQUFMLENBQWlCMXJILENBQWpCLENBQWQ7Y0FDQSxJQUFNaXRILFNBQVMsR0FBR2xCLEtBQUssQ0FBQy90RixJQUF4QixDQUZnRDs7Y0FLaEQsSUFBSWl2RixTQUFTLEdBQUdILGNBQWhCLEVBQWdDOztnQkFFOUIsSUFBSTlzSCxDQUFDLEdBQUcsQ0FBSixLQUFVLEtBQUswckgsV0FBTCxDQUFpQjl0SCxNQUEvQixFQUF1Qzs7a0JBRXJDLEtBQUs4dEgsV0FBTCxDQUFpQjl0SCxNQUFqQixHQUEwQixDQUExQjtrQkFDQWd2SCxLQUFLLEdBQUcsSUFBUjtpQkFMNEI7O2VBQWhDLE1BUU8sSUFBSUssU0FBUyxJQUFJSCxjQUFiLElBQStCRyxTQUFTLEdBQUdGLGFBQS9DLEVBQThEO2dCQUNuRUMsY0FBYyxHQUFHaHRILENBQWpCOzthQXZCOEI7Ozs7WUE2QmxDLElBQUk0c0gsS0FBSixFQUFXO2NBQ1Q7YUE5QmdDOzs7OztZQW9DbEMsSUFBSUksY0FBYyxLQUFLLElBQXZCLEVBQTZCO2NBQzNCLElBQU1qQixNQUFLLEdBQUcsS0FBS0wsV0FBTCxDQUFpQnNCLGNBQWpCLENBQWQsQ0FEMkI7O2NBRzNCLElBQUksS0FBS0UsU0FBVCxFQUFvQjtnQkFDbEIsSUFBTWgwRSxLQUFLLEdBQUcsS0FBS296RSxhQUFuQjtnQkFDQSxJQUFNbHpFLE9BQU0sR0FBRyxLQUFLbXpFLGNBQXBCO2dCQUNBLElBQU1ZLGNBQWMsR0FBR2owRSxLQUFLLEdBQUd5ekUsaUJBQS9CLENBSGtCOztnQkFNbEIsS0FBS3R0SCxHQUFMLENBQVNndEgsU0FBVCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5Qm56RSxLQUF6QixFQUFnQ0UsT0FBaEM7Z0JBQ0EsS0FBSy81QyxHQUFMLENBQVMrdEgsU0FBVCxDQUFtQixLQUFLbEIsWUFBeEIsRUFDRVMsaUJBREYsRUFDcUIsQ0FEckIsRUFDd0JRLGNBRHhCLEVBQ3dDL3pFLE9BRHhDLEVBRUUsQ0FGRixFQUVLLENBRkwsRUFFUSt6RSxjQUZSLEVBRXdCL3pFLE9BRnhCO2dCQUtBLEtBQUsvNUMsR0FBTCxDQUFTZ3VILFNBQVQsR0FBcUIsS0FBS0EsU0FBMUI7Z0JBQ0EsS0FBS2h1SCxHQUFMLENBQVNpdUgsT0FBVCxHQUFtQixPQUFuQjs7Z0JBRUEsS0FBSyxJQUFJdHRILEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUcrckgsTUFBSyxDQUFDLzhHLElBQU4sQ0FBV3BSLE1BQS9CLEVBQXVDb0MsRUFBQyxFQUF4QyxFQUE0QztrQkFDMUMsS0FBS1gsR0FBTCxDQUFTa3VILFdBQVQsR0FBdUIsS0FBSy9CLE1BQUwsQ0FBWXhySCxFQUFaLENBQXZCLENBRDBDOzs7a0JBSTFDLElBQU1vN0MsS0FBSyxHQUFHLEtBQUtxeEUsYUFBTCxDQUFtQixLQUFLUyxTQUFMLENBQWVsK0csSUFBZixDQUFvQmhQLEVBQXBCLENBQW5CLENBQWQ7O2tCQUNBLElBQU13dEgsUUFBUSxHQUFHLEtBQUtmLGFBQUwsQ0FBbUJWLE1BQUssQ0FBQy84RyxJQUFOLENBQVdoUCxFQUFYLENBQW5CLENBQWpCOztrQkFFQSxLQUFLWCxHQUFMLENBQVNvdUgsU0FBVDtrQkFDQSxLQUFLcHVILEdBQUwsQ0FBU3F1SCxNQUFULENBQWdCUCxjQUFoQixFQUFnQy94RSxLQUFoQztrQkFDQSxLQUFLLzdDLEdBQUwsQ0FBU3N1SCxNQUFULENBQWdCejBFLEtBQWhCLEVBQXVCczBFLFFBQXZCO2tCQUNBLEtBQUtudUgsR0FBTCxDQUFTdXVILE1BQVQ7aUJBekJnQjs7O2dCQTZCbEIsS0FBS3pCLFNBQUwsQ0FBZUUsU0FBZixDQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQm56RSxLQUEvQixFQUFzQ0UsT0FBdEM7Z0JBQ0EsS0FBSyt5RSxTQUFMLENBQWVpQixTQUFmLENBQXlCLEtBQUtwQixNQUE5QixFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0Qzl5RSxLQUE1QyxFQUFtREUsT0FBbkQ7OztjQUdGLEtBQUs4ekUsU0FBTCxHQUFpQm5CLE1BQWpCO2NBQ0FZLGlCQUFpQixHQUFHLENBQXBCLENBckMyQjs7Y0F3QzNCLEtBQUtqQixXQUFMLENBQWlCMTlGLE1BQWpCLENBQXdCLENBQXhCLEVBQTJCZy9GLGNBQWMsR0FBRyxDQUE1Qzs7O1lBR0YsS0FBS3JCLFdBQUwsSUFBb0IsQ0FBcEI7V0F6Rm9COztTQWpDVjs7O1FBOEhkLEtBQUtTLEtBQUwsR0FBYTl5SCxNQUFNLENBQUM4Z0QscUJBQVAsQ0FBNkIsS0FBSzB4RSxhQUFsQyxDQUFiOzs7O1dBelRGLGVBQXdCO1FBQ3RCLE9BQU87VUFDTDV5RSxLQUFLLEVBQUU7WUFDTDk2QyxJQUFJLEVBQUVpUTtXQUZIO1VBSUwrcUMsTUFBTSxFQUFFO1lBQ05oN0MsSUFBSSxFQUFFaVE7V0FMSDtVQU9MMnpHLFFBQVEsRUFBRTtZQUNSNWpILElBQUksRUFBRWlRO1dBUkg7VUFVTHhNLEdBQUcsRUFBRTtZQUNIekQsSUFBSSxFQUFFaVE7V0FYSDtVQWFMdE0sR0FBRyxFQUFFO1lBQ0gzRCxJQUFJLEVBQUVpUSxNQURIO1lBRUh3akMsT0FBTyxFQUFFO1dBZk47VUFpQkwyNUUsTUFBTSxFQUFFO1lBQ05wdEgsSUFBSSxFQUFFbUY7V0FsQkg7VUFvQkw4cEgsU0FBUyxFQUFFO1lBQ1RqdkgsSUFBSSxFQUFFaVEsTUFERztZQUVUd2pDLE9BQU8sRUFBRSxJQUZBO1lBR1QxNkIsU0FBUyxFQUFFO1dBdkJSO1VBeUJMczBHLGFBQWEsRUFBRTtZQUNicnRILElBQUksRUFBRWl6QyxPQURPO1lBRWJsNkIsU0FBUyxFQUFFLGlCQUZFO1lBR2IwNkIsT0FBTyxFQUFFOztTQTVCYjs7OztXQWlDRixlQUFvQjtRQUNsQixPQUFPdkIsR0FBUCxzd0JBT3lCcUwsS0FBSyxDQUFDLG1CQUFELENBUDlCLEVBcUJtQkYsVUFyQm5CLEVBMEJhRSxLQUFLLENBQUMsbUJBQUQsQ0ExQmxCOzs7OztJQXBDbUIvRDs7RUE4VHZCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUMyckcsUUFBbkM7Ozs7Ozs7O0FDblRBLE1BQW1CL2lGLEdBQW5CLEdBQWdDcWxGLENBQWhDLENBQU8vMkUsQ0FBUDtFQUFBLElBa0JhOVAsQUFnRFBGLEdBbEVOLEdBa0VxQixTQUFmQSxDQUFlO0lBQUEsT0FBTW5zQyxTQUFTb3NDLGFBQVRwc0MsQ0FBdUIsRUFBdkJBLENBQU47RUFBQSxDQWxFckI7RUFBQSxJQWdGYW16SCxHQWhGYixHQWdGMEIsU0FBYkEsQ0FBYSxDQUN4QkMsQ0FEd0IsRUFFeEJDLENBRndCLEVBR3hCM2xGLENBSHdCLEVBR3hCQTtJQUFBQTtJQUVBLElBQU1KLElBQWlCOGxGLEVBQWM5Z0YsSUFBZDhnRixDQUEyQjNoRixVQUFsRDtRQUVNNmhGLFNBQ1F6eEgsQ0FEUnl4SCxLQUNKRCxDQURJQyxHQUNvQkYsRUFBYzdnRixJQURsQytnRixHQUM4Q0QsRUFBUS9nRixJQUg1RDs7SUFLQSxTQUFhendDLENBQWIsS0FBSTZyQyxDQUFKLEVBQXdCO01BQ3RCLElBQU0wRSxLQUFpQjlFLEVBQVdRLFlBQVhSLENBQXdCbkIsS0FBeEJtQixFQUF3Q2dtRixDQUF4Q2htRixDQUF2QjtVQUNNTSxLQUFlTixFQUFXUSxZQUFYUixDQUF3Qm5CLEtBQXhCbUIsRUFBd0NnbUYsQ0FBeENobUYsQ0FEckI7O01BRUFJLElBQU8sSUFBSUcsR0FBSixDQUNMdUUsRUFESyxFQUVMeEUsRUFGSyxFQUdMd2xGLENBSEssRUFJTEEsRUFBYzdsRixPQUpULENBQVBHO0tBSEYsTUFTTztNQUNMLElBQU1FLEtBQWVGLEVBQUs2RSxJQUFMN0UsQ0FBaUJ1RSxXQUF0QztVQUNNc2hGLE1BQVk3bEYsRUFBSzhELElBRHZCO1VBRU1naUYsS0FBZ0JELFFBQWNILENBRnBDOztNQUdBLElBQUlJLEVBQUosRUFBbUI7UUFVakIsSUFBSUMsR0FBSjs7UUFUOEIsVUFBOUI3akcsTUFBSzhqRyxJQUF5QixLQUF6QkEsS0FBeUIsQ0FBekJBLEtBQXlCOWpHLFlBQTlCOGQsQ0FBOEI5ZCxFQUFHd2pHLENBQUh4akcsR0FLOUI4ZCxFQUFLOEQsSUFBTDlELEdBQWdCMGxGLENBTGMsRUFLZEEsS0FNcUJ2eEgsQ0FOckJ1eEgsS0FNZDFsRixFQUFLNkYsSUFOUzYvRSxJQU1UNy9FLENBQ0prZ0YsTUFBcUJMLEVBQWMxaEYsSUFEL0I2QixNQUVIZ2dGLElBQVc3aEYsSUFSQzBoRixJQVVkMWxGLEVBQUs2RixJQUFMN0YsQ0FBK0IrbEYsR0FBL0IvbEYsQ0FmNEI7OztNQWtCaEMsSUFBSUUsT0FBWTBsRixDQUFaMWxGLElBQXVCNGxGLEVBQTNCLEVBQTBDO1FBQ3hDLElBQUlqekcsS0FBcUJtdEIsRUFBSzRFLElBQTlCOztRQUNBLE9BQU8veEIsT0FBVXF0QixFQUFqQixHQUEwQjtVQUN4QixJQUFNbjlCLE1BQXNCOFAsR0FBUTB4QixXQUFwQztVQUNLM0UsRUFBV1EsWUFBWFIsQ0FBd0Ivc0IsRUFBeEIrc0IsRUFBZ0NnbUYsQ0FBaENobUYsR0FDTC9zQixLQUFROVAsR0FESDY4Qjs7Ozs7SUFNWCxPQUFPSSxDQUFQO0VBQU9BLENBcElUO0VBQUEsSUF1SmFpbUYsR0F2SmIsR0F1SmlDLFNBQXBCQSxDQUFvQixDQUMvQmptRixDQUQrQixFQUUvQnpzQyxDQUYrQjtJQUFBLElBRy9CeXhDLENBSCtCLHVFQUdJaEYsQ0FISjtJQUFBLE9BSy9CQSxFQUFLSyxJQUFMTCxDQUFnQnpzQyxDQUFoQnlzQyxFQUF1QmdGLENBQXZCaEYsR0FDT0EsQ0FOd0I7RUFBQSxDQXZKakM7RUFBQSxJQWtLTWttRixHQWxLTixHQWtLb0IsRUFsS3BCO0VBQUEsSUErS2FDLEdBL0tiLEdBK0tpQyxTQUFwQkEsQ0FBb0IsQ0FBQ25tRixDQUFEO0lBQUEsSUFBYXpzQyxDQUFiLHVFQUE4QjJ5SCxHQUE5QjtJQUFBLE9BQzlCbG1GLEVBQUsyRSxJQUFMM0UsR0FBd0J6c0MsQ0FETTtFQUFBLENBL0tqQztFQUFBLElBZ01hNnlILEdBaE1iLEdBZ01rQ3BtRixTQUFyQm9tRixDQUFxQnBtRjtJQUFBQSxPQUFvQkEsRUFBSzJFLElBQXpCM0U7RUFBQUEsQ0FoTWxDO0VBQUEsSUF1TWFxbUYsR0F2TWIsR0F1TTJCcm1GLFNBQWRxbUYsQ0FBY3JtRjtJQUFBQTtJQUN6QixnQkFBSzZGLElBQUwsS0FBS0EsS0FBTCxDQUFLQSxLQUFMM2pCLGdCQUFpQyxDQUFqQ0EsRUFBaUMsQ0FBTyxDQUF4Q0E7SUFDQSxJQUFJclAsSUFBMEJtdEIsRUFBSzRFLElBQW5DO0lBQ0EsSUFBTXgyQixJQUE2QjR4QixFQUFLNkUsSUFBTDdFLENBQWlCdUUsV0FBcEQ7O0lBQ0EsT0FBTzF4QixNQUFVekUsQ0FBakIsR0FBc0I7TUFDcEIsSUFBTXJMLE1BQTJCOFAsRUFBUTB4QixXQUF6QztNQUNNMXhCLEVBQXNCNHVCLE1BQXRCNXVCLElBQ05BLElBQVE5UCxHQURGOFA7O0VBQ0U5UCxDQTlNWjs7Ozs7Ozs7RUNPQSxJQUFNdWpILE1BQWMsU0FBZEEsQ0FBYyxDQUFDNzJGLENBQUQsRUFBa0I1YyxDQUFsQixFQUFpQ3pFLENBQWpDLEVBQWlDQTtJQUNuRCxJQUFNNkYsSUFBTSxJQUFJZ1IsR0FBSixFQUFaOztJQUNBLEtBQUssSUFBSXR0QixLQUFJa2IsQ0FBYixFQUFvQmxiLE1BQUt5VyxDQUF6QixFQUE4QnpXLElBQTlCO01BQ0VzYyxFQUFJelUsR0FBSnlVLENBQVF3YixFQUFLOTNCLEVBQUw4M0IsQ0FBUnhiLEVBQWlCdGMsRUFBakJzYzs7O0lBRUYsT0FBT0EsQ0FBUDtFQUFPQSxDQUxUO0VBQUEsSUEwY2E1TixNQUFTbXZDO0lBQUFBOztJQUFBQTs7SUEvYnBCNzBDLGdCQUFZbzFDLENBQVpwMUMsRUFBWW8xQztNQUFBQTs7TUFBQUE7O01BRVYsSUFEQTFQLDBCQUFNMFAsQ0FBTjFQLEdBQ0kwUCxFQUFTaGdELElBQVRnZ0QsS0FBa0JDLElBQVNiLEtBQS9CLEVBQ0UsTUFBVWxhLE1BQU0sK0NBQU5BLENBQVY7TUFIUThhOzs7SUErYlFQO01BQUFBO01BQUFBLE9BeGJaK3dFLFlBQ05DLENBRE1ELEVBRU5FLENBRk1GLEVBR043aUYsQ0FITTZpRixFQUdON2lGO1FBRUEsSUFBSWdqRixDQUFKO1FBQUlBLEtBQ2F2eUgsQ0FEYnV5SCxLQUNBaGpGLENBREFnakYsR0FFRmhqRixJQUFXK2lGLENBRlRDLEdBRVNELEtBQ2tCdHlILENBRGxCc3lILEtBQ0ZBLENBREVBLEtBRVhDLElBQVFELENBRkdBLENBRlRDO1FBTUosSUFBTWxzSCxJQUFPLEVBQWI7WUFDTWtTLElBQVMsRUFEZjtRQUVBLElBQUkvUyxJQUFRLENBQVo7O1FBVkErcEMsMkNBV21COGlGLENBWG5COWlGOzs7UUFBQUE7VUFXQTtZQUFBLElBQVdrQyxFQUFYO1lBQ0VwckMsRUFBS2IsQ0FBTGEsSUFBY2tzSCxJQUFRQSxFQUFNOWdGLEVBQU44Z0YsRUFBWS9zSCxDQUFaK3NILENBQVJBLEdBQTZCL3NILENBQTNDYSxFQUNBa1MsRUFBTy9TLENBQVArUyxJQUFnQmczQixFQUFVa0MsRUFBVmxDLEVBQWdCL3BDLENBQWhCK3BDLENBRGhCbHBDLEVBRUFiLEdBRkFhOzs7VUFaRmtwQzs7VUFBQUE7OztRQWdCQSxPQUFPO1VBQ0xoM0IsU0FESztVQUVMbFM7U0FGRjs7O01BcWFrQmc3QztNQUFBQSxPQXpacEI3VixnQkFDRTZtRixDQURGN21GLEVBRUU4bUYsQ0FGRjltRixFQUdFK0QsQ0FIRi9ELEVBR0UrRDtRQUVBLE9BQU8xQyxLQUFLdWxGLEVBQUx2bEYsQ0FBdUJ3bEYsQ0FBdkJ4bEYsRUFBOEJ5bEYsQ0FBOUJ6bEYsRUFBK0MwQyxDQUEvQzFDLEVBQXlEdDBCLE1BQWhFOzs7TUFvWmtCOG9DO01BQUFBLE9BalpYL0ksZ0JBQ1BpNUUsQ0FET2o1RSxRQUVrQi9JO1FBQUFBO1lBQXhCOGlGLENBQXdCOWlGO1lBQWpCK2lGLENBQWlCL2lGOzs7UUFBQUE7O1FBUW5CaWpGLFFBQVdQLElBQ2ZWLENBRGVVLENBQVhPO3VCQUdxQzNsRixLQUFLdWxGLEVBQUx2bEYsQ0FDekN3bEYsQ0FEeUN4bEYsRUFFekN5bEYsQ0FGeUN6bEYsRUFHekMwQyxDQUh5QzFDLENBSHJDMmxGO1lBR1NDLENBSFRELFlBR0NqNkcsTUFIRGk2RztZQUcwQkUsQ0FIMUJGLFlBR29CbnNILElBSHBCbXNIOztRQWNOLEtBQUt6ckgsTUFBTUMsT0FBTkQsQ0FBY3lySCxDQUFkenJILENBQUwsRUFFRSxPQURBOGxDLEtBQUs4bEYsRUFBTDlsRixHQUFpQjZsRixDQUFqQjdsRixFQUNPNGxGLENBQVA7UUFRRixJQUFNRyxJQUFXLG1CQUFLRCxFQUFMLEtBQUtBLEtBQUwsQ0FBS0EsS0FBTDVrRyxhQUFLNGtHLEVBQUw5bEYsR0FBbUIsRUFBcEM7WUFLTWl5QixJQUF3QixFQUw5QjtRQVdBLElBQUkrekQsQ0FBSjtZQUNJQyxDQURKO1lBSUlDLElBQVUsQ0FKZDtZQUtJQyxJQUFVUixFQUFTcHhILE1BQVRveEgsR0FBa0IsQ0FMaEM7WUFNSXpuQyxJQUFVLENBTmQ7WUFPSWtvQyxJQUFVUixFQUFVcnhILE1BQVZxeEgsR0FBbUIsQ0FQakM7O1FBNk1BLE9BQU9NLEtBQVdDLENBQVhELElBQXNCaG9DLEtBQVdrb0MsQ0FBeEM7VUFDRSxJQUEwQixTQUF0QlQsRUFBU08sQ0FBVFAsQ0FBSixFQUdFTyxJQUhGLEtBSU8sSUFBMEIsU0FBdEJQLEVBQVNRLENBQVRSLENBQUosRUFHTFEsSUFISyxLQUlBLElBQUlKLEVBQVFHLENBQVJILE1BQXFCRixFQUFRM25DLENBQVIybkMsQ0FBekIsRUFFTDV6RCxFQUFTaXNCLENBQVRqc0IsSUFBb0JnekQsSUFDbEJVLEVBQVNPLENBQVRQLENBRGtCVixFQUVsQlcsRUFBVTFuQyxDQUFWMG5DLENBRmtCWCxDQUFwQmh6RCxFQUlBaTBELEdBSkFqMEQsRUFLQWlzQixHQUxBanNCLENBRkssS0FRQSxJQUFJOHpELEVBQVFJLENBQVJKLE1BQXFCRixFQUFRTyxDQUFSUCxDQUF6QixFQUVMNXpELEVBQVNtMEQsQ0FBVG4wRCxJQUFvQmd6RCxJQUNsQlUsRUFBU1EsQ0FBVFIsQ0FEa0JWLEVBRWxCVyxFQUFVUSxDQUFWUixDQUZrQlgsQ0FBcEJoekQsRUFJQWswRCxHQUpBbDBELEVBS0FtMEQsR0FMQW4wRCxDQUZLLEtBUUEsSUFBSTh6RCxFQUFRRyxDQUFSSCxNQUFxQkYsRUFBUU8sQ0FBUlAsQ0FBekIsRUFFTDV6RCxFQUFTbTBELENBQVRuMEQsSUFBb0JnekQsSUFDbEJVLEVBQVNPLENBQVRQLENBRGtCVixFQUVsQlcsRUFBVVEsQ0FBVlIsQ0FGa0JYLENBQXBCaHpELEVBSUF3eUQsSUFBV0MsQ0FBWEQsRUFBMEJ4eUQsRUFBU20wRCxJQUFVLENBQW5CbjBELENBQTFCd3lELEVBQWlEa0IsRUFBU08sQ0FBVFAsQ0FBakRsQixDQUpBeHlELEVBS0FpMEQsR0FMQWowRCxFQU1BbTBELEdBTkFuMEQsQ0FGSyxLQVNBLElBQUk4ekQsRUFBUUksQ0FBUkosTUFBcUJGLEVBQVEzbkMsQ0FBUjJuQyxDQUF6QixFQUVMNXpELEVBQVNpc0IsQ0FBVGpzQixJQUFvQmd6RCxJQUNsQlUsRUFBU1EsQ0FBVFIsQ0FEa0JWLEVBRWxCVyxFQUFVMW5DLENBQVYwbkMsQ0FGa0JYLENBQXBCaHpELEVBSUF3eUQsSUFBV0MsQ0FBWEQsRUFBMEJrQixFQUFTTyxDQUFUUCxDQUExQmxCLEVBQThDa0IsRUFBU1EsQ0FBVFIsQ0FBOUNsQixDQUpBeHlELEVBS0FrMEQsR0FMQWwwRCxFQU1BaXNCLEdBTkFqc0IsQ0FGSyxLQWdCTCxTQU55QjkrRCxDQU16QixLQU5JNnlILENBTUosS0FIRUEsSUFBbUJWLElBQVlPLENBQVpQLEVBQXFCcG5DLENBQXJCb25DLEVBQThCYyxDQUE5QmQsQ0FBbkJVLEVBQ0FDLElBQW1CWCxJQUFZUyxDQUFaVCxFQUFxQlksQ0FBckJaLEVBQThCYSxDQUE5QmIsQ0FFckIsR0FBS1UsRUFBaUIveEgsR0FBakIreEgsQ0FBcUJELEVBQVFHLENBQVJILENBQXJCQyxDQUFMO1lBSU8sSUFBS0EsRUFBaUIveEgsR0FBakIreEgsQ0FBcUJELEVBQVFJLENBQVJKLENBQXJCQyxDQUFMLEVBSUE7Y0FJTCxJQUFNSyxLQUFXSixFQUFpQmwxSCxHQUFqQmsxSCxDQUFxQkosRUFBUTNuQyxDQUFSMm5DLENBQXJCSSxDQUFqQjtrQkFDTUssV0FBdUJuekgsQ0FBdkJtekgsS0FBVUQsRUFBVkMsR0FBbUNYLEVBQVNVLEVBQVRWLENBQW5DVyxHQUF3RCxJQUQ5RDs7Y0FFQSxJQUFnQixTQUFaQSxHQUFKLEVBQXNCO2dCQUdwQixJQUFNQyxNQUFVOUIsSUFBV0MsQ0FBWEQsRUFBMEJrQixFQUFTTyxDQUFUUCxDQUExQmxCLENBQWhCOztnQkFDQVEsSUFBa0JzQixHQUFsQnRCLEVBQTJCVyxFQUFVMW5DLENBQVYwbkMsQ0FBM0JYLEdBQ0FoekQsRUFBU2lzQixDQUFUanNCLElBQW9CczBELEdBRHBCdEI7ZUFKRixNQVFFaHpELEVBQVNpc0IsQ0FBVGpzQixJQUFvQmd6RCxJQUFrQnFCLEdBQWxCckIsRUFBMkJXLEVBQVUxbkMsQ0FBVjBuQyxDQUEzQlgsQ0FBcEJoekQsRUFDQXd5RCxJQUFXQyxDQUFYRCxFQUEwQmtCLEVBQVNPLENBQVRQLENBQTFCbEIsRUFBOEM2QixHQUE5QzdCLENBREF4eUQsRUFJQTB6RCxFQUFTVSxFQUFUVixJQUErQixJQUovQjF6RDs7Y0FNRmlzQjthQXhCSyxNQUVMbW5DLElBQVdNLEVBQVNRLENBQVRSLENBQVhOLEdBQ0FjLEdBREFkO2lCQUpBQSxJQUFXTSxFQUFTTyxDQUFUUCxDQUFYTixHQUNBYSxHQURBYjs7O1FBK0JOLE9BQU9ubkMsS0FBV2tvQyxDQUFsQixHQUEyQjtVQUd6QixJQUFNRyxNQUFVOUIsSUFBV0MsQ0FBWEQsRUFBMEJ4eUQsRUFBU20wRCxJQUFVLENBQW5CbjBELENBQTFCd3lELENBQWhCOztVQUNBUSxJQUFrQnNCLEdBQWxCdEIsRUFBMkJXLEVBQVUxbkMsQ0FBVjBuQyxDQUEzQlgsR0FDQWh6RCxFQUFTaXNCLEdBQVRqc0IsSUFBc0JzMEQsR0FEdEJ0Qjs7O1FBSUYsT0FBT2lCLEtBQVdDLENBQWxCLEdBQTJCO1VBQ3pCLElBQU1HLE1BQVVYLEVBQVNPLEdBQVRQLENBQWhCO1VBQ2dCLFNBQVpXLEdBQVksSUFDZGpCLElBQVdpQixHQUFYakIsQ0FEYzs7O1FBU2xCLE9BSEFybEYsS0FBSzhsRixFQUFMOWxGLEdBQWlCNmxGLENBQWpCN2xGLEVBRUFtbEYsSUFBa0JULENBQWxCUyxFQUFpQ2x6RCxDQUFqQ2t6RCxDQUZBbmxGLEVBR096QixHQUFQOzs7O0lBaURrQmlXO0VBQUFBLEVBbGNRQyxHQWtjUkQsRUExY3RCOzs7O01DaEJNZ3lFOzs7OztJQTRGSixvQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBS2owSCxLQUFMLEdBQWEsRUFBYjtNQUNBLE1BQUtnYyxLQUFMLEdBQWErakMsS0FBSyxDQUFDLHFCQUFELENBQWxCO01BQ0EsTUFBS20wRSxhQUFMLEdBQXFCLENBQXJCO01BQ0EsTUFBS0MsTUFBTCxHQUFjLElBQWQ7TUFDQSxNQUFLQyxTQUFMLEdBQWlCLElBQWpCO01BQ0EsTUFBS2pNLE9BQUwsR0FBZSxDQUFmO01BRUEsTUFBS2tNLE9BQUwsR0FBZSxDQUFDNWlILFFBQWhCO01BRUEsTUFBSzhxQyxNQUFMLEdBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFkO01BQ0EsTUFBS0MsTUFBTCxHQUFjLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZDtNQUNBLE1BQUtjLEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBS0UsTUFBTCxHQUFjLEdBQWQ7TUFFQSxNQUFLODJFLGFBQUwsR0FBcUIsS0FBckI7TUFDQSxNQUFLQyxhQUFMLEdBQXFCLEtBQXJCLENBbEJZOztNQXFCWixNQUFLQyxlQUFMLEdBQXVCejBFLEtBQUssQ0FBQyxtQkFBRCxDQUE1QjtNQUNBLE1BQUswMEUsaUJBQUwsR0FBeUIsQ0FBekI7TUFDQSxNQUFLQyxlQUFMLEdBQXVCLEVBQXZCO01BRUEsTUFBS3R0RSxNQUFMLEdBQWMsS0FBZDtNQXpCWTs7Ozs7YUE0QmQsNkJBQW9CO1FBQ2xCLEtBQUtBLE1BQUwsR0FBYyxJQUFkOztRQUNBOzs7O2FBR0YsZ0JBQU9yTyxpQkFBUCxFQUEwQjtRQUN4QixJQUNFQSxpQkFBaUIsQ0FBQ3IzQyxHQUFsQixDQUFzQixPQUF0QixLQUNBcTNDLGlCQUFpQixDQUFDcjNDLEdBQWxCLENBQXNCLFFBQXRCLENBREEsSUFFQXEzQyxpQkFBaUIsQ0FBQ3IzQyxHQUFsQixDQUFzQixRQUF0QixDQUZBLElBR0FxM0MsaUJBQWlCLENBQUNyM0MsR0FBbEIsQ0FBc0IsUUFBdEIsQ0FKRixFQUtFO1VBQ0EsS0FBSzBsRCxNQUFMLEdBQWMsSUFBZDs7O1FBR0YscUVBQWFyTyxpQkFBYjs7OzthQUdGLGtCQUFTO1FBQUE7O1FBQ1AsSUFBSSxLQUFLcU8sTUFBVCxFQUFpQjtVQUNmLElBQU1qSyxNQUFNLEdBQUd4L0MsSUFBSSxDQUFDa1gsR0FBTCxDQUFTLEtBQUswbkMsTUFBTCxDQUFZLENBQVosSUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBMUIsQ0FBZjtVQUNBLElBQU1hLE1BQU0sR0FBR3ovQyxJQUFJLENBQUNrWCxHQUFMLENBQVMsS0FBSzJuQyxNQUFMLENBQVksQ0FBWixJQUFpQixLQUFLQSxNQUFMLENBQVksQ0FBWixDQUExQixDQUFmLENBRmU7O1VBS2YsSUFBTW00RSxVQUFVLEdBQUd4M0UsTUFBTSxHQUFHQyxNQUE1QjtVQUNBLElBQU13M0UsT0FBTyxHQUFHLEtBQUt0M0UsS0FBTCxHQUFhLEtBQUtFLE1BQWxDO1VBRUEsSUFBSXEzRSxZQUFKO1VBQ0EsSUFBSUMsYUFBSjs7VUFFQSxJQUFJSCxVQUFVLEdBQUdDLE9BQWpCLEVBQTBCO1lBQ3hCQyxZQUFZLEdBQUcsS0FBS3YzRSxLQUFwQjtZQUNBdzNFLGFBQWEsR0FBRzMzRSxNQUFoQjtXQUZGLE1BR087WUFDTDAzRSxZQUFZLEdBQUcsS0FBS3IzRSxNQUFwQjtZQUNBczNFLGFBQWEsR0FBRzEzRSxNQUFoQjtXQWhCYTs7O1VBb0JmLEtBQUsyM0UsUUFBTCxHQUFnQkYsWUFBWSxHQUFHQyxhQUFmLEdBQStCMzNFLE1BQS9DO1VBQ0EsS0FBSzYzRSxTQUFMLEdBQWlCSCxZQUFZLEdBQUdDLGFBQWYsR0FBK0IxM0UsTUFBaEQsQ0FyQmU7O1VBd0JmO1lBQ0UsSUFBTTMrQyxDQUFDLEdBQUcsS0FBS3MySCxRQUFMLElBQWlCLEtBQUt4NEUsTUFBTCxDQUFZLENBQVosSUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBbEMsQ0FBVjtZQUNBLElBQU1yNkMsQ0FBQyxHQUFHLEVBQUcsS0FBS3E2QyxNQUFMLENBQVksQ0FBWixJQUFpQjk5QyxDQUFwQixDQUFWOztZQUNBLEtBQUt3MkgsSUFBTCxHQUFZLFVBQUExbUgsQ0FBQztjQUFBLE9BQUk5UCxDQUFDLEdBQUc4UCxDQUFKLEdBQVFyTSxDQUFaO2FBQWI7O1VBR0Y7WUFDRSxJQUFNekQsRUFBQyxHQUFHLEtBQUt1MkgsU0FBTCxJQUFrQixLQUFLeDRFLE1BQUwsQ0FBWSxDQUFaLElBQWlCLEtBQUtBLE1BQUwsQ0FBWSxDQUFaLENBQW5DLENBQVY7O1lBQ0EsSUFBTXQ2QyxFQUFDLEdBQUcsRUFBRyxLQUFLczZDLE1BQUwsQ0FBWSxDQUFaLElBQWlCLzlDLEVBQXBCLENBQVY7O1lBQ0EsS0FBS3kySCxJQUFMLEdBQVksVUFBQTFtSCxDQUFDO2NBQUEsT0FBSS9QLEVBQUMsR0FBRytQLENBQUosR0FBUXRNLEVBQVo7YUFBYjtXQWpDYTs7VUFxQ2Y7WUFDRSxJQUFNekQsR0FBQyxHQUFHZCxJQUFJLENBQUNrWCxHQUFMLENBQVMsS0FBS21nSCxTQUFMLElBQWtCLEtBQUt4NEUsTUFBTCxDQUFZLENBQVosSUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBbkMsQ0FBVCxDQUFWOztZQUNBLEtBQUsyNEUsU0FBTCxHQUFpQixVQUFBNWxHLENBQUM7Y0FBQSxPQUFJOXdCLEdBQUMsR0FBRzh3QixDQUFSO2FBQWxCOztVQUdGLEtBQUs2M0IsTUFBTCxHQUFjLEtBQWQ7OztRQUdGLElBQUlndUUsVUFBVSxHQUFHLEtBQUtsQixhQUF0Qjs7UUFFQSxJQUFJLEtBQUtDLE1BQVQsRUFBaUI7VUFDZmlCLFVBQVUsR0FBRyxLQUFLakIsTUFBbEI7U0FERixNQUVPLElBQUksS0FBS0MsU0FBVCxFQUFvQjtVQUN6QmdCLFVBQVUsR0FBRyxLQUFLRCxTQUFMLENBQWUsS0FBS2YsU0FBcEIsQ0FBYjs7O1FBR0YsT0FBT2oxRyxHQUFQLHkyQkFFb0IsS0FBS20rQixLQUZ6QixFQUU2QyxLQUFLRSxNQUZsRCxFQUdNLEtBQUs4MkUsYUFBTCxHQUNFbjFHLEdBREYsa1pBR2EsS0FBSzQxRyxRQUhsQixFQUljLEtBQUtDLFNBSm5CLEVBS2VyckgsSUFBSSxDQUFDRSxTQUFMLENBQWUsS0FBSzB5QyxNQUFwQixDQUxmLEVBTWU1eUMsSUFBSSxDQUFDRSxTQUFMLENBQWUsS0FBSzJ5QyxNQUFwQixDQU5mLEVBT2MsS0FBSzY0RSxlQVBuQixFQVNjLENBQUMsS0FBSy8zRSxLQUFMLEdBQWEsS0FBS3kzRSxRQUFuQixJQUErQixDQVQ3QyxFQVVhLENBQUMsS0FBS3YzRSxNQUFMLEdBQWMsS0FBS3czRSxTQUFwQixJQUFpQyxDQVY5QyxJQWFFLEVBaEJSLEVBb0JpQixLQUFLRCxRQXBCdEIsRUFxQmtCLEtBQUtDLFNBckJ2QixFQXVCZ0IsQ0FBQyxLQUFLMTNFLEtBQUwsR0FBYSxLQUFLeTNFLFFBQW5CLElBQStCLENBdkIvQyxFQXdCZSxDQUFDLEtBQUt2M0UsTUFBTCxHQUFjLEtBQUt3M0UsU0FBcEIsSUFBaUMsQ0F4QmhELEVBeUI0QixLQUFLUixlQXpCakMsRUEwQjRCLEtBQUtFLGVBQUwsS0FBeUIsRUFBekIsaUJBQXFDLEtBQUtBLGVBQTFDLFNBQThELE1BMUIxRixFQThCbUIsS0FBS0QsaUJBOUJ4QixFQW1DaUIsS0FBS00sUUFuQ3RCLEVBb0NrQixLQUFLQyxTQXBDdkIsRUFxQ2dCLENBQUMsS0FBSzEzRSxLQUFMLEdBQWEsS0FBS3kzRSxRQUFuQixJQUErQixDQXJDL0MsRUFzQ2UsQ0FBQyxLQUFLdjNFLE1BQUwsR0FBYyxLQUFLdzNFLFNBQXBCLElBQWlDLENBdENoRCxFQXdDcUIsS0FBS0QsUUF4QzFCLEVBd0NzQyxLQUFLQyxTQXhDM0MsRUE0Q1FsaUgsR0FBTSxDQUFDLEtBQUs5UyxLQUFOLEVBQWEsVUFBQW1kLENBQUM7VUFBQSxpQkFBT0EsQ0FBQyxDQUFDNU8sQ0FBVCxjQUFjNE8sQ0FBQyxDQUFDM08sQ0FBaEI7U0FBZCxFQUFtQyxVQUFBMk8sQ0FBQyxFQUFJO1VBQzlDLE9BQU80dUIsQ0FBUCx5UkFDT3FwRixVQURQLEVBRVVqNEcsQ0FBQyxDQUFDbkIsS0FBRixJQUFXLE1BQUksQ0FBQ0EsS0FGMUIsRUFHUSxNQUFJLENBQUNpNUcsSUFBTCxDQUFVOTNHLENBQUMsQ0FBQzVPLENBQVosQ0FIUixFQUlRLE1BQUksQ0FBQzJtSCxJQUFMLENBQVUvM0csQ0FBQyxDQUFDM08sQ0FBWixDQUpSLEVBSzhDLE1BQUksQ0FBQzI1RyxPQUxuRDtTQURNLENBNUNkOzs7O2FBMkRGLHlCQUFnQi9wSCxDQUFoQixFQUFtQjtRQUFBOztRQUNqQkEsQ0FBQyxDQUFDNGlELGVBQUYsR0FEaUI7O1FBSWpCLElBQUksS0FBS3V6RSxhQUFMLElBQXNCbjJILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBVCxDQUFlZ0MsTUFBZixLQUEwQixDQUFwRCxFQUF1RDtVQUNuRDtTQUxhOzs7UUFTakIsSUFBTWhDLEtBQUssR0FBRzVCLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBVCxDQUFlMGdCLEdBQWYsQ0FBbUIsVUFBQTQwRyxPQUFPLEVBQUk7O1VBRTFDLElBQU1DLElBQUksR0FBRzUzSCxJQUFJLENBQUNzSSxHQUFMLENBQVMsTUFBSSxDQUFDczJDLE1BQUwsQ0FBWSxDQUFaLENBQVQsRUFBeUIsTUFBSSxDQUFDQSxNQUFMLENBQVksQ0FBWixDQUF6QixDQUFiO1VBQ0EsSUFBTWk1RSxJQUFJLEdBQUc3M0gsSUFBSSxDQUFDd0ksR0FBTCxDQUFTLE1BQUksQ0FBQ28yQyxNQUFMLENBQVksQ0FBWixDQUFULEVBQXlCLE1BQUksQ0FBQ0EsTUFBTCxDQUFZLENBQVosQ0FBekIsQ0FBYjtVQUNBLElBQU1rNUUsSUFBSSxHQUFHOTNILElBQUksQ0FBQ3NJLEdBQUwsQ0FBUyxNQUFJLENBQUN1MkMsTUFBTCxDQUFZLENBQVosQ0FBVCxFQUF5QixNQUFJLENBQUNBLE1BQUwsQ0FBWSxDQUFaLENBQXpCLENBQWI7VUFDQSxJQUFNazVFLElBQUksR0FBRy8zSCxJQUFJLENBQUN3SSxHQUFMLENBQVMsTUFBSSxDQUFDcTJDLE1BQUwsQ0FBWSxDQUFaLENBQVQsRUFBeUIsTUFBSSxDQUFDQSxNQUFMLENBQVksQ0FBWixDQUF6QixDQUFiO1VBQ0EsSUFBTWp1QyxDQUFDLEdBQUc1USxJQUFJLENBQUNzSSxHQUFMLENBQVN1dkgsSUFBVCxFQUFlNzNILElBQUksQ0FBQ3dJLEdBQUwsQ0FBU292SCxJQUFULEVBQWVELE9BQU8sQ0FBQy9tSCxDQUF2QixDQUFmLENBQVY7VUFDQSxJQUFNQyxDQUFDLEdBQUc3USxJQUFJLENBQUNzSSxHQUFMLENBQVN5dkgsSUFBVCxFQUFlLzNILElBQUksQ0FBQ3dJLEdBQUwsQ0FBU3N2SCxJQUFULEVBQWVILE9BQU8sQ0FBQzltSCxDQUF2QixDQUFmLENBQVY7VUFFQSxPQUFPO1lBQUVELENBQUY7WUFBS0M7V0FBWjtTQVRZLENBQWQ7O1FBWUEsSUFBSXhPLEtBQUssR0FBRyxLQUFLcTBILE9BQWpCLEVBQTBCO1VBQ3hCcjBILEtBQUssQ0FBQ295QixNQUFOLENBQWEsS0FBS2lpRyxPQUFsQjs7O1FBR0YsS0FBS3IwSCxLQUFMLEdBQWFBLEtBQWI7UUFFQSxJQUFNMHBCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUI7VUFDckNDLE9BQU8sRUFBRSxJQUQ0QjtVQUVyQ0MsUUFBUSxFQUFFLElBRjJCO1VBR3JDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1NBSFYsQ0FBZDtRQU1BLEtBQUttK0MsYUFBTCxDQUFtQnowQixLQUFuQjtRQUNBLEtBQUtrdEIsYUFBTDs7OztXQTVSRixlQUF3QjtRQUN0QixPQUFPO1VBQ0wwRyxLQUFLLEVBQUU7WUFDTDk2QyxJQUFJLEVBQUVpUTtXQUZIO1VBSUwrcUMsTUFBTSxFQUFFO1lBQ05oN0MsSUFBSSxFQUFFaVE7V0FMSDtVQU9MOHBDLE1BQU0sRUFBRTtZQUNOLzVDLElBQUksRUFBRW1GLEtBREE7WUFFTjRULFNBQVMsRUFBRTtXQVRSO1VBV0xpaEMsTUFBTSxFQUFFO1lBQ05oNkMsSUFBSSxFQUFFbUYsS0FEQTtZQUVONFQsU0FBUyxFQUFFO1dBYlI7VUFlTHZiLEtBQUssRUFBRTtZQUNMd0MsSUFBSSxFQUFFbUYsS0FERDs7WUFFTHV1QyxVQUFVLENBQUNvdkUsTUFBRCxFQUFTcVEsTUFBVCxFQUFpQjtjQUFFLE9BQU8sSUFBUDs7O1dBakIxQjtVQW1CTHRCLE9BQU8sRUFBRTtZQUNQN3hILElBQUksRUFBRWlRLE1BREM7WUFFUDhJLFNBQVMsRUFBRTtXQXJCUjtVQXVCTFMsS0FBSyxFQUFFO1lBQ0x4WixJQUFJLEVBQUVYLE1BREQ7WUFFTDBaLFNBQVMsRUFBRTtXQXpCUjtVQTJCTDQ0RyxNQUFNLEVBQUU7O1lBQ04zeEgsSUFBSSxFQUFFaVEsTUFEQTtZQUVOOEksU0FBUyxFQUFFO1dBN0JSO1VBK0JMNjRHLFNBQVMsRUFBRTs7WUFDVDV4SCxJQUFJLEVBQUVpUSxNQURHO1lBRVQ4SSxTQUFTLEVBQUU7V0FqQ1I7VUFtQ0w0c0csT0FBTyxFQUFFO1lBQ1AzbEgsSUFBSSxFQUFFaVEsTUFEQztZQUVQOEksU0FBUyxFQUFFO1dBckNSO1VBd0NMaTVHLGVBQWUsRUFBRTtZQUNmaHlILElBQUksRUFBRVgsTUFEUztZQUVmMFosU0FBUyxFQUFFO1dBMUNSO1VBNENMazVHLGlCQUFpQixFQUFFO1lBQ2pCanlILElBQUksRUFBRWlRLE1BRFc7WUFFakI4SSxTQUFTLEVBQUU7V0E5Q1I7VUFnRExtNUcsZUFBZSxFQUFFO1lBQ2ZseUgsSUFBSSxFQUFFWCxNQURTO1lBRWYwWixTQUFTLEVBQUU7V0FsRFI7VUFxREwrNEcsYUFBYSxFQUFFO1lBQ2I5eEgsSUFBSSxFQUFFaXpDLE9BRE87WUFFYmw2QixTQUFTLEVBQUU7V0F2RFI7VUF5RExnNUcsYUFBYSxFQUFFO1lBQ2IveEgsSUFBSSxFQUFFaXpDLE9BRE87WUFFYmw2QixTQUFTLEVBQUU7O1NBM0RmOzs7O1dBZ0VGLGVBQW9CO1FBQ2xCLE9BQU9tNUIsR0FBUDs7Ozs7SUFuRW1COEc7O0VBaVN2QnlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLFlBQXRCLEVBQW9DaXdHLFFBQXBDOzs7RUNsU0EsSUFBTTJCLFlBQVksR0FBSWw0SCxNQUFNLENBQUNrNEgsWUFBUCxJQUF1Qmw0SCxNQUFNLENBQUNtNEgsa0JBQXBEO0VBQ0EsSUFBTUMsWUFBWSxHQUFHLElBQUlGLFlBQUosRUFBckI7RUFFQTtFQUNBO0VBQ0E7O01BQ01HOzs7OztJQXlDSix1QkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBS3o0RSxLQUFMLEdBQWEsR0FBYjtNQUNBLE1BQUtFLE1BQUwsR0FBYyxHQUFkO01BQ0EsTUFBSyt1RCxLQUFMLEdBQWEscUJBQWI7TUFDQSxNQUFLeXBCLE1BQUwsR0FBYyxNQUFkLENBTlk7O01BUVosTUFBS0MsTUFBTCxHQUFjLE1BQWQ7TUFSWTs7Ozs7YUFXZCxrQkFBUztRQUNQLElBQU10N0QsT0FBTyxHQUFHO1VBQ2QsYUFBYSxJQURDO1VBRWQsUUFBUSxLQUFLcTdELE1BQUwsS0FBZ0IsTUFGVjtVQUdkLGNBQWMsS0FBS0EsTUFBTCxLQUFnQjtTQUhoQztRQU1BLE9BQU83MkcsR0FBUCxrVUFDZ0JvakMsR0FBUSxDQUFDb1ksT0FBRCxDQUR4QixFQUdlLEtBQUtyZCxLQUhwQixFQUlnQixLQUFLRSxNQUpyQixFQUtxQixLQUFLQSxNQUwxQixFQU9pQixLQUFLODRDLFVBUHRCLEVBUWtCLEtBQUs0L0IsV0FSdkIsRUFTYSxLQUFLcGhDLE1BVGxCLEVBVUssS0FBS2toQyxNQUFMLEtBQWdCLFlBQWhCLEdBQStCLEtBQUt6cEIsS0FBcEMsR0FBNEMsZUFWakQ7Ozs7YUFjRixvQkFBV251RyxDQUFYLEVBQWM7UUFDWkEsQ0FBQyxDQUFDODlDLGNBQUY7UUFDQTk5QyxDQUFDLENBQUM2MkYsWUFBRixDQUFla2hDLFVBQWYsR0FBNEIsTUFBNUI7UUFFQSxLQUFLSCxNQUFMLEdBQWMsTUFBZDs7OzthQUdGLHFCQUFZNTNILENBQVosRUFBZTtRQUNiQSxDQUFDLENBQUM4OUMsY0FBRjtRQUVBLEtBQUs4NUUsTUFBTCxHQUFjLE1BQWQ7Ozs7YUFHRixnQkFBTzUzSCxDQUFQLEVBQVU7UUFBQTs7UUFDUkEsQ0FBQyxDQUFDODlDLGNBQUY7UUFFQSxLQUFLODVFLE1BQUwsR0FBYyxZQUFkOztRQUVBLElBQUksS0FBS0MsTUFBTCxLQUFnQixNQUFwQixFQUE0QjtVQUMxQixJQUFNamhDLEtBQUssR0FBR3J0RixLQUFLLENBQUN3VyxJQUFOLENBQVcvZixDQUFDLENBQUM2MkYsWUFBRixDQUFlRCxLQUExQixDQUFkO1VBQ0EsSUFBTTl1RSxPQUFPLEdBQUcsRUFBaEI7VUFDQSxJQUFJZ0QsT0FBTyxHQUFHLENBQWQ7VUFFQThyRSxLQUFLLENBQUM1bUYsT0FBTixDQUFjLFVBQUNvbkYsSUFBRCxFQUFPcHZGLEtBQVAsRUFBaUI7WUFDN0IsSUFBSTVELElBQUo7WUFDQSxJQUFNa3pGLE1BQU0sR0FBRyxJQUFJUCxVQUFKLEVBQWY7O1lBRUEsSUFBSSxTQUFTdm1GLElBQVQsQ0FBYzRtRixJQUFJLENBQUNoekYsSUFBbkIsQ0FBSixFQUE4QjtjQUM1QkEsSUFBSSxHQUFHLE9BQVA7YUFERixNQUVPLElBQUksUUFBUW9NLElBQVIsQ0FBYTRtRixJQUFJLENBQUNoekYsSUFBbEIsQ0FBSixFQUE2QjtjQUNsQ0EsSUFBSSxHQUFHLE1BQVA7YUFESyxNQUVBLElBQUksU0FBU29NLElBQVQsQ0FBYzRtRixJQUFJLENBQUNoekYsSUFBbkIsQ0FBSixFQUE4QjtjQUNuQ0EsSUFBSSxHQUFHLE9BQVA7YUFESyxNQUVBLElBQUksUUFBUW9NLElBQVIsQ0FBYTRtRixJQUFJLENBQUNoekYsSUFBbEIsQ0FBSixFQUE2QjtjQUNsQ0EsSUFBSSxHQUFHLE1BQVA7YUFESyxNQUVBO2NBQ0xBLElBQUksR0FBRyxTQUFQOzs7WUFHRmt6RixNQUFNLENBQUNFLE1BQVA7Y0FBQSxtRUFBZ0IsaUJBQU94M0YsQ0FBUDtnQkFBQTtnQkFBQTtrQkFBQTtvQkFBQTtzQkFBQTt3QkFBQSxjQUNOb0UsSUFETTt3QkFBQSxnQ0FFUCxPQUZPLHVCQVlQLE1BWk8sd0JBZ0JQLE9BaEJPLHdCQXNCUCxNQXRCTzt3QkFBQTs7c0JBQUE7d0JBQUE7d0JBQUE7d0JBQUEsT0FJYXN6SCxZQUFZLENBQUNNLGVBQWIsQ0FBNkIxZ0MsTUFBTSxDQUFDMXVGLE1BQXBDLENBSmI7O3NCQUFBO3dCQUlGMHRCLE1BSkU7d0JBS1J4TyxPQUFPLENBQUNzdkUsSUFBSSxDQUFDL3lGLElBQU4sQ0FBUCxHQUFxQml5QixNQUFyQjt3QkFMUTt3QkFBQTs7c0JBQUE7d0JBQUE7d0JBQUE7d0JBT1JyRyxPQUFPLENBQUN0YSxHQUFSO3dCQUNBbVMsT0FBTyxDQUFDc3ZFLElBQUksQ0FBQy95RixJQUFOLENBQVAsR0FBcUIsSUFBckI7O3NCQVJRO3dCQUFBOztzQkFBQTt3QkFhVnlqQixPQUFPLENBQUNzdkUsSUFBSSxDQUFDL3lGLElBQU4sQ0FBUCxHQUFxQmtILElBQUksQ0FBQ2lzQyxLQUFMLENBQVc4L0MsTUFBTSxDQUFDMXVGLE1BQWxCLENBQXJCO3dCQWJVOztzQkFBQTt3QkFpQkpxdkgsSUFqQkksR0FpQkcsSUFBSUMsS0FBSixFQWpCSDt3QkFrQlZELElBQUksQ0FBQzN0SCxHQUFMLEdBQVdndEYsTUFBTSxDQUFDMXVGLE1BQWxCO3dCQUNBa2YsT0FBTyxDQUFDc3ZFLElBQUksQ0FBQy95RixJQUFOLENBQVAsR0FBcUI0ekgsSUFBckI7d0JBbkJVOztzQkFBQTt3QkF1QlZud0csT0FBTyxDQUFDc3ZFLElBQUksQ0FBQy95RixJQUFOLENBQVAsR0FBcUJpekYsTUFBTSxDQUFDMXVGLE1BQTVCO3dCQXZCVTs7c0JBQUE7d0JBMkJWa2YsT0FBTyxDQUFDc3ZFLElBQUksQ0FBQy95RixJQUFOLENBQVAsR0FBcUJpekYsTUFBTSxDQUFDMXVGLE1BQTVCO3dCQTNCVTs7c0JBQUE7d0JBZ0Nka2lCLE9BQU8sSUFBSSxDQUFYOzt3QkFFQSxJQUFJQSxPQUFPLEtBQUs4ckUsS0FBSyxDQUFDaHpGLE1BQXRCLEVBQThCOzBCQUM1QixNQUFJLENBQUNoQyxLQUFMLEdBQWFrbUIsT0FBYjswQkFFTSs2QixXQUhzQixHQUdSLElBQUluRCxXQUFKLENBQWdCLFFBQWhCLEVBQTBCOzRCQUM1Q0MsT0FBTyxFQUFFLElBRG1DOzRCQUU1Q0MsUUFBUSxFQUFFLElBRmtDOzRCQUc1Q0MsTUFBTSxFQUFFOzhCQUFFaitDLEtBQUssRUFBRSxNQUFJLENBQUNBOzsyQkFISixDQUhROzswQkFTNUIsTUFBSSxDQUFDbStDLGFBQUwsQ0FBbUI4QyxXQUFuQjs7MEJBQ0EsTUFBSSxDQUFDKzBFLE1BQUwsR0FBYyxNQUFkOzs7c0JBNUNZO3NCQUFBO3dCQUFBOzs7O2VBQWhCOztjQUFBO2dCQUFBOzs7O1lBZ0RBLFFBQVF4ekgsSUFBUjtjQUNFLEtBQUssT0FBTDtnQkFDRWt6RixNQUFNLENBQUM2Z0MsaUJBQVAsQ0FBeUIvZ0MsSUFBekI7Z0JBQ0E7O2NBQ0YsS0FBSyxNQUFMO2dCQUNFRSxNQUFNLENBQUNHLFVBQVAsQ0FBa0JMLElBQWxCO2dCQUNBOztjQUNGLEtBQUssT0FBTDtnQkFDRUUsTUFBTSxDQUFDOGdDLGFBQVAsQ0FBcUJoaEMsSUFBckI7Z0JBQ0E7O2NBQ0YsS0FBSyxNQUFMO2dCQUNFRSxNQUFNLENBQUNHLFVBQVAsQ0FBa0JMLElBQWxCO2dCQUNBOztjQUNGO2dCQUNFRSxNQUFNLENBQUNHLFVBQVAsQ0FBa0JMLElBQWxCO2dCQUNBOztXQS9FTjs7Ozs7V0EvRkosZUFBd0I7UUFDdEIsT0FBTztVQUNMbDRDLEtBQUssRUFBRTtZQUFFOTZDLElBQUksRUFBRWlRO1dBRFY7VUFFTCtxQyxNQUFNLEVBQUU7WUFBRWg3QyxJQUFJLEVBQUVpUTtXQUZYO1VBR0w4NUYsS0FBSyxFQUFFO1lBQUUvcEcsSUFBSSxFQUFFWDtXQUhWO1VBSUxtMEgsTUFBTSxFQUFFO1lBQUV4ekgsSUFBSSxFQUFFWDs7U0FKbEI7Ozs7V0FRRixlQUFvQjtRQUNsQixPQUFPNnlDLEdBQVAsd3FCQVl3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQVo3QixFQWF3QkEsS0FBSyxDQUFDLG1CQUFELENBYjdCLEVBaUJtQkYsVUFqQm5CLEVBcUJ3QkUsS0FBSyxDQUFDLG1CQUFELENBckI3QixFQXlCd0JBLEtBQUssQ0FBQyxxQkFBRCxDQXpCN0I7Ozs7O0lBWHNCL0Q7O0VBc0wxQmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLGNBQXRCLEVBQXNDK3hHLFdBQXRDOzs7RUM3TEE7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O01BQ01VOzs7OztJQWdISixvQkFBYztNQUFBOztNQUFBOztNQUNaO01BRUEsTUFBS241RSxLQUFMLEdBQWEsR0FBYjtNQUNBLE1BQUtFLE1BQUwsR0FBYyxHQUFkO01BQ0EsTUFBS2tILE1BQUwsR0FBYyxFQUFkO01BRUEsTUFBS2d5RSxRQUFMLEdBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEI7TUFFQSxNQUFLQyxPQUFMLEdBQWUsQ0FBZjtNQUNBLE1BQUtDLElBQUwsR0FBWSxDQUFaO01BVlk7Ozs7O1dBMUVkLGVBQVc7UUFDVCxPQUFPLEtBQUtDLEtBQVo7O1dBTkYsYUFBUzcySCxLQUFULEVBQWdCO1FBQ2QsS0FBSzYySCxLQUFMLEdBQWE3MkgsS0FBYjs7UUFDQSxLQUFLODJILGFBQUw7Ozs7V0FZRixlQUFjO1FBQ1osT0FBTyxLQUFLQyxRQUFaOztXQU5GLGFBQVkvMkgsS0FBWixFQUFtQjtRQUNqQixLQUFLKzJILFFBQUwsR0FBZ0IvMkgsS0FBaEI7O1FBQ0EsS0FBSzgySCxhQUFMOzs7O1dBa0JGLGVBQVk7UUFDVixPQUFPLEtBQUtweUUsTUFBWjs7V0FaRixhQUFVMWtELEtBQVYsRUFBaUI7UUFDZixLQUFLMGtELE1BQUwsR0FBYzFrRCxLQUFkLENBRGU7OztRQUtmLEtBQUs2MkgsS0FBTCxHQUFhLEtBQUtueUUsTUFBTCxDQUFZMWlELE1BQXpCO1FBQ0EsS0FBSyswSCxRQUFMLEdBQWdCLEtBQUtyeUUsTUFBTCxDQUFZLENBQVosRUFBZTFpRCxNQUEvQixDQU5lOztRQVFmLEtBQUs0MEMsYUFBTDs7OztXQW1CRixlQUFZO1FBQ1YsT0FBT2gyQyxTQUFQOztXQWJGLGFBQVVaLEtBQVYsRUFBaUI7UUFBQTs7O1FBRWYsS0FBSzBrRCxNQUFMLENBQVl0MkMsT0FBWixDQUFvQixVQUFBNG9ILEdBQUcsRUFBSTtVQUN6QixLQUFLLElBQUk1eUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzR5SCxHQUFHLENBQUNoMUgsTUFBeEIsRUFBZ0NvQyxDQUFDLEVBQWpDLEVBQXFDO1lBQ25DNHlILEdBQUcsQ0FBQzV5SCxDQUFELENBQUgsR0FBUyxNQUFJLENBQUNzeUgsUUFBTCxDQUFjLENBQWQsQ0FBVDs7U0FGSjs7UUFNQSxLQUFLbnhFLFdBQUw7O1FBQ0EsS0FBSzNPLGFBQUw7Ozs7V0FpQ0YsZUFBYztRQUNaLE9BQU8sS0FBSzgvRSxRQUFaOztXQTNCRixhQUFZdDlHLE9BQVosRUFBcUI7UUFBQTs7UUFDbkIsS0FBS3M5RyxRQUFMLEdBQWdCdDlHLE9BQWhCLENBRG1COztRQUluQixLQUFLLElBQUk1SyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtrMkMsTUFBTCxDQUFZMWlELE1BQWhDLEVBQXdDd00sQ0FBQyxFQUF6QyxFQUE2QztVQUMzQyxJQUFNd29ILEdBQUcsR0FBRyxLQUFLdHlFLE1BQUwsQ0FBWWwyQyxDQUFaLENBQVo7O1VBRDJDLDJCQUdsQ0QsQ0FIa0M7WUFJekMsSUFBTTBvSCxZQUFZLEdBQUdELEdBQUcsQ0FBQ3pvSCxDQUFELENBQXhCLENBSnlDOztZQU16QyxJQUFJLE1BQUksQ0FBQ21vSCxRQUFMLENBQWN6N0csT0FBZCxDQUFzQmc4RyxZQUF0QixNQUF3QyxDQUFDLENBQTdDLEVBQWdEOzs7Y0FHOUMsSUFBTUMsT0FBTyxHQUFHLE1BQUksQ0FBQzk5RyxPQUFMLENBQWErSCxNQUFiLENBQW9CLFVBQUMxaUIsQ0FBRCxFQUFJeUQsQ0FBSixFQUFVO2dCQUM1QyxPQUFPdkUsSUFBSSxDQUFDa1gsR0FBTCxDQUFTM1MsQ0FBQyxHQUFHKzBILFlBQWIsSUFBNkJ0NUgsSUFBSSxDQUFDa1gsR0FBTCxDQUFTcFcsQ0FBQyxHQUFHdzRILFlBQWIsQ0FBN0IsR0FBMEQvMEgsQ0FBMUQsR0FBOER6RCxDQUFyRTtlQURjLENBQWhCOztjQUlBLE1BQUksQ0FBQ2ltRCxNQUFMLENBQVlsMkMsQ0FBWixFQUFlRCxDQUFmLElBQW9CMm9ILE9BQXBCOzs7O1VBVkosS0FBSyxJQUFJM29ILENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5b0gsR0FBRyxDQUFDaDFILE1BQXhCLEVBQWdDdU0sQ0FBQyxFQUFqQyxFQUFxQztZQUFBLE1BQTVCQSxDQUE0Qjs7OztRQWV2QyxLQUFLZzNDLFdBQUw7O1FBQ0EsS0FBSzNPLGFBQUw7Ozs7YUFvQkYsa0JBQVM7UUFBQTs7UUFDUCxJQUFNdWdGLFNBQVMsR0FBRyxLQUFLNzVFLEtBQUwsR0FBYSxLQUFLcTVFLE9BQXBDO1FBQ0EsSUFBTVMsVUFBVSxHQUFHLEtBQUs1NUUsTUFBTCxHQUFjLEtBQUtvNUUsSUFBdEM7UUFFQSxJQUFNUyxRQUFRLEdBQUcsS0FBS1gsUUFBTCxDQUFjLENBQWQsQ0FBakI7UUFDQSxJQUFNWSxRQUFRLEdBQUcsS0FBS1osUUFBTCxDQUFjLEtBQUtBLFFBQUwsQ0FBYzEwSCxNQUFkLEdBQXVCLENBQXJDLENBQWpCO1FBRUEsT0FBT21kLEdBQVAsa05BRW9CLEtBQUttK0IsS0FGekIsRUFFNkMsS0FBS0UsTUFGbEQsRUFHb0IsS0FBS0UsbUJBSHpCLEVBS00sS0FBSzE5QyxLQUFMLENBQVcwZ0IsR0FBWCxDQUFlLFVBQUNzMkcsR0FBRCxFQUFNTyxRQUFOLEVBQW1CO1VBQ2xDLElBQU0vb0gsR0FBQyxHQUFHNG9ILFVBQVUsR0FBR0csUUFBdkI7VUFFQSxPQUFPUCxHQUFHLENBQUN0MkcsR0FBSixDQUFRLFVBQUMxZ0IsS0FBRCxFQUFRdzNILFdBQVIsRUFBd0I7WUFDckMsSUFBTWpwSCxDQUFDLEdBQUc0b0gsU0FBUyxHQUFHSyxXQUF0QjtZQUNBLElBQU1yUCxPQUFPLEdBQUcsQ0FBQ25vSCxLQUFLLEdBQUdxM0gsUUFBVCxLQUFzQkMsUUFBUSxHQUFHRCxRQUFqQyxDQUFoQjtZQUVBLE9BQU90ckYsQ0FBUCx1ZUFJb0JvOEUsT0FKcEIsRUFLYWdQLFNBTGIsRUFNY0MsVUFOZCxFQU9TN29ILENBUFQsRUFRU0MsR0FSVCxFQVNzQitvSCxRQVR0QixFQVV5QkMsV0FWekIsRUFXa0IsTUFBSSxDQUFDQyxXQVh2QjtXQUpLLENBQVA7U0FIQSxDQUxOOzs7O2FBZ0NGLHlCQUFnQjtRQUFBOztRQUNkLElBQU16M0gsS0FBSyxHQUFHLEtBQUtBLEtBQW5CLENBRGM7O1FBSWQsS0FBSyxJQUFJd08sQ0FBQyxHQUFHeE8sS0FBSyxDQUFDZ0MsTUFBTixHQUFlLENBQTVCLEVBQStCd00sQ0FBQyxJQUFJLEtBQUtvb0gsSUFBekMsRUFBK0Nwb0gsQ0FBQyxFQUFoRCxFQUFvRDtVQUNsRHhPLEtBQUssQ0FBQ295QixNQUFOLENBQWE1akIsQ0FBYixFQUFnQixDQUFoQjtTQUxZOzs7UUFTZHhPLEtBQUssQ0FBQ29PLE9BQU4sQ0FBYyxVQUFBNG9ILEdBQUcsRUFBSTtVQUNuQixLQUFLLElBQUl6b0gsQ0FBQyxHQUFHeW9ILEdBQUcsQ0FBQ2gxSCxNQUFKLEdBQWEsQ0FBMUIsRUFBNkJ1TSxDQUFDLElBQUksTUFBSSxDQUFDb29ILE9BQXZDLEVBQWdEcG9ILENBQUMsRUFBakQsRUFBcUQ7WUFDbkR5b0gsR0FBRyxDQUFDNWtHLE1BQUosQ0FBVzdqQixDQUFYLEVBQWMsQ0FBZDs7U0FGSixFQVRjOztRQWdCZCxJQUFNbXBILGNBQWMsR0FBRzEzSCxLQUFLLENBQUNnQyxNQUE3Qjs7UUFFQSxLQUFLLElBQUl3TSxFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxHQUFHLEtBQUtvb0gsSUFBekIsRUFBK0Jwb0gsRUFBQyxFQUFoQyxFQUFvQztVQUNsQyxJQUFJQSxFQUFDLEdBQUdrcEgsY0FBUixFQUF3Qjs7WUFHdEIxM0gsS0FBSyxDQUFDb08sT0FBTixDQUFjLFVBQUE0b0gsR0FBRyxFQUFJO2NBQ25CLEtBQUssSUFBSXpvSCxDQUFDLEdBQUd5b0gsR0FBRyxDQUFDaDFILE1BQWpCLEVBQXlCdU0sQ0FBQyxHQUFHLE1BQUksQ0FBQ29vSCxPQUFsQyxFQUEyQ3BvSCxDQUFDLEVBQTVDLEVBQWdEO2dCQUM5Q3lvSCxHQUFHLENBQUN6b0gsQ0FBRCxDQUFILEdBQVMsTUFBSSxDQUFDbW9ILFFBQUwsQ0FBYyxDQUFkLENBQVQ7O2FBRko7V0FIRixNQVFPOztZQUVMLElBQU1NLEdBQUcsR0FBRyxJQUFJcnZILEtBQUosQ0FBVSxLQUFLZ3ZILE9BQWYsRUFBd0I3MEcsSUFBeEIsQ0FBNkIsS0FBSzQwRyxRQUFMLENBQWMsQ0FBZCxDQUE3QixDQUFaO1lBQ0ExMkgsS0FBSyxDQUFDd08sRUFBRCxDQUFMLEdBQVd3b0gsR0FBWDs7OztRQUlKLEtBQUtwZ0YsYUFBTDs7OzthQUdGLHFCQUFZeDRDLENBQVosRUFBZTtRQUNiLHdCQUFrQ0EsQ0FBQyxDQUFDK0UsTUFBRixDQUFTdzBILE9BQTNDO1lBQVFKLFFBQVIscUJBQVFBLFFBQVI7WUFBa0JDLFdBQWxCLHFCQUFrQkEsV0FBbEI7O1FBQ0EsSUFBTUksWUFBWSxHQUFHLEtBQUtsQixRQUFMLENBQWN6N0csT0FBZCxDQUFzQixLQUFLamIsS0FBTCxDQUFXdTNILFFBQVgsRUFBcUJDLFdBQXJCLENBQXRCLENBQXJCLENBRmE7OztRQUliLElBQU1LLFNBQVMsR0FBR0QsWUFBWSxLQUFLLENBQUMsQ0FBbEIsR0FBc0IsQ0FBdEIsR0FBMEIsQ0FBQ0EsWUFBWSxHQUFHLENBQWhCLElBQXFCLEtBQUtsQixRQUFMLENBQWMxMEgsTUFBL0U7UUFFQSxLQUFLaEMsS0FBTCxDQUFXdTNILFFBQVgsRUFBcUJDLFdBQXJCLElBQW9DLEtBQUtkLFFBQUwsQ0FBY21CLFNBQWQsQ0FBcEM7O1FBRUEsS0FBS3R5RSxXQUFMOztRQUNBLEtBQUszTyxhQUFMOzs7O2FBR0YsdUJBQWM7UUFDWixJQUFNbHRCLEtBQUssR0FBRyxJQUFJbzBCLFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEI7VUFDdENDLE9BQU8sRUFBRSxJQUQ2QjtVQUV0Q0MsUUFBUSxFQUFFLElBRjRCO1VBR3RDQyxNQUFNLEVBQUU7WUFBRWorQyxLQUFLLEVBQUUsS0FBS0E7O1NBSFYsQ0FBZDtRQU1BLEtBQUttK0MsYUFBTCxDQUFtQnowQixLQUFuQjs7OztXQTNORixlQUF3QjtRQUN0QixPQUFPO1VBQ0w0ekIsS0FBSyxFQUFFO1lBQUU5NkMsSUFBSSxFQUFFaVE7V0FEVjtVQUVMK3FDLE1BQU0sRUFBRTtZQUFFaDdDLElBQUksRUFBRWlRO1dBRlg7VUFHTGtrSCxPQUFPLEVBQUU7WUFBRW4wSCxJQUFJLEVBQUVpUTtXQUhaO1VBSUxta0gsSUFBSSxFQUFFO1lBQUVwMEgsSUFBSSxFQUFFaVE7V0FKVDs7O1VBT0wyRyxPQUFPLEVBQUU7WUFBRTVXLElBQUksRUFBRW1GO1dBUFo7VUFRTDNILEtBQUssRUFBRTtZQUFFd0MsSUFBSSxFQUFFbUY7V0FSVjtVQVNMb2hDLEtBQUssRUFBRTtZQUFFdm1DLElBQUksRUFBRWl6Qzs7U0FUakI7Ozs7V0FhRixlQUFvQjtRQUNsQixPQUFPZixHQUFQLGtZQVd3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQVg3QixFQVl3QkEsS0FBSyxDQUFDLG1CQUFELENBWjdCOzs7OztJQWhCbUIvRDs7RUFnT3ZCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUN5eUcsUUFBbkM7Ozs7TUMxT01xQjs7Ozs7SUFzREoseUJBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtwM0MsT0FBTCxHQUFlLEtBQWY7TUFDQSxNQUFLMWdGLEtBQUwsR0FBYSxFQUFiO01BRUEsTUFBSyszSCxLQUFMLEdBQWEsQ0FBYjtNQUNBLE1BQUtDLEtBQUwsR0FBYSxDQUFiO01BRUEsTUFBS3IySCxJQUFMLEdBQVksTUFBS0EsSUFBTCxDQUFVOE4sSUFBViwrQkFBWjtNQVRZOzs7OzthQVlkLGtCQUFTO1FBQUE7O1FBQ1AsT0FBTzBQLEdBQVAsMk9BR2EsS0FBSzY0RyxLQUhsQixFQUljLEtBQUtELEtBSm5CLEVBUU0sS0FBSy8zSCxLQUFMLENBQVcwZ0IsR0FBWCxDQUFlLFVBQUN5UCxLQUFELEVBQVc7VUFDMUIsT0FBT2hSLEdBQVAsZ0tBRWMsVUFBQS9nQixDQUFDO1lBQUEsT0FBSSxNQUFJLENBQUM2NUgsWUFBTCxDQUFrQjluRyxLQUFLLENBQUMrbkcsTUFBeEIsQ0FBSjtXQUZmLEVBR0svbkcsS0FBSyxDQUFDbzhFLEtBSFg7U0FEQSxDQVJOOzs7O2FBb0JGLGNBQUtudUcsQ0FBTCxFQUFRO1FBQ04sS0FBS3NpRixPQUFMLEdBQWUsSUFBZjtRQUVBM2hGLFFBQVEsQ0FBQ2lyQixnQkFBVCxDQUEwQixPQUExQixFQUFtQyxLQUFLcm9CLElBQXhDO1FBQ0EsS0FBS28ySCxLQUFMLEdBQWEzNUgsQ0FBQyxDQUFDdWdELE9BQWY7UUFDQSxLQUFLcTVFLEtBQUwsR0FBYTU1SCxDQUFDLENBQUN5Z0QsT0FBZjtRQUVBLEtBQUtqSSxhQUFMO1FBQ0EsS0FBS2lNLFNBQUwsQ0FBZTV4QixHQUFmLENBQW1CLE1BQW5COzs7O2FBR0YsZ0JBQU87UUFDTCxLQUFLeXZELE9BQUwsR0FBZSxLQUFmO1FBRUEzaEYsUUFBUSxDQUFDczBDLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLEtBQUsxeEMsSUFBM0M7UUFFQSxLQUFLa2hELFNBQUwsQ0FBZTNVLE1BQWYsQ0FBc0IsTUFBdEIsRUFMSzs7OzthQVVQLHNCQUFhZ3FGLE1BQWIsRUFBcUI7UUFDbkIsSUFBTXh1RyxLQUFLLEdBQUcsSUFBSW8wQixXQUFKLENBQWdCLE9BQWhCLEVBQXlCO1VBQ3JDQyxPQUFPLEVBQUUsSUFENEI7VUFFckNDLFFBQVEsRUFBRSxJQUYyQjtVQUdyQ0MsTUFBTSxFQUFFO1lBQUVqK0MsS0FBSyxFQUFFazRIOztTQUhMLENBQWQ7UUFNQSxLQUFLLzVFLGFBQUwsQ0FBbUJ6MEIsS0FBbkI7Ozs7V0FsSEYsZUFBd0I7UUFDdEIsT0FBTztVQUNMMXBCLEtBQUssRUFBRTtZQUFFd0MsSUFBSSxFQUFFbUY7V0FEVjs7U0FBUDs7OztXQUtGLGVBQW9CO1FBQ2xCLE9BQU8rc0MsR0FBUCxzK0JBNkJpQm9MLFFBN0JqQjs7Ozs7SUFSd0I5RDs7RUF1SDVCaUQsY0FBYyxDQUFDajdCLE1BQWYsQ0FBc0IsaUJBQXRCLEVBQXlDOHpHLGFBQXpDOzs7O01DdEhNSzs7Ozs7SUFnSEosc0JBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtuNEgsS0FBTCxHQUFhLElBQWI7TUFDQSxNQUFLczlDLEtBQUwsR0FBYSxHQUFiO01BQ0EsTUFBS0UsTUFBTCxHQUFjLEdBQWQ7TUFFQSxNQUFLNDZFLGNBQUwsR0FBc0IsSUFBdEI7TUFQWTs7Ozs7YUFVZCxxQkFBWTdzRyxJQUFaLEVBQWtCK1UsS0FBbEIsRUFBeUI7UUFBQTs7UUFDdkIsSUFBSSxDQUFDL1UsSUFBTCxFQUFXO1VBQ1QsT0FBTzJnQixHQUFQOzs7UUFHRixJQUFNeXVCLE9BQU8sR0FBRztVQUNkMDlELFNBQVMsRUFBRzlzRyxJQUFJLENBQUMvb0IsSUFBTCxLQUFjLFdBRFo7VUFFZG9HLElBQUksRUFBRzAzQixLQUFLLEtBQUs7U0FGbkI7UUFLQSxPQUFPbmhCLEdBQVAsNmRBR3FCbWhCLEtBQUssR0FBRyxFQUg3QixFQUthaWlCLEdBQVEsQ0FBQ29ZLE9BQUQsQ0FMckIsRUFNYyxVQUFBdjhELENBQUM7VUFBQSxPQUFJLE1BQUksQ0FBQ2s2SCxZQUFMLENBQWtCbDZILENBQWxCLEVBQXFCbXRCLElBQXJCLENBQUo7U0FOZixFQVl1QkEsSUFBSSxDQUFDL29CLElBQUwsS0FBYyxXQUFkLEdBQTRCLEVBQTVCLEdBQWlDLENBWnhELEVBYVUrb0IsSUFBSSxDQUFDOW9CLElBYmYsRUFnQkk4b0IsSUFBSSxDQUFDL29CLElBQUwsS0FBYyxXQUFkLEdBQ0EyYyxHQURBLGdMQUlRb00sSUFBSSxDQUFDcXNDLFFBQUwsQ0FBY2wzQyxHQUFkLENBQWtCLFVBQUErcEMsS0FBSztVQUFBLE9BQUksTUFBSSxDQUFDOHRFLFdBQUwsQ0FBaUI5dEUsS0FBakIsRUFBd0JucUIsS0FBSyxHQUFHLENBQWhDLENBQUo7U0FBdkIsQ0FKUixJQVFBNEwsR0F4Qko7Ozs7YUE0QkYsa0JBQVM7UUFDUCxPQUFPL3NCLEdBQVAsOE5BRWEsS0FBS20rQixLQUZsQixFQUdjLEtBQUtFLE1BSG5CLEVBTVEsS0FBSys2RSxXQUFMLENBQWlCLEtBQUt2NEgsS0FBdEIsRUFBNkIsQ0FBN0IsQ0FOUjs7OzthQVlGLHNCQUFhNUIsQ0FBYixFQUFnQm10QixJQUFoQixFQUFzQjtRQUNwQm50QixDQUFDLENBQUM0aUQsZUFBRjs7UUFFQSxJQUFJejFCLElBQUksQ0FBQy9vQixJQUFMLEtBQWMsV0FBbEIsRUFBK0I7VUFDN0JwRSxDQUFDLENBQUNvNkgsYUFBRixDQUFnQjMxRSxTQUFoQixDQUEwQnYzQixNQUExQixDQUFpQyxNQUFqQztTQURGLE1BRU87VUFDTCxJQUFJLEtBQUs4c0csY0FBVCxFQUF5QjtZQUN2QixLQUFLQSxjQUFMLENBQW9CdjFFLFNBQXBCLENBQThCdjNCLE1BQTlCLENBQXFDLFFBQXJDOzs7VUFHRmx0QixDQUFDLENBQUNvNkgsYUFBRixDQUFnQjMxRSxTQUFoQixDQUEwQnYzQixNQUExQixDQUFpQyxRQUFqQztVQUNBLEtBQUs4c0csY0FBTCxHQUFzQmg2SCxDQUFDLENBQUNvNkgsYUFBeEI7O1VBRUEsS0FBS0MsYUFBTCxDQUFtQmx0RyxJQUFuQjs7Ozs7YUFJSix1QkFBY0EsSUFBZCxFQUFvQjtRQUNsQixJQUFNN0IsS0FBSyxHQUFHLElBQUlvMEIsV0FBSixDQUFnQixPQUFoQixFQUF5QjtVQUNyQ0MsT0FBTyxFQUFFLElBRDRCO1VBRXJDQyxRQUFRLEVBQUUsSUFGMkI7VUFHckNDLE1BQU0sRUFBRTtZQUFFaitDLEtBQUssRUFBRXVyQjs7U0FITCxDQUFkO1FBTUEsS0FBSzR5QixhQUFMLENBQW1CejBCLEtBQW5COzs7O1dBcE1GLGVBQXdCO1FBQ3RCLE9BQU87VUFDTDR6QixLQUFLLEVBQUU7WUFBRTk2QyxJQUFJLEVBQUVpUTtXQURWO1VBRUwrcUMsTUFBTSxFQUFFO1lBQUVoN0MsSUFBSSxFQUFFaVE7V0FGWDtVQUdMelMsS0FBSyxFQUFFO1lBQUV3QyxJQUFJLEVBQUVsRTs7U0FIakI7Ozs7V0FPRixlQUFvQjtRQUNsQixPQUFPbzJDLEdBQVAseWxFQUt3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQUw3QixFQVMwQkEsS0FBSyxDQUFDLG1CQUFELENBVC9CLEVBbUJpQkQsUUFuQmpCLEVBMEQwQkMsS0FBSyxDQUFDLG1CQUFELENBMUQvQixFQStEMEJBLEtBQUssQ0FBQyxtQkFBRCxDQS9EL0IsRUFvRjRCRSxVQXBGNUIsRUFnRzRCQyxTQWhHNUI7Ozs7O0lBVnFCbEU7O0VBeU16QmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLGNBQXRCLEVBQXNDbTBHLFVBQXRDOzs7O01DMU1NTzs7Ozs7SUE4RUosdUJBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUtwN0UsS0FBTCxHQUFhLEVBQWI7TUFDQSxNQUFLRSxNQUFMLEdBQWMsRUFBZDtNQUNBLE1BQUt4OUMsS0FBTCxHQUFhLElBQWI7TUFDQSxNQUFLeWhHLE9BQUwsR0FBZSxFQUFmO01BQ0EsTUFBS2g2RCxLQUFMLEdBQWE3bUMsU0FBYjtNQUVBLE1BQUsrM0gsZUFBTCxHQUF1QjtRQUNyQkMsSUFBSSxFQUFFLE1BQUtDLFVBQUwsQ0FBZ0JwcEgsSUFBaEIsK0JBRGU7UUFFckJxcEgsS0FBSyxFQUFFLE1BQUtDLFdBQUwsQ0FBaUJ0cEgsSUFBakIsK0JBRmM7UUFHckIwNUIsSUFBSSxFQUFFLE1BQUs2dkYsVUFBTCxDQUFnQnZwSCxJQUFoQjtPQUhSO01BVFk7Ozs7O1dBbkJkLGVBQVk7UUFDVixPQUFPLEtBQUtveEMsS0FBWjs7V0FORixhQUFVN2dELEtBQVYsRUFBaUI7UUFDZixLQUFLNmdELEtBQUwsR0FBYTdnRCxLQUFiO1FBQ0EsS0FBSzQyQyxhQUFMOzs7O1dBWUYsZUFBYTtRQUNYLE9BQU8sS0FBS2lLLEtBQVo7O1dBTkYsYUFBVzdnRCxLQUFYLEVBQWtCO1FBQ2hCLEtBQUs2Z0QsS0FBTCxHQUFhN2dELEtBQWI7UUFDQSxLQUFLNDJDLGFBQUw7Ozs7V0FPRixhQUFZNTJDLEtBQVosRUFBbUI7UUFDakIsSUFBTStRLE9BQU8sR0FBRy9RLEtBQUssQ0FBQytRLE9BQU4sQ0FBYyxXQUFkLEVBQTJCLEVBQTNCLENBQWhCO1FBQ0EsS0FBS2tvSCxRQUFMLEdBQWdCbG9ILE9BQU8sQ0FBQ3pQLEtBQVIsQ0FBYyxHQUFkLENBQWhCO1FBQ0EsS0FBS3MxQyxhQUFMOzs7O2FBbUJGLG9CQUFXMTZCLElBQVgsRUFBaUI7UUFBQTs7UUFDZixPQUFPaUQsR0FBUCw4YUFFa0IsS0FBS3NvQixLQUFMLEtBQWUsTUFBZixHQUF3QixRQUF4QixHQUFtQyxFQUZyRCxFQUlldnJCLElBSmYsRUFLZ0JBLElBTGhCLEVBUWtCLFVBQUE5ZCxDQUFDO1VBQUEsT0FBSSxNQUFJLENBQUM4NkgsU0FBTCxDQUFlOTZILENBQWYsRUFBa0IsTUFBbEIsQ0FBSjtTQVJuQixFQVNtQixVQUFBQSxDQUFDO1VBQUEsT0FBSSxNQUFJLENBQUM4NkgsU0FBTCxDQUFlOTZILENBQWYsRUFBa0IsTUFBbEIsQ0FBSjtTQVRwQixFQVVvQixLQUFLcy9DLG1CQVZ6Qjs7OzthQWlCRixxQkFBWXhoQyxJQUFaLEVBQWtCO1FBQUE7O1FBQ2hCLE9BQU9pRCxHQUFQLGtnQkFFbUIsS0FBS3NvQixLQUFMLEtBQWUsT0FBZixHQUF5QixRQUF6QixHQUFvQyxFQUZ2RCxFQUlldnJCLElBSmYsRUFLZ0JBLElBTGhCLEVBUWtCLFVBQUE5ZCxDQUFDO1VBQUEsT0FBSSxNQUFJLENBQUM4NkgsU0FBTCxDQUFlOTZILENBQWYsRUFBa0IsT0FBbEIsQ0FBSjtTQVJuQixFQVNtQixVQUFBQSxDQUFDO1VBQUEsT0FBSSxNQUFJLENBQUM4NkgsU0FBTCxDQUFlOTZILENBQWYsRUFBa0IsTUFBbEIsQ0FBSjtTQVRwQixFQVVvQixLQUFLcy9DLG1CQVZ6Qjs7OzthQWtCRixvQkFBV3hoQyxJQUFYLEVBQWlCO1FBQUE7O1FBQ2YsT0FBT2lELEdBQVAsb2JBRWtCLEtBQUtzb0IsS0FBTCxLQUFlLE1BQWYsR0FBd0IsUUFBeEIsR0FBbUMsRUFGckQsRUFJZXZyQixJQUpmLEVBS2dCQSxJQUxoQixFQVFrQixVQUFBOWQsQ0FBQztVQUFBLE9BQUksTUFBSSxDQUFDODZILFNBQUwsQ0FBZTk2SCxDQUFmLEVBQWtCLE1BQWxCLENBQUo7U0FSbkIsRUFTbUIsVUFBQUEsQ0FBQztVQUFBLE9BQUksTUFBSSxDQUFDODZILFNBQUwsQ0FBZTk2SCxDQUFmLEVBQWtCLE1BQWxCLENBQUo7U0FUcEIsRUFVb0IsS0FBS3MvQyxtQkFWekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQTJERixrQkFBUztRQUFBOztRQUNQLElBQU14aEMsSUFBSSxHQUFHLEtBQUsya0MsS0FBTCxHQUFhLENBQTFCO1FBRUEsT0FBTzFoQyxHQUFQLDhGQUNJLEtBQUs4NUcsUUFBTCxDQUFjdjRHLEdBQWQsQ0FBa0IsVUFBQWxlLElBQUksRUFBSTtVQUMxQixPQUFPLE1BQUksQ0FBQ20ySCxlQUFMLENBQXFCbjJILElBQXJCLEVBQTJCMFosSUFBM0IsQ0FBUDtTQURBLENBREo7Ozs7YUFPRixtQkFBVTlkLENBQVYsRUFBYTRCLEtBQWIsRUFBb0I7UUFDbEI1QixDQUFDLENBQUM4OUMsY0FBRjtRQUNBOTlDLENBQUMsQ0FBQzRpRCxlQUFGOztRQUVBLElBQUksS0FBS3ZaLEtBQUwsS0FBZXpuQyxLQUFuQixFQUEwQjtVQUN4QixLQUFLeW5DLEtBQUwsR0FBYXpuQyxLQUFiO1VBRUEsSUFBTWloRCxXQUFXLEdBQUcsSUFBSW5ELFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEI7WUFDNUNDLE9BQU8sRUFBRSxJQURtQztZQUU1Q0MsUUFBUSxFQUFFLElBRmtDO1lBRzVDQyxNQUFNLEVBQUU7Y0FBRWorQyxLQUFLLEVBQUUsS0FBS3luQzs7V0FISixDQUFwQjtVQU1BLEtBQUswVyxhQUFMLENBQW1COEMsV0FBbkI7VUFDQSxLQUFLckssYUFBTDs7Ozs7V0F0TkosZUFBd0I7UUFDdEIsT0FBTztVQUNMMEcsS0FBSyxFQUFFO1lBQ0w5NkMsSUFBSSxFQUFFaVE7V0FGSDtVQUlMK3FDLE1BQU0sRUFBRTtZQUNOaDdDLElBQUksRUFBRWlRO1dBTEg7VUFPTGd2RixPQUFPLEVBQUUsRUFQSjtVQVFMaDZELEtBQUssRUFBRTtZQUNMamxDLElBQUksRUFBRVg7V0FUSDtVQVdMN0IsS0FBSyxFQUFFO1NBWFQ7Ozs7V0FlRixlQUFvQjtRQUNsQixPQUFPMDBDLEdBQVAsOHJCQWF3QnFMLEtBQUssQ0FBQyxtQkFBRCxDQWI3QixFQWN3QkEsS0FBSyxDQUFDLG1CQUFELENBZDdCLEVBbUJ3QkEsS0FBSyxDQUFDLG1CQUFELENBbkI3QixFQXVCWUEsS0FBSyxDQUFDLHFCQUFELENBdkJqQixFQTJCWUEsS0FBSyxDQUFDLHFCQUFELENBM0JqQixFQStCWUEsS0FBSyxDQUFDLHFCQUFELENBL0JqQjs7Ozs7SUFsQnNCL0Q7O0VBNk4xQmlELGNBQWMsQ0FBQ2o3QixNQUFmLENBQXNCLGNBQXRCLEVBQXNDMDBHLFdBQXRDOzs7O01DN05NUzs7Ozs7SUF3RUosb0JBQWM7TUFBQTs7TUFBQTs7TUFDWjtNQUVBLE1BQUs3N0UsS0FBTCxHQUFhLEVBQWI7TUFDQSxNQUFLcUQsTUFBTCxHQUFjLEtBQWQ7TUFKWTs7Ozs7V0F0QmQsZUFBWTtRQUNWLE9BQU8sS0FBS0UsS0FBWjs7V0FORixhQUFVN2dELEtBQVYsRUFBaUI7UUFDZixLQUFLNmdELEtBQUwsR0FBYTdnRCxLQUFiO1FBQ0EsS0FBSzQyQyxhQUFMOzs7O1dBWUYsZUFBYTtRQUNYLE9BQU8sS0FBS2lLLEtBQVo7OztXQU5GLGFBQVc3Z0QsS0FBWCxFQUFrQjtRQUNoQixLQUFLNmdELEtBQUwsR0FBYTdnRCxLQUFiO1FBQ0EsS0FBSzQyQyxhQUFMOzs7O1dBUUYsZUFBWTtRQUNWLE9BQU8sS0FBSytKLE1BQVo7O1dBR0YsYUFBVUEsTUFBVixFQUFrQjtRQUNoQixLQUFLQSxNQUFMLEdBQWNBLE1BQWQ7Ozs7YUFXRixrQkFBUztRQUNQLElBQU16a0MsSUFBSSxHQUFHLEtBQUsya0MsS0FBTCxHQUFhLENBQTFCO1FBRUEsT0FBTzFoQyxHQUFQLDRkQUdlLEtBQUt3aEMsTUFBTCxHQUFjLFFBQWQsR0FBeUIsRUFIeEMsRUFLaUJ6a0MsSUFMakIsRUFNa0JBLElBTmxCLEVBU29CLEtBQUtnOUcsU0FUekIsRUFVcUIsS0FBS0EsU0FWMUIsRUFXc0IsS0FBS3g3RSxtQkFYM0I7Ozs7YUFtQkYsbUJBQVV0L0MsQ0FBVixFQUFhO1FBQ1hBLENBQUMsQ0FBQzg5QyxjQUFGO1FBQ0E5OUMsQ0FBQyxDQUFDNGlELGVBQUY7UUFFQSxLQUFLTCxNQUFMLEdBQWMsQ0FBQyxLQUFLQSxNQUFwQjtRQUVBLElBQU1NLFdBQVcsR0FBRyxJQUFJbkQsV0FBSixDQUFnQixRQUFoQixFQUEwQjtVQUM1Q0MsT0FBTyxFQUFFLElBRG1DO1VBRTVDQyxRQUFRLEVBQUUsSUFGa0M7VUFHNUNDLE1BQU0sRUFBRTtZQUFFaitDLEtBQUssRUFBRSxLQUFLMmdEOztTQUhKLENBQXBCO1FBTUEsS0FBS3hDLGFBQUwsQ0FBbUI4QyxXQUFuQjtRQUNBLEtBQUtySyxhQUFMOzs7O1dBbEhGLGVBQXdCO1FBQ3RCLE9BQU87VUFDTDBHLEtBQUssRUFBRTtZQUNMOTZDLElBQUksRUFBRWlRO1dBRkg7VUFJTCtxQyxNQUFNLEVBQUU7WUFDTmg3QyxJQUFJLEVBQUVpUTtXQUxIO1VBT0xrdUMsTUFBTSxFQUFFO1lBQ05uK0MsSUFBSSxFQUFFaXpDLE9BREE7WUFFTlEsT0FBTyxFQUFFO1dBVE47VUFXTGoyQyxLQUFLLEVBQUU7WUFDTHdDLElBQUksRUFBRWl6Qzs7U0FaVjs7OztXQWlCRixlQUFvQjtRQUNsQixPQUFPZixHQUFQLHVpQkFhd0JxTCxLQUFLLENBQUMsbUJBQUQsQ0FiN0IsRUFjd0JBLEtBQUssQ0FBQyxtQkFBRCxDQWQ3QixFQW1Cd0JBLEtBQUssQ0FBQyxtQkFBRCxDQW5CN0IsRUFvQllBLEtBQUssQ0FBQyxxQkFBRCxDQXBCakI7Ozs7O0lBcEJtQi9EOztFQXVIdkJpRCxjQUFjLENBQUNqN0IsTUFBZixDQUFzQixXQUF0QixFQUFtQ20xRyxRQUFuQzs7O0VDekhlLG1CQUFXOzs7Ozs7Ozs7Ozs7O0lBaUJ4QixPQUFPaDZHLENBQVAsb3REQVNlLFVBQUEvZ0IsQ0FBQyxFQUFJO01BQ2QsSUFBTWc3SCxPQUFPLEdBQUdyNkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWhCO01BQ0FvekUsT0FBTyxDQUFDcDVILEtBQVIsR0FBZ0I1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQVQsQ0FBZTBnQixHQUFmLENBQW1CLFVBQUFzMkcsR0FBRztRQUFBLE9BQUlBLEdBQUcsQ0FBQ3AxSCxJQUFKLENBQVMsSUFBVCxDQUFKO09BQXRCLEVBQTBDQSxJQUExQyxDQUErQyxJQUEvQyxDQUFoQjtLQVhOLEVBbUNnQixVQUFBeEQsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBckNSLEVBZ0RnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBbERSLEVBNkRnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUN6QyxJQUFYLEdBQWtCeDRILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBM0I7S0EvRFIsRUEwRWdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzFDLE9BQVgsR0FBcUJ2NEgsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE5QjtLQTVFUixFQW9GaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNkLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0EzM0IsT0FBTyxDQUFDdGEsR0FBUixDQUFZM1YsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFyQjtNQUNBcTVILFVBQVUsQ0FBQ2pnSCxPQUFYLEdBQXFCelAsSUFBSSxDQUFDaXNDLEtBQUwsQ0FBV3gzQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXBCLENBQXJCO0tBdkZSLEVBK0ZnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUN0d0YsS0FBWCxHQUFtQixJQUFuQjtLQWpHUjtFQXNHRDs7O0VDdkhjLHNCQUFXO0lBQ3hCLE9BQU81cEIsQ0FBUCxnekNBV2UsVUFBQS9nQixDQUFDLEVBQUk7TUFDZCxJQUFNZzdILE9BQU8sR0FBR3I2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixtQkFBdkIsQ0FBaEI7TUFFQSxJQUFJb04sR0FBRyxHQUFHLEdBQVY7O01BQ0EsS0FBSyxJQUFJM3dELElBQVQsSUFBaUJyRSxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTFCLEVBQWlDO1FBQy9Cb3pELEdBQUcsa0JBQVczd0QsSUFBWCxpQkFBcUJyRSxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQVQsQ0FBZXlDLElBQWYsQ0FBckIsUUFBSDs7O01BRUYyd0QsR0FBRyxJQUFJLEtBQVA7TUFFQWdtRSxPQUFPLENBQUNwNUgsS0FBUixHQUFnQm96RCxHQUFoQjtLQXBCTixFQTZDZ0IsVUFBQWgxRCxDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixpQkFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBL0NSLEVBMERnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNzdFLE1BQVgsR0FBb0JwL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE3QjtLQTVEUixFQW9FaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNkLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGlCQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzlzQixLQUFYLEdBQW1CbnVHLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBNUI7S0F0RVI7RUEyRUQ7OztFQzVFYyxpQkFBWTtJQUN6QixPQUFPbWYsQ0FBUCw0L0JBU2MsVUFBQS9nQixDQUFDLEVBQUk7TUFDYixJQUFNazdILE1BQU0sR0FBR3Y2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixhQUF2QixDQUFmO01BQ0FzekUsTUFBTSxDQUFDMzRFLE1BQVAsR0FBZ0IsSUFBaEI7S0FYTixFQTZCZ0IsVUFBQXZpRCxDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixZQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQy83RSxLQUFYLEdBQW1CbC9DLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBNUI7S0EvQlIsRUEwQ2dCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixZQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzc3RSxNQUFYLEdBQW9CcC9DLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBN0I7S0E1Q1IsRUFtRGdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixZQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzE0RSxNQUFYLEdBQW9CLElBQXBCO0tBckRSO0VBMEREOzs7RUMzRGMsbUJBQVk7SUFDekIsSUFBSTQ0RSxjQUFKO0lBQ0EsSUFBSUMsY0FBSjtJQUNBLElBQUlDLGdCQUFKO0lBRUEsT0FBT3Q2RyxDQUFQLDg2REFXYyxVQUFBL2dCLENBQUMsRUFBSTtNQUNiLElBQU1rN0gsTUFBTSxHQUFHdjZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGVBQXZCLENBQWY7TUFDQXN6RSxNQUFNLENBQUMzNEUsTUFBUCxHQUFnQixJQUFoQjtNQUVBb0wsWUFBWSxDQUFDd3RFLGNBQUQsQ0FBWjtNQUNBLElBQU1HLE1BQU0sR0FBRzM2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixxQkFBdkIsQ0FBZjtNQUNBMHpFLE1BQU0sQ0FBQzE1SCxLQUFQLEdBQWU1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXhCO01BQ0F1NUgsY0FBYyxHQUFHbnZHLFVBQVUsQ0FBQztRQUFBLE9BQU1zdkcsTUFBTSxDQUFDMTVILEtBQVAsR0FBZSxFQUFyQjtPQUFELEVBQTBCLEdBQTFCLENBQTNCO0tBbEJOLEVBb0JjLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNazdILE1BQU0sR0FBR3Y2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixlQUF2QixDQUFmO01BQ0FzekUsTUFBTSxDQUFDMzRFLE1BQVAsR0FBZ0IsSUFBaEI7TUFFQW9MLFlBQVksQ0FBQ3l0RSxjQUFELENBQVo7TUFDQSxJQUFNRSxNQUFNLEdBQUczNkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIscUJBQXZCLENBQWY7TUFDQTB6RSxNQUFNLENBQUMxNUgsS0FBUCxHQUFlNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUF4QjtNQUNBdzVILGNBQWMsR0FBR3B2RyxVQUFVLENBQUM7UUFBQSxPQUFNc3ZHLE1BQU0sQ0FBQzE1SCxLQUFQLEdBQWUsRUFBckI7T0FBRCxFQUEwQixHQUExQixDQUEzQjtLQTNCTixFQTZCZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNmLElBQU1rN0gsTUFBTSxHQUFHdjZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGlCQUF2QixDQUFmO01BQ0FzekUsTUFBTSxDQUFDMzRFLE1BQVAsR0FBZ0IsSUFBaEI7TUFFQW9MLFlBQVksQ0FBQzB0RSxnQkFBRCxDQUFaO01BQ0EsSUFBTUMsTUFBTSxHQUFHMzZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLHVCQUF2QixDQUFmO01BQ0EwekUsTUFBTSxDQUFDMTVILEtBQVAsR0FBZTVCLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBeEI7TUFDQXk1SCxnQkFBZ0IsR0FBR3J2RyxVQUFVLENBQUM7UUFBQSxPQUFNc3ZHLE1BQU0sQ0FBQzE1SCxLQUFQLEdBQWUsRUFBckI7T0FBRCxFQUEwQixHQUExQixDQUE3QjtLQXBDTixFQWtFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDLzdFLEtBQVgsR0FBbUJsL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQXBFUixFQStFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNzdFLE1BQVgsR0FBb0JwL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE3QjtLQWpGUixFQXlGaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNkLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDcjVILEtBQVgsR0FBbUI1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBM0ZSLEVBbUdpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNqNUUsSUFBWCxHQUFrQmhpRCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTNCO0tBckdSLEVBNEdpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNoNUUsUUFBWCxHQUFzQmppRCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQS9CO0tBOUdSO0VBbUhEOzs7O0VDdkhELElBQU0yNUgsV0FBVywrQ0FBakI7QUFLQSxFQUFlLG1CQUFZO0lBQ3pCLE9BQU94NkcsQ0FBUCxpN0NBU2F3NkcsV0FUYixFQVVlLFVBQUF2N0gsQ0FBQyxFQUFJO01BQ2QsSUFBTWs3SCxNQUFNLEdBQUd2NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWY7TUFDQXN6RSxNQUFNLENBQUN0NUgsS0FBUCxHQUFlNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUF4QjtLQVpOLEVBK0JnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBakNSLEVBNENnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBOUNSLEVBeURnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUN2NUUsUUFBWCxHQUFzQjFoRCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQS9CO0tBM0RSLEVBa0VlMjVILFdBbEVmLEVBbUVpQixVQUFBdjdILENBQUMsRUFBSTtNQUNkLElBQU13N0gsT0FBTyxHQUFHNzZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQWhCO01BQ0E0ekUsT0FBTyxDQUFDNTVILEtBQVIsR0FBZ0I1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXpCO0tBckVSO0VBMkVEOzs7RUNsRmMsbUJBQVk7SUFDekIsT0FBT21mLENBQVAsdXpEQVVjLFVBQUEvZ0IsQ0FBQyxFQUFJO01BQ2IsSUFBTWs3SCxNQUFNLEdBQUd2NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZUFBdkIsQ0FBZjtNQUNBc3pFLE1BQU0sQ0FBQ3Q1SCxLQUFQLEdBQWU1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXhCO0tBWk4sRUFjZSxVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWs3SCxNQUFNLEdBQUd2NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWY7TUFDQXN6RSxNQUFNLENBQUN0NUgsS0FBUCxHQUFlNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUF4QjtLQWhCTixFQXNDZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDLzdFLEtBQVgsR0FBbUJsL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQXhDUixFQW1EZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNzdFLE1BQVgsR0FBb0JwL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE3QjtLQXJEUixFQStEZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDcHpILEdBQVgsR0FBaUI3SCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTFCO0tBakVSLEVBMkVnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNsekgsR0FBWCxHQUFpQi9ILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBMUI7S0E3RVIsRUFxRmdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3I1SCxLQUFYLEdBQW1CNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQXZGUixFQStGaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNkLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDOTBFLE9BQVgsR0FBcUJubUQsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE5QjtLQWpHUjtFQXNHRDs7O0VDdkdjLG1CQUFXO0lBQ3hCLE9BQU9tZixDQUFQLDJzRUFTYyxVQUFBL2dCLENBQUMsRUFBSTtNQUNiLElBQU15N0gsUUFBUSxHQUFHOTZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGVBQXZCLENBQWpCO01BQ0E2ekUsUUFBUSxDQUFDNzVILEtBQVQsR0FBaUI1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTFCO0tBWE4sRUFhZSxVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTXk3SCxRQUFRLEdBQUc5NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWpCO01BQ0E2ekUsUUFBUSxDQUFDNzVILEtBQVQsR0FBaUI1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTFCO0tBZk4sRUFrQ2dCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3I1SCxLQUFYLEdBQW1CNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQXBDUixFQStDZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDLzdFLEtBQVgsR0FBbUJsL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQWpEUixFQTREZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNzdFLE1BQVgsR0FBb0JwL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE3QjtLQTlEUixFQXdFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDcHpILEdBQVgsR0FBaUI3SCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTFCO0tBMUVSLEVBb0ZnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNsekgsR0FBWCxHQUFpQi9ILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBMUI7S0F0RlIsRUE4RmdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3R5RSxXQUFYLEdBQXlCM29ELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBbEM7S0FoR1IsRUFxR2dCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3R5RSxXQUFYLEdBQXlCM29ELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBbEM7S0F2R1IsRUE4R2lCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3J5RSxhQUFYLEdBQTJCNW9ELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBcEM7S0FoSFIsRUF3SGlCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3I5RyxLQUFYLEdBQW1CNWQsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQTFIUjtFQWdJRDs7O0VDakljLGlCQUFZO0lBQ3pCLE9BQU9tZixDQUFQLHl3REFXZSxVQUFBL2dCLENBQUMsRUFBSTtNQUNkLElBQU1rN0gsTUFBTSxHQUFHdjZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQWY7TUFDQXN6RSxNQUFNLENBQUN0NUgsS0FBUCxHQUFlNUIsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUF4QjtLQWJOLEVBc0NnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsWUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBeENSLEVBbURnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsWUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBckRSLEVBNERpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsWUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNyNUgsS0FBWCxHQUFtQjVCLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBNUI7S0E5RFIsRUFxRWlCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixZQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ2hLLFFBQVgsR0FBc0JqeEgsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUEvQjtLQXZFUjtFQTRFRDs7O0VDN0VjLG1CQUFZO0lBQ3pCLE9BQU9tZixDQUFQLHNoQ0FTZSxVQUFBL2dCLENBQUMsRUFBSTtNQUNkLElBQU1rN0gsTUFBTSxHQUFHdjZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGdCQUF2QixDQUFmO01BQ0FzekUsTUFBTSxDQUFDMzRFLE1BQVAsR0FBZ0J2aUQsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUF6QjtLQVhOLEVBNkJnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBL0JSLEVBMENnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBNUNSLEVBbURpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMxNEUsTUFBWCxHQUFvQnZpRCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBckRSO0VBMEREOzs7RUMzRGMsbUJBQVk7O0lBRXpCb3FCLFVBQVUsQ0FBQyxZQUFNO01BQ2YsSUFBTTB2RyxPQUFPLEdBQUcvNkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZUFBdkIsQ0FBaEI7TUFDQSxJQUFNK3pFLFdBQVcsR0FBR2g3SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixlQUF2QixDQUFwQjtNQUNBLElBQU1nMEUsSUFBSSxHQUFHLEVBQWI7TUFFQTEzRixXQUFXLENBQUMsWUFBTTtRQUNoQixJQUFJMDNGLElBQUksQ0FBQ2g0SCxNQUFMLEdBQWMsRUFBbEIsRUFBc0I7VUFDcEIsSUFBTWk0SCxXQUFXLEdBQUd0OEgsSUFBSSxDQUFDb0ksS0FBTCxDQUFXcEksSUFBSSxDQUFDK0MsTUFBTCxLQUFnQnM1SCxJQUFJLENBQUNoNEgsTUFBaEMsQ0FBcEI7VUFDQWc0SCxJQUFJLENBQUM1bkcsTUFBTCxDQUFZNm5HLFdBQVosRUFBeUIsQ0FBekI7OztRQUdGLElBQU0xOUUsTUFBTSxHQUFHdTlFLE9BQU8sQ0FBQ3Y5RSxNQUF2QjtRQUNBLElBQU1DLE1BQU0sR0FBR3M5RSxPQUFPLENBQUN0OUUsTUFBdkI7UUFFQSxJQUFNanVDLENBQUMsR0FBRzVRLElBQUksQ0FBQytDLE1BQUwsTUFBaUI2N0MsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFuQyxJQUEwQ0EsTUFBTSxDQUFDLENBQUQsQ0FBMUQ7UUFDQSxJQUFNL3RDLENBQUMsR0FBRzdRLElBQUksQ0FBQytDLE1BQUwsTUFBaUI4N0MsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFuQyxJQUEwQ0EsTUFBTSxDQUFDLENBQUQsQ0FBMUQ7UUFDQXc5RSxJQUFJLENBQUNqNUgsSUFBTCxDQUFVO1VBQUV3TixDQUFGO1VBQUtDO1NBQWY7UUFFQXNySCxPQUFPLENBQUM5NUgsS0FBUixHQUFnQmc2SCxJQUFoQjtRQUNBRCxXQUFXLENBQUMvNUgsS0FBWixHQUFvQjJKLElBQUksQ0FBQ0UsU0FBTCxDQUFlbXdILElBQWYsRUFBcUIsSUFBckIsRUFBMkIsQ0FBM0IsQ0FBcEI7T0FkUyxFQWVSLEdBZlEsQ0FBWDtLQUxRLEVBcUJQLEdBckJPLENBQVY7SUF1QkEsT0FBTzc2RyxDQUFQLHdqSUFvQmdCLFVBQUEvZ0IsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBdEJSLEVBaUNnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBbkNSLEVBMkNpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZUFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM5OEUsTUFBWCxHQUFvQjV5QyxJQUFJLENBQUNpc0MsS0FBTCxDQUFXeDNDLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBcEIsQ0FBcEI7S0E3Q1IsRUFxRGlCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixlQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzc4RSxNQUFYLEdBQW9CN3lDLElBQUksQ0FBQ2lzQyxLQUFMLENBQVd4M0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFwQixDQUFwQjtLQXZEUixFQXFFaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNkLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGlCQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQy9FLGFBQVgsR0FBMkJsMkgsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFwQztLQXZFUixFQTZFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGlCQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3I1SCxLQUFYLEdBQW1CMkosSUFBSSxDQUFDRSxTQUFMLENBQWV6TCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXhCLEVBQStCLElBQS9CLEVBQXFDLENBQXJDLENBQW5CO0tBL0VSLEVBc0ZpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDOUUsYUFBWCxHQUEyQm4ySCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXBDO0tBeEZSLEVBK0ZpQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5COztNQUNBLElBQUk1bkQsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFULEtBQW1CLElBQXZCLEVBQTZCO1FBQzNCcTVILFVBQVUsQ0FBQzNFLGVBQVgsR0FBNkIsd0JBQTdCO09BREYsTUFFTztRQUNMMkUsVUFBVSxDQUFDM0UsZUFBWCxHQUE2QixJQUE3Qjs7S0FwR1Y7RUE4R0Q7OztFQ3ZJYyx3QkFBWTtJQUN6QixJQUFNLzVHLE9BQU8sR0FBRyxDQUNkO01BQUV1OUcsTUFBTSxFQUFFLE1BQVY7TUFBa0IzckIsS0FBSyxFQUFFO0tBRFgsRUFFZDtNQUFFMnJCLE1BQU0sRUFBRSxNQUFWO01BQWtCM3JCLEtBQUssRUFBRTtLQUZYLEVBR2Q7TUFBRTJyQixNQUFNLEVBQUUsUUFBVjtNQUFvQjNyQixLQUFLLEVBQUU7S0FIYixDQUFoQjtJQU1BLE9BQU9wdEYsQ0FBUCwrNkJBR2F4VixJQUFJLENBQUNFLFNBQUwsQ0FBZThRLE9BQWYsQ0FIYixFQUljLFVBQUF2YyxDQUFDLEVBQUk7TUFDYlcsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIscUJBQXZCLEVBQThDckYsTUFBOUMsR0FBdUQsSUFBdkQ7TUFDQTVoRCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QiwyQkFBdkIsRUFBb0RobUQsS0FBcEQsR0FBNEQ1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXJFO0tBTk4sRUFpQm9CLFVBQUE1QixDQUFDLEVBQUk7TUFDbkJBLENBQUMsQ0FBQzg5QyxjQUFGO01BQ0EsSUFBTW05RSxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsb0JBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDYSxJQUFYLENBQWdCOTdILENBQWhCO0tBcEJOLEVBd0NldUwsSUFBSSxDQUFDRSxTQUFMLENBQWU4USxPQUFmLEVBQXdCLElBQXhCLEVBQThCLENBQTlCLENBeENmLEVBeUNpQixVQUFBdmMsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsb0JBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDcjVILEtBQVgsR0FBbUIySixJQUFJLENBQUNpc0MsS0FBTCxDQUFXeDNDLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBcEIsQ0FBbkI7S0EzQ1I7RUFnREQ7OztFQ3ZEYyxxQkFBWTtJQUN6QixJQUFNbTZILElBQUksR0FBRztNQUNYQyxJQUFJLEVBQUUsTUFESztNQUVYMzNILElBQUksRUFBRSxNQUZLO01BR1htMUQsUUFBUSxFQUFFLENBQ1I7UUFDRXdpRSxJQUFJLEVBQUUsWUFEUjtRQUVFMzNILElBQUksRUFBRSxPQUZSO1FBR0VtMUQsUUFBUSxFQUFFLENBQ1I7VUFDRXdpRSxJQUFJLEVBQUUsb0JBRFI7VUFFRTMzSCxJQUFJLEVBQUUsU0FGUjtVQUdFeVosSUFBSSxFQUFFLElBSFI7VUFJRW0rRyxTQUFTLEVBQUUsS0FKYjtVQUtFNzNILElBQUksRUFBRTtTQU5BLEVBUVI7VUFDRTQzSCxJQUFJLEVBQUUsb0JBRFI7VUFFRTMzSCxJQUFJLEVBQUUsU0FGUjtVQUdFeVosSUFBSSxFQUFFLElBSFI7VUFJRW0rRyxTQUFTLEVBQUUsS0FKYjtVQUtFNzNILElBQUksRUFBRTtTQWJBLENBSFo7UUFtQkUwWixJQUFJLEVBQUUsSUFuQlI7UUFvQkUxWixJQUFJLEVBQUU7T0FyQkEsRUF1QlI7UUFDRTQzSCxJQUFJLEVBQUUsY0FEUjtRQUVFMzNILElBQUksRUFBRSxTQUZSO1FBR0V5WixJQUFJLEVBQUUsSUFIUjtRQUlFbStHLFNBQVMsRUFBRSxLQUpiO1FBS0U3M0gsSUFBSSxFQUFFO09BNUJBLEVBOEJSO1FBQ0U0M0gsSUFBSSxFQUFFLGNBRFI7UUFFRTMzSCxJQUFJLEVBQUUsU0FGUjtRQUdFeVosSUFBSSxFQUFFLElBSFI7UUFJRW0rRyxTQUFTLEVBQUUsS0FKYjtRQUtFNzNILElBQUksRUFBRTtPQW5DQSxDQUhDO01BeUNYMFosSUFBSSxFQUFFLElBekNLO01BMENYMVosSUFBSSxFQUFFO0tBMUNSO0lBNkNBLE9BQU8yYyxDQUFQLHNzQkFHYXhWLElBQUksQ0FBQ0UsU0FBTCxDQUFlc3dILElBQWYsQ0FIYixFQUljLFVBQUEvN0gsQ0FBQyxFQUFJO01BQ2IsSUFBTWs4SCxLQUFLLEdBQUd2N0gsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsa0JBQXZCLENBQWQ7TUFDQXMwRSxLQUFLLENBQUMzNUUsTUFBTixHQUFlLElBQWY7TUFFQSxJQUFNNDVFLEtBQUssR0FBR3g3SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1Qix3QkFBdkIsQ0FBZDtNQUNBdTBFLEtBQUssQ0FBQ3Y2SCxLQUFOLEdBQWMySixJQUFJLENBQUNFLFNBQUwsQ0FBZXpMLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBeEIsRUFBK0IsSUFBL0IsRUFBcUMsQ0FBckMsQ0FBZDtLQVROLEVBV2UsVUFBQTVCLENBQUMsRUFBSTtNQUNkaXdCLE9BQU8sQ0FBQ3RhLEdBQVIsQ0FBWTNWLENBQVo7S0FaTixFQTZCZXVMLElBQUksQ0FBQ0UsU0FBTCxDQUFlc3dILElBQWYsRUFBcUIsSUFBckIsRUFBMkIsQ0FBM0IsQ0E3QmYsRUE4QmlCLFVBQUEvN0gsQ0FBQyxFQUFJO01BQ2QsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDcjVILEtBQVgsR0FBbUIySixJQUFJLENBQUNpc0MsS0FBTCxDQUFXeDNDLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBcEIsQ0FBbkI7S0FoQ1I7RUFxQ0Q7OztFQ25GYyxzQkFBWTtJQUN6QixPQUFPbWYsQ0FBUCx3aURBVWUsVUFBQS9nQixDQUFDLEVBQUk7TUFDZCxJQUFNazdILE1BQU0sR0FBR3Y2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixtQkFBdkIsQ0FBZjtNQUNBc3pFLE1BQU0sQ0FBQ3Q1SCxLQUFQLEdBQWU1QixDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXhCO0tBWk4sRUE4QmdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixpQkFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBaENSLEVBMkNnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNzdFLE1BQVgsR0FBb0JwL0MsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE3QjtLQTdDUixFQXFEaUIsVUFBQTVCLENBQUMsRUFBSTtNQUNsQixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixpQkFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM1M0IsT0FBWCxHQUFxQnJqRyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTlCO0tBdkRKLEVBZ0VnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsaUJBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDNXhGLEtBQVgsR0FBbUJycEMsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUE1QjtLQWxFUixFQXdFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGlCQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzV4RixLQUFYLEdBQW1CcnBDLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBNUI7S0ExRVIsRUFnRmdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixpQkFBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM1eEYsS0FBWCxHQUFtQnJwQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBbEZSO0VBd0ZEOzs7RUN6RmMsbUJBQVk7SUFDekIsT0FBT21mLENBQVAsc2hDQVNlLFVBQUEvZ0IsQ0FBQyxFQUFJO01BQ2QsSUFBTWs3SCxNQUFNLEdBQUd2NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWY7TUFDQXN6RSxNQUFNLENBQUMzNEUsTUFBUCxHQUFnQnZpRCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQXpCO0tBWE4sRUE2QmdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQy83RSxLQUFYLEdBQW1CbC9DLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBNUI7S0EvQlIsRUEwQ2dCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzc3RSxNQUFYLEdBQW9CcC9DLENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBN0I7S0E1Q1IsRUFtRGlCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQzE0RSxNQUFYLEdBQW9CdmlELENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBN0I7S0FyRFI7RUEwREQ7O0VDN0RjLFNBQVN3NkgsYUFBVCxDQUF1QkMsU0FBdkIsRUFBa0NDLFVBQWxDLEVBQThDQyxTQUE5QyxFQUF5RG5WLFFBQXpELEVBQXlGO0lBQUEsSUFBdEJvVixTQUFzQix1RUFBVm5wSCxRQUFVO0lBQ3RHLElBQU03VCxJQUFJLEdBQUcsRUFBYjtJQUVBLElBQU1xNEcsS0FBSyxHQUFHLElBQUl6M0UsWUFBSixDQUFpQm04RixTQUFqQixDQUFkO0lBQ0EsSUFBTUUsS0FBSyxHQUFHRixTQUFTLEdBQUdELFVBQTFCOztJQUNBLElBQU1JLElBQUksR0FBRyxJQUFJbjlILElBQUksQ0FBQ285SCxFQUF0Qjs7SUFFQSxJQUFJQyxLQUFLLEdBQUdQLFNBQVMsR0FBR0MsVUFBeEI7SUFDQSxJQUFJTyxLQUFLLEdBQUcsQ0FBWjtJQUNBLElBQUlDLFNBQVMsR0FBRyxJQUFoQjtJQUNBLElBQUk5NEYsSUFBSSxHQUFHLENBQVg7SUFDQSxJQUFJbFosT0FBTyxHQUFHLENBQWQ7O0lBRUF0ckIsSUFBSSxDQUFDNjhILFNBQUwsR0FBaUIsVUFBQ0EsU0FBRCxFQUFlOztNQUU5Qk8sS0FBSyxHQUFHUCxTQUFTLEdBQUdDLFVBQXBCO0tBRkY7O0lBS0E5OEgsSUFBSSxDQUFDMGhCLEtBQUwsR0FBYSxZQUFNO01BQ2hCLFVBQVM2N0csV0FBVCxHQUF1QjtRQUN0QixLQUFLLElBQUkvMkgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3UySCxTQUFwQixFQUErQnYySCxDQUFDLEVBQWhDLEVBQW9DO1VBQ2xDLElBQU1wRSxLQUFLLEdBQUdyQyxJQUFJLENBQUN5OUgsR0FBTCxDQUFTSCxLQUFLLEdBQUdILElBQWpCLENBQWQ7VUFDQTdrQixLQUFLLENBQUM3eEcsQ0FBRCxDQUFMLEdBQVdwRSxLQUFYO1VBQ0FpN0gsS0FBSyxHQUFHLENBQUNBLEtBQUssR0FBR0QsS0FBVCxJQUFrQixDQUExQjs7O1FBR0Z4VixRQUFRLENBQUNwakYsSUFBRCxFQUFPNnpFLEtBQVAsQ0FBUjtRQUVBN3pFLElBQUksSUFBSXk0RixLQUFSO1FBQ0EzeEcsT0FBTyxJQUFJLENBQVg7O1FBRUEsSUFBSUEsT0FBTyxHQUFHMHhHLFNBQWQsRUFBeUI7VUFDdkJNLFNBQVMsR0FBRzl3RyxVQUFVLENBQUMrd0csV0FBRCxFQUFjTixLQUFLLEdBQUcsSUFBdEIsQ0FBdEI7O09BYkgsR0FBRDtLQURGOztJQW1CQWo5SCxJQUFJLENBQUN1ckMsSUFBTCxHQUFZLFlBQU07TUFDaEI0aUIsWUFBWSxDQUFDbXZFLFNBQUQsQ0FBWjtLQURGOztJQUlBLE9BQU90OUgsSUFBUDtFQUNEOzs7RUN2Q2MsbUJBQVk7O0lBRXpCd3NCLFVBQVUsQ0FBQyxZQUFNO01BQ2YsSUFBTWl4RyxPQUFPLEdBQUd0OEgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBaEI7TUFFQSxJQUFJbXFFLEtBQUssR0FBRyxJQUFaO01BQ0EsSUFBTW1MLEtBQUssR0FBR2QsYUFBYSxDQUFDLEdBQUQsRUFBTSxFQUFOLEVBQVUsQ0FBVixFQUFhLFVBQUNwNEYsSUFBRCxFQUFPaHZCLElBQVAsRUFBZ0I7UUFDdEQrOEcsS0FBSyxHQUFHO1VBQUUvdEYsSUFBRjtVQUFRaHZCLElBQUksRUFBRXpMLEtBQUssQ0FBQ3dXLElBQU4sQ0FBVy9LLElBQVg7U0FBdEI7T0FEeUIsQ0FBM0I7TUFJQSxJQUFNbW9ILEtBQUssR0FBR2YsYUFBYSxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsQ0FBUixFQUFXLFVBQUNwNEYsSUFBRCxFQUFPaHZCLElBQVAsRUFBZ0I7UUFDcEQrOEcsS0FBSyxDQUFDLzhHLElBQU4sQ0FBVyxDQUFYLElBQWdCQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsR0FBMUI7UUFDQWlvSCxPQUFPLENBQUNyN0gsS0FBUixHQUFnQm13SCxLQUFoQjtPQUZ5QixDQUEzQjtNQUtBbUwsS0FBSyxDQUFDaDhHLEtBQU47TUFDQWk4RyxLQUFLLENBQUNqOEcsS0FBTixHQWRlOzs7O0tBQVAsRUFvQlAsR0FwQk8sQ0FBVjtJQXNCQSxPQUFPSCxDQUFQLDAyREFpQmdCLFVBQUEvZ0IsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUMvN0UsS0FBWCxHQUFtQmwvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTVCO0tBbkJSLEVBOEJnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM3N0UsTUFBWCxHQUFvQnAvQyxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQTdCO0tBaENSLEVBMkNnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUNwekgsR0FBWCxHQUFpQjdILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBMUI7S0E3Q1IsRUF3RGdCLFVBQUE1QixDQUFDLEVBQUk7TUFDYixJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ2x6SCxHQUFYLEdBQWlCL0gsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUExQjtLQTFEUixFQXFFZ0IsVUFBQTVCLENBQUMsRUFBSTtNQUNiLElBQU1pN0gsVUFBVSxHQUFHdDZILFFBQVEsQ0FBQ2luRCxhQUFULENBQXVCLGNBQXZCLENBQW5CO01BQ0FxekUsVUFBVSxDQUFDalQsUUFBWCxHQUFzQmhvSCxDQUFDLENBQUM2L0MsTUFBRixDQUFTaitDLEtBQS9CO0tBdkVSLEVBa0ZnQixVQUFBNUIsQ0FBQyxFQUFJO01BQ2IsSUFBTWk3SCxVQUFVLEdBQUd0NkgsUUFBUSxDQUFDaW5ELGFBQVQsQ0FBdUIsY0FBdkIsQ0FBbkI7TUFDQXF6RSxVQUFVLENBQUM1SCxTQUFYLEdBQXVCcnpILENBQUMsQ0FBQzYvQyxNQUFGLENBQVNqK0MsS0FBaEM7S0FwRlIsRUEyRmlCLFVBQUE1QixDQUFDLEVBQUk7TUFDZCxJQUFNaTdILFVBQVUsR0FBR3Q2SCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixjQUF2QixDQUFuQjtNQUNBcXpFLFVBQVUsQ0FBQ3hKLGFBQVgsR0FBMkJ6eEgsQ0FBQyxDQUFDNi9DLE1BQUYsQ0FBU2orQyxLQUFwQztLQTdGUjtFQXVHRDs7O0VDdkZELElBQU13N0gsSUFBSSxHQUFHO0lBQ1gsV0FBV0MsSUFEQTtJQUVYLGFBQWFud0csTUFGRjtJQUdYLGFBQWExVyxNQUhGO0lBSVgsYUFBYThtSCxNQUpGO0lBS1gsYUFBYWhwRSxNQUxGO0lBTVgsV0FBV3RTLElBTkE7SUFPWCxnQkFBZ0J1N0UsU0FQTDtJQVFYLGFBQWF4MEYsTUFSRjtJQVNYLGFBQWF5MEYsTUFURjtJQVVYLGFBQWFDLE1BVkY7SUFXWCxjQUFjQyxNQVhIO0lBWVgsZ0JBQWdCQyxTQVpMO0lBYVgsbUJBQW1CQyxXQWJSO0lBY1gsYUFBYTVxRSxNQWRGO0lBZVgsZ0JBQWdCNnFFLFFBZkw7SUFnQlgsZ0JBQWdCTjtFQWhCTCxDQUFiOztFQW1CQSxTQUFTTyxRQUFULENBQWtCejVILElBQWxCLEVBQXdCO0lBQ3RCLFFBQVFBLElBQVI7TUFDRSxLQUFLLE9BQUw7UUFDRTFELFFBQVEsQ0FBQ285QyxJQUFULENBQWMwRyxTQUFkLENBQXdCM1UsTUFBeEIsQ0FBK0IsTUFBL0I7UUFDQW52QyxRQUFRLENBQUNvOUMsSUFBVCxDQUFjMEcsU0FBZCxDQUF3QjV4QixHQUF4QixDQUE0QixPQUE1QjtRQUNBOztNQUNGLEtBQUssTUFBTDtRQUNFbHlCLFFBQVEsQ0FBQ285QyxJQUFULENBQWMwRyxTQUFkLENBQXdCM1UsTUFBeEIsQ0FBK0IsT0FBL0I7UUFDQW52QyxRQUFRLENBQUNvOUMsSUFBVCxDQUFjMEcsU0FBZCxDQUF3QjV4QixHQUF4QixDQUE0QixNQUE1QjtRQUNBOztFQUVMOztFQUVEaXJHLFFBQVEsQ0FBQyxPQUFELENBQVI7QUFFQTl2RixHQUFNLENBQUNqdEIsQ0FBRCxxbUJBSzBDLFVBQUEvZ0IsQ0FBQztJQUFBLE9BQUk4OUgsUUFBUSxDQUFDLE1BQUQsQ0FBWjtFQUFBLENBTDNDLEVBTTJDLFVBQUE5OUgsQ0FBQztJQUFBLE9BQUk4OUgsUUFBUSxDQUFDLE9BQUQsQ0FBWjtFQUFBLENBTjVDLEVBUUE1OUgsTUFBTSxDQUFDMkksSUFBUCxDQUFZdTBILElBQVosRUFBa0I5NkcsR0FBbEIsQ0FBc0IsVUFBQWplLElBQUk7SUFBQSxPQUFJMGMsQ0FBSiw4R0FBcUIxYyxJQUFyQixFQUFrQ0EsSUFBbEM7RUFBQSxDQUExQixDQVJBLEVBa0JBbkUsTUFBTSxDQUFDMkksSUFBUCxDQUFZdTBILElBQVosRUFBa0I5NkcsR0FBbEIsQ0FBc0IsVUFBQWplLElBQUksRUFBSTtJQUM5QixPQUFPMGMsQ0FBUCx1UkFHc0IxYyxJQUh0QixFQUdtQ0EsSUFIbkMsRUFHa0RBLElBSGxELEVBR2lFQSxJQUhqRSxFQUlRKzRILElBQUksQ0FBQy80SCxJQUFELENBQUosRUFKUjtFQVFELENBVEMsQ0FsQkEsR0ErQkgxRCxRQUFRLENBQUNpbkQsYUFBVCxDQUF1QixZQUF2QixDQS9CRyxDQUFOOzs7OyJ9
